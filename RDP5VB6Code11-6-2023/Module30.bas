Attribute VB_Name = "Module1"
'option explicit
'Dataset Management variables ofr big infiles

Public ExcludedEventNumThresh As Long, NumExcludedEventNum As Long, ExcludedEventBPNum As Long, ConsensusStrat As Long, SigmoidX(2) As Double, LogisticRWeights() As Double, LogisticRMean() As Double, LogisticRSD() As Double, Resetload As Long, TempSeqInFileFlag As Long, BSMask() As Byte
Public RDP5MLFile As String, PermMemPoc As Long, ActualEventList() As Single, NumActualEvents As Long, StupidWrap As Byte, TotMCCycles As Long, TotMCCycles2 As Long
Public RDPInName As String, SSAppendFlag As Byte, SSInName As String, SSOutName As String, INTERACTFlag As Long, InteractList() As Long, InteractListLen As Long, RememberBreakpointNum As Long, StatsDump() As Single, SDNum As Long, StatsList() As Double, StatsDumpFlag As Byte
Public ChiInt() As Long, CombinedFileFlag As Long
Public oMCCorrection
Public StillLoadingFlag As Byte, LoopENum As Long, BPTime As Long, TreeTime As Long, FBD As Long
Public TotFGCT As Long
Public ActualFound As Byte, MissSecondGDP As Long, MissFirstGDP As Long, HitSecondGDP1 As Long, HitFirstGDP1 As Long, HitSecondGDP2 As Long, HitFirstGDP2 As Long
Public MissSecondRDP As Long, MissFirstRDP As Long, HitSecondRDP1 As Long, HitFirstRDP1 As Long, HitSecondRDP2 As Long, HitFirstRDP2 As Long
Public MissSecondRGDP As Long, MissFirstRGDP As Long
Public MissSecondFDP As Long, MissFirstSDP As Long, HitSecondFDP1 As Long, HitFirstSDP1 As Long, HitSecondFDP2 As Long, HitFirstSDP2 As Long
Public FPMissSecondGDP As Long, FPMissFirstGDP As Long, FPHitSecondGDP1 As Long, FPHitFirstGDP1 As Long, FPHitSecondGDP2 As Long, FPHitFirstGDP2 As Long
Public FPMissSecondRDP As Long, FPMissFirstRDP As Long, FPHitSecondRDP1 As Long, FPHitFirstRDP1 As Long, FPHitSecondRDP2 As Long, FPHitFirstRDP2 As Long
Public FPMissSecondRGDP As Long, FPMissFirstRGDP As Long
Public HitFirstRGDP00 As Long, HitSecondRGDP00 As Long, HitFirstRGDP10 As Long, HitSecondRGDP10 As Long, HitFirstRGDP01 As Long, HitSecondRGDP01 As Long, HitSecondRGDP11 As Long, HitFirstRGDP11 As Long, HitSecondRGDP12 As Long, HitFirstRGDP12 As Long, HitSecondRGDP21 As Long, HitFirstRGDP21 As Long, HitSecondRGDP22 As Long, HitFirstRGDP22 As Long
Public FPHitFirstRGDP00 As Long, FPHitSecondRGDP00 As Long, FPHitFirstRGDP10 As Long, FPHitSecondRGDP10 As Long, FPHitFirstRGDP01 As Long, FPHitSecondRGDP01 As Long, FPHitSecondRGDP11 As Long, FPHitFirstRGDP11 As Long, FPHitSecondRGDP12 As Long, FPHitFirstRGDP12 As Long, FPHitSecondRGDP21 As Long, FPHitFirstRGDP21 As Long, FPHitSecondRGDP22 As Long, FPHitFirstRGDP22 As Long
Public StoreLPV() As Double
Public FPMissSecondFDP As Long, FPMissFirstSDP As Long, FPHitSecondFDP1 As Long, FPHitFirstSDP1 As Long, FPHitSecondFDP2 As Long, FPHitFirstSDP2 As Long


Public NewOneFound As Byte, EarlyBale As Long, SBlockBakE() As Long, UseCompress As Byte, TAIX() As Integer, MaskThresh As Single, FirstAddSome As Long, SumEventCount() As Long, EventsInExcludedsBP() As Long, WhereIsExclude() As Long, GPaledCol() As Long, GOriginalCol() As Long, BlastTS As Long, CurSeedExtras, OSNPos() As Long, BusyWithExcludes As Long, FullOName() As String, DoneExcludes() As Long, DoExcludes As Byte, UCThresh As Double, FourQuaterColour As Long, ELLite() As Long, Excludetrace() As Long, DSP2Flag As Byte, BQPV As Double, OriginalPos() As Long, DontLoadExcludes As Long, LoadBusy As Long, MaxEListLen As Long, EventsInExcludeds() As Long, ExcludedEventNum As Long, EXoverList() As XOverDefine, ExcludeCoords() As Long, JumpInFlag As Byte, Skiploadflag As Long, DatasetNumber As Long, SeqnumCoords(), DistanceCoords(), PemvalidCoords(), PermDIffsCoords(), TreeDistanceCoords()
Public StrainSeqBak() As String, OriginalNameBak() As String, StraiNameBak() As String, NextnoBak As Long
Public Dataset() As Long, NumInDataset() As Long
Public TraceDatasetNo() As Long, BEVSS(1) As Single
Public FSSRDP() As Byte, FSSMC() As Byte, FSSGC() As Byte, CompressorRDP() As Byte, CompressSeq() As Byte
Public UPArrayDim1 As Long, UPArrayDimXFact As Single
Public ntCompareMatD() As Long, ntCompareMatV() As Long
Public TotASET As Long

'DefLng A-Z
'f1vs1scalefactor
'remember to editbin /largeaddressaware rdp4.exe
'PairwiseTripArray(255, 255, 255) As Byte, LookupYZ() As Long,
'Public SS255RDP(255, 3) As Byte, XDP255RDP(255, 3) As Byte, SS255GC(255, 3) As Byte, XDP255GC(255, 3) As Byte, SS255MC(255, 3) As Byte, XDP255MC(255, 3) As Byte, PairwiseTripArray3(42, 42, 42) As Byte, PairwiseTripArray(255, 255, 255) As Byte
Public MemPoc As Long, UBPermValid As Long, UBSubValid As Long, UBPermDiffs As Long, UBSubDiffs As Long, SMatInFileFlag As Long, UBSMat As Long, UBFMat As Long, UBFAMat As Long, UBSCMat As Long, UBSAMat As Long, UBFCMat As Long, FAMatSmall() As Single, SAMatSmall() As Single, FCMatSmall() As Single, SCMatSmall() As Single, FMatSmall() As Single, SMatSmall() As Single, F1P16LastTooltip(1) As Long, AncSeqESS() As Long, PosIndicatorP11(1) As Single, SaveForMrBayes As Byte, MLTreeSet() As String, DatasetName As String, MapBack() As Long, BPProbDistFlag As Long, BPProbDistSE As Long, BPProbDist() As Single, GTMass As Long, vbClearLine As String, GrabProbsFlag As Long
Public PermValidSmall() As Single, PermDiffsSmall() As Single, SubValidSmall() As Single, SubDiffsSmall() As Single
Public T4TransCount As Long, AcceptAllMnuFlag As Long, p7MouseMoveTime, TDHits As Long
Public P7MMactive As Long, SearchWholeDBFlag As Long, HTTPRequest As WinHttp.WinHttpRequest, HTTPRequest2 As WinHttp.WinHttpRequest
Public OKToResizeF1 As Long
Public CurWothwhilePos As Long
Public LastF1P7X As Long, LastF1P7Y As Long, MaRec As Long, MiRec As Long, F2C8Press As Long, DoingShellFlag As Long, RF1Count As Long, DebuggingFlag As Long, JustOpened As Long, SDisplaySeq() As Long, FlashntX1 As Long, FlashntX2 As Long, OnlyDoFlash As Long, AccountREcombFlag As Long, OverlapList() As Long, GenesWithOverlaps() As Long
Public FormColour As Long, tPic As StdPicture, tDib As New cDibSection, gPic As StdPicture, gDib As New cDibSection, sPic As StdPicture, cDib As New cDibSection, hdcHolder As Long
Public P1MDStart As Long, AllowDoEvensFlag As Long, BPFlashed As Long, AvGCContent() As Single, MinGCContent As Single, MaxGCContent As Single, GCContent() As Single, DonGCContentFlag As Long
Public MCMSN As Byte, DistanceInFileFlag As Byte, UBDistance As Long, DontSaveUndo As Long, LatestSlot As Long, MaxUndos As Long, UndoCycle As Long, UndoSlot As Long, LastCurgene As Long, MostCommonnt() As Byte, FirstFlash As Long, HScroll1Hits As Variant, LastSEFlag As Long, STENFlash() As Long, GeneSEPos() As Long, LastntNum As Long, CallHS1 As Long, LastP1Time As Long, LastP1X As Long, LastP1Y As Long, P1MMStillGoing As Long, DontFade As Long, FlashntNum As Long, Flashnt() As Long, PermPlantCount As Long, PermPlantNum() As Long, FullSCreenWidth As Long, RefChimaera() As Long, ChimaeraNum As Long, ParentSeqs() As Long, ChimaeraSeqs() As Long, Chimaeraflag As Byte, V4Adj As Single, RefetchGB As String, AbortflagGB As Long, XLenPerColumn As Single, PrintStartY As Long, SubPrintlen As Long, LastPrintSeqLen As Long, LastLeftPos As Long, TopPosY As Long, BottomPosY As Long, LastTop As Long, LastBottom As Long, SeqText2 As String
Public DSDFlag As Long, ttyfAdjust As Single, SeqSpacePos1 As Long, SeqSpacePos2 As Long, SeqSpaceIncrement As Long, LastVScroll3Value As Long, SeqColCatNum As Long, ColX() As Long, AVTaj() As Single, AvBKG() As Single, DoneBKgFlag As Long, GenBankFetchStep3 As Long, DoneTajDflag As Long, IDDisplayMode As Long, CurGeneNo As Long, MaxTajD As Single, MinTajD As Single, TajD() As Single, ModSeqNumFlag As Long, DownloadedGBFiles As String, FatGeneFlag As Long, PositionIndicaterOn As Byte, OnlyDoPositionIndicator As Byte, Curgene As Long
Public GeneSEFlash As Long, OnlyDoPosBar As Byte, ColBump() As Long, SeqFeatureTrace() As Long, SEPosMap() As Long, SeqFeatureMap() As Long, LastSegment() As Long, GeneLabel() As Long, CurSegment As Long, RemoveSegment() As Long, DoneSegment() As Long, GenBankFetchStep2 As Long, MaxBkgIDPos As Long, Inet1State As Long, F5T1Executing As Long, StartFetch As Long, LastGeneNo As Long, DontPutForm2Ontop As Byte, Form2OnTopFlag As Byte, ORFRefList() As Long, ORFRefNum As Long, SilentGBFlag As Long, RID As String, GenBankFetchStep As Long, MakeConsFlag As Byte, DDF5C As Byte, F1VS1ScaleFactor As Single, UBCD2 As Long, ColDist2() As Integer, ColPos2() As Long, SeqColRef2() As Byte, ProbEstimateInFileFlag As Long, BestRescanFlag As Byte, BestRescanP As Double, OverrideGCCompare As Byte, TestDist() As Single, TestTreeDist() As Single, OverrideModSeqNum As Long, F2P2LastTooltip(1) As Long, MinDist As Single, MinTDist As Single, IntervalD As Single, IntervalTD As Single, AdjustD As Single, AdjustTD As Single
Public VRandOnFileFlag As Long, VRandUB1 As Long, VRandUB2 As Long
Public DontPrintNames As Byte, PermSelectNode(4) As Long, XFlashbound As Long, YFlashBound(1) As Long, BranchFlashFlag As Long, TreeDrawColBakFlag() As Long, TreeDrawColBak() As Long, P3Seq2Pos As Long, MaxONameLen As Integer, ONameLen() As Integer, TreeDrawB() As Single, GTCSNum() As Long, PHIWin As Long, F5T2Executing As Long, F5T3Executing As Long, xPHIWin As Long, OKPress As Byte, xCurSCale As Long, oF1T3E As Boolean, oF1T3I As Long, MatrixTB() As Byte, VarPosTB() As Long, PhiTestPVal As Double, F2ResizeFlag As Long, WinBusyGrowing As Byte, PHIWarn As Long, PairsScores(65536) As Byte, SmallF2LabelFlag As Byte, YannWarn() As Byte, ActualFName As String, MaxRequiredFraglen As Long, CurrentTripListNum As Long, SwapAround() As Byte, FlatDiff(85, 85) As Byte, FlatValid(85, 85) As Byte, GlobalTimer As Long, ExeCountD As Long, FastestFlag As Long, MissedScans As Long, Unmissedscans As Long, Worthwhilescan() As Byte, ProgBinWrite(255) As Byte, ProgBinRead(30, 255) As Byte, S1S2() As Long, S2S3() As Long

Public AbortGBFetch3 As Byte, AbortGBFetch As Byte, NUCO As Long, GroupSize As Long, BinArray3() As Byte, BinArray4() As Byte, BinArray5() As Byte, SS63RDP(63, 3) As Byte, XDP63RDP(63, 3) As Byte, DontWorryAboutSplitsFlag As Byte, DontRedrawPlotsFlag As Byte, MinPAGlobal As Double
Public BinConverter3() As Byte, BinConverter4() As Byte, SSChoice(18) As Long, BinArray2() As Byte, XDP2() As Long, XDP3() As Long, XDP4() As Long, XPD2() As Long, XPD3() As Long, XPD4() As Long, XSN2() As Byte, XSN3() As Byte, XSN4() As Byte, ExeCountA As Long, ExecountB As Long, BinArray() As Byte, MaxABWin As Long, ChiTableSize As Long, ChiTable2() As Single, ChiTable3() As Single, Chimap() As Long, DeleteArray() As Long, SkipTrip() As Byte, SeqCompressor3(4, 4, 4) As Integer, IntegerSeq3() As Long, CompressedSeqs3() As Byte, FindSS0() As Long, FindSS1() As Long, FindSS2() As Long, UBFact3x3 As Long, Fact3X3() As Double, BreaksExist() As Byte, Fact2() As Long, ProbEstimate() As Double
Public Timer1SS As Long, lP7XP As Long, F2P2Index As Long, F2P2Seq As Long, F1P26PX As Long, F1P26PY As Long, F1P26X As Long, F1P26Y As Long, F1P16Y As Long, F2P3Y As Long, F1P6Y As Long, F1P2Y As Long, F1P3Y As Long, F1P7X As Long, F2P2Y As Long, GVSS() As Single, GLVS As Long, MainSeed As Long, VXPos() As Long, AllowExtraSeqsFlag As Byte, DontDoH1Inc As Long, F1P1X As Long, F1P1Y As Long, P1Seq As Long, P1NT As Long, XDiffPosCA() As Long, CycleCounterA As Long, P7ZoomLevel As Long, oP7XP As Long, p7WinSize As Long, p7CurWinSize As Long, CurveArray() As Single, P7XP As Long, QvRRejectFlag As Byte, RedoRefNamesFlag As Byte, RefGroupName() As String, QvRShowOnlyFlag As Byte, TempMaskseq() As Byte, QvRAutoAssignableFlag As Byte, QvRScanGoonFlag As Byte, QvRFlagOverrideFlag As Byte, QvRSelectFlag As Byte, RefNum As Long, RCyc As Integer, UFTag As String, UseALFlag As Byte, ReferenceCols() As Long, ReferenceList() As Integer, QvRFlag As Byte, PrintCharLenFlag, PrintCharLen() As Integer, F1BusyResizing As Byte
Public TempTreeDistanceDumpFlag As Byte, UBTD1 As Long, WN1 As Long, WN2 As Long, WN3 As Long, WNStr(3) As String, XDiffPosC() As Long, GDPCFlag As Byte, GPVTNum As Long, GPVTFont() As Single, GPVText() As String, MaxVGC As Single, FakeP7() As Single, OnlyNamesFlag As Long, PersistantP2tTYF As Single, PersistantP2TYFM As Integer, MassMarkFlag As Byte, ModNextnoFlag As Byte, SchemDownFlag As Byte, StrainSeqOnDisk As Byte, UBTreeMatrix As Long, TreeMatrixInFileFLag As Byte, XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long, TreeXUB As Long, TreeXInFileFlag As Long, UBuTDist As Long, UBuDist As Long, uDistanceInFIleFlag As Single, P7W As Long, P7H As Long, RDPLGBFlag As Byte, DontUpdateVS1ValFlag As Byte, DontRedoQuickDistFlag As Byte, UpdateIDFlag As Byte, HSCrollInc As Long, sHSCroll1Down As Long, eHSCroll1Down As Long
Public BigFileFlag As Byte, DontDoScansFlag As Byte
Public ButtonScrollFlag As Byte, Segbound() As Byte, LiteFlag As Byte, P6Width As Long, HVScrollflag As Byte, ActualMidPixelV As Single, ActualMidPixelH As Single, DoMatrixWhileResizing As Byte, Rffflag As Byte, DoMLAncsFlag As Byte, TotGapCharCount As Long, ScDME As Long, ScDMB As Long, ModSNE As Long, ModSNB As Long, SeqMnuFlag As Byte, RCAllFlag As Long, ColHL As Long
Public P2KC As Long, UBPermValX As Long, CompressValid11(1024, 1024) As Byte, CompressDiffs11(1024, 1024) As Byte
Public CompressValid02(1024, 1024) As Byte, CompressDiffs02(1024, 1024) As Byte
Public CompressValid12(729, 729) As Byte, CompressDiffs12(729, 729) As Byte
Public CompressValid03(729, 729) As Byte, CompressDiffs03(729, 729) As Byte
Public CompressValid13(1024, 1024) As Byte, CompressDiffs13(1024, 1024) As Byte
Public CompressValid04(1024, 1024) As Byte, CompressDiffs04(1024, 1024) As Byte
Public CompressValid14(625, 625) As Byte, CompressDiffs14(625, 625) As Byte
Public CompressRDP(125)
Public SeqCompressor11(1, 1, 1, 1, 1, 1, 1, 1, 1, 1) As Integer, SeqCompressor02(1, 1, 1, 1, 1, 1, 1, 1, 1, 1) As Integer
Public SeqCompressor03(2, 2, 2, 2, 2, 2) As Integer, SeqCompressor12(2, 2, 2, 2, 2, 2) As Integer
Public SeqCompressor13(3, 3, 3, 3, 3) As Integer, SeqCompressor04(3, 3, 3, 3, 3) As Integer
Public SeqCompressor14(4, 4, 4, 4) As Integer

Public uSeqNuminFile As Byte, UBuMD2 As Long, UBuSN2 As Long, DontResetFocus As Byte
Public VS4Max2 As Long, VS4CV As Long, VS4Scrolling, P16BaseFontSize As Single, DontDoHS1Change As Byte, SeqSpacesInFileFlag As Byte, ColDistInFile As Byte, PermSeqNumInFile As Byte, FubValidInFile As Byte, FVL As Long
Public MaxAnalNo As Long, P2CurE As Long, OVS As Integer, P2PD As Integer, P2Method As Integer, TripListSaveCO As Long, TripListLenSeq() As Long, ISeq4P() As Integer, Analysislist() As Integer, TripList() As Integer, TripListLen As Long, VS4Max, OverviewSeq As Long, RIMode As Byte, CValCycle As Byte, SBExtras As Long, SBlockBak() As Long, SeqFL As Long, FlashColour() As Long, Pic7GoonFlag As Byte, Pic7BBFlag As Byte, Pic7EBFlag As Byte, FlashX1 As Long, FlashX2 As Long, FlashBeginBreakFlag As Byte, FlashEndBreakFlag As Byte, BeginFlashval As Long, EndFlashval As Long
Public ItsFinished As Byte, AllCheckFlag As Byte, BestParentP As Double, BestParent As Long, CheckParent As Long, WinMethod As Long
Public F2ZO As Byte, MnuClickFlag As Byte, SelectedSeqNumber As Long, NoTypeSeqFlag As Byte, btMissingData() As Byte, MapBlocks() As Single, MapBlockNum() As Long, ShowMapsFlag As Byte, Identical2() As Byte, ISPerm(2) As Long, IdenticalR() As Long, IdenticalF() As Long, MatZoomMod(20) As Long, P26MD As Long, P26MDX As Single, P26MDY As Single, opxv As Long, opyv As Long, TestPress As Long, LowMemThreshold As Long, ButtonRepress As Long, NumSeq() As Byte, ConvNumSeq(255) As Byte
Public MiddlePos(10, 10) As Long, F2VSScaleFactor(3) As Double, DontChangeVScrollFlag As Byte
Public ADT As Byte, RedoDist() As Integer, ISeq4() As Integer, ISeq3() As Integer, StoreChanged() As Byte, StillCycling As Long, LastOY As Long, PFName As String, BigFileOffsets() As Long, RBPPos() As Long, RBPNum As Long, ReassortmentFlag As Byte, TRelX As Long, TRelY As Long, RRelX As Long, RRelY As Long, LTmpSeq As Long, PAncPVals() As Double, ReMapF() As Long, ReMapR() As Long, RNDSEED As Long, NUMXY As Long, SafePath As String, BPCIs() As Long, BusyWithTreeFlag As Byte, PseudoFlag As Byte, FastNJFlag As Byte, ARFlag As Byte, VSC1NC As Byte, RedoIntegrateXOversFlag As Byte, LastH1Val As Long, LastH1Dir As Byte, H1M As Long, H1C As Long, SeqSpacesTempFlag As Byte, LastPermXVal As Long, LastPermYVal As Long, PermFlashY As Single, ConservativeGroup As Long, F1VS2Adj As Double, ReassignPFlag As Byte, ClickedInTreeFlag As Byte, NumEventsAboveCO As Long, AutoMultFlag As Long, ClusteringResult As String, MaxTemperature As Single, ontType As Byte, ntType As Byte, p1TTYF As Double, ProgcolourB() As Long
Public RememberBPs() As Long, NumberBPs As Long, CTNames() As String, CTNumlines As Long, CTBlocks() As Long, CTBlockNum As Long, CTText() As String, CTTextNum As Long
Public LastV2Val As Long, CompressValid4(625, 625) As Byte, CompressDiffs4(625, 625) As Byte, SeqCompressor4(4, 4, 4, 4) As Integer, EditSeqFlag As Byte, CompressValid3() As Byte, CompressDiffs3() As Byte
Public FubValid() As Single

Public PropSynMuts(4, 4, 4) As Single, LoadFileOnStartUpFlag As Byte, SSP6Fract As Double, SSP4Fract As Double, P6OSize As Long, P6HSF As Double, F1RF As Long, LastF1Width As Long, LastF1Height As Long, TaskBarHeight As Long, XConA As Double, YConA As Double, P1FontSize As Double, NextnoSubtract As Long, PermXP As Long, PermYP As Long, F7Flag As Byte, PDBFileName() As String, PDBFileNumber As Long, LKString As String, SeqSpacesTemp() As Long, xSHWinLen As Long, SHWinLen As Long, xSHStep As Long, SHStep As Long, SHTree As Byte, SHTModel As Byte, SHTRndSeed As Long, SHOptMethod As Byte, SHOrAUFlag As Byte

Public SeqCoverage() As Single
Public NodeFindZ() As Byte, NodeXYZ() As Long, NodeMaxRep() As Single, MultBPFlag As Byte, BIGFilename As String, TempNHF As String, BigTreeNHU As String, BigTreeNH As String, BTSeq1 As Long, BTSeq2 As Long, BTSeq3 As Long, ProxButton As Integer, ProxShift As Integer, ProxX As Single, ProxY As Single
'Picture6_MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
'-f 4 -nordpfile -nocsvfile -hotspot

Public AncDis As Long, MidPosRDP As Long, IXOFlag As Byte, F2ontop As Byte, WSize As Long, IDCO As Double, CSVFlag As Byte
Public PADRETraceEventU() As Long, PADRETraceU() As Long, PADRENameU() As String, PADRENextnoU As Long
Public BigTreeTraceEventU() As Long, BigTreeTraceU() As Long, BigTreeNameU() As String, BigTreeNextnoU As Long, BigTreeTraceEvent() As Long, BigTreeTrace() As Long, BigTreeName() As String, BigTreeNextno As Long, SNodePathX() As Integer, RAxMLCats As Long, TreeTestStats() As Double, DontChangeAnything As Byte, TopolTests(3, 8) As Double, NHComp(1) As String, xBStreeStrat As Byte, xBSupTest As Integer, BSTreeStrat As Byte, BSupTest As Integer, MeanE() As Double, MeanM() As Double, LowerThanRealM() As Double, LowerThanReal() As Double, NOC() As Long, FlashY As Double, FlashCol As Long, Parts() As Long, PartNo As Long, OriginalName() As String, PDBtoAlign() As Long, Form4OWidth As Long, Form4OHeight As Long, Recompress() As Long, Decompress() As Long, ABCons() As Byte, CurrentlyRunningFlag As Byte, RefSpaces() As Long, SHAPECO As Double, SCHEMAPermNo As Long, NumEScores() As Long, SCHEMAMScores() As Long, SCHEMAEScores() As Long, RealEScores() As Long, RealMScores() As Long, PermContactMapT() As Long
Public MaxaaLen As Long, MartString() As String, MartVertex() As Single, MartEdge() As Single, APhys As Variant, F1MO As Byte, SHAPEFlag As Byte, SHAPEScores() As Single, MultCoords() As Long, MultFNum As Long, MultFN() As String, dMax() As Single, LargeSeqFlag As Long, SSFoldFile As String, AcceptChangeFlag As Byte, HSCord() As Double, HSNum As Long, VScoreMat() As Single, NucMat() As Byte, xVisRDWin As Long, VisRDWin As Long, PrintPoints() As Single, VisRDOccupancyStat() As Single, ExRecFlag As Byte, ScrollSF As Double, MLAncSeq As String, ParsAncSeq As String, ParsAncSeqG As String, SumAncSeq As String, AncPVals() As Double, LastAncSeqFlag As Byte, AncSeqFlag As Byte, SelectNode(10) As Long, NodeXY() As Long, xModelTestFlag As Byte, ModelTestFlag As Byte, MaxRepeatCycles As Long, RepeatCycles() As Long, GeneNumber As Long, FlashArray() As Long, BusyFlashing() As Byte, P3OH As Long, P1OH As Long, SeqLines() As Long, NumSeqLines As Long, SeqText() As String, NumSeqText As Long
Public AncPValsML() As Double, AncPValsBayes() As Double, AncPValsPars() As Double
Public TBNGens As Long, TBNChains As Long, TBSampFreq As Long, TBTemp As Double, TBSwapFreq As Long, TBSwapNum As Long, TBModel As Byte, xTBModel As Byte, xTBGamma As Byte, TBGamma As Byte, TBGammaCats As Long, DontLoseSeqsFlag As Byte
Public TPTVRat As Double, TPGamma As Long, TPAlpha As Double, TPInvSites As Double, TPModel As Byte, xTPModel As Byte, TPBPFEstimate As Byte, xTPBPFEstimate As Byte
Public XoverSeqNumTS() As Long, XTableFlag As Byte, TPL As Long, TPL2 As Long, XTable() As Single, YTable() As Single, DontRefreshP1 As Byte, DontRefreshFlag As Byte, SqrA() As Double, F1MDF As Byte, F1LXY(1) As Long, F1Hotspot(3) As Long, OptButtonF As Byte, NoF3Check2 As Byte, PFlashed As Byte, SuspendFlash As Byte, CurFlash As Byte, APos() As Long, SAbortFlag As Byte
'LDHAT variables
Public UpdateProgressBar As Long, DontDoTimer1Flag As Byte, DontDoTimer4Flag As Byte, xBlockPen As Long, xStartRho As Double, xMCMCUpdates As Long, xFreqCo As Double, xFreqCoMD As Double, xGCFlag As Byte, xGCTractLen As Long, BlockPen As Long, StartRho As Double, MCMCUpdates As Long, FreqCo As Double, FreqCoMD As Double, GCFlag As Byte, GCTractLen As Long

Public BRunning As Byte, VarRho(10) As Double, NoF3Check As Byte, TBench(100) As Double, DoScans(1, 100) As Byte, pDoScans(1, 100) As Byte, xAllowConflict, xPermTypeFlag, PermTypeFlag As Byte, AllowConflict As Byte, AgeEvent() As Double, S2TraceBack() As Long
Public GYAxHi(1) As Double, GDistM(1) As Double, GPValM(1) As Double, GExtraTNum As Long, GExtraText() As String, GBlockNum As Long, GBlock() As Long, GCritval() As Double, GLegend As String, GVarPos() As Long, GPrintMin(1) As Single, GPrintLen As Long, GPrintType As Byte, GPrint() As Single, GPrintNum As Long, GPrintCol() As Long, GPrintPos() As Long, xLRDWin As Byte, xLRDRegion As Byte, LRDWin As Byte, LRDWinLen As Long, FirstPass As Byte, BPCoord(1) As Double, exRelX As Long, exRely As Long, NewBP(1) As Long, ExpectFL As Long, StartProgress As Integer, EndProgress As Integer, DontClick As Byte, Timercheck(1) As Long, ABFl(100) As Byte, TotSignals(255) As Long, TotUSignals(255) As Long, MName As String, VRFlag As Byte, Mat567Len As Long, HorstFlag As Byte, DontDoKey As Byte, VarsitesMC() As Long, VarsitesCM() As Long, VarsitesLD() As Long, DoVS5 As Byte, MatZoom(20) As Double, MatCoord(20, 1) As Long, DoneMatX(20) As Byte, CurScale As Byte, MatBound(20) As Double
Public TypeSeqNumber As Long, xMatPermNo As Long, MatPermNo As Long, MatWinSize As Long, xMatWinSize As Long, CompatMatIJ() As Byte

Public MatrixL() As Single, MatrixMC() As Single, MatrixC() As Byte, MatrixBP() As Single, MatrixLD() As Single, MatrixRMin() As Single, MatrixRMinD() As Single, MatrixRRP() As Single, MatrixRR() As Single, MatrixR() As Single, MatrixM() As Single, SHMatrixX() As Single, MatrixRF() As Single, MatrixSH() As Single

Public KPFlag As Byte, MethodTime(20) As Double, TimeFract(20) As Double, CurMatrixFlag As Byte, DoneColFlag As Byte, BestEStore() As Long, aaConv() As Byte, AASeq() As Byte, CurGenes As Long
Public HeatMap(8, 1024) As Long
Public TopBoot As Long, OldBoot As Long
Public TargetFileSize As Long, FullSize As Long
Public uDaught() As Byte, uSeqNum() As Byte, uMissingData() As Byte, uTreeTrace() As Long, uNextno As Long, uTreeDistance() As Single, uSeqCol() As Long, uFFillCol() As Long, uDistance() As Single, uOriginalName() As String
Public SelGrpFlag As Byte, GrpMaskSeq() As Byte

Public SPSPos As Long, PermSPos As Long
Public CIndex As Byte, F2P2SNum As Long, PValMap() As Single, AvHomol(3) As Double
Public Fact() As Double, BinTable() As Double
Public DoQuick As Byte
Public Udst As Double, AddTimes As Long, SchemBlocks() As Long, SBlocksLen As Long, SchemString() As Long, SStringLen As Long
Public DoneTree() As Byte, TBS(20) As String, TreeXScaleMod() As Double, TreeBlocksL() As Long, TBLLen As Long, TreeBlocks() As Long, TBLen() As Long, TreeDraw() As Single, TDLen(3, 4, 2) As Long, O31FS As Double, SSOLoSeq As Long, TYF As Double, TYF2 As Double
Public BPCVal() As Double, BPCvalFlag As Byte, tRecSeqX As Long, PermUDst As Double, PermAvDst As Double, PermsCurrentXOver() As Integer, ForcePhylE As Byte, BPListHolder() As Double
Public MCMaxY As Long, DScores() As Double, FCMat() As Single, SCMat() As Single, TarSeq As Long, OSEPAVal As Long, testpa() As Double, NOPINI() As Long
Public TestName(25) As String
Public BestXOListMa() As XOverDefine, BestXOListMi() As XOverDefine, BCurrentXoverMa() As Integer, BCurrentXoverMi() As Integer

Public ISInvolved() As Long, P13BPFC(1) As Long, StepSEn() As Long, StepNextNo As Long
Public ExtraD() As Long, ExtraHits() As Byte, ExtraHitsMa() As Byte, ExtraHitsMi() As Byte, PermSeq1 As Long, PermSeq2 As Long, PermSeq3 As Long, TreeTraceSeqs() As Long, PermNextno As Long, PermOriginalName() As String, TreeFMat() As Single, TreeSMat() As Single, TreeTrace() As Long, TreeSeqNum() As Integer, TreeNextno As Long, TreeStrainName() As String, TreeMatrix() As Single
Public oNextno As Long, PermSeqNum() As Integer, Steps() As Long, StepNo As Long
Public PN As Byte, PNPos() As Byte, MaxXOP() As Double, RedoList() As Long, RedoListSize As Long, DonePVCO() As Double
Public BanWin() As Long, MDMap() As Byte
Public oTotRec As Long, MissingData() As Byte
Public TargetX As Long, XoverWindow As Long, LenStrainSeq As Long, NumRecsI() As Long, ColTotals() As Single, ttt, LongSeqNum() As Long, ValidList() As Long, CountList() As Long
Public DistMod() As Double, MinSeqSize As Long, CHEvFlag As Long
Public FMat() As Single, SMat() As Single, FAMat() As Single, SAMat() As Single
Public CritPVals() As Double, CPermNo As Long, GPerms As Long, GRndSeed As Long, BestPermP() As Double, APermFlag As Byte

Public SuperEvent(), SEventNumber As Long, NumInE As Long
Public SubValid() As Single, SubDiffs() As Single, PermDIffs() As Single, PermValid() As Single, tPermDiffs() As Long, tPermValid() As Long
Public EventTrace() As Long
Public SuperEventList() As Long ',SimSeqNum() As Integer
Public BackUpNextno As Long, LongFlag As Byte, EventSeq() As Integer, LongWindedFlag As Byte, SERecSeq As Long, SEPAVal As Long

''option explicit
Public ShowAllHits() As Byte, GetRidOf(3) As Long, ENumbs As Long, oRecombNo() As Long, RecombNo() As Long, PermDist() As Single, ThirdFlag As Byte, EvN As Long, mtP() As Double, mtEv() As Double
Public RecMap() As Double, BestEvent() As Long, Eventnumber As Long
Public MaxEn() As Long, MinS() As Long, Daught() As Byte, MinorPar() As Byte, MajorPar() As Byte
Public Confirm() As Integer, ConfirmP() As Double, ConfirmMi() As Integer, ConfirmPMi() As Double, ConfirmMa() As Integer, ConfirmPMa() As Double
Public AncSeqS() As String, UnionC(85, 85) As Byte
Public BranchMapX() As Long

'Manual Distanceplot
Public SelectGroups() As Long, DSeqs() As Byte, CSelect As Long

'Phylpro variable
Public pPPNumSeqs As Long, MRV As Double, MaRV As Double, PPXOSeq() As String, PPWinScore() As Double, TotalPPRecombinants As Long, PPWinLen As Long, pPPWinLen As Long, xPPWinLen As Long, PPStripGaps As Long, pPPStripGaps As Long, pIncSelf As Byte, IncSelf As Byte, xPPStripGaps As Long, xIncSelf As Byte, PPPerms As Long, PPSeed As Long

Public togglex As Byte, XL As String, TW As Long

'Make International
Public TmpD As Double

Public ShortOutput() As Byte, DatasetNo As Long

'Ancestral Sequences
Public AncDstMat() As Single, AncSeq() As Integer, BranchMap() As Long, MRCAMat() As Long, ConDeg() As Double

'Plot display during scan
Public StartPlt() As Byte, PDistPlt() As Single, ProbPlt() As Single, HitPlt() As Long, RedoPltL(2) As Byte

'Recombination matrix
Public RecombMatrix() As Double

'Phylip Test Variables
Public DstMat() As Single
'Benchmark Setting
Public BMark As Long

'GUI settings
Public P12X As Long, P12Y As Long, OldAbort As Integer, oScreenHeight As Long, oScreenWidth As Long, TwipPerPix As Integer, oTwipPerPixX As Integer, oTwipPerPixY As Integer, OptionsFlag As Integer
Public BkR As Byte, BkG As Byte, BkB As Byte
Public HAddjust As Double, VAddjust As Double
Public HalfColour As Long, QuaterColour As Long, ThreeQuaterColour As Long, RedBorder As Long, Rejected As Long, FillColour As Long, Form1OHeight As Long, Form1OWidth As Long, Form2OHeight As Long, Form2OWidth As Long

'Permanant settings for save files
Public pLDHatFlag As Integer

'Variables for managing compatibility matrices
Public MaxLim As Long

'Variables for managing display during scan
Public ScanFlagX As Integer, RowSpace As Integer
Public PHMax As Double, PPMax As Double, oDMax As Single, oPMax As Single, AvDst As Double, PerMaxPval As Double, Hitnumber() As Long, MaxHits As Long

'Manual Scan settings
Public RevSeq() As Integer, Selected() As Integer, UYPos() As Integer, SYPos() As Integer
Public OIndex As Long, OManFlag As Integer, TopDistFlag As Integer, ManPFlag As Integer, TManFlag As Integer, ManFlag As Integer, ManMinSeqNo As Integer, ManMaxSeqNo As Integer

'Variables for managing the schematic sequence display
Public GEvents() As Long, MenuUpFlag As Integer, HighlightFlag As Integer
Public ProgNames(10) As String, TimerVal As Integer, ProgF() As Integer, PermArray() As Integer
Public PermYVal2 As Single, PermXVal As Single, PermYVal As Single, OutsideFlagX As Integer, InlyerA As Integer, InlyerB As Integer, SchemFlag As Integer, yPicRef As Long, AddNum As Integer, PRecSeq As Long, RecSeq As Long
Public FFillCol() As Long, SeqCol() As Long
Public AXONoY As Long, AXONo As Long, P2DHeight As Long, PPAVal As Long, PAVal As Long, OPAVal As Long

Public NewDirName As String
Public SpaceAdjust As Double, AdjArrayPos As Double, XPicAddjust As Double, MaxLogPValSch As Double, MinLogPValSch As Double, MaxDistSch As Single, MinDistSch As Single

'Variables for managing the sequence display
Public GTCS As Long, ltPosX As Integer, ltPosY As Integer, HScroll1Mod As Integer, ShowSeqFlag As Integer, PrintSeqLen As Integer
Public Identical() As Byte, IDCount() As Integer
Public SiteIdentity() As Long, MoveSeq As Double, P3MouseDown As Integer, WinLeft As Long, DontDoComboFlag As Integer, SubMaskSeq() As Integer, GCIDCount() As Integer, MCIDCount() As Integer, GCXDiffPos() As Long, GCXPosDiff() As Long
Public LastY3 As Long, YStrain As Long, WinCount As Long
Public Output() As String, GCXOverSeq() As String, MCXoverSeq() As String
Public GapChar As String
Public GCIdentical() As Byte, MCIdentical() As Byte

'Variables for managing the plot display
Public APlot As Long, P7PixCol As Long, PicHeight As Integer, Pic7PointerVal As Integer, CopyFlag As Integer, OptFlag As Integer, ExeCheckFlag As Integer, Over7Flag As Integer
Public RefCol() As Long, PltPos() As Long
Public PltVal() As Double, MCPrintData() As Single, MCPrintPos() As Double
Public XFactor As Double, MinPx As Double, MaDistance As Double, MiDistance As Double

'Variables for managing tree display(s)
Public ETSeqNum() As Integer, TSeqLen As Long, TreeSeqMap() As Long, CurTree() As Integer, XCord() As Integer, YCord() As Long, RYCord() As Long, TTFlag() As Integer, NodeYPos() As Integer, TreeX() As Integer, TreeY() As Integer, TreeImage(3) As Integer, NewNo() As Integer, ColourSeq() As Integer, TreeRX() As Integer, TreeRY() As Integer
Public TreeTypeFlag As Integer, CTF As Integer, TRegion As Integer, Outie As Long, LChange As Integer, Pic2MD As Integer, PartFlag As Integer, NJDrawFlag As Integer, F2TreeIndex As Integer, TreeDistFlag As Integer
Public TempSeq() As String, NHString() As String
Public MultColour() As Long
Public TreeRLen() As Long, BTree As Long, ETree As Long, SelCol As Long, BeginMark As Long, EndMark As Long, NextnoB As Long
Public TreeDistance() As Single, NodeLength() As Double

Public TBSReps As Integer, TRndSeed As Long, TTVRat As Double, TModel As Integer, TCoeffVar As Double, TBaseFreqFlag As Integer, TAfreq As Double, TCFreq As Double, TGFreq As Double, TTFreq As Double, TPower As Double, TNegBLFlag As Integer, TSubRepsFlag As Integer, TGRFlag As Integer, TRndIOrderFlag As Integer
Public xTModel As Integer, xTBaseFreqFlag As Integer, xTNegBLFlag As Integer, xTSubRepsFlag As Integer, xTGRFlag As Integer, xTRndIOrderFlag As Integer
Public OSS2 As Boolean, OSS8 As Boolean, OSS5 As Boolean, OP3 As Boolean, OP5 As Boolean, OP16 As Boolean
Public SDLen() As Integer, SSeqXPos() As Single, SSeqYPos() As Double, SNodeXPos() As Single, SNodeYPos() As Double, SNodepath() As Integer

'Variables for managing the recombination info window
Public RecSeqX As Long, PAValX As Long, P2YVal As Long, HLFlag As Long

'Variables for managing shelled apps
Public PBStart As Integer, PBTarget As Integer, BatIndex As Integer
Public scWndJob As Long, gcProcess As Integer, hProcess As Long, scProcess As Long, cProcess As Long, OutSize As Long, reProcess As Long, mcProcess As Long, gcmcProcess As Long

'SiScan variables
Public SSSubSeq() As String, PltCol3() As Long, PScores() As Byte, SSOLSeq As String, SSOLSeqName As String, PltCol2() As Long, PltCol() As Long
Public oSeq As Integer, ManSSOLSeq As Integer, SSUp As Double, SSLo As Double, SSFastFlag As Byte, SSGapFlag As Byte, SSVarPFlag As Byte, SSOutlyerFlag As Byte, SSRndSeed As Long, SSWinLen As Long, SSStep As Long, SSNumPerms As Long, UCriticalZ As Double, CriticalZ As Double, TotalSSRecombinants As Long, SSS As Long, SSE As Long
Public pSSFastFlag, pSSGapFlag As Byte, pSSVarPFlag As Byte, pSSOutlyerFlag As Byte, pSSRndSeed As Long, pSSWinLen As Long, pSSStep As Long, pSSNumPerms As Long
Public pSSNumPerms2 As Long, xSSNumPerms2 As Long, SSNumPerms2 As Long, xSSFastFlag, xSSGapFlag As Byte, xSSVarPFlag As Byte, xSSOutlyerFlag As Byte, xSSRndSeed As Long, xSSWinLen As Long, xSSStep As Long, xSSNumPerms As Long

'TOPAL variables
Public DistMatrix() As Single
Public SSScore() As Double, HighestDSS() As Double, SmoothDSS() As Double
Public TOSeq() As String
Public ToSeqGenCLine As String
Public TotMat() As Single, LastMatrix() As Double, TOCoeffVar As Double, TOHigh As Double, MatAverage As Double, TOPower As Double, TOPValCOff As Double, TOTvTs As Double, TOFreqFlag As Double, TOFreqA As Double, TOFreqC As Double, TOFreqG As Double, TOFreqT As Double, xTOTsTv As Double
Public TOTSeqNum() As Integer
Public TOEndPlot As Long
Public xTOWinLen As Long, ToNumSeqs As Long, TOPFlag As Integer, TORndNum As Integer, TOModel As Integer, TOTreeType As Integer, TOPerms As Integer, TOWinLen As Integer, TOStepSize As Integer, TOSmooth As Integer, xTOModel As Integer, xToTreeType As Integer, xToFreqFlag As Integer

'Reticulate variables
Public FormatFlag As Integer, RETFlag As Integer, Square As Integer, MatrixFlag As Integer, RepaintFlag As Integer, ZoomFlag As Integer, RedoReticulateFlag As Integer
Public RetXPos() As Long, RetYPos() As Long
Public EndY As Long, VarSites As Long
Public MatLine As String
Public RetPlot() As Double
Public XYFactor As Double, MaxWhite As Double, MinWhite As Double, RetPVal As Double, RetOCompat As Double, RetNSS As Double

'Distance plot variables
Public xDPModelFlag As Integer, xDPBFreqFlag As Integer, DPBFreqFlag As Integer, DPModelFlag As Integer
Public DPWindow As Long, DPStep As Long
Public MinDistX As Double, MaxDistX As Double, DPTVRatio As Double, DPBFreqA As Double, DPBFreqC As Double, DPBFreqG As Double, DPBFreqT As Double, DPCoeffVar As Double, xDPTVRatio As Double

'Colour schemes
Public BackColours As Long, Purple As Long, vLGreen As Long, LGreen As Long, Green As Long, vLPurple As Long, LPurple As Long, Yellow As Long, vLYellow As Long, LYellow As Long, mPurple As Long, mYellow As Long, mGreen As Long
Public ProgColour() As Long

'LARD variables
Public xLRDBaseFreqFlag As Integer, xLRDModel As Integer, LRDStep As Integer, LRDBaseFreqFlag As Integer, LRDModel As Integer, LRDCategs As Integer
Public LSurface() As Double
Public MinL As Double, MaxL As Double, LRDCodon1 As Double, LRDCodon2 As Double, LRDCodon3 As Double, LRDAFreq As Double, LRDCFreq As Double, LRDGFreq As Double, LRDTFreq As Double, LRDShape As Double, LRDTvRat As Double, LRDACCoeff As Double, LRDAGCoeff As Double, LRDATCoeff As Double, LRDCGCoeff As Double, LRDCTCoeff As Double, LRDGTCoeff As Double
Public lWndJob As Long, lProcess As Long, LXPos() As Long
Public LRDRegion As Long

'File management
Public WholeFileFlag As Integer, ErrorFlag As Integer, RLFlag As Integer, SaveFlag As Integer, SaveBMPFlag As Integer, SaveTxtFlag As Integer, OldFileFlag As Integer
Public FileList() As String, RecombSeq() As String
Public DefExt As String, SeqFile As String, FNameII As String, FName As String, sFName As String, EMFFName As String

'MaxChi/Chimaera variables
Public lHWindowWidth As Long, pHWindowWidth As Long, MaxY As Integer, LoHiFlag As Byte, MCCorrect As Long, HWindowWidth As Long, CriticalChi As Double, CriticalDiff As Long, SubSetF() As Integer, SubSetR() As Integer, MCWarningFlag() As Integer, PeakNumber() As Integer, MCXDiffPos() As Long, MCXPosDiff() As Long

Public NoMCFlag As Integer, IncludeSeq As Integer, MCStripGapsFlag As Integer, xMCStripGapsFlag As Integer, pMCStripGapsFlag As Integer, xMCProportionFlag As Integer, pMCFlag As Integer, pMCSteplen As Integer, xMCSteplen As Integer, pMCTripletFlag As Integer, pMCProportionFlag As Integer, xMCTripletFlag As Integer, MCSteplen As Integer, MCOverlapL As Long, MCOverlapR As Long, MCTripletFlag As Integer, MCProportionFlag As Integer
Public MCFullFile As String, MaxChiCline As String
Public MCRndSeed As Long, MCFile() As Long, mmcProcess As Long, MCFullOL As Long, MCFullOR As Long, XOverListSize As Long, MCMaxX As Long, MCMaxZ As Long, pMCWinSize As Long, pMCStart As Long, pMCEnd As Long, xMCWinSize As Long, xMCStart As Long, xMCEnd As Long, MCWinSize As Long, MCStart As Long, MCEnd As Long
Public PeakPair() As Double
Public xMCPermMaxP As Double, xMCMaxP As Double, xMCWinFract As Double, pMCMaxP As Double, pMCPermMaxP As Double, pMCWinFract As Double, MCMinChiP As Double, MCPermMaxP As Double, MCMaxP As Double, MCWinFract As Double
Public SmoothChi() As Double, SmoothChiX() As Double, Scores() As Byte, ScoresX() As Byte, WinScoresX() As Long, Winscores() As Long, Chivals() As Double, ChiValsX() As Double

'SCHEMA variables
Public PDBSeq() As String, Nucs() As Byte, RevNucs() As Byte, Trans(4, 4, 4) As String, ContactFrame() As Long, TotStructs As Long, Translation(5) As String, WinScorePDB() As Double, WinFrame() As Long, WinRange() As Long

Public SCHEMADistCO As Double, PermContactNumberT As Long, PermContactNumberB As Long, SixFrame() As Long, LongInteract() As Long, InterProtMap() As Long, PermInterProtInteracts As Long
Public ProtInfo() As Long, PermPDBNo As Long, ContactMapT() As Double, ContactMapB() As Double, PermPDBSeq() As String, PermSeq2Align() As Long, PermSeq1Align() As Long, Seq1Align() As Long, PDBFile As String

'Chimaera Variables
Public CXoverSeq() As String
Public xLenXoverSeq() As Long
Public xCProportionFlag As Integer, pCProportionFlag As Integer, CProportionFlag As Integer
Public CRndSeed As Long, pCWinSize As Long, xCWinSize As Long, CWinSize As Long
Public xCPermMaxP As Double, xCMaxP As Double, xCWinFract As Double, pCMaxP As Double, pCPermMaxP As Double, pCWinFract As Double, CMinChiP As Double, CPermMaxP As Double, CMaxP As Double, CWinFract As Double

'LDHat Variables
Public TotalLDRecombinants As Long

'RDP Variables
Public RDPUD As Double, RDPLD As Double
Public Outlyer As Integer, FirstDrawFlag As Integer, SpacerNo As Integer, ntInCommon As Integer, XOverWindowX As Integer, SpacerFlag As Integer
Public SpacerFlagT  As Byte
Public Spacer4No As Long
Public AvBkgHomology As Double
Public XoverSeqNumW() As Byte, XoverSeqNum() As Integer, SpacerSeqs() As Integer, XPosDiff() As Long, XDiffPos() As Long, ValidSpacer() As Integer
Public OLSeq As Long, LenXoverSeq As Long, InRangeFlag As Integer
Public XOverLength As Long, pXOverWindowX As Long, xXOverWindowX As Long
Public XOverSeq() As String
Public ProbTest As String
Public XOverHomologyNum() As Long
Public IndProb As Double, ProbX As Double, ProbY As Double, AddjustFactor As Double, ProbabilityXOver As Double, NFactorial As Double, MFactorial As Double

'General Settings
Public PValCat() As Long, MaxPValCat() As Double, CurrentXOver() As Integer, MaskSeq() As Integer, SeqSpaces() As Long, LenNoGaps() As Long, SeqNum() As Integer, pMaskSeq() As Integer
Public CurrentCorrect As Byte, MaxXOListSize As Long, Beginning As Integer, Ending As Integer, RecombineFlag As Integer, CircularFlagT As Integer, WeightedFlagT As Integer, HomologyIndicatorT As Integer, ShowPlotFlagT As Integer, CircularFlag As Integer, ShowPlotFlag As Integer, RunFlag As Integer, NJFlag As Integer, DistanceFlag As Integer, AbortFlag As Integer, xCircularFlag As Integer, xSpacerFlag As Integer, xMCFlag As Integer, MCFlagT As Integer, MCFlag As Integer, pCircularFlag As Integer, pSpacerFlag As Integer
Public ValidSite() As Single, Distance() As Single, AnalT() As Double
Public pLowestProb As Double, xLowestProb As Double, LowestProb As Double
Public Pos As Long, NextNo As Long
Public PolishBPFlag As Byte, RealignFlag As Byte, ConsensusProg As Byte, xConsensusProg As Byte
Public StraiName()  As String, StrainSeq() As String
Public VarString As String

'Checking variables
Public CurrentCheck As Integer

'Recombinant scanning
Public RFlag() As Integer
Public Seq1 As Long, Seq2 As Long, Seq3 As Long, ShortOutFlag As Integer, LDHatFlag As Integer, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, IndividualA As Integer, IndividualB As Integer
Public MCCorrection As Long
Public CLine As String
Public ST As Double, ET As Double, GCST As Double, MCS As Double, MCE As Double, ChiS As Double, ChiE As Double, lds As Double, LDE As Double

'ManualBootscan variables
Public NumberOfSeqs As Long

'Auto-Bootscan variables
Public FoundMethods() As Byte
Public BSHi1 As Long, BSHi2 As Long, BSLo As Long
Public pBSPValFlag, xBSPValFlag As Byte, BSPValFlag As Byte, GoOnA() As Long, GoOnB() As Long, BSRWBuffer As Long, BSRSize As Long, BSRWSize As Long, BSWinRWChunk As Long, BSFilePos() As Long
Public BSFileName As String, InFileX As String, OutFileX As String
Public xBSBootReps As Long, xBSSubModelFlag As Integer, BSBootReps As Long, BSRndNumSeed As Integer, BSSubModelFlag As Integer, BSTypeFlag As Integer, xBSTypeFlag As Integer, BSFreqFlag As Integer, xBSFreqFlag As Integer, BSFreqA As Double, BSFreqC As Double, BSFreqG As Double, BSFreqT As Double
Public xBSStepWin As Long, xBSStepSize As Long, BSStepWin As Long, BSStepSize As Long, s1col As Long, s2col As Long, s3col As Long, s1colb As Long, s2colb As Long, s3colb As Long
Public xBSTTRatio As Double, BSTTRatio As Double, xBSCutoff As Double, pBSCutoff As Double, BSCutOff As Double, BSStart As Double, BSEnd As Long
Public pBSTypeFlag As Integer, pBSStepSize As Long, pBSStepWin As Long, pBSBootReps As Long

'Bootscan check variables
Public BSCCenterFlag As Integer, BSCDecreaseStepFlag As Integer
Public BSCDStepSize As Long, BSCDSpan As Long
Public BSCoeffVar As Double
Public SimSeq As String

'GENECONV variables
Public GCDimSize As Long, HighEnough(5) As Long, HiFragScore(5) As Long, PVals() As Double, FragMaxScore() As Long, MaxScorePos() As Long
Public SubSeq() As Byte
Public xGCTripletFlag As Byte, pGCTripletflag As Byte, GCtripletflag As Byte, GCFoundSitesFlag As Byte
Public GCSeq() As String
Public GCOutfileName As String, GCFragSeq As String, GCCompCfg As String, GCPOutCfg As String, GCFragCfg As String, GCOFile As String, GCCFile As String
Public GCEnabledNo() As Integer
Public GCMCCheckFlag As Integer, NumEnabledSeqs As Integer, NextGCImage As Integer, xGCPermPolyFlag As Integer, GCPermPolyFlag As Integer, xGCLogFlag As Integer, xGCOutFlag As Integer
Public xGCOutFlagII As Integer, xGCSortFlag As Integer, xGCSeqTypeFlag As Integer, xGCIndelFlag As Byte, xGCMonoSiteFlag As Integer, GCLogFlag As Integer, GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer, GCMaxOverlapFrags As Integer
Public pGCMissmatchPen As Integer, pGCIndelFlag As Byte, pGCMinFragLen As Integer, pGCMinPolyInFrag As Integer, pGCMinPairScore As Integer, pGCMaxOverlapFrags As Integer
Public GCMissmatchPen As Integer, GCSeq1 As Integer, GCSeq2 As Integer, GCSeq3 As Integer, GCOutFlag As Integer, GCOutFlagII As Integer, GCSortFlag As Integer, GCSeqTypeFlag As Integer, GCIndelFlag As Byte, GCMonoSiteFlag As Integer
Public FragSt() As Long, FragEn() As Long, FragScore() As Long
Public GCSeqRange() As Long, xGCSeqRange() As Long
Public GCMaxPairFrags As Long, GCMaxGlobFrags As Long, MaskFlag As Long, GCMCCorrection As Long, GCNumPerms As Long, GCEndLen As Long, GCOffsetAddjust As Long
Public MinGCP As Double, GCMaxPermPVal As Double, MinP As Single, MinPVal As Double
Public GCGroupFlag As Byte

'Managing recombination checks
Public RelX As Long, RelY As Long, RecStart As Long, RecEnd As Long
Public RecProb As Double

'Managing ORFMaps and GenBank files
Public ORFWin() As Integer
Public ORFFlag As Integer, HighlightFlagII As Integer
Public GBFile As String
Public Pic20PointerVal As Single

'Homology display
Public FullWindowSize As Integer, Pic4PointerVal As Integer, Pic11PointerVal As Integer, Pic4Flag As Integer, Pic11Flag As Integer, Chunk As Integer, HomologyIndicator As Integer
Public BkgIdentity() As Single
Public MinHomology As Double, MaxHomology As Double

Public ImageData() As Byte, bm As BITMAP
Public Type BITMAP '14 bytes
   bmType As Long
   bmWidth As Long
   bmHeight As Long
   bmWidthBytes As Long
   bmPlanes As Integer
   bmBitsPixel As Integer
   bmBits As Long
End Type





Private Type BITMAPINFOHEADER '40 bytes
    biSize As Long
    biWidth As Long
    biHeight As Long
    biPlanes As Integer
    biBitCount As Integer
    biCompression As Long
    biSizeImage As Long
    biXPelsPerMeter As Long
    biYPelsPerMeter As Long
    biClrUsed As Long
    biClrImportant As Long
End Type

Type POINTAPI
    x As Long
    Y As Long
End Type
Type XOverDefine
    OutsideFlag As Byte '1
    MissIdentifyFlag As Byte '1
    ProgramFlag As Byte '1
    SBPFlag As Byte '1
    Accept As Byte '1
    MajorP As Integer '2
    MinorP As Integer '2
    Daughter As Integer '2
    Beginning As Long '4
    Ending As Long '4
    LHolder As Long '4
    Eventnumber As Long '4
    PermPVal As Single '4
    BeginP As Long '4
    EndP As Long '4
    Probability As Double '8
    DHolder As Double '8
    
'    NumPoly As Long '4
'    NumDiffs As Long '4
'    TotDiffs As Long '4
'    MisPen As Variant '16
    
'    BeginPermP As Double '8
'    EndPermP As Double '8
'    TreePos(2) As Long '4
    
End Type
Type GenomeFeatureDefine
    Orientation As Integer
    Frame As Integer
    Start As Long
    End As Long
    IntronFlag As Integer
    ExonNumber As Integer
    StartInAlign As Long
    EndInAlign As Long
    Name As String
    Product As String
End Type
Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type
Type LOGPEN
    lopnStyle As Long
    lopnWidth As POINTAPI
    lopnColor As Long
End Type

Private Type RGBQUAD
    rgbBlue As Byte
    rgbGreen As Byte
    rgbRed As Byte
    rgbReserved As Byte
End Type
'Modified 8-bit BMI type
Private Type BITMAPINFO
    bmiHeader As BITMAPINFOHEADER
    bmiColors(255) As RGBQUAD
End Type

Type site_type
    PT(4) As Long
    nt As Long
    ld_stat(3) As Double
End Type

Type ProvinceDetails
        Kingdom As Integer
        Island As Integer
        Acres As Long
        Province As String
        Protection As Byte
        pRace As String
        pHonor As String
        pNW As Long
    End Type


Type RDPHeader
    
    MaskSeqX As Long
    CurrentXOverX As Long
    XoverListX As Long
    XOverListY As Long
    BCurrentXOverMiX As Long
    BestXOListMiX As Long
    BestXOListMiY As Long
    BCurrentXOverMaX As Long
    BestXOListMaX As Long
    BestXOListMaY As Long
    SEventNumberA As Long
    EventnumberA As Long
    NoPIniX As Long
    NoPIniY As Long
    DScoresX As Long
    DScoresY As Long
    DScoresZ As Long
    SuperEventListX As Long
    NumDA As Long
    NumMiA As Long
    NumMaA As Long
    DaughtX As Long
    DaughtY As Long
    MinorParX As Long
    MinorParY As Long
    MajorParX As Long
    MajorParY As Long
    BestEventX As Long
    BestEventY As Long
    ConfirmX As Long
    ConfirmY As Long
    ConfirmPX As Long
    ConfirmPY As Long
    ConfirmMiX As Long
    ConfirmMiY As Long
    ConfirmPMiX As Long
    ConfirmPMiY As Long
    ConfirmMaX As Long
    ConfirmMaY As Long
    ConfirmPMaX As Long
    ConfirmPMaY As Long
    StepNoA As Long
    StepsX As Long
    StepSY As Long
    MulColourX As Long
    ColourSeqX As Long
    TreeTestStatsX As Long
    TreeTestStatsY As Long
    GPermsA As Long
    PermsXOListX As Long
    PermsXOListY As Long
    PermsXOListZ As Long
    BPCIsX As Long
    BPCIsY As Long
    SelGrpFlagA As Long
    GrpMaskSeqX As Long
    ReassortmentFlagA As Long
    RBPNumA As Long
    RBPPosX As Long
    MethodTimeX As Long
    TimeFractX As Long
    RefNumA As Long
    ReferenceListX As Long
    RefGroupNameX As Long
    ReferenceColsX As Long
    WorthWhileScanX As Long
    Stuffer1 As Long
    Stuffer2 As Long
    Stuffer3 As Long
    Stuffer4 As Long
    Stuffer5 As Long
    Stuffer6 As Long
    Stuffer7 As Long
    Stuffer8 As Long
    Stuffer9 As Long
    stuffer10 As Long
    Stuffer11 As Long
    Stuffer12 As Long
    Stuffer13 As Long
    Stuffer14 As Long
    Stuffer15 As Long
    Stuffer16 As Long
    Stuffer17 As Long
    Stuffer18 As Long
    Stuffer19 As Long
    stuffer20 As Long
    Stuffer21 As Long
    Stuffer22 As Long
    Stuffer23 As Long
    Stuffer24 As Long
    Stuffer25 As Long
    Stuffer26 As Long
    Stuffer27 As Long
    Stuffer28 As Long
    Stuffer29 As Long
    
End Type

'LDHat variables
Public idum As Long

Type data_sum
    NSeq As Long
    LSeq As Long
    tlseq As Long
    lC As Byte
    avc As Double
    rho As Double
    lkmax As Double
    LD(4) As Double
    rme As Double
    rce As Long
End Type

Type MEMORYSTATUS
    dwLength    As Long ' sizeof(MEMORYSTATUS)
    dwMemoryLoad    As Long ' percent of memory in use
    dwTotalPhys As Long ' bytes of physical memory
    dwAvailPhys As Long ' free physical memory bytes
    dwTotalPageFile As Long ' bytes of paging file
    dwAvailPageFile As Long ' free bytes of paging file
    dwAvailVirtual  As Long ' user bytes of address space
    dwTotalVirtual  As Long ' free user bytes
End Type

Type RGBTRIPLE
        rgbtBlue As Byte
        rgbtGreen As Byte
        rgbtRed As Byte
End Type


Type BITMAPCOREHEADER '12 bytes
        bcSize As Long
        bcWidth As Integer
        bcHeight As Integer
        bcPlanes As Integer
        bcBitCount As Integer
End Type
Type BITMAPCOREINFO
        bmciHeader As BITMAPCOREHEADER
        bmciColors As RGBTRIPLE
End Type
Type BITMAPFILEHEADER
        bfType As Integer
        bfSize As Long
        bfReserved1 As Integer
        bfReserved2 As Integer
        bfOffBits As Long
End Type
Type BITMAPV4HEADER
        bV4Size As Long
        bV4Width As Long
        bV4Height As Long
        bV4Planes As Integer
        bV4BitCount As Integer
        bV4V4Compression As Long
        bV4SizeImage As Long
        bV4XPelsPerMeter As Long
        bV4YPelsPerMeter As Long
        bV4ClrUsed As Long
        bV4ClrImportant As Long
        bV4RedMask As Long
        bV4GreenMask As Long
        bV4BlueMask As Long
        bV4AlphaMask As Long
        bV4CSType As Long
        bV4Endpoints As Long
        bV4GammaRed As Long
        bV4GammaGreen As Long
        bV4GammaBlue As Long
End Type


Type LOGBRUSH
        lbStyle As Long
        lbColor As Long
        lbHatch As Long
End Type


Public Type APPBARDATA
    cbSize As Long
    hwnd As Long
    uCallbackMessage As Long
    uEdge As Long
    RC As RECT
    lParam As Long
End Type

Public XoverList() As XOverDefine
Public PermsXOverList() As XOverDefine

Public GeneList() As GenomeFeatureDefine
Public MemSit As MEMORYSTATUS


Public Const INTERNET_OPEN_TYPE_PRECONFIG = 0
Public Const INTERNET_OPEN_TYPE_DIRECT = 1
Public Const INTERNET_OPEN_TYPE_PROXY = 3

Public Const scUserAgent = "VB OpenUrl"
Public Const INTERNET_FLAG_RELOAD = &H80000000

Public Const ABM_GETTASKBARPOS = &H5
Public Const VK_LBUTTON = &H1

Public Const SWP_NOMOVE = 2
Public Const SWP_NOSIZE = 1
Public Const FLAGS = SWP_NOMOVE Or SWP_NOSIZE
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2

Declare Function SetWindowPos Lib "user32" _
      (ByVal hwnd As Long, _
      ByVal hWndInsertAfter As Long, _
      ByVal x As Long, _
      ByVal Y As Long, _
      ByVal cx As Long, _
      ByVal cy As Long, _
      ByVal wFlags As Long) As Long
      
Declare Function GetForegroundWindow Lib "user32" () As Long

'Internet declares from Peter G Aitken
'Public Declare Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" _
'(ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, _
'ByVal sProxyBypass As String, ByVal lFlags As Long) As Long'

'Public Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" _
'(ByVal hOpen As Long, ByVal sUrl As String, ByVal sHeaders As String, _
'ByVal lLength As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long

'Public Declare Function InternetReadFile Lib "wininet.dll" _
'(ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, _
'lNumberOfBytesRead As Long) As Integer

'Public Declare Function InternetCloseHandle Lib "wininet.dll" _
'(ByVal hInet As Long) As Integer
'sytem info declare
Type SYSTEM_INFO
        dwOemID As Long
        dwPageSize As Long
        lpMinimumApplicationAddress As Long
        lpMaximumApplicationAddress As Long
        dwActiveProcessorMask As Long
        dwNumberOrfProcessors As Long
        dwProcessorType As Long
        dwAllocationGranularity As Long
        dwReserved As Long
End Type

Public Declare Function SuperDistP Lib "dna5.dll" (ByVal x As Long, ByVal NextNo As Long, ByVal UB14 As Long, ByVal UB04 As Long, ByVal UB13 As Long, ByVal UB03 As Long, ByVal UB12 As Long, ByVal UB02 As Long, ByVal UB11 As Long, ByRef AvDst As Double, ByRef PDistance As Single, ByRef PValid As Single, ByRef Dist As Single, ByRef RedoDist As Integer, ByRef SeqCatCount As Long, ByRef ISeq14 As Integer, ByRef ISeq04 As Integer, ByRef ISeq13 As Integer, ByRef ISeq03 As Integer, ByRef ISeq12 As Integer, ByRef ISeq02 As Integer, ByRef ISeq11 As Integer, ByRef CompressValid14 As Byte, ByRef CompressDiffs14 As Byte, ByRef CompressValid13 As Byte, ByRef CompressDiffs13 As Byte, ByRef CompressValid12 As Byte, ByRef CompressDiffs12 As Byte, ByRef CompressValid11 As Byte, ByRef CompressDiffs11 As Byte, ByRef CompressDiffs04 As Byte, ByRef CompressDiffs03 As Byte, ByRef CompressDiffs02 As Byte) As Double
Public Declare Function SuperDistP2 Lib "dna5.dll" (ByVal x As Long, ByVal NextNo As Long, ByVal UB14 As Long, ByVal UB04 As Long, ByVal UB13 As Long, ByVal UB03 As Long, ByVal UB12 As Long, ByVal UB02 As Long, ByVal UB11 As Long, ByRef AvDst As Double, ByRef PDistance As Single, ByRef PValid As Single, ByRef Dist As Single, ByRef RedoDist As Integer, ByRef SeqCatCount As Long, ByRef ISeq14 As Integer, ByRef ISeq04 As Integer, ByRef ISeq13 As Integer, ByRef ISeq03 As Integer, ByRef ISeq12 As Integer, ByRef ISeq02 As Integer, ByRef ISeq11 As Integer, ByRef CompressValid14 As Byte, ByRef CompressDiffs14 As Byte, ByRef CompressValid13 As Byte, ByRef CompressDiffs13 As Byte, ByRef CompressValid12 As Byte, ByRef CompressDiffs12 As Byte, ByRef CompressValid11 As Byte, ByRef CompressDiffs11 As Byte, ByRef CompressDiffs04 As Byte, ByRef CompressDiffs03 As Byte, ByRef CompressDiffs02 As Byte) As Double
Public Declare Function UFDist Lib "dna5.dll" (ByVal LenStrainseq0 As Long, ByVal BPos3 As Long, ByVal EPos3 As Long, ByVal UBPV As Long, ByRef PermValid As Single, ByRef PermDIffs As Single, ByRef BT As Single, ByRef RT As Single, ByRef ISeqs As Long, ByVal UBSN As Long, ByRef SeqNum As Integer) As Long

'UFDist(int                                          LenStrainSeq0,             int BPos3,         int EPos3,            int UBPV,  float *PermValid,             float *PermDIffs, float *BT                        , float *RT,          int *ISeqs, int UBSN, short int *SeqNum) {
        
Public Declare Function CMaxD2P Lib "dna5.dll" (ByVal IncNum As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal SBP As Long, ByVal EBP As Long, ByVal NextNo As Long, ByVal SLen As Long, ByRef SeqNum As Integer, ByRef SeqnumX As Integer, ByRef IdenticalR As Long, ByRef IdenticalF As Long, ByRef NucMat As Byte, ByRef IncSeq3 As Long, ByRef IncSeq2 As Byte, ByRef IncSeq As Byte, ByRef e As Single, ByRef D As Single, ByRef VScoreMat As Single, ByRef AvDist As Single, ByRef TotCount As Long) As Long
Public Declare Function CMaxD2P3 Lib "dna5.dll" (ByVal IncNum As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal SBP As Long, ByVal EBP As Long, ByVal NextNo As Long, ByVal SLen As Long, ByRef SeqNum As Integer, ByRef SeqnumX As Integer, ByRef IdenticalR As Long, ByRef IdenticalF As Long, ByRef NucMat As Byte, ByRef IncSeq3 As Long, ByRef IncSeq2 As Byte, ByRef IncSeq As Byte, ByRef e As Single, ByRef D As Single, ByRef VScoreMat As Single, ByRef AvDist As Single, ByRef TotCount As Long) As Long


Public Declare Function CheckYannP Lib "dna5.dll" (ByVal SEN As Long, ByVal NextNo As Long, ByVal LenStrainseq0 As Long, ByVal BPos As Long, ByVal Epos As Long, ByRef ISeqs As Long, ByVal UBSN As Long, ByRef SeqNum As Integer, ByRef IsPresent As Byte, ByRef TraceSub As Long, ByVal UBXH As Long, ByVal UBXHMi As Long, ByVal UBXHMa As Long, ByRef ExtraHits As Byte, ByRef ExtraHitsMi As Byte, ByRef ExtraHitsMa As Byte, ByRef A As Long, ByRef b As Long) As Long


'int MyMathFuncs::CheckYannP(                       int SEN,             int NextNo             ,int LenStrainSeq0        , int BPos,            int Epos, int *ISeqs,                    int UBSN,        short int *SeqNum, unsigned char *IsPresent, int *TraceSub,           int UBXH,                int UBXHMi,            int UBXHMa, unsigned char *ExtraHits, unsigned char *ExtraHitsMi, unsigned char *ExtraHitsMa, int *A, int *b) {
    
Public Declare Function GetFragsP Lib "dna5.dll" (ByVal CircularFlagX As Integer, ByVal LengthXoverSeq As Long, ByVal SequenceLength As Long, ByVal GCDimSize As Long, ByRef SubSeqArray As Byte, ByRef FragStartpos As Long, ByRef FragEndPos As Long, ByRef FragmentScore As Long, ByRef FragmentCount As Long) As Long
Public Declare Function GetFragsP3 Lib "dna5.dll" (ByVal CircularFlagX As Integer, ByVal LengthXoverSeq As Long, ByVal SequenceLength As Long, ByVal GCDimSize As Long, ByRef SubSeqArray As Byte, ByRef FragStartpos As Long, ByRef FragEndPos As Long, ByRef FragmentScore As Long, ByRef FragmentCount As Long) As Long

Public Declare Function GetFragsP2 Lib "dna5.dll" (ByRef GoOn As Byte, ByVal ElementNum As Long, ByVal UBFC As Long, ByVal UBFS1 As Long, ByVal UBFS2 As Long, ByVal UBSS1 As Long, ByVal UBSS2 As Long, ByVal CircularFlagX As Integer, ByRef LengthXoverSeq As Long, ByVal SequenceLength As Long, ByVal GCDimSize As Long, ByRef SubSeqArray As Byte, ByRef FragStartpos As Long, ByRef FragEndPos As Long, ByRef FragmentScore As Long, ByRef FragmentCount As Long) As Long

Public Declare Function GetMaxFragScoreP Lib "dna5.dll" (ByVal LenXoverSeqx As Long, ByVal LenSeqsx As Long, ByVal CircularFlagX As Integer, ByVal GCMissmatchPenX As Integer, ByRef MissMatchPenArray As Double, ByRef MaxScorePosX As Long, ByRef FragMaxScorex As Long, ByRef FragScoreX As Long, ByRef FragCountx As Long, ByRef HiFragScore As Long) As Long
Public Declare Function GetMaxFragScoreP2 Lib "dna5.dll" (ByVal ElementNum As Long, ByRef LenXoverSeqx As Long, ByVal LenSeqsx As Long, ByVal CircularFlagX As Integer, ByVal GCMissmatchPenX As Integer, ByRef MissMatchPenArray As Double, ByRef MaxScorePosX As Long, ByRef FragMaxScorex As Long, ByRef FragScoreX As Long, ByRef FragCountx As Long, ByRef HiFragScore As Long, ByRef NDiffG As Long) As Long
'GetMaxFragScoreP2(                                                     int elementnum, int      *LenXoverSeq,             int lseq,            short int CircularFlag, short     int GCMissmatchPen,            double *MissPen,               int *MaxScorePos,                  int *FragMaxScore, int            *FragScore, int          *FragCount,           int *hiscore,         int *NDiffG)
Public Declare Function FindSubSeqGCAP Lib "dna5.dll" (ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long) As Long
Public Declare Function FindSubSeqGCAP2 Lib "dna5.dll" (ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long, ByRef BinArray As Byte) As Long
Public Declare Function FindSubSeqGCAP3 Lib "dna5.dll" (ByVal UBND As Long, ByVal UBXPD As Long, ByVal UBSS1 As Long, ByVal UBSS2 As Long, ByVal ElementNum As Long, ByRef LenXOverSeqG As Long, ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByRef ElementSeq As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long, ByRef BinArray As Byte) As Long
Public Declare Function FindSubSeqGCAP4 Lib "dna5.dll" (ByVal UBND As Long, ByVal UBXPD As Long, ByVal UBSS1 As Long, ByVal UBSS2 As Long, ByVal ElementNum As Long, ByRef LenXOverSeqG As Long, ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByRef ElementSeq2 As Long, ByRef ElementSeq As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long, ByRef BinArray As Byte) As Long


Public Declare Function FindSubSeqGCAP6 Lib "dna5.dll" (ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSS2 As Long, ByRef FSSGC As Byte, ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SubSeqArray As Byte, ByRef NumberOfDifferences As Long) As Long
Public Declare Function FindSubSeqGCAP7 Lib "dna5.dll" (ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSS2 As Long, ByRef FSSGC As Byte, ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SubSeqArray As Byte, ByRef NumberOfDifferences As Long, ByRef XDiffPos As Long, ByRef XPosDiff As Long) As Long
Public Declare Function cleanss Lib "dna5.dll" (ByVal LenXoverSeq As Long, ByVal UBSSS As Long, ByRef SubSeq As Byte) As Long

'cleanss(int y,int UBSS, char *SubSeq)
'int MyMathFuncs::FindSubSeqGCAP6(                        int ubcs,unsigned char *cs, int ubfss                 , unsigned char *fssgc, char gcindelflag,             int LSeq,                     int seq1,                   int seq2,               int seq3,             char *SubSeq,                      int *NDiff) {

Public Declare Function FastGC Lib "dna5.dll" (ByVal LenSeq As Long, ByVal NextNo As Long, ByVal PValCutoff As Double, ByVal UBSN As Long, ByVal UBTP As Long, ByVal UBDP As Long, ByRef SeqNum As Integer, ByRef VarSites As Long, ByRef Mask As Byte, ByRef TestPairs As Byte, ByRef DoPairs As Byte) As Double
'FastGC(int lseq, int Nextno,                                                            double PCO,               int UBSN,              int UBTP,             int UBDP,              short int *SeqNum, int *VarSites,      unsigned char *Mask,            unsigned char *TestPairs, unsigned char *DP)
'FindSubSeqGCAP3                                                 (int UBND, int           UBXPD1, int          UBSS1, int           UBSS2, int           elementnum, int          *lxos, char                  gcindelflag, int         LSeq, int                       seq1, int                seq2, int               *elementseq, short int    *SeqNum, char                             *SubSeq, int               *XPosDiff, int                *XDiffPos, int              *NDiff, unsigned char              *binarray)
Public Declare Function GCGetHiPValP Lib "dna5.dll" (ByVal LSeqX As Long, ByVal LenXoverSeqx As Long, ByRef FragCountx As Long, ByRef PValsx As Double, ByRef MaxYx As Long, ByRef MaxXx As Long, ByRef highenoughx As Long) As Double
'(int                                                               lseq, int            LenXoverSeq, int          *FragCount, double         *PVals, int            *MaxY, int           *MaxX, int            *highenough)
Public Declare Function FakeMissing Lib "dna5.dll" (ByVal Seq1 As Long, ByVal LenSeq As Long, ByVal UBSN1 As Long, ByVal UBTSN1 As Long, ByRef SeqnumBak As Long, ByRef SeqNum As Integer, ByRef tSN As Integer) As Long
'FakeMissing                                          (int seq1           ,int lseq,             int UBSN1, int UBTSN1,                int *SeqnumBak, short int *Seqnum, short int *tSN)
Public Declare Function CalcChiValsP Lib "dna5.dll" (ByVal UBWS As Long, ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
'Public Declare Function CalcChiVals Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Public Declare Function GetLaticePathP Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberXY As Long, ByRef LaticeXY As Double, ByRef LaticeAB As Double, ByRef LaticePath As Long) As Double
Public Declare Function GetLaticePathPF Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberXY As Long, ByRef LaticeXY As Single, ByRef LaticeAB As Single, ByRef LaticePath As Long) As Single

Public Declare Function CompressTE Lib "dna5.dll" (ByVal SLen As Long, ByVal DecompressSeq As String, ByVal TEString As String, ByRef Decompress As Long) As Long
'CompressTE(int lseq,                                               unsigned char *DecompressSeq, unsigned char *TEString, int *Decompress)
Public Declare Function GrowMChiWinP Lib "dna5.dll" (ByVal LO As Long, ByVal RO As Long, ByVal LenXoverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte) As Long
Public Declare Function GrowMChiWin2P Lib "dna5.dll" (ByVal LO As Long, ByVal RO As Long, ByVal LenXoverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte, ByRef MDMap As Byte) As Long
Public Declare Function GrowMChiWinP2 Lib "dna5.dll" (ByVal MaxABWin As Long, ByVal LO As Long, ByVal RO As Long, ByVal LenXoverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte, ByRef ChiTable As Single, ByRef Chimap As Long) As Long
Public Declare Function GrowMChiWin2P2 Lib "dna5.dll" (ByVal MaxABWin As Long, ByVal LO As Long, ByVal RO As Long, ByVal LenXoverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte, ByRef MDMap As Byte, ByRef ChiTable As Single, ByRef Chimap As Long) As Long
Public Declare Function DoHMMCycles Lib "dna5.dll" (ByVal RandomNumberSeed As Long, ByVal SLen As Long, ByVal HMMCycles As Long, ByVal LenStrainseq0 As Long, ByVal NumberXY As Long, ByVal NumberABC As Long, ByRef RecodeB As Byte, ByRef TransitionBak As Double, ByRef EmissionBak As Double, ByRef InitPBak As Double, ByRef LaticePathBak As Long) As Long
Public Declare Function DoHMMCyclesDetermin Lib "dna5.dll" (ByVal RandomNumberSeed As Long, ByVal SLen As Long, ByVal HMMCycles As Long, ByVal LenStrainseq0 As Long, ByVal NumberXY As Long, ByVal NumberABC As Long, ByRef RecodeB As Byte, ByRef TransitionBak As Double, ByRef EmissionBak As Double, ByRef InitPBak As Double, ByRef LaticePathBak As Long) As Long
Public Declare Function DoHMMCyclesSerial Lib "dna5.dll" (ByVal RandomNumberSeed As Long, ByVal SLen As Long, ByVal HMMCycles As Long, ByVal LenStrainseq0 As Long, ByVal NumberXY As Long, ByVal NumberABC As Long, ByRef RecodeB As Byte, ByRef TransitionBak As Double, ByRef EmissionBak As Double, ByRef InitPBak As Double, ByRef LaticePathBak As Long) As Long

'static MATHFUNCSDLL_API int _stdcall DoHMMCycles(int SLen, int HMMCycles,                 int LenStrainSeq0              , int NumberXY,             int NumberABC,          unsigned char *RecodeB,   double *TransitionBak, double *EmissionBak, double *InitPBak,                          int *LaticePathBak);
        
Public Declare Function FindMChiP Lib "dna5.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long
Public Declare Function WinScoreCalcP Lib "dna5.dll" (ByVal UBWS As Long, ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long
Public Declare Function FindSubSeqCP Lib "dna5.dll" (ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqnumX As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long) As Long   'ByVal var3x As Integer
Public Declare Function FindSubSeqDP Lib "dna5.dll" (ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqnumX As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long) As Long   'ByVal var3x As Integer

Public Declare Function FindSubSeqMCPB Lib "dna5.dll" (ByVal UBFFS As Long, ByVal UBCS1 As Long, ByVal NextNo As Long, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef CS As Byte, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef FSSMC As Byte) As Long

'static MATHFUNCSDLL_API int _stdcall FindSubSeqMCPB(int UBFSS,             int ubcs1          , int nextno,              int seq1,             int seq2,                 int seq3,           unsigned char *CS,  int *xdiffpos, int *xposdiff, unsigned char *FSSRDP);
Public Declare Function SuperDist14 Lib "dna5.dll" (ByVal x As Long, ByVal Y As Long, ByVal UB14 As Long, ByRef TVD As Long, ByRef CSeq1 As Integer, ByRef CSeq2 As Integer, ByRef CompressValid14 As Byte, ByRef CompressDiffs14 As Byte) As Long

'SuperDist14(                                           int X,          int Y,           int UB14,        int *tvd,           short int *ISeq14A,        short int *ISeq14B, char *CompressValid14, char *CompressDiffs14)

Public Declare Function SmoothChiValsP Lib "dna5.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long
Public Declare Function CalcChiVals4P Lib "dna5.dll" (ByVal UBWS As Long, ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long) As Double
Public Declare Function CalcChiVals4P2 Lib "dna5.dll" (ByVal UBCT As Long, ByVal UBWS As Long, ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long, ByRef ChiTable As Single) As Double
Public Declare Function CalcChiVals4P3 Lib "dna5.dll" (ByVal UBWS As Long, ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long, ByRef ChiTable As Single) As Double
Public Declare Function CalcChiValsP2 Lib "dna5.dll" (ByVal UBWS As Long, ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef ChiTable As Single) As Double

Public Declare Function MakeVarSites Lib "dna5.dll" (ByVal LSeq As Long, ByVal BPos As Long, ByVal Epos As Long, ByVal sa As Long, ByVal SB As Long, ByVal SX As Long, ByVal SY As Long, ByVal UBSN1 As Long, ByRef SeqNum As Integer, ByRef VXPos As Long, ByRef VarSiteMap As Integer, ByRef VSBE As Long) As Long
'int MyMathFuncs::MakeVarSites                           (int lseq, int BPos, int EPos, int sa, int SB, int SX,                                                                   int SY, int UBSN1       , short int *SeqNum, int *VXPos, short int *VarSiteMap, int *VSBE){
Public Declare Function FastBootDistP Lib "dna5.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double

Public Declare Function FastBootDistIP Lib "dna5.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double
Public Declare Function FastBootDistIP7 Lib "dna5.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double

Public Declare Function FastBootDistIP6 Lib "dna5.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByVal UBWM1 As Long, ByVal UBWM2 As Long, ByRef WeightMod As Long, ByVal UBTSN1 As Long, ByVal UBTSN2 As Long, ByRef SeqNum As Integer, ByVal UBD As Long, ByVal UBD As Long, ByRef Distance As Single) As Double

Public Declare Function FastBootDistIP5 Lib "dna5.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double

Public Declare Function FastBootDistIP4 Lib "dna5.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single, ByRef FlatDiffs As Byte, ByRef FlatValid As Byte) As Long

Public Declare Function ProbCalcP Lib "dna5.dll" (ByRef Fact As Double, ByVal xoverlengthx As Integer, ByVal numincommonx As Integer, ByVal indprobx As Double, ByVal LenXoverSeqx As Long) As Double
Public Declare Function ProbCalcP2 Lib "dna5.dll" (ByRef Fact3X3 As Double, ByVal UB3X3 As Long, ByVal xoverlengthx As Integer, ByVal numincommonx As Integer, ByVal indprobx As Double, ByVal LenXoverSeqx As Long) As Double
Public Declare Function FindSubSeqP Lib "dna5.dll" (ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer) As Long 'ByVal var3x As Integer
Public Declare Function FindSubSeqPB Lib "dna5.dll" (ByRef AH As Long, ByVal ubfss As Integer, ByVal XoverWindow As Long, ByVal UBCS1 As Long, ByVal LenStrainseq0 As Long, ByVal NextnoX As Integer, ByVal Seq1x As Long, ByVal Seq2x As Long, ByVal Seq3x As Long, ByRef CS As Byte, ByVal UBXOSNW As Long, ByRef xoverseqnumwx As Byte, ByRef xDiffposx As Long, ByRef XPosDiff As Long, ByRef FSSRDP As Byte) As Long  'ByVal var3x As Integer
Public Declare Function FindSubSeqPB4 Lib "dna5.dll" (ByRef AH As Long, ByVal ubfss As Integer, ByVal XoverWindow As Long, ByVal UBCS1 As Long, ByVal LenStrainseq0 As Long, ByVal NextnoX As Integer, ByVal Seq1x As Long, ByVal Seq2x As Long, ByVal Seq3x As Long, ByRef CS As Byte, ByVal UBXOSNW As Long, ByRef xoverseqnumwx As Byte, ByRef xDiffposx As Long, ByRef XPosDiff As Long, ByRef FSSRDP As Byte) As Long  'ByVal var3x As Integer

'int MyMathFuncs::FindSubSeqPB(                      int *ah          , int UBFSS             , int xoverwindow            , int ubcs1,             int lenstrainseq0,             int nextno,                   int seq1,           int seq2,               int seq3   ,    char *CS ,          int ubxos,            char *xoverseqnumw       , int *xdiffpos                  , unsigned char *FSSRDP)
Public Declare Function FindSubSeqPB2 Lib "dna5.dll" (ByRef AH As Long, ByVal ubfss As Integer, ByVal XoverWindow As Long, ByVal UBCS1 As Long, ByVal LenStrainseq0 As Long, ByVal NextnoX As Integer, ByVal Seq1x As Long, ByVal Seq2x As Long, ByVal Seq3x As Long, ByRef CS As Byte, ByVal UBXOSNW As Long, ByRef xoverseqnumwx As Byte, ByRef FSSRDP As Byte) As Long  'ByVal var3x As Integer
Public Declare Function FindSubSeqPB3 Lib "dna5.dll" (ByRef AH As Long, ByVal ubfss As Integer, ByVal XoverWindow As Long, ByVal UBCS1 As Long, ByVal LenStrainseq0 As Long, ByVal NextnoX As Integer, ByVal Seq1x As Long, ByVal Seq2x As Long, ByVal Seq3x As Long, ByRef CS As Byte, ByVal UBXOSNW As Long, ByRef xoverseqnumwx As Byte, ByRef FSSRDP As Byte) As Long  'ByVal var3x As Integer
Public Declare Function FindSubSeqPB6 Lib "dna5.dll" (ByRef AH As Long, ByVal ubfss As Integer, ByVal XoverWindow As Long, ByVal UBCS1 As Long, ByVal LenStrainseq0 As Long, ByVal NextnoX As Integer, ByVal Seq1x As Long, ByVal Seq2x As Long, ByVal Seq3x As Long, ByRef CS As Byte, ByVal UBXOSNW As Long, ByRef xoverseqnumwx As Byte, ByRef FSSRDP As Byte) As Long 'ByVal var3x As Integer

Public Declare Function FindSubSeqPB5 Lib "dna5.dll" (ByRef AH As Long, ByVal ubfss As Integer, ByVal XoverWindow As Long, ByVal UBCS1 As Long, ByVal LenStrainseq0 As Long, ByVal NextnoX As Integer, ByVal Seq1x As Long, ByVal Seq2x As Long, ByVal Seq3x As Long, ByRef CS As Byte, ByVal UBXOSNW As Long, ByRef xoverseqnumwx As Byte, ByRef FSSRDP As Byte) As Long  'ByVal var3x As Integer


Public Declare Function FindSubSeqP3 Lib "dna5.dll" (ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer) As Long 'ByVal var3x As Integer

Public Declare Function XOHomologyP Lib "dna5.dll" (ByVal Inlyerx As Integer, ByVal LenStrainseqx As Long, ByVal LenXoverSeqx As Long, ByVal XOverWindowX As Integer, ByRef xoverseqnumwx As Byte, ByRef xoverhomologynumx As Long) As Integer
Public Declare Function XOHomologyPB5 Lib "dna5.dll" (ByVal Inlyerx As Integer, ByVal LenStrainseqx As Long, ByVal LenXoverSeqx As Long, ByVal XOverWindowX As Integer, ByRef xoverseqnumwx As Byte, ByRef xoverhomologynumx As Long) As Integer
Public Declare Function CountVSites Lib "dna5.dll" (ByVal x As Long, ByVal LenStrainseqx As Long, ByVal sa As Long, ByVal SB As Long, ByVal SX As Long, ByVal Epos As Long, ByVal UBSN As Long, ByRef SeqNum As Integer) As Long
' CountVSites(int x, int lseq, int SA, int SB, int SX,                                                                                      int Epos, int UBSN, short int *Seqnum)
Public Declare Function FindFirstCOP Lib "dna5.dll" (ByVal x As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LenXoverSeq As Long, ByVal UBXOHN As Long, ByRef XOverHomologyNum As Long) As Long
Public Declare Function ViterbiCP Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef OptXY As Double, ByRef RecodeB As Byte, ByRef LaticeXY As Double, ByRef TransitionM2 As Double, ByRef EmissionM2 As Double, ByRef LaticeAB As Double) As Double
Public Declare Function ViterbiCPF Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef OptXY As Single, ByRef RecodeB As Byte, ByRef LaticeXY As Single, ByRef TransitionM2 As Single, ByRef EmissionM2 As Single, ByRef LaticeAB As Single) As Single

Public Declare Function FindNextP Lib "dna5.dll" (ByVal XOHN As Long, ByVal StartPosition As Long, ByVal HighHomolSeqPair As Integer, ByVal MedHomolSeqPair As Integer, ByVal LowHomolSeqPair As Integer, ByVal LenXoverSubSeq As Long, ByVal SizeOfXoverWindow As Integer, ByRef XOverHomologyNumArray As Long) As Long
Public Declare Function FindNextPB Lib "dna5.dll" (ByVal XOHN As Long, ByVal StartPosition As Long, ByVal HighHomolSeqPair As Integer, ByVal MedHomolSeqPair As Integer, ByVal LowHomolSeqPair As Integer, ByVal LenXoverSubSeq As Long, ByVal SizeOfXoverWindow As Integer, ByRef XOverHomologyNumArray As Long) As Long

Public Declare Function FastSimilarityBP Lib "dna5.dll" (ByVal DF As Long, ByVal Reps As Long, ByVal ISDim As Long, ByVal NextNo As Long, ByVal UBX As Long, ByRef Valid As Single, ByRef Diffs As Single, ByRef XCVal As Integer, ByRef IntegerSeq As Integer, ByRef CompressValid As Byte, ByRef CompressDiffs As Byte, ByRef DistCheckB As Single, ByRef WeightMod As Long) As Double
Public Declare Function DefineEventP Lib "dna5.dll" (ByVal ShortOutFlag As Long, ByVal LongWindedFlag As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LowHomol As Long, ByVal TargetX As Long, ByVal CircularFlag As Long, ByVal XX As Long, ByVal XoverWindow As Long, ByVal LenSeq As Long, ByVal LenXoverSeq As Long, ByVal SeqDaughter As Long, ByVal SeqMinorP As Long, ByRef EndFlag As Long, ByRef BE As Long, ByRef EN As Long, ByrefNCommon As Long, ByrefXOverLength As Long, ByRef XoverSeqNum As Byte, ByRef XDiffPos As Long, ByRef XOverHomologyNum As Long) As Double
Public Declare Function DefineEventP2 Lib "dna5.dll" (ByVal UBXOHN As Long, ByVal ShortOutFlag As Long, ByVal LongWindedFlag As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LowHomol As Long, ByVal TargetX As Long, ByVal CircularFlag As Long, ByVal XX As Long, ByVal XoverWindow As Long, ByVal LenSeq As Long, ByVal LenXoverSeq As Long, ByVal SeqDaughter As Long, ByVal SeqMinorP As Long, ByRef EndFlag As Long, ByRef BE As Long, ByRef EN As Long, ByrefNCommon As Long, ByrefXOverLength As Long, ByRef XoverSeqNum As Byte, ByRef XOverHomologyNum As Long) As Long

Public Declare Function TreeReps Lib "dna5.dll" (ByVal NSeqs As Long, ByVal Reps As Long, ByVal BSRndNumSeed As Long, ByVal NameLen As Long, ByRef DstMat As Single, ByVal LTI As Long, ByRef LTree As Long, ByRef tMatch As Byte, ByRef DLen As Single) As Long
Public Declare Function TreeRepsP Lib "dna5.dll" (ByVal NSeqs As Long, ByVal Reps As Long, ByVal BSRndNumSeed As Long, ByVal NameLen As Long, ByRef DstMat As Single, ByVal LTI As Long, ByRef LTree As Long, ByRef tMatch As Byte, ByRef DLen As Single) As Long
Public Declare Function MakeLowCI Lib "dna5.dll" (ByVal Y As Long, ByVal TargetNum As Long, ByVal oPermNum As Long, ByVal PNA As Long, ByVal UBMS As Long, ByRef MapS As Single, ByVal UBPVM As Long, ByRef PValMap As Single) As Long
Public Declare Function MakeHighCI Lib "dna5.dll" (ByVal PermNum As Long, ByVal Y As Long, ByVal TargetNum As Long, ByVal oPermNum As Long, ByVal PNA As Long, ByVal UBMS As Long, ByRef MapS As Single, ByVal UBPVM As Long, ByRef PValMap As Single) As Long

'static MATHFUNCSDLL_API int _stdcall MakeLowCI(int Y,                  int TargetNum,         int oPermNum,            int PNA, int UBMS,                float *MapS,           int UBPVM, float *PValMap);
        

'TreeReps(int                                         NSeqs,               int Reps,         int BSRndNumSeed,         int NameLen,      float *DstMat, int LTI, int *LTree, char *tMatch)
Public Declare Function CalcKMaxP Lib "dna5.dll" (ByVal GCMissmatchPenX As Integer, ByVal XOLen As Long, ByVal MCFlag As Integer, ByVal MCCorrection As Long, ByVal LowestProb As Double, ByRef PCO As Double, ByRef HiFragScore As Long, ByRef Critval As Double, ByRef MissPen As Double, ByRef LLx As Double, ByRef KMaxX As Double, ByRef NDiffx As Long, ByRef highenoughx As Long) As Long
Public Declare Function CollapseNodesXP Lib "dna5.dll" (ByVal NextNo As Long, ByVal Cutoff As Single, ByRef T As Long, ByRef DLen As Single, ByRef CMat As Single, ByRef AMat As Single, ByRef TraceBak As Single) As Long
Public Declare Function CollapseNodesXP2 Lib "dna5.dll" (ByVal NextNo As Long, ByVal Cutoff As Single, ByRef T As Long, ByRef DLen As Single, ByRef CMat As Single, ByRef PAMat As Single, ByRef TraceBak As Single) As Long
Public Declare Function CollapseNodesXP3 Lib "dna5.dll" (ByVal NextNo As Long, ByVal Cutoff As Single, ByRef T As Long, ByRef DLen As Single, ByRef CMat As Single, ByRef PAMat As Single, ByRef TraceBak As Single) As Long

Public Declare Function DoPerms3P Lib "dna5.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByVal NumberOfPermutations2 As Long, ByRef PScoreHolderArray As Long, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long
Public Declare Function MakeBanWinP Lib "dna5.dll" (ByVal UBBW As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal HWindowWidth As Long, ByVal LS As Long, ByVal LenXoverSeq As Long, ByRef BanWin As Long, ByRef MDMap As Byte, ByRef MissingData As Byte, ByRef XPosDiff As Long, ByRef XDiffPos As Long) As Long
Public Declare Function FindSubSeqP2 Lib "dna5.dll" (ByVal UBXSN As Long, ByVal UBVO As Long, ByVal UBCS As Long, ByVal XoverWindow As Long, ByVal LenSeq As Long, ByVal A As Long, ByVal b As Long, ByVal C As Long, ByRef AH As Long, ByRef CompressedSeqs3 As Byte, ByRef XoverSeqNumW As Byte, ByRef XDP As Long, ByRef XPD As Long, ByRef SkipTrip As Byte, ByRef FindSS0 As Long) As Long
Public Declare Function ClearDeleteArray Lib "dna5.dll" (ByVal LenToClear As Long, ByRef DeleteArray As Long) As Long
Public Declare Function ClearDeleteArrayB Lib "dna5.dll" (ByVal LenToClear As Long, ByRef DeleteArray As Byte) As Long
Public Declare Function DelPValsP Lib "dna5.dll" (ByVal GCMaxOverlapFrags As Integer, ByVal Y As Long, ByVal x As Long, ByVal LS As Long, ByRef PVals As Double, ByRef FragCount As Long, ByRef FragSt As Long, ByRef FragEn As Long, ByRef MaxScorePos As Long, ByRef DeleteArray As Long) As Long
Public Declare Function MakeSubProbP Lib "dna5.dll" (ByVal x As Long, ByVal LS As Long, ByVal LenXoverSeq As Long, ByVal BTarget As Long, ByVal ETarget As Long, ByRef SubSeq As Byte, ByRef LL As Double, ByRef KMax As Double, ByRef MissPen As Double, ByRef Critval As Double) As Double
Public Declare Function MakeDeleteArrayP Lib "dna5.dll" (ByVal FragSt As Long, ByVal FragEn As Long, ByVal FragCount As Long, ByRef DeleteArray As Long) As Long
Public Declare Function FindMissingP Lib "dna5.dll" (ByVal LS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal Z As Long, ByVal EN As Long, ByRef MissingData As Byte) As Long
Public Declare Function CheckSplitP Lib "dna5.dll" (ByVal step As Long, ByVal LS As Long, ByVal BE As Long, ByVal EN As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef Split As Long, ByRef MissingData As Byte) As Long
Public Declare Function GCCalcPValP Lib "dna5.dll" (ByVal LSeqX As Long, ByVal LenXoverX As Long, ByRef FragMaxScorex As Long, ByRef PValsx As Double, ByRef FragCountx As Long, ByRef KMaxX As Double, ByRef LLx As Double, ByRef highenoughx As Long, ByRef Critval As Double) As Double
Public Declare Function ChiPVal2P Lib "dna5.dll" (ByVal x As Double) As Double
Public Declare Function UpdatePlotsCP Lib "dna5.dll" (ByVal UPArrayDim As Long, ByVal UPArrayDimXFact As Single, ByVal Pict As Long, ByVal LSeq As Long, ByVal P1 As Integer, ByVal P2 As Integer, ByVal P3 As Integer, ByVal P4 As Integer, ByVal StepSize As Long, ByVal XFactor As Single, ByVal oDMax As Single, ByVal oPMax As Single, ByVal MaxHits As Long, ByRef Decompress As Long, ByRef PDistPlt As Single, ByRef ProbPlt As Single, ByRef HitPlt As Long) As Long
Public Declare Function UpdatePlotsCP2 Lib "dna5.dll" (ByVal UPArrayDim As Long, ByVal UPArrayDimXFact As Single, ByVal Pict As Long, ByVal LSeq As Long, ByVal P1 As Integer, ByVal P2 As Integer, ByVal P3 As Integer, ByVal P4 As Integer, ByVal StepSize As Long, ByVal XFactor As Single, ByVal oDMax As Single, ByVal oPMax As Single, ByVal MaxHits As Long, ByRef Decompress As Long, ByRef PDistPlt As Single, ByRef ProbPlt As Single, ByRef HitPlt As Long, ByRef LL1 As Single, ByRef LL2 As Single, ByRef LL3 As Single) As Long

'int  MyMathFuncs::UpdatePlotsCP(                   HDC Pict, int LSeq,            short int P1, short int P2, short int P3,                               short int P4, int StepSize, float XFactor,                         float oDMax, float oPMax, int MaxHits,                                   int *Decompress, float *PDistPlt, float *ProbPlt, int *HitPlt )

Public Declare Function AlistGC Lib "dna5.dll" (ByVal GCIndelFlag As Byte, ByVal GCMissmatchPen As Integer, ByVal GCDimSize As Long, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Single, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBFSSGC2 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef FSSGC As Byte) As Long
Public Declare Function AlistGC2 Lib "dna5.dll" (ByVal UBSLPV1 As Long, ByRef StoreLPV As Double, ByVal GCIndelFlag As Byte, ByVal GCMissmatchPen As Integer, ByVal GCDimSize As Long, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Single, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBFSSGC2 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef FSSGC As Byte) As Long

'static MATHFUNCSDLL_API int _stdcall AlistGC(char GCIndelFlag,               short int GCMissmatchPen, int GCDimSize,                short int *AList,        int AListLen,         int StartP,           int EndP,             int NextNo,          double SubThresh,         unsigned char *RL, int CircularFlag,          int MCCorrection,           int MCFlag,           double LowestProb,            int TargetX, int LenStrainseq0,                  int ShortOutFlag,           int UBFSSGC,                 int UBCS, unsigned char *CS, unsigned char *FSSGC);

Public Declare Function AEFirstAlistGC Lib "dna5.dll" (ByVal GCIndelFlag As Byte, ByVal GCMissmatchPen As Integer, ByVal GCDimSize As Long, ByVal UBDP As Long, ByRef DP2 As Byte, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Single, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBFSSGC2 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef FSSGC As Byte) As Long

'Public Declare Function AlistMC2 Lib "dna5.dll" (ByRef Worthwhilescan As Byte, ByVal StartP As Long, ByVal EndP As Long, ByVal LongWindedFlag As Long, ByVal ShortOutFlag As Integer, ByVal MaxABWin As Long, ByVal HWindowWidth As Long, ByVal lHWindowWidth As Long, ByVal CriticalDiff As Long, ByVal FindallFlag As Byte, ByVal NextNo As Long, ByVal UBSLPV As Long, ByRef StoreLPV As Double, ByRef AList As Integer, ByVal AListLen As Long, ByRef RL As Byte, ByVal CircularFlag As Integer, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal UCTHresh As Double, ByVal LowestProb As Double, ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSSMC As Long, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByRef Chimap As Long, ByRef ChiTable2 As Single) As Long

Public Declare Function AEFirstAlistMC Lib "dna5.dll" (ByVal SEventNumber As Long, ByVal LongWindedFlag As Long, ByVal ShortOutFlag As Integer, ByVal MaxABWin As Long, ByVal HWindowWidth As Long, ByVal lHWindowWidth As Long, ByVal CriticalDiff As Long, ByVal FindallFlag As Byte, ByVal UBDP As Long, ByRef DP2 As Byte, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSSMC As Long, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByRef MissingData As Byte, ByRef Chimap As Long, ByRef ChiTable2 As Single) As Long
Public Declare Function AEFirstAlistChi Lib "dna5.dll" (ByVal SEventNumber As Long, ByVal LongWindedFlag As Long, ByVal ShortOutFlag As Integer, ByVal MaxABWin As Long, ByVal HWindowWidth As Long, ByVal lHWindowWidth As Long, ByVal CriticalDiff As Long, ByVal FindallFlag As Byte, ByVal UBDP As Long, ByRef DP2 As Byte, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSSMC As Long, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByRef MissingData As Byte, ByRef Chimap As Long, ByRef ChiTable2 As Single) As Long

'int MyMathFuncs::AEFirstAlistMC(                         int LongWindedFlag, short int ShortOutFlag, int MaxABWin, int HWindowWidth, int lHWindowWidth, int CriticalDiff, unsigned char FindallFlag,                                                         int UBDP, unsigned char *DP2, short int *AList, int AListLen, int StartP, int EndP, int NextNo, double SubThresh, unsigned char *RL, int CircularFlag, int MCCorrection, int MCFlag, double LowestProb,                                                                                                   double MCWinFract, int MCWinSize, short int MCProportionFlag, int LenStrainseq0,                                             int UBCS, unsigned char *CS, int UBFSSMC, unsigned char *FSSMC, short int *SeqNum, int *Chimap, float *ChiTable2) {
    

'/int MyMathFuncs::AEFirstAlistGC                   (char GCIndelFlag, short int GCMissmatchPen,                     int GCDimSize, int UBDP, unsigned char *DP2, short int            *AList, int AListLen,                        int StartP, int EndP,                      int NextNo, double SubThresh,           unsigned char *RL, int CircularFlag, int MCCorrection, int MCFlag, double LowestProb, int TargetX,                                                              int LenStrainseq0, int ShortOutFlag, int UBFSSGC, int UBCS, unsigned char *CS, unsigned char *FSSGC) {
    

Public Declare Function UpdateCountsP Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef LaticePath As Long, ByRef RecodeB As Byte, ByRef TransitionCount As Double, ByRef StateCount As Double) As Double
Public Declare Function UpdateCountsPF Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef LaticePath As Long, ByRef RecodeB As Byte, ByRef TransitionCount As Single, ByRef StateCount As Single) As Single

Public Declare Function ReverseCP Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef ValXY As Double, ByRef OptXY As Double, ByRef RecodeB As Byte, ByRef LaticeXY As Double, ByRef TransitionM2 As Double, ByRef EmissionM2 As Double) As Double
Public Declare Function ReverseCPF Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef ValXY As Single, ByRef OptXY As Single, ByRef RecodeB As Byte, ByRef LaticeXY As Single, ByRef TransitionM2 As Single, ByRef EmissionM2 As Single) As Single

Public Declare Function ForwardCP Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef ValXY As Double, ByRef OptXY As Double, ByRef RecodeB As Byte, ByRef LaticeXY As Double, ByRef TransitionM2 As Double, ByRef EmissionM2 As Double) As Double
Public Declare Function ForwardCPF Lib "dna5.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef ValXY As Single, ByRef OptXY As Single, ByRef RecodeB As Byte, ByRef LaticeXY As Single, ByRef TransitionM2 As Single, ByRef EmissionM2 As Single) As Single

Public Declare Function MakeBinArrayP Lib "dna5.dll" (ByVal Seq1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByRef SeqNum As Integer, ByRef BinArray As Byte) As Long
Public Declare Function MakeBinArrayP2 Lib "dna5.dll" (ByVal Seq1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByRef SeqNum As Integer, ByRef BinArray As Byte) As Long
Public Declare Function MakeNumSeqP Lib "dna5.dll" (ByVal NextNo As Long, ByVal SLen As Long, ByVal uboundnumseq1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef ConvNumSeq As Byte, ByRef SeqNum As Integer, ByRef NumSeq As Byte) As Long
Public Declare Function MakeBinArrayP4 Lib "dna5.dll" (ByVal Seq1 As Long, ByVal NextNo As Long, ByVal UBIS4 As Long, ByVal UBBC As Long, ByVal UBBA As Long, ByRef MaskSeq As Integer, ByRef ISeq4 As Integer, ByRef BinArray As Byte, ByRef BinConverter4 As Byte) As Long
'MakeBinArrayP4(int Seq1, int  Nextno, int UBIS4, int UBBC, int UBBA, short int *Maskseq, short int *ISeq4, unsigned char *BinArray,  unsigned char *BinConverter4)
Public Declare Function CleanChiVals Lib "dna5.dll" (ByVal LenXoverSeq As Long, ByVal LenStrainSeqSeq0 As Long, ByRef Chivals As Double) As Long
Public Declare Function CleanChiVals2 Lib "dna5.dll" (ByVal LenXoverSeq As Long, ByVal LenStrainSeqSeq0 As Long, ByRef Chivals As Double) As Long

'CleanChiVals(int                                     LenXoverSeq, int LenSeq, double *ChiVals);
'int  MyMathFuncs::FastRecCheckMC(                   int LongWindedFlag,             double *BQPV,         int EarlyBale,          double UCTHresh,            short int MCFlag, short int ShortOutFlag,         int MCCorrection, double LowestProb,                        short int CircularFlag, int NextNo,                    int MaxABWin,           int HWindowWidthX,           int lHWindowWidth,
Public Declare Function FastRecCheckMC Lib "dna5.dll" (ByVal SEventNumber As Long, ByVal LongWindedFlag As Long, ByRef BQPV As Double, ByVal EarlyBale As Long, ByVal UCThresh As Double, ByVal MCFlag As Integer, ByVal ShortOutFlag As Integer, ByVal MCCorrection As Long, ByVal LowestProb As Double, ByVal CircularFlag As Integer, ByVal NextNo As Long, ByVal MaxABWin As Long, ByVal HWindowWidthX As Long, ByVal lHWindowWidth As Long, _
 ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal CriticalDiffX As Long, ByVal FindallFlag As Byte, ByVal UBFSSMC As Long, ByVal UBCS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef CS As Byte, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByVal UBWS As Long, ByRef Scores As Byte, ByRef Winscores As Long, ByRef XDiffPos As Long, ByRef Chivals As Double, ByRef BanWin As Long, ByRef MDMap As Byte, ByRef ChiTable2 As Single, ByRef Chimap As Long, ByRef mtP As Double, ByRef SmoothChi As Double) As Long

'    double MCWinFract,            int MCWinSize, short int MCProportionFlag,                 int LenStrainSeq0,         int CriticalDiffX,      unsigned char FindallFlag,        int BEP, int ENP,                     int UBFSSMC, int UBCS,                  int Seq1,             int Seq2, int Seq3                  , unsigned char *CS, unsigned char *FSSMC, short int *SeqNum, int UBWS,       unsigned char *Scores,         int *Winscores,                 int *XDiffPos,   double *Chivals      , int UBBW, int *BanWin,                   int UBMDM,   unsigned char *MDMap   , float *ChiTable2, int *Chimap, double *mtP, double *SmoothChi) {
Public Declare Function FastRecCheckChim Lib "dna5.dll" (ByRef MissingData As Byte, ByRef XPD As Long, ByRef LXOS As Long, ByVal YP As Long, ByVal SEventNumber As Long, ByVal LongWindedFlag As Long, ByRef BQPV As Double, ByVal EarlyBale As Long, ByVal UCThresh As Double, ByVal MCFlag As Integer, ByVal ShortOutFlag As Integer, ByVal MCCorrection As Long, ByVal LowestProb As Double, ByVal CircularFlag As Integer, ByVal NextNo As Long, ByVal MaxABWin As Long, ByVal HWindowWidthX As Long, ByVal lHWindowWidth As Long, _
 ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal CriticalDiffX As Long, ByVal FindallFlag As Byte, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef CS As Byte, ByRef FSSRDP As Byte, ByRef SeqNum As Integer, ByVal UBWS As Long, ByRef Scores As Byte, ByRef Winscores As Long, ByVal UBXDP As Long, ByRef XDP As Long, ByRef Chivals As Double, ByRef BanWin As Long, ByRef MDMap As Byte, ByRef ChiTable2 As Single, ByRef Chimap As Long, ByRef mtP As Double, ByRef SmoothChi As Double) As Long
    
'FastRecCheckChim(                                       int *LXOS,            int YP,           int SEN,                int LongWindedFlag,           double *BQPV,            int EarlyBale,          double UCTHresh,        short int MCFlag,      short int ShortOutFlag,                int MCCorrection,      double LowestProb,       short int CircularFlag,               int NextNo,           int MaxABWin,          int HWindowWidthX,              int lHWindowWidth,
'double MCWinFract,            int MCWinSize,      short int MCProportionFlag,           int LenStrainSeq0,              int CriticalDiffX, unsigned char FindallFlag,           int UBFSSRDP,           int UBCS,           int Seq1,          int Seq2,           int Seq3, unsigned char *CS, unsigned char *FSSRDP,    short int *SeqNum,            int UBWS, unsigned char *Scores,          int *Winscores,     int UBXDP,             int *XDP, double *Chivals, int *BanWin,                     unsigned char *MDMap,       float *ChiTable2,         int *Chimap, double *mtP, double *SmoothChi)
    
    
Public Declare Function CopyCharArray Lib "dna5.dll" (ByVal UB1 As Long, ByVal UB2 As Long, ByRef FromArray As Byte, ByRef ToArray As Byte) As Long
'Public Declare Function MakeBinArrayP2 Lib "DNA5.dll" (ByVal ubba As Long, ByVal Seq1 As Long, ByVal LSeq As Long, ByVal Nextno As Long, ByRef Maskseq As Integer, ByRef SeqNum As Integer, ByRef BinArray As Byte) As Long

Public Declare Function MakeBinArray2P Lib "dna5.dll" (ByVal UBPV1 As Long, ByRef PermValid As Single, ByVal UBDP1 As Long, ByRef DoPairs As Byte, ByVal Seq1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByRef SeqNum As Integer, ByRef BinArray As Byte, ByRef SLookupNum As Long, ByRef SLookup As Long, ByRef IsIn As Byte, ByRef TraceSub As Long, ByRef ActualSize As Long, ByVal MinSeqSize As Long) As Long
Public Declare Function MakeBinArray3P Lib "dna5.dll" (ByVal sNextno As Long, ByVal UBDP1 As Long, ByRef DoPairs As Byte, ByVal Seq1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByRef SeqNum As Integer, ByRef BinArray As Byte, ByRef SLookupNum As Long, ByRef SLookup As Long, ByRef TraceSub As Long, ByRef ActualSize As Long, ByVal MinSeqSize As Long) As Long

'MakeBinArray(ByVal Seq1, ByVal LSeq, ByVal Nextno, byref Maskseq, byref SeqNum, byref BinArray)
Public Declare Function FindSubSeqP4 Lib "dna5.dll" (ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer, ByRef BinArray As Byte) As Long  'ByVal var3x As Integer
Public Declare Function FindSubSeqP5 Lib "dna5.dll" (ByVal UBXSN As Long, ByVal UBBA As Long, ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer, ByRef BinArray3 As Byte, ByRef BinArray4 As Byte, ByRef PairwiseTripArray As Byte, ByRef SS255RDP As Byte) As Long 'ByVal var3x As Integer
Public Declare Function FindSubSeqP6 Lib "dna5.dll" (ByVal UBXSN As Long, ByVal UBBA As Long, ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer, ByRef BinArray3 As Byte, ByRef BinArray4 As Byte, ByRef BinArray5 As Byte, ByRef PairwiseTripArray63 As Byte, ByRef SS255RDP As Byte) As Long 'ByVal var3x As Integer
Public Declare Function FindSubSeqP7 Lib "dna5.dll" (ByVal UBXOSN1 As Long, ByVal UBXOSN2 As Long, ByVal UBXOSN3 As Long, ByRef LenXOverSeqG As Long, ByVal ElementNum As Long, ByRef GoOnG As Byte, ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByRef ElementSeq As Long, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer, ByRef BinArray As Byte) As Long 'ByVal var3x As Integer
Public Declare Function FindSubSeqP8 Lib "dna5.dll" (ByVal UBXOSN1 As Long, ByVal UBXOSN2 As Long, ByVal UBXOSN3 As Long, ByRef LenXOverSeqG As Long, ByVal ElementNum As Long, ByRef GoOnG As Byte, ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByRef ElementSeq2 As Long, ByRef ElementSeq As Long, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer, ByRef BinArray As Byte) As Long 'ByVal var3x As Integer

Public Declare Function MakeISeq4P Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBNS As Long, ByVal UBIS4 As Long, ByRef SeqCompressor4 As Integer, ByRef ISeq4 As Integer, ByRef NumSeq As Byte) As Long
Public Declare Function MakeISeq3P Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBNS As Long, ByVal UBIS4 As Long, ByRef SeqCompressor4 As Integer, ByRef ISeq4 As Integer, ByRef NumSeq As Byte) As Long


Public Declare Function MakeXPD2 Lib "dna5.dll" (ByVal LenXOSeq As Long, ByRef xDiffposx As Long, ByRef xPosdiffx As Long) As Long    'ByVal var3x As Integer

Public Declare Function AddjustCXO Lib "dna5.dll" (ByVal NextNo As Long, ByVal WinPP As Long, ByVal LowestProb As Double, ByVal UBDS1 As Long, ByVal UBDS2 As Long, ByRef DoneSeq As Byte, ByVal UBTD1 As Long, ByVal UBTD2 As Long, ByRef TempDone As Byte, ByRef oRecombNo As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Byte, ByVal UBTS As Long, ByRef TraceSub As Long, ByRef tCurrentxover As Integer, ByVal UBTXOL1 As Long, ByVal UBTXOL2 As Long, ByRef TempXOList As XOverDefine, ByRef PCurrentXover As Integer, ByVal UBPXO1 As Long, ByVal UBPXO2 As Long, ByRef PXOList As XOverDefine) As Long 'ByVal var3x As Integer

'AddjustCXO(                                           int NextNo,            int WinPP, double LowestProb                   ,int UBDS1, int UBDS2,       unsigned char *DoneSeq, int UBTD1                 , int UBTD2, unsigned char *TempDone      , int *oRecombNo, int *RNum,                      int*RList,   unsigned char *DoPairs, int UBTS,                 int *TraceSub, short int *tCurrentxover,             int UBTXOL1, int UBTXOL2                ,  XOVERDEFINE *TempXOList,        short int *PCurrentXOver, int UBPXO1, int UBPXO2, XOVERDEFINE *PXOList) {


Public Declare Function RecodeNucsLong Lib "dna5.dll" (ByVal Y As Long, ByVal LSeq As Long, ByVal UBRecoded As Long, ByVal UBReplace As Long, ByRef tSeqnum As Integer, ByRef NucMat As Byte, ByRef Replace As Byte, ByRef Recoded As Byte) As Long
'RecodeNucsLong(                                         int Y,            int LSeq,          int UBRecoded,           int UBReplace,     short int *tSeqnum,  unsigned char *NucMat,  unsigned char *Replace, unsigned char *Recoded)

Public Declare Function GoLeftP Lib "dna5.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal CircularFlag As Long, ByVal StartPos As Long, ByVal LS As Long, ByVal UBMD As Long, ByRef MissingData As Byte) As Long

Public Declare Function MakeCompressSeqP Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBR As Long, ByRef Recoded As Byte, ByVal UBCS As Long, ByRef CompressSeq As Byte, ByVal UBCR1 As Long, ByVal UBCR2 As Long, ByRef CompressorRDP As Byte) As Long
'int MyMathFuncs::MakeCompressSeqP                     (int NextNo              , int UBR,       unsigned char *Recoded, int UBCS,   unsigned char *CompressSeq,          int UBCR1, int UBCR2,             unsigned char *CompressorRDP){

Public Declare Function MakeAListISE Lib "dna5.dll" (ByRef RestartPos As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte, ByVal UBPV As Long, ByRef PermValid As Single) As Long

Public Declare Function MakeAListASEF Lib "dna5.dll" (ByVal BAL As Long, ByRef RestartPos As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte, ByRef tMaskseq As Byte, ByVal UBPV As Long, ByRef PermValid As Single, ByRef PermDIffs As Single) As Long
Public Declare Function MakeAListASES Lib "dna5.dll" (ByVal BAL As Long, ByRef RestartPos As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte, ByRef DoPairs2 As Byte, ByRef tMaskseq As Byte, ByVal UBPV As Long, ByRef PermValid As Single, ByRef PermDIffs As Single) As Long

'MakeAListASEF(                                          int oNextno,          int NextNo,           int MinSeqSize,           int UBAL,        short int *AList,      int UBDP,       unsigned char *DP, unsigned char *tMaskseq            ,int UBPV, float *PermValid, float *PermDiffs) {
Public Declare Function MakeAListIS Lib "dna5.dll" (ByRef RestartPos As Long, ByVal UBPB As Long, ByRef ProgBinRead As Byte, ByRef TraceSub As Long, ByVal WinPP As Long, ByRef RNum As Long, ByVal UBRL As Long, ByRef RList As Long, ByVal UBAnL As Long, ByRef Analysislist As Integer, ByVal TripListLen As Long, ByRef Worthwhilescan As Byte, ByRef ActualSeqSize As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte) As Long
Public Declare Function MakeAListISP Lib "dna5.dll" (ByVal Prg As Long, ByRef RestartPos As Long, ByVal UBPB As Long, ByRef ProgBinRead As Byte, ByRef TraceSub As Long, ByVal WinPP As Long, ByRef RNum As Long, ByVal UBRL As Long, ByRef RList As Long, ByVal UBAnL As Long, ByRef Analysislist As Integer, ByVal TripListLen As Long, ByRef Worthwhilescan As Byte, ByRef ActualSeqSize As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte) As Long
Public Declare Function MakeAListISP2 Lib "dna5.dll" (ByVal Prg As Long, ByRef RestartPos As Long, ByVal UBPB As Long, ByRef ProgBinRead As Byte, ByRef TraceSub As Long, ByVal WinPP As Long, ByRef RNum As Long, ByVal UBRL As Long, ByRef RList As Long, ByVal UBAnL As Long, ByRef Analysislist As Integer, ByVal TripListLen As Long, ByRef Worthwhilescan As Byte, ByRef ActualSeqSize As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByVal UBAL2 As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte) As Long

Public Declare Function MakeAListOSP Lib "dna5.dll" (ByVal UBAL As Long, ByVal BusyWithExcludes As Long, ByVal UBSV As Long, ByRef SubValid As Single, ByVal sNextno As Long, ByVal UBTS1 As Long, ByVal Prg As Long, ByRef RestartPos As Long, ByVal UBPB As Long, ByRef ProgBinRead As Byte, ByRef TraceSub As Long, ByVal WinPP As Long, ByRef RNum As Long, ByVal UBRL As Long, ByRef RList As Long, ByVal UBAnL As Long, ByRef Analysislist As Integer, ByVal TripListLen As Long, ByRef Worthwhilescan As Byte, ByRef ActualSeqSize As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal MinSeqSize As Long, ByVal UBAL As Long, ByRef AList As Integer, ByVal UBDP As Long, ByRef DoPairs As Byte) As Long



'MakeAListIS(int UBPB, unsigned char *ProgBinRead,                                                 int *TraceSub,            int WinPP, int *RNum, int UBRL,                               int *RList,         int UBAnL ,          int *Analysislist,               int TripListLen,unsigned char *Worthwhilescan,int       *ActualSeqSize,int              PermNextno,           int NextNo,             int MinSeqSize,       int UBAL,               short int *AList,     int UBDP, unsigned char *DoPairs) {

'MakeAListISE(int PermNextno, int NextNo,                                               int MinSeqSize, int UBAL, short int *AList, int UBDP,                         unsigned char *DoPairs, int UBPV, float *PermValid);

Public Declare Function FastRecCheckP Lib "dna5.dll" (ByVal CircularFlag As Long, ByVal DoAllFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal EarlyBale As Long, ByVal UCThresh As Double, ByVal LowestProb As Double, ByVal NextNo As Long, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByVal UBXSNW As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal lenstrainseq0PlusOne As Long, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, ByRef XoverSeqNum As Integer, ByRef XoverSeqNumW As Byte, ByVal UBXOHN As Long, ByRef XOverHomologyNum As Long, ByRef FSSRDP As Byte, _
ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double, ByRef BQPV As Double) As Long

Public Declare Function AEFirstRDP Lib "dna5.dll" (ByVal Seq1 As Long, ByVal MinDiffs As Long, ByVal MinSeqSize As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByVal UBRL As Long, ByRef RL As Long, ByVal UBDP As Long, ByRef DP As Byte, ByRef DP2 As Byte, ByVal UBPV As Long, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef tMaskseq As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long

Public Declare Function AEFirstRDP2 Lib "dna5.dll" (ByVal Seq1 As Long, ByVal MinDiffs As Long, ByVal MinSeqSize As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByVal UBRL As Long, ByRef RL As Long, ByVal UBDP As Long, ByRef DP As Byte, ByRef DP2 As Byte, ByVal UBPV As Long, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef tMaskseq As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long

Public Declare Function AEFirstRDP3 Lib "dna5.dll" (ByVal Seq1 As Long, ByVal MinDiffs As Long, ByVal MinSeqSize As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByVal UBRL As Long, ByRef RL As Long, ByVal UBDP As Long, ByRef DP As Byte, ByRef DP2 As Byte, ByVal UBPV As Long, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef tMaskseq As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long

Public Declare Function PrimaryRDP3 Lib "dna5.dll" (ByVal Seq1 As Long, ByVal MinDiffs As Long, ByVal MinSeqSize As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByVal UBRL As Long, ByRef RL As Long, ByVal UBDP As Long, ByRef DP As Byte, ByRef DP2 As Byte, ByVal UBPV As Long, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef tMaskseq As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long

Public Declare Function AlistRDP3 Lib "dna5.dll" (ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long

Public Declare Function AlistRDP4 Lib "dna5.dll" (ByVal UBSLPV1 As Long, ByRef StoreLPV As Double, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long


Public Declare Function AEFirstAlistRDP3 Lib "dna5.dll" (ByVal UBDP As Long, ByRef DP2 As Byte, ByRef AList As Integer, ByVal AListLen As Long, ByVal StartP As Long, ByVal EndP As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByRef RL As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long


Public Declare Function AESecondRDP3 Lib "dna5.dll" (ByVal Seq1 As Long, ByVal MinDiffs As Long, ByVal MinSeqSize As Long, ByVal oNextno As Long, ByVal NextNo As Long, ByVal SubThresh As Double, ByVal UBRL As Long, ByRef RL As Long, ByVal UBDP As Long, ByRef DP As Byte, ByRef DP2 As Byte, ByVal UBPV As Long, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef tMaskseq As Byte, ByVal CircularFlag As Long, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal LowestProb As Double, ByVal TargetX As Long, ByVal LenStrainseq0 As Long, ByVal ShortOutFlag As Long, ByVal UBD As Long, ByRef Distance As Single, ByVal UBTD As Long, ByRef TreeDistance As Single, ByVal UBFSSRDP As Long, ByVal UBCS As Long, ByRef CS As Byte, ByRef SeqNum As Integer, ByVal XoverWindow As Long, ByVal XOverWindowX As Integer, _
ByRef FSSRDP As Byte, ByVal ProbEstimateInFileFlag As Long, ByVal UBPE1 As Long, ByVal UBPE2 As Long, ByRef ProbEstimate As Double, ByVal UBFact3x3 As Long, ByRef Fact3X3 As Double, ByRef Fact3 As Double) As Long


'int MyMathFuncs::AEFirstRDP(int Seq1,                                        int MinDIffs,      int MinSeqSize,          int oNextno,           int NextNo, double SubThresh,                 int UBRL,      int *RL,           int UBDP, unsigned char *DP, int UBPV, float *PermDiffs, float *PermValid,                                      unsigned char *tMaskseq, int CircularFlag, int MCCorrection,                          int MCFlag,          double LowestProb, int TargetX,                     int LenStrainseq0,           int ShortOutFlag,           int UBD,          float *Distance,           int UBTD,        float *TreeDistance,             int UBFSSRDP,           int UBCS, unsigned char *CS, short int *Seqnum,                int XoverWindow,     short int XOverWindowX,
'unsigned char *FSSRDP, int ProbEstimateInFileFlag,           int UBPE1,           int UBPE2,         double *ProbEstimate,            int UBFact3x3, double      *Fact3X3,            double *Fact) {
    


'int ProbEstimateInFileFlag,         int UBPE1,           int UBPE2,        double *ProbEstimate,             int UBFact3x3,         double *Fact3X3, double *Fact, double *BQPV);

'FastRecCheckP                                     (int CircularFlag,              int DoAllFlag,          int MCCorrection,          int MCFlag,            int EarlyBale,      double UCThresh,              double LowestProb,     int NextNo,               int TargetX,           int LenStrainseq0,            int ShortOutFlag,            int UBD,          float *Distance,          int UBTD         , float *TreeDistance,                 int UBFSSRDP,          int UBCS,          int UBXSNW,        unsigned char *CS, short int *Seqnum,          int Seq1, int Seq2,                   int Seq3, int LenStrainSeq                       , int XoverWindow, short int XOverWindowX,                    short int *XoverSeqNum, char *XoverSeqNumW,                  int UBXOHN, int *XOverHomologyNum                  , unsigned char *FSSRDP, int ProbEstimateInFileFlag, int UBPE1, int UBPE2, double *ProbEstimate, int UBFact3x3, double *Fact3X3, double *Fact, double *BQPV);


Public Declare Function AlistMC2 Lib "dna5.dll" (ByRef Worthwhilescan As Byte, ByVal StartP As Long, ByVal EndP As Long, ByVal LongWindedFlag As Long, ByVal ShortOutFlag As Integer, ByVal MaxABWin As Long, ByVal HWindowWidth As Long, ByVal lHWindowWidth As Long, ByVal CriticalDiff As Long, ByVal FindallFlag As Byte, ByVal NextNo As Long, ByVal UBSLPV As Long, ByRef StoreLPV As Double, ByRef AList As Integer, ByVal AListLen As Long, ByRef RL As Byte, ByVal CircularFlag As Integer, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal UCThresh As Double, ByVal LowestProb As Double, ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSSMC As Long, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByRef Chimap As Long, ByRef ChiTable2 As Single) As Long
Public Declare Function AlistMC3 Lib "dna5.dll" (ByVal SEN As Long, ByRef Worthwhilescan As Byte, ByVal StartP As Long, ByVal EndP As Long, ByVal LongWindedFlag As Long, ByVal ShortOutFlag As Integer, ByVal MaxABWin As Long, ByVal HWindowWidth As Long, ByVal lHWindowWidth As Long, ByVal CriticalDiff As Long, ByVal FindallFlag As Byte, ByVal NextNo As Long, ByVal UBSLPV As Long, ByRef StoreLPV As Double, ByRef AList As Integer, ByVal AListLen As Long, ByRef RL As Byte, ByVal CircularFlag As Integer, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal UCThresh As Double, ByVal LowestProb As Double, ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSSMC As Long, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByRef MissingData As Byte, ByRef Chimap As Long, ByRef ChiTable2 As Single) As Long
Public Declare Function AlistChi Lib "dna5.dll" (ByVal SEventNumber As Long, ByRef MissingData As Byte, ByRef Worthwhilescan As Byte, ByVal StartP As Long, ByVal EndP As Long, ByVal LongWindedFlag As Long, ByVal ShortOutFlag As Integer, ByVal MaxABWin As Long, ByVal HWindowWidth As Long, ByVal lHWindowWidth As Long, ByVal CriticalDiff As Long, ByVal FindallFlag As Byte, ByVal NextNo As Long, ByVal UBSLPV As Long, ByRef StoreLPV As Double, ByRef AList As Integer, ByVal AListLen As Long, ByRef RL As Byte, ByVal CircularFlag As Integer, ByVal MCCorrection As Long, ByVal MCFlag As Long, ByVal UCThresh As Double, ByVal LowestProb As Double, ByVal MCWinFract As Double, ByVal MCWinSize As Long, ByVal MCProportionFlag As Integer, ByVal LenStrainseq0 As Long, ByVal UBCS As Long, ByRef CS As Byte, ByVal UBFSSMC As Long, ByRef FSSMC As Byte, ByRef SeqNum As Integer, ByRef Chimap As Long, ByRef ChiTable2 As Single) As Long

'int MyMathFuncs::AlistMC2(                          int StartP,         int EndP,        int LongWindedFlag, short int ShortOutFlag,                    int MaxABWin,              int HWindowWidth,         int lHWindowWidth,                int CriticalDiff, unsigned char FindallFlag,        int NextNo,        int ubslpv,               double *StoreLPV,     short int *AList,      int AListLen,    unsigned char *RL, short int CircularFlag,                int MCCorrection, short int MCFlag, double UCTHresh,                     double LowestProb,            double MCWinFract,             int MCWinSize, short int MCProportionFlag,               int LenStrainseq0,              int UBCS, unsigned char *CS    , int UBFSSMC,    unsigned char *FSSMC, short int *SeqNum,               int *Chimap,               float *ChiTable2) {
    
Public Declare Function GoRightP Lib "dna5.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal CircularFlag As Long, ByVal StartPos As Long, ByVal LS As Long, ByVal UBMD As Long, ByRef MissingData As Byte) As Long
Public Declare Function MakePairsP Lib "dna5.dll" (ByVal NextNo As Long, ByVal DA As Long, ByVal Ma As Long, ByVal Mi As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Byte) As Long
Public Declare Function MarkRemovalsP Lib "dna5.dll" (ByVal NextNo As Long, ByVal WinPP As Long, ByVal RedoListSize As Long, ByRef RedoList As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Byte) As Long
Public Declare Function SignalCountC Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBXO1 As Long, ByVal UBXO2 As Long, ByVal AddNum As Long, ByVal LowestProb As Double, ByRef CurrentXOver As Integer, ByRef XoverList As XOverDefine, ByRef oRecombNo As Long) As Long

Public Declare Function FillSetsP Lib "dna5.dll" (ByVal SZ1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByVal UBCX As Long, ByVal UBXO1 As Long, ByVal UBRL1 As Long, ByVal UBS As Long, ByRef RNum As Long, ByRef RList As Long, ByRef CurrentXOver As Integer, ByRef XoverList As XOverDefine, ByRef RI As Long, ByRef OLSeq As Byte, ByRef Sets As Byte) As Long
Public Declare Function FillSetsP2 Lib "dna5.dll" (ByVal UBXO2 As Long, ByVal SZ1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByVal UBCX As Long, ByVal UBXO1 As Long, ByVal UBRL1 As Long, ByVal UBS As Long, ByRef RNum As Long, ByRef RList As Long, ByRef CurrentXOver As Integer, ByRef XoverList As XOverDefine, ByRef RI As Long, ByRef OLSeq As Byte, ByRef Sets As Byte) As Long
Public Declare Function FillSetsP3 Lib "dna5.dll" (ByVal BE As Long, ByVal EN As Long, ByVal UBXO2 As Long, ByVal SZ1 As Long, ByVal LSeq As Long, ByVal NextNo As Long, ByVal UBCX As Long, ByVal UBXO1 As Long, ByVal UBRL1 As Long, ByVal UBS As Long, ByRef RNum As Long, ByRef RList As Long, ByRef CurrentXOver As Integer, ByRef XoverList As XOverDefine, ByRef RI As Long, ByRef OLSeq As Byte, ByRef Sets As Byte) As Long

Public Declare Function DoSetsAP Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBCX As Long, ByVal OBXO1 As Long, ByVal SZ1 As Long, ByVal LSeq As Long, ByRef RI As Long, ByRef OLSeq As Byte, ByRef Sets As Byte, ByRef DoIt As Byte, ByRef CurrentXOver As Integer, ByRef XoverList As XOverDefine, ByRef DoIt As Byte, ByRef ISeqs As Long) As Long
Public Declare Function MakeNodeDepthC Lib "dna5.dll" (ByVal NextNo As Long, ByVal PermNextno As Long, ByVal UBND1 As Long, ByVal UBDM1 As Long, ByVal UBDD As Long, ByRef DoneDist As Byte, ByRef NodeDepth As Integer, ByRef DMat As Single, ByRef TraceBak As Single) As Long
Public Declare Function MaketFSMat Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBtFM As Long, ByRef FMat As Single, ByRef tFMat As Single) As Long
Public Declare Function MaketFSMatL Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBtFM As Long, ByRef FMat As Single, ByRef tFMat As Single, ByRef RedoList As Long) As Long

Public Declare Function FillRmat Lib "dna5.dll" (ByVal Y As Long, ByVal NextNo As Long, ByVal UBRM1 As Long, ByVal UBRM2 As Long, ByVal UBDM1 As Long, ByVal UBDM2 As Long, ByVal UBDM3 As Long, ByRef RMat As Double, ByRef DistMat As Double, ByRef ZP As Byte) As Long
Public Declare Function CleanXOSNW Lib "dna5.dll" (ByVal LenXOSeq As Long, ByVal XoverWindow As Long, ByVal UBXO1 As Long, ByRef XoverSeqNumW As Byte) As Long

'int MyMathFuncs::CleanXOSNW(int lenxoseq, int xoverwindow, int UBXO1, char *xoverseqnumw)

Public Declare Function FtoFA Lib "dna5.dll" (ByVal NSeqs As Long, ByVal LenStrainseq0 As Long, ByVal UBTS As Long, ByRef TraceSeqs As Long, ByVal UBTFA As Long, ByRef tFAMat As Single, ByVal UBFA As Long, ByRef FAMat As Single) As Long

'FtoFA(                                        int NSeqs, int LenStrainSeq0,                  int UBTS, int *TraceSeqs,               int UBTFA, float *tFAMat                           , int UBFA, float *FAMat);

Public Declare Function FixOverlapsP Lib "dna5.dll" (ByVal DoneThisOne As Byte, ByVal CurBegin As Long, ByVal CurEnd As Long, ByVal CurProg As Long, ByVal x As Long, ByVal Y As Long, ByVal MSX As Long, ByVal LSAdjust As Single, ByVal UBPD As Long, ByVal UBXONC1 As Long, ByVal UBXONC2 As Long, ByRef ProgDo As Byte, ByRef XOverNoComponent As Integer, ByRef MaxXONo As Integer) As Byte

Public Declare Function UpdateDonePVCO Lib "dna5.dll" (ByVal NPVal As Double, ByVal LPV As Double, ByVal Prg As Long, ByVal S1 As Long, ByVal SIP As Long, ByVal UBXOL1 As Long, ByVal UBDPV As Long, ByRef CurrentXOver As Integer, ByRef XoverList As XOverDefine, ByRef DonePVCO As Double) As Double

'UpdateDonePVCO                                        (double NPVal,        double LPV              , int Prg       , int s1,          int SIP,            int UBXOL1, int UBDPV, short int *CurrentXOver,                           XOVERDEFINE *XoverList, double *DonePVCO);

Public Declare Function CheckMatrixP Lib "dna5.dll" (ByRef MinS As Long, ByRef ISeqs As Long, ByVal NextNo As Long, ByVal SCO As Long, ByVal MinSeqSize As Long, ByVal UBMP As Long, ByRef MissPair As Byte, ByVal UBPV As Long, ByRef PermValid As Single, ByVal UBSV As Long, ByRef SubValid As Single, ByVal UBF As Long, ByRef FMat As Single, ByRef SMat As Single, ByRef ValtotF As Long, ByRef ValtotS As Long) As Long



'CheckMatrixP                                        (int * MinS,int *ISeqs,                int NextNo,              int SCO,         int MinSeqSize,             int UBMP,  unsigned char *MissPair,          int UBPV,  float *PermValid,                 int UBSV,          float *SubValid,             int UBF, float *FMat, float                 *SMat,            int *ValtotF, int *ValtotS){
    
  Public Declare Function MakeVarSiteMap Lib "dna5.dll" (ByVal SWin As Long, ByVal LenVarSeq As Long, ByRef VarSiteMap As Integer, ByRef VarSiteSmooth As Single) As Long
   
'int MyMathFuncs::MakeVarSiteMap                       (int SWin, int LenVarSeq,                 short int *VarSiteMap, float *VarSiteSmooth)
    
 Public Declare Function DoRecode Lib "dna5.dll" (ByVal NextNo As Long, ByVal LenStrainseq0 As Long, ByVal UBSN As Long, ByRef SeqNum As Integer, ByVal UBRec As Long, ByRef Recoded As Byte, ByRef NucMat As Byte, ByVal UBRep As Long, ByRef Replace As Byte) As Long
 Public Declare Function DoRecodeP Lib "dna5.dll" (ByVal NextNo As Long, ByVal LenStrainseq0 As Long, ByVal UBSN As Long, ByRef SeqNum As Integer, ByVal UBRec As Long, ByRef Recoded As Byte, ByRef NucMat As Byte, ByVal UBRep As Long, ByRef Replace As Byte) As Long
   
'static MATHFUNCSDLL_API int _stdcall DoRecode(int NextNo, int LenStrainSeq0,                           int UBSN,            short int *SeqNum, int UBRec,        unsigned char *Recoded,     unsigned char *NucMat, int UBRep, unsigned char *Replace);
Public Declare Function CountNucs Lib "dna5.dll" (ByVal NextNo As Long, ByVal LenStrainseq0 As Long, ByVal UBSN As Long, ByRef SeqNum As Integer, ByRef NucMat As Byte, ByVal UBNC As Long, ByRef NucCount As Long) As Long

Public Declare Function MakeLenFrag Lib "dna5.dll" (ByVal LenStrainseq0 As Long, ByVal NextNo As Long, ByVal ABPos As Long, ByVal AEPos As Long, ByRef BCycle As Long, ByRef BoundX As Long, ByVal UBSN21 As Long, ByRef SeqNum2 As Integer, ByVal UBSN As Long, ByRef SeqNum As Integer) As Long
'MakeLenFrag                                     (int LenStrainSeq0, int NextNo,                          int ABPos,           int AEPos        , int *BCycle,             int *BoundX,            int UBSN21,    short int *SeqNum2, int UBSN, short int *SeqNum);
   
'        static MATHFUNCSDLL_API int _stdcall CountNucs(int NextNo, int LenStrainSeq0,                  int UBSN, short int *SeqNum,  unsigned char *NucMat, int           UBNC, int *NucCount);
            
Public Declare Function MakeImageDataP Lib "dna5.dll" (ByVal BkR As Long, ByVal BkG As Long, ByVal BkB As Long, ByVal SX As Long, ByVal SY As Long, ByVal PosE1 As Long, ByVal PosE0 As Long, ByVal PosS1 As Long, ByVal PosS0 As Long, ByVal StS As Long, ByVal StSX As Long, ByVal CurScale As Long, ByVal XAD As Single, ByVal Min As Single, ByVal MR As Single, ByVal UBID1 As Long, ByVal UBID2 As Long, ByVal UBID3 As Long, ByVal UBRM1 As Long, ByVal UBHM1 As Long, ByRef HeatMap As Long, ByRef RMatrix As Single, ByRef ImageData As Byte) As Long
Public Declare Function MakeSeqCatCount2P Lib "dna5.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal UBSN1 As Long, ByVal UBSCC1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef SeqCatCount As Long, ByRef AA As Long, ByRef SeqNum As Integer, ByRef NucMat As Byte, ByRef SeqSpace As Byte, ByRef NucMatB As Byte, ByRef NucMat2 As Byte, ByRef FLP As Byte, ByRef ML As Byte, ByRef NL As Byte) As Long
Public Declare Function ConvSimToDistP Lib "dna5.dll" (ByVal SLen As Long, ByVal NextNo As Long, ByVal UBDistance As Long, ByVal UBPermValid As Long, ByVal ubfubvalid As Long, ByVal UBSubValid As Long, ByRef RedoList As Integer, ByRef Distance As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef PermValid As Single, ByRef PermDIffs As Single, ByRef FubValid As Single, ByRef Fubdiffs As Single, ByRef SubValid As Single, ByRef SubDiffs As Single) As Long
Public Declare Function EraseEmptiesP Lib "dna5.dll" (ByVal NextNo As Long, ByVal UB As Long, ByVal UBFM As Long, ByVal SCO As Long, ByRef ISeqs As Long, ByRef FMat As Single, ByRef FubValid As Single, ByRef SMat As Single, ByRef SubValid As Single) As Long
Public Declare Function DoAABlocksP Lib "dna5.dll" (ByVal XRes As Long, ByVal YRes As Long, ByVal UBPC As Long, ByVal UBIX As Long, ByVal UBID22 As Long, ByVal UBID23 As Long, ByVal UBID12 As Long, ByVal UBID13 As Long, ByRef PCount As Long, ByRef ImageX As Long, ByRef ImageData As Byte, ByRef ImageData2 As Byte) As Long
Public Declare Function MakeBigMap Lib "dna5.dll" (ByVal IStart As Long, ByVal XRes As Long, ByVal YRes As Long, ByVal MBN As Long, ByVal TType As Long, ByVal TNum As Long, ByVal TSH As Long, ByVal XSize As Single, ByVal TSingle As Single, ByVal UBMB1 As Long, ByVal UBMB2 As Long, ByVal UBMB3 As Long, ByVal UBMB4 As Long, ByVal Pict As Long, ByRef MapBlocks As Single) As Long
'Public Declare Function MakeBigMapB Lib "DNA5.dll" (ByVal IStart As Long, ByVal XRes As Long, ByVal YRes As Long, ByVal MBN As Long, ByVal TType As Long, ByVal TNum As Long, ByVal TSH As Long, ByVal XSize As Single, ByVal TSingle As Single, ByVal UBMB1 As Long, ByVal UBMB2 As Long, ByVal UBMB3 As Long, ByVal UBMB4 As Long, ByVal Pict As Long, ByRef MapBlocks As Single) As Long
Public Declare Function DrawTreeLines Lib "dna5.dll" (ByVal Pict As Long, ByVal IStart As Long, ByVal TSHx As Long, ByVal TargetA As Long, ByVal TNum As Long, ByVal TType As Long, ByVal TDL1 As Long, ByVal UBTD1 As Long, ByVal UBTD2 As Long, ByVal UBTD3 As Long, ByVal UBTD4 As Long, ByVal PRat As Single, ByVal TSingle As Single, ByRef OS As Long, ByRef TreeDrawB As Single) As Long

Public Declare Function GetMaxXPos Lib "dna5.dll" (ByVal CharLen As Long, ByVal TNum As Long, ByVal TType As Long, ByVal TDL0 As Long, ByVal UBON As Long, ByVal UBTD1 As Long, ByVal UBTD2 As Long, ByVal UBTD3 As Long, ByVal UBTD4 As Long, ByVal PRat As Single, ByRef ONameLen As Integer, ByRef TreeDrawB As Single) As Single
Public Declare Function GetMaxXPosB Lib "dna5.dll" (ByVal UBTTS1 As Long, ByVal UBTTS2 As Long, ByVal UBTT As Long, ByVal CharLen As Long, ByVal TNum As Long, ByVal TType As Long, ByVal TDL0 As Long, ByVal UBON As Long, ByVal UBTD1 As Long, ByVal UBTD2 As Long, ByVal UBTD3 As Long, ByVal UBTD4 As Long, ByVal PRat As Single, ByRef ONameLen As Integer, ByRef TreeDrawB As Single, ByRef TreeTraceSeqs As Long, ByRef TreeTrace As Long) As Single

Public Declare Function MakeTreeDrawB2 Lib "dna5.dll" (ByVal UB1 As Long, ByVal UB2 As Long, ByVal UB3 As Long, ByVal UB4 As Long, ByVal UB5 As Long, ByRef TreeDraw As Single, ByRef TreeDrawB As Single) As Long
Public Declare Function TSeqPermsP Lib "dna5.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal LSeq As Long, ByRef THold As Long, ByRef tMissingData As Byte, ByRef SeqNum As Integer, ByRef SeqRnd As Integer) As Long
Public Declare Function DoPermsXP Lib "dna5.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long


Public Declare Function FillIntTD Lib "dna5.dll" (ByVal UB As Long, ByRef MinDist As Single, ByRef MinTDist As Single, ByRef AdjustD As Single, ByRef AdjustTD As Single, ByRef IntTD As Integer, ByRef Distance As Single, ByRef TreeDistance As Single) As Long
Public Declare Function ReadIntTD Lib "dna5.dll" (ByVal UB As Long, ByVal MinDist As Single, ByVal MinTDist As Single, ByVal AdjustD As Single, ByVal AdjustTD As Single, ByRef IntTD As Integer, ByRef Distance As Single, ByRef TreeDistance As Single) As Long

Public Declare Function SeqColBlocks Lib "dna5.dll" (ByVal Pict As Long, ByVal UBSL As Long, ByVal tTYF As Double, ByVal TCA As Single, ByVal XConA As Double, ByVal NumSeqLines As Long, ByVal Targ As Long, ByVal VSV As Long, ByRef SeqLines As Long) As Long
Public Declare Function SeqColBlocksP Lib "dna5.dll" (ByVal Pict As Long, ByVal UBSL As Long, ByVal tTYF As Double, ByVal TCA As Single, ByVal XConA As Double, ByVal NumSeqLines As Long, ByVal Targ As Long, ByVal VSV As Long, ByRef SeqLines As Long) As Long

Public Declare Function PrintSeqs Lib "dna5.dll" (ByVal X1 As Long, ByVal Pict As Long, ByVal UBST As Long, ByVal LOS As Long, ByVal Targ As Long, ByVal UBSL As Long, ByVal NumSeqLines As Long, ByVal StartX As Long, ByVal VSV As Long, ByVal SLFS As Long, ByVal SeqSpaceIncrement As Long, ByVal FirstSeq As Long, ByRef SeqLines As Long, ByVal SeqText As String) As Long
Public Declare Function PrintSeqsP Lib "dna5.dll" (ByVal Pict As Long, ByVal UBST As Long, ByVal LOS As Long, ByVal Targ As Long, ByVal UBSL As Long, ByVal NumSeqLines As Long, ByVal StartX As Long, ByVal VSV As Long, ByVal SLFS As Long, ByVal SeqSpaceIncrement As Long, ByVal FirstSeq As Long, ByRef SeqLines As Long, ByVal SeqText As String) As Long
Public Declare Function ExtraRemovalsP Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBF As Long, ByVal UBS As Long, ByRef ISeqs As Long, ByRef ExtraRemove As Long, ByRef FMat As Single, ByRef SMat As Single) As Long
Public Declare Function FindNewX Lib "dna5.dll" (ByVal WinPPY As Long, ByVal WinPP As Long, ByVal Seq3 As Long, ByVal NextNo As Long, ByRef RNum As Long) As Long
Public Declare Function GetBestMatch Lib "dna5.dll" (ByVal NextNo As Long, ByVal NumSeeds As Long, ByVal UBD As Long, ByRef Dist As Single, ByRef BestMatch As Long) As Long
Public Declare Function GetBestMatch2 Lib "dna5.dll" (ByVal NextNo As Long, ByVal NumSeeds As Long, ByVal UBD As Long, ByRef Dist As Single, ByRef BestMatch As Long, ByRef NIY As Long) As Long

Public Declare Function RecodeNucs Lib "dna5.dll" (ByVal NextNo As Long, ByVal LenSeq As Long, ByVal UboundNucCount As Long, ByRef NucCount As Long, ByVal UBReplace As Long, ByRef Replace As Byte) As Long
'int MyMathFuncs::RecodeNucs(                        int NextNo,             int LS,               int UBNC,                 int *NucCount,       int UBR,                    int *Replace)

'        static MATHFUNCSDLL_API int _stdcall GetBestMatch(int Nextno, int NumSeeds, int UBD,                       float *Dist, int *BestMatch);
Public Declare Function GetClosestTo Lib "dna5.dll" (ByVal A As Long, ByVal NextNo As Long, ByVal UBD As Long, ByRef Done As Long, ByRef ClosestTo As Single, ByRef Dist As Single) As Long

Public Declare Function MarkDones Lib "dna5.dll" (ByVal NextNo As Long, ByVal LenSeq As Long, ByVal STA As Long, ByVal ENA As Long, ByVal A1 As Long, ByVal A2 As Long, ByVal A3 As Long, ByVal UBDS1 As Long, ByVal UBPXO As Long, ByRef DoneSeq As Byte, ByRef PCurrentXover As Integer, ByRef PXOList As XOverDefine) As Long
'MarkDones                              (int Nextno,                    int lseq,          int STA,          int ENA,           int A1,               int A2,             int A3,         int UBDS1, int UBPXO,                       unsigned char *DoneSeq, short int *PCurrentXOver, XOVERDEFINE *PXOList)
Public Declare Function Clearcut Lib "dna5.dll" (ByVal OutlyerX As Long, ByVal NextNo As Long, ByVal NJ1RNJ0 As Long, ByVal HighestTaxNum As Long, ByVal rnseed As Long, ByVal Random0Deterministic1 As Long, ByVal UboundDist1 As Long, ByRef Dists As Single, ByRef OutTree As Byte) As Single

Public Declare Function MakeCollecteventsC Lib "dna5.dll" (ByVal NextNo As Long, ByVal LenStrainseq0 As Long, ByVal WinPP As Long, ByRef RSize As Long, ByRef OLSeq As Long, ByVal UBCM As Long, ByRef CompMat As Long, ByVal UBRL As Long, ByRef RList As Long, ByRef RNum As Long, ByVal AddNum As Long, ByVal UBSM As Long, ByRef SMatSmall As Single, ByRef ISeqs As Long, ByRef Trace As Long, ByRef PCurrentXover As Integer, ByVal UBPXO As Long, ByRef PXOList As XOverDefine, ByVal UBCE As Long, ByRef CollectEvents As XOverDefine) As Long

Public Declare Function MakeNJTrees Lib "dna5.dll" (ByVal NSeqs As Long, ByVal NextNo As Long, ByRef ISeqs As Long, ByRef MinPair As Byte, ByRef SeqPair As Byte, ByVal BSRndNumSeed As Long, ByVal NameLen As Long, ByVal LenStrainseq0 As Long, ByVal UBTS As Long, ByRef Outlyer As Long, ByRef TraceSeqs As Long, ByVal UBFM As Long, ByRef FMat As Single, ByVal UBSM As Long, ByRef SMat As Single, ByVal UBFAM As Long, ByRef FAMat As Single, ByVal UBSAM As Long, ByRef SAMat As Single, ByRef ListOfRedos As Long, ByRef FHolder As Byte, ByRef SHolder As Byte, ByRef tFAMat As Single, ByRef tSAMat As Single) As Long
Public Declare Function MakeNJTreesP Lib "dna5.dll" (ByVal NSeqs As Long, ByVal NextNo As Long, ByRef ISeqs As Long, ByRef MinPair As Byte, ByRef SeqPair As Byte, ByVal BSRndNumSeed As Long, ByVal NameLen As Long, ByVal LenStrainseq0 As Long, ByVal UBTS As Long, ByRef Outlyer As Long, ByRef TraceSeqs As Long, ByVal UBFM As Long, ByRef FMat As Single, ByVal UBSM As Long, ByRef SMat As Single, ByVal UBFAM As Long, ByRef FAMat As Single, ByVal UBSAM As Long, ByRef SAMat As Single, ByRef ListOfRedos As Long, ByRef FHolder As Byte, ByRef SHolder As Byte, ByRef tFAMat As Single, ByRef tSAMat As Single) As Long
Public Declare Function MakeNJTreesP2 Lib "dna5.dll" (ByVal ResolveRoot0no1yes As Long, ByVal NSeqs As Long, ByVal NextNo As Long, ByRef ISeqs As Long, ByRef MinPair As Byte, ByRef SeqPair As Byte, ByVal BSRndNumSeed As Long, ByVal NameLen As Long, ByVal LenStrainseq0 As Long, ByVal UBTS As Long, ByRef Outlyer As Long, ByRef TraceSeqs As Long, ByVal UBFM As Long, ByRef FMat As Single, ByVal UBSM As Long, ByRef SMat As Single, ByVal UBFAM As Long, ByRef FAMat As Single, ByVal UBSAM As Long, ByRef SAMat As Single, ByRef ListOfRedos As Long, ByRef FHolder As Byte, ByRef SHolder As Byte, ByRef tFAMat As Single, ByRef tSAMat As Single) As Long

Public Declare Function Tree2ArrayP Lib "dna5.dll" (ByVal EarlyExitFlag As Byte, ByVal NameLen As Long, ByVal NumberOfSeqs As Long, ByVal LTree As Long, ByRef T2Holder As Byte, ByVal UBTM2 As Long, ByRef TMat2 As Single) As Long

'Tree2ArrayP(                               unsigned char EarlyExitFlag, int NameLen,                 int NumberOfSeqs,                 int LTree,        char *T2Holder,            int UBTM2       , float *TMat2)
'MakeNJTrees                                          (int NSeqs, int NextNo,                  int *ISeqs, unsigned char *MinPair,        unsigned char *SeqPair,   int BSRndNumSeed,          int NameLen,             int LenStrainSeq0             , int UBTS, int *Outlyer, int *TraceSeqs,                       int UBFM,         float *FMat,               int UBSM, float *SMat,                  int UBFAM         , float *FAMat,          int UBSAM,          float *SAMat,             int *LR,                 char *FHolder, char *SHolder)
'MakeCollecteventsC                                        (int NextNo,           int lenstrainseq0, int WinPP, int *RSize, int *OLSeq,                                            int UBCM, int *CompMat,              int UBRL, int *RList                , int *RNum, int Addnum,                  int UBSM,              float *SMatSmall, int *ISeqs,                      int *Trace,       short int *PCurrentXOver,           int UBPXO, XOVERDEFINE *PXOList, int UBCE,XOVERDEFINE *collectevents) {


'int MyMathFuncs::Clearcut(                int NextNo,              int treetype,             int nlen,                        int RJ, int UBD, float *dists, char *outtree)
'        static MATHFUNCSDLL_API int _stdcall GetClosestTo(int A, int Nextno, int UBD, unsigned char *Done, int *ClosestTo, float *Dist);

'static MATHFUNCSDLL_API int _stdcall FindNewX(int WinPPY,              int WinPP          , int Seq3        ,   int Nextno, int *RNum);
'                                                   HDC Pict,           int LOS,           int Targ,           int UBSL,           int NumSeqLines,           int StartX,           int VSV,           int SLFS,           int SeqSpaceIncrement,           int FirstSeq,          int *SeqLines,        LPSTR *SeqText

'ReadIntTD(int UB, float MinDist, float MinTDist, float AdjustD, float AdjustTD, short int *IntTD, float *Distance, float *TreeDistance)

'FillIntTD(int UB, float *mindist, float *mintdist, float *adjustd, float *adjusttd, short int *IntTD, float *Distance, float *TreeDistance);
'int MyMathFuncs::MakeTreeDrawB(int UBA, int UBB, int UBC, int UBD, int UBE, float *TreeDraw, float *TreeDrawB)
'float MyMathFuncs::GetMaxXPos(int CharLen, int TNum, int TType, int TDL0, int UBON, int UBTD1, int UBTD2, int UBTD3, int UBTD4, float PRat, short int *ONameLen, float *TreeDrawB) {
    



'int MyMathFuncs::DrawTreeLines(HDC Pict, int IStart, int TSHx, int TargetA, int TNum, int TType, int TDL1, int UBTD1, int UBTD2, int UBTD3, int UBTD4, float PRat, float TSingle, int *OS, float *TreeDrawB) {
    

'int MyMathFuncs::MakeBigMap(int IStart, int XRes, int YRes, int MBN, int TType, int TNum, int TSH, float XSize, float TSingle, int UBMB1, int UBMB2, int UBMB3,int UBMB4, HDC pict, float *MapBlocks) {
'DoSetsAP                                             (int    Nextno, int            UBCX, int           UBXO1, int           SZ1,           int lseq, int          *RI, char         *OLSeq,         char *Sets,         char *doit, short int *CurrentXOver, XOVERDEFINE *XOverlist, unsigned char *DoIt, int *ISeqs)
'Declare Function DoSetsB Lib "dna.dll" (ByVal SZ1 As Long, ByVal LSeq As Long, ByRef RI As Long, ByRef OLSeq As Byte) As Long






'MakeXPD(short int                                            spacerflag, short int         outlyer,  int              lenseq, int            nextno, int               seq1, int               seq2, int               seq3, short int          spacerno, short int        *seqnum,  short int       *spacerseqs, int             *xdiffpos, int           *xposdiff, short int      *validspacer, unsigned char *binarray)
'Dummy = MakeBinArray(Seq1, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray(0, 0))
'Throws a bad dll calling converntion bug
'Public Declare Function GetACP Lib "DNA5.dll" (ByVal LenXOverSeq As Long, ByVal LS As Long, ByVal MaxY As Long, ByVal MaxX As Long, ByVal TWin As Long, ByRef A As Long, ByRef C As Long, ByRef Scores As Byte) As Long


'FindSubSeqP2(int                                     UBXSN, int UBVO, int UBCS, int XoverWindow, int lenseq, int A, int B, int C, int *AH, unsigned char *CompressedSeqs3, unsigned char *XoverSeqNumW, int *XDP, unsigned char *SkipTrip, int *FindSS0)

'Public Declare Function NEIGHBOURP Lib "DNA5.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Single, ByRef HolderForOutTree As Byte, ByRef HolderForColumnTotals As Single, ByRef TreeDistanceArray As Single) As Long


Public Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long

Public Declare Function GetObject Lib "gdi32" Alias "GetObjectA" (ByVal hObject As Long, _
  ByVal nCount As Long, ByRef lpObject As Any) As Long

Public Declare Function GetBitmapBits Lib "gdi32" (ByVal hBitmap As Long, ByVal dwCount As Long, _
  ByRef lpBits As Any) As Long

Public Declare Function SetBitmapBits Lib "gdi32" (ByVal hBitmap As Long, ByVal dwCount As Long, _
  ByRef lpBits As Any) As Long


Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
Public Declare Function GetAsyncKeyState Lib "user32" (ByVal vKey As Long) As Integer


Declare Function Polygon Lib "gdi32" (ByVal hdc As Long, ByRef lpPoint As POINTAPI, ByVal nCount As Long) As Long
Declare Function ExtCreatePen Lib "gdi32" (ByVal dwPenStyle As Long, ByVal dwWidth As Long, lplb As LOGBRUSH, ByVal dwStyleCount As Long, lpStyle As Long) As Long
Declare Sub GetSystemInfo Lib "kernel32" (lpSystemInfo As SYSTEM_INFO)

Public Declare Function MulDiv Lib "kernel32" (ByVal nNumber As Long, ByVal nNumerator As Long, ByVal nDenominator As Long) As Long
Public Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, ByVal nIndex As Long) As Long
Public Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long
Public Declare Function GetClientRect Lib "user32" (ByVal hwnd As Long, lpRect As RECT) As Long
Public Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, ByVal hdc As Long) As Long




Public Const HORZRES = 8            '  Horizontal width in pixels
Public Const HORZSIZE = 4           '  Horizontal size in millimeters
Public Const VERTRES = 10           '  Vertical width in pixels
Public Const VERTSIZE = 6           '  Vertical size in millimeters

'Phylip declares
'DNADIST



     Declare Function LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
     Declare Function LoadLibraryEx Lib "kernel32" Alias "LoadLibraryExA" (ByVal lpLibFileName As String, ByVal hFile As Long, ByVal dwFlags As Long) As Long
     Declare Function FreeLibrary Lib "kernel32" (ByVal hLibModule As Long) As Long
      
    ' Missing from VB API declarations:
     Const DONT_RESOLVE_DLL_REFERENCES = &H1&
    Const LOAD_LIBRARY_AS_DATAFILE = &H2&
     Const LOAD_WITH_ALTERED_SEARCH_PATH = &H8&

'Declare Function SHGetFolderPath Lib "shfolder.dll" Alias "SHGetFolderPathA" (ByVal hwndOwner As Long, ByVal nFolder As Long, ByVal hToken As Long, ByVal dwReserved As Long, ByVal lpszPath As String) As Long
                         
Public Const CSIDL_COMMON_APPDATA = &H23
Public Const CSIDL_COMMON_DOCUMENTS = &H2E

Declare Function SHAppBarMessage Lib "shell32.dll" (ByVal dwMessage As Long, pData As APPBARDATA) As Long

'function declaration (I had this in a global module)
Declare Function AddFontResource Lib "gdi32" Alias "AddFontResourceA" (ByVal lpFileName As String) As Long
Declare Function RemoveFontResource Lib "gdi32" Alias "RemoveFontResourceA" (ByVal lpFileName As String) As Long


Declare Function SEQBOOT Lib "dna.dll" (ByVal RandomNumberSeed As Long, ByVal NumberOfBootstrapReps As Integer, ByVal NumberOfSites As Long, ByRef ScratchPatchArray As Integer, ByRef WeightModArray As Long) As Double
Declare Function SEQBOOT2 Lib "dna.dll" (ByVal RandomNumberSeed As Long, ByVal NumberOfBootstrapReps As Integer, ByVal NumberOfSites As Long, ByRef ScratchPatchArray As Integer, ByRef WeightModArray As Long) As Double
'double FAR pascal SEQBOOT2             (int nseed,                      short int bsbootreps,                   int bsstepwin,               short int *scratch,                 int *weightmod)


Declare Function AddExcludesToCoRec Lib "dna.dll" (ByVal x As Long, ByVal ExcludedEventNum As Long, ByVal UBEIE1 As Long, ByVal UBD1 As Long, ByRef EventsInExcludeds As Long, ByRef Daught As Byte) As Long
'int FAR pascal AddExcludesToCoRec(                int x, int ExcludedEventNum, int UBEIE1, int UBD1,                                     int *EventsInExcludeds, unsigned char *Daught){

Declare Function DNADIST Lib "dna.dll" (ByVal CoeffVariation As Double, ByVal TransitionTransversionRatio As Double, ByVal BaseFreqFlag As Integer, ByVal DistModelFlag As Integer, ByVal AFrequency As Double, ByVal CFrequency As Double, ByVal GFrequency As Double, ByVal TFrequency As Double, ByVal NumberOfSequences As Long, ByVal NumberOfSites As Long, ByRef IntSeqString As Integer, ByRef AliasArray As Long, ByRef AllyArray As Long, ByRef WeightArray As Long, ByRef LocationArray As Long, ByRef PXArray As Integer, ByRef xx1Array As Integer, ByRef xx2Array As Integer, ByRef Product1Array As Double, ByRef Product2Array As Double, ByRef Product3Array As Double, ByRef DistanceMatrixArray As Single) As Double
'extern "C" double FAR pascal DNADIST(  double cvi,                     double ttratio,                              short int tbff,                short int tmodel,               double tafreq,              double tcfreq,              double tgfreq,              double ttfreq,              int numsp,                       int sites,                   short int *seqnum,             int *alias,               int *ally,               int *weight,               int *location,               short int *px,            short int *xx1,            short int *xx2,            double *prod,                  double *prod2,                 double *prod3,                 float *dmat);
   
Declare Function BootDist Lib "dna.dll" (ByVal BootStrapReplicates As Integer, ByVal CoeffVariation As Double, ByVal TransitionTransversionRatio As Double, ByVal DistModelFlag As Integer, ByVal NumberOfSequences As Long, ByVal NumberOfSites As Long, ByRef IntSeqString As Integer, ByRef AliasArray As Long, ByRef AllyArray As Long, ByRef WeightArray As Long, ByRef LocationArray As Long, ByRef PXArray As Integer, ByRef xx1Array As Integer, ByRef xx2Array As Integer, ByRef Product1Array As Double, ByRef Product2Array As Double, ByRef Product3Array As Double, ByRef DistanceMatrixArray As Single, ByRef DistanceValue As Double, ByRef Numerator1 As Long, ByRef Numerator2 As Long, ByRef Denominator As Long, ByRef Numerator As Double, ByRef WeightModifier As Long) As Long
'int FAR pascal BootDist(                short int bootreps,                   double cvi,                     double ttratio,                              short int tmodel,               int numsp,                        int sites,                  short int *seqnum,             int *alias,                int *ally,              int *weight,               int *location,               short int *px,             short int *xx1,           short int *xx2,             double *prod,                double *prod2,                   double *prod3,               float *dmat,                          double *vv,                    int *num1               , int *num2                , int *denominator,            double *numerator,              int *wmod)


'Declare Function MakeV Lib "dna.dll" (ByVal freqax As Double, ByVal freqcx As Double, ByVal freqgx As Double, ByVal freqtx As Double, ByVal freqarx As Double, ByVal freqgrx As Double, ByVal freqcyx As Double, ByVal freqtyx As Double, ByVal cvix As Double, ByVal fracchangex As Double, ByVal xvx As Double, ByVal tmodelx As Integer, ByVal numspx As Long, ByVal sitesx As Long, ByVal endsitex As Long, ByRef weightx As Long, ByRef xx1x As Double, ByRef xx2x As Double, ByRef pxx As Integer, ByRef prodx As Double, ByRef prod2x As Double, ByRef prod3x As Double, ByRef dstmatx As Double) As Integer
'Declare Function NEIGHBOUR Lib "C:\Program Files\DevStudio\MyProjects\DNA\Debug\dna.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Double, ByRef HolderForOutTree As Integer) As Long

Declare Function MakeMapSC Lib "dna.dll" (ByVal FullLength As Long, ByVal ENumb As Long, ByRef APos As Long, ByVal NS As Long, ByVal ST As Long, ByVal A As Long, ByVal UBMS As Long, ByRef MapS As Single, ByVal UBPD1 As Long, ByRef BPProbDist As Single, ByVal LSSeq As Long, ByRef XPosDiff As Long, ByVal UBMB As Long, ByRef MapBack As Long, ByRef tMapS As Single) As Long
'extern "C" int FAR pascal MakeMapSC(int FullLength, int ENumb, int *APos, int NS, int ST, int A, int UBMS, float *MapS, int UBPD1, float *BPProbDist, int LSSeq, int *XPosDiff, int UBMB, int *MapBack, float *tMapS);
Declare Function FindWinners Lib "dna.dll" (ByVal NumSeeds As Long, ByVal UBD As Long, ByRef Winner1 As Long, ByRef Winner2 As Long, ByRef Done As Long, ByRef TraceA As Long, ByRef Dist As Single) As Long

'int FAR pascal FindWinners(int NumSeeds                            , int UBD           , int *w1,                int *w2,           int *Done, int *TraceA, float *Dist){


Declare Function NEIGHBOUR Lib "dna.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Single, ByRef HolderForOutTree As Byte, ByRef HolderForColumnTotals As Single, ByRef TreeDistanceArray As Single) As Long
Declare Function NEIGHBOURP Lib "dna5.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Single, ByRef HolderForOutTree As Byte, ByRef HolderForColumnTotals As Single) As Long

'int FAR pascal NEIGHBOUR(                short int njoin,               short int jumble,            int nseed,                  int outgrno,                  int numsp,                     float *x,                       char *ot,                       double *coltotals,                     float *tarray)

Declare Function CalcHits Lib "dna.dll" (ByVal WinPP As Long, ByVal LS As Long, ByVal CTest As Long, ByVal BPos2 As Long, ByVal EPos2 As Long, ByVal UBSN As Long, ByVal UBCM As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef Hits As Single, ByRef TotS As Single) As Long

Declare Function GoLeft Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal CircularFlag As Long, ByVal StartPos As Long, ByVal LS As Long, ByVal UBMD As Long, ByRef MissingData As Byte) As Long

Declare Function GoRight Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal CircularFlag As Long, ByVal StartPos As Long, ByVal LS As Long, ByVal UBMD As Long, ByRef MissingData As Byte) As Long

'Declare Function NEIGHBOUR2 Lib "dna.dll" (ByVal TreeTypeFlag As Integer, ByVal JumbleFlag As Integer, ByVal RandomNoSeed As Long, ByVal OutgroupNumber As Long, ByVal NumberOfSpecies As Long, ByRef DistanceMatrix As Single, ByRef HolderForOutTree As Byte, ByRef HolderForColumnTotals As Double, ByRef TreeDistanceArray As Single) As Long

'Declare Function JCDist Lib "dna.dll" (ByVal BootstrapReplicates As Integer, ByVal JCORSimFlag As Integer, ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef WeightModifyer As Long, ByRef Numerator2 As Long, ByRef Denominator As Long) As Long
Declare Function GetPltVal Lib "dna.dll" (ByVal BootStrapReplicates As Integer, ByVal YPosition As Long, ByRef Total0 As Integer, ByRef Total1 As Integer, ByRef Total2 As Integer, ByRef PlotValueArray As Double) As Long
Declare Function GetPltVal2 Lib "dna.dll" (ByVal BootStrapReplicates As Integer, ByVal StartPosition As Long, ByVal EndPosition As Long, ByRef Total0 As Integer, ByRef Total1 As Integer, ByRef Total2 As Integer, ByRef PlotValueArray As Double) As Long
Declare Function MakeSubAlign Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Long, ByVal LengthOfFullSequence As Long, ByVal WindowNumber As Long, ByVal SizeOfStep As Long, ByVal SizeOfWindow As Long, ByRef SubAlignmentInIntegerArray As Integer, ByRef AlignmentInIntegerArray As Integer) As Long
Declare Function GetColPix Lib "dna.dll" (ByVal CurScale As Long, ByVal MR As Single, ByVal Y As Long, ByVal Pict As Long, ByVal PosS0 As Single, ByVal PosS1 As Single, ByVal XAddj As Single, ByVal PosE As Long, ByVal StSX As Long, ByVal x As Long, ByVal UBRM As Long, ByVal UBHM As Long, ByVal Min As Single, ByRef RegionMat As Single, ByRef ColPix As Long, ByRef HeatMap As Long) As Long
Declare Function GetColPix2 Lib "dna.dll" (ByVal Band As Single, ByRef XDP As Long, ByRef ZDP As Long, ByVal CurScale As Long, ByVal MR As Single, ByVal Y As Long, ByVal Pict As Long, ByVal PosS0 As Single, ByVal PosS1 As Single, ByVal XAddj As Single, ByVal PosE As Long, ByVal StSX As Long, ByVal x As Long, ByVal UBRM As Long, ByVal UBHM As Long, ByVal Min As Single, ByRef RegionMat As Single, ByRef ColPix As Long, ByRef HeatMap As Long) As Long

Declare Function SingleToInt Lib "dna.dll" (ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal NumberBootReps As Integer, ByVal NumberOfSequencesMinusOne As Long, ByRef InArray As Single, ByRef OutArray As Integer) As Long
'int FAR pascal SingleToInt(                int s1,                  int s2,                  short int bootreps,              int nextno,                              float *in,               short int *out){


'Declare Function TreeToArray Lib "c:\darren\dna project\dll2\windebug\dna.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Integer, ByRef TemporaryArray As Double, ByRef RootNodeArray As Long) As Double
Declare Function TreeToArray Lib "dna.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Byte, ByRef TemporaryArray As Single, ByRef NodeOrderArray As Long, ByRef DoneNodeArray As Long, ByRef TempNodeOrderArray As Long, ByRef RootNodeArray As Byte, ByRef NodeLenArray As Double, ByRef NumDonex As Double) As Double
Declare Function TreeToArrayP Lib "dna5.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Byte, ByRef TemporaryArray As Single, ByRef NodeOrderArray As Long, ByRef DoneNodeArray As Long, ByRef TempNodeOrderArray As Long, ByRef RootNodeArray As Byte, ByRef NodeLenArray As Double, ByRef NumDonex As Double) As Double

'double FAR pascal TreeToArray (            short int nlen2,              int nextno,                      int treelen,              char *sholder,                   float *tmat,                    int  *nodeorder,              int *donenode,               int *tempnodeorder,               int *rootnode,         double *nodelen,              double *numdone){
'double FAR pascal TreeToArray          (   short int nlen2,              int nextno,                      int treelen,              char *sholder,                   float *tmat,                    int  *nodeorder,              int *donenode,               int *tempnodeorder,               int *rootnode,         double *nodelen,              double *numdone){


Declare Function TreeToArrayB Lib "dna.dll" (ByVal NameLengthc As Integer, ByVal NumberOfSequences As Long, ByVal TreeLength As Long, ByRef IntegerTreeHolder As Integer, ByRef TemporaryArray As Single, ByRef NodeOrderArray As Long, ByRef DoneNodeArray As Long, ByRef TempNodeOrderArray As Long, ByRef RootNodeArray As Byte, ByRef NodeLenArray As Double) As Double
'double FAR pascal TreeToArrayB (              short int nlen2,            int nextno,                       int treelen,            short int *sholder,                  float *tmat,                      int  *nodeorder,              int *donenode,               int *tempnodeorder,                int *rootnode,               double *nodelen){

Declare Function ScanPositive Lib "dna.dll" (ByVal WindowNumber As Long, ByVal BootScanCutOff As Double, ByVal CutOffCount As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal NumberOfSequencesx As Long, ByVal BootStrapReplicates As Integer, ByRef GoOnHolderA As Long, ByRef GoOnHolderB As Long, ByRef SequenceOrder As Byte, ByRef DistanceMatrix As Single) As Long
'int FAR pascal          ScanPositive (        int winnum,               double bscutoff   ,              int cocount,              int x ,                   int y,                     int numberofseqs,               short int bootreps,                  int *goona,             int *goonb,                 char *orderarray,                 float *dstmat)

Declare Function MakeAList Lib "dna.dll" (ByVal PropTrips As Long, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByVal UBAL1 As Long, ByRef Analysislist As Integer) As Long
Declare Function MakeAListP Lib "dna5.dll" (ByVal PropTrips As Long, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByVal UBAL1 As Long, ByRef Analysislist As Integer) As Long
Declare Function MakeAListP2 Lib "dna5.dll" (ByVal PropTripsSingle As Single, ByVal NextNo As Long, ByRef MaskSeq As Integer, ByVal UBAL1 As Long, ByRef Analysislist As Integer) As Long

'int FAR pascal MakeAList(              int PropTrips,              int NextNo,     short int *MaskSeq,               int UBAL1,      short int *Analysislist){

'Metafile declares
Declare Function CloseEnhMetaFile Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function CreateFont Lib "gdi32" Alias "CreateFontA" (ByVal H As Long, ByVal W As Long, ByVal e As Long, ByVal O As Long, ByVal W As Long, ByVal i As Long, ByVal U As Long, ByVal S As Long, ByVal C As Long, ByVal OP As Long, ByVal CP As Long, ByVal Q As Long, ByVal PAF As Long, ByVal F As String) As Long
Declare Function CreatePenIndirect Lib "gdi32" (lpLogPen As LOGPEN) As Long
Declare Function CreateEnhMetaFile Lib "gdi32" Alias "CreateEnhMetaFileA" (ByVal hdcRef As Long, ByVal lpFileName As String, lpRect As RECT, ByVal lpDescription As String) As Long
Declare Function DeleteEnhMetaFile Lib "gdi32" (ByVal hemf As Long) As Long
Declare Function LineTo Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long) As Long
Declare Function MoveToEx Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long, lpPoint As POINTAPI) As Long
Declare Function SetTextColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Declare Function TextOut Lib "gdi32" Alias "TextOutA" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long, ByVal lpString As String, ByVal nCount As Long) As Long
Declare Function SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Declare Function SetBkMode Lib "gdi32" (ByVal hdc As Long, ByVal nBkMode As Long) As Long
Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Declare Function Rectangle Lib "gdi32" (ByVal hdc As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Declare Function ExtFloodFill Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long, ByVal crColor As Long, ByVal wFillType As Long) As Long
Declare Function FloodFill Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long, ByVal crColor As Long) As Long
Declare Function SetPolyFillMode Lib "gdi32" (ByVal hdc As Long, ByVal nPolyFillMode As Long) As Long
Declare Function SetDCBrushColor Lib "gdi32.dll" (ByVal hdc As Long, ByVal colorref As Long) As Long
Declare Function SetDCPenColor Lib "gdi32.dll" (ByVal hdc As Long, ByVal colorref As Long) As Long
Declare Function CreateBrushIndirect Lib "gdi32" (lpLogBrush As LOGBRUSH) As Long

'Text Functions
'Public Declare Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32A" (ByVal hdc As Long, ByVal lpsz As String, ByVal cbString As Long, lpSize As Size) As Long
'Public Declare Function GetTextMetrics Lib "gdi32" Alias "GetTextMetricsA" (ByVal hdc As Long, lpMetrics As TEXTMETRIC) As Long


'DIB Functions
Declare Function GetPixel Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long) As Long
Declare Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Declare Function SetPixelV Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long, ByVal crColor As Long) As Long
Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal x As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
Declare Function DeleteDC Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function StretchBlt Lib "gdi32" (ByVal hdc As Long, ByVal x As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal nSrcWidth As Long, ByVal nSrcHeight As Long, ByVal dwRop As Long) As Long
Declare Function SetDIBits Lib "gdi32" (ByVal hdc As Long, ByVal hBitmap As Long, ByVal nStartScan As Long, ByVal nNumScans As Long, lpBits As Any, lpBI As BITMAPINFO, ByVal wUsage As Long) As Long
'Shell declares
Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
'Declare Sub ExitProcess Lib "kernel32" (ByVal uExitCode As Long)
Declare Function GetExitCodeProcess Lib "kernel32" (ByVal hProcess As Long, lpExitCode As Long) As Long
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
'Declare Function ShellAbout Lib "shell32.dll" Alias "ShellAboutA" (ByVal hwnd As Long, ByVal szApp As String, ByVal szOtherStuff As String, ByVal hIcon As Long) As Long
Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Declare Function GetWindowThreadProcessId Lib "user32" (ByVal hwnd As Long, lpdwProcessId As Long) As Long
'Declare Function IsWindow Lib "user32" (ByVal hwnd As Long) As Long
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long
Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, ByVal wCmd As Long) As Long
Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
'Time functions
Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)
Declare Function GetTickCount Lib "kernel32" () As Long
'Memory managemnet declares
Declare Sub GlobalMemoryStatus Lib "kernel32.dll" (lpBuffer As MEMORYSTATUS)
'Misc Declares
Declare Function GetBkColor Lib "gdi32" (ByVal hdc As Long) As Long
Declare Function Arc Lib "gdi32" (ByVal hdc As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long, ByVal X4 As Long, ByVal Y4 As Long) As Long


Declare Function IsProcessorFeaturePresent Lib "kernel32" (ByVal feature As Long) As Boolean


Declare Function FindLeftEnd Lib "dna.dll" (ByVal S1 As Long, ByVal s2 As Long, ByVal S3 As Long, ByVal SLen As Long, ByVal Start As Long, ByVal UMBD As Long, ByRef MissingData As Byte) As Long
Declare Function FindRightEnd Lib "dna.dll" (ByVal S1 As Long, ByVal s2 As Long, ByVal S3 As Long, ByVal SLen As Long, ByVal Start As Long, ByVal UMBD As Long, ByRef MissingData As Byte) As Long

'int FAR pascal FindLeftEnd(                  int S1,           int S2,           int S3,           int SLen,             int BE,            int UBMD,  unsigned char *MissingData){



'Custom C functions
Declare Function CopyString Lib "dna.dll" (ByVal LSeqX As Long, ByRef SeqNumArray As Integer, ByVal SeqString As String, ByRef seqspacesx As Long) As Integer
'Declare Function CopyStringB Lib "dna.dll" (ByVal LSeqX As Long, ByRef SeqNumArray As Integer, ByVal SeqString As String) As Integer
Declare Function CopyStringC Lib "dna.dll" (ByVal LenXoverSeqx As Long, ByRef xoverseqnumx As Integer, ByVal xoverseqx As String) As Integer
Declare Function CopyStringD Lib "dna.dll" (ByVal LenXoverSeqx As Long, ByRef SeqnumX As Integer, ByRef xDiffposx As Long, ByVal StringX As String) As Integer
Declare Function FindSubSeq Lib "dna.dll" (ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer) As Long 'ByVal var3x As Integer
Declare Function FindSubSeqFaster Lib "dna.dll" (ByVal UBIS4, ByRef AH As Long, ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Byte, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer, ByRef ISeq4 As Integer) As Long 'ByVal var3x As Integer

Declare Function FindSubSeq2 Lib "dna.dll" (ByVal spacerflagx As Integer, ByVal OutlyerX As Integer, ByVal XOverWindowX As Integer, ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal spacernox As Integer, ByRef SeqnumX As Integer, ByRef xoverseqnumx As Integer, ByRef xoverseqnumwx As Integer, ByRef spacerseqsx As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long, ByRef validspacerx As Integer) As Long  'ByVal var3x As Integer
Declare Function FindSubSeqB Lib "dna.dll" (ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqnumX As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long) As Long   'ByVal var3x As Integer
Declare Function FindSubSeqC Lib "dna.dll" (ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqnumX As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long) As Long   'ByVal var3x As Integer
Declare Function FindSubSeqD Lib "dna.dll" (ByVal LenSeqx As Long, ByVal NextnoX As Integer, ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByRef SeqnumX As Integer, ByRef xDiffposx As Long, ByRef xPosdiffx As Long) As Long    'ByVal var3x As Integer

Declare Function ShiftDown Lib "dna.dll" (ByVal diffspacex As Integer, ByVal LSeqX As Long, ByVal LastDimx As Integer, ByVal LastEndx As Integer, ByRef ArrayX As Integer) As Integer
Declare Function ShiftUp Lib "dna.dll" (ByVal diffspacex As Integer, ByVal LSeqX As Long, ByVal LastDimx As Integer, ByVal LastEndx As Integer, ByRef ArrayX As Integer) As Integer
Declare Function FillArray Lib "dna.dll" (ByVal fillvalx As Integer, ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal LenSeq As Long, ByVal sposx As Integer, ByRef parray As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function FillArray2 Lib "dna.dll" (ByVal Addj As Double, ByVal fillvalx As Integer, ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal LenSeq As Long, ByVal sposx As Integer, ByRef parray As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function ModPermArray Lib "dna.dll" (ByVal Frm1Pic5ScaleWidth As Long, ByVal UB As Long, ByVal LastDim As Long, ByVal Spos As Long, ByVal b As Long, ByRef PermArray As Integer, ByRef TempArray As Integer) As Long

Declare Function FindSlot Lib "dna.dll" (ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal sposx As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function ReFindSlot Lib "dna.dll" (ByVal AdjPos As Double, ByVal picwid As Long, ByVal LSeqX As Long, ByVal rbeginx As Long, ByVal UTargetx As Long, ByVal sposx As Integer, ByRef parray As Integer, ByRef maxsposarray As Integer) As Integer
Declare Function XOHomology Lib "dna.dll" (ByVal Inlyerx As Integer, ByVal LenStrainseqx As Long, ByVal LenXoverSeqx As Long, ByVal XOverWindowX As Integer, ByRef xoverseqnumwx As Byte, ByRef xoverhomologynumx As Long) As Integer

Declare Function WinScoreCalc Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long
Declare Function ModMatPic Lib "dna.dll" (ByVal cAddj As Long, ByVal SY As Long, ByVal SX As Long, ByVal XAD As Single, ByVal PosE0 As Long, ByVal PosE1 As Long, ByVal UBMP As Long, ByVal UBMC As Long, ByRef MatPic As Single, ByRef MatrixC As Byte) As Long
'int FAR pascal ModMatPic(                  int cAddj,           int SY,           int SX,         float XAD, int            PosE0, int           PosE1,             int UBMP, int        UBMC, float           *MatPic, char           *MatrixC)
Declare Function MatCToMatPic Lib "dna.dll" (ByVal SX As Long, ByVal SY As Long, ByVal PosE0 As Long, ByVal PosE1 As Long, ByVal UBMP As Long, ByVal UBMC As Long, ByRef MatPic As Single, ByRef MatrixC As Byte) As Long

'int FAR pascal MatCToMatPic(                  int SX,             int SY, int         PosE0, int           PosE1, int           UBMP, int           UBMC,        float *MatPic,           char *MatrixC){

Declare Function WinScoreCalc2 Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long
Declare Function WinScoreCalc3 Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long, ByRef PositionsOfDiffs2 As Long) As Long
Declare Function WinScoreCalc4 Lib "dna.dll" (ByVal CriticalDifference As Long, ByVal HalfWindowWidth As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfSequence As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef ScoresHolder As Byte, ByRef PositionsOfDifferences As Long, ByRef SequenceInIntegerArray As Integer, ByRef WindowScoresHolder As Long) As Long

Declare Function XOHomologyB Lib "dna.dll" (ByVal Seq1x As Integer, ByVal Seq2x As Integer, ByVal Seq3x As Integer, ByVal Inlyerx As Integer, ByVal LenStrainseqx As Long, ByVal LenXoverSeqx As Long, ByVal XOverWindowX As Integer, ByRef homologycountholder As Double, ByRef ArrayWithSequences As Integer, ByRef AvHomolx As Double, ByRef xdifposx As Long) As Integer
Declare Function ProbCalc Lib "dna.dll" (ByRef Fact As Double, ByVal xoverlengthx As Integer, ByVal numincommonx As Integer, ByVal indprobx As Double, ByVal LenXoverSeqx As Long) As Double
Declare Function DistanceCalc Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Single, ByRef TotalDistance As Double) As Double
'double FAR pascal DistanceCalc(             short int nextno,                           int lenseq,                            short int *seqnum,                           float *distance,                       double *avdst)

Declare Function DistanceCalcX Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Single, ByRef ValidSitesArray As Single, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Single, ByRef TotalDistance As Double) As Double
Declare Function DistanceCalcY Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Single, ByRef ValidSitesArray As Single, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Single, ByRef TotalDistance As Double, ByRef DistanceModifier As Double) As Double
Declare Function DistanceCalcZ Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Single, ByRef ValidSitesArray As Single, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Single, ByRef TotalDistance As Double, ByRef valy As Long, ByRef CountY As Long) As Double
Declare Function DistanceCalcW Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef DifferencesArray As Single, ByRef ValidSitesArray As Single, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Single, ByRef TotalDistance As Double, ByRef InvovedArray As Long) As Double
'double FAR pascal DistanceCalcW(             int nextno,                                 int lenseq,                            float *diffsx,                    float *validx,                   short int *seqnum,                           float *distance,                     double *avdst,                 int *involved)
  

Declare Function BSSubSeq Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef SequencesInIntegerArray As Integer, ByRef xPosdiffx As Long, ByRef xDiffposx As Long, ByRef ScoresX As Byte) As Long
'Declare Function DistanceCalc2 Lib "c:\darren\dna project\dll2\windebug\dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByRef SequenceDataInIntegerArray As Integer, ByRef EmptyDistanceMatrix As Double, ByRef TotalDistance As Double) As Double
Declare Function DistanceCalcB Lib "dna.dll" (ByVal NextnoX As Integer, ByVal LenSeqx As Long, ByVal nonspacernox As Integer, ByRef SeqnumX As Integer, ByRef DistanceX As Single, ByRef validsitex As Single) As Double
Declare Function DistanceCalcC Lib "dna.dll" (ByVal NextnoX As Integer, ByVal LenSeqx As Long, ByVal StartX As Long, ByVal Endx As Long, ByRef SeqnumX As Integer, ByRef DistanceX As Single, ByRef validsitex As Single) As Double
Declare Function DistanceCalcD Lib "dna.dll" (ByVal NextnoX As Integer, ByVal LenSeqx As Long, ByRef SeqnumX As Integer, ByRef DistanceX As Single, ByRef validsitex As Single, ByRef CurrentXOverX As Integer, ByRef distancebx As Single) As Double
Declare Function DistanceCalcE Lib "dna.dll" (ByVal TestSequenceNumber As Integer, ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencePlusOne As Long, ByVal StartPosition As Long, ByVal EndPosition As Long, ByRef AlignmentInIntegerArray As Integer, ByRef DistanceMatrix As Single) As Double
Declare Function DistanceCalcF Lib "dna.dll" (ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal NumberOfSequencesMinusOne As Integer, ByVal LengthOfSequencesPlusOne As Long, ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal AverageIdentity As Double, ByRef AlignmentIntegerArray As Integer, ByRef DistHolderArray As Single, ByRef HomologyArray As Single) As Double


Declare Function DrawMatrix Lib "dna.dll" (ByVal hdc As Long, ByVal pwidx As Integer, ByVal yposx As Integer, ByVal wid As Integer, ByVal sqrx As Integer, ByVal parrayx As String) As Integer
Declare Function DrawMatrixB Lib "dna.dll" (ByVal hdc As Long, ByVal pwidx As Integer, ByVal yposx As Integer, ByVal wid As Integer, ByVal sqrx As Integer, ByVal parrayx As String) As Integer
Declare Function DrawDiffs Lib "dna.dll" (ByVal hdc As Long, ByVal LenXoverSeqx As Long, ByVal XFactorx As Double, ByRef xDiffposx As Long) As Integer
Declare Function DrawDiffsB Lib "dna.dll" (ByVal hdc As Long, ByVal LenXoverSeqx As Long, ByVal XFactorx As Double, ByRef xDiffposx As Long) As Integer

Declare Function SpacerFindB Lib "dna.dll" (ByVal NumberOfSequencesMinusOne As Integer, ByVal ReferenceSequenceFlag As Integer, ByVal MinimumParentalIdentity As Double, ByVal MaximumParentalIdentity As Double, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef OutlyerHolder As Integer, ByRef ReferenceSequenceNumberHolder As Integer, ByRef ArrayOfTreeDistances As Single, ByRef IdentityMatrix As Single, ByRef SequenceMasks As Integer, ByRef ReferenceSequenceHolder As Integer, ByRef ValidReferenceSequenceHolder As Integer) As Long
'int FAR pascal          SpacerFindB(        short int Nextno,                         short int SpacerFlag,                       double MiDistance,                       double MaDistance,                       short int Seq1,                short int Seq2,         short int Seq3,             short int *OL,                   short int *SN,                                  float *TreeDistance,                float *Distance,                short int *MaskSeq,                short int *SpacerSeqs,                 short int *ValidSpacer)

Declare Function MatCToMatPicTB Lib "dna.dll" (ByVal SX As Long, ByVal SY As Long, ByVal PosE0 As Long, ByVal PosE1 As Long, ByVal UBMP As Long, ByVal UBMC As Long, ByRef MatPic As Single, ByRef MatrixC As Byte) As Long
Declare Function ModMatPicTB Lib "dna.dll" (ByVal cAddj As Long, ByVal SY As Long, ByVal SX As Long, ByVal XAD As Single, ByVal PosE0 As Long, ByVal PosE1 As Long, ByVal UBMP As Long, ByVal UBMC As Long, ByRef MatPic As Single, ByRef MatrixC As Byte) As Long


'Declare Function PlotDraw Lib "dna.dll" (ByVal hdc As Long, ByVal lenxoverseqx As Long, ByVal picheightx As Integer, ByVal XFactorx As Double, ByRef XDiffPosx As Long, ByRef xoverhomologynumx As Double) As Integer
'Declare Function HomologyWin Lib "dna.dll" (ByVal WeightedFlagx As Integer, ByVal lenhsnum As Integer, ByVal Beginningx As Integer, ByVal Endingx As Integer, ByVal nextnox As Integer, ByRef validsitex As Double, ByRef runningtotalx As Double, ByRef homologyseqnumx As Integer, ByRef homologyx As Double, ByRef bkghomologyx As Double, ByRef adjustfactorx As Double) As Integer
'Declare Function MakeSubSeq Lib "dna.dll" (ByVal nextnox As Integer, ByVal lenseqx As Long, ByRef seqnumx As Integer, ByRef rtseqsx As Integer, ByRef rtseqcompx As Double) As Integer
Declare Function MakeSubSeqB Lib "dna.dll" (ByVal spacernox As Integer, ByVal LenSeqx As Long, ByVal nonspacernox As Integer, ByRef SeqnumX As Integer, ByRef rtseqsx As Integer, ByRef rtseqcompx As Integer) As Integer
Declare Function MakeSubSeqC Lib "dna.dll" (ByVal NextnoX As Integer, ByVal LenSeqx As Long, ByRef SeqnumX As Integer, ByRef rtseqsx As Integer, ByRef rtseqcompx As Byte, ByRef CurrentXOverX As Integer) As Integer
Declare Function TreeDist Lib "dna.dll" (ByVal NextnoX As Integer, ByRef treedistancex As Single, ByRef nodelengthx As Double, ByRef treexx As Integer) As Double
'double FAR pascal TreeDist(              int nextno,              float *treedistance,          double *nodelength,              short int *treex)

Declare Function ShortestDist Lib "dna.dll" (ByVal NextnoX As Long, ByVal sortednox As Long, ByRef distancebakx As Single, ByRef treexx As Integer, ByRef treeyx As Integer) As Single
'double FAR pascal ShortestDist(             short int nextno,           short int sortedno,       float *distancebak,          short int *treex,          short int *treey)
Declare Function ShortestDistB Lib "dna.dll" (ByVal NextnoX As Long, ByVal sortednox As Long, ByRef OldX As Single, ByRef WinningX As Long, ByRef distancebakx As Single, ByRef treexx As Integer, ByRef treeyx As Integer) As Single

Declare Function MakeDistMapX Lib "dna.dll" (ByVal NextNo As Long, ByRef DistMap As Single, ByRef NJSubDistance As Single, ByRef WinningX As Long) As Long
'int FAR pascal MakeDistMapX(int Nextno, float *DistMap, float *NJSubDistance, int *WinningX){
Declare Function UpdateDistMapX Lib "dna.dll" (ByVal x As Long, ByVal Z As Long, ByVal NextNo As Long, ByRef DistMap As Single, ByRef NJSubDistance As Single, ByRef WinningX As Long) As Long
'int FAR pascal UpdateDistMapX(int X, int Z, int Nextno, float *DistMap, float *NJSubDistance, int *WinningX){


Declare Function GetSiteHomol Lib "dna.dll" (ByVal LSeqX As Long, ByVal NextnoX As Integer, ByRef SeqnumX As Integer, ByRef idcountx As Integer, ByRef seqhomolx As Long) As Integer
Declare Function FindNext Lib "dna.dll" (ByVal StartPosition As Long, ByVal HighHomolSeqPair As Integer, ByVal MedHomolSeqPair As Integer, ByVal LowHomolSeqPair As Integer, ByVal LenXoverSubSeq As Long, ByVal SizeOfXoverWindow As Integer, ByRef XOverHomologyNumArray As Long) As Long

Declare Function CalcChiVals Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Declare Function CalcChiVals2 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Declare Function CalcChiVals3 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double) As Double
Declare Function CalcChiVals4 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long) As Double
Declare Function CalcChiVals5 Lib "dna.dll" (ByVal CriticalDiff As Long, ByVal HalfWindowWidth As Long, ByVal LenXoverSeqx As Long, ByVal LenSeqx As Long, ByRef WindowScoresArray As Long, ByRef ChiValueArray As Double, ByRef BanWins As Long) As Double

Declare Function DoPerms Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long
Declare Function DoPermsX Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long

Declare Function DoPerms2 Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByRef PScoreHolderArray As Byte, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long
Declare Function DoPerms3 Lib "dna.dll" (ByVal LengthOfAlignment As Long, ByVal WindowLength As Long, ByVal NumberOfPermutations As Long, ByVal NumberOfPermutations2 As Long, ByRef PScoreHolderArray As Long, ByRef VerticalRandomisationTemplate As Byte, ByRef VerticalRandomisationConversion As Byte, ByRef PermutationPScoreHolder As Long) As Long

Declare Function GetPScores Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Byte, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer) As Long
Declare Function GetPScores2 Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Long, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer) As Long
Declare Function GetPScores4 Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Byte, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer, ByRef SimSequencesInIntegerArray As Integer) As Long

Declare Function GetPScoresRnd Lib "dna.dll" (ByVal WinStartPos As Long, ByVal WindowLength As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByVal OutlyerSequence As Integer, ByVal LengthOfSequence As Long, ByRef PScoreArray As Long, ByRef Seq3To4COnversionArray As Byte, ByRef Seq3ScoreArray As Integer, ByRef SequencesInIntegerArray As Integer, ByRef HorizontalRandomisationArray As Long) As Long

'Declare Function InStrX Lib "dna.dll" (ByVal strtx As Integer, ByRef sequencex As String, ByVal targetx As Integer, ByVal slenx As Integer) As Long
Declare Function FindMChi Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long
Declare Function FindMChi2 Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long
Declare Function FindMChi3 Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal LengthOfSubSequence As Long, ByRef MaxXVal As Long, ByRef MaxYVal As Integer, ByRef MaxChiVal As Double, ByRef ArrayOfChiVals As Double) As Long

Declare Function SmoothChiVals Lib "dna.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long
Declare Function SmoothChiVals2 Lib "dna.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long
Declare Function SmoothChiVals3 Lib "dna.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long
Declare Function SmoothChiVals3P Lib "dna5.dll" (ByVal LengthXoverSeq As Long, ByVal LengthSeq As Long, ByRef ChiValArray As Double, ByRef SmoothChiArray As Double) As Long

Declare Function AddScores Lib "dna.dll" (ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal NumberOfSequencesMinusOne As Long, ByVal NumToAdd As Long, ByVal SeqNumber As Long, ByRef HitsHolder As Long) As Long
Declare Function DoHits Lib "dna.dll" (ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal NumberOfSequencesMinusOne As Long, ByVal Daughter As Long, ByVal MinorParent As Long, ByVal MajorParent As Long, ByRef HitsHolder As Long, ByRef NumHitsHolder As Long) As Long
Declare Function DoHits2 Lib "dna.dll" (ByVal BeginningPosition As Long, ByVal Endingposition As Long, ByVal NumberOfSequencesMinusOne As Long, ByVal Daughter As Long, ByVal MinorParent As Long, ByVal MajorParent As Long, ByRef HitsHolder As Long, ByRef NumHitsHolder As Long) As Long
Declare Function MakeZValue Lib "dna.dll" (ByVal WindowNumber As Long, ByVal NumberOfWindows As Long, ByVal NumberOfGroups As Integer, ByVal NumberOfPermutations As Long, ByVal NumberOfPermutations2 As Long, ByRef DoGroupArray As Byte, ByRef PermutationPScoresArray As Long, ByRef ZScoreHolderArray As Double) As Double
Declare Function MakeZValue3 Lib "dna.dll" (ByRef SqA As Double, ByVal WindowNumber As Long, ByVal NumberOfWindows As Long, ByVal NumberOfGroups As Integer, ByVal NumberOfPermutations As Long, ByVal NumberOfPermutations2 As Long, ByRef DoGroupArray As Byte, ByRef PermutationPScoresArray As Long, ByRef ZScoreHolderArray As Double) As Double

Declare Function MakeZValue2 Lib "dna.dll" (ByVal WindowNumber As Long, ByVal NumberOfWindows As Long, ByVal NumberOfGroups As Integer, ByVal NumberOfPermutations As Long, ByVal NumberOfPermutations2 As Long, ByRef DoGroupArray As Byte, ByRef PermutationPScoresArray As Long, ByRef ZScoreHolderArray As Double) As Double
Declare Function QuickCheckB Lib "dna.dll" (ByVal HP As Long, ByVal LP1 As Long, ByVal LP2 As Long, ByVal SSStep As Long, ByVal LS As Long, ByVal PositionInSequence As Long, ByVal WindowLength As Long, ByRef TallyX As Long, ByRef SeqScore3X As Integer) As Long
Declare Function QuickCheck Lib "dna.dll" (ByVal PositionInSequence As Long, ByVal WindowLength As Long, ByRef TallyX As Long, ByRef SeqScore3X As Integer) As Long

Declare Function MakeVRand Lib "dna.dll" (ByVal NumberOfSpacesToFill As Long, ByVal RandomNumberSeed As Long, ByVal NumberOfPerms As Long, ByVal LengthOfAlignmnet As Long, ByRef RandomNumberTemplate As Byte) As Double
Declare Function DoSums Lib "dna.dll" (ByVal NumberOfPermutations As Long, ByVal NumberOfPermutations2 As Long, ByRef PermutationSScores As Long, ByRef PermutationPScores As Long) As Long
Declare Function Get3Score Lib "dna.dll" (ByVal GapFlag As Byte, ByVal LengthOfSequences As Long, ByVal Sequence1 As Integer, ByVal Sequence2 As Integer, ByVal Sequence3 As Integer, ByRef SequenceIntegerArray As Integer, ByRef Pattern3Holder As Integer) As Long
Declare Function ReSortArray Lib "dna.dll" (ByVal WindowNumber As Long, ByVal NumberOfWindows As Long, ByVal InPosition As Long, ByVal ReadNumber As Long, ByVal NumberOfBSReps As Long, ByRef FileBuffer As Integer, ByRef SortingArray As Integer) As Long
Declare Function DoChiPerms Lib "dna.dll" (ByVal MaxChiVal As Double, ByVal WindowSize As Long, ByVal LengthOfSubSeq As Long, ByVal LengthOfRegion As Long, ByVal PermutationNumber As Long, ByVal LeftOffset As Long, ByRef PermutationScoreArray As Byte, ByRef ScoreArray As Byte) As Long
Declare Function FillMatrix Lib "dna.dll" (ByVal LengthOfSequence As Long, ByVal BeginningOfRegion As Long, ByVal EndingOfRegion As Long, ByVal DistanceR As Double, ByRef RecombMatrixx As Double) As Long
Declare Function FindSubSeqGCA Lib "dna.dll" (ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long) As Long
Declare Function FindSubSeqGCA2 Lib "dna.dll" (ByRef Identical As Byte, ByVal IndelFlag As Byte, ByVal LengthOfSequence As Long, ByVal Sequence1 As Long, ByVal Sequence2 As Long, ByVal Sequence3 As Long, ByRef SequencesInIntegerArray As Integer, ByRef SubSeqArray As Byte, ByRef XPosDiffArray As Long, ByRef XDiffPosArray As Long, ByRef NumberOfDifferences As Long) As Long

'int FAR pascal FindSubSeqGCA(               char gcindelflag,        int LSeq,                     int seq1,                    int seq2,                int seq3,               short int *SeqNum,                        char *SubSeq,               int *XPosDiff,               int *XDiffPos,                    int *NDiff){

Declare Function GetFrags Lib "dna.dll" (ByVal CircularFlagX As Integer, ByVal LengthXoverSeq As Long, ByVal SequenceLength As Long, ByVal GCDimSize As Long, ByRef SubSeqArray As Byte, ByRef FragStartpos As Long, ByRef FragEndPos As Long, ByRef FragmentScore As Long, ByRef FragmentCount As Long) As Long
'int FAR pascal GetFrags(                short int CircularFlag,         int LenXoverSeq,              int LSeq,                     int maxcount,            char *SubSeq,              int *FragSt,                int *FragEn,              int *FragScore,              int *FragCount){

Declare Function GetAncDst Lib "dna.dll" (ByVal NumberOfSequences As Long, ByVal SequenceLength As Long, ByRef AncestralSequenceArray As Integer, ByRef SequenceArray As Integer, ByRef AncestralDistances As Single, ByRef ConversionArray As Double) As Long
'int FAR pascal GetAncDst(               int Nextno,                      int lseq,                      short int *AncSeq,                       short int *SeqNum,              float *AncDstMat,                    double *ConDeg ){

Declare Function MakeAnc Lib "dna.dll" (ByVal NumberOfSequences As Long, ByVal SequenceLength As Long, ByVal CurrentPos As Long, ByRef BranchMapArray As Long, ByRef THoldX As Double, ByRef PathArray As Long, ByRef IdneticalArray As Byte, ByRef ConvX As Byte, ByRef AncSeqArray As Integer, ByRef SequenceArray As Integer) As Long
Declare Function getmaxfragscore Lib "dna.dll" Alias "GetMaxFragScore" (ByVal LenXoverSeqx As Long, ByVal LenSeqsx As Long, ByVal CircularFlagX As Integer, ByVal GCMissmatchPenX As Integer, ByRef MissMatchPenArray As Double, ByRef MaxScorePosX As Long, ByRef FragMaxScorex As Long, ByRef FragScoreX As Long, ByRef FragCountx As Long, ByRef HiFragScore As Long) As Long
Declare Function GetMaxFragScoreB Lib "dna.dll" (ByVal LenXoverSeqx As Long, ByVal LenSeqsx As Long, ByVal CircularFlagX As Integer, ByVal GCMissmatchPenX As Integer, ByRef MissMatchPenArray As Double, ByRef MaxScorePosX As Long, ByRef FragMaxScorex As Long, ByRef FragScoreX As Long, ByRef FragCountx As Long, ByRef HiFragScore As Long) As Long

Declare Function CalcKMax Lib "dna.dll" (ByVal GCMissmatchPenX As Integer, ByVal XOLen As Long, ByRef MissPen As Double, ByRef LLx As Double, ByRef KMaxX As Double, ByRef NDiffx As Long, ByRef highenoughx As Long) As Long
Declare Function GCCalcPVal Lib "dna.dll" (ByVal LSeqX As Long, ByVal LenXoverX As Long, ByRef FragMaxScorex As Long, ByRef PValsx As Double, ByRef FragCountx As Long, ByRef KMaxX As Double, ByRef LLx As Double, ByRef highenoughx As Long, ByRef Critval As Double) As Double
Declare Function GCGetHiPVal Lib "dna.dll" (ByVal LSeqX As Long, ByVal LenXoverSeqx As Long, ByRef FragCountx As Long, ByRef PValsx As Double, ByRef MaxYx As Long, ByRef MaxXx As Long, ByRef highenoughx As Long) As Double
Declare Function FinishDists Lib "dna.dll" (ByVal LSeqX As Long, ByVal NextnoX As Long, ByVal UpperboundPermarray As Long, ByVal BPosition As Long, ByVal EPosition As Long, ByRef FMatX As Single, ByRef SMatx As Single, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef PermValidx As Single, ByRef PermDiffsx As Single, ByRef SeqnumX As Integer) As Double
Declare Function FinishDists3 Lib "dna.dll" (ByVal LSeqX As Long, ByVal NextnoX As Long, ByVal UpperboundPermarray As Long, ByVal BPosition As Long, ByVal EPosition As Long, ByRef FMatX As Single, ByRef SMatx As Single, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef PermValidx As Single, ByRef PermDiffsx As Single, ByRef SeqnumX As Integer) As Double
Declare Function GCXoverDP Lib "dna5.dll" (ByVal MCFlag As Long, ByVal UBPV As Long, ByRef PVals As Double, ByVal LowestProb As Double, ByVal MCCorrection As Long, ByVal ShortOutFlag As Long, ByVal CircularFlag As Long, ByVal GCDimSize As Long, ByVal LenStrainseq0 As Long, ByVal GCMissmatchPen As Integer, ByVal GCIndelFlag As Byte, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal UBFST As Long, ByRef FragSt As Long, ByRef FragEn As Long, ByVal UBFS As Long, ByRef FragScore As Long, ByRef SeqNum As Integer, ByVal UBSS As Long, ByRef SubSeq As Byte, ByVal UBMSP As Long, ByRef MaxScorePos As Long, ByVal UBFMS As Long, ByRef FragMaxScore As Long, ByRef HighEnough As Long) As Double
Declare Function GCXoverDP2 Lib "dna5.dll" (ByVal UBCS As Long, ByRef CS As Byte, ByVal ubfss As Long, ByRef FSSGC As Byte, ByVal MCFlag As Long, ByVal UBPV As Long, ByRef PVals As Double, ByVal LowestProb As Double, ByVal MCCorrection As Long, ByVal ShortOutFlag As Long, ByVal CircularFlag As Long, ByVal GCDimSize As Long, ByVal LenStrainseq0 As Long, ByVal GCMissmatchPen As Integer, ByVal GCIndelFlag As Byte, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal UBFST As Long, ByRef FragSt As Long, ByRef FragEn As Long, ByVal UBFS As Long, ByRef FragScore As Long, ByVal UBSS As Long, ByRef SubSeq As Byte, ByVal UBMSP As Long, ByRef MaxScorePos As Long, ByVal UBFMS As Long, ByRef FragMaxScore As Long, ByRef HighEnough As Long) As Double


'GCXoverDP(int MCFlag, double                                       UBPV, double *mtP,                    double *PVals, double *KMax, double *Critval,                           double *LL, double LowestProb, double *PCO,                         int MCCorrection,         int ShortOutFlag, int CircularFlag                      , int GCDimSize          , int lenstrainseq0, short int GCMissmatchPen,                char GCIndelFlag,             int Seq1, int Seq2, int Seq3,                             int UBFST,           int *FragSt, int *FragEn                   , int UBFS, int *FragScore,                   int *FragCount,    short int *SeqNum,           int UBSS,              char *SubSeq,         int UBMSP,          int *MaxScorePos            , int UBFMS      , int *FragMaxScore, int *HighEnough)
Declare Function QuickDist Lib "dna.dll" (ByVal LSeqX As Long, ByVal NextnoX As Long, ByVal UpperboundPermarray As Long, ByVal BPosition As Long, ByVal EPosition As Long, ByRef FMatX As Single, ByRef SMatx As Single, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef PermValidx As Single, ByRef PermDiffsx As Single, ByRef SeqnumX As Integer) As Double
Declare Function QuickDist5 Lib "dna.dll" (ByVal LSeqX As Long, ByVal NextnoX As Long, ByVal UpperboundPermarray As Long, ByVal BPosition As Long, ByVal EPosition As Long, ByRef SMatx As Single, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef SeqnumX As Integer) As Double
Declare Function QuickDist6 Lib "dna.dll" (ByVal LSeqX As Long, ByVal NextnoX As Long, ByVal UpperboundPermarray As Long, ByVal BPosition As Long, ByVal EPosition As Long, ByRef ISeqs As Long, ByRef SMatx As Single, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef SeqnumX As Integer) As Double


'double FAR pascal QuickDist(             int lseq,            int Nextno,            int ub,                            int BPos3,               int EPos3,               float *FMat,           float *SMat,           float *SubValid,           float *SubDiffs,           float *PermValid,           float *PermDiffs,           short int *SeqNum)


Declare Function GetHighest Lib "dna.dll" (ByVal C As Long, ByVal A As Long, ByRef S As Long, ByVal UBMTN1 As Long, ByRef MTN As Long, ByRef TD As Single, ByRef MaskSeq As Long, ByRef DoneThisPair As Integer) As Single
Declare Function GetHighest2 Lib "dna.dll" (ByVal C As Long, ByVal A As Long, ByRef S As Long, ByVal UBMTN1 As Long, ByRef MTN As Long, ByRef TD As Single, ByRef ColTot As Single, ByRef MaskSeq As Long, ByRef DoneThisPair As Integer) As Single

'int FAR pascal GetHighest(''''''''''''''''''int C,             int A,       int *s,         int UBMTN              , int *MTN        , float*TD          , int *MaskSeq         , short int *DoneThisPair){

Declare Function UpdateColHigh Lib "dna.dll" (ByVal A As Long, ByVal C As Long, ByVal x As Long, ByVal UBMTN As Long, ByRef MTN As Long, ByRef MaskSeq As Long, ByRef ColHigh As Single, ByVal UBTD As Long, ByRef TD As Single, ByVal UBDTP As Long, ByRef DoneThisPair As Integer) As Long

'int FAR pascal UpdateColHigh(                   int A,          int C,         int x,           int UBMTN, int *MTN                      , int *MaskSeq,      float *ColHigh       , int UBTD,              float *TD,      int UBDTP, short int *DoneThisPair ){

Declare Function MakeTreeArray Lib "dna.dll" (ByVal NextnoX As Long, ByRef ArrayX As Single, ByRef arrayy As Single) As Long
Declare Function MakeTreeArrayX Lib "dna.dll" (ByVal NextnoX As Long, ByRef ArrayX As Single, ByRef arrayy As Single) As Long
Declare Function MakeTreeArrayXP Lib "dna5.dll" (ByVal NextnoX As Long, ByRef ArrayX As Single, ByRef arrayy As Single) As Long

'int FAR pascal MakeTreeArray (               int nextno,            float *tmat2,           float *tmat2bak){

Declare Function TreeMid Lib "dna.dll" (ByVal MaxCurPosX As Long, ByVal NumberOfSeqsX As Long, ByRef NumDonex As Double, ByRef TMat2x As Single, ByRef TBx As Long, ByRef NodeOrderx As Long, ByRef MidNodex As Double, ByRef nonelenx As Double) As Double
Declare Function TreeMidP Lib "dna5.dll" (ByVal MaxCurPosX As Long, ByVal NumberOfSeqsX As Long, ByRef NumDonex As Double, ByRef TMat2x As Single, ByRef TBx As Long, ByRef NodeOrderx As Long, ByRef MidNodex As Double, ByRef nonelenx As Double) As Double

'double FAR pascal TreeMid(             int MaxCurPos,           int NumberOfSeqs,            double *NumDone,           float *TMat2,           int *TB,             int *NodeOrder,          double *MidNode,           double *NodeLen){

Declare Function UltraTreeDist Lib "dna.dll" (ByVal MDx As Double, ByVal MaxCurPosX As Long, ByVal NumSeqs As Long, ByRef DistMatrix As Single, ByRef NumDonex As Double, ByRef DoneThisx As Long, ByRef AbBex As Long, ByRef NodeOrderx As Long, ByRef MidNodex As Double, ByRef NodeLenx As Double) As Double
Declare Function UltraTreeDistP Lib "dna5.dll" (ByVal MDx As Double, ByVal MaxCurPosX As Long, ByVal NumSeqs As Long, ByRef DistMatrix As Single, ByRef NumDonex As Double, ByRef DoneThisx As Long, ByRef AbBex As Long, ByRef NodeOrderx As Long, ByRef MidNodex As Double, ByRef NodeLenx As Double) As Long

'double FAR pascal UltraTreeDist(             double MD,           int MaxCurPos,            int NumberOfSeqs,      float *TMat2,               double *NumDone,          int *DoneThis,           int *AbBe,           int *NodeOrder,           double *MidNode,          double *NodeLen ){

'Declare Function QuickDist2 Lib "dna.dll" (ByVal lseqx As Long, ByVal Nextnox As Long, ByVal ubnd As Long, ByVal BPos3x As Long, ByVal EPos3x As Long, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef SeqnumX As Integer, ByRef ISeqsX As Long) As Double
Declare Function MakeRmat Lib "dna.dll" Alias "MakeRMat" (ByVal NextNo As Long, ByVal WinPP As Long, ByRef RMatx As Double, ByRef LMatx As Double, ByRef PDist As Double, ByRef ISeqs As Long, ByRef FMat As Single, ByRef SMat As Single, ByRef CompMat As Long, ByRef TtX As Double) As Double
'double FAR pascal MakeRMat(             int Nextno,           int WinPP,           double *RMat,          double *LMat,          double *PDist,         int *Iseqs,         float *FMat,           float *SMat,         int *CompMat,          double *Ttx){


Declare Function CalCR Lib "dna.dll" (ByVal TmF As Double, ByVal NextNo As Long, ByVal WinPP As Long, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef RCorr As Single, ByRef RInv As Single, ByRef IntVal As Double, ByRef RMat As Double, ByRef tRCorr As Single) As Double
Declare Function MakeLMat Lib "dna.dll" (ByVal x As Long, ByVal NextNo As Long, ByRef LMat As Double, ByRef PDist As Double, ByRef SubValidx As Single, ByRef SubDiffsx As Single, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef AVSN As Double) As Double
'double FAR pascal MakeLMat(             int X,           int Nextno,          double *LMat,          double *PDist,         float *SubValidx,          float *SubDiffsx,          int *Iseqs,           int *CompMat,         double *AVSN){

Declare Function MakeEventSeqs Lib "dna.dll" (ByVal DA As Long, ByVal MiP As Long, ByVal MaP As Long, ByVal EN As Long, ByVal LSeq As Long, ByRef EventSeq As Integer, ByRef SeqNum As Integer) As Double
Declare Function DefineEvent Lib "dna.dll" (ByVal ShortOutFlag As Long, ByVal LongWindedFlag As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LowHomol As Long, ByVal TargetX As Long, ByVal CircularFlag As Long, ByVal XX As Long, ByVal XoverWindow As Long, ByVal LenSeq As Long, ByVal LenXoverSeq As Long, ByVal SeqDaughter As Long, ByVal SeqMinorP As Long, ByRef EndFlag As Long, ByRef BE As Long, ByRef EN As Long, ByrefNCommon As Long, ByrefXOverLength As Long, ByRef XoverSeqNum As Byte, ByRef XDiffPos As Long, ByRef XOverHomologyNum As Long) As Double
Declare Function MakeGoodC Lib "dna.dll" (ByVal NextNo As Long, ByVal LenSeq As Long, ByRef GoodC As Long, ByRef BPosLR As Long, ByRef SeqNum As Integer) As Double
Declare Function FindOverlap Lib "dna.dll" (ByVal LenSeq As Long, ByVal BPos2 As Long, ByVal EPos2 As Long, ByRef RSize As Long, ByRef OLSeq As Long) As Long
Declare Function MakeTMatch Lib "dna.dll" (ByVal WinPP As Long, ByRef CompMat As Long, ByRef tMatchX As Long, ByRef RNum As Long, ByRef FoundOne As Long, ByRef SQ As Long, ByRef RList As Long, ByRef FOX As Long, ByRef CSeq As Long, ByRef tMatch As Double, ByRef InvList As Long) As Long
Declare Function ttestprob Lib "dna.dll" (ByVal T As Double, ByVal DF As Long) As Double
Declare Function StripUnfound Lib "dna.dll" (ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef InvList As Long, ByRef FoundOne As Long, ByRef RCorr As Single, ByRef RLScore As Double) As Double
Declare Function MakeRCompat Lib "dna.dll" (ByRef ISeqs As Long, ByRef CompMat As Long, ByVal WinPP As Long, ByVal NextNo As Long, ByRef RCompat As Long, ByRef RCompatB As Long, ByRef InPen As Long, ByRef RCats As Long, ByRef RNum As Long, ByRef NRNum As Long, ByRef GoodC As Long, ByRef DoneX As Long, ByRef RList As Long, ByRef NRList As Long, ByRef FAMat As Single, ByRef LDist As Double) As Double
'double FAR pascal MakeRCompat(              int *ISeqs,         int *CompMat,         int WinPP,           int Nextno,          int *RCompat,          int *RCompatB,            int *InPen,           int *RCats,          int *RNum,          int *NRNum,          int *GoodC,           int *DoneX,          int *Rlist,         int *NRList,        float *FAMat,              double *LDist){
   

Declare Function MakeActualSeqSize Lib "dna.dll" (ByVal LS As Long, ByVal NextNo As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef ActualSeqSize As Long, ByRef SeqNum As Integer) As Long
Declare Function MakeTDiffs Lib "dna.dll" (ByVal NextNo As Long, ByVal xNextno As Long, ByRef TDiffs As Single, ByRef TValid As Single, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef Uninvolved As Long, ByRef ActualSeqSize As Long) As Long
Declare Function MakeTDiffs2 Lib "dna.dll" (ByVal NextNo As Long, ByVal xNextno As Long, ByRef TDiffs As Single, ByRef PermDIffs As Single, ByRef Uninvolved As Long, ByRef ActualSeqSize As Long) As Long
Declare Function MakeTDiffs3 Lib "dna.dll" (ByVal NextNo As Long, ByVal xNextno As Long, ByRef TValid As Single, ByRef PermValid As Single, ByRef Uninvolved As Long, ByRef ActualSeqSize As Long) As Long


'int FAR pascal MakeTDiffs(                 int nextno,           int xnextno,           float *TDiffs,        float *TValid,           float *PermDiffs,          float *PermValid,         int *UnInvolved,          int *ActualSeqSize){

'int FAR pascal MakePermDiffs(int Nextno, int MinSeqSize,double *TDiffs, double *TValid, double *PermDiffs, double *PermValid, double *Distance){
Declare Function MakePermDiffs Lib "dna.dll" (ByVal NextNo As Long, ByVal MinSeqSize As Long, ByRef TDiffs As Single, ByRef TValid As Single, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef Distance As Single) As Long
'int FAR pascal MakePermDiffs(                int Nextno,           int MinSeqSize,            float *TDiffs,         float *TValid,          float *PermDiffs,          float *PermValid,          float *Distance){

Declare Function ModSN Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal BPos As Long, ByVal Epos As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef Breaks As Long, ByRef SeqNum As Integer, ByRef missdata As Byte) As Long
Declare Function RebuildSeqNum Lib "dna.dll" (ByVal LS As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef Breaks As Long, ByRef RList As Long, ByRef SeqNum As Integer, ByRef tSeqnum As Integer) As Long
'int FAR pascal ModSeqNumY(int BPos, int EPos, int LS, int WinPP, int *RNum, int *BReaks, int *Rlist, short int *SeqNum, short int *tSeqNum){
Declare Function ModSeqNumY Lib "dna.dll" (ByVal BPos As Long, ByVal Epos As Long, ByVal LS As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef Breaks As Long, ByRef RList As Long, ByRef SeqNum As Integer, ByRef tSeqnum As Integer, ByRef missdata As Byte) As Long

Declare Function MakeTrpScore Lib "dna.dll" (ByVal x As Long, ByVal NextNo As Long, ByRef FAMat As Single, ByRef SAMat As Single, ByRef TrpScore As Double, ByRef NuminGroup As Long, ByRef ISeqs As Long, ByRef GroupSeq As Long) As Long
Declare Function MakeTrpScore2 Lib "dna.dll" (ByVal x As Long, ByVal NextNo As Long, ByRef FAMat As Single, ByRef SAMat As Single, ByRef TrpScore As Double, ByRef NuminGroup As Long, ByRef ISeqs As Long, ByRef GroupSeq As Long) As Long

'int FAR pascal MakeTrpScore(               int X,            int Nextno,                 float *FAMat,    float *SAMat,          double *TrpScore,         double *NumInGroup,         int *Iseqs,           int *GroupSeq){

Declare Function MakePairs Lib "dna.dll" (ByVal NextNo As Long, ByVal DA As Long, ByVal Ma As Long, ByVal Mi As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Long) As Long
Declare Function ModSeqNumA Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal BPos As Long, ByVal Epos As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef Breaks As Long, ByRef SeqNum As Integer) As Long
Declare Function ModSeqNumB Lib "dna.dll" (ByVal BPos As Long, ByVal Epos As Long, ByVal LS As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef Breaks As Long, ByRef RList As Long, ByRef SeqNum As Integer, ByRef tSeqnum As Integer) As Long
Declare Function FindMissing Lib "dna.dll" (ByVal LS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal Z As Long, ByVal EN As Long, ByRef MissingData As Byte) As Long
Declare Function CheckSplit Lib "dna.dll" (ByVal LS As Long, ByVal BE As Long, ByVal EN As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef Split As Long, ByRef MissingData As Byte) As Long
Declare Function CheckSplit2 Lib "dna.dll" (ByVal step As Long, ByVal LS As Long, ByVal BE As Long, ByVal EN As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef Split As Long, ByRef MissingData As Byte) As Long

Declare Function MakeDoneThis Lib "dna.dll" (ByVal NextNo As Long, ByRef FMat As Single, ByRef FAMat As Single, ByRef SAMat As Single, ByRef LD As Double, ByRef DoneThis As Long, ByRef ISeqs As Long) As Long
Declare Function MakeDoneThis2 Lib "dna.dll" (ByVal NextNo As Long, ByRef FMat As Single, ByRef FAMat As Single, ByRef SAMat As Single, ByRef DoneThis As Long, ByRef ISeqs As Long) As Long
Declare Function MakeDoneThis3 Lib "dna.dll" (ByVal NextNo As Long, ByRef FMat As Single, ByRef FAMat As Single, ByRef SAMat As Single, ByRef DoneThis As Long, ByRef ISeqs As Long) As Long

'int FAR pascal MakeDoneThis (               int Nextno,           float *FMat,          float *FAMat,          float *SAMat,          double *LD,         int *DoneThis,          int *Iseqs){

Declare Function MakePhPrScore Lib "dna.dll" (ByVal NextNo As Long, ByVal TmF As Double, ByRef TraceInvolvedBak As Long, ByRef DoneThis As Long, ByRef ISeqs As Long, ByRef PhPrScore As Double, ByRef FMat As Single, ByRef SMat As Single, ByRef tPhPrScore As Double, ByRef SubPhPrScore As Double, ByRef SubScore As Double) As Double
'double FAR pascal MakePhPrScore(             int Nextno,           double tmF,          int *TraceInvolvedBak,          int *DoneThis,          int *Iseqs,          double *PhPrScore,         float *FMat,          float *SMat,          double *tPhPrScore,         double *SubPhPrScore,         double *SubScore){

Declare Function MakeTrpGroups Lib "dna.dll" (ByVal x As Long, ByVal NextNo As Long, ByRef NuminGroup As Long, ByRef CompMat As Long, ByRef ISeqs As Long, ByRef DoneOne As Long, ByRef GroupSeq As Long, ByRef MinDistZ As Double, ByRef FAMat As Single) As Long
Declare Function MakeTrpGroups2 Lib "dna.dll" (ByVal x As Long, ByVal NextNo As Long, ByRef NuminGroup As Long, ByRef CompMat As Long, ByRef ISeqs As Long, ByRef DoneOne As Long, ByRef GroupSeq As Long, ByRef MinDistZ As Double, ByRef FAMat As Single) As Long

'int FAR pascal MakeTrpGroups(                int X,            int Nextno,          double *NumInGroup,         int *CompMat,         int *Iseqs,           int *DoneOne,         int *GroupSeq,           double *MinDistZ,         float *FAMat){

Declare Function MakeBPosLR Lib "dna.dll" (ByVal VSN As Long, ByVal tSN As Long, ByVal LS As Long, ByVal BPos As Long, ByVal Epos As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long, ByRef BPosLR As Long, ByRef AVSN As Double) As Long
Declare Function MakeOLSeq Lib "dna.dll" (ByVal LS As Long, ByVal BPos As Long, ByVal Epos As Long, ByRef RSize As Long, ByRef OLSeq As Long) As Long
Declare Function AddSeqToUPGMA Lib "dna.dll" (ByVal NextNo As Long, ByVal SortedNo As Long, ByRef XInstance As Integer, ByRef distancebak As Single, ByRef TreeX As Integer, ByRef TreeY As Integer, ByRef Check As Long, ByRef NodeYPos As Integer) As Long
Declare Function AddSeqToUPGMA2 Lib "dna.dll" (ByVal NextNo As Long, ByVal SortedNo As Long, ByRef XInstance As Integer, ByRef distancebak As Single, ByRef TreeX As Integer, ByRef TreeY As Integer, ByRef Check As Long, ByRef NodeYPos As Integer) As Long

'int FAR pascal AddSeqToUPGMA(                int Nextno,          int SortedNo,            short int *XInstance,       float *DistanceBak,          short int *TreeX,         short int *TreeY,         int *Check,       short int *NodeYPos){

Declare Function MakeRList Lib "dna.dll" (ByVal NextNo As Long, ByRef GoodC As Long, ByRef ISeqs As Long, ByRef RListX As Long, ByRef InvListX As Long, ByRef RNumX As Long, ByRef RList As Long, ByRef InvList As Long, ByRef RNum As Long, ByRef RInv As Single, ByRef RCorr As Single, ByRef PScores As Double, ByRef TPVal As Double, ByRef TVal As Double, ByRef TotP As Double, ByRef RLScore As Double, ByRef dontredox As Byte, ByRef accpetablecorx As Byte, ByRef rcorrwarnx As Byte) As Double
Declare Function TreeDist2 Lib "dna.dll" (ByVal NextNo As Long, ByRef TreeX As Integer, ByRef TreeY As Integer, ByRef TreeDistance As Single) As Long
'int FAR pascal TreeDist2(                int Nextno,          short int *TreeX,        short int *TreeY,       float *TreeDistance){

Declare Function MakeTMatch2 Lib "dna.dll" (ByVal tWinPP As Long, ByVal WinPP As Long, ByRef tMatchX As Long, ByRef SQ As Long, ByRef tMatch As Double, ByRef RNum As Long, ByRef RList As Long, ByRef CompMat As Long) As Long
Declare Function TestRList Lib "dna.dll" (ByVal WinPP As Long, ByRef A As Long, ByRef Z As Long, ByRef FoundOne As Long, ByRef RNum As Long, ByRef SQ As Long, ByRef RList As Long) As Long
Declare Function StripDupInv Lib "dna.dll" (ByVal NextNo As Long, ByRef RCorr As Single, ByRef RLScore As Double, ByRef InPen As Long, ByRef RNum As Long, ByRef RList As Long, ByRef InvList As Long) As Long
Declare Function MakeLDist Lib "dna.dll" (ByVal NextNo As Long, ByRef LDist As Double, ByRef FAMat As Single, ByRef RNum As Long, ByRef RList As Long) As Long
'int FAR pascal MakeLDist(                int Nextno,           double *LDist,        float *FAMat,           int *RNum,          int *Rlist){

Declare Function MakeRelevant Lib "dna.dll" (ByVal NextNo As Long, ByRef Relevant As Long, ByRef RNum As Long, ByRef RList As Long) As Long
Declare Function CopySeqs Lib "dna.dll" (ByVal LS As Long, ByVal NextNo As Long, ByRef SeqNum As Integer, ByRef PermSeqNum As Integer) As Long
Declare Function SplitEvent Lib "dna.dll" (ByVal XOWin As Long, ByVal LS As Long, ByVal LenXoverSeq As Long, ByVal SeqDaughter As Long, ByVal SeqMinorP As Long, ByVal BTarget As Long, ByVal ETarget As Long, ByRef XOverLength As Long, ByRef NCommon As Long, ByRef XPosDiff As Long, ByRef XoverSeqNum As Byte) As Long
Declare Function MakeUninvolved Lib "dna.dll" (ByVal WinPP As Long, ByVal NextNo As Long, ByRef Uninvolved As Long, ByRef RNum As Long, ByRef RList As Long) As Long
Declare Function StripUnfound2 Lib "dna.dll" (ByVal WinPP As Long, ByVal AddNum As Long, ByRef RNum As Long, ByRef WinnerPos As Long, ByRef RList As Long, ByRef Breaks As Long) As Long
Declare Function CopySeq Lib "dna.dll" (ByVal LS As Long, ByVal NextNo As Long, ByVal x As Long, ByVal Y As Long, ByRef SeqNum As Integer) As Long
Declare Function DelPVals Lib "dna.dll" (ByVal GCMaxOverlapFrags As Integer, ByVal Y As Long, ByVal x As Long, ByVal LS As Long, ByRef PVals As Double, ByRef FragCount As Long, ByRef FragSt As Long, ByRef FragEn As Long, ByRef MaxScorePos As Long, ByRef DeleteArray As Long) As Long
Declare Function MakeSubProb Lib "dna.dll" (ByVal x As Long, ByVal LS As Long, ByVal LenXoverSeq As Long, ByVal BTarget As Long, ByVal ETarget As Long, ByRef SubSeq As Byte, ByRef LL As Double, ByRef KMax As Double, ByRef MissPen As Double, ByRef Critval As Double) As Double
Declare Function GrowMChiWin Lib "dna.dll" (ByVal LO As Long, ByVal RO As Long, ByVal LenXoverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte) As Long
Declare Function ChiPVal2 Lib "dna.dll" (ByVal x As Double) As Double
Declare Function DestroyPeaks Lib "dna.dll" (ByVal MaxY As Long, ByVal LenXoverSeq As Long, ByVal LS As Long, ByVal LO As Long, ByVal RO As Long, ByRef SmoothChi As Double, ByRef Chivals As Double) As Long
Declare Function FindSide Lib "dna.dll" (ByVal TopL As Long, ByVal TopR As Long, ByVal LS As Long, ByVal LO As Long, ByVal RO As Long, ByVal WinWin As Long, ByVal LenXoverSeq As Long, ByVal MaxY As Long, ByRef Scores As Byte, ByRef HiLeft As Double, ByRef HiRight As Double) As Long
Declare Function GrowMChiWin2 Lib "dna.dll" (ByVal LO As Long, ByVal RO As Long, ByVal LenXoverSeq As Long, ByVal HWindowWidth As Long, ByVal TWin As Long, ByVal MaxY As Long, ByVal LS As Long, ByVal A As Long, ByVal C As Long, ByVal MaxFailCount As Long, ByRef MPV As Double, ByRef WinWin As Long, ByRef MChi As Double, ByRef TopL As Long, ByRef TopR As Long, ByRef TopLO As Long, ByRef TopRO As Long, ByRef Scores As Byte, ByRef MDMap As Byte) As Long
Declare Function MakeBanWin Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal HWindowWidth As Long, ByVal LS As Long, ByVal LenXoverSeq As Long, ByRef BanWin As Long, ByRef MDMap As Byte, ByRef MissingData As Byte, ByRef XPosDiff As Long, ByRef XDiffPos As Long) As Long
Declare Function DestroyPeak Lib "dna.dll" (ByVal MaxY As Long, ByVal LS As Long, ByVal RO As Long, ByVal LO As Long, ByVal LenXoverSeq As Long, ByRef LOT As Double, ByRef SmoothChi As Double, ByRef Chivals As Double) As Long
Declare Function DestroyPeakP Lib "dna5.dll" (ByVal MaxY As Long, ByVal LS As Long, ByVal RO As Long, ByVal LO As Long, ByVal LenXoverSeq As Long, ByRef LOT As Double, ByRef SmoothChi As Double, ByRef Chivals As Double) As Long

Declare Function GetAC Lib "dna.dll" (ByVal LenXoverSeq As Long, ByVal LS As Long, ByVal MaxY As Long, ByVal MaxX As Long, ByVal TWin As Long, ByRef A As Long, ByRef C As Long, ByRef Scores As Byte) As Long
Declare Function vQuickDist Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal UB As Long, ByVal BPos3 As Long, ByVal EPos3 As Long, ByRef FMat As Single, ByRef SMat As Single, ByRef SubValid As Single, ByRef SubDiffs As Single, ByRef PermValid As Single, ByRef PermDIffs As Single, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Double
Declare Function vQuickDist2 Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal UB As Long, ByVal BPos3 As Long, ByVal EPos3 As Long, ByRef FMat As Single, ByRef SMat As Single, ByRef SubValid As Single, ByRef SubDiffs As Single, ByRef PermValid As Single, ByRef PermDIffs As Single, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Double

'double FAR pascal vQuickDist             (int lseq,           int Nextno,           int ub,           int BPos3,           int EPos3,           float *FMat,         float *SMat,           float *SubValid,          float *SubDiffs,          float *PermValid,          float *PermDiffs,          short int *SeqNum,       int *iseqs)

Declare Function FindHiSeqs Lib "dna.dll" (ByVal LS As Long, ByVal RS As Long, ByVal RE As Long, ByVal Ac As Long, ByVal Mi As Long, ByVal Ma As Long, ByRef SeqNum As Integer, ByRef Dists As Single, ByRef Valids As Single, ByRef Diffs As Single) As Long
'int FAR pascal FindHiSeqs(                  int LS,           int RS,          int RE,          int Ac,          int Mi,           int Ma,            short int *SeqNum,         float *Dists,         float *Valids,            float *Diffs){

Declare Function CheckMatrix Lib "dna.dll" (ByVal UB As Long, ByVal SCO As Long, ByVal MinSeqSize As Long, ByVal NextNo As Long, ByRef Valtot As Long, ByRef ISeqs As Long, ByRef PermValid As Single, ByRef SubValid As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef FAMat As Single, ByRef SAMat As Single) As Long
Declare Function CheckMatrix2 Lib "dna.dll" (ByVal UB As Long, ByVal SCO As Long, ByVal MinSeqSize As Long, ByVal NextNo As Long, ByRef Valtot As Long, ByRef ISeqs As Long, ByRef PermValid As Single, ByRef SubValid As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef FAMat As Single, ByRef SAMat As Single) As Long

'int FAR pascal CheckMatrix(                int UB,           int SCO,             int MinSeqSize,          int Nextno,          int *Valtot,         int *ISeqs,           float *PermValid,         float *SubValid,          float *FMat,          float *SMat,          float *FAMat,            float *SAMat){

Declare Function FindNextRedo Lib "dna.dll" (ByVal Start As Long, ByRef Relevant2 As Byte, ByRef RedoList As Long, ByRef ISeqs As Long, ByRef Relevant As Long) As Long
Declare Function CleanRedo Lib "dna5.dll" (ByVal ReplaceWithNextNo As Long, ByVal x As Long, ByVal NextNo As Long, ByRef RedoListSize As Long, ByVal UBRL As Long, ByRef RedoList As Long) As Long
'                 CleanRedo                 (int x,            int NextNo      , int *RedoLS                  ,  int UBRL,         int *RedoList);
Declare Function CleanRedoList Lib "dna.dll" (ByRef RedoListSize As Long, ByRef RedoList As Long) As Long
Declare Function MarkRemovals Lib "dna.dll" (ByVal NextNo As Long, ByVal WinPP As Long, ByVal RedoListSize As Long, ByRef RedoList As Long, ByRef RNum As Long, ByRef RList As Long, ByRef DoPairs As Long) As Long
Declare Function ModSeqNumZ Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal BPos As Long, ByVal Epos As Long, ByVal WinPP As Long, ByRef RNum As Long, ByRef RList As Long, ByRef Breaks As Long, ByRef SeqNum As Integer, ByRef missdata As Byte) As Long
Declare Function ModSeqNumD Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal FS As Long, ByVal BE As Long, ByVal EN As Long, ByRef SeqNum As Integer, ByRef MissingData As Byte) As Long
Declare Function ModSeqNumE Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal FS As Long, ByVal BE As Long, ByVal EN As Long, ByRef SeqNum As Integer, ByRef MissingData As Byte) As Long
Declare Function ReplaceSeq Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal S1 As Long, ByVal s2 As Long, ByRef SeqNum As Integer, ByRef MissingData As Byte) As Long
Declare Function PBar Lib "dna.dll" (ByRef valu As Double) As Long
Declare Function MakeSDM Lib "dna.dll" (ByVal NextNo As Long, ByVal SLen As Long, ByRef SP As Long, ByRef EP As Long, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef MissingData As Byte, ByRef SeqNum As Integer, ByRef SDM As Double, ByRef DistMat As Double) As Long
Declare Function MakeSDMP Lib "dna5.dll" (ByVal NextNo As Long, ByVal SLen As Long, ByRef SP As Long, ByRef EP As Long, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef MissingData As Byte, ByRef SeqNum As Integer, ByRef SDM As Double, ByRef DistMat As Double) As Long
Declare Function MakeSDMP2 Lib "dna5.dll" (ByVal NextNo As Long, ByVal SLen As Long, ByRef SP As Long, ByRef EP As Long, ByRef ISeqs As Long, ByRef CompMat As Long, ByRef MissingData As Byte, ByRef SeqNum As Integer, ByRef SDM As Double, ByRef DistMat As Double) As Long
Declare Function MakeMoveDist Lib "dna5.dll" (ByVal NextNo As Long, ByRef MoveDistF As Single, ByRef MoveDistS As Single, ByVal UBFM As Long, ByRef FMat As Single, ByVal UBSM As Long, ByRef SMat As Single) As Long

Declare Function TransferDist Lib "dna.dll" (ByVal NSeqs As Long, ByVal CR As Long, ByVal Reps As Long, ByRef tFMat As Single, ByRef DstMat As Single) As Double
Declare Function TransferDistP Lib "dna5.dll" (ByVal NSeqs As Long, ByVal CR As Long, ByVal Reps As Long, ByRef tFMat As Single, ByRef DstMat As Single) As Long

'double FAR pascal TransferDist(             int NSeqs,           int cr,           int Reps,           float *tFMat,          float *DstMat){


Declare Function MaketSeqNum Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByRef tSeqNum2 As Integer, ByRef SeqNum As Integer, ByRef FMat As Single) As Long
Declare Function MaketSeqNum2 Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByRef tSeqNum2 As Integer, ByRef SeqNum As Integer, ByRef InvSeq As Long) As Long

'int FAR pascal MaketSeqNum(                int lseq,           int NextNo,           short int *tSeqNum2,       short int *SeqNum,       float *FMat){

Declare Function MakeETSeqNumX Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal tlseq As Long, ByVal RS As Long, ByVal RE As Long, ByRef ETSeqNum As Integer, ByRef TreeSeqNum As Integer) As Long
'int FAR pascal MakeETSeqNumX(                int NextNo,           int lseq,           int tlseq,           int rs,           int RE,           short int *ETSeqNum,       short int *TreeSeqNum){

Declare Function MakeOLSeqB Lib "dna.dll" (ByVal BE As Long, ByVal EN As Long, ByVal LSeq As Long, ByRef OLSeq As Byte) As Long
Declare Function DoSetsA Lib "dna.dll" (ByVal SZ1 As Long, ByVal LSeq As Long, ByRef RI As Long, ByRef OLSeq As Byte, ByRef Sets As Byte, ByRef DoIt As Byte) As Long
Declare Function DoSetsB Lib "dna.dll" (ByVal SZ1 As Long, ByVal LSeq As Long, ByRef RI As Long, ByRef OLSeq As Byte) As Long

'Declare Function doAlignment Lib "clustalw.dll" (ByRef SeqsIn As Integer, ByRef SeqsOut As Integer, ByVal HeightA As Long, ByVal LengthA As Long, ByVal GapOpen As Single, ByVal GapExtend As Single, ByVal RemoveGapsF As Long) As Long

'Declare Function doPOA Lib "poa.dll" Alias "main" (ByRef SeqsIn As Integer, ByRef SeqsOut As Integer, ByVal HeightA As Long, ByVal LengthA As Long, ByVal GapOpen As Single, ByVal GapExtend As Single, ByVal GapExtend2 As Long, ByRef ScoreMat As Double) As Long
Declare Function GetPltValX Lib "dna.dll" (ByVal b As Long, ByVal BSBootReps As Long, ByRef DstMat As Single, ByRef PltVal As Double) As Long

Declare Function MakeDst Lib "dna.dll" (ByVal LSeq As Long, ByVal DA As Long, ByVal Mi As Long, ByVal Ma As Long, ByVal BPos As Long, ByVal Epos As Long, ByRef VDiffs As Double, ByRef SeqNum As Integer) As Double
Declare Function UpdatePlotInfo2 Lib "dna.dll" (ByVal UBPDP As Long, ByVal UPArrayDimXFact As Single, ByVal PVal As Single, ByVal Prg As Long, ByVal LSeq As Long, ByVal BPos As Long, ByVal Epos As Long, ByVal Dst As Single, ByRef MaxHits As Long, ByRef PDistPlt As Single, ByRef ProbPlt As Single, ByRef HitPlt As Long, ByRef RedoPltL As Byte) As Single
Declare Function FastBootDist Lib "dna.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double
Declare Function FastBootDistI Lib "dna.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single, ByRef IdenticalF As Long, ByRef IdenticalR As Long) As Double

Declare Function FastBootDistX Lib "dna.dll" (ByVal DoFirst As Long, ByVal Reps As Long, ByVal NextNo As Long, ByVal LenSeq As Long, ByRef DiffsX As Single, ByRef ValidX As Single, ByRef WeightMod As Long, ByRef SeqNum As Integer, ByRef Distance As Single) As Double

'double FAR pascal FastBootDist(             int df,                int reps,           int nextno,           int lenseq,           float *diffsx,          float *validx,          int *weightmod,          short int *seqnum,       float *distance)

Declare Function CollapseNodesX Lib "dna.dll" (ByVal NextNo As Long, ByVal Cutoff As Single, ByRef T As Long, ByRef DLen As Single, ByRef CMat As Single, ByRef AMat As Single, ByRef TraceBak As Single) As Long
'int FAR pascal CollapseNodesX(               int NextNo,            double CutOff,          int *T,          float *DLen,          float *CMat,          float *AMat,          float *TraceBak){

Declare Function CheckPatternX Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByRef ISeqs As Long, ByRef ST As Long, ByRef EN As Long, ByRef SeqNum As Integer, ByRef Pattern As Double, ByRef DonePattern As Byte) As Long
Declare Function MakeMatchMatX Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal x As Long, ByRef ContainSite As Byte, ByRef SMat As Single, ByRef MatchMat As Single, ByRef BMatch As Single, ByRef BPMatch As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Long
Declare Function MakeMatchMatX2 Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal x As Long, ByRef ContainSite As Byte, ByRef SMat As Single, ByRef MatchMat As Single, ByRef BMatch As Single, ByRef BPMatch As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Long
Declare Function MakeMatchMatX2P Lib "dna5.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal x As Long, ByRef ContainSite As Byte, ByRef SMat As Single, ByRef MatchMat As Single, ByRef BMatch As Single, ByRef BPMatch As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Long
Declare Function MakeMatchMatX2P2 Lib "dna5.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal x As Long, ByRef ContainSite As Byte, ByRef SMat As Single, ByRef MatchMat As Single, ByRef BMatch As Single, ByRef BPMatch As Long, ByRef SeqNum As Integer, ByRef ISeqs As Long) As Long


Declare Function TreeGroupsX Lib "dna.dll" (ByVal NextNo As Long, ByRef THolder As Byte, ByVal TLen As Long, ByVal NLen As Long, ByRef DoneNode As Byte, ByRef TArray As Byte, ByRef tMatch As Byte, ByRef DLen As Single) As Long
Declare Function TreeGroupsXP Lib "dna5.dll" (ByVal NextNo As Long, ByRef THolder As Byte, ByVal TLen As Long, ByVal NLen As Long, ByRef tMatch As Byte, ByRef DLen As Single) As Long

'int FAR pascal TreeGroupsX(                int NextNo,           char *THolder,         int TLen,           int NLen,           char *DoneNode,         char *TArray,         char *TMatch,         float *DLen){

Declare Function MakeDeleteArray Lib "dna.dll" (ByVal FragSt As Long, ByVal FragEn As Long, ByVal FragCount As Long, ByRef DeleteArray As Long) As Long
Declare Function MakeSubSeqPerm Lib "dna.dll" (ByVal LS As Long, ByVal D As Long, ByVal P1 As Long, ByVal P2 As Long, ByRef PermSeqNum As Integer, ByRef XDiffPos As Long, ByRef XPosDiff As Long) As Long

Declare Function FindBesSeqSF Lib "dna.dll" (ByVal NextNo As Long, ByRef ListToRedo As Long, ByRef SMat As Single, ByRef FMat As Single, ByRef BestSeqS As Long, ByRef BestSeqF As Long) As Long
Declare Function FindBesSeqS Lib "dna.dll" (ByVal NextNo As Long, ByRef ListToRedo As Long, ByRef SMat As Single, ByRef BestSeqS As Long) As Long

'int FAR pascal FindBesSeqSF(int Nextno, int *ListToRedo, float  *SMat, float *FMat, int *BestSeqS,int *BestSeqF){
Declare Function ReAddDists Lib "dna.dll" (ByVal NextNo As Long, ByRef ListToRedo As Long, ByRef SAMat As Single, ByRef FAMat As Single, ByRef SCMat As Single, ByRef FCMat As Single, ByRef BestSeqS As Long, ByRef BestSeqF As Long) As Long
Declare Function ReAddDistsB Lib "dna.dll" (ByVal NextNo As Long, ByRef ListToRedo As Long, ByRef SAMat As Single, ByRef SCMat As Single, ByRef BestSeqS As Long) As Long

'int FAR pascal ReAddDists(int Nextno, int *ListToRedo, float *SAMat, float *FAMat,float *SCMat, float *FCMat, int *BestSeqS, int *BestSeqF){


Declare Function MakeRecCMatrix Lib "dna.dll" (ByVal LS As Long, ByVal RSize As Long, ByVal ST As Long, ByVal EN As Long, ByRef SCArray As Long, ByRef RegionMat As Single) As Long
Declare Function MakeHeatPlot Lib "dna.dll" (ByVal MaxN As Double, ByVal UBHM As Long, ByVal ColorScheme As Long, ByVal hdcRef As Long, ByVal RSize As Long, ByVal XAddj As Double, ByRef HeatMap As Long, ByRef RegionMat As Double) As Long

Declare Function MakeVarMap Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByRef SeqNum As Integer, ByRef VarSiteMap As Byte, ByRef VRPos As Long, ByRef VXPos As Long, ByRef ISeqs As Long, ByRef CompMat As Long) As Long
Declare Function MakeVarMap2 Lib "dna.dll" (ByVal NextNo As Long, ByVal LS As Long, ByVal UBVSM As Long, ByRef SeqNum As Integer, ByRef VarSiteMap As Integer, ByRef VRPos As Long, ByRef VXPos As Long, ByRef ISeqs As Long, ByRef CompMat As Long) As Long

Declare Function MakeCntHit Lib "dna.dll" (ByVal BPos As Long, ByVal Epos As Long, ByVal SWinx As Long, ByVal NextNo As Long, ByVal LenVarSeq As Long, ByVal LS As Long, ByRef CntHit As Double, ByRef VarSiteMap As Byte, ByRef VarSiteSmooth As Single, ByRef VRPos As Long) As Long
Declare Function MakeCntHit2 Lib "dna.dll" (ByVal BPos As Long, ByVal Epos As Long, ByVal SWinx As Long, ByVal NextNo As Long, ByVal LenVarSeq As Long, ByVal LS As Long, ByVal UBVSM As Long, ByRef CntHit As Double, ByRef VarSiteMap As Integer, ByRef VarSiteSmooth As Single, ByRef VRPos As Long) As Long

Declare Function FindBestRecSignal Lib "dna.dll" (ByVal DoneTarget As Byte, ByVal NextNo As Long, ByVal UB As Long, ByRef LowP As Double, ByRef DoneSeq As Byte, ByRef Trace As Long, ByRef PCurrentXover As Integer, ByRef PXOList As XOverDefine) As Long
Declare Function FindBestRecSignalP Lib "dna5.dll" (ByVal DoneTarget As Byte, ByVal NextNo As Long, ByVal UB As Long, ByVal UB2 As Long, ByRef LowP As Double, ByRef DoneSeq As Byte, ByRef Trace As Long, ByRef PCurrentXover As Integer, ByRef PXOList As XOverDefine) As Long
Declare Function FindBestRecSignalP2 Lib "dna5.dll" (ByVal DoneTarget As Byte, ByVal NextNo As Long, ByVal UB As Long, ByVal UB2 As Long, ByRef LowP As Double, ByRef DoneSeq As Byte, ByRef Trace As Long, ByRef PCurrentXover As Integer, ByRef TestPVs As Double) As Long
Declare Function MakeTestPVs Lib "dna5.dll" (ByVal UBDS As Long, ByRef DoneSeq As Byte, ByVal NextNo As Long, ByVal UB As Long, ByVal UB2 As Long, ByRef PCurrentXover As Integer, ByRef PXOList As XOverDefine, ByRef TestPVs As Double) As Long
Declare Function MarkOutsides Lib "dna5.dll" (ByVal UBDS As Long, ByRef DoneSeq As Byte, ByVal NextNo As Long, ByVal UB As Long, ByRef PCurrentXover As Integer, ByRef PXOList As XOverDefine) As Long
'int MyMathFuncs::MarkOutsides(                int UBDS, unsigned char *DoneSeq,           int NextNo,           int UB,     short int *PCurrentXOver,                           XOVERDEFINE *PXOList) {
    
Declare Function CheckEnds Lib "dna.dll" (ByVal LS As Long, ByVal RL As Long, ByVal LSS As Long, ByVal ChF As Long, ByVal CirF As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal BPos As Long, ByVal Epos As Long, ByRef SeqNum As Integer, ByRef XPD As Long, ByRef XDP As Long, ByRef MissingData As Byte) As Long
Declare Function CopyXOListsX Lib "dna.dll" (ByVal UB1 As Long, ByVal UB3 As Long, ByVal UB2 As Long, ByVal UB4 As Long, ByVal NextNo As Long, ByRef CurrentXOver As Integer, ByRef PCurrentXover As Integer, ByRef PXOList As XOverDefine, ByRef XoverList As XOverDefine, ByRef NumRecsI As Long) As Long
Declare Function FindActualEvents Lib "dna.dll" (ByVal LS As Long, ByVal WinPP As Long, ByVal NextNo As Long, ByVal UB As Long, ByRef RSize As Long, ByRef Don As Byte, ByRef BPMatch As Long, ByRef BMatch As Single, ByRef OKSeq As Double, ByRef FoundOne As Long, ByRef SP As Long, ByRef EP As Long, ByRef RCorr As Single, ByRef OLSeq As Long, ByRef OLSeqB As Long, ByRef OLSeqE As Long, ByRef CSeq As Long, ByRef RNum As Long, ByRef RList As Long, ByRef InvS As Byte, ByRef TrS As Long, ByRef tMatch As Double, ByRef PXOList As XOverDefine, ByRef PCurrentXover As Integer, ByRef SQ As Long, ByRef tDon As Byte, ByRef ISeqs As Long, ByRef TList As Byte, ByRef CompMat As Long) As Long
'int FAR pascal   FindActualEvents(              int LS,          int WinPP,           int NextNo,              int UB,        int *RSize,           char *Don,          int *BPMatch,         float *BMatch,          double *OKSeq,         int *FoundOne,         int *SP,          int *EP,            double *RCorr,         int *OLSeq,         int *OLSeqB,          int *OLSeqE,           int *CSeq,           int *RNum,       int *RList,          char *InvS,         int *TrS,           double *TMatch,          XOVERDEFINE *PXOList,         short int *PCurrentXOver,      int *SQ,         char *tDon,         int *ISeqs,           char *TList,         int *CompMat){
Declare Function FillSets Lib "dna.dll" (ByVal UBS As Long, ByVal UBRL As Long, ByRef RNum As Long, ByRef RI As Long, ByRef RList As Long, ByRef Sets As Byte) As Long
'int FAR pascal FillSets(int UBS, int UBRL,  ByRef RNum, ByRef RI,  ByRef RList, unsigned char *Sets){

Declare Function MakePValMap Lib "dna.dll" (ByVal DN As Long, ByVal LS As Long, ByVal PermNum As Long, ByRef MaP As Integer, ByRef PValMap As Single) As Long
Declare Function AddToMap Lib "dna.dll" (ByVal A As Long, ByVal S As Long, ByVal Win As Double, ByVal LS As Long, ByRef APos As Long, ByRef MaP As Integer) As Long
Declare Function AddToMapP Lib "dna5.dll" (ByVal A As Long, ByVal S As Long, ByVal Win As Double, ByVal LS As Long, ByRef APos As Long, ByRef MaP As Integer) As Long

Declare Function CheckBPOL Lib "dna.dll" (ByVal LS As Long, ByVal D As Long, ByVal LSSeq As Long, ByVal NewStart As Long, ByVal RecSize As Long, ByRef tSeqnum As Integer, ByRef NS As Long, ByRef NE As Long, ByRef XDiffPos As Long) As Long
Declare Function FindMaxMapVal Lib "dna.dll" (ByVal DN As Long, ByVal LS As Long, ByVal PermNum As Long, ByRef MaxVals As Long, ByRef MaP As Integer) As Long

Declare Function OptLeftBPMC Lib "dna.dll" (ByVal LO As Long, ByVal HiLeft As Double, ByVal TopL As Long, ByVal MaxX As Long, ByVal MaxY As Long, ByVal WinWin As Long, ByVal LenXoverSeq As Long, ByVal LSeq As Long, ByRef Scores As Byte, ByRef MDMap As Byte) As Long
Declare Function OptRightBPMC Lib "dna.dll" (ByVal LO As Long, ByVal HiLeft As Double, ByVal TopL As Long, ByVal MaxX As Long, ByVal MaxY As Long, ByVal WinWin As Long, ByVal LenXoverSeq As Long, ByVal LSeq As Long, ByRef Scores As Byte, ByRef MDMap As Byte) As Long

Declare Function DrawMats Lib "dna.dll" (ByVal Pict As Long, ByVal MaxN As Double, ByVal CurScale As Long, ByVal XAddj As Double, ByVal UBRM As Long, ByRef PosS As Long, ByRef PosE As Long, ByRef RegionMat As Double, ByRef HeatMap As Long) As Long
Declare Function FindMaxNS Lib "dna.dll" (ByVal RSize As Long, ByRef RegionMat As Single) As Single
Declare Function FindMaxN Lib "dna.dll" (ByVal RSize As Long, ByRef RegionMat As Double) As Double

Declare Function ChiPVal3 Lib "dna.dll" (ByVal x As Double, ByVal DF As Long) As Double
Declare Function MakeMatrixMC Lib "dna.dll" (ByVal LS As Long, ByVal LenXoverSeq As Long, ByRef A As Single, ByRef C As Single, ByRef Scores As Byte, ByRef MatrixMC As Single) As Long

Declare Function CheckMissingData Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal XB As Long, ByVal XE As Long, ByVal LS As Long, ByRef MissingData As Byte) As Long
Declare Function PPRegression Lib "dna.dll" (ByVal IncSelf As Byte, ByVal x As Long, ByVal LS As Long, ByVal NumberOfSeqs As Long, ByVal NSX As Long, ByRef PDstMat As Single, ByRef PPWinScoreT As Single) As Long
'int FAR pascal PPRegression(                char IncSelf,          int X,          int ls,            int NumberOfSeqs,           int NSX,           float *PDstMat,           double *PPWinScoreT){

Declare Function UpdatePDstMat Lib "dna.dll" (ByVal x As Long, ByVal Begin1 As Long, ByVal End2 As Long, ByVal NumberOfSeqs As Long, ByVal LS As Long, ByRef SeqNum As Integer, ByRef XDiffPos As Long, ByRef RevSeq As Integer, ByRef PDstMat As Single) As Long
'//int FAR pascal          UpdatePDstMat      (int X,           int Begin1,          int End2,           int NumberOfSeqs,           int LS,          short int *SeqNum,       int *XDiffpos,          short int *RevSeq,         float *PDstMat){

Declare Function MakePDstMat Lib "dna.dll" (ByVal NumberOfSeqs As Long, ByVal LS As Long, ByVal LenXoverSeq As Long, ByVal WinLen As Long, ByRef XDiffPos As Long, ByRef RevSeq As Integer, ByRef SeqNum As Integer, ByRef PDstMat As Single) As Long
'int FAR pascal MakePDstMat(                 int NumberOfSeqs,          int LS,           int LenXOverSeq,           int WinLen,            int *XDiffpos,          short int *RevSeq,       short int *SeqNum,         float *PDstMat){

Declare Function MakeDistX Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal LS As Long, ByRef DistanceX As Single, ByRef SeqNum As Integer) As Long
'int FAR pascal MakeDistX (               int Seq1,          int Seq2,             int Seq3,          int LS,           float *DistanceX,         short int *SeqNum){

Declare Function FindMaxZ Lib "dna.dll" (ByVal HV As Long, ByVal LV1 As Long, ByVal LV2 As Long, ByVal LV3 As Long, ByVal WinNum As Long, ByVal FHPos As Long, ByVal SHPos As Long, ByRef SeqMap As Byte, ByRef DoGroupS As Byte, ByRef DoGroupP As Byte, ByRef maxz As Double, ByRef WinP As Double, ByRef WinScore As Double, ByRef wps As Byte, ByRef ZSScoreHolder As Double, ByRef ZPScoreHolder As Double) As Long
Declare Function ShrinkRegionC Lib "dna.dll" (ByVal LS As Long, ByVal SSGapFlag As Long, ByVal SSStep As Long, ByVal SSWinLen As Long, ByVal HVX As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal EP As Long, ByVal SP As Long, ByRef TEnd As Long, ByRef TBegin As Long, ByRef SeqNum As Integer) As Long
Declare Function GetSSOL Lib "dna.dll" (ByVal LS As Long, ByVal SEventNumber As Long, ByVal NN1 As Long, ByVal NN2 As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal SSOutlyerFlag As Long, ByVal LFlag As Long, ByRef Seq1 As Long, ByRef Seq2 As Long, ByRef Seq3 As Long, ByRef oSeq As Long, ByRef TreeDistance As Single, ByRef Distance As Single, ByRef MissingData As Byte, ByRef TraceSub As Long) As Long
'int FAR pascal GetSSOL(                 int LS,          int SEventNumber,           int nn1,            int nn2,          int PermNextNo,           int NextNo,            int SSOutlyerFlag,          int LFlag,          int *Seq1,          int *Seq2,            int *Seq3,          int *oSeq,           float *TreeDistance,          float *Distance,          unsigned char *MissingData,  int *TraceSub){

Declare Function BlankSSArrays Lib "dna.dll" (ByVal UB1 As Long, ByVal UB2 As Long, ByVal UB3 As Long, ByVal UB4 As Long, ByRef zssh As Double, ByRef zpsh As Double) As Long
Declare Function ShrinkRegionBS Lib "dna.dll" (ByVal CircularFlag As Long, ByVal SEventNumber As Long, ByVal Hi1 As Long, ByVal Hi2 As Long, ByVal LO As Long, ByVal LS As Long, ByRef XPosDiff As Long, ByRef RS As Long, ByRef RE As Long, ByRef SeqNum As Integer, ByRef MissingData As Byte) As Double
Declare Function MakeScoresBS Lib "dna.dll" (ByVal LenXoverSeq As Long, ByVal ScoreP As Long, ByVal LS As Long, ByVal BE As Long, ByVal EN As Long, ByRef A As Long, ByRef C As Long, ByRef XPosDiff As Long, ByRef Scores As Byte) As Long
Declare Function FindBeginBS Lib "dna.dll" (ByVal CircularFlag As Long, ByVal BSStepSize As Long, ByVal BSStepWin As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LowHomol As Long, ByVal numwinsx As Long, ByVal BSCutOff As Double, ByVal BSBootReps As Long, ByVal PosCount As Long, ByVal OverlapNum As Integer, ByRef TotalProb As Double, ByRef LastFull As Long, ByRef ProbCounter As Long, ByRef YVal As Long, ByRef PVal As Double, ByRef PPVal As Double, ByRef EraseAll As Byte, ByRef CurPos As Long, ByRef PltVal As Double) As Long
Declare Function FindEndBS Lib "dna.dll" (ByVal Y As Long, ByVal BSCutOff As Double, ByVal BSBootReps As Long, ByVal NumWins As Long, ByVal OverlapNum As Long, ByVal MedHomol As Long, ByVal HighHomol As Long, ByVal LowHomol As Long, ByVal gbcc As Long, ByRef lastfullx As Long, ByRef probcounterx As Long, ByRef CurPosX As Long, ByRef totalprobx As Double, ByRef PltVal As Double) As Long
Declare Function FindSubSeqTS Lib "dna.dll" (ByVal LS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef BE As Long, ByRef EN As Long, ByRef BE2 As Long, ByRef EN2 As Long, ByRef nM As Long, ByRef NN As Long, ByRef nK As Long, ByRef NL As Long, ByRef XPosDiff As Long, ByRef XDiffPos As Long, ByRef SeqNum As Integer, ByRef XoverSeqNum As Long) As Long
Declare Function FindSubSeqTS2 Lib "dna.dll" (ByVal LS As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef BE As Long, ByRef EN As Long, ByRef BE2 As Long, ByRef EN2 As Long, ByRef nM As Long, ByRef NN As Long, ByRef nK As Long, ByRef NL As Long, ByRef XPosDiff As Long, ByRef XDiffPos As Long, ByRef SeqNum As Integer, ByRef XoverSeqNum As Long, ByRef MissingData As Byte) As Long

Declare Function Fill4DSingArray Lib "dna.dll" (ByVal b1 As Long, ByVal b2 As Long, ByVal b3 As Long, ByVal b4 As Long, ByVal fillval As Single, ByRef ArrayX As Single) As Long
Declare Function FindFormula Lib "dna.dll" (ByVal Order As Long, ByVal UB As Long, ByVal UB2 As Long, ByRef SSA As Double, ByRef SS As Double, ByRef XTable As Single, ByRef TTable As Double, ByRef EX As Double) As Long
Declare Function Get3SeqPvalC Lib "dna.dll" (ByVal UBA As Long, ByVal UBB As Long, ByVal M As Single, ByVal n As Single, ByVal k As Single, ByVal j As Single, ByRef YTable As Single) As Single
Declare Function Seq3PVals Lib "dna.dll" (ByVal UBA As Long, ByVal UBB As Long, ByVal nM As Single, ByVal NN As Single, ByVal nK As Single, ByRef YTable As Single) As Single
Declare Function CheckwrapC Lib "dna.dll" (ByVal LS As Long, ByVal LenXoverSeq As Long, ByVal NegMod As Long, ByVal CircularFlag As Long, ByRef nK As Long, ByRef BE As Long, ByRef EN As Long, ByRef XDiffPos As Long, ByRef XPosDiff As Long, ByRef XoverSeqNumTS As Long) As Long
Declare Function AddToRegionMat Lib "dna.dll" (ByVal LS As Long, ByVal ST As Long, ByVal EN As Long, ByVal RSize As Long, ByVal SConvert As Single, ByVal ParDist As Single, ByRef RegionMat As Single) As Long
Declare Function CopyLongArray Lib "dna.dll" (ByVal D1 As Long, ByVal D2 As Long, ByVal LS As Long, ByVal NextNo As Long, ByVal LS2 As Long, ByVal Nextno2 As Long, ByRef SeqNum As Long, ByRef PermSeqNum As Long) As Long
Declare Function CopyDoubleArray Lib "dna.dll" (ByVal D1 As Long, ByVal D2 As Long, ByVal LS As Long, ByVal NextNo As Long, ByVal LS2 As Long, ByVal Nextno2 As Long, ByRef SeqNum As Double, ByRef PermSeqNum As Double) As Long
'int FAR pascal CopyDoubleArray (                int D1,           int D2,           int LS,          int Nextno,           int LS2,            int Nextno2,               double *SeqNum,    double *PermSeqNum){

Declare Function CopySingleArray Lib "dna.dll" (ByVal D1 As Long, ByVal D2 As Long, ByVal LS As Long, ByVal NextNo As Long, ByVal LS2 As Long, ByVal Nextno2 As Long, ByRef SeqNum As Single, ByRef PermSeqNum As Single) As Long
'int FAR pascal CopySingleArray (                 int D1,            int D2,        int LS,            int Nextno,          int LS2,            int Nextno2,          float *SeqNum,            float *PermSeqNum){

Declare Function UpdateDistArrays Lib "dna.dll" (ByVal NextNo As Long, ByVal x As Long, ByVal A As Long, ByVal UB1 As Long, ByVal UB2 As Long, ByVal UB3 As Long, ByVal UB4 As Long, ByVal UB5 As Long, ByVal UB6 As Long, ByRef TreeFMat As Single, ByRef TreeSMat As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef TreeMatrix As Single, ByRef Distance As Single) As Long
'int FAR pascal UpdateDistArrays(                int NextNo,            int X,          int A,           int UB1,             int UB2,           int UB3,           int UB4,           int UB5,           int UB6,          float *TreeFMat,          float *TreeSMat,          float *FMat,         float *SMat,         float *TreeMatrix,              float *Distance){
 
Declare Function MakeDistModPar Lib "dna.dll" (ByVal NextNo As Long, ByVal UB1 As Long, ByVal UB2 As Long, ByRef Tot As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef PermDIffs As Single, ByRef PermValid As Single) As Double
'double FAR pascal MakeDistModPar(             int Nextno,          int UB1,            int UB2,           double *Tot,         float *FMat,           float *SMat,         float *PermDiffs,           float *PermValid){

Declare Function MakeVScoreMat Lib "dna.dll" (ByRef ScoreMat As Single) As Double
'double FAR pascal MakeVScoreMat(                 float *ScoreMat){

Declare Function MakeWinScoreV Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal Seq4 As Long, ByVal LSeq As Long, ByVal VWin As Long, ByRef NucMat As Byte, ByRef SeqNum As Integer, ByRef D As Single, ByRef VScoreMat As Single, ByRef WinScoreV As Single) As Double
'double FAR pascal MakeWinScoreV(             int Seq1,           int Seq2,           int Seq3,           int Seq4,         int lseq,               int VWin,          char *NucMat,         short int *SeqNum,         float *d      , float *VScoreMat        , float *WinScoreV){
   

Declare Function MakeTheta Lib "dna.dll" (ByVal PlotF As Long, ByVal LSeq As Long, ByVal SideB As Double, ByVal SideBs As Double, ByVal OD3 As Double, ByRef WinScoreV As Single, ByRef rScore As Single, ByRef Theta As Single, ByRef VisRDOccupancyStat As Single) As Double
Declare Function MakePrintPoints Lib "dna.dll" (ByVal LSeq As Long, ByVal XDist As Long, ByVal YDist As Long, ByVal PicHeight As Long, ByVal XFactor As Double, ByRef Theta As Single, ByRef rScore As Single, ByRef PrintPoints As Single, ByRef Decompress As Long) As Double
Declare Function TSeqPerms Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal LSeq As Long, ByRef THold As Long, ByRef tMissingData As Byte, ByRef SeqNum As Integer, ByRef SeqRnd As Integer) As Long
Declare Function CMaxD Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal SBP As Long, ByVal EBP As Long, ByVal NextNo As Long, ByVal SLen As Long, ByRef SeqNum As Integer, ByRef SeqnumX As Integer, ByRef Identical As Byte, ByRef NucMat As Byte, ByRef IncSeq2 As Byte, ByRef IncSeq As Byte, ByRef e As Single, ByRef D As Single, ByRef VScoreMat As Single, ByRef AvDist As Single, ByRef TotCount As Long) As Long
Declare Function CMaxD2 Lib "dna.dll" (ByVal IncNum As Long, ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByVal SBP As Long, ByVal EBP As Long, ByVal NextNo As Long, ByVal SLen As Long, ByRef SeqNum As Integer, ByRef SeqnumX As Integer, ByRef IdenticalR As Long, ByRef IdenticalF As Long, ByRef NucMat As Byte, ByRef IncSeq3 As Long, ByRef IncSeq2 As Byte, ByRef IncSeq As Byte, ByRef e As Single, ByRef D As Single, ByRef VScoreMat As Single, ByRef AvDist As Single, ByRef TotCount As Long) As Long
Declare Function CMaxD3 Lib "dna.dll" (ByVal IncNum As Long, ByVal SBP As Long, ByVal EBP As Long, ByVal NextNo As Long, ByVal SLen As Long, ByRef SeqNum As Integer, ByRef SeqnumX As Integer, ByRef IdenticalR As Long, ByRef IdenticalF As Long, ByRef NucMat As Byte, ByRef IncSeq3 As Long, ByRef IncSeq2 As Byte, ByRef ISeqs As Long, ByRef e As Single, ByRef D As Single, ByRef VScoreMat As Single, ByRef AvDist As Single, ByRef TotCount As Long) As Long

Declare Function UpdateMatrixRRP Lib "dna.dll" (ByVal RSize As Long, ByRef MatrixRRP As Single, ByRef MatrixRX As Single, ByRef MatrixRR As Single) As Long
Declare Function FillMatrixC Lib "dna.dll" (ByVal NDone As Long, ByVal x As Long, ByVal VarNum As Long, ByVal NextNo As Long, ByRef tCMat As Byte, ByRef BinMat As Byte, ByRef MatrixC As Byte) As Long

Declare Function FillRegionMatX Lib "dna.dll" (ByVal LSeq As Long, ByVal RSize As Long, ByVal ST As Long, ByVal EN As Long, ByRef SCArray As Long, ByRef PairDist As Single, ByRef RegionMat As Single) As Long
Declare Function FillTempDataset Lib "dna.dll" (ByVal x As Long, ByVal Y As Long, ByVal NextNo As Long, ByVal LSeq As Long, ByRef TempDataset As Byte, ByRef TempMat As Long) As Long
Declare Function DrawRDPPlot Lib "dna.dll" (ByVal Y As Long, ByVal LenXoverSeq As Long, ByVal UBL As Long, ByVal RDPLD As Long, ByVal RDPUD As Long, ByVal PicHeight As Long, ByVal Pict As Long, ByVal XFactor As Double, ByRef XDiffPos As Long, ByRef XOverHomologyNum As Long) As Long

Declare Function MakeBackups Lib "dna.dll" (ByVal UBuDaught As Long, ByVal SE As Long, ByVal NextNo As Long, ByVal LSeq As Long, ByRef MissingData As Byte, ByRef uMissingData As Byte, ByRef SeqNum As Integer, ByRef uSeqNum As Byte, ByRef FFillCol As Long, ByRef uFFillCol As Long, ByRef SeqCol As Long, ByRef uSeqCol As Long, ByRef Daught As Byte, ByRef uDaught As Byte, ByRef Distance As Single, ByRef uDistance As Single, ByRef TreeDistance As Single, ByRef uTreeDistance As Single, ByRef TreeTrace As Long, ByRef uTreeTrace As Long) As Long
'int FAR pascal MakeBackups(                int UBuDaught,           int SE,          int Nextno,            int LSeq,          unsigned char *MissingData, unsigned char *uMissingData, short int *SeqNum,     unsigned char *uSeqNum, int *FFillCol,        int *uFFillCol,           int *SeqCol,           int *uSeqCol,         int *Daught,          int *uDaught,           float *Distance,         float *uDistance,            float *TreeDistance,       float *uTreeDistance,           int *TreeTrace,          int *uTreeTrace){

Declare Function ReplaceWithBackups Lib "dna.dll" (ByVal UBuDaught As Long, ByVal SE As Long, ByVal NextNo As Long, ByVal LSeq As Long, ByRef MissingData As Byte, ByRef uMissingData As Byte, ByRef SeqNum As Integer, ByRef uSeqNum As Byte, ByRef FFillCol As Long, ByRef uFFillCol As Long, ByRef SeqCol As Long, ByRef uSeqCol As Long, ByRef Daught As Byte, ByRef uDaught As Byte, ByRef Distance As Single, ByRef uDistance As Single, ByRef TreeDistance As Single, ByRef uTreeDistance As Single, ByRef TreeTrace As Long, ByRef uTreeTrace As Long) As Long
'int FAR pascal ReplaceWithBackups(               int UBuDaught,           int SE,           int Nextno,            int LSeq,          unsigned char *MissingData, unsigned char *uMissingData, short int *SeqNum,      unsigned char *uSeqNum, int *FFillCol,         int *uFFillCol,         int *SeqCol,          int *uSeqCol,          int *Daught,          int *uDaught,          float *Distance,          float *uDistance,           float *TreeDistance,            float *uTreeDistance,        int *TreeTrace,            int *uTreeTrace){

Declare Function ScanNums Lib "dna.dll" (ByVal NextNo As Long, ByRef GrpMaskSeq As Byte, ByRef MaskSeq As Integer) As Long
Declare Function AtomDists Lib "dna.dll" (ByVal x As Long, ByVal UB As Long, ByVal TotAmino As Long, ByRef AtomArray As Double, ByRef MinDistXX As Double) As Long
Declare Function FastDistA Lib "dna.dll" (ByVal ISDim As Long, ByVal NextNo As Long, ByVal UBX As Long, ByRef XCVal As Integer, ByRef IntegerSeq As Integer, ByRef CompressValid As Byte, ByRef CompressDiffs As Byte, ByRef DistCheckB As Single) As Double
'double FAR pascal FastDistA(             int ISDim,           int Nextno,          int UBX,          short int *XCVal,         short int *IntegerSeq,       unsigned char *CompressValid, unsigned char *CompressDiffs, float *DistCheckB)

Declare Function FastSimilarityA Lib "dna.dll" (ByVal ISDim As Long, ByVal NextNo As Long, ByVal UBX As Long, ByRef AvDst As Double, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef XCVal As Integer, ByRef IntegerSeq As Integer, ByRef CompressValid As Byte, ByRef CompressDiffs As Byte, ByRef DistCheckB As Single, ByRef tRedoDist As Integer) As Double
Declare Function FastSimilarityI Lib "dna.dll" (ByVal ISDim As Long, ByVal NextNo As Long, ByVal UBX As Long, ByRef AvDst As Double, ByRef PermDIffs As Single, ByRef PermValid As Single, ByRef XCVal As Integer, ByRef IntegerSeq As Integer, ByRef CompressValid As Byte, ByRef CompressDiffs As Byte, ByRef DistCheckB As Single, ByRef tRedoDist As Integer) As Double

'double FAR pascal FastSimilarityA(             int ISDim,           int Nextno,           int UBX,           double *avdst,          float *diffsx,            float *validx,              short int *XCVal,         short int *IntegerSeq,    unsigned char *CompressValid,unsigned char *CompressDiffs, float *DistCheckB, short int *tredodist)

Declare Function FastSimilarityB Lib "dna.dll" (ByVal DF As Long, ByVal Reps As Long, ByVal ISDim As Long, ByVal NextNo As Long, ByVal UBX As Long, ByRef Valid As Single, ByRef Diffs As Single, ByRef XCVal As Integer, ByRef IntegerSeq As Integer, ByRef CompressValid As Byte, ByRef CompressDiffs As Byte, ByRef DistCheckB As Single, ByRef WeightMod As Long) As Double
'double FAR pascal FastSimilarityB(             int df,       int reps,                 int ISDim,           int Nextno,           int UBX,         int *Valid, int              *Diffs, short int        *XCVal, short int      *IntegerSeq,   unsigned char *CompressValid,  unsigned char *CompressDiffs,      float *DistCheckB, int *weightmod)

Declare Function ViterbiC Lib "dna.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef OptXY As Double, ByRef RecodeB As Byte, ByRef LaticeXY As Double, ByRef TransitionM2 As Double, ByRef EmissionM2 As Double, ByRef LaticeAB As Double) As Double
Declare Function ReverseC Lib "dna.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef ValXY As Double, ByRef OptXY As Double, ByRef RecodeB As Byte, ByRef LaticeXY As Double, ByRef TransitionM2 As Double, ByRef EmissionM2 As Double) As Double
Declare Function ForwardC Lib "dna.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef ValXY As Double, ByRef OptXY As Double, ByRef RecodeB As Byte, ByRef LaticeXY As Double, ByRef TransitionM2 As Double, ByRef EmissionM2 As Double) As Double
Declare Function GetLaticePath Lib "dna.dll" (ByVal SLen As Long, ByVal NumberXY As Long, ByRef LaticeXY As Double, ByRef LaticeAB As Double, ByRef LaticePath As Long) As Double
Declare Function UpdateCounts Lib "dna.dll" (ByVal SLen As Long, ByVal NumberABC As Long, ByVal NumberXY As Long, ByRef LaticePath As Long, ByRef RecodeB As Byte, ByRef TransitionCount As Double, ByRef StateCount As Double) As Double

Declare Function MakeNumSeq Lib "dna.dll" (ByVal NextNo As Long, ByVal SLen As Long, ByVal uboundnumseq1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef ConvNumSeq As Byte, ByRef SeqNum As Integer, ByRef NumSeq As Byte) As Long
'int FAR pascal MakeNumSeq (                int Nextno,           int SLen,         int StartPosInAlign,            int EndPosInAlign,           char *ConvNumSeq,         short int *SeqNum,       char *NumSeq){

Declare Function MakeISeq4 Lib "dna.dll" (ByVal NextNo As Long, ByVal UBNS As Long, ByVal UBIS4 As Long, ByRef SeqCompressor4 As Integer, ByRef ISeq4 As Integer, ByRef NumSeq As Byte) As Long
'int FAR pascal MakeISeq4 (             int Nextno,           int UBNS,             int UBIS4,           short int *SeqCompressor4,       short int *ISeq4,        unsigned char *NumSeq){

Declare Function ConvSimToDist Lib "dna.dll" (ByVal SLen As Long, ByVal NextNo As Long, ByVal UBDistance As Long, ByVal UBPermValid As Long, ByVal ubfubvalid As Long, ByVal UBSubValid As Long, ByRef RedoList As Integer, ByRef Distance As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef PermValid As Single, ByRef PermDIffs As Single, ByRef FubValid As Single, ByRef Fubdiffs As Single, ByRef SubValid As Single, ByRef SubDiffs As Single) As Long
'int FAR pascal ConvSimToDist(                int SLen,          int Nextno            , int UBDistance,          int UBPermvalid         , int UBPermvalidx,        int UBFubvalid,           int UBSubvalid,           short int *RedoDist        , float *Distance         , float *FMat         , float *SMat      , float *PermValid            , float *PermDiffs         ,  float *PermValidx         , float *PermDiffsx        , float *Fubvalid         , float *Fubdiffs         , float *SubValid        , float *SubDiffs)

Declare Function MakeTreeD Lib "dna.dll" (ByVal UBTD As Long, ByVal UBND As Long, ByVal UBSB As Long, ByVal NumberOfSeqs As Long, ByRef LLen As Single, ByRef TreeD As Single, ByRef SeqXPos As Single, ByRef NodeDepth As Integer, SepBranch As Integer) As Long
'extern "C" int FAR pascal MakeTreeD(     int UBTD,          int UBND,              int UBSB,         int NumberOfSeqs,           float *LLen,         float *TreeD        , float  *SeqXPos         , short int *NodeDepth       , char *SepBranch);

Declare Function GetSeqXPos Lib "dna.dll" (ByVal UBND1 As Long, ByVal UBND2 As Long, ByVal CCount As Long, ByVal NumberOfSeqs As Long, ByRef NodeDepth As Integer, ByRef Done As Integer, ByRef NodeXPos As Single, ByRef LLen As Single, ByRef SeqXPos As Single, ByRef NameXPos As Single) As Long
'extern "C" int FAR pascal GetSeqXPos(int UBND1                 , int UBND2,            int CCount,     int NumberOfSeqs          , short int *NodeDepth    , short int *Done,           float *NodeXPos,          float *LLen,          float *SeqXPos,          float *NameXPos);

Declare Function FillNodeMaxRep Lib "dna.dll" (ByVal TType As Long, ByVal PermNextno As Long, ByVal NextNo As Long, ByVal UBNF As Long, ByVal UBTRX As Long, ByVal UBTRY As Long, ByVal UBTTS As Long, ByVal UBTT As Long, ByVal UBSC As Long, ByRef NodeMaxRep As Single, ByRef NodeFind As Byte, ByRef TreeRY As Integer, ByRef TreeRX As Integer, ByRef SeqCoverage As Single, ByRef TreeTraceSeqs As Long, ByRef TreeTrace As Long) As Long
'int FAR pascal FillNodeMaxRep(                  int TType          , int PermNextno,           int Nextno,           int ubnf,           int ubtrx,           int ubtry,          int ubtts           , int ubtt,      int ubsc         ,    float *NodeMaxRep ,          char *NodeFind,    short int *TreeRY,       short int *TreeRX,           float *SeqCoverage,            int *TreeTraceSeqs,          int *TreeTrace){
Declare Function MakeSeqCoverageC Lib "dna.dll" (ByVal SF As Long, ByVal NextNo As Long, ByVal UBSV As Long, ByVal UBTTS As Long, ByVal UBSC As Long, ByRef SubValid As Single, ByRef SeqCoverage As Single, ByRef TreeTraceSeqs As Long, ByRef TreeTrace As Long) As Long
'int FAR pascal MakeSeqCoverageC(int SF, int Nextno, int UBSV, int UBTTS, int UBSC, float *SubValid, float *SeqCoverage, int *TreeTraceSeqs, int *TreeTrace){


Declare Function ClearNumTaxa Lib "dna.dll" (ByVal NC As Long, ByVal NextNo As Long, ByRef NumTaxa As Long) As Long
Declare Function AdjustTokenPrivileges Lib "advapi32.dll" (ByVal TokenHandle As Long, ByVal DisableAllPrivileges As Long, NewState As TOKEN_PRIVILEGES, ByVal BufferLength As Long, PreviousState As TOKEN_PRIVILEGES, ReturnLength As Long) As Long
Declare Function OpenProcessToken Lib "advapi32.dll" (ByVal ProcessHandle As Long, ByVal DesiredAccess As Long, TokenHandle As Long) As Long
Declare Function LookupPrivilegeValue Lib "advapi32.dll" Alias "LookupPrivilegeValueA" (ByVal lpSystemName As String, ByVal lpName As String, lpLuid As LUID) As Long
Declare Function GetCurrentProcess Lib "kernel32" () As Long

Declare Function ExtraRemovals Lib "dna.dll" (ByVal NextNo As Long, ByVal UBF As Long, ByVal UBS As Long, ByRef ISeqs As Long, ByRef ExtraRemove As Long, ByRef FMat As Single, ByRef SMat As Single) As Long
Declare Function ExtraRemovals2 Lib "dna.dll" (ByVal NextNo As Long, ByVal UBF As Long, ByVal UBS As Long, ByRef ISeqs As Long, ByRef ExtraRemove As Long, ByRef FMat As Single, ByRef SMat As Single) As Long

'int FAR pascal ExtraRemovals(int Nextno, int UBF, int UBS, int *ISeqs, int *ExtraRemove, float *FMat, float *SMat){

'int FAR pascal MakeTrpListLen (int X, int UB1, int *TripListLen, int *AnalysisList, int *DoubListLen, short int *DoubList, unsigned char *SVx, unsigned char *SDx, short int *AlistTrace, float *Distance)
Declare Function MakeTrpListLen Lib "dna.dll" (ByVal x As Long, ByVal UBDistance As Long, ByRef TripListLen As Long, ByRef Analysislist As Integer, ByRef DoubListLen As Long, ByRef DoubList As Integer, ByRef SVx As Integer, ByRef SDx As Integer, ByRef AlistTrace As Integer, ByRef Distance As Single) As Long
Declare Function MakeNTS Lib "dna.dll" (ByVal nt As Long, ByVal SelGrpFlag As Long, ByVal NumSeqs As Long, ByRef TDist As Integer, ByRef GrpM As Byte, ByRef NTS As Long) As Long
'extern "C" int FAR pascal MakeNTS(int NT, int SelGrpFlag,int NumSeqs, short int *TDist, unsigned char *GrpM, int *NTS);

Declare Function MakeAnalysisListX Lib "dna.dll" (ByVal UBAL As Long, ByVal MaxNums As Long, ByVal UBNTS As Long, ByVal SelGrpFlag As Long, ByVal NumSeqs As Long, ByRef TDist As Integer, ByRef GrpM As Byte, ByRef NTS As Long, ByRef Analysislist As Integer, ByRef NTS2 As Long, ByRef SeqList As Long) As Long
'int FAR pascal MakeAnalysisList(                    int UBAL,     int MaxNums,                int UBNTS,           int SelGrpFlag,            int NumSeqs,    short int *TDist,     unsigned char *GrpM,       int *NTS, short    int *AnalysisList,            int *NTS2,           int *SeqList)

Declare Function FindNextBranch Lib "dna.dll" (ByVal TSH As Long, ByVal tTYF As Single, ByVal IStart As Long, ByVal TNum As Long, ByVal TType As Long, ByVal TDlenX As Long, ByRef OS As Long, ByRef GoOn As Long, ByRef x As Long, ByRef TreeDraw As Single) As Long

'FindNextBranch(                              int TSH,                  float tTYF,     int IStart,           int TNum,          int TType,           int TDLenX,           int *OS              , char *GoOn,       int *XX          , float *TreeDraw)

Declare Function MakeuBackups Lib "dna.dll" (ByVal LSeq As Long, ByVal SE As Long, ByVal UBDaught As Long, ByVal NextNo As Long, ByRef uMissingData As Byte, ByRef MissingData As Byte, ByRef uSeqNum As Byte, ByRef SeqNum As Integer, ByRef uFFillCol As Long, ByRef FFillCol As Long, ByRef uSeqCol As Long, ByRef SeqCol As Long, ByRef uDaught As Byte, ByRef Daught As Byte, ByRef uTreeTrace As Long, ByRef TreeTrace As Long) As Long
Declare Function ReplaceuBackups Lib "dna.dll" (ByVal LSeq As Long, ByVal SE As Long, ByVal UBDaught As Long, ByVal NextNo As Long, ByRef uMissingData As Byte, ByRef MissingData As Byte, ByRef uSeqNum As Byte, ByRef SeqNum As Integer, ByRef uFFillCol As Long, ByRef FFillCol As Long, ByRef uSeqCol As Long, ByRef SeqCol As Long, ByRef uDaught As Byte, ByRef Daught As Byte, ByRef uTreeTrace As Long, ByRef TreeTrace As Long) As Long

'int FAR pascal MakeuBackups(                int LSeq,            int SE,           int UBDaught,           int Nextno           , char *uMissingData, char *MissingData,short int *uSeqNum, short int *SeqNum,int *uFFillCol, int *FFillCol,int *uSeqCol, int *SeqCol,int *uDaught, int *Daught, int *uTreeTrace, int *TreeTrace){


Declare Function SuperDist Lib "dna.dll" (ByVal x As Long, ByVal NextNo As Long, ByVal UB14 As Long, ByVal UB04 As Long, ByVal UB13 As Long, ByVal UB03 As Long, ByVal UB12 As Long, ByVal UB02 As Long, ByVal UB11 As Long, ByRef AvDst As Double, ByRef PDistance As Single, ByRef PValid As Single, ByRef Dist As Single, ByRef RedoDist As Integer, ByRef SeqCatCount As Long, ByRef ISeq14 As Integer, ByRef ISeq04 As Integer, ByRef ISeq13 As Integer, ByRef ISeq03 As Integer, ByRef ISeq12 As Integer, ByRef ISeq02 As Integer, ByRef ISeq11 As Integer, ByRef CompressValid14 As Byte, ByRef CompressDiffs14 As Byte, ByRef CompressValid13 As Byte, ByRef CompressDiffs13 As Byte, ByRef CompressValid12 As Byte, ByRef CompressDiffs12 As Byte, ByRef CompressValid11 As Byte, ByRef CompressDiffs11 As Byte, ByRef CompressDiffs04 As Byte, ByRef CompressDiffs03 As Byte, ByRef CompressDiffs02 As Byte) As Double

Declare Function SuperDist2 Lib "dna.dll" (ByVal NextNo As Long, ByVal UB14 As Long, ByVal UB04 As Long, ByVal UB13 As Long, ByVal UB03 As Long, ByVal UB12 As Long, ByVal UB02 As Long, ByVal UB11 As Long, ByRef SeqCatCount As Long, ByRef ISeq14 As Integer, ByRef ISeq04 As Integer, ByRef ISeq13 As Integer, ByRef ISeq03 As Integer, ByRef ISeq12 As Integer, ByRef ISeq02 As Integer, ByRef ISeq11 As Integer, ByRef CompressValid14 As Byte, ByRef CompressDiffs14 As Byte, ByRef CompressValid13 As Byte, ByRef CompressDiffs13 As Byte, ByRef CompressValid12 As Byte, ByRef CompressDiffs12 As Byte, ByRef CompressValid11 As Byte, ByRef CompressDiffs11 As Byte, ByRef CompressDiffs04 As Byte, ByRef CompressDiffs03 As Byte, ByRef CompressDiffs02 As Byte) As Long
Declare Function CleanSCMat Lib "dna.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBFC As Long, ByRef FCMat As Single, ByRef SCMat As Single, ByRef FMat As Single) As Long
Declare Function CleanFCMat Lib "dna.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBFC As Long, ByRef FCMat As Single, ByRef FMat As Single) As Long
Declare Function CleanFCMat2 Lib "dna.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBFC As Long, ByRef FCMat As Single, ByRef Invol As Long) As Long
Declare Function CleanFCMat2P Lib "dna5.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBFC As Long, ByRef FCMat As Single, ByRef Invol As Long) As Long

Declare Function MakeImageData Lib "dna.dll" (ByVal BkR As Long, ByVal BkG As Long, ByVal BkB As Long, ByVal SX As Long, ByVal SY As Long, ByVal PosE1 As Long, ByVal PosE0 As Long, ByVal PosS1 As Long, ByVal PosS0 As Long, ByVal StS As Long, ByVal StSX As Long, ByVal CurScale As Long, ByVal XAD As Single, ByVal Min As Single, ByVal MR As Single, ByVal UBID1 As Long, ByVal UBID2 As Long, ByVal UBID3 As Long, ByVal UBRM1 As Long, ByVal UBHM1 As Long, ByRef HeatMap As Long, ByRef RMatrix As Single, ByRef ImageData As Byte) As Long
'int FAR pascal MakeImageData(                  int SX,           int SY,           int PosE1,           int PosE0,           int PosS1,           int PosS0,           int StS,           int StSX,           int CurScale,         float XAD,           float Min,           float MR,             int UBID1,           int UBID2,            int UBID3,          int UBRM1,           int UBHM1,          int *HeatMap,        float *RegionMat, unsigned char *ImageData){

'int FAR pascal MakeImageData                  (int SX,           int SY,           int PosE1,           int PosE0,           int PosS1,           int PosS0,           int StS,           int StSX,           int CurScale,         float XAD,           float Min,           float MR,             int UBID1,           int UBID2,           int UBID3,           int UBRM1,           int UBHM1,           int *HeatMap,     float *RegionMat,    unsigned char *ImageData){
Declare Function CopyDistandFindMinMax Lib "dna.dll" (ByVal NextNo As Long, ByVal UBT As Long, ByVal UBD As Long, ByRef MaxDistSch As Single, ByRef MinDistSch As Single, ByRef TDistance As Single, ByRef Distance As Single) As Long
'int FAR pascal CopyDistandFindMinMax(int Nextno, int UBT, int UBD, float *MaxDistSch, float *MinDistSch, float *TDistance, float *Distance){
Declare Function MakeSeqCatCount Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal UBSN1 As Long, ByVal UBSCC1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef SeqCatCount As Long, ByRef AA As Long, ByRef SeqNum As Integer, ByRef NucMat As Byte) As Long
'int FAR pascal MakeSeqCatCount                 (int   Nextno, int           LSeq, int           UBSN1, int           UBSCC1, int           StartPosInAlign,int            EndPosInAlign,  int         *SeqCatCount, unsigned char *SeqSpace, unsigned char *SeqCat, int *AA, short int *SeqNum, unsigned char *NucMat){
'Declare Function MakeSeqCatCount2 Lib "dna.dll" () as long
Declare Function MakeSeqCatCount2 Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal UBSN1 As Long, ByVal UBSCC1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef SeqCatCount As Long, ByRef AA As Long, ByRef SeqNum As Integer, ByRef NucMat As Byte, ByRef SeqSpace As Byte, ByRef NucMatB As Byte, ByRef NucMat2 As Byte, ByRef FLP As Byte, ByRef ML As Byte, ByRef NL As Byte) As Long
'int FAR pascal MakeSeqCatCount2 (int                  Nextno, int           LSeq, int           UBSN1, int           UBSCC1, int           StartPosInAlign,int            EndPosInAlign,  int         *SeqCatCount,  int         *AA, short int    *SeqNum, unsigned char   *NucMat, unsigned char *SeqCat, unsigned char *SeqSpace, unsigned char  *NucMatB, unsigned char  *NucMat2, unsigned char *flp, unsigned char *ml, unsigned char *nl){

Declare Function MakeNucSets2 Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal UBSN1 As Long, ByVal UBSCC1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef SeqCatCount As Long, ByRef AA As Long, ByRef SeqNum As Integer, ByRef NucMat As Byte, ByRef SeqCat As Byte, ByRef SeqSpace As Byte) As Long


Declare Function MakeNucSets Lib "dna.dll" (ByVal NextNo As Long, ByVal LSeq As Long, ByVal UBSN1 As Long, ByVal UBSCC1 As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByRef AA As Long, ByRef NucMatB As Byte, ByRef Nuc11 As Byte, ByRef Nuc02 As Byte, ByRef Nuc12 As Byte, ByRef Nuc03 As Byte, ByRef Nuc13 As Byte, ByRef Nuc04 As Byte, ByRef Nuc14 As Byte, ByRef SeqCatCount As Long, ByRef SeqNum As Integer, ByRef NucMat As Byte, ByRef NucMat2 As Byte, ByRef SeqCat As Byte, ByRef SeqSpace As Byte) As Long
'int FAR pascal MakeNucSets(int                   Nextno, int     LSeq,int      UBSN1, int     UBSCC1, int           StartPosInAlign, int           EndPosInAlign,int           *AA, int          *NucMatB,unsigned char *Nuc11,unsigned char *Nuc02,unsigned char *Nuc12,unsigned char *Nuc03,unsigned char *Nuc13 unsigned char *Nuc04,unsigned char *Nuc14,          int *SeqCatCount,    short int *SeqNum,   unsigned char *NucMat,unsigned char *NucMat2,unsigned char *SeqCat,unsigned char *SeqSpace){
Declare Function FixOverlaps Lib "dna.dll" (ByVal DoneThisOne As Byte, ByVal CurBegin As Long, ByVal CurEnd As Long, ByVal CurProg As Long, ByVal x As Long, ByVal Y As Long, ByVal MSX As Long, ByVal LSAdjust As Single, ByVal UBPD As Long, ByVal UBXONC1 As Long, ByVal UBXONC2 As Long, ByRef ProgDo As Byte, ByRef XOverNoComponent As Integer, ByRef MaxXONo As Integer) As Byte
'unsigned char FAR pascal FixOverlaps(unsigned char DoneThisOne, int CurBegin, int CurEnd, int CurProg, int X, int Y, int MSX, float LSAdjust,double CurProb,int UBPD, int UBXONC1, int UBXONC2, unsigned char *ProgDo,short int *XOverNoComponent, short int *MaxXONo){
Declare Function MakeMatrixRRX Lib "dna.dll" (ByVal RSize As Long, ByVal UBRRX As Long, ByVal UBRRP As Long, ByVal MaxN As Single, ByVal CoV1 As Single, ByVal CoV2 As Single, ByRef MatrixRRP As Single, ByRef MatrixRRX As Single) As Long
'int FAR pascal MakeMatrixRRX(int RSize, int UBRRX, int UBRRP, float MaxN, float cov1, float cov2,float *MatrixRRP, float *MatrixRRX){
Declare Function MakeIdentical02 Lib "dna.dll" (ByVal LSeq As Long, ByVal CountVSites As Long, ByRef Identical0 As Byte, ByVal StrainSeq As String, ByVal TempBig As String) As Long
'int FAR pascal MakeIdentical0(int LSeq, int CountVSites, unsigned char *Identical0,unsigned char *StrainSeq, unsigned char *TempBig){

Declare Function CopySingleDist Lib "dna.dll" (ByVal UB As Long, ByVal UBPVX As Long, ByVal UBPV As Long, ByRef PermValidx As Single, ByRef PermValid As Single, ByRef PermDiffsx As Single, ByRef PermDIffs As Single) As Long
'int FAR pascal CopySingleDist(int UB, int UBPVX, int UBPV, float *PermValidx, float *PermValid, float *PermDiffsx, float *PermDiffs){
Declare Function MakeValTots Lib "dna.dll" (ByVal NextNo As Long, ByVal SCO As Long, ByVal UBX As Long, ByVal UBFM As Long, ByVal UBFV As Long, ByVal UBMP As Long, ByRef ValtotS As Long, ByRef ValtotF As Long, ByRef ISeqs As Long, ByRef MissPair As Byte, ByRef FubValid As Single, ByRef SubValid As Single, ByRef FMat As Single, ByRef SMat As Single) As Long

'int FAR pascal MakeValTots(int Nextno, int SCO, int UBX, int UBFM, int UBFV, int UBMP, int *ValtotS, int *ValtotF, int *ISeqs, unsigned char *MissPair, float *FubValid, float *SubValid, float *FMat, float *SMat){

Declare Function StartBlock Lib "dna.dll" (ByVal D As Long, ByVal x As Long, ByVal UBMD As Long, ByVal LSeq As Long, ByRef MissingData As Byte) As Long
'extern "C" int FAR pascal StartBlock(int D, int X, int UBMD, int LSeq, unsigned char *MissingData);
Declare Function EndBlock Lib "dna.dll" (ByVal C As Long, ByVal x As Long, ByVal UBMD As Long, ByVal LSeq As Long, ByRef MissingData As Byte) As Long

'extern "C" int FAR pascal EndBlock(int C, int X, int UBMD, int LSeq, unsigned char *MissingData);

Declare Function MakeSC11 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN11 As Long, ByVal UBIS11 As Long, ByRef ISeq11 As Integer, ByRef SeqCompressor11 As Integer, ByRef Nuc11 As Byte) As Long
Declare Function MakeSC12 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN12 As Long, ByVal UBIS12 As Long, ByRef ISeq12 As Integer, ByRef SeqCompressor12 As Integer, ByRef Nuc12 As Byte) As Long
Declare Function MakeSC13 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN13 As Long, ByVal UBIS13 As Long, ByRef ISeq13 As Integer, ByRef SeqCompressor13 As Integer, ByRef Nuc13 As Byte) As Long
Declare Function MakeSC14 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN14 As Long, ByVal UBIS14 As Long, ByRef ISeq14 As Integer, ByRef SeqCompressor14 As Integer, ByRef Nuc14 As Byte) As Long
Declare Function MakeSC04 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN04 As Long, ByVal UBIS04 As Long, ByRef ISeq04 As Integer, ByRef SeqCompressor04 As Integer, ByRef Nuc04 As Byte) As Long
Declare Function MakeSC03 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN03 As Long, ByVal UBIS03 As Long, ByRef ISeq03 As Integer, ByRef SeqCompressor03 As Integer, ByRef Nuc03 As Byte) As Long
Declare Function MakeSC02 Lib "dna.dll" (ByVal x As Long, ByRef Y As Long, ByVal UBN02 As Long, ByVal UBIS02 As Long, ByRef ISeq02 As Integer, ByRef SeqCompressor02 As Integer, ByRef Nuc02 As Byte) As Long

Declare Function StringDist Lib "dna.dll" (ByVal LS As Long, ByVal x As Long, ByRef Valid As Long, ByRef Diffs As Long, ByVal StrZ As String, ByVal StrX As String) As Long
'int FAR pascal StringDist(                int LS,          int X           , int *Valid, int      *Diffs,              char *StrZ          , char *StrX){

Declare Function FindNextMask Lib "dna.dll" (ByVal NextNo As Long, ByVal NumSeeds As Long, ByRef Winner As Long, ByRef MaskSeq As Long, ByRef Dist As Single) As Long
Declare Function FindNextMask2 Lib "dna.dll" (ByVal NextNo As Long, ByVal NumSeeds As Long, ByRef Winner As Long, ByRef MaskSeq As Long, ByRef Dist As Single, ByRef TooRec As Long) As Long

'int FAR pascal FindNextMask(int Nextno,int NumSeeds                             , int *Winner             , int *Maskseq, float *Dist){

Declare Function EraseEmpties Lib "dna.dll" (ByVal NextNo As Long, ByVal UB As Long, ByVal UBFM As Long, ByVal SCO As Long, ByRef ISeqs As Long, ByRef FMat As Single, ByRef FubValid As Single, ByRef SMat As Single, ByRef SubValid As Single) As Long
'int FAR pascal EraseEmpties(int Nextno, int UB, int UBFM, int SCO, int *ISeqs, float *FMat, float *FubValid, float *SMat, float *SubValid){

Declare Function FillNuc Lib "dna.dll" (ByVal x As Long, ByVal Holder As Long, ByVal NextNo As Long, ByVal UBSN As Long, ByVal UBN As Long, ByRef NucXX As Byte, ByRef NucMat2 As Byte, ByRef SeqNum As Integer) As Long

'int FAR pascal FillNuc(int X, int holder, int Nextno, int UBSN, int UBN, unsigned char *NucXX, unsigned char *NucMat2, short int *SeqNum){

Declare Function ClearNodeArrays Lib "dna.dll" (ByVal PermNextno As Long, ByVal TType As Long, ByVal UBNF As Long, ByVal UBNMR As Long, ByVal UBNXY1 As Long, ByVal UBNXY2 As Long, ByRef NodeMaxRep As Single, ByRef NodeFind As Byte, ByRef NodeXY As Long) As Long
'int FAR pascal ClearNodeArrays(int PermNextno,int TType, int UBNF, int UBNMR, int UBNXY1, int UBNXY2, float *NodeMaxRep,  unsigned char *NodeFind, int *NodeXY){

Declare Function MakeAA Lib "dna.dll" (ByVal NextNo As Long, ByVal x As Long, ByVal UBSN As Long, ByRef AA As Long, ByRef NucMat As Byte, ByRef SeqNum As Integer) As Long

'int FAR pascal MakeAA(int Nextno, int X, int UBSN, int *AA, unsigned char  *NucMat, short int *SeqNum){


'int FAR pascal MakeSC11(int X, int UBN11, int UBIS11,short int *ISeq11, short int *SeqCompressor11, unsigned char *Nuc11){
Declare Function MakeTreeMatrix Lib "dna.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBD As Long, ByVal UBTM As Long, ByRef FMat As Single, ByRef TreeMatrix As Single, ByRef Distance As Single) As Long
Declare Function MakeTreeFMat Lib "dna.dll" (ByVal NextNo As Long, ByVal UBFM As Long, ByVal UBTF As Long, ByRef FMat As Single, ByRef TreeMatrix As Single) As Long
Declare Function MakeTreeSMat Lib "dna.dll" (ByVal NextNo As Long, ByVal UB4 As Long, ByVal UBFM As Long, ByVal UBTS As Long, ByRef FMat As Single, ByRef TreeSMat As Single, ByRef SMat As Single) As Long

Declare Function MakeNucSets3 Lib "dna.dll" (ByVal UBFLP As Long, ByVal NextNo As Long, ByVal StartPosInAlign As Long, ByVal EndPosInAlign As Long, ByVal UB11 As Long, ByVal UB12 As Long, ByVal UB13 As Long, ByVal UB14 As Long, ByVal UB02 As Long, ByVal UB03 As Long, ByVal UB04 As Long, ByRef NL As Byte, ByRef ML As Byte, ByRef FLP As Byte, ByRef Nuc11 As Byte, ByRef Nuc02 As Byte, ByRef Nuc12 As Byte, ByRef Nuc03 As Byte, ByRef Nuc13 As Byte, ByRef Nuc04 As Byte, ByRef Nuc14 As Byte) As Long
'int FAR pascal MakeNucSets3(int                   LSeq, int           Nextno, int           StartPosInAlign, int           EndPosInAlign, unsigned char *NL, unsigned char *ML, unsigned char *FLP, unsigned char *Nuc11, unsigned char *Nuc02, unsigned char *Nuc12, unsigned char *Nuc03, unsigned char *Nuc13, unsigned char *Nuc04, unsigned char *Nuc14, int *SeqCatCount){

Declare Function FillNucXX Lib "dna.dll" (ByVal NXX As Long, ByVal NextNo As Long, ByVal x As Long, ByVal UBNXX As Long, ByVal UBFLP As Long, ByRef NucXX As Byte, ByRef FLP As Byte) As Long

'int FAR pascal FillNucXX(int NXX, int Nextno, int X, int UBNXX, int UBFLP, unsigned char * NucXX, unsigned char *FLP){
Declare Function ReAddToRList Lib "dna.dll" (ByVal NextNo As Long, ByVal UBTRL As Long, ByVal UBRL As Long, ByRef tRList As Long, ByRef RList As Long, ByRef RNum As Long) As Long
'int FAR pascal ReAddToRList(int Nextno, int UBTRL, int UBRL, int *tRList, int *RList, int *RNum){

'int FAR pascal MakeTreeFMat(int Nextno, int UBFM, int UBD, int UBTM, float *FMat, float *TreeMatrix, float *Distance){
Declare Function CopyEventInfo Lib "dna.dll" (ByVal SEventNumber As Long, ByVal NextNo As Long, ByVal UBoD As Long, ByVal UBD As Long, ByVal UBE As Long, ByVal UBOE As Long, ByRef BestEvent As Long, ByRef OBE As Long, ByRef oD As Byte, ByRef oMi As Byte, ByRef oMa As Byte, ByRef Daught As Byte, ByRef MinorPar As Byte, ByRef MajorPar As Byte) As Long

'int FAR pascal CopyEventInfo(int SEventNumber, int Nextno, int UBoD, int UBD, int UBE, int UBOE, int *BestEvent, int *OBE, unsigned char *oD, unsigned char *oMi, unsigned char *oMa, unsigned char *Daught, unsigned char *MinorPar, unsigned char *MajorPar){

Declare Function DoAABlocks Lib "dna.dll" (ByVal XRes As Long, ByVal YRes As Long, ByVal UBPC As Long, ByVal UBIX As Long, ByVal UBID22 As Long, ByVal UBID23 As Long, ByVal UBID12 As Long, ByVal UBID13 As Long, ByRef PCount As Long, ByRef ImageX As Long, ByRef ImageData As Byte, ByRef ImageData2 As Byte) As Long
'int FAR pascal DoAABlocks(int XRes, int YRes, int UBPC, int UBIX, int UBID22, int UBID23, int UBID12, int UBID13, int *PCount, int *ImageX, unsigned char *ImageData, unsigned char *ImageData2){

Declare Function MakeImageDataBO Lib "dna.dll" (ByVal r As Long, ByVal g As Long, ByVal b As Long, ByVal UBFP As Long, ByVal UBID1 As Long, ByVal UBID2 As Long, ByVal UBID3 As Long, ByRef FakePicture As Single, ByRef ImageData As Byte) As Long
'int FAR pascal MakeImageDataBO(int R, int G, int B, int UBFP, int UBID2, int UBID3, float *FakePicture, unsigned char *ImageData){
Declare Function ModFP Lib "dna.dll" (ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByRef MaxV As Single, ByRef FakePicture As Single) As Long
'int FAR pascal ModFP(int UBFP1, int UBFP2, float MaxV, float *FakePicture){

Declare Function MakeTestStrip Lib "dna.dll" (ByVal UBX As Long, ByVal XFactor As Single, ByRef XDiffPos As Long, ByRef Teststrip As Single) As Long

'int FAR pascal MakeTestStrip(int UBX, float XFactor, int *XDiffPos, float *Teststrip) {


Declare Function AddFPX Lib "dna.dll" (ByVal UBFP1 As Long, ByVal StepDir As Long, ByVal IY As Long, ByVal X1 As Long, ByVal X2 As Long, ByVal TopS As Single, ByVal BotS As Single, ByRef FakePicture As Single) As Long
'int FAR pascal AddFPX(int UBFP1, int StepDir, int IY, int X1, int X2, float TopS, float BotS, float *FakePicture){
Declare Function AddFPY Lib "dna.dll" (ByVal UBFP1 As Long, ByVal StepDir As Long, ByVal IX As Long, ByVal Y1 As Long, ByVal Y2 As Long, ByVal TopS As Single, ByVal BotS As Single, ByRef FakePicture As Single) As Long

'int FAR pascal AddFPY(int UBFP1, int StepDir, int IX, int Y1, int Y2, float TopS, float BotS, float *FakePicture){

'Declare Function FillObject Lib "dna.dll" (ByVal  UBFP1, int UBFP2, float *FakePicture, float *FakePicture2, float *FakePicture3) as long

Declare Function FillObject Lib "dna.dll" (ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByRef FakePicture As Single, ByRef FakePicture2 As Single, ByRef FakePicture3 As Single) As Long
Declare Function MakeDistanceBakB Lib "dna.dll" (ByVal NextNo As Long, ByVal UBDB As Long, ByVal UBD As Long, ByRef Distance As Single, ByRef distancebak As Single) As Long
'extern "C" int FAR pascal MakeDistanceBakB(int Nextno, int UBDB, int UBD, float *Distance, float *distancebak);
Declare Function CopyFloatArray Lib "dna.dll" (ByVal NextNo As Long, ByVal UBDB As Long, ByVal UBD As Long, ByRef Distance As Single, ByRef distancebak As Single) As Long

Declare Function MakeTots Lib "dna.dll" (ByVal NextNo As Long, ByVal UBF As Long, ByRef Tot As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef DontUse As Byte) As Long
Declare Function MakeDI Lib "dna.dll" (ByVal NextNo As Long, ByVal UBDT As Long, ByVal UBF As Long, ByRef DI As Single, ByRef FMat As Single, ByRef SMat As Single, ByRef DoneThis As Long) As Long

Declare Function FinishDists2 Lib "dna.dll" (ByVal NextNo As Long, ByRef PermValid As Single, ByRef PermDIffs As Single, ByRef TValid As Single, ByRef TDiffs As Single, ByRef Distance As Single) As Long
'int FAR pascal FinishDists2(int Nextno as long, float *PermValid As Single, float *PermDiffs As Single, float *TValid As Single, float *TDiffs As Single, float *Distance As Single){
Declare Function GetCoRec Lib "dna.dll" (ByVal x As Long, ByVal PermNextno As Long, ByVal UBD As Long, ByRef Daught As Byte) As Long
'int FAR pascal GetCoRec(int X, int PermNextno, int UBD, unsigned char *Daught) {


Declare Function FillArray3 Lib "dna.dll" (ByVal LCA As Long, ByVal fv As Single, ByRef CurveArray As Single) As Long

Declare Function MakeFastLineList Lib "dna.dll" (ByVal PC As Long, ByVal ExtraZ As Long, ByVal PHAdj As Long, ByVal DixB As Single, ByVal AmB As Single, ByVal LOffset As Long, ByVal GPrintLen As Long, ByVal PicHeight As Long, ByVal WFactor As Single, ByVal Y As Long, ByVal OriMod1 As Long, ByVal UBDC As Long, ByVal OriMod2 As Long, ByVal UBLL1 As Long, ByVal UBGPP1 As Long, ByVal UBGP1 As Long, ByRef CurveArray As Single, ByRef GPrintMin As Single, ByRef LineList As Single, ByRef GPrintPos As Long, ByRef GPrint As Single, ByRef Decompress As Long) As Long

'int FAR pascal MakeFastLineList(                  int PC,           int ExtraZ,           int PHAdj,          float dixb,          float AmB,             int LOffset,           int GPrintLen,           int PicHeight,         float WFactor,             int Y,           int OriMod1,           int UBDC,           int OriMod2,           int UBLL1,           int UBGPP1,           int UBGP1,        float *CurveArray,          float *GPrintMin,          float *LineList,            int *GPrintPos,        float *GPrint,            int *Decompress){


'int FAR pascal CurveLeft(int ZoomL, int PosX, float SWin, float IncX, float XFactor, float PZ2, float XF2, float *CurveArray){

Declare Function CurveLeft Lib "dna.dll" (ByVal ZoomL As Long, ByVal PosX As Long, ByVal SWin As Single, ByVal IncX As Single, ByVal XFactor As Single, ByVal PZ2 As Single, ByVal XF2 As Single, ByRef CurveArray As Single) As Long
Declare Function CurveRight Lib "dna.dll" (ByVal LCA As Long, ByVal ZoomR As Long, ByVal PosX As Long, ByVal SWin As Single, ByVal IncX As Single, ByVal XFactor As Single, ByVal PZ2 As Single, ByVal XF2 As Single, ByRef CurveArray As Single) As Long

'int FAR pascal CurveRight(                  int LCA, int           ZoomR, int           PosX, float         SWin, float           IncX2, float          XFactor, float           PZ2, float           XF2, float          *CurveArray){

Declare Function CurveMid Lib "dna.dll" (ByVal LCA As Long, ByVal ZoomR As Long, ByVal AddjV As Single, ByVal HSWin2 As Single, ByRef CurveArray As Single) As Long
'int FAR pascal CurveMid(int LCA, int ZoomR, float AddjV, float HSWin2, float *CurveArray){


Declare Function FillSeqLines Lib "dna.dll" (ByVal PermNextno As Long, ByVal NumSeqLines As Long, ByVal Offset1 As Long, ByVal Offset2 As Long, ByVal Offset4 As Long, ByVal RSN1 As Long, ByVal Col1 As Long, ByVal Col2 As Long, ByVal Col3 As Long, ByVal Col4 As Long, ByVal UBSCR As Long, ByVal UBSL As Long, ByVal UBCD As Long, ByRef ColDist As Integer, ByRef SeqLines As Long, ByRef SeqColRef As Byte) As Long
'int FAR pascal FillSeqLines(int PermNextno, int NumSeqLines, int Offset1, int Offset2, int Offset4, int RSN1, int Col1, int Col2, int Col3, int Col4, int UBSCR, int UBSL, int UBCD, short int *ColDist, int *SeqLines,unsigned char *SeqColRef){


Declare Function FillSeqLines2 Lib "dna.dll" (ByVal NumSeqLines As Long, ByVal Offset1 As Long, ByVal Offset2 As Long, ByVal Offset4 As Long, ByVal RSN1 As Long, ByVal Col1 As Long, ByVal Col2 As Long, ByVal Col3 As Long, ByVal Col4 As Long, ByVal UBSL As Long, ByRef ColDist2 As Integer, ByRef SeqLines As Long, ByRef SeqColRef2 As Byte, ByRef ColPos2 As Long) As Long

'int FAR pascal FillSeqLines2(                   int NumSeqLines, int         Offset1, int            Offset2, int           Offset4, int           RSN1, int           Col1, int           Col2, int           Col3, int           Col4, int           UBSL, short int *   ColDist2, int             *SeqLines,unsigned char *SeqColRef2, int *ColPos2){


'extern "C" int FAR pascal CopyFloatArray(int Nextno, int UBDB, int UBD, float *Distance, float *distancebak);


Declare Function DoAALineY Lib "dna.dll" (ByVal C As Single, ByVal M As Single, ByVal Y1 As Single, ByVal Y2 As Single, ByVal X1 As Single, ByVal X2 As Single, ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByRef FakePicture As Single) As Long
Declare Function DoAALineYT Lib "dna.dll" (ByVal C As Single, ByVal M As Single, ByVal Y1 As Single, ByVal Y2 As Single, ByVal X1 As Single, ByVal X2 As Single, ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByRef FakePicture As Single) As Long
Declare Function DoAALineX Lib "dna.dll" (ByVal C As Single, ByVal M As Single, ByVal Y1 As Single, ByVal Y2 As Single, ByVal X1 As Single, ByVal X2 As Single, ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByRef FakePicture As Single) As Long
Declare Function DoAALineXT Lib "dna.dll" (ByVal C As Single, ByVal M As Single, ByVal Y1 As Single, ByVal Y2 As Single, ByVal X1 As Single, ByVal X2 As Single, ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByRef FakePicture As Single) As Long

Declare Function DoAALineXY Lib "dna.dll" (ByVal UBFP1 As Long, ByVal UBFP2 As Long, ByVal UBLL1 As Long, ByVal UBLL2 As Long, ByRef FakePicture As Single, ByRef LineList As Single) As Long
'int FAR pascal DoAALineXY(int UBFP1, int UBFP2, int UBLL1, int UBLL2, float *FakePicture, float *LineList){

Declare Function DrawDiffsC Lib "dna.dll" (ByVal SP As Long, ByVal EP As Long, ByVal UBTS As Long, ByVal MaxTS As Single, ByVal UBID1 As Long, ByVal UBID2 As Long, ByRef Teststrip As Single, ByRef ImageData As Byte) As Long

Declare Function DrawDiffsD Lib "dna.dll" (ByVal Z As Long, ByVal BkR As Long, ByVal BkG As Long, ByVal BkB As Long, ByVal SP As Long, ByVal EP As Long, ByVal UBTS As Long, ByVal MaxTS As Single, ByVal UBID1 As Long, ByVal UBID2 As Long, ByRef ColAdj As Long, ByRef Teststrip As Single, ByRef ImageData As Byte) As Long


Declare Function get_f_and_g Lib "dna.dll" (ByRef inc_matrix As Byte, ByRef num_states As Long, ByVal num_chars As Long, ByRef f_values As Double, ByRef g_values As Double) As Long
Declare Function FillIncMatrix Lib "dna.dll" (ByVal i As Long, ByVal num_inf As Long, ByVal NumTaxa As Long, ByRef inf_states As Long, ByRef PairsScores As Byte, ByRef char_alignment As Integer, ByRef PairsMatrix As Byte, ByRef SqScore As Long, ByRef inc_matrix As Byte) As Long
Declare Function MakeStateMap Lib "dna.dll" (ByVal num_taxa As Long, ByVal j As Long, ByVal UBSN1 As Long, ByRef SeqNum As Integer, ByRef state_map As Long, ByRef gap_char As Long) As Long
Declare Function CopyColumn Lib "dna.dll" (ByVal j As Long, ByVal UBNA As Long, ByVal UBSN As Long, ByVal num_taxa As Long, ByVal site_count As Long, ByRef SeqNum As Integer, ByRef new_alignment As Byte) As Long
Declare Function pair_score Lib "dna.dll" (ByRef Alignment As Integer, ByRef site_states As Long, ByVal char_a As Long, ByVal char_b As Long, ByVal num_sites As Long, ByVal num_taxa As Long) As Long
Declare Function pair_score2 Lib "dna.dll" (ByRef Alignment As Integer, ByRef site_states As Long, ByVal char_a As Long, ByVal num_sites As Long, ByVal num_taxa As Long, ByRef IncMatrix As Byte) As Long
Declare Function GetDScore Lib "dna.dll" (ByVal NumTaxa As Long, ByVal i As Long, ByVal j As Long, ByRef SqScore As Long, ByRef char_alignment As Integer, ByRef PairsMatrix As Byte) As Long
Declare Function MakeNewAlignment Lib "dna.dll" (ByVal num_taxa As Long, ByVal num_sites As Long, ByVal UBNA As Long, ByVal UBA As Long, ByRef state_map As Long, ByRef Alignment As Byte, ByRef new_alignment As Integer) As Long

Declare Function ReMakeDistance Lib "dna.dll" (ByVal LSeq As Long, ByVal NextNo As Long, ByVal UBD As Long, ByRef SM As Single, ByRef Distance As Single, ByRef PermValid As Single, ByRef PermDIffs As Single) As Long

Declare Function FillColDist Lib "dna.dll" (ByVal Col As Long, ByVal x As Long, ByVal tNT As Long, ByVal NextNo As Long, ByVal UBSN As Long, ByVal UBCD As Long, ByVal UBSCR As Long, ByRef SeqNum As Integer, ByRef ColDist As Integer, ByRef SeqColRef As Byte) As Long
Declare Function FillColDist2 Lib "dna.dll" (ByVal pCounter As Long, ByVal x As Long, ByVal tNT As Long, ByVal NextNo As Long, ByVal UBSN As Long, ByRef SeqNum As Integer, ByRef ColDist2 As Integer) As Long

Declare Function EmptyNodeFind Lib "dna.dll" (ByVal PermNextno As Long, ByVal UBNF As Long, ByVal UBNMR As Long, ByRef NodeFind As Byte, ByRef NodeMaxRep As Single) As Long

'int FAR pascal EmptyNodeFind(int PermNextno, int UBNF, int UBNMR, unsigned char *NodeFind, float *NodeMaxRep){


Declare Function FillVSiteMatC Lib "dna.dll" (ByVal NextNo As Long, ByVal PS1 As Long, ByVal PS2 As Long, ByVal UBSN As Long, ByVal UBSL As Long, ByVal UBVSM As Long, ByRef SList As Long, ByRef PermPlantNum As Long, ByRef VSitesMat As Long, ByRef OffsetPerm As Long, ByRef DiffPos As Long, ByVal LSub As Long, ByRef SeqNum As Integer, ByRef WorthDoing As Byte) As Long


Declare Function FindDupFlash Lib "dna.dll" (ByVal A As Long, ByVal b As Long, ByVal UBF As Long, ByRef FlashntNum As Long, ByRef Flashnt As Long) As Long

Declare Function P11Draw Lib "dna.dll" (ByVal Chunk As Long, ByVal LSeq As Long, ByVal SSB As Long, ByVal MinID As Single, ByVal UBID1 As Long, ByVal UBID2 As Long, ByVal Interval As Single, ByVal HeightOfWindow As Integer, ByVal StepSizeC As Single, ByRef Decompress As Long, ByRef DisplayID As Single, ByRef ImageData As Byte) As Long
Declare Function P4Draw Lib "dna.dll" (ByVal Chunk As Long, ByVal LSeq As Long, ByVal SSB As Long, ByVal MinID As Single, ByVal UBID1 As Long, ByVal UBID2 As Long, ByVal Interval As Single, ByVal HeightOfWindow As Integer, ByVal StepSizeC As Single, ByRef Decompress As Long, ByRef DisplayID As Single, ByRef ImageData As Byte) As Long


Declare Function TestPerms Lib "dna.dll" (ByVal LSub As Long, ByVal UBCH1 As Long, ByVal UBCH2 As Long, ByVal UBCR1 As Long, ByVal UBVSM1 As Long, ByVal UBVSM2 As Long, ByRef HigherMat As Single, ByRef LowerMat As Single, ByRef VSitesMatP As Long, ByRef VSitesMat As Long, ByRef ChiResult As Single, ByRef ChiResultP As Single, ByRef ChiHigher As Long) As Long
Declare Function TestPerms2 Lib "dna.dll" (ByVal LSub As Long, ByVal UBCH1 As Long, ByVal UBCH2 As Long, ByVal UBCR1 As Long, ByVal UBVSM1 As Long, ByVal UBVSM2 As Long, ByRef HigherMat As Single, ByRef LowerMat As Single, ByRef VSitesMatP As Long, ByRef VSitesMat As Long, ByRef ChiResult As Single, ByRef ChiResultP As Single, ByRef ChiHigher As Long, ByRef TN As Single) As Long
Declare Function FillORFWin Lib "dna.dll" (ByVal Z As Long, ByVal FrameRef As Long, ByVal SIL As Long, ByVal EIL As Long, ByVal UBOW1 As Long, ByVal UBOW2 As Long, ByRef ORFWin As Integer) As Long
Declare Function GetNumInListC Lib "dna.dll" (ByVal Seq1 As Long, ByVal Seq2 As Long, ByVal Seq3 As Long, ByRef S1S2 As Long, ByRef S2S3 As Long) As Long
'extern "C" int FAR pascal GetNumInListC(int Seq1, int Seq2, int Seq3, int *S1S2, int *S2S3);

'FillORFWin(int Z, int FrameRef, int SIL, int EIL, int UBOW, short int *ORFWin)
'int FAR pascal TestPerms(int LSub, int UBCH1, int UBCH2, int UBCR1, int UBVSM1, int UBVSM2, float *HigherMat, float *LowerMat, int *VSitesMatP, int *VSitesMat, float *ChiResult,float *ChiResultP, int *ChiHigher){



'int FAR pascal P11Draw(int Chunk, int LSeq, int SSB, float MinID, int UBID1, int UBID2, float Interval,short int HeightOfWindow, float StepSizeC, int *Decompress, float *DisplayID, unsigned char *ImageData){


'int FAR pascal FillVSiteMatC(int Nextno, int PS1, int PS2, int UBSN, int UBSL, int UBVSM, int *SList, int *PermPlantNum, int *VSitesMat, int *OffsetPerm, int *DiffPos, int LSub, short int *SeqNum, unsigned char *WorthDoing){


'int FAR pascal FillColDist2(int                   PCounter, int          X, int            tnt, int            Nextno, int          UBSN, short int    *SeqNum, short int      *ColDist2)

'int FAR pascal DrawDiffsD(                  int Z, i          nt BkR,           int BkG,           int BkB,           int SP,           int EP,           int UBTS,          float MaxTS,            int UBID1,           int UBID2,          int *ColAdj,        float *Teststrip,    unsigned char *ImageData){

'int FAR pascal DoAALineY(                float C,           float M,           float Y1,           float Y2,           float X1,           float X2,             int UBFP1,           int UBFP2,        float *FakePicture){

Type Site
    polystatus As Byte
    infstatus As Byte
    gapstatus As Byte
    orig_index As Long
    num_states As Long
    num_missing As Long
End Type
Private Type LUID
   LowPart As Long
   HighPart As Long
End Type

Private Type LUID_AND_ATTRIBUTES
   pLuid As LUID
   Attributes As Long
End Type

Private Type TOKEN_PRIVILEGES
   PrivilegeCount As Long
   TheLuid As LUID
   Attributes As Long
End Type


Public Type SAFEARRAYBOUND
    cElements As Long
    lLbound As Long
End Type

Public Type SAFEARRAY2D
    cDims As Integer
    fFeatures As Integer
    cbElements As Long
    cLocks As Long
    pvData As Long
    Bounds(0 To 1) As SAFEARRAYBOUND
End Type

Public Declare Function VarPtrArray Lib "msvbvm50.dll" Alias "VarPtr" (Ptr() As Any) As Long

Public Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
    lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)


'Declare Function SeqWrite Lib "c:\darren\dna project\dll2\windebug\dna.dll" (ByVal hdc As Long, ByVal nextnox As Integer, ByVal fraglen As Integer, ByVal seqlen As Integer, ByVal winleftx As Integer, ByRef seqfrag As String) As Integer
'Constants
Public Const FW_BOLD = 700
Public Const FW_NORMAL = 400
Public Const DEFAULT_CHARSET = 1
Public Const OUT_DEFAULT_PRECIS = 0
Public Const CLIP_DEFAULT_PRECIS = 0
Public Const PROOF_QUALITY = 2
Public Const DEFAULT_PITCH = 0
Public Const FF_DONTCARE = 0
Public Const WM_CLOSE = &H10
Public Const GW_HWNDNEXT = 2
Public Const STILL_ACTIVE = &H103
Public Const PROCESS_QUERY_INFORMATION = &H400
Public Const LENTYPE = 50
Public NumT As Long, NumD As Long, Q() As Double, Qb() As Double, typex() As Long, pi() As Double, new2() As Long


'Console application declares start********************************
Public Declare Function GetStdHandle Lib "kernel32" _
(ByVal nStdHandle As Long) As Long

Public Declare Function WriteFile Lib "kernel32" _
(ByVal hFile As Long, _
lpBuffer As Any, _
ByVal nNumberOfBytesToWrite As Long, _
lpNumberOfBytesWritten As Long, _
lpOverlapped As Any) As Long

Public Const STD_OUTPUT_HANDLE = -11&

Public Type COORD
        x As Integer
        Y As Integer
End Type

Public Type SMALL_RECT
        Left As Integer
        Top As Integer
        Right As Integer
        Bottom As Integer
End Type

Public Type CONSOLE_SCREEN_BUFFER_INFO
        dwSize As COORD
        dwCursorPosition As COORD
        wAttributes As Integer
        srWindow As SMALL_RECT
        dwMaximumWindowSize As COORD
End Type
Public Declare Function GetConsoleScreenBufferInfo Lib "kernel32" _
(ByVal hConsoleOutput As Long, _
lpConsoleScreenBufferInfo As CONSOLE_SCREEN_BUFFER_INFO) As Long

Public Declare Function SetConsoleTextAttribute Lib "kernel32" _
(ByVal hConsoleOutput As Long, ByVal wAttributes As Long) As Long

Public Const FOREGROUND_BLUE = &H1     '  text color contains blue.
Public Const FOREGROUND_GREEN = &H2     '  text color contains green.
Public Const FOREGROUND_INTENSITY = &H8     '  text color is intensified.
Public Const FOREGROUND_RED = &H4     '  text color contains red.


Public scrbuf      As CONSOLE_SCREEN_BUFFER_INFO
Public hOutput             As Long
'Console application declares end********************************

Public Function WriteToConsole(sText As String) As Boolean
    Dim lWritten            As Long
    
    If WriteFile(hOutput, ByVal sText, Len(sText), lWritten, ByVal 0) = 0 Then
        WriteToConsole = False
    Else
        WriteToConsole = True
    End If
End Function


Public Sub ResortCurrentxover(S1)
    Dim GoOn As Byte
    Dim WinPrg As Integer, Prg As Integer
    Dim WinRep As Long, WinRepB As Long, MaxPValB As Double, MaxPVal As Double, MaxPu As Long, Begin As Long, Ending As Long
    Dim PVal As Double
    Dim PU() As Long
    ReDim PU(AddNum * 2)
    Prg = XoverList(S1, MaxXOListSize).ProgramFlag
    Begin = XoverList(S1, MaxXOListSize).Beginning
    Ending = XoverList(S1, MaxXOListSize).Ending
    PVal = XoverList(S1, MaxXOListSize).Probability
    MaxPVal = 0
    'First find most represented program
    
    For x = 0 To MaxXOListSize - 1
        PU(XoverList(S1, x).ProgramFlag) = PU(XoverList(S1, x).ProgramFlag) + 1
    Next ' X
    For x = 0 To AddNum * 2
        If PU(x) >= MaxPu Then
            MaxPu = PU(x)
            WinPrg = x
        End If
    Next 'X
    
    For x = 1 To MaxXOListSize - 1
        If XoverList(S1, x).ProgramFlag = WinPrg Then
            If (PVal <= XoverList(S1, x).Probability Or (Prg <> XoverList(S1, x).ProgramFlag And Prg <> XoverList(S1, x).ProgramFlag + AddNum)) And XoverList(S1, x).Probability > MaxPVal Then
                If XoverList(S1, x).Beginning >= Begin And XoverList(S1, x).Ending <= Ending Then
                    MaxPVal = XoverList(S1, x).Probability
                    WinRep = x
                End If
                WinRepB = x
                MaxPValB = XoverList(S1, x).Probability
            End If
        End If
    Next x
    
    If MaxPValB > 0 Then 'ie there is no space but there is a worse P-val, so replace it.
        
        WinRep = WinRepB
    End If
    
    If WinRep > 0 Then
        
        
        
        If RelX = 0 And RelY = 0 And SEventNumber < 1 Then
            RecombNo(XoverList(S1, WinRep).ProgramFlag) = RecombNo(XoverList(S1, WinRep).ProgramFlag) - 1
        End If
        XoverList(S1, WinRep) = XoverList(S1, MaxXOListSize)
    Else
        
         If RelX = 0 And RelY = 0 And SEventNumber < 1 Then
            RecombNo(XoverList(S1, MaxXOListSize).ProgramFlag) = RecombNo(XoverList(S1, MaxXOListSize).ProgramFlag) - 1
         End If
    End If
    
    
End Sub



Public Sub LoadPairsScores()

    Dim A As Long, oDirX As String, FF As Byte, UB As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Open "PairsScores" For Binary As #FF
    UB = -1
    UB = LOF(FF)
    On Error GoTo 0
    If UB < 1000 Then
        For A = 0 To 65536
            PairsScores(A) = 255
        Next A
    Else
        Get #FF, , PairsScores()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
End Sub
Public Sub WriteNames(S1, s2, S3, c1, c2, c3)

    Dim LastFontSize As Single, LOSpace As Integer, YPos As Integer, TotLen As Integer, L1 As Integer, L2 As Integer, L3 As Integer, L4 As Integer, L5 As Integer, L6 As Integer, DrawLen As Integer, XPos1 As Integer, XPos2 As Integer, XPos3 As Integer
    Dim OFontSize As Double

    OFontSize = Form1.Picture7.FontSize
     
    GExtraTNum = 5
    ReDim GExtraText(GExtraTNum)
    If UBound(OriginalName, 1) >= S1 And UBound(OriginalName, 1) >= s2 And UBound(OriginalName, 1) >= S3 Then
        L1 = Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(2))
        L2 = Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(3))
        L3 = Form1.Picture7.TextWidth(WNStr(2) + " - " + WNStr(3))
        
        
        GExtraText(0) = WNStr(1) + " - " + WNStr(2)
        GExtraText(1) = WNStr(1) + " - " + WNStr(3)
        GExtraText(2) = WNStr(2) + " - " + WNStr(3)
        
    Else
        L1 = Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(2))
        L2 = Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(3))
        L3 = Form1.Picture7.TextWidth(WNStr(2) + " - " + WNStr(3))
       
        
        GExtraText(0) = WNStr(1) + " - " + WNStr(2)
        GExtraText(1) = WNStr(1) + " - " + WNStr(3)
        GExtraText(2) = WNStr(2) + " - " + WNStr(3)
        
    
    
    End If
    
    L4 = Form1.Picture7.TextWidth("(Major Parent - Minor Parent)")
    L5 = Form1.Picture7.TextWidth("(Major Parent - Recombinant)")
    L6 = Form1.Picture7.TextWidth("(Minor Parent - Recombinant)")
    GExtraText(3) = "(Major Parent - Minor Parent)"
    GExtraText(4) = "(Major Parent - Recombinant)"
    GExtraText(5) = "(Minor Parent - Recombinant)"
        
    DrawLen = Form1.Picture7.ScaleWidth - 30 '+ 200
    
    
    TotLen = 0
    If L1 < L4 Then
        L1 = L4
   
    End If
    If L2 < L5 Then
        L2 = L5
    
    End If
    
    If L3 < L6 Then
        L3 = L6
    End If
    TotLen = L1 + L2 + L3
    
    If DrawLen > TotLen Then
        LOSpace = (DrawLen - TotLen) / 2
        If L1 > L4 Then
            XPos1 = 25
        Else
            XPos1 = 25 + (L4 - L1) / 2
        End If
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    Else

        Do Until TotLen < DrawLen Or Form1.Picture7.FontSize < 4
            LastFontSize = Form1.Picture7.FontSize
            Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
            If Form1.Picture7.FontSize = LastFontSize Then Exit Do
            
                
            
            L1 = Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(2))
            '@
            L2 = Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(3))
            L3 = Form1.Picture7.TextWidth(WNStr(2) + " - " + WNStr(3))
            L4 = Form1.Picture7.TextWidth("(Major Parent - Minor Parent)")
            L5 = Form1.Picture7.TextWidth("(Major Parent - Recombinant)")
            L6 = Form1.Picture7.TextWidth("(Minor Parent - Recombinant)")
                    
            If L1 < L4 Then
                 L1 = L4
             End If
             If L2 < L5 Then
                 L2 = L5
             End If
             If L3 < L6 Then
                 L3 = L6
             End If
            TotLen = L1 + L2 + L3
        Loop
        
        
        
        
        LOSpace = (DrawLen - TotLen) / 2
        If L1 > L4 Then
            XPos1 = 25
        Else
            XPos1 = 25 + (L4 - L1) / 2
        End If
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
        
    End If
    If XPos2 < XPos1 Then XPos2 = XPos1
    If XPos3 < XPos1 Then XPos3 = XPos1
'Exit Sub
    Dim X1Pos1 As Long, X1Pos2 As Long, X1Pos3 As Long
    Dim X2Pos1 As Long, X2Pos2 As Long, X2Pos3 As Long
    If L1 = L4 Then
        X1Pos1 = XPos1 + (L4 - Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(2))) / 2
        X2Pos1 = XPos1
    Else
        X1Pos1 = XPos1
        X2Pos1 = X1Pos1 + (L1 - L4) / 2
    End If
    
    If L2 = L5 Then
        X1Pos2 = XPos2 + (L5 - Form1.Picture7.TextWidth(WNStr(1) + " - " + WNStr(3))) / 2
        X2Pos2 = XPos2
    Else
        X1Pos2 = XPos2
        X2Pos2 = X1Pos2 + (L2 - L5) / 2
    End If
    
    If L3 = L6 Then
        X1Pos3 = XPos3 + (L6 - Form1.Picture7.TextWidth(WNStr(2) + " - " + WNStr(3))) / 2
        X2Pos3 = XPos3
    Else
        X1Pos3 = XPos3
        X2Pos3 = X1Pos3 + (L3 - L6) / 2
    End If
    
    'XX = PermNextno
    YPos = Form1.Picture7.Height * (0.92)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = X1Pos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print WNStr(1) & " - " & WNStr(2)
    Form1.Picture7.CurrentX = X1Pos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    '@
    Form1.Picture7.Print WNStr(1) & " - " & WNStr(3)
    Form1.Picture7.CurrentX = X1Pos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print WNStr(2) & " - " & WNStr(3)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = X1Pos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print WNStr(1) & " - " & WNStr(2)
    Form1.Picture7.CurrentX = X1Pos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    '@
    Form1.Picture7.Print WNStr(1) & " - " & WNStr(3)
    Form1.Picture7.CurrentX = X1Pos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print WNStr(2) & " - " & WNStr(3)
    Form1.Picture7.CurrentX = X1Pos1
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c1
    Form1.Picture7.Print WNStr(1) & " - " & WNStr(2)
    Form1.Picture7.CurrentX = X1Pos2
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c2
    Form1.Picture7.Print WNStr(1) & " - " & WNStr(3)
    Form1.Picture7.CurrentX = X1Pos3
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c3
    Form1.Picture7.Print WNStr(2) & " - " & WNStr(3)
    
    
    XPos1 = XPos1 + (L1 - L4) / 2
    XPos2 = XPos2 + (L2 - L5) / 2
    XPos3 = XPos3 + (L3 - L6) / 2
    
    '
    YPos = Form1.Picture7.Height * (0.96)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = XPos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print "(Major Parent - Minor Parent)"
    Form1.Picture7.CurrentX = XPos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print "(Major Parent - Recombinant)"
    Form1.Picture7.CurrentX = XPos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print "(Minor Parent - Recombinant)"
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = XPos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    '@
    Form1.Picture7.Print "(Major Parent - Minor Parent)"
    Form1.Picture7.CurrentX = XPos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print "(Major Parent - Recombinant)"
    Form1.Picture7.CurrentX = XPos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print "(Minor Parent - Recombinant)"
    Form1.Picture7.CurrentX = XPos1
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c1
    Form1.Picture7.Print "(Major Parent - Minor Parent)"
    Form1.Picture7.CurrentX = XPos2
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c2
    Form1.Picture7.Print "(Major Parent - Recombinant)"
    Form1.Picture7.CurrentX = XPos3
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = c3
    Form1.Picture7.Print "(Minor Parent - Recombinant)"
    
    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFontSize
End Sub
Public Sub LoadMFA()
 SSSx = Abs(GetTickCount)
Dim NF As Integer, TempString As String, BusyReadingFlag As Byte, NumCoords As Long, CoOrds() As Long ', SeqFile As String
    Dim TempS As String, TempSS As String
    Dim incR As Long
    Dim Target As String
    Dim Position1 As Long, Position2 As Long, BTS As String, crPos As Long, lfPos As Long, NPos As Long, Pos As Long, LastPos As Long, ZZ As Long, GG As Long, WBN As Byte, NextNo3 As Long, lNextNo3 As Long, MaxLen As Long
    Dim FFlag As Byte
    Dim SuperSeq() As String
    Dim TempMultName() As String, TempMult() As String
    ReDim TempMultName(0), TempMult(0), MultCoords(MultFNum, 0)
    FFlag = 0
    Form1.SSPanel1.Caption = "Loading MFA File"
    NextNo = -1
    ReDim CoOrds(4, 1000)
    ReDim SuperSeq(0)
    For FN = 0 To MultFNum
        
        If WholeFileFlag = 0 Then
            NF = FreeFile
            Open FName$ For Binary Access Read As #NF
            
            Form1.ProgressBar1.Value = 1
            Call UpdateF2Prog
            CurPos = 1
            BTS = String(1000000, " ")
            Get #1, 1, BTS
            LastPos = 1
            crPos = InStr(CurPos, BTS, Chr$(13), vbBinaryCompare)
        
            lfPos = InStr(CurPos, BTS, Chr$(10), vbBinaryCompare)
            'TempString
            If crPos > 0 And lfPos > 0 Then
                If crPos < lfPos Then
                    Target = Chr$(13)
                Else
                    Target = Chr$(10)
                End If
                incR = 2
            ElseIf crPos > 0 Then
                Target = Chr$(13)
                incR = 1
            ElseIf lfPos > 0 Then
                Target = Chr$(10)
                incR = 1
            End If
            BusyReadingFlag = 0
            Do While Not EOF(NF)
                
                
                Do
                    Pos = InStr(LastPos, BTS, Target, vbBinaryCompare)
                    If Pos > 0 Then
                        TempString = Mid$(BTS, LastPos, Pos - LastPos)
                        
                        If Left(TempString, 1) = ">" Then 'its a new sequence
                            x = x
                            BusyReadingFlag = 0
                            NextNo = NextNo + 1
                            'If Nextno = 44 Then
                            '    Exit Sub
                            'End If
                            Call SeqArrays
                            OriginalName(NextNo) = Right(TempString, Len(TempString) - 1)
                            nxpos = InStr(1, OriginalName(NextNo), ":", vbBinaryCompare)
                            
                            If nxpos > 0 Then
                                nxxpos = InStr(nxpos, OriginalName(NextNo), "-", vbBinaryCompare)
                                'XX = Mid$(OriginalName(Nextno), nxpos + 1, nxxpos - nxpos - 1)
                                Position1 = CLng(Trim(Mid$(OriginalName(NextNo), nxpos + 1, nxxpos - nxpos - 1)))
                                nxxxpos = InStr(nxxpos, OriginalName(NextNo), " ", vbBinaryCompare)
                                If nxxxpos = 0 Then
                                    nxxxpos = InStr(nxxpos, OriginalName(NextNo), "-", vbBinaryCompare)
                                    If nxxxpos = 0 Then
                                        nxxxpos = InStr(nxxpos, OriginalName(NextNo), "+", vbBinaryCompare)
                                        If nxxxpos = 0 Then
                                            nxxxpos = InStr(nxxpos, OriginalName(NextNo), Target, vbBinaryCompare)
                                        End If
                                    End If
                                End If
                                'XX = Mid$(OriginalName(Nextno), nxxpos + 1, nxxxpos - nxxpos - 1)
                                Position2 = CLng(Trim(Mid$(OriginalName(NextNo), nxxpos + 1, nxxxpos - nxxpos - 1)))
                            End If
                            
                            
                            OriginalName(NextNo) = Trim(Left(OriginalName(NextNo), nxpos - 1))
                            lNextNo3 = NextNo3
                            NextNo3 = -1
                            WBN = 0
                            'targetxx = Nextno - 1
                            If nxpos > 0 Then
                                NumCoords = NumCoords + 1
                                If NumCoords > UBound(CoOrds, 2) Then
                                    ReDim Preserve CoOrds(4, NumCoords + 1000)
                                End If
                                CoOrds(0, NumCoords) = ZZ
                                CoOrds(1, NumCoords) = Position1
                                CoOrds(2, NumCoords) = Position2
                                
                            End If
                            NextNo3 = NextNo
                            For ZZ = 0 To NextNo - 1
                                If OriginalName(NextNo) = OriginalName(ZZ) Then
                                
                                    If nxpos > 0 Then
                                        
                                        CoOrds(0, NumCoords) = ZZ
                                        
                                        
                                    End If
                                    If ZZ <= lNextNo3 Then
                                        'make all the sequences the same length
                                        'find
                                        MaxLen = 0
                                        For GG = 0 To NextNo - 1
                                            If MaxLen < Len(StrainSeq(GG)) Then
                                                MaxLen = Len(StrainSeq(GG))
                                            End If
                                        Next GG
                                        For GG = 0 To NextNo - 1
                                            StrainSeq(GG) = StrainSeq(GG) + String(MaxLen - Len(StrainSeq(GG)), "-")
                                                
                                        Next GG
                                        If Len(StrainSeq(0)) > 10000 Then
                                            
                                            ReDim Preserve SuperSeq(NextNo)
                                            For x = 0 To NextNo - 1
                                                SuperSeq(x) = SuperSeq(x) + StrainSeq(x)
                                                StrainSeq(x) = ""
                                                
                                            Next x
                                            
                                        End If
                                        
                                        
                                    End If
                                    
                                    NextNo3 = ZZ
                                    WBN = 1
                                    Exit For
                                End If
                            Next ZZ
                            
                            'now get the sequences
                            If NextNo3 = -1 Then
                                NextNo3 = NextNo
                            End If
                            LastPos = Pos + incR
                            
                            TempSS = ""
                            TempS = ""
                            Do While Not EOF(NF)
                                Pos = InStr(LastPos, BTS, Target, vbBinaryCompare)
                                If Pos > 0 Then
                                    TempString = Mid$(BTS, LastPos, Pos - LastPos)
                                    If Left(TempString, 1) = ">" Then
                                        BusyReadingFlag = 0
                                        Pos = LastPos - incR
                                        Exit Do 'this does not update lastpos so the same line will be re-read
                                    End If
                                    BusyReadingFlag = 1
                                    TempS = TempS + TempString
                                    If Len(TempS) > 100000 Then
                                        TempSS = TempSS + TempS
                                        TempS = ""
                                        
                                    End If
                                    LastPos = Pos + incR
                                Else
                                    CurPos = CurPos + LastPos - 1
                                    BTS = String(1000000, " ")
                                    Get #1, CurPos, BTS
                                    LastPos = 1
                                    
                                End If
                                            
                            Loop
                            If nxpos > 0 Then
                               
                            
                                CoOrds(3, NumCoords) = Len(StrainSeq(NextNo3)) + 1
                                CoOrds(4, NumCoords) = CoOrds(3, NumCoords) + Len(TempSS) + Len(TempS)
                            End If
                            
                            XX = Len(TempS)
                            StrainSeq(NextNo3) = StrainSeq(NextNo3) + TempSS + TempS
                            x = x
                        End If
                        If WBN = 1 Then
                            NextNo = NextNo - 1
                        End If
                    
                    End If
                    EEE = Abs(GetTickCount)
                    If Abs(EEE - SSS) > 500 Then
                        SSS = EEE
                
                        Form1.ProgressBar1.Value = 1 + ((CurPos + LastPos) / LOF(NF)) * 100 * 0.3
                        Form1.SSPanel1.Caption = Trim(Str(CurPos + LastPos)) + " of " + Trim(Str(LOF(NF))) + " nucleotides loaded"
                        Call UpdateF2Prog
                        Form1.Refresh
                    End If
                    If Pos = 0 Then
                        CurPos = CurPos + LastPos - 1
                        BTS = String(1000000, " ")
                        Get #1, CurPos, BTS
                        LastPos = 1
                        Exit Do
                    End If
                    LastPos = Pos + incR
                    
                Loop
                
                
            Loop
    
            Close #NF
            If UBound(SuperSeq, 1) > 0 Then
                For x = 0 To UBound(SuperSeq, 1)
                    StrainSeq(x) = SuperSeq(x)
                    
                Next x
            End If
            
            'XX = Len(StrainSeq(0)) '499680
        Else
            LastPos = InStr(1, SeqFile, ">", vbBinaryCompare)
            NextNo = NextNo + 1
    
            
    
            crPos = InStr(LastPos, SeqFile, Chr$(13), vbBinaryCompare)
            
            lfPos = InStr(LastPos, SeqFile, Chr$(10), vbBinaryCompare)
            
            If crPos > 0 And lfPos > 0 Then
                If crPos < lfPos Then
                    Target = Chr$(13)
                Else
                    Target = Chr$(10)
                End If
                incR = 2
            ElseIf crPos > 0 Then
                Target = Chr$(13)
                incR = 1
            ElseIf lfPos > 0 Then
                Target = Chr$(10)
                incR = 1
            End If
    
            LastPos = 0
            Pos = InStr(LastPos + 1, SeqFile, ">", vbBinaryCompare)
    
            Do
                
                If Pos = 0 Then Exit Do 'Pos = Len(SeqFile) - 1
                NPos = InStr(LastPos + 1, SeqFile, Target, vbBinaryCompare)
                
                'If NPos = 0 Then
                '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
                '    If NPos = 0 Then
                '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
                '    End If
                'End If
                If NPos = 0 Then Exit Sub
                If NPos <= Pos Then
                    NPos = InStr(Pos + 1, SeqFile, Target, vbBinaryCompare)
                End If
                
                OriginalName(NextNo) = Trim(Mid$(SeqFile, Pos + 1, NPos - Pos - 1))
                
                nxpos = InStr(1, OriginalName(NextNo), ":", vbBinaryCompare)
                If nxpos > 0 Then
                    nxxpos = InStr(nxpos, OriginalName(NextNo), "-", vbBinaryCompare)
                    'XX = Mid$(OriginalName(Nextno), nxpos + 1, nxxpos - nxpos - 1)
                    Position1 = CLng(Trim(Mid$(OriginalName(NextNo), nxpos + 1, nxxpos - nxpos - 1)))
                    nxxxpos = InStr(nxxpos, OriginalName(NextNo), " ", vbBinaryCompare)
                    If nxxxpos = 0 Then
                        nxxxpos = InStr(nxxpos + 1, OriginalName(NextNo), "-", vbBinaryCompare)
                        If nxxxpos = 0 Then
                            nxxxpos = InStr(nxxpos, OriginalName(NextNo), "+", vbBinaryCompare)
                            If nxxxpos = 0 Then
                                nxxxpos = InStr(nxxpos, OriginalName(NextNo), Target, vbBinaryCompare)
                            End If
                        End If
                    End If
                    'XX = Mid$(OriginalName(Nextno), nxxpos + 1, nxxxpos - nxxpos - 1)
                    If nxxxpos > 0 Then
                        Position2 = CLng(Trim(Mid$(OriginalName(NextNo), nxxpos + 1, nxxxpos - nxxpos - 1)))
                    Else
                        Position2 = CLng(Trim(Mid$(OriginalName(NextNo), nxxpos + 1, Len(OriginalName(NextNo)))))
                    End If
                End If
                
                OriginalName(NextNo) = Left(OriginalName(NextNo), nxpos - 1)
                lNextNo3 = NextNo3
                NextNo3 = -1
                WBN = 0
                'targetxx = Nextno - 1
                If nxpos > 0 Then
                    NumCoords = NumCoords + 1
                    If NumCoords > UBound(CoOrds, 2) Then
                        ReDim Preserve CoOrds(4, NumCoords + 1000)
                    End If
                    CoOrds(0, NumCoords) = NextNo
                    CoOrds(1, NumCoords) = Position1
                    CoOrds(2, NumCoords) = Position2
                End If
                NextNo3 = NextNo
                For ZZ = 0 To NextNo - 1
                    If OriginalName(NextNo) = OriginalName(ZZ) Then
                        If nxpos > 0 Then
                            
                            CoOrds(0, NumCoords) = ZZ
                            
                        End If
                        
                        
                        If ZZ <= lNextNo3 Then
                            'make all the sequences the same length
                            'find
                            MaxLen = 0
                            For GG = 0 To NextNo - 1
                                If MaxLen < Len(StrainSeq(GG)) Then
                                    MaxLen = Len(StrainSeq(GG))
                                End If
                            Next GG
                            For GG = 0 To NextNo - 1
                                StrainSeq(GG) = StrainSeq(GG) + String(MaxLen - Len(StrainSeq(GG)), "-")
                                    
                            Next GG
                        End If
                        
                        
                        
                        NextNo3 = ZZ
                        WBN = 1
                        Exit For
                    End If
                Next ZZ
                
                
                
                
                If NextNo3 = -1 Then
                    NextNo3 = NextNo
                End If
                
                
                
                LastPos = NPos + incR
                NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
                Pos = InStr(LastPos + 1, SeqFile, ">", vbBinaryCompare)
                
                If Pos = 0 Then
                    If InStr(1, SeqFile, "Recombination Data", vbBinaryCompare) = 0 Then
                        Pos = Len(SeqFile)
                    Else
                        NPos = InStr(1, SeqFile, "GB Data", vbBinaryCompare) - 2
                        Xpos = InStr(1, SeqFile, "Recombination Data", vbBinaryCompare) - 2
                        
                        If Xpos < NPos Or NPos = 0 Then
                            Pos = Xpos
                        Else
                            Pos = NPos
                        End If
                    End If
                    FFlag = 1
                
                End If
                If NPos = 0 Then NPos = Len(SeqFile)
                
                
                TempSS = ""
                TempS = ""
                   
                    
                SS = Abs(GetTickCount)
                
                Do While LastPos + 2 < Pos And NPos > 0
                    
                                           
                    TempS = TempS + Mid$(SeqFile, LastPos, NPos - LastPos)
                    
                    
                    If Len(TempS) > 100000 Then
                        TempSS = TempSS + TempS
                        TempS = ""
                    End If
                    'xxx = Asc(left(TempS, 1))
                    LastPos = NPos + incR
                    'xx = Len(StrainSeq(10))
                    NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
                    'If NPos = 0 Then
                    '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
                    '    If NPos = 0 Then
                    '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
                    '    End If
                    'End If
                    'If NPos = 0 Then Exit Sub
                    'EEe = Abs(GetTickCount)
                    'If Abs(EEe - SSS) > 500 Then
                    '    SSS = EEe
                    '    Form1.SSPanel1.Caption = "Loaded" + Str(Len(StrainSeq(0))) + " nucleotides"
                    '    Form1.Refresh
                    'End If
                Loop
                
                
                    Dim PosX As Long
                
                If nxpos > 0 Then
                    CoOrds(3, NumCoords) = Len(StrainSeq(NextNo3)) + 1
                    CoOrds(4, NumCoords) = CoOrds(3, NumCoords) + Len(TempSS) + Len(TempS)
                    
                End If
                StrainSeq(NextNo3) = StrainSeq(NextNo3) + TempSS + TempS
                
                'XX = Len(StrainSeq(0))
                If FFlag = 1 Then Exit Do
                If Pos >= Len(SeqFile) - 2 Then Exit Do
                If WBN = 0 Then
                    NextNo = NextNo + 1
                Else
                    x = x
                End If
                Call SeqArrays
    
                'Form1.SSPanel1.Caption = trim$(cstr(Nextno)) & " Sequences Loaded"
                    EEE = Abs(GetTickCount)
                    If Abs(EEE - SSS) > 500 Then
                        SSS = EEE
                
                        Form1.ProgressBar1.Value = 1 + (LastPos / Len(SeqFile)) * 100 * 0.3
                        Form1.SSPanel1.Caption = Trim(Str(LastPos)) + " of " + Trim(Str(Len(SeqFile))) + " nucleotides loaded"
                        Call UpdateF2Prog
                        Form1.Refresh
                    End If
        x = x
            Loop
            XX = Len(StrainSeq(0)) '499680
            NextNo = NextNo - 1
        End If
        
        'go through and reorder everything to be in the same order as the type sequence
        
        TypeSeq = TypeSeqNumber
        If TypeSeq > NextNo Then
            TypeSeq = 0
        End If
        Dim Done() As Byte, Lowest As Long, WinCoord As Long, TSeqX As String
        ReDim Done(NumCoords)
        Cycle = 0
        Dim TempArray() As String, CycleXX As Long
        ReDim TempArray(NextNo)
        Form1.SSPanel1.Caption = "Rearranging segments"
        Do
            CycleXX = CycleXX + 1
            Form1.SSPanel1.Caption = "Rearranging " & Str(CycleXX) & " segments"
            Lowest = Len(StrainSeq(0)) * NextNo
            
            For x = 1 To NumCoords
                
                If CoOrds(0, x) = TypeSeq And Done(x) = 0 Then
                    If CoOrds(1, x) <= Lowest Then
                        Lowest = CoOrds(1, x)
                        WinCoord = x
                    End If
                    If CoOrds(2, x) <= Lowest Then
                        Lowest = CoOrds(2, x)
                        WinCoord = x
                    End If
                End If
            Next x
            If Lowest > Len(StrainSeq(0)) Then
                TypeSeq = TypeSeq + 1
                If TypeSeq > NextNo Then
                    Cycle = Cycle + 1
                    If Cycle = 2 Then Exit Do
                    TypeSeq = 0
                End If
            Else
            
            
            'do the reordering
                Dim TSeqY As String, TNuc As String, TSLen As Long
                If CoOrds(1, WinCoord) > CoOrds(2, WinCoord) Then 'need to first reverse complement all the sequences between these coordinates
                       'If CoOrds(1, WinCoord) = 804260 Then
                       ' X = X
                       'End If
                       
                       
                       
                       For x = 0 To NextNo
                            TSeqX = Mid$(StrainSeq(x), CoOrds(3, WinCoord), CoOrds(4, WinCoord) - CoOrds(3, WinCoord))
                            TSeqY = TSeqX
                            TSLen = Len(TSeqX)
                            For Y = TSLen To 1 Step -1
                                TNuc = Mid$(TSeqX, Y, 1)
                                If TNuc = "A" Then
                                    Mid$(TSeqY, TSLen - Y + 1, 1) = "T"
                                ElseIf TNuc = "C" Then
                                    Mid$(TSeqY, TSLen - Y + 1, 1) = "G"
                                ElseIf TNuc = "G" Then
                                    Mid$(TSeqY, TSLen - Y + 1, 1) = "C"
                                ElseIf TNuc = "T" Then
                                    Mid$(TSeqY, TSLen - Y + 1, 1) = "A"
                                Else
                                    TNuc = "-"
                                End If
                                
                            Next Y
                            x = x
                            
                            Mid$(StrainSeq(x), CoOrds(3, WinCoord), CoOrds(4, WinCoord) - CoOrds(3, WinCoord)) = TSeqY
                       Next x
                
                
                End If
                
                For Y = 1 To NumCoords
                    If CoOrds(3, Y) = CoOrds(3, WinCoord) Then
                        Done(Y) = 1
                    End If
                Next Y
                'Done(WinCoord) = 1
                For x = 0 To NextNo
                    'XX = Len(TempArray(0))
                    TempArray(x) = TempArray(x) + Mid$(StrainSeq(x), CoOrds(3, WinCoord), CoOrds(4, WinCoord) - CoOrds(3, WinCoord))
                   
                Next x
            End If
            
        Loop
        For x = 0 To NextNo
            StrainSeq(x) = TempArray(x)
        Next x
        
        If MultFNum > 0 Then
            If NextNo > UBound(TempMult, 1) Then
                ReDim TempMult(NextNo)
                ReDim TempMultName(NextNo)
                ReDim MultCoords(MultFNum, NextNo)
                For x = 0 To NextNo
                    Pos = InStr(1, OriginalName(x), "_", vbBinaryCompare)
                    If Pos > 0 Then
                        TempMultName(x) = Left(OriginalName(x), Pos - 1)
                        MultCoords(FN, x) = Right(OriginalName(x), Len(OriginalName(x)) - Pos)
                    Else
                        TempMultName(x) = OriginalName(x)
                    End If
                    
                    TempMult(x) = StrainSeq(x)
                    StrainSeq(x) = ""
                Next x
            ElseIf NextNo = UBound(TempMult, 1) Then
                If FN = 3 Then
                    x = x
                End If
                If UBound(TempMult, 1) <= NextNo Then
                    
                    For x = 0 To NextNo
                        Pos = InStr(1, OriginalName(x), "_", vbBinaryCompare)
                        If Pos > 0 Then
                            Temp = Left(OriginalName(x), Pos - 1)
                        Else
                            Temp = OriginalName(x)
                        End If
                        For Y = 0 To UBound(TempMult, 1)
                            If TempMultName(Y) = Temp Then
                                TempMult(Y) = TempMult(Y) + StrainSeq(x)
                                Exit For
                            End If
                        Next Y
                        x = x
                        If Y = UBound(TempMult, 1) + 1 Then 'there is a new sequence
                            For Y = 0 To NextNo
                                If TempMult(Y) = "" Then
                                    TempMultName(Y) = Temp
                                    If x > 0 Then
                                        TempMult(Y) = String(Len(TempMult(0)) - Len(TempMult(Y)), "-") + TempMult(Y)
                                    End If
                                End If
                            Next Y
                        End If
                        'xxx = Right(OriginalName(X), Len(OriginalName(X)) - Pos)
                        If Pos > 0 Then
                            MultCoords(FN, x) = Right(OriginalName(x), Len(OriginalName(x)) - Pos)
                        End If
                        'TempMult(X) = StrainSeq(X)
                        StrainSeq(x) = ""
                    Next x
                    x = x
                Else
                x = x
                End If
            
            Else
                ReDim StrainSeq(UBound(TempMult, 1))
            End If
            
            If FN < MultFNum And StrainSeq(0) <> "" Then
                For x = 0 To NextNo
                    TempMult(x) = TempMult(x) + "~"
                Next x
            ElseIf FN = MultFNum Then
                NextNo = UBound(TempMult, 1)
                For x = 0 To NextNo
                    OriginalName(x) = TempMultName(x)
                    StrainSeq(x) = TempMult(x)
                Next x
                'XX = Len(StrainSeq(X))
                XX = FN
            End If
        End If
        
    Next FN
    
    StrainSeq(NextNo) = Trim(StrainSeq(NextNo))
    'need to get rid of characters at end of last seq
    x = x
 EEE = Abs(GetTickCount)
 ttt = EEE - SSSx '2321.766'2293,2247,295
 x = x
End Sub
Public Sub WriteNamesViSRD(S1, s2, S3)

    Dim LOSpace As Integer, YPos As Integer, TotLen As Integer, L1 As Integer, L2 As Integer, L3 As Integer, DrawLen As Integer, XPos1 As Integer, XPos2 As Integer, XPos3 As Integer
    Dim OFontSize As Double, Longest As Long, Win As Long, TSeqN As String
    
    'find longest sequence name
    Longest = 0
    For x = 1 To 3
        If Form1.Picture7.TextWidth(WNStr(x)) > Longest Then
        
            Longest = Form1.Picture7.TextWidth(WNStr(x))
            Win = x
        End If
    Next x
    
    If Form1.Picture7.TextWidth(WNStr(Win)) < Form1.Picture7.TextWidth("Sequence X") Then
        TSeqN = "Sequence X"
    Else
        TSeqN = WNStr(Win)
    End If
    
    OFontSize = Form1.Picture7.FontSize
    L1 = Form1.Picture7.TextWidth(TSeqN + " ----- " + TSeqN)
    GExtraTNum = 2
    ReDim GExtraText(GExtraTNum)
    GExtraText(0) = WNStr(1) + " - " + WNStr(3)
    GExtraText(2) = WNStr(1) + " - " + WNStr(2)
    GExtraText(1) = WNStr(2) + " - " + WNStr(3)
    
    DrawLen = Form1.Picture7.ScaleWidth - 40
    TotLen = L1 * 3

    If DrawLen > TotLen Then
        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L1 + LOSpace
    Else

        Do Until TotLen < DrawLen Or Form1.Picture7.FontSize < 4
            Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
            L1 = Form1.Picture7.TextWidth(TSeqN + " ---- " + TSeqN)
            
            TotLen = L1 * 3
        Loop

        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L1 + LOSpace
    End If
    
    XPos1 = XPos1 - 20
    XPos2 = XPos2 - 20
    XPos3 = XPos3 - 20
    
If x = 12345 Then
    YPos = Form1.Picture7.Height * (0.92)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = XPos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print OriginalName(S1) & " - " & OriginalName(s2)
    Form1.Picture7.CurrentX = XPos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print OriginalName(S1) & " - " & OriginalName(S3)
    Form1.Picture7.CurrentX = XPos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print OriginalName(s2) & " - " & OriginalName(S3)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = XPos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print OriginalName(S1) & " - " & OriginalName(s2)
    Form1.Picture7.CurrentX = XPos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print OriginalName(S1) & " - " & OriginalName(S3)
    Form1.Picture7.CurrentX = XPos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print OriginalName(s2) & " - " & OriginalName(S3)
End If
    
     
    YPos = Form1.Picture7.Height * (0.92)
     
    Form1.Picture7.Line (XPos1, YPos)-(XPos1 + 15, YPos + 15), mYellow, BF
    Form1.Picture7.Line (XPos2, YPos)-(XPos2 + 15, YPos + 15), mGreen, BF
    Form1.Picture7.Line (XPos3, YPos)-(XPos3 + 15, YPos + 15), mPurple, BF
    XPos1 = XPos1 + 15
    XPos2 = XPos2 + 15
    XPos3 = XPos3 + 15
    'draw trees
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.Line (XPos1 + Form1.Picture7.TextWidth(TSeqN) + 2, YPos)-(XPos1 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)
    Form1.Picture7.Line (XPos1 + Form1.Picture7.TextWidth(TSeqN) + 2, YPos + 16)-(XPos1 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)
    Form1.Picture7.Line (XPos1 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)-(XPos1 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)
    Form1.Picture7.Line (XPos1 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)-(XPos1 + Form1.Picture7.TextWidth(TSeqN) + 30, YPos)
    Form1.Picture7.Line (XPos1 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)-(XPos1 + Form1.Picture7.TextWidth(TSeqN) + 30, YPos + 16)
    
    Form1.Picture7.Line (XPos2 + Form1.Picture7.TextWidth(TSeqN) + 2, YPos)-(XPos2 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)
    Form1.Picture7.Line (XPos2 + Form1.Picture7.TextWidth(TSeqN) + 2, YPos + 16)-(XPos2 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)
    Form1.Picture7.Line (XPos2 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)-(XPos2 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)
    Form1.Picture7.Line (XPos2 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)-(XPos2 + Form1.Picture7.TextWidth(TSeqN) + 30, YPos)
    Form1.Picture7.Line (XPos2 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)-(XPos2 + Form1.Picture7.TextWidth(TSeqN) + 30, YPos + 16)

    Form1.Picture7.Line (XPos3 + Form1.Picture7.TextWidth(TSeqN) + 2, YPos)-(XPos3 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)
    Form1.Picture7.Line (XPos3 + Form1.Picture7.TextWidth(TSeqN) + 2, YPos + 16)-(XPos3 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)
    Form1.Picture7.Line (XPos3 + Form1.Picture7.TextWidth(TSeqN) + 11, YPos + 8)-(XPos3 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)
    Form1.Picture7.Line (XPos3 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)-(XPos3 + Form1.Picture7.TextWidth(TSeqN) + 30, YPos)
    Form1.Picture7.Line (XPos3 + Form1.Picture7.TextWidth(TSeqN) + 21, YPos + 8)-(XPos3 + Form1.Picture7.TextWidth(TSeqN) + 30, YPos + 16)
    
    
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = XPos1 + Form1.Picture7.TextWidth(TSeqN) - Form1.Picture7.TextWidth(OriginalName(S1))
    Form1.Picture7.CurrentY = YPos - 5
    Form1.Picture7.ForeColor = RGB(0, 255, 0)
    Form1.Picture7.Print OriginalName(S1)
    Form1.Picture7.CurrentX = XPos1 + Form1.Picture7.TextWidth(TSeqN) - Form1.Picture7.TextWidth(OriginalName(s2))
    Form1.Picture7.CurrentY = YPos + 10
    Form1.Picture7.ForeColor = RGB(0, 0, 255)
    Form1.Picture7.Print OriginalName(s2)
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = XPos1 + Form1.Picture7.TextWidth(TSeqN) + 32
    Form1.Picture7.CurrentY = YPos - 5
    Form1.Picture7.ForeColor = RGB(255, 0, 0)
    Form1.Picture7.Print OriginalName(S3)
    Form1.Picture7.CurrentX = XPos1 + Form1.Picture7.TextWidth(TSeqN) + 32
    Form1.Picture7.CurrentY = YPos + 10
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Form1.Picture7.Print "Sequence X"
    
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = XPos2 + Form1.Picture7.TextWidth(TSeqN) - Form1.Picture7.TextWidth(OriginalName(S1))
    Form1.Picture7.CurrentY = YPos - 5
    Form1.Picture7.ForeColor = RGB(0, 255, 0)
    Form1.Picture7.Print OriginalName(S1)
    Form1.Picture7.CurrentX = XPos2 + Form1.Picture7.TextWidth(TSeqN) - Form1.Picture7.TextWidth(OriginalName(S3))
    Form1.Picture7.CurrentY = YPos + 10
    Form1.Picture7.ForeColor = RGB(255, 0, 0)
    Form1.Picture7.Print OriginalName(S3)
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = XPos2 + Form1.Picture7.TextWidth(TSeqN) + 32
    Form1.Picture7.CurrentY = YPos - 5
    Form1.Picture7.ForeColor = RGB(0, 0, 255)
    Form1.Picture7.Print OriginalName(s2)
    Form1.Picture7.CurrentX = XPos2 + Form1.Picture7.TextWidth(TSeqN) + 32
    Form1.Picture7.CurrentY = YPos + 10
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Form1.Picture7.Print "Sequence X"
    
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = XPos3 + Form1.Picture7.TextWidth(TSeqN) - Form1.Picture7.TextWidth(OriginalName(s2))
    Form1.Picture7.CurrentY = YPos - 5
    Form1.Picture7.ForeColor = RGB(0, 0, 255)
    Form1.Picture7.Print OriginalName(s2)
    Form1.Picture7.CurrentX = XPos3 + Form1.Picture7.TextWidth(TSeqN) - Form1.Picture7.TextWidth(OriginalName(S3))
    Form1.Picture7.CurrentY = YPos + 10
    Form1.Picture7.ForeColor = RGB(255, 0, 0)
    Form1.Picture7.Print OriginalName(S3)
    Form1.Picture7.ForeColor = RGB(0, 255, 0)
    Form1.Picture7.CurrentX = XPos3 + Form1.Picture7.TextWidth(TSeqN) + 32
    Form1.Picture7.CurrentY = YPos - 5
    Form1.Picture7.Print OriginalName(S1)
    Form1.Picture7.CurrentX = XPos3 + Form1.Picture7.TextWidth(TSeqN) + 32
    Form1.Picture7.CurrentY = YPos + 10
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Form1.Picture7.Print "Sequence X"
    
    
    
    
    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFontSize
End Sub


Public Sub SeqCols2()
    Dim FF As Long, ST As Long, oDirX As String
    Form1.SSPanel1.Caption = "Sorting alignment columns"
    Form1.Refresh
    ReDim IDCount(Len(StrainSeq(0)) + 200, 4)
    ReDim Identical(Len(StrainSeq(0)) + 200)
    'ReDim Identical2(Len(StrainSeq(0)) + 200)
'    ReDim SeqColRef(Len(StrainSeq(0)) + 200, Nextno)
'    ReDim ColDist(Len(StrainSeq(0)) + 200, Nextno)
    ReDim SiteIdentity(Len(StrainSeq(0)) + 200)

    Dim A As Long, Dummy As Variant, TargetVal As Long, Col As Integer
    Dim x As Long, Y As Long, Z As Long, SY As Long, EY As Long, LSeq
    Dim NumReplace As Long
    Dim Tot As Long, StartVal As Long, PosCounter As Long

    StartVal = Form1.ProgressBar1.Value
    TargetVal = StartVal + 5
    VarSites = 0
    LSeq = Len(StrainSeq(0))
    Dummy = GetSiteHomol(LSeq + 1, NextNo, SeqNum(0, 0), IDCount(0, 0), SiteIdentity(0))
    NumReplace = 0
    
  
    
  ' Z = 0
  '  For X = 0 To Nextno
  '      If SeqNum(41, X) <> 66 Then
  '          Z = Z + 1
  '      End If
  '
  '
  '  Next X
   x = x
    ReDim IdenticalR(LSeq), IdenticalF(LSeq)
    A = 0
    
    
    TotGapCharCount = 0
    SS = Abs(GetTickCount)
    'this could be ported to c++ to decrease load times
    '@
    Dim WinID As Long, WinNT As Long, CDBound As Long, NucFrac As Single, CurNuc As Long, UBSN As Long, UBCD As Long, UBSCR As Long, OverShoot As Long, ID0 As Long, ID1 As Long, ID2 As Long, ID3 As Long, ID4 As Long
    
    OverShoot = NextNo + 1
    PosCounter = -1
    CDBound = 100000
    ReDim ColDist2(CDBound), ColPos2(Len(StrainSeq(0)) + 1), SeqColRef2(Len(StrainSeq(0)) + 1)
    
    ReDim MostCommonnt(LSeq + 5)
    For x = 1 To LSeq
        MostCommonnt(x) = SeqNum(x, 0)
    Next x
    UBSN = UBound(SeqNum, 1)
    For x = 1 To LSeq
        
        PosCounter = PosCounter + 1
        If PosCounter + NextNo * 2 > CDBound Then
            CDBound = CDBound + 100000
            ReDim Preserve ColDist2(CDBound)
        End If
        ColPos2(x) = PosCounter
        'XX = StrainSeq(0)
        'If X = 41 Then
        '    X = X
        'End If
        'If X = Recompress(153548) Then
        '    X = X
        'End If
        IdenticalF(x) = A
        ID0 = IDCount(x, 0)
        ID1 = IDCount(x, 1)
        ID2 = IDCount(x, 2)
        ID3 = IDCount(x, 3)
        'ID0 = IDCount(X, 0)
        
        If ID0 = OverShoot Or ID1 = OverShoot Or ID2 = OverShoot Or ID3 = OverShoot Then
            Identical(x) = 1
            
        Else
            ID4 = IDCount(x, 4)
            If ID0 < 2 And ID1 < 2 And ID2 < 2 Then
            
            ElseIf ID0 < 2 And ID1 < 2 And ID3 < 2 Then
                'only counts sites where there is variation in actual nucleotides
                
            ElseIf ID0 < 2 And ID2 < 2 And ID3 < 2 Then
                'only counts sites where there is variation in actual nucleotides
                
            ElseIf ID1 < 2 And ID2 < 2 And ID3 < 2 Then
                'only counts sites where there is variation in actual nucleotides
                
           
            Else
                A = A + 1
                IdenticalR(A) = x
                IdenticalF(x) = A
            End If
            VarSites = VarSites + 1
            
            'Check for strange characters in this column
            'IDCount(X, 4) = Nextno + 1 - IDCount(X, 0) - IDCount(X, 1) - IDCount(X, 2) - IDCount(X, 3)
            If ID4 > 0 Then
                EY = ID4 - 1

                For Z = 0 To EY
                    'TString = Mid$(StrainSeq(Z), X, 1)
                    CurNuc = SeqNum(x, Z)
                    If CurNuc <> 66 And CurNuc <> 68 And CurNuc <> 72 And CurNuc <> 85 And CurNuc <> 46 Then
                        Mid$(StrainSeq(Z), x, 1) = "-"
                        SeqNum(x, Z) = 46
                        NumReplace = NumReplace + 1
                        TotGapCharCount = TotGapCharCount + 1
                    End If

                Next 'Z

            End If
            Col = 0
            WinID = -1
            
            If ID0 >= ID1 And ID0 >= ID2 And ID0 >= ID3 Then
                WinID = ID0
                WinNT = 66
            ElseIf ID1 >= ID0 And ID1 >= ID2 And ID1 >= ID3 Then
                WinID = ID1
                WinNT = 68
            ElseIf ID2 >= ID0 And ID2 >= ID1 And ID2 >= ID3 Then
                WinID = ID2
                WinNT = 72
            ElseIf ID3 >= ID0 And ID3 >= ID1 And ID3 >= ID2 Then
                WinID = ID3
                WinNT = 85
            End If
            MostCommonnt(x) = WinNT
            
            If WinID > -1 Then
                
                NucFrac = WinID / OverShoot
                Col = SeqColCatNum - Int(NucFrac * SeqColCatNum)
'                If NucFrac >= 0.9 Then
'                    Col = 1
'                ElseIf NucFrac >= 0.8 Then
'                    Col = 2
'                ElseIf NucFrac >= 0.7 Then
'                    Col = 3
'                ElseIf NucFrac >= 0.6 Then
'                    Col = 4
'                ElseIf NucFrac >= 0.5 Then
'                    Col = 5
'                ElseIf NucFrac >= 0.4 Then
'                    Col = 6
'                ElseIf NucFrac >= 0.3 Then
'                    Col = 7
'                ElseIf NucFrac >= 0.2 Then
'                    Col = 8
'                ElseIf NucFrac >= 0.1 Then
'                    Col = 9
'                Else
'                    Col = 10
'                End If
'                If Col2 <> Col Then
'                    X = X
'                End If
                SeqColRef2(x) = Col
                ColPos2(x) = PosCounter
                
                If x = x Then
                    
                    PosCounter = FillColDist2(PosCounter, x, WinNT, NextNo, UBSN, SeqNum(0, 0), ColDist2(0))
                    
                Else
                
                    For Y = 0 To NextNo
    
                        If SeqNum(x, Y) = WinNT Then
                            
                            ColDist2(PosCounter) = Y
                            If Y < NextNo Then
                                
                                Z = Y + 1
    
                                Do
    
                                    If SeqNum(x, Z) = WinNT Then
                                        
                                        Z = Z + 1
    
                                        If Z > NextNo Then
                                            PosCounter = PosCounter + 1
                                            ColDist2(PosCounter) = Z - 1
                                            Y = Z
                                            Exit Do
                                        End If
    
                                    Else
                                        PosCounter = PosCounter + 1
                                        ColDist2(PosCounter) = Z - 1
                                        Y = Z
                                        PosCounter = PosCounter + 1
                                        
                                        Exit Do
                                    End If
    
                                Loop
    
                            Else
                                PosCounter = PosCounter + 1
                                
                                
                                ColDist2(PosCounter) = Y
                            End If
    
                        End If
                    Next 'Y
                End If
            End If

        End If
        ET = Abs(GetTickCount)
        If CLine = "" Or CLine = " " Then
        If Abs(ET - ST) > 500 Then
            ST = ET
        'If X / Int(LSeq / 10) = Int(X / Int(LSeq / 10)) Then
            If StartVal + (TargetVal - StartVal) * (x / LSeq) <= 100 Then
                Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * (x / LSeq)
            Else
                Form1.ProgressBar1.Value = 100
            End If
            Call UpdateF2Prog
        'End If
        End If
        End If
    Next 'X
    PosCounter = PosCounter + 1
    ReDim Preserve ColDist2(PosCounter + 1000)
    
    ColPos2(LSeq + 1) = PosCounter
    
    
    'For X = 0 To Len(StrainSeq(0))
    '    If Identical(X) = 0 Then Identical2(X) = 1
    'Next X
    If (Len(StrainSeq(0)) + 3) * (NextNo + 1) * 4 > 10000000 Or x = x Then
        ColDistInFile = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        UBCD2 = UBound(ColDist2, 1)
        Open "RDP5CDFile" + UFTag For Binary As #FF
        '@
        Put #FF, , ColDist2()
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
        ReDim ColDist2(0)
    Else
        ColDistInFile = 0
    End If
A = A
EE = Abs(GetTickCount)
    TT = EE - SS '2.828,2.297,2.187,2.172,2.109,2.641
    '0.844
    '3.766
    '2.375
    '0.954
    x = x
End Sub
Public Sub SeqCols()
'    Dim FF As Long, ST As Long, oDirX As String
'    Form1.SSPanel1.Caption = "Sorting alignment columns"
'    Form1.Refresh
'    ReDim IDCount(Len(StrainSeq(0)) + 200, 4)
'    ReDim Identical(Len(StrainSeq(0)) + 200)
'    'ReDim Identical2(Len(StrainSeq(0)) + 200)
'    ReDim SeqColRef(Len(StrainSeq(0)) + 200, Nextno)
'    ReDim ColDist(Len(StrainSeq(0)) + 200, Nextno)
'    ReDim SiteIdentity(Len(StrainSeq(0)) + 200)
'
'    Dim A As Long, Dummy As Variant, TargetVal As Long, Col As Integer
'    Dim X As Long, Y As Long, Z As Long, SY As Long, EY As Long, LSeq
'    Dim NumReplace As Long
'    Dim Tot As Long, StartVal As Long
'
'    StartVal = Form1.ProgressBar1.Value
'    TargetVal = StartVal + 5
'    Varsites = 0
'    LSeq = Len(StrainSeq(0))
'    Dummy = GetSiteHomol(LSeq + 1, Nextno, SeqNum(0, 0), IDCount(0, 0), SiteIdentity(0))
'    NumReplace = 0
'
'
'
'  ' Z = 0
'  '  For X = 0 To Nextno
'  '      If SeqNum(41, X) <> 66 Then
'  '          Z = Z + 1
'  '      End If
'  '
'  '
'  '  Next X
'   X = X
'    ReDim IdenticalR(LSeq), IdenticalF(LSeq)
'    A = 0
'
'
'    TotGapCharCount = 0
'    SS = abs(gettickcount)
'    'this could be ported to c++ to decrease load times
'    '@
'    Dim NucFrac As Single, CurNuc As Long, UBSN As Long, UBCD As Long, UBSCR As Long, OverShoot As Long, ID0 As Long, ID1 As Long, ID2 As Long, ID3 As Long, ID4 As Long
'    UBSN = UBound(SeqNum, 1)
'    UBCD = UBound(ColDist, 1)
'    UBSCR = UBound(SeqColRef, 1)
'    OverShoot = Nextno + 1
'    For X = 1 To LSeq
'        'XX = StrainSeq(0)
'        'If X = 41 Then
'        '    X = X
'        'End If
'        'If X = Recompress(153548) Then
'        '    X = X
'        'End If
'        IdenticalF(X) = A
'        ID0 = IDCount(X, 0)
'        ID1 = IDCount(X, 1)
'        ID2 = IDCount(X, 2)
'        ID3 = IDCount(X, 3)
'        'ID0 = IDCount(X, 0)
'
'        If ID0 = OverShoot Or ID1 = OverShoot Or ID2 = OverShoot Or ID3 = OverShoot Then
'            Identical(X) = 1
'
'        Else
'            ID4 = IDCount(X, 4)
'            If ID0 < 2 And ID1 < 2 And ID2 < 2 Then
'
'            ElseIf ID0 < 2 And ID1 < 2 And ID3 < 2 Then
'                'only counts sites where there is variation in actual nucleotides
'
'            ElseIf ID0 < 2 And ID2 < 2 And ID3 < 2 Then
'                'only counts sites where there is variation in actual nucleotides
'
'            ElseIf ID1 < 2 And ID2 < 2 And ID3 < 2 Then
'                'only counts sites where there is variation in actual nucleotides
'
'
'            Else
'                A = A + 1
'                IdenticalR(A) = X
'                IdenticalF(X) = A
'            End If
'            Varsites = Varsites + 1
'
'            'Check for strange characters in this column
'            'IDCount(X, 4) = Nextno + 1 - IDCount(X, 0) - IDCount(X, 1) - IDCount(X, 2) - IDCount(X, 3)
'            If ID4 > 0 Then
'                EY = ID4 - 1
'
'                For Z = 0 To EY
'                    'TString = Mid$(StrainSeq(Z), X, 1)
'                    CurNuc = SeqNum(X, Z)
'                    If CurNuc <> 66 And CurNuc <> 68 And CurNuc <> 72 And CurNuc <> 85 And CurNuc <> 46 Then
'                        Mid$(StrainSeq(Z), X, 1) = "-"
'                        SeqNum(X, Z) = 46
'                        NumReplace = NumReplace + 1
'                        TotGapCharCount = TotGapCharCount + 1
'                    End If
'
'                Next 'Z
'
'            End If
'            Col = 0
'            If ID0 >= ID1 And ID0 >= ID2 And ID0 >= ID3 Then
'                NucFrac = ID0 / OverShoot
'                If NucFrac > 0.75 Then
'                    Col = 1
'                ElseIf NucFrac > 0.5 Then
'                    Col = 2
'                ElseIf NucFrac >= 0.25 Then
'                    Col = 3
'                Else
'                    Col = 4
'                End If
''                If X = X Then
'                    Dummy = FillColDist(Col, X, 66, Nextno, UBSN, UBCD, UBSCR, SeqNum(0, 0), ColDist(0, 0), SeqColRef(0, 0))
''                Else
''                    Tot = 0
''
''                    For Y = 0 To Nextno
''
''                        If SeqNum(X, Y) = 66 Then
''                            SeqColRef(X, Y) = Col
''                            Tot = 1
''
''                            If Y < Nextno Then
''                                Z = Y + 1
''
''                                Do
''
''                                    If SeqNum(X, Z) = 66 Then
''                                        Tot = Tot + 1
''                                        Z = Z + 1
''
''                                        If Z > Nextno Then
''                                            ColDist(X, Y) = Tot
''                                            Y = Z
''                                            Exit Do
''                                        End If
''
''                                    Else
''                                        ColDist(X, Y) = Tot
''                                        Y = Z
''                                        Exit Do
''                                    End If
''
''                                Loop
''
''                            Else
''                                ColDist(X, Y) = 1
''                            End If
''
''                        End If
''                    Next 'Y
''                End If
'            ElseIf ID1 >= ID0 And ID1 >= ID2 And ID1 >= ID3 Then
'                NucFrac = ID1 / OverShoot
'                If NucFrac > 0.75 Then
'                    Col = 1
'                ElseIf NucFrac > 0.5 Then
'                    Col = 2
'                ElseIf NucFrac >= 0.25 Then
'                    Col = 3
'                Else
'                    Col = 4
'                End If
''                If X = X Then
'                    Dummy = FillColDist(Col, X, 68, Nextno, UBSN, UBCD, UBSCR, SeqNum(0, 0), ColDist(0, 0), SeqColRef(0, 0))
''                Else
''                    For Y = 0 To Nextno
''
''                        If SeqNum(X, Y) = 68 Then
''                            SeqColRef(X, Y) = Col
''                            Tot = 1
''
''                            If Y < Nextno Then
''                                Z = Y + 1
''
''                                Do
''
''                                    If SeqNum(X, Z) = 68 Then
''                                        Tot = Tot + 1
''                                        Z = Z + 1
''
''                                        If Z > Nextno Then
''                                            ColDist(X, Y) = Tot
''                                            Y = Z
''                                            Exit Do
''                                        End If
''
''                                    Else
''                                        ColDist(X, Y) = Tot
''                                        Y = Z
''                                        Exit Do
''                                    End If
''
''                                Loop
''
''                            Else
''                                ColDist(X, Y) = 1
''                            End If
''
''                        End If
''
''                    Next 'Y
''                End If
'            ElseIf ID2 >= ID0 And ID2 >= ID1 And ID2 >= ID3 Then
'                NucFrac = ID2 / OverShoot
'                If NucFrac > 0.75 Then
'                    Col = 1
'                ElseIf NucFrac > 0.5 Then
'                    Col = 2
'                ElseIf NucFrac >= 0.25 Then
'                    Col = 3
'                Else
'                    Col = 4
'                End If
'
''                If X = X Then
'                    Dummy = FillColDist(Col, X, 72, Nextno, UBSN, UBCD, UBSCR, SeqNum(0, 0), ColDist(0, 0), SeqColRef(0, 0))
''                Else
''
''                    For Y = 0 To Nextno
''
''                        If SeqNum(X, Y) = 72 Then
''                            SeqColRef(X, Y) = Col
''                            Tot = 1
''
''                            If Y < Nextno Then
''                                Z = Y + 1
''
''                                Do
''
''                                    If SeqNum(X, Z) = 72 Then
''                                        Tot = Tot + 1
''                                        Z = Z + 1
''
''                                        If Z > Nextno Then
''                                            ColDist(X, Y) = Tot
''                                            Y = Z
''                                            Exit Do
''                                        End If
''
''                                    Else
''                                        ColDist(X, Y) = Tot
''                                        Y = Z
''                                        Exit Do
''                                    End If
''
''                                Loop
''
''                            Else
''                                ColDist(X, Y) = 1
''                            End If
''
''                        End If
''
''                    Next 'Y
''                End If
'            ElseIf ID3 >= ID0 And ID3 >= ID1 And ID3 >= ID2 Then
'                NucFrac = ID3 / OverShoot
'                If NucFrac > 0.75 Then
'                    Col = 1
'                ElseIf NucFrac > 0.5 Then
'                    Col = 2
'                ElseIf NucFrac >= 0.25 Then
'                    Col = 3
'                Else
'                    Col = 4
'                End If
''                If X = X Then
'                    Dummy = FillColDist(Col, X, 85, Nextno, UBSN, UBCD, UBSCR, SeqNum(0, 0), ColDist(0, 0), SeqColRef(0, 0))
''                Else
''                    SeqColRef2(X) = Col
''                    For Y = 0 To Nextno
'''
''                        If SeqNum(X, Y) = 85 Then
''                            SeqColRef(X, Y) = Col
''                            Tot = 1
''
''                            If Y < Nextno Then
''                                Z = Y + 1
''
''                                Do
''
''                                    If SeqNum(X, Z) = 85 Then
''                                        Tot = Tot + 1
''                                        Z = Z + 1
''
''                                        If Z > Nextno Then
''                                            ColDist(X, Y) = Tot
''                                            Y = Z
''                                            Exit Do
''                                        End If
''
''                                    Else
''                                        ColDist(X, Y) = Tot
''                                        Y = Z
''                                        Exit Do
''                                    End If
''
''                                Loop
''
''                            Else
''                                ColDist(X, Y) = 1
''                            End If
''
''                        End If
''
''                    Next 'Y
''                End If
''                Else
''                    For Y = 0 To Nextno
''
''                        If SeqNum(X, Y) = 85 Then
''                            SeqColRef(X, Y) = Col
''                            Tot = 1
''
''                            If Y < Nextno Then
''                                Z = Y + 1
''
''                                Do
''
''                                    If SeqNum(X, Z) = 85 Then
''                                        Tot = Tot + 1
''                                        Z = Z + 1
''
''                                        If Z > Nextno Then
''                                            ColDist(X, Y) = Tot
''                                            Y = Z
''                                            Exit Do
''                                        End If
''
''                                    Else
''                                        ColDist(X, Y) = Tot
''                                        Y = Z
''                                        Exit Do
''                                    End If
''
''                                Loop
''
''                            Else
''                                ColDist(X, Y) = 1
''                            End If
''
''                        End If
''
''                    Next 'Y
''                End If
'            End If
'
'        End If
'        ET = abs(gettickcount)
'        If Abs(ET - ST) > 500 Then
'            ST = ET
'        'If X / Int(LSeq / 10) = Int(X / Int(LSeq / 10)) Then
'            Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * (X / LSeq)
'        'End If
'        End If
'    Next 'X
'
'    EE = abs(gettickcount)
'    TT = EE - SS '2.828,2.297,2.187,2.172,2.109,2.641
'    '0.844
'    X = X
'
'    'For X = 0 To Len(StrainSeq(0))
'    '    If Identical(X) = 0 Then Identical2(X) = 1
'    'Next X
'    If (Len(StrainSeq(0)) + 3) * (Nextno + 1) * 4 > 10000000 Then
'        ColDistInFile = 1
'        oDirX = CurDir
'        ChDrive App.Path
'        ChDir App.Path
'        FF = FreeFile
'        Open "RDP5CDFile" + UFTag For Binary As #FF
'        '@
'        Put #FF, , ColDist
'        Close #FF
'        Open "RDP5SCRFile" + UFTag For Binary As #FF
'        Put #FF, , SeqColRef
'        Close #FF
'        ChDrive oDirX
'        ChDir oDirX
'        Erase ColDist
'        Erase SeqColRef
'    Else
'        ColDistInFile = 0
'    End If
'A = A

End Sub

Public Sub RecombMap()

    Dim lP As Double, PVFlag As Byte
    ReDim GPVTFont(5, 100), GPVText(100)
    
    Call UnModNextno 'need to do this to get proper distances back
    GPVTNum = -1
    PVFlag = 1 'do pval on y axis
    'pvflag = 0 'do par dist on y axis
    
    Dim ENumb As Long
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    'If MCFlag = 1 Or MCFlag = 2 Then
        lP = -Log10(LowestProb)
    'ElseIf MCFlag = 0 Then
    '    LP = -Log10(LowestProb / MCCorrection)
    'End If
    MaxVGC = 1.1
    PPMax = 1
    For x = 1 To ENumb
        If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept < 2 Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber
            Else
                SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
            End If
            
            For Z = 0 To AddNum - 1
                If Confirm(SEN, Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            
            If CNum > ConsensusProg Then
                If PVFlag = 1 Then
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability < PPMax And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 Then
                        PPMax = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability
                    Else
                    
                    End If
                End If
            End If
        End If
    Next x
    
    PPMax = -Log10(PPMax)
    MinPVal = PPMax
    lP = 0
    DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(PPMax), CSng(lP), 0, "-Log(P-Val)"
    
    
    Dim DistCol As Long
                   
                
    CurPPos = 0
    Dim PV As Double
    LOffset = 30
    WFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    
    HFactor = PicHeight - 35 '(Form1.Picture7.Height - 104)
    TOffset = 20
    Dim PntAPI As POINTAPI
    
    
    Dim ProbCol As Long
    For Z = 1 To ENumb
        
        x = BestEvent(Z, 0)
        Y = BestEvent(Z, 1)
        GoOn = 1
        
        If (x > 0 Or Y > 0) And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Accept < 2 Then 'Or XOverList(X, Y).OutsideFlag = 0 And Distance(X, XOverList(X, Y).MinorP) < Distance(X, XOverList(X, Y).MajorP) Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XoverList(x, Y).Eventnumber
            Else
                SEN = SuperEventList(XoverList(x, Y).Eventnumber)
            End If
            
            For A = 0 To AddNum - 1
                If Confirm(SEN, A) > 0 Then
                    CNum = CNum + 1
                End If
            Next A
            
            If CNum > ConsensusProg Then
                
                PV = -Log10(XoverList(x, Y).Probability)
                
                If PV > 0 Then
                    If PV < PV Then PV = PV
                    If lP > PV Then lP = PV
                End If
            End If
        End If
    Next Z
    
    
    
    'Add data to standard drawing and copying arrays etc
    Count = 0
    GPrintNum = SEventNumber * 2 'three line types
    ReDim GPrint(GPrintNum, ENumb), GPrintCol(GPrintNum), GPrintPos(GPrintNum, 1, ENumb)
    GPrintLen = Count - 1 'how many points to plot
    ReDim GCritval(10)
    GCritval(0) = 0
    GLegend = "-Log[P-Val]"
    GPrintType = 1 'a region plot
    GPrintMin(0) = 0
    GPrintMin(1) = PPMax
    GBlockNum = -1
    GExtraTNum = -1
    ReDim GVarPos(0, Len(StrainSeq(0)))
    GPrintLen = Len(StrainSeq(0))
    Dim EX As Long, BPX As Long
    
    
    GDistM(0) = 1000000
    GPValM(0) = 1000000
    GDistM(1) = 0
    GPValM(1) = 0
    
    
    
    
    For Z = 1 To ENumb
        
        x = BestEvent(Z, 0)
        Y = BestEvent(Z, 1)
        GoOn = 1
        
        If (x > 0 Or Y > 0) And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Accept < 2 Then 'Or XOverList(X, Y).OutsideFlag = 0 And Distance(X, XOverList(X, Y).MinorP) < Distance(X, XOverList(X, Y).MajorP) Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XoverList(x, Y).Eventnumber
            Else
                SEN = SuperEventList(XoverList(x, Y).Eventnumber)
            End If
            
            For A = 0 To AddNum - 1
                If Confirm(SEN, A) > 0 Then
                    If Confirm(SEN, A) = 1 Then
                        PValCon = 10 ^ -(ConfirmP(SEN, A))
                        If PValCon < LowestProb Then
                            CNum = CNum + 1
                        End If
                    Else
                        CNum = CNum + 1
                    End If
                End If
            Next A
            
            If CNum > ConsensusProg Then
                BE = XoverList(x, Y).Beginning
                EN = XoverList(x, Y).Ending
                PV = -Log10(XoverList(x, Y).Probability)
                
                If PV > lP Then
                    If PV < GPValM(0) Then GPValM(0) = PV
                    If PV > GPValM(1) Then GPValM(1) = PV
                    EX = EX + 1
                    If XoverList(x, Y).OutsideFlag = 0 Then
                        MDist = Distance(XoverList(x, Y).MinorP, XoverList(x, Y).MajorP)
                    Else
                        If Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter) And Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MajorP, XoverList(x, Y).MinorP) Then
                            MDist = Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter)
                        ElseIf Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter) And Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MajorP, XoverList(x, Y).MinorP) Then
                            MDist = Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter)
                        Else
                            MDist = Distance(XoverList(x, Y).MinorP, XoverList(x, Y).MajorP)
                        End If
                    End If
                    
                    If MDist < GDistM(0) Then GDistM(0) = MDist
                    If MDist > GDistM(1) Then GDistM(1) = MDist
                    x = x
                    
                End If
            End If
        End If
                    
    Next Z
    
    EX = -1
    BPX = -1
    lP = 0
    
    Dim GPV As Double
    
    Dim EXNum() As Long
    ReDim EXNum(ENumb)
    For x = 0 To ENumb
        EXNum(x) = -1
    Next x
    
    Dim BPL() As Byte
    ReDim BPL(Len(StrainSeq(0)))
    
    For Z = 1 To ENumb
        
        x = BestEvent(Z, 0)
        Y = BestEvent(Z, 1)
        GoOn = 1
        
        If (x > 0 Or Y > 0) And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Accept < 2 Then 'Or XOverList(X, Y).OutsideFlag = 0 And Distance(X, XOverList(X, Y).MinorP) < Distance(X, XOverList(X, Y).MajorP) Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XoverList(x, Y).Eventnumber
            Else
                SEN = SuperEventList(XoverList(x, Y).Eventnumber)
            End If
            
            For A = 0 To AddNum - 1
                If Confirm(SEN, A) > 0 Then
                    If Confirm(SEN, A) = 1 Then
                        PValCon = 10 ^ -(ConfirmP(SEN, A))
                        If PValCon < LowestProb Then
                            CNum = CNum + 1
                        End If
                    Else
                        CNum = CNum + 1
                    End If
                End If
            Next A
            
            If CNum > ConsensusProg Then
                BE = XoverList(x, Y).Beginning
                EN = XoverList(x, Y).Ending
                PV = -Log10(XoverList(x, Y).Probability)
                If PV > lP Then
                    EX = EX + 1
                    If XoverList(x, Y).OutsideFlag = 0 Then
                        MDist = Distance(XoverList(x, Y).MinorP, XoverList(x, Y).MajorP)
                    Else
                        If Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter) And Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MajorP, XoverList(x, Y).MinorP) Then
                            MDist = Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter)
                        ElseIf Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MajorP, XoverList(x, Y).Daughter) And Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter) <= Distance(XoverList(x, Y).MajorP, XoverList(x, Y).MinorP) Then
                            MDist = Distance(XoverList(x, Y).MinorP, XoverList(x, Y).Daughter)
                        Else
                            MDist = Distance(XoverList(x, Y).MinorP, XoverList(x, Y).MajorP)
                        End If
                    End If
                    If PVFlag = 1 Then
                        'XX = UBound(HeatMap, 1)
                        If GDistM(1) <> GDistM(0) Then
                            'GDistM(0)=0.7599,GDistM(1)=0.959
                            ProbCol = HeatMap(0, CLng(CLng(((MDist - GDistM(0)) / (GDistM(1) - GDistM(0))) * 51) * 20))
                            'ProbCol = HeatMap(0, Int(((MDist - GDistM(0)) / (GDistM(1) - GDistM(0))) * 1020))
                        Else
                            ProbCol = 0
                        End If
                        'Call DistColour(DistCol)
                        
                        GPV = PV
                        'GPrintCol(EX) = DistCol
                    Else
                        ProbCol = HeatMap(0, CLng(CLng((PV - GPValM(0)) / (GPValM(1) - GPValM(0)) * 51) * 20))
                        'Call ProbColour(ProbCol)
                        
                         GPV = MDist
                        
                    End If
                    Dim EXX As Long
                    Form1.Picture7.ForeColor = ProbCol
                    SV = EX - 1
                    'check to see if there is a colour match with a previous event
                    For A = 0 To SV
                        If GPrintCol(A) = ProbCol Then '16740352
                            EXX = A
                            EX = EX - 1
                            Exit For
                        End If
                    Next A
                    If A > SV Then
                         EXX = EX
                    End If
                    EXNum(EXX) = EXNum(EXX) + 1
                    GPrint(EXX, EXNum(EXX)) = GPV
                    GPrintCol(EXX) = ProbCol
                    
                    
                    MhDC = Form1.Picture7.hdc
                    'Standard format
                    
                    BPL(BE) = 1
                    BPL(EN) = 1
                    If BE < EN Then
'                        MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
'                        LineTo MhDC, LOffset + EN * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
'                        LineTo MhDC, LOffset + EN * WFactor, TOffset + HFactor
'                        LineTo MhDC, LOffset + BE * WFactor, TOffset + HFactor
'                        LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                       
                        GPrintPos(EXX, 0, EXNum(EXX)) = BE
                        GPrintPos(EXX, 1, EXNum(EXX)) = EN
                        
                    Else
'                        MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
'                        LineTo MhDC, LOffset + EN * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
'                        LineTo MhDC, LOffset + EN * WFactor, TOffset + HFactor
'                        LineTo MhDC, LOffset + 1 * WFactor, TOffset + HFactor
'                        LineTo MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                                        
                        GPrintPos(EXX, 0, EXNum(EXX)) = BE
                        GPrintPos(EXX, 1, EXNum(EXX)) = Len(StrainSeq(0))
                                        
'                        MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor, PntAPI
'                        LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
'                        LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + HFactor
'                        LineTo MhDC, LOffset + BE * WFactor, TOffset + HFactor
'                        LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (PV - LP) / (PPMax - LP)) * HFactor
                         EXNum(EXX) = EXNum(EXX) + 1
                        GPrint(EXX, EXNum(EXX)) = GPV
                        GPrintCol(EXX) = ProbCol
                        GPrintPos(EXX, 0, EXNum(EXX)) = 1
                        GPrintPos(EXX, 1, EXNum(EXX)) = EN
                    End If
                End If
            End If
        End If
                    
    Next Z
    BPX = -1
    For x = 0 To Len(StrainSeq(0))
        If BPL(x) = 1 Then
            BPX = BPX + 1
            GVarPos(0, BPX) = x
        End If
    Next x
   GPrintNum = EX
    
    
    
    Call RedrawPlotAA(1)
    
    If BPX >= 0 Then
    ReDim Preserve GVarPos(0, BPX)
    End If
    Form1.Picture7.Refresh
End Sub
Public Sub RecombMapII()
    Dim RecMap() As Long, SEN As Long
    ReDim RecMap(Len(StrainSeq(0)))
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    b = 0
    C = 0
    NextNo = NextNo
    For x = 1 To ENumb
        
        
        If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept < 2 Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber
            Else
                SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
            End If
            
            For Z = 0 To AddNum - 1
                If Confirm(SEN, Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            
            If CNum > ConsensusProg Then
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                If ST < EN Then
                    For Y = ST To EN
                        RecMap(Y) = RecMap(Y) + 1
                    Next Y
                Else
                    For Y = ST To Len(StrainSeq(0))
                        RecMap(Y) = RecMap(Y) + 1
                    Next Y
                    For Y = 1 To EN
                        RecMap(Y) = RecMap(Y) + 1
                    Next Y
                End If
                C = C + 1
            End If
        ElseIf XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability = 0 Then
            b = b + 1
        End If
    
        
    Next x
    PPMax = 0
    For x = 1 To Len(StrainSeq(0))
        If RecMap(x) > PPMax Then PPMax = RecMap(x)
    Next x
    
    MinPVal = PPMax
    MCMinChiP = PPMax
    DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(PPMax), 0, 0, "Number of events"
    
    
    Dim PV As Double
    LOffset = 30
    WFactor = ((Form1.Picture7.Width - 40) / Len(StrainSeq(0)))
    HFactor = (Form1.Picture7.Height - 75)
    TOffset = 20
    Dim PntAPI As POINTAPI
    Form1.Picture7.ForeColor = 0
    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(Len(StrainSeq(0)))
    For Z = 1 To Len(StrainSeq(0))
        MCPrintData(Z) = RecMap(Z)
        MCPrintPos(Z) = Z
    Next Z
    MhDC = Form1.Picture7.hdc
    
    MoveToEx MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RecMap(1)) / (PPMax)) * HFactor, PntAPI
    'Exit Sub
    For Z = 2 To Len(StrainSeq(0))
    
        MhDC = Form1.Picture7.hdc
        LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - RecMap(Z) / PPMax) * HFactor
    Next Z
    Form1.Picture7.Refresh
End Sub
Public Sub RecombMapIII()
    
    ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    
    Call UnModNextno
    Call UnModSeqNum(0)
    Dim TargetS(3)
    TargetS(0) = 0.01
    TargetS(1) = 0.05
    TargetS(2) = 0.95
    TargetS(3) = 0.99
    
    If Form1.Combo1.ListIndex = 18 Then
        Call RecombMapIIIc
        Exit Sub
    End If
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double, Win As Long
    
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Dim PermutationX As Long
    
    PermutationX = MatPermNo
    If PermutationX > 10000 Then PermutationX = 10000
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
    
    Dim BPV() As Double
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
    
    For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                    If XoverList(x, Y).Eventnumber <= Eventnumber Then
                        If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                            BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                        End If
                    End If
                End If
            Next Y
    Next x
    Dim PValCon As Double
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
    
    
    Dim AccX As Byte, NAccX As Byte
    AccX = 0
    NAccX = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            
            If XoverList(x, Y).Accept = 1 Then
                AccX = 1
                If NAccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            ElseIf XoverList(x, Y).Accept = 0 Then
                NAccX = 1
                If AccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            End If
            
        Next Y
        
    Next x
    
    
    If AccX = 1 And NAccX = 1 Then
        If CLine = "" Or CLine = " " Then
            If ReassortmentFlag = 1 Then
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination/reassortment events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a breakpoint distribution plot")
            Else
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a breakpoint distribution plot")
            End If
        Else
            Response = 7 'No
        End If
        If Response = 6 Then 'yes
            UseAll = 0
        Else
            UseAll = 1
        End If
    Else
        UseAll = 1
    End If
    
    
    Dim OnlyReassortmentFlag As Byte '0 = consider both recombination and reassortment, 1 = only reassortment, 2 = only recombination
    
    If ReassortmentFlag > 0 Then
        Dim Segbound() As Byte
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                tBP = RBPPos(x)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
        
        Dim ReassortmentNo As Long, RecombinationNo As Long
        
        For x = 0 To SEventNumber
            
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or UseAll = 1 Then
                If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
                    ReassortmentNo = ReassortmentNo + 1
                Else
                    RecombinationNo = RecombinationNo + 1
                End If
                If RecombinationNo > 0 And ReassortmentNo > 0 Then
                    Exit For
                End If
            End If
        Next x
        If RecombinationNo > 0 And ReassortmentNo > 0 Then
            Response = MsgBox("Both reassortment and recombination events have been detected. Would you like to only consider the recombination events? It would make sense to ignor the reassortment events because their associated 'breakpoints' are not real.", vbYesNo, "Construct a breakpoint distribution plot")
            If Response = 7 Then
                Response = MsgBox("OK. So would you like to only consider the reassortment events then? Reassortment events don't really involve breakpoints so this analysis would be kind've meaningless. If you press 'no' then both the recombination and reassortment events will be considered (which will be another meaningless type of analysis).", vbYesNo, "Construct a breakpoint distribution plot")
                If Response = 7 Then
                    OnlyReassortmentFlag = 0
                Else
                    OnlyReassortmentFlag = 1
                End If
            Else
                OnlyReassortmentFlag = 2
            End If
        Else
            OnlyReassortmentFlag = 0
        End If
    Else
        OnlyReassortmentFlag = 0
    End If
    
    
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).Eventnumber <= Eventnumber Then
                Enu = SuperEventList(XoverList(x, Y).Eventnumber)
                If Excl(Enu) = 0 Then
                    'If Enu = 4 Then
                    '    X = X
                    'End If
                    'If Enu = 23 Then
                    '    X = X
                    'End If
                    NC = 0
                    For Z = 0 To AddNum - 1
                        If BPV(Enu, Z) < LowestProb Then
                        
                            NC = NC + 1
                        
                        End If
                    Next Z
                    
                    
                    If Enu > 0 And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                        If OnlyReassortmentFlag = 0 Then
                            Excl(Enu) = 1
                        ElseIf OnlyReassortmentFlag = 1 Then 'only reassortment
                            If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) = 1 Then
                                Excl(Enu) = 1
                            End If
                        ElseIf OnlyReassortmentFlag = 2 Then 'only recombination
                            If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) <> 1 And Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) <> 1 Then
                                Excl(Enu) = 1
                            End If
                        End If
                    
                    End If
                End If
            End If
        Next Y
    Next x
   
    
    Dim BPos() As Long, TypeSeq
    Call MakeAPos(APos(), BPos())
    
    TypeSeq = TypeSeqNumber
    
    Win = MatWinSize
    If Win = 0 Then Win = 200
    b = 0
    C = 0
    
    
    
    If ExRecFlag = 1 Then
        MultBPFlag = 0
        For x = 0 To NextNo
            If CurrentXOver(x) > 2 Then
                MultBPFlag = 1: Exit For
            End If
        Next x
        If MultBPFlag = 1 Then
            'sort out plant numbers
            Dim TraceHost() As Long, KeepTrack As Long
            Call GetPlantNums(KeepTrack, TraceHost())
            
            Dim IntervalMap() As Long, CountPos As Long
            Call MakeIntervalMap(CountPos, IntervalMap())
            
            
            
            Dim DoneMap() As Byte
            ReDim DoneMap(CountPos, KeepTrack)
        End If
        
        
    End If
    
    
    If BPCvalFlag = 0 Or x = x Then
        BPCvalFlag = 1
        ReDim BPCVal(1, 1)
         Dim DN As Long
        DN = 1
        Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
        'Call RecombMapPermsS(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
        x = x
        'Exit Sub
    Else
        Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
    End If
    
    Dim ModnumX() As Double, ModnumY() As Double
    ReDim ModnumX(NextNo), ModnumY(Len(StrainSeq(0)))
    
    If AbortFlag = 1 Then
        Screen.MousePointer = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        AbortFlag = 0
        Exit Sub
    End If
    
    If ExRecFlag = 2 Then
        For x = 0 To NextNo - 1
            If ParentSeqs(0) <> x And ParentSeqs(1) <> x Then
                
                    For Y = 1 To Len(StrainSeq(0))
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            ST = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = Len(StrainSeq(0)) To 1 Step -1
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            EN = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = ST To EN
                        
                        ModnumY(Y) = ModnumY(Y) + 1
                        
                    Next Y
                    x = x + 1
            End If
        Next x
        'XX = ModnumY(1690)
        For x = 0 To NextNo
            'pair_00-85_461A-210C    0,0739
            
            'pair_00-85_859A-914G    0,0654
            'pair_Heather_A115-D89   0,1000
            'pair_Heather_A115-D126  0,0380
            'pair_Heather_A120-D89   0,0440
            'pair_Heather_D126-A120  0,0480
            'pair_90-35_899-122  0,0591
            'pair_90-35_905A-858G    0,0617
            'pair_140-35_461A-210C   0,0568
            'pair_140-35_461A-1033G  0,0617
            'pair_140-35_461A-2116D  0,0573
            'pair_140-35_914-899     0,0620
            'pair_140-35_O5-914G     0,0216
            'pair_140-35_O5-O2   0,0596
            'pair_140-03_899-914     0,0990
            'pair_EPRRE-03_899A-122D     0,0526
            
            'pair_00-85_461A-1033G   0,0761
            If InStr(1, OriginalName(x), "AG00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7610 / 20)
            ElseIf InStr(1, OriginalName(x), "AC00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7390 / 22)
            ElseIf InStr(1, OriginalName(x), "859A-914G00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6540 / 15)
            ElseIf InStr(1, OriginalName(x), "D126-A120", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4800 / 43)
            ElseIf InStr(1, OriginalName(x), "A120-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4400 / 21)
            ElseIf InStr(1, OriginalName(x), "A115-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(10000 / 20)
            ElseIf InStr(1, OriginalName(x), "A115-D126", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(3800 / 20)
            ElseIf InStr(1, OriginalName(x), "A905-G858", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 38)
            ElseIf InStr(1, OriginalName(x), "899A-122D", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5910 / 33)
            ElseIf InStr(1, OriginalName(x), "O32-O35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5960 / 24)
            ElseIf InStr(1, OriginalName(x), "G914-O32", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(2160 / 18)
            ElseIf InStr(1, OriginalName(x), "AG140-35b", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5730 / 25)
            ElseIf InStr(1, OriginalName(x), "AC140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5680 / 26)
            ElseIf InStr(1, OriginalName(x), "AG140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 26)
            ElseIf InStr(1, OriginalName(x), "A899-G914", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(9900 / 24)
            ElseIf InStr(1, OriginalName(x), "914G-899A", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6200 / 24)
            ElseIf InStr(1, OriginalName(x), "A899-D122", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5260 / 14)
            Else
                ModnumX(x) = 1
            End If
            
            
        Next x
    Else
        For x = 0 To NextNo
            ModnumX(x) = 1
        Next x
         For Y = 1 To Len(StrainSeq(0))
            ModnumY(Y) = 1
        Next Y
    End If

    'Make exclusions
    'maxm = 0
    BPNum = 0
    
    'Open "bpdist.csv" For Output As #10
    Dim Par1 As Long, Pasr2 As Long
    For x = 1 To ENumb
        
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
           
            
            If x = x Then
                D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending ' 596,817,596,595,564,595,789,696,932,752
                
                If ExRecFlag = 1 Then
                    
                    
                   
                    If PermPlantNum(D) > 0 Then
'                        If Chimaeraflag = 1 Then
'                           Par1 = RefChimaera(PermPlantNum(D), 0)
'                           Par2 = RefChimaera(PermPlantNum(D), 1)
'                        Else
'                           Par1 = ParentSeqs(0)
'                           Par2 = ParentSeqs(1)
'                        End If
                        If MultBPFlag = 1 Then
                            MapPos = IntervalMap(ST)
                            CurHost = TraceHost(D)
                            If DoneMap(MapPos, CurHost) = 0 Then
                                DoneMap(MapPos, CurHost) = 1
                                Size = 1
                                RecMap(ST) = RecMap(ST) + (1 / Size) * ModnumX(D)
                                BPNum = BPNum + ModnumX(D)
                                
                            
                            End If
                        Else
                            Size = 1
                            RecMap(ST) = RecMap(ST) + (1 / Size) * ModnumX(D)
                            BPNum = BPNum + ModnumX(D)
                        End If
                    End If
                Else
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        'zzz = zzz + 1
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 Then
                           ' Print #10, APos(ST)
                            Z = ST
                            Size = 1
                            If Z <= ST Then
                                For Y = Z To ST
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            Else
                                For Y = Z To Len(StrainSeq(0))
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                                For Y = 1 To ST
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            End If
                            'zzz = zzz + 1
                        Else
                            x = x
                        End If
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 Then
                            Z = EN
                            Size = 1
                            'zzz = zzz + 1
                            ' Print #10, APos(EN)
                            If EN <= Z Then
                                For Y = EN To Z
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            Else
                                For Y = EN To Len(StrainSeq(0))
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                                For Y = 1 To Z
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            End If
                            'RecMap(En) = RecMap(En) + 1
                        Else
                        x = x
                        End If
                    Else
                        x = x
                    End If
                End If
            End If
        End If
    
        
    Next x
    XX = BPNum '385
  '  Close #10
  
    For x = 1 To Len(StrainSeq(0))
        If ModnumY(x) > 0 Then
'            If RecMap(X) > 0 Then
'                X = X
'            End If
        
            RecMap(x) = CLng(RecMap(x) / ModnumY(x))
            x = x
        End If
    Next x
    
    Erase ModnumY
    
    'XX = RecMap(697)
    
    'Map sites to positions in type sequence that will be used to modify the plot
    
    PPMax = 0
    For x = 1 To Len(StrainSeq(0))
        If RecMap(x) > PPMax Then PPMax = RecMap(x)
    Next x
    Dim hWin As Long
    hWin = CLng(Win / 2)
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        
        If CircularFlag = 0 And x = 12345 Then
            ST = CLng(Win / 2)
            EN = APos(Len(StrainSeq(0))) - ST
        Else
            ST = 1
            EN = APos(Len(StrainSeq(0)))
        End If
    Else
        ST = 1
        EN = Decompress(Len(StrainSeq(0)))
        
    End If
    Dim Tot As Double
    mrs = 0
    
        
    Tot = 0
    lastv = -1
    lastw = -1
    For x = ST To EN
        
        
        If x = ST Then
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then 'if there is no compression
                'do first window
                For A = ST - hWin To ST + hWin - 1
                    If A < 1 Then
                        STX = APos(Len(StrainSeq(0))) + A
                        If STX < Len(StrainSeq(0)) Then
                            ENX = BPos(STX + 1) - 1
                        ElseIf STX = Len(StrainSeq(0)) Then
                            ENX = Len(StrainSeq(0))
                        Else
                            ENX = BPos(STX + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                        End If
                        STX = BPos(STX)
                    
                    ElseIf A > APos(Len(StrainSeq(0))) Then
                        STX = A - APos(Len(StrainSeq(0)))
                        ENX = BPos(STX + 1) - 1
                        STX = BPos(STX)
                    Else
                        ENX = BPos(A + 1) - 1
                        STX = BPos(A)
                    End If
                    If ENX = 0 Then ENX = Len(StrainSeq(0))
                    
                        For V = STX To ENX
                            Z = Recompress(V)
                        
                            If Z < 1 Then
                                Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                
                            ElseIf Z > Len(StrainSeq(0)) Then
                                Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                
                            Else
                                Tot = Tot + RecMap(Z)
                                
                            End If
                        Next V
                        
                    
                    
                Next A
            Else 'if there is compression
                'do first window
                For A = ST - hWin To ST + hWin - 1
                    If A < 1 Then
                        STX = Decompress(Len(StrainSeq(0))) + A
                        If STX < Decompress(Len(StrainSeq(0))) Then
                            ENX = (STX + 1) - 1
                        ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                            ENX = Decompress(Len(StrainSeq(0)))
                        Else
                            ENX = STX + 1
                        End If
                        STX = STX
                    
                    ElseIf A > Decompress(Len(StrainSeq(0))) Then
                        STX = A - Decompress(Len(StrainSeq(0)))
                        ENX = (STX + 1) - 1
                        STX = (STX)
                    Else
                        ENX = (A + 1) - 1
                        STX = (A)
                    End If
                    If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                    If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                    
                        For V = STX To ENX
                            Z = Recompress(V)
                            If Z <> lastv Then
                                If Z < 1 Then
                                    Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                    lastw = Z
                                    
                                ElseIf Z > Len(StrainSeq(0)) Then
                                    Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                    lastw = Z
                                    
                                Else
                                    Tot = Tot + RecMap(Z)
                                    lastw = Z
                                    
                                End If
                                lastv = Z
                            End If
                        Next V
                        If Tot > 0 Then
                            x = x
                        End If
                        x = x
                    
                    
                Next A
            End If
            x = x
            
        Else
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then 'i.e. no compression
                A = x - hWin - 1
                If A < 1 Then
                    STX = APos(Len(StrainSeq(0))) + A
                    'ENX = BPos(STX - 1) + 1
                    If STX < Len(StrainSeq(0)) Then
                        ENX = BPos(STX - 1) + 1
                    ElseIf STX = Len(StrainSeq(0)) Then
                        ENX = Len(StrainSeq(0))
                    Else
                        ENX = BPos(STX + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                    End If
                    
                    STX = BPos(STX)
                
                ElseIf A > APos(Len(StrainSeq(0))) Then
                    STX = A - APos(Len(StrainSeq(0)))
                    ENX = BPos(STX - 1) + 1
                    STX = BPos(STX)
                Else
                    ENX = BPos(A - 1) + 1
                    STX = BPos(A)
                   
                End If
                'If ENx <> stx Then
                '    X = X
                'End If
                For Z = ENX To STX
                    If Z < 1 Then
                        Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                    Else
                        Tot = Tot - RecMap(Z)
                    End If
                Next Z
                
                A = x + hWin - 1
                If A < 1 Then
                        STX = APos(Len(StrainSeq(0))) + A
                        ENX = BPos(STX + 1) - 1
                        STX = BPos(STX)
                    
                    ElseIf A >= APos(Len(StrainSeq(0))) Then
                        STX = A - APos(Len(StrainSeq(0)))
                        ENX = BPos(STX + 1) - 1
                        STX = BPos(STX)
                    Else
                        ENX = BPos(A + 1) - 1
                        STX = BPos(A)
                    
                End If
                
                For Z = STX To ENX
                    If Z < 1 Then
                        Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                        
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                        
                    Else
                        Tot = Tot + RecMap(Z)
                        
                    End If
                Next Z
                
                If Tot <> 0 Then
                    x = x '565-u,571-u-u,597-u-u-u,615-d,646-d-d,647-d-d-d,753-u,803-d,818 -u,868-d,933-u,983-d
                End If
                If Tot < 0 Then
                    Tot = 0 'this is needed because occasionally a -1 is possible because w're looking at breakpoints
                                        'mapped from the alignment onto individuals equences that may have gaps at particular alignment
                                        'positions
                End If
            
            Else 'there is compression
                A = x - hWin - 1
                If A < 1 Then
                    STX = Decompress(Len(StrainSeq(0))) + A
                    If STX < Decompress(Len(StrainSeq(0))) Then
                        ENX = (STX + 1) - 1
                    ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                        ENX = Decompress(Len(StrainSeq(0)))
                    Else
                        ENX = STX + 1
                    End If
                    STX = STX
                
                ElseIf A > Decompress(Len(StrainSeq(0))) Then
                    STX = A - Decompress(Len(StrainSeq(0)))
                    ENX = (STX + 1) - 1
                    STX = (STX)
                Else
                    ENX = (A + 1) - 1
                    STX = (A)
                End If
                If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                
                For V = STX To ENX
                    Z = Recompress(V)
                    If Z <> lastv Then
                        If Z < 1 Then
                            Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                            
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                            
                        Else
                            Tot = Tot - RecMap(Z)
                            
                        End If
                        lastv = Z
                        
                    End If
                Next V
                
                A = x + hWin - 1
                If A < 1 Then
                    STX = Decompress(Len(StrainSeq(0))) + A
                    If STX < Decompress(Len(StrainSeq(0))) Then
                        ENX = (STX + 1) - 1
                    ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                        ENX = Decompress(Len(StrainSeq(0)))
                    Else
                        ENX = STX + 1
                    End If
                    STX = STX
                
                ElseIf A > Decompress(Len(StrainSeq(0))) Then
                    STX = A - Decompress(Len(StrainSeq(0)))
                    ENX = (STX + 1) - 1
                    STX = (STX)
                Else
                    ENX = (A + 1) - 1
                    STX = (A)
                End If
                If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                
                For V = STX To ENX
                    'Z = v
                    Z = Recompress(V)
                   ' If Z = 1 Then
                   '     X = X
                   ' End If
                    
                    If Z <> lastw Then
                        If Z < 1 Then
                            Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                            
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                            
                        Else
                            Tot = Tot + RecMap(Z)
                            
                        End If
                        lastw = Z
                    End If
                Next V
                
                
                If Tot < 0 Then
                    Tot = 0 'this is needed because occasionally a -1 is possible because w're looking at breakpoints
                                        'mapped from the alignment onto individuals equences that may have gaps at particular alignment
                                        'positions
                End If
            End If
        
            
        
        End If
        
        RecMapSmooth(Recompress(x)) = Tot / Win
        '565-u,571-u-u,597-u-u-u,615-d,646-d-d,647-d-d-d,753-u,803-d,818 -u,868-d,933-u,983-d
        
        If mrs < RecMapSmooth(Recompress(x)) Then
            mrs = RecMapSmooth(Recompress(x))
        End If
    Next x
    
   'XX = RecMapSmooth(799) '0.11'0.12'0.14
        'XX = RecMapSmooth(565)
        
    x = x
    'GPerms = 5
    'Adjust recmap
    Dim RMapSmooth() As Double, RMapBounds() As Double
        ReDim RMapSmooth(GPerms, Len(StrainSeq(0)))
 '*************************************
 'This bit gets left out
 '*************************************
    If GPerms > 0 And x = 12345 Then
        
        
        For A = 1 To GPerms
            Tot = 0
            'BPListHolder(X, CPermNo)
            For x = ST To EN
                If x = ST Then
                    'do first window
                    For Z = ST - hWin To ST + hWin - 1
                        If Z < 1 Then
                            'XX = UBound(BPListHolder, 1)
                            Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                        Else
                            Tot = Tot + BPListHolder(Z, A)
                        End If
                        
                    Next Z
                    
                Else
                    Z = x - hWin
                    If Z < 1 Then
                        Tot = Tot - BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot - BPListHolder(Z, A)
                    End If
                    Z = x + hWin - 1
                    If Z < 1 Then
                        Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot + BPListHolder(Z, A)
                    End If
                    
                End If
                RMapSmooth(A, x) = Tot / Win
            Next x
        Next A
        
        
        Dim OrderArray() As Long, Tester As Double
        ReDim RMapBounds(4, Len(StrainSeq(0)))
        For Y = 1 To Len(StrainSeq(0))
            ReDim OrderArray(GPerms)
            For x = 1 To GPerms
                Tester = RMapSmooth(x, Y)
                For Z = 1 To GPerms
                    If Tester < RMapSmooth(Z, Y) Then OrderArray(x) = OrderArray(x) + 1
                Next Z
                x = x
            Next x
            Dim Target(4) As Double
            Target(0) = Int((GPerms * TargetS(3)) + 1)
            If Target(0) > GPerms Then Target(0) = GPerms
            Target(1) = Int((GPerms * TargetS(2)) + 1)
            If Target(1) > GPerms Then Target(1) = GPerms
            Target(2) = Int((GPerms * TargetS(1)))
            If Target(2) < 0 Then Target(2) = 0
            Target(3) = Int((GPerms * TargetS(0)))
            If Target(3) < 0 Then Target(3) = 0
            Target(4) = Int(GPerms * 0.5)
            
            For x = 0 To 3
                For Z = 1 To GPerms
                    If OrderArray(Z) = Target(x) Then
                        RMapBounds(x, Y) = RMapSmooth(Z, Y)
                        Exit For
                    End If
                Next Z
                If Z > GPerms Then
                    If x < 2 Then
                    'find closest smaller value to target
                        Tot = 0
                        For Z = 1 To GPerms
                            If OrderArray(Z) < Target(x) Then
                                If OrderArray(Z) > Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the smallest value
                            Tot = 0
                            For Z = 1 To GPerms
                                If OrderArray(Z) > Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                    x = x
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    Else
                        'find closest larger value to target
                        Tot = 1000000
                        For Z = 1 To GPerms
                            If OrderArray(Z) > Target(x) Then
                                If OrderArray(Z) < Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the largest value
                            Tot = 1000
                            For Z = 1 To GPerms
                                If OrderArray(Z) < Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    End If
                End If
            Next x
            Tot = 0
            For Z = 1 To GPerms
                Tot = Tot + RMapSmooth(Z, Y)
            Next Z
            RMapBounds(4, Y) = Tot / GPerms
        Next Y
        'RecMapSmooth(X)
        For x = DN To Len(StrainSeq(0)) - DN + 1
            
            RecMapSmooth(x) = RecMapSmooth(x) - RMapBounds(4, x)
        Next x
        
        For x = DN To Len(StrainSeq(0)) - DN + 1
            RMapBounds(0, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(0, x))
            RMapBounds(1, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(1, x))
            RMapBounds(2, x) = RecMapSmooth(x) - (RMapBounds(2, x) - RMapBounds(4, x))
            RMapBounds(3, x) = RecMapSmooth(x) - (RMapBounds(3, x) - RMapBounds(4, x))
            x = x
        Next x
    End If
    '****************************************
    'end of left out bit
    '****************************************
    PPMax = 0
    Dim PPMin As Double
    PPMin = 100
    
    If CLine <> "" Then
        ReDim HSCord(10, 10)
        '0 = hot(1)/cold(0)
        '1 = start bp 95 global
        '2 = end bp 95 global
        '3 = start bp 99 global
        '4 = end bp 99 global
        '5 = start bp 95 local
        '6 = end bp 95 local
        '7 = start bp 99 local
        '8 = end bp 99 local
        HSNum = 0
        If CircularFlag = 1 Then
            ST = DN + 1
            EN = APos(Len(StrainSeq(0)) - DN + 1)
        Else
            ST = CLng(Win / 2) + DN + 1
            EN = APos(Len(StrainSeq(0)) - DN + 1) - CLng(Win / 2)
        End If
        '-f test.txt -nordpfile -nocsvfile -hotspot
        '-f 4 -nordpfile -nocsvfile -hotspot
        Dim LastEqual As Long
        For Z = ST To EN
            
            If (RecMapSmooth(Z) * Win) > PValMap(Z, PermutationX * TargetS(0)) Then '546 = 3, 747=2,817=2, 913=2
                HSNum = HSNum + 1
                If HSNum > UBound(HSCord, 2) Then
                    ReDim Preserve HSCord(10, HSNum + 10)
                End If
                Spos = Z
                LastEqual = Spos
                For A = Spos To EN
                    
                    If (RecMapSmooth(A) * Win) < PValMap(A, PermutationX * TargetS(0)) Then
                        
                        
                        Epos = LastEqual - 1
                        
                        Exit For
                    
                            
                    ElseIf A = EN Then
                    
                        Epos = A
                    
                    End If
                    If (RecMapSmooth(A) * Win) > PValMap(A, PermutationX * TargetS(0)) Then
                        LastEqual = A
                    Else
                        x = x
                    End If
                Next A
                x = x
                Z = A
                HSCord(0, HSNum) = 1 'ie this is a hotspot
                HSCord(3, HSNum) = Spos
                HSCord(4, HSNum) = Epos
                Max = 0
                For A = Spos To Epos
                    If Max < RecMapSmooth(A) * Win Then
                        Max = RecMapSmooth(A) * Win
                    End If
                Next A
                HSCord(1, HSNum) = Max
                'If BPCVal(0, 0) <> BPCVal(0, 1) Then
                '    x = x
                'End If
                For A = Spos To Epos
                    If (RecMapSmooth(A) * Win) >= BPCVal(0, 1) Then
                        Spos = A
                        For b = Epos To A + 1 Step -1
                           If (RecMapSmooth(b) * Win) >= BPCVal(0, 1) Then
                                Exit For
                           End If
                        Next b
                        
                        HSCord(5, HSNum) = Spos
                        HSCord(6, HSNum) = b
                        Epos = b
                        Exit For
                    End If
                    
                Next A
                x = x
                For A = Spos To Epos
                    If (RecMapSmooth(A) * Win) >= BPCVal(0, 0) Then
                        Spos = A
                        For b = Epos To A + 1 Step -1
                           If (RecMapSmooth(b) * Win) >= BPCVal(0, 0) Then
                                Exit For
                           End If
                        Next b
                        
                        HSCord(7, HSNum) = Spos
                        HSCord(8, HSNum) = b
                        Epos = b
                        Exit For
                    End If
                    
                Next A
                x = x
            End If
           ' If PValMap(Z, PermutationX * targets(1)) > 0 Then
           '         x = x
           '     End If
        Next Z
        x = x
        
    End If
    
    
    
    For x = DN To Len(StrainSeq(0)) - DN + 1
        If RecMapSmooth(x) > PPMax Then PPMax = RecMapSmooth(x)
        If RecMapSmooth(x) < PPMin Then PPMin = RecMapSmooth(x)
        
        
        '************************************
        'Restore this if GPerms is reinstated
        '************************************
        'For Y = 0 To 3
        '    If RMapBounds(Y, X) > PPMax Then PPMax = RMapBounds(Y, X)
        '    If RMapBounds(Y, X) < PPMin Then PPMin = RMapBounds(Y, X)
        'Next Y
    Next x
    
    
    
    If PPMax < (BPCVal(0, 0) / Win) Then PPMax = BPCVal(0, 0) / Win
    
    ReDim MCPrintPos(APos(Len(StrainSeq(0))))
    ReDim MCPrintData(6, APos(Len(StrainSeq(0))))
    For Z = 1 To APos(Len(StrainSeq(0)))
        MCPrintData(0, Z) = RecMapSmooth(Z)
        MCPrintPos(Z) = Z
    Next Z
    Dim TempXDiffpos() As Long
    ReDim TempXDiffpos(Len(StrainSeq(0)))
    Z = 1
    For x = 1 To Len(StrainSeq(0))
        TempXDiffpos(x) = XDiffPos(x)
        XDiffPos(x) = 0
        If RecMap(x) > 0 Then
            XDiffPos(Z) = x
            Z = Z + 1
        End If
        
    Next x
    
    Erase RecMap
    Form1.Picture7.Cls
    
    
    
    For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
        
        XDiffPos(x) = APos(XDiffPos(x))
        MCPrintData(6, x) = XDiffPos(x)
        
    Next x
    olenxoverseq = LenXoverSeq
    LenXoverSeq = Z
    MinPVal = PPMax
    MCMinChiP = PPMax
    PPMin = 0
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        GYAxHi(1) = APos(Decompress(Len(StrainSeq(0))))
        'DoAxes 1, Decompress(APos((Len(StrainSeq(0))))), TypeSeq, PPMax * Win, PPMin * Win, 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"
    Else
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'DoAxes 1, Decompress(((Len(StrainSeq(0))))), TypeSeq, PPMax * Win, (PPMin * Win), 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"

    End If
    RDPUD = PPMax * Win
    LenXoverSeq = olenxoverseq
    BSStepWin = Win
    
    
    Dim PV As Double
    LOffset = 30
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        WFactor = ((Form1.Picture7.Width - 40) / Decompress(APos(Len(StrainSeq(0)))))
    Else
        WFactor = ((Form1.Picture7.Width - 40) / Decompress((Len(StrainSeq(0)))))
    End If
    HFactor = (PicHeight - 35)
    TOffset = 20
    Dim PntAPI As POINTAPI
    If Form1.Picture7.DrawWidth = 0 Then Form1.Picture7.DrawWidth = 1
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = 0
    'Form1.Picture7.AutoRedraw = True
    'MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RecMapSmooth(1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    MhDC = Form1.Picture7.hdc
    If PPMax - PPMin > 0 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
'            MoveToEx MhDC, LOffset + Decompress(1) * WFactor - 5, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'
'            MoveToEx MhDC, (LOffset - 5 + Decompress(1) * WFactor), (TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor), PntAPI
'            LineTo MhDC, (LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor), (TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor)
        
        Else
'            MoveToEx MhDC, LOffset + Decompress(1) * WFactor - 5, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress((Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'
'            MoveToEx MhDC, LOffset - 5 + (Decompress(1) * WFactor), TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + (Decompress((Len(StrainSeq(0)))) * WFactor), TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        ' Form1.Picture7.DrawWidth = 100
        'Form1.Picture1.DrawStyle = 1
        'Form1.Picture1.AutoRedraw = True
        'MhDC = Form1.Picture1.hdc
        '                MoveToEx MhDC, 1, 1, PntAPI
        '    LineTo MhDC, 1000, 1000
x = x
        End If
    Else
        Form1.Picture7.DrawStyle = 0
        Exit Sub
    End If
    
    MCPrintData(5, 0) = BPCVal(0, 0) / Win
    MCPrintData(5, 1) = BPCVal(0, 1) / Win
    
    Form1.Picture7.DrawStyle = 0
    
    'XX = UBound(PValMap, 2)
    
    
    If x = x Then
    'show only local 99 and 95% CIs
        Form1.Picture7.ForeColor = RGB(255, 255, 255)
        
        If x = x Then ' draw with polygon
            Dim PolyPoints() As POINTAPI
'            Form1.Picture7.Refresh
            ReDim PolyPoints(APos(Len(StrainSeq(0)) - DN + 1) * 2)
            Form1.Picture7.FillStyle = 0
            Form1.Picture7.FillColor = RGB(255, 255, 255)
            A = -1
            For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
            For x = APos(Len(StrainSeq(0)) - DN + 1) To DN Step -1
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
'            Polygon MhDC, PolyPoints(0), A
            
            Form1.Picture7.FillStyle = 0
            Form1.Picture7.FillColor = RGB(150, 150, 150)
            Form1.Picture7.ForeColor = RGB(150, 150, 150)
            A = -1
            For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
            For x = APos(Len(StrainSeq(0)) - DN + 1) To DN Step -1
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
'            Polygon MhDC, PolyPoints(0), A
            
'            Form1.Picture7.Refresh
            x = x
        Else 'draw it with lines
'            MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * Targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * Targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            For X = DN + 1 To APos((Len(StrainSeq(0))) - DN + 1)
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            Next X
'            Form1.Picture7.ForeColor = RGB(150, 150, 150)
'            MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * Targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + (Decompress(DN)) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * Targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            Next X
        End If
        x = x
    Else
        'do coulourful plot
        For Z = PermutationX To PermutationX / 2 Step -1
            If Z > 0.75 * PermutationX Then
                Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - PermutationX / 2) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX * 0.75)) / (PermutationX * 0.25)))
            Else
                Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (255 - 255 * ((PermutationX * 0.75) - Z) / (PermutationX * 0.25)))
            End If
            
            'Form1.Picture7.ForeColor = RGB(127 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50)
            'Form1.Picture7.ForeColor = RGB(200 + 55 * (Z - 50) / 50, 0 + 255 * (Z - 50) / 50, 127 + 128 * (Z - 50) / 50)
            
'            MoveToEx MhDC, LOffset + Decompress(1) * WFactor, TOffset + (1 - (PValMap(1, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(1) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0))), Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            For X = 2 To APos(Len(StrainSeq(0)))
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            Next X
        
        Next Z
    End If
    
    Form1.Picture7.ForeColor = RGB(128, 128, 128)
   ' MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValmap( 1, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
   ' For X = 2 To Len(StrainSeq(0))
   '     LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValmap( X, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
   ' Next X
    Form1.Picture7.ForeColor = RGB(130, 130, 130)
    MCPrintData(1, 1) = PValMap(1, TargetS(1) * PermutationX) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(1) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(1) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(1, x) = PValMap(x, TargetS(1) * PermutationX) / Win
    Next x
    MCPrintData(2, 1) = PValMap(1, TargetS(2) * PermutationX) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(2) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(2) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(2, x) = PValMap(x, TargetS(2) * PermutationX) / Win
    Next x
    Form1.Picture7.ForeColor = RGB(200, 200, 200)
    MCPrintData(3, 1) = PValMap(1, TargetS(0) * PermutationX) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(0) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(0) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(3, x) = PValMap(x, 0.01 * PermutationX) / Win
    Next x
    MCPrintData(4, 1) = PValMap(1, TargetS(3) * PermutationX) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(3) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(3) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(4, x) = PValMap(x, TargetS(3) * PermutationX) / Win
    Next x
    Form1.Picture7.ForeColor = 0
    '***********************************
    'Left out
    '***********************************
    If GPerms > 0 And x = 123425 Then
        Form1.Picture7.DrawWidth = CLng((Form1.Picture7.ScaleWidth - LOffset * 2) / Len(StrainSeq(0)) + 0.5)
        
        Form1.Picture7.DrawStyle = 0
'        For X = 0 To 1
'            If X = 0 Or X = 3 Then
'                Form1.Picture7.ForeColor = HalfColour
'                Y = 3
'            Else
'                Form1.Picture7.ForeColor = RGB(128, 128, 128)
'                Y = 2
'            End If
'            MhDC = Form1.Picture7.hDC
'            MoveToEx MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RMapBounds(X, 1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RMapBounds(Y, 1) - PPMin) / (PPMax - PPMin)) * HFactor
'            For Z = 2 To APos(Len(StrainSeq(0)))
'
'                MhDC = Form1.Picture7.hDC
'                LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RMapBounds(X, Z) - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RMapBounds(Y, Z) - PPMin) / (PPMax - PPMin)) * HFactor
'            Next Z
'        Next X
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.DrawStyle = 0
        Form1.Picture7.ForeColor = 0
'        MoveToEx MhDC, LOffset - 5 + 0 * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor
        Erase RMapBounds
    End If
    
'    Form1.Picture7.ForeColor = 0
'    MhDC = Form1.Picture7.hDC
'    MoveToEx MhDC, LOffset + Decompress(DN) * WFactor, TOffset + (1 - (RecMapSmooth(DN) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'    For Z = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'
'        MhDC = Form1.Picture7.hDC
'        LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RecMapSmooth(Z) - PPMin) / (PPMax - PPMin)) * HFactor
'    Next Z
    
    

    
'get everything into standard save/copy format
GPrintNum = 2 'three lines
NSites = APos(Len(StrainSeq(0)))


ReDim GVarPos(0, NSites)
For x = 1 To NSites
    GVarPos(0, x) = XDiffPos(x)
Next x
For x = 1 To Len(StrainSeq(0))
    XDiffPos(x) = TempXDiffpos(x)
Next x

Erase TempXDiffpos

ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)

ReDim GCritval(10)



GCritval(2) = BPCVal(0, 0)
GCritval(3) = BPCVal(0, 1)

GLegend = "Breakpoints per " & Trim(Str(Win)) & " nt window"
GPrintLen = NSites * 2  'how many points to plot
GPrintCol(2) = 0 'line is black
GPrintCol(0) = RGB(198, 198, 198) 'RGB(128, 128, 128) 'line is grey
GPrintCol(1) = RGB(128, 128, 128) 'line is light grey

GPrintType = 0 'a normal line plot
GPrintMin(0) = PPMin * Win  'bottom val
GPrintMin(1) = PPMax * Win 'upper val


'Form1.Picture7.ForeColor = RGB(255, 255, 255)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X
'        Form1.Picture7.ForeColor = RGB(150, 150, 150)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X

For x = 0 To NSites - 1
    
    GPrint(2, x) = RecMapSmooth(x + 1) * Win 'GraphPlt(0, X)
   ' GPrint(0, NSites * 2 - X) = RecMapSmooth(X + 1) * Win 'GraphPlt(0, X)
    GPrintPos(2, x) = x + 1 'PltPos(X)
   ' GPrintPos(0, NSites * 2 - X) = X + 1 ' PltPos(X)
    
    
Next x

Erase RecMapSmooth

GBlockNum = -1



For x = 0 To NSites - 1
    'PValMap(DN, PermutationX * targets(0))
    GPrint(0, x) = PValMap(x + 1, PermutationX * TargetS(0)) 'GraphPlt(1, X)
    GPrint(0, NSites * 2 - x) = PValMap(x + 1, PermutationX * TargetS(3)) 'GraphPlt(2, X)
    GPrintPos(0, x) = x + 1 'PltPos(X)
    GPrintPos(0, NSites * 2 - x) = x + 1 'PltPos(X)
    
    GPrint(1, x) = PValMap(x + 1, PermutationX * TargetS(1)) 'GraphPlt(1, X)
    GPrint(1, NSites * 2 - x) = PValMap(x + 1, PermutationX * TargetS(2)) 'GraphPlt(2, X)
    GPrintPos(1, x) = x + 1 'PltPos(X)
    GPrintPos(1, NSites * 2 - x) = x + 1 'PltPos(X)
Next x
GPrintPos(0, GPrintLen - 1) = GPrintPos(1, 0)
GPrintPos(1, GPrintLen - 1) = GPrintPos(2, 0)
'GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
GPrintPos(0, GPrintLen) = GPrintPos(1, 0)
'GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
GPrintPos(1, GPrintLen) = GPrintPos(2, 0)
'GPrint(0, GPrintLen - 1) = GPrint(0, 0)
GPrint(0, GPrintLen - 1) = GPrint(1, GPrintLen - 2)
GPrint(0, GPrintLen) = GPrint(1, 0)
GPrint(1, GPrintLen - 1) = GPrint(2, GPrintLen - 2)
GPrint(1, GPrintLen) = GPrint(2, 0)
GExtraTNum = 2
ReDim GExtraText(GExtraTNum)
GExtraText(0) = "Breakpoint number"
GExtraText(1) = "Local 95% confidence interval"
GExtraText(2) = "Local 99% confidence interval"


Call RedrawPlotAA(1)
If DebuggingFlag < 2 Then
    Form1.WindowState = Form1.WindowState
End If
Erase PValMap
    'Call SelectionMod
    
    Form1.Picture7.Refresh
    
    
    
End Sub
Public Sub RecombMapIIIc()
    
    
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double, Win As Long
    Dim TargetS(3)
    TargetS(0) = 0.01
    TargetS(1) = 0.05
    TargetS(2) = 0.95
    TargetS(3) = 0.99
    CurrentCheck = 17
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Dim PermutationX As Long
    
    PermutationX = MatPermNo
    If PermutationX > 10000 Then PermutationX = 10000
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
    
    Dim BPV() As Double
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
    
    For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                    If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                        BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                    End If
                End If
            Next Y
    Next x
    Dim PValCon As Double
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
    
    Dim AccX As Byte, NAccX As Byte
    AccX = 0
    NAccX = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            
            If XoverList(x, Y).Accept = 1 Then
                AccX = 1
                If NAccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            ElseIf XoverList(x, Y).Accept = 0 Then
                NAccX = 1
                If AccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            End If
            
        Next Y
        
    Next x
    
    
    If AccX = 1 And NAccX = 1 Then
        If CLine = "" Or CLine = " " Then
            If ReassortmentFlag = 1 Then
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination/reassortment events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a breakpoint distribution plot")
            Else
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a breakpoint distribution plot")
            End If
        Else
            Response = 7 'No
        End If
        If Response = 6 Then 'yes
            UseAll = 0
        Else
            UseAll = 1
        End If
    Else
        UseAll = 1
    End If
    
    
    Dim OnlyReassortmentFlag As Byte '0 = consider both recombination and reassortment, 1 = only reassortment, 2 = only recombination
    
    If ReassortmentFlag > 0 Then
        Dim Segbound() As Byte
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                tBP = RBPPos(x)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
        
        Dim ReassortmentNo As Long, RecombinationNo As Long
        
        For x = 0 To SEventNumber
            
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or UseAll = 1 Then
                If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
                    ReassortmentNo = ReassortmentNo + 1
                Else
                    RecombinationNo = RecombinationNo + 1
                End If
                If RecombinationNo > 0 And ReassortmentNo > 0 Then
                    Exit For
                End If
            End If
        Next x
        If RecombinationNo > 0 And ReassortmentNo > 0 Then
            Response = MsgBox("Both reassortment and recombination events have been detected. Would you like to only consider the recombination events? It would make sense to ignor the reassortment events because their associated 'breakpoints' are not real.", vbYesNo, "Construct a breakpoint distribution plot")
            If Response = 7 Then
                Response = MsgBox("OK. So would you like to only consider the reassortment events then? Reassortment events don't really involve breakpoints so this analysis would be kind've meaningless. If you press 'no' then both the recombination and reassortment events will be considered (which will be another meaningless type of analysis).", vbYesNo, "Construct a breakpoint distribution plot")
                If Response = 7 Then
                    OnlyReassortmentFlag = 0
                Else
                    OnlyReassortmentFlag = 1
                End If
            Else
                OnlyReassortmentFlag = 2
            End If
        Else
            OnlyReassortmentFlag = 0
        End If
    Else
        OnlyReassortmentFlag = 0
    End If
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Enu = SuperEventList(XoverList(x, Y).Eventnumber)
            'If Enu = 4 Then
            '    X = X
            'End If
            'If Enu = 23 Then
            '    X = X
            'End If
            NC = 0
            For Z = 0 To AddNum - 1
                If BPV(Enu, Z) < LowestProb Then
                
                    NC = NC + 1
                
                End If
            Next Z
            
            
            If Enu > 0 And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                If OnlyReassortmentFlag = 0 Then
                    Excl(Enu) = 1
                ElseIf OnlyReassortmentFlag = 1 Then 'only reassortment
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) = 1 Then
                        Excl(Enu) = 1
                    End If
                ElseIf OnlyReassortmentFlag = 2 Then 'only recombination
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) <> 1 And Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) <> 1 Then
                        Excl(Enu) = 1
                    End If
                End If
            Else
                x = x
            End If
        Next Y
    Next x
'    For X = 0 To SEventNumber
'        XX = Excl(X)
'    Next X
    
    Dim BPos() As Long, TypeSeq
    Call MakeAPos(APos(), BPos())
    
    TypeSeq = TypeSeqNumber
    
    Win = MatWinSize
    If Win = 0 Then Win = 200
    b = 0
    C = 0
    If BPCvalFlag = 0 Or x = x Then
        BPCvalFlag = 1
        ReDim BPCVal(1, 1)
         Dim DN As Long
        DN = 1
        Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
        x = x
    End If
    If AbortFlag = 1 Then
        Screen.MousePointer = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        AbortFlag = 0
        Exit Sub
    End If
    ZZ = 0
    Dim ModnumX() As Double, ModnumY() As Double
    ReDim ModnumX(NextNo), ModnumY(Len(StrainSeq(0)))
    
    If x = x Then
        
        For x = 0 To NextNo
            If InStr(1, OriginalName(x), "parent", vbTextCompare) > 0 Then
                
                    For Y = 1 To Len(StrainSeq(0))
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            ST = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = Len(StrainSeq(0)) To 1 Step -1
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            EN = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = ST To EN
                        
                        ModnumY(Y) = ModnumY(Y) + 1
                        
                    Next Y
                    x = x + 1
            End If
        Next x
        
        
        For x = 0 To NextNo
            'pair_00-85_461A-210C    0,0739
            
            'pair_00-85_859A-914G    0,0654
            'pair_Heather_A115-D89   0,1000
            'pair_Heather_A115-D126  0,0380
            'pair_Heather_A120-D89   0,0440
            'pair_Heather_D126-A120  0,0480
            'pair_90-35_899-122  0,0591
            'pair_90-35_905A-858G    0,0617
            'pair_140-35_461A-210C   0,0568
            'pair_140-35_461A-1033G  0,0617
            'pair_140-35_461A-2116D  0,0573
            'pair_140-35_914-899     0,0620
            'pair_140-35_O5-914G     0,0216
            'pair_140-35_O5-O2   0,0596
            'pair_140-03_899-914     0,0990
            'pair_EPRRE-03_899A-122D     0,0526
            
            'pair_00-85_461A-1033G   0,0761
            If InStr(1, OriginalName(x), "AG00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7610 / 20)
            ElseIf InStr(1, OriginalName(x), "AC00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7390 / 22)
            ElseIf InStr(1, OriginalName(x), "859A-914G00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6540 / 15)
            ElseIf InStr(1, OriginalName(x), "D126-A120", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4800 / 43)
            ElseIf InStr(1, OriginalName(x), "A120-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4400 / 21)
            ElseIf InStr(1, OriginalName(x), "A115-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(10000 / 20)
            ElseIf InStr(1, OriginalName(x), "A115-D126", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(3800 / 20)
            ElseIf InStr(1, OriginalName(x), "A905-G858", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 38)
            ElseIf InStr(1, OriginalName(x), "899A-122D", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5910 / 33)
            ElseIf InStr(1, OriginalName(x), "O32-O35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5960 / 24)
            ElseIf InStr(1, OriginalName(x), "G914-O32", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(2160 / 18)
            ElseIf InStr(1, OriginalName(x), "AG140-35b", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5730 / 25)
            ElseIf InStr(1, OriginalName(x), "AC140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5680 / 26)
            ElseIf InStr(1, OriginalName(x), "AG140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 26)
            ElseIf InStr(1, OriginalName(x), "A899-G914", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(9900 / 24)
            ElseIf InStr(1, OriginalName(x), "914G-899A", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6200 / 24)
            ElseIf InStr(1, OriginalName(x), "A899-D122", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5260 / 14)
            Else
                ModnumX(x) = 1
            End If
            
            
        Next x
        x = x
    Else
        For x = 0 To NextNo
            ModnumX(x) = 1
            
        Next x
        For Y = 1 To Len(StrainSeq(0))
            ModnumY(Y) = 1
        Next Y
    End If
    'Make exclusions
    'maxm = 0
    For x = 1 To ENumb
        
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
           
            
            If x = x Then
                D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 Then
                        Z = ST
                        Size = 1
                        If Z <= ST Then
                            For Y = Z To ST
                                RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                            Next Y
                        Else
                            For Y = Z To Len(StrainSeq(0))
                                RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                            Next Y
                            For Y = 1 To ST
                                RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                            Next Y
                        End If
                        
                    End If
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 Then
                        Z = EN
                        Size = 1
                                  
                        If EN <= Z Then
                            For Y = EN To Z
                                RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                            Next Y
                        Else
                            For Y = EN To Len(StrainSeq(0))
                                RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                            Next Y
                            For Y = 1 To Z
                                RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                            Next Y
                        End If
                        'RecMap(En) = RecMap(En) + 1
                    End If
                End If

            End If
        End If
    
        
    Next x
    XX = ZZ
    For x = 1 To Len(StrainSeq(0))
        If ModnumY(x) > 0 Then
            RecMap(x) = CLng(RecMap(x) / ModnumY(x))
        End If
    Next x
    'Map sites to positions in type sequence that will be used to modify the plot
    
    PPMax = 0
    For x = 1 To Len(StrainSeq(0))
        If RecMap(x) > PPMax Then PPMax = RecMap(x)
    Next x
    Dim hWin As Long
    hWin = CLng(Win / 2)
    
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        
        If CircularFlag = 0 And x = 12345 Then
            ST = CLng(Win / 2)
            EN = APos(Len(StrainSeq(0))) - ST
        Else
            ST = 1
            EN = APos(Len(StrainSeq(0)))
        End If
    Else
        ST = 1
        EN = Decompress(Len(StrainSeq(0)))
        
    End If
    Dim Tot As Double
    mrs = 0
    'If PermutationX > 10000 Then
    '    PNA = PermutationX / 10000
    'Else
        PNA = 1
    'End If
    Tot = 0
    lastv = -1
    lastw = -1
    EE = 0
    For x = ST To EN
        If x = ST Then
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            'do first window
                For A = ST - hWin To ST + hWin - 1
                    If A < 1 Then
                        STX = APos(Len(StrainSeq(0))) + A
                        If STX < Len(StrainSeq(0)) Then
                            ENX = BPos(STX + 1) - 1
                        ElseIf STX = Len(StrainSeq(0)) Then
                            ENX = Len(StrainSeq(0))
                        Else
                            ENX = BPos(STX + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                        End If
                        STX = BPos(STX)
                    
                    ElseIf A > APos(Len(StrainSeq(0))) Then
                        STX = A - APos(Len(StrainSeq(0)))
                        ENX = BPos(STX + 1) - 1
                        STX = BPos(STX)
                    Else
                        ENX = BPos(A + 1) - 1
                        STX = BPos(A)
                    End If
                    If ENX = 0 Then ENX = Len(StrainSeq(0))
                    
                    
                        For Z = STX To ENX
                        
                            If Z < 1 Then
                                Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                
                            ElseIf Z > Len(StrainSeq(0)) Then
                                Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                
                            Else
                                Tot = Tot + RecMap(Z)
                                
                            End If
                        Next Z
                    
                    
                    
                
                Next A
            Else
                'do first window
                For A = ST - hWin To ST + hWin - 1
                    If A < 1 Then
                        STX = Decompress(Len(StrainSeq(0))) + A
                        If STX < Decompress(Len(StrainSeq(0))) Then
                            ENX = (STX + 1) - 1
                        ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                            ENX = Decompress(Len(StrainSeq(0)))
                        Else
                            ENX = STX + 1
                        End If
                        STX = STX
                    
                    ElseIf A > Decompress(Len(StrainSeq(0))) Then
                        STX = A - Decompress(Len(StrainSeq(0)))
                        ENX = (STX + 1) - 1
                        STX = (STX)
                    Else
                        ENX = (A + 1) - 1
                        STX = (A)
                    End If
                    If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                    If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                    
                        For V = STX To ENX
                            Z = Recompress(V)
                            If Z <> lastv Then
                                If Z < 1 Then
                                    Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                    lastw = Z
                                    
                                ElseIf Z > Len(StrainSeq(0)) Then
                                    Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                    lastw = Z
                                    
                                Else
                                    Tot = Tot + RecMap(Z)
                                    lastw = Z
                                    
                                End If
                                lastv = Z
                            End If
                        Next V
                        If Tot > 0 Then
                            x = x
                        End If
                        x = x
                    
                    
                Next A
            
            End If
            
            x = x
            
        Else
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then 'i.e. no compression
                A = x - hWin - 1
                If A < 1 Then
                    STX = APos(Len(StrainSeq(0))) + A
                    'ENX = BPos(STX - 1) + 1
                    If STX < Len(StrainSeq(0)) Then
                        ENX = BPos(STX - 1) + 1
                    ElseIf STX = Len(StrainSeq(0)) Then
                        ENX = Len(StrainSeq(0))
                    Else
                        ENX = BPos(STX + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                    End If
                    
                    STX = BPos(STX)
                
                ElseIf A > APos(Len(StrainSeq(0))) Then
                    STX = A - APos(Len(StrainSeq(0)))
                    ENX = BPos(STX - 1) + 1
                    STX = BPos(STX)
                Else
                    ENX = BPos(A - 1) + 1
                    STX = BPos(A)
                   
                End If
                'If ENx <> stx Then
                '    X = X
                'End If
                For Z = ENX To STX
                    If Z < 1 Then
                        Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                    Else
                        Tot = Tot - RecMap(Z)
                    End If
                Next Z
                A = x + hWin - 1
                If A < 1 Then
                        STX = APos(Len(StrainSeq(0))) + A
                        ENX = BPos(STX + 1) - 1
                        STX = BPos(STX)
                    
                    ElseIf A >= APos(Len(StrainSeq(0))) Then
                        STX = A - APos(Len(StrainSeq(0)))
                        ENX = BPos(STX + 1) - 1
                        STX = BPos(STX)
                    Else
                        ENX = BPos(A + 1) - 1
                        STX = BPos(A)
                    
                End If
                
                For Z = STX To ENX
                    If Z < 1 Then
                        Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                    Else
                        Tot = Tot + RecMap(Z)
                    End If
                Next Z
                If Tot < 0 Then Tot = 0 'this is needed because occasionally a -1 is possible because w're looking at breakpoints
                                        'mapped from the alignment onto individuals equences that may have gaps at particular alignment
                                        'positions
            Else 'there is compression
                A = x - hWin - 1
                If A < 1 Then
                    STX = Decompress(Len(StrainSeq(0))) + A
                    If STX < Decompress(Len(StrainSeq(0))) Then
                        ENX = (STX + 1) - 1
                    ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                        ENX = Decompress(Len(StrainSeq(0)))
                    Else
                        ENX = STX + 1
                    End If
                    STX = STX
                
                ElseIf A > Decompress(Len(StrainSeq(0))) Then
                    STX = A - Decompress(Len(StrainSeq(0)))
                    ENX = (STX + 1) - 1
                    STX = (STX)
                Else
                    ENX = (A + 1) - 1
                    STX = (A)
                End If
                If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                
                For V = STX To ENX
                    Z = Recompress(V)
                    If Z <> lastv Then
                        If Z < 1 Then
                            Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                            
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                            
                        Else
                            Tot = Tot - RecMap(Z)
                            
                        End If
                        lastv = Z
                        
                    End If
                Next V
                
                A = x + hWin - 1
                If A < 1 Then
                    STX = Decompress(Len(StrainSeq(0))) + A
                    If STX < Decompress(Len(StrainSeq(0))) Then
                        ENX = (STX + 1) - 1
                    ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                        ENX = Decompress(Len(StrainSeq(0)))
                    Else
                        ENX = STX + 1
                    End If
                    STX = STX
                
                ElseIf A > Decompress(Len(StrainSeq(0))) Then
                    STX = A - Decompress(Len(StrainSeq(0)))
                    ENX = (STX + 1) - 1
                    STX = (STX)
                Else
                    ENX = (A + 1) - 1
                    STX = (A)
                End If
                If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                
                For V = STX To ENX
                    'Z = v
                    Z = Recompress(V)
                   ' If Z = 1 Then
                   '     X = X
                   ' End If
                    
                    If Z <> lastw Then
                        If Z < 1 Then
                            Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                            
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                            
                        Else
                            Tot = Tot + RecMap(Z)
                            
                        End If
                        lastw = Z
                    End If
                Next V
                
                
                If Tot < 0 Then
                    Tot = 0 'this is needed because occasionally a -1 is possible because w're looking at breakpoints
                                        'mapped from the alignment onto individuals equences that may have gaps at particular alignment
                                        'positions
                End If
            
            
            End If
            
        End If
        
        RecMapSmooth(Recompress(x)) = Tot / Win
        '565-u,571-u-u,597-u-u-u,615-d,646-d-d,647-d-d-d,753-u,803-d,818 -u,868-d,933-u,983-d
        
        If mrs < RecMapSmooth(Recompress(x)) Then
            mrs = RecMapSmooth(Recompress(x))
        End If
        'Normalises the plot
        GoOn = 0
        
        'If X > 1541 And X < 1553 Then
        '    X = X
        'End If
        'Exit Sub
        For Z = PermutationX / 2 To PermutationX - 1
            'If z = 998 Then
            '    X = X
            'End If
            XX = UBound(PValMap, 1)
            If PValMap(Recompress(x), CLng(Z / PNA)) <= Tot Then
                GoOn = 1
                Exit For
            End If
        Next Z
        If Z = PermutationX Or PValMap(Recompress(x), CLng(Z / PNA)) = Tot Then
            GoOn = 1
            If PValMap(Recompress(x), CLng(Z / PNA)) = Tot Then
                For A = Z To 0 Step -1
                    If PValMap(Recompress(x), CLng(A / PNA)) <> Tot Then Exit For
                Next A
                STX = A + 1
                For A = Z To PermutationX
                    If PValMap(Recompress(x), CLng(A / PNA)) <> Tot Then Exit For
                Next A
                ENX = A - 1
                Z = CLng((STX + ENX) / 2)
            End If
           
        ElseIf Z = PermutationX / 2 Then
            GoOn = 0
        End If
        If GoOn = 0 Then
        
            For Z = PermutationX / 2 To 0 Step -1
                If PValMap(Recompress(x), CLng(Z / PNA)) >= Tot Then
                    GoOn = 1
                    Exit For
                End If
            Next Z
            If Z < 1 Then
                Z = TargetS(3)
            End If
        End If
        RecMapSmooth(Recompress(x)) = ((Z) / PermutationX)  'PValMap(X, RecMapSmooth(X))
        
        
        'XX = PValMap(X, 1000)
        
        XX = UBound(RecMapSmooth, 1)
        If mrs < RecMapSmooth(Recompress(x)) Then
            mrs = RecMapSmooth(Recompress(x))
        End If
        SS = Abs(GetTickCount)
        If Abs(EE - SS) > 500 Then
            Form1.SSPanel1.Caption = Trim(Str(x)) & " of " & Trim(Str(Decompress(Len(StrainSeq(0))))) & " sites done"
            If DebuggingFlag < 2 Then
                Form1.WindowState = Form1.WindowState
            End If
            Form1.Refresh
            EE = SS
            x = x
        End If
    Next x
    
    'GPerms = 5
    'Adjust recmap
    Dim RMapSmooth() As Double, RMapBounds() As Double
        ReDim RMapSmooth(GPerms, Len(StrainSeq(0)))
        ReDim RMapBounds(4, Len(StrainSeq(0)))
    If GPerms > 0 And x = 12345 Then
        
        
        For A = 1 To GPerms
            Tot = 0
            'BPListHolder(X, CPermNo)
            For x = ST To EN
                If x = ST Then
                    'do first window
                    For Z = ST - hWin To ST + hWin - 1
                        If Z < 1 Then
                            'XX = UBound(BPListHolder, 1)
                            Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                        Else
                            Tot = Tot + BPListHolder(Z, A)
                        End If
                        
                    Next Z
                    
                Else
                    Z = x - hWin
                    If Z < 1 Then
                        Tot = Tot - BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot - BPListHolder(Z, A)
                    End If
                    Z = x + hWin - 1
                    If Z < 1 Then
                        Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot + BPListHolder(Z, A)
                    End If
                    
                End If
                RMapSmooth(A, x) = Tot / Win
            Next x
        Next A
        
        
        Dim OrderArray() As Long, Tester As Double
        For Y = 1 To Len(StrainSeq(0))
            ReDim OrderArray(GPerms)
            For x = 1 To GPerms
                Tester = RMapSmooth(x, Y)
                For Z = 1 To GPerms
                    If Tester < RMapSmooth(Z, Y) Then OrderArray(x) = OrderArray(x) + 1
                Next Z
                x = x
            Next x
            Dim Target(4) As Double
            Target(0) = Int((GPerms * TargetS(3)) + 1)
            If Target(0) > GPerms Then Target(0) = GPerms
            Target(1) = Int((GPerms * TargetS(2)) + 1)
            If Target(1) > GPerms Then Target(1) = GPerms
            Target(2) = Int((GPerms * TargetS(1)))
            If Target(2) < 0 Then Target(2) = 0
            Target(3) = Int((GPerms * TargetS(0)))
            If Target(3) < 0 Then Target(3) = 0
            Target(4) = Int(GPerms * 0.5)
            
            For x = 0 To 3
                For Z = 1 To GPerms
                    If OrderArray(Z) = Target(x) Then
                        RMapBounds(x, Y) = RMapSmooth(Z, Y)
                        Exit For
                    End If
                Next Z
                If Z > GPerms Then
                    If x < 2 Then
                    'find closest smaller value to target
                        Tot = 0
                        For Z = 1 To GPerms
                            If OrderArray(Z) < Target(x) Then
                                If OrderArray(Z) > Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the smallest value
                            Tot = 0
                            For Z = 1 To GPerms
                                If OrderArray(Z) > Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                    x = x
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    Else
                        'find closest larger value to target
                        Tot = 1000000
                        For Z = 1 To GPerms
                            If OrderArray(Z) > Target(x) Then
                                If OrderArray(Z) < Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the largest value
                            Tot = 1000
                            For Z = 1 To GPerms
                                If OrderArray(Z) < Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    End If
                End If
            Next x
            Tot = 0
            For Z = 1 To GPerms
                Tot = Tot + RMapSmooth(Z, Y)
            Next Z
            RMapBounds(4, Y) = Tot / GPerms
        Next Y
        'RecMapSmooth(X)
        For x = DN To Len(StrainSeq(0)) - DN + 1
            
            RecMapSmooth(x) = RecMapSmooth(x) - RMapBounds(4, x)
        Next x
        
        For x = DN To Len(StrainSeq(0)) - DN + 1
            RMapBounds(0, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(0, x))
            RMapBounds(1, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(1, x))
            RMapBounds(2, x) = RecMapSmooth(x) - (RMapBounds(2, x) - RMapBounds(4, x))
            RMapBounds(3, x) = RecMapSmooth(x) - (RMapBounds(3, x) - RMapBounds(4, x))
            x = x
        Next x
    End If
    
    PPMax = 0
    Dim PPMin As Double
    PPMin = -1000
    For x = DN To Len(StrainSeq(0)) - DN + 1
        
        If RecMapSmooth(x) = 0 Then RecMapSmooth(x) = TargetS(3) / PermutationX
        If RecMapSmooth(x) > 0.5 Then
            RecMapSmooth(x) = 1 - RecMapSmooth(x)
            If RecMapSmooth(x) = 0 Then RecMapSmooth(x) = TargetS(3) / PermutationX
            RecMapSmooth(x) = Abs(Log10(RecMapSmooth(x)))
        Else
            RecMapSmooth(x) = Log10(RecMapSmooth(x))
        End If
        If RecMapSmooth(x) < PPMax Then PPMax = RecMapSmooth(x)
        If RecMapSmooth(x) > PPMin Then
            PPMin = RecMapSmooth(x)
        End If
        For Y = 0 To 3
            If RMapBounds(Y, x) > PPMax And GPerms > 0 Then PPMax = RMapBounds(Y, x)
            If RMapBounds(Y, x) < PPMin And GPerms > 0 Then
                PPMin = RMapBounds(Y, x)
            End If
        Next Y
    Next x
    If PPMax > Log10(TargetS(3)) Then PPMax = Log10(TargetS(3))
    
    'XX = Abs(Log10(Targets(0)))
    If PPMin < Abs(Log10(TargetS(0))) Then PPMin = Abs(Log10(TargetS(0)))
    ReDim MCPrintPos(APos(Len(StrainSeq(0))))
    ReDim MCPrintData(6, APos(Len(StrainSeq(0))))
    For Z = 1 To APos(Len(StrainSeq(0)))
        MCPrintData(0, Z) = RecMapSmooth(Z)
        MCPrintPos(Z) = Z
    Next Z
    Dim TempXDiffpos() As Long
    ReDim TempXDiffpos(Len(StrainSeq(0)))
    Z = 1
    For x = 1 To Len(StrainSeq(0))
        TempXDiffpos(x) = XDiffPos(x)
        XDiffPos(x) = 0
        If RecMap(x) > 0 Then
            XDiffPos(Z) = x
            Z = Z + 1
        End If
        
    Next x
    For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
        
        XDiffPos(x) = APos(XDiffPos(x))
        MCPrintData(6, x) = XDiffPos(x)
        
    Next x
    olenxoverseq = LenXoverSeq
    LenXoverSeq = Z
    MinPVal = PPMax
    MCMinChiP = PPMax
    PPMax = -4
    PPMin = 4
    'GYAxHi(1) = APos(Decompress(Len(StrainSeq(0))))
    'DoAxes 1, APos(Decompress(Len(StrainSeq(0)))), TypeSeq, PPMax, PPMin, 1, "Log(P-val)/-log(P-val)"
    
    
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
       GYAxHi(1) = APos(Decompress(Len(StrainSeq(0))))
       ' DoAxes 1, APos(Decompress(Len(StrainSeq(0)))), TypeSeq, PPMax, PPMin, 1, "Log(P-val)/-log(P-val)"
    Else
       GYAxHi(1) = Decompress(Len(StrainSeq(0)))
       ' DoAxes 1, Decompress(Len(StrainSeq(0))), TypeSeq, PPMax, PPMin, 1, "Log(P-val)/-log(P-val)"
    End If
    
    RDPUD = PPMax
    LenXoverSeq = olenxoverseq
    BSStepWin = Win
    
    
    Dim PV As Double
    LOffset = 30
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        WFactor = ((Form1.Picture7.Width - 40) / Decompress(APos(Len(StrainSeq(0)))))
    Else
        WFactor = ((Form1.Picture7.Width - 40) / Decompress((Len(StrainSeq(0)))))
    End If
    HFactor = (PicHeight - 35)
    TOffset = 20
    Dim PntAPI As POINTAPI
    If Form1.Picture7.DrawWidth = 0 Then Form1.Picture7.DrawWidth = 1
    Form1.Picture7.DrawStyle = 2
    'MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RecMapSmooth(1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    
    MhDC = Form1.Picture7.hdc
    
    
    
    Form1.Picture7.DrawStyle = 0
    
    
    If x = x Then
    'show only local 99 and 95% CIs
        Form1.Picture7.ForeColor = RGB(255, 255, 255)
        xY = Log10(TargetS(0))
        XX = Log10(TargetS(0)) / (PPMax)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (Log10(Targets(0)) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (Abs(Log10(Targets(0))) - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Log10(Targets(0)) - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Abs(Log10(Targets(0))) - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X
'        Form1.Picture7.ForeColor = RGB(150, 150, 150)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (Log10(Targets(1)) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (Abs(Log10(Targets(1))) - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Log10(Targets(1)) - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Abs(Log10(Targets(1))) - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X
    Else
        
    End If
    
    Form1.Picture7.ForeColor = RGB(128, 128, 128)
   
    Form1.Picture7.ForeColor = RGB(130, 130, 130)
    MCPrintData(1, 1) = Log10(TargetS(1))
'    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (Log10(Targets(1)) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Log10(Targets(1)) - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(1, x) = Log10(TargetS(1))
    Next x
    MCPrintData(2, 1) = Abs(Log10(TargetS(1)))
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (Abs(Log10(Targets(1))) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Abs(Log10(Targets(1))) - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(2, x) = Abs(Log10(TargetS(1)))
    Next x
    Form1.Picture7.ForeColor = RGB(200, 200, 200)
    MCPrintData(3, 1) = Log10(TargetS(0))
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (Log10(Targets(0)) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Log10(Targets(0)) - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(3, x) = Log10(TargetS(0))
    Next x
    MCPrintData(4, 1) = Abs(Log10(TargetS(0)))
'    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (Abs(Log10(Targets(0))) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (Abs(Log10(Targets(0))) - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(4, x) = Abs(Log10(TargetS(0)))
    Next x
    Form1.Picture7.ForeColor = 0
    If GPerms > 0 Then
        Form1.Picture7.DrawWidth = CLng((Form1.Picture7.ScaleWidth - LOffset * 2) / Len(StrainSeq(0)) + 0.5)
        
        Form1.Picture7.DrawStyle = 0
        For x = 0 To 1
            If x = 0 Or x = 3 Then
                Form1.Picture7.ForeColor = HalfColour
                Y = 3
            Else
                Form1.Picture7.ForeColor = RGB(128, 128, 128)
                Y = 2
            End If
            MhDC = Form1.Picture7.hdc
'            MoveToEx MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RMapBounds(X, 1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RMapBounds(Y, 1) - PPMin) / (PPMax - PPMin)) * HFactor
'            For Z = 2 To APos(Len(StrainSeq(0)))
'
'                MhDC = Form1.Picture7.hDC
'                LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RMapBounds(X, Z) - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RMapBounds(Y, Z) - PPMin) / (PPMax - PPMin)) * HFactor
'            Next Z
        Next x
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.DrawStyle = 0
        Form1.Picture7.ForeColor = 0
'        MoveToEx MhDC, LOffset - 5 + 0 * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor
        
    End If
    
    Form1.Picture7.ForeColor = 0
    MhDC = Form1.Picture7.hdc
'    MoveToEx MhDC, LOffset + Decompress(DN) * WFactor, TOffset + (1 - (RecMapSmooth(DN) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'    For Z = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'
'        MhDC = Form1.Picture7.hDC
'        LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RecMapSmooth(Z) - PPMin) / (PPMax - PPMin)) * HFactor
'    Next Z
    
    
    
'get everything into standard save/copy format
GPrintNum = 2 'three lines
NSites = APos(Len(StrainSeq(0)))
ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)

ReDim GVarPos(0, NSites)
For x = 1 To NSites
    GVarPos(0, x) = XDiffPos(x)
Next x
For x = 1 To Len(StrainSeq(0))
    XDiffPos(x) = TempXDiffpos(x)
Next x

ReDim GCritval(10)



'GCritval(2) = BPCVal(0, 0)
'GCritval(3) = BPCVal(0, 1)

GLegend = "Log(P-val)/-log(P-val)"
GPrintLen = NSites * 2  'how many points to plot
GPrintCol(2) = 0 'line is black
GPrintCol(0) = RGB(198, 198, 198) ' 'line is grey
GPrintCol(1) = RGB(128, 128, 128) 'line is light grey

GPrintType = 0 'a normal line plot
GPrintMin(0) = PPMin  'bottom val
GPrintMin(1) = PPMax  'upper val


'Form1.Picture7.ForeColor = RGB(255, 255, 255)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * Targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * Targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X
'        Form1.Picture7.ForeColor = RGB(150, 150, 150)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * Targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * Targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X

For x = 0 To NSites - 1
    
    GPrint(2, x) = RecMapSmooth(x + 1)  'GraphPlt(0, X)
    'GPrint(0, NSites * 2 - X) = RecMapSmooth(X + 1)  'GraphPlt(0, X)
    GPrintPos(2, x) = x + 1 'PltPos(X)
    'GPrintPos(0, NSites * 2 - X) = X + 1 ' PltPos(X)
    
    
Next x

GBlockNum = -1



For x = 0 To NSites - 1
    'PValMap(DN, PermutationX * Targets(0))
    GPrint(0, x) = Log10(TargetS(0)) 'GraphPlt(1, X)
    GPrint(0, NSites * 2 - x) = Abs(Log10(TargetS(0))) 'GraphPlt(2, X)
    GPrintPos(0, x) = x + 1 'PltPos(X)
    GPrintPos(0, NSites * 2 - x) = x + 1 'PltPos(X)
    
    GPrint(1, x) = Log10(TargetS(1)) 'GraphPlt(1, X)
    GPrint(1, NSites * 2 - x) = Abs(Log10(TargetS(1))) 'GraphPlt(2, X)
    GPrintPos(1, x) = x + 1 'PltPos(X)
    GPrintPos(1, NSites * 2 - x) = x + 1 'PltPos(X)
Next x
GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
GPrintPos(1, GPrintLen - 1) = GPrintPos(1, 0)
'GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
'GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
GPrintPos(1, GPrintLen) = GPrintPos(1, 0)
'GPrint(0, GPrintLen - 1) = GPrint(0, 0)
GPrint(0, GPrintLen - 1) = GPrint(0, GPrintLen - 2)
GPrint(0, GPrintLen) = GPrint(0, 0)
GPrint(1, GPrintLen - 1) = GPrint(1, GPrintLen - 2)
GPrint(1, GPrintLen) = GPrint(1, 0)
GExtraTNum = 2
ReDim GExtraText(GExtraTNum)
GExtraText(2) = "Breakpoint clustering log(p-value)"
GExtraText(0) = "Local 95% confidence interval"
GExtraText(1) = "Local 99% confidence interval"

Erase PValMap
Call RedrawPlotAA(1)
    
    Form1.Picture7.Refresh
End Sub
Public Sub RecombMapIIIb()
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double, Win As Long
    
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Dim PermutationX As Long
    
    PermutationX = MatPermNo
    If PermutationX > 10000 Then PermutationX = 10000
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
    
    Dim BPV() As Double
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
    
    For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                    If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                        BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                    End If
                End If
            Next Y
    Next x
    Dim PValCon As Double
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
    
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Enu = SuperEventList(XoverList(x, Y).Eventnumber)
            If Enu = 4 Then
                x = x
            End If
            'If Enu = 3 Then
            '    X = X
            'End If
            NC = 0
            If BPV(Enu, 0) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 1) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 3) < LowestProb Then
                
                NC = NC + 1
                
            ElseIf BPV(Enu, 4) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 2) < LowestProb Then
                
                NC = NC + 1
                
            End If
            If BPV(Enu, 5) < LowestProb Then
                
                NC = NC + 1
                
            End If
            
            If XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 Then
                Excl(Enu) = 1
            Else
                x = x
            End If
        Next Y
    Next x
'    For X = 0 To SEventNumber
'        XX = Excl(X)
'    Next X
    
    Dim BPos() As Long, TypeSeq
    Call MakeAPos(APos(), BPos())
    
    TypeSeq = TypeSeqNumber
    
    Win = MatWinSize
    If Win = 0 Then Win = 200
    b = 0
    C = 0
    If BPCvalFlag = 0 Or x = x Then
        BPCvalFlag = 1
        ReDim BPCVal(1, 1)
         Dim DN As Long
        DN = 1
        Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
        x = x
    End If
    If AbortFlag = 1 Then
        Screen.MousePointer = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        AbortFlag = 0
        Exit Sub
    End If
    ZZ = 0
    
    'Make exclusions
    yyy = 0
    For x = 1 To ENumb
        
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
           
            
            If x = x Then
                D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 Then
                        RecMap(APos(ST)) = RecMap(APos(ST)) + 1
                        If APos(ST) > 2750 Then
                            yyy = yyy + 1
                        End If
                    End If
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 Then
                        RecMap(APos(EN)) = RecMap(APos(EN)) + 1
                        If APos(EN) > 2750 Then
                            yyy = yyy + 1
                        End If
                        'RecMap(En) = RecMap(En) + 1
                    End If
                    
                End If

            End If
        End If
    
        
    Next x
    
    
    'Map sites to positions in type sequence that will be used to modify the plot
    
    PPMax = 0
    For x = 1 To Len(StrainSeq(0))
        If RecMap(x) > PPMax Then PPMax = RecMap(x)
    Next x
    Dim hWin As Long
    hWin = CLng(Win / 2)
    
    If CircularFlag = 0 And x = 12345 Then
        ST = CLng(Win / 2)
        EN = APos(Len(StrainSeq(0))) - ST
    Else
        ST = 1
        EN = APos(Len(StrainSeq(0)))
    End If
    Dim Tot As Double
    For x = ST To EN
        If x = ST Then
            'do first window
            For A = (ST - hWin) To (ST + hWin - 1)
                
               If A < 1 Then
                    STX = APos(Len(StrainSeq(0))) + A
               ElseIf A > APos(Len(StrainSeq(0))) Then
                    STX = A - APos(Len(StrainSeq(0)))
               Else
                    STX = A
               End If
               Tot = Tot + RecMap(STX)
                     
                
                
            Next A
            x = x
            
        Else
            A = x - hWin
            If A < 1 Then
                 STX = APos(Len(StrainSeq(0))) + A
            ElseIf A > APos(Len(StrainSeq(0))) Then
                 STX = A - APos(Len(StrainSeq(0)))
            Else
                 STX = A
            End If
            Tot = Tot - RecMap(STX)
                
            A = x + hWin - 1
            If A < 1 Then
                 STX = APos(Len(StrainSeq(0))) + A
            ElseIf A > APos(Len(StrainSeq(0))) Then
                 STX = A - APos(Len(StrainSeq(0)))
            Else
                 STX = A
            End If
            
            Tot = Tot + RecMap(STX)
        End If
        RecMapSmooth(x) = Tot / Win
    Next x
    
    'GPerms = 5
    'Adjust recmap
    Dim RMapSmooth() As Double, RMapBounds() As Double
        ReDim RMapSmooth(GPerms, Len(StrainSeq(0)))
        ReDim RMapBounds(4, Len(StrainSeq(0)))
    If GPerms > 0 Then
        
        
        For A = 1 To GPerms
            Tot = 0
            'BPListHolder(X, CPermNo)
            For x = ST To EN
                If x = ST Then
                    'do first window
                    For Z = ST - hWin To ST + hWin - 1
                        If Z < 1 Then
                            'XX = UBound(BPListHolder, 1)
                            Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                        Else
                            Tot = Tot + BPListHolder(Z, A)
                        End If
                        
                    Next Z
                    
                Else
                    Z = x - hWin
                    If Z < 1 Then
                        Tot = Tot - BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot - BPListHolder(Z, A)
                    End If
                    Z = x + hWin - 1
                    If Z < 1 Then
                        Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot + BPListHolder(Z, A)
                    End If
                    
                End If
                RMapSmooth(A, x) = Tot / Win
            Next x
        Next A
        
        
        Dim OrderArray() As Long, Tester As Double
        For Y = 1 To Len(StrainSeq(0))
            ReDim OrderArray(GPerms)
            For x = 1 To GPerms
                Tester = RMapSmooth(x, Y)
                For Z = 1 To GPerms
                    If Tester < RMapSmooth(Z, Y) Then OrderArray(x) = OrderArray(x) + 1
                Next Z
                x = x
            Next x
            Dim Target(4) As Double
            Target(0) = Int((GPerms * 0.99) + 1)
            If Target(0) > GPerms Then Target(0) = GPerms
            Target(1) = Int((GPerms * 0.95) + 1)
            If Target(1) > GPerms Then Target(1) = GPerms
            Target(2) = Int((GPerms * 0.05))
            If Target(2) < 0 Then Target(2) = 0
            Target(3) = Int((GPerms * 0.01))
            If Target(3) < 0 Then Target(3) = 0
            Target(4) = Int(GPerms * 0.5)
            
            For x = 0 To 3
                For Z = 1 To GPerms
                    If OrderArray(Z) = Target(x) Then
                        RMapBounds(x, Y) = RMapSmooth(Z, Y)
                        Exit For
                    End If
                Next Z
                If Z > GPerms Then
                    If x < 2 Then
                    'find closest smaller value to target
                        Tot = 0
                        For Z = 1 To GPerms
                            If OrderArray(Z) < Target(x) Then
                                If OrderArray(Z) > Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the smallest value
                            Tot = 0
                            For Z = 1 To GPerms
                                If OrderArray(Z) > Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                    x = x
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    Else
                        'find closest larger value to target
                        Tot = 1000000
                        For Z = 1 To GPerms
                            If OrderArray(Z) > Target(x) Then
                                If OrderArray(Z) < Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the largest value
                            Tot = 1000
                            For Z = 1 To GPerms
                                If OrderArray(Z) < Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    End If
                End If
            Next x
            Tot = 0
            For Z = 1 To GPerms
                Tot = Tot + RMapSmooth(Z, Y)
            Next Z
            RMapBounds(4, Y) = Tot / GPerms
        Next Y
        'RecMapSmooth(X)
        For x = DN To Len(StrainSeq(0)) - DN + 1
            RecMapSmooth(x) = RecMapSmooth(x) - RMapBounds(4, x)
        Next x
        
        For x = DN To Len(StrainSeq(0)) - DN + 1
            RMapBounds(0, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(0, x))
            RMapBounds(1, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(1, x))
            RMapBounds(2, x) = RecMapSmooth(x) - (RMapBounds(2, x) - RMapBounds(4, x))
            RMapBounds(3, x) = RecMapSmooth(x) - (RMapBounds(3, x) - RMapBounds(4, x))
            x = x
        Next x
    End If
    PPMax = 0
    Dim PPMin As Double
    PPMin = 100
    For x = DN To Len(StrainSeq(0)) - DN + 1
        If RecMapSmooth(x) > PPMax Then
            PPMax = RecMapSmooth(x)
        End If
        If RecMapSmooth(x) < PPMin Then PPMin = RecMapSmooth(x)
        For Y = 0 To 3
            If RMapBounds(Y, x) > PPMax Then PPMax = RMapBounds(Y, x)
            If RMapBounds(Y, x) < PPMin Then PPMin = RMapBounds(Y, x)
        Next Y
    Next x
    If PPMax < (BPCVal(0, 0) / Win) Then PPMax = BPCVal(0, 0) / Win
    
    ReDim MCPrintPos(APos(Len(StrainSeq(0))))
    ReDim MCPrintData(6, APos(Len(StrainSeq(0))))
    For Z = 1 To APos(Len(StrainSeq(0)))
        MCPrintData(0, Z) = RecMapSmooth(Z)
        MCPrintPos(Z) = Z
    Next Z
    Dim TempXDiffpos() As Long
    ReDim TempXDiffpos(Len(StrainSeq(0)))
    Z = 1
    For x = 1 To Len(StrainSeq(0))
        TempXDiffpos(x) = XDiffPos(x)
        XDiffPos(x) = 0
        If RecMap(x) > 0 Then
            XDiffPos(Z) = x
            Z = Z + 1
        End If
        
    Next x
    For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
        
        
        MCPrintData(6, x) = XDiffPos(x)
        
    Next x
    olenxoverseq = LenXoverSeq
    LenXoverSeq = Z
    MinPVal = PPMax
    MCMinChiP = PPMax
    DoAxes 0, 1, APos(Decompress(Len(StrainSeq(0)))), TypeSeq, PPMax * Win, PPMin * Win, 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"
    RDPUD = PPMax * Win
    LenXoverSeq = olenxoverseq
    BSStepWin = Win
    
    
    Dim PV As Double
    LOffset = 30
    WFactor = ((Form1.Picture7.Width - 40) / APos(Len(StrainSeq(0))))
    HFactor = (PicHeight - 35)
    TOffset = 20
    Dim PntAPI As POINTAPI
    If Form1.Picture7.DrawWidth = 0 Then Form1.Picture7.DrawWidth = 1
    Form1.Picture7.DrawStyle = 2
    'MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RecMapSmooth(1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    MhDC = Form1.Picture7.hdc
    MoveToEx MhDC, LOffset + 1 * WFactor - 5, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor
    
    MoveToEx MhDC, LOffset - 5 + 1 * WFactor, TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    LineTo MhDC, LOffset + Len(StrainSeq(0)) * WFactor, TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
    
    
    MCPrintData(5, 0) = BPCVal(0, 0) / Win
    MCPrintData(5, 1) = BPCVal(0, 1) / Win
    
    Form1.Picture7.DrawStyle = 0
    
    XX = UBound(PValMap, 2)
    
    If GPerms = 0 Then
        If x = x Then
        'show only local 99 and 95% CIs
            Form1.Picture7.ForeColor = RGB(255, 255, 255)
            MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * 0.01) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
            LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * 0.99) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
                LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, PermutationX * 0.01) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, PermutationX * 0.99) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            Next x
            Form1.Picture7.ForeColor = RGB(150, 150, 150)
            MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * 0.05) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
            LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * 0.95) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
                LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, PermutationX * 0.05) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, PermutationX * 0.95) / Win - PPMin) / (PPMax - PPMin)) * HFactor
            Next x
        Else
            'do coulourful plot
            For Z = PermutationX To PermutationX / 2 Step -1
                If Z > 0.75 * PermutationX Then
                    Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - PermutationX / 2) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX * 0.75)) / (PermutationX * 0.25)))
                Else
                    Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (255 - 255 * ((PermutationX * 0.75) - Z) / (PermutationX * 0.25)))
                End If
                
                'Form1.Picture7.ForeColor = RGB(127 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50)
                'Form1.Picture7.ForeColor = RGB(200 + 55 * (Z - 50) / 50, 0 + 255 * (Z - 50) / 50, 127 + 128 * (Z - 50) / 50)
                
                MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValMap(1, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
                LineTo MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0))), Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                For x = 2 To APos(Len(StrainSeq(0)))
                    LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                    LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                Next x
            x = x
            Next Z
        End If
    End If
    Form1.Picture7.ForeColor = RGB(128, 128, 128)
   ' MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValmap( 1, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
   ' For X = 2 To Len(StrainSeq(0))
   '     LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValmap( X, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
   ' Next X
    Form1.Picture7.ForeColor = RGB(130, 130, 130)
    MCPrintData(1, 1) = PValMap(1, 0.05 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.05 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, 0.05 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(1, x) = PValMap(x, 0.05 * PermutationX) / Win
    Next x
    MCPrintData(2, 1) = PValMap(1, 0.95 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.95 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, 0.95 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(2, x) = PValMap(x, 0.95 * PermutationX) / Win
    Next x
    Form1.Picture7.ForeColor = RGB(200, 200, 200)
    MCPrintData(3, 1) = PValMap(1, 0.01 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.01 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, 0.01 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(3, x) = PValMap(x, 0.01 * PermutationX) / Win
    Next x
    MCPrintData(4, 1) = PValMap(1, 0.99 * PermutationX) / Win
    MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, 0.99 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
        LineTo MhDC, LOffset + x * WFactor, TOffset + (1 - (PValMap(x, 0.99 * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(4, x) = PValMap(x, 0.99 * PermutationX) / Win
    Next x
    Form1.Picture7.ForeColor = 0
    If GPerms > 0 Then
        Form1.Picture7.DrawWidth = CLng((Form1.Picture7.ScaleWidth - LOffset * 2) / Len(StrainSeq(0)) + 0.5)
        'Form1.Picture7.Picture = LoadPicture()
        Form1.Picture7.DrawStyle = 0
        For x = 0 To 1
            If x = 0 Or x = 3 Then
                Form1.Picture7.ForeColor = HalfColour
                Y = 3
            Else
                Form1.Picture7.ForeColor = RGB(128, 128, 128)
                Y = 2
            End If
            MhDC = Form1.Picture7.hdc
            MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RMapBounds(x, 1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
            LineTo MhDC, LOffset + BE * WFactor, TOffset + (1 - (RMapBounds(Y, 1) - PPMin) / (PPMax - PPMin)) * HFactor
            For Z = 2 To APos(Len(StrainSeq(0)))
            
                MhDC = Form1.Picture7.hdc
                LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - (RMapBounds(x, Z) - PPMin) / (PPMax - PPMin)) * HFactor
                LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - (RMapBounds(Y, Z) - PPMin) / (PPMax - PPMin)) * HFactor
            Next Z
        Next x
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.DrawStyle = 0
        Form1.Picture7.ForeColor = 0
        MoveToEx MhDC, LOffset - 5 + 0 * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
        LineTo MhDC, LOffset + APos(Len(StrainSeq(0))) * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor
        
    End If
    
    Form1.Picture7.ForeColor = 0
    MhDC = Form1.Picture7.hdc
    MoveToEx MhDC, LOffset + DN * WFactor, TOffset + (1 - (RecMapSmooth(DN) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For Z = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
    
        MhDC = Form1.Picture7.hdc
        LineTo MhDC, LOffset + Z * WFactor, TOffset + (1 - (RecMapSmooth(Z) - PPMin) / (PPMax - PPMin)) * HFactor
    Next Z
    
    
    
'get everything into standard save/copy format
GPrintNum = 2 'three lines
NSites = APos(Len(StrainSeq(0)))
ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)

ReDim GVarPos(0, NSites)
For x = 1 To NSites
    GVarPos(0, x) = XDiffPos(x)
Next x
For x = 1 To Len(StrainSeq(0))
    XDiffPos(x) = TempXDiffpos(x)
Next x

ReDim GCritval(10)



GCritval(2) = BPCVal(0, 0)
GCritval(3) = BPCVal(0, 1)

GLegend = "Breakpoints per " & Trim(Str(Win)) & " nt window"
GPrintLen = NSites * 2  'how many points to plot
GPrintCol(0) = 0 'line is black
GPrintCol(1) = RGB(128, 128, 128) 'line is grey
GPrintCol(2) = RGB(198, 198, 198) 'line is light grey

GPrintType = 0 'a normal line plot
GPrintMin(0) = PPMin * Win  'bottom val
GPrintMin(1) = PPMax * Win 'upper val


'Form1.Picture7.ForeColor = RGB(255, 255, 255)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * 0.01) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * 0.99) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.01) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.99) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X
'        Form1.Picture7.ForeColor = RGB(150, 150, 150)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * 0.05) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * 0.95) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.05) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * 0.95) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X

For x = 0 To NSites - 1
    
    GPrint(0, x) = RecMapSmooth(x + 1) * Win 'GraphPlt(0, X)
    GPrint(0, NSites * 2 - x) = RecMapSmooth(x + 1) * Win 'GraphPlt(0, X)
    GPrintPos(0, x) = x + 1 'PltPos(X)
    GPrintPos(0, NSites * 2 - x) = x + 1 ' PltPos(X)
    
    
Next x

GBlockNum = -1



For x = 0 To NSites - 1
    'PValMap(DN, PermutationX * 0.01)
    GPrint(1, x) = PValMap(x + 1, PermutationX * 0.05) 'GraphPlt(1, X)
    GPrint(1, NSites * 2 - x) = PValMap(x + 1, PermutationX * 0.95) 'GraphPlt(2, X)
    GPrintPos(1, x) = x + 1 'PltPos(X)
    GPrintPos(1, NSites * 2 - x) = x + 1 'PltPos(X)
    
    GPrint(2, x) = PValMap(x + 1, PermutationX * 0.01) 'GraphPlt(1, X)
    GPrint(2, NSites * 2 - x) = PValMap(x + 1, PermutationX * 0.99) 'GraphPlt(2, X)
    GPrintPos(2, x) = x + 1 'PltPos(X)
    GPrintPos(2, NSites * 2 - x) = x + 1 'PltPos(X)
Next x
GPrintPos(1, GPrintLen - 1) = GPrintPos(1, 0)
GPrintPos(2, GPrintLen - 1) = GPrintPos(2, 0)
GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
GPrintPos(1, GPrintLen) = GPrintPos(1, 0)
GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
GPrintPos(2, GPrintLen) = GPrintPos(2, 0)
GPrint(0, GPrintLen - 1) = GPrint(0, 0)
GPrint(1, GPrintLen - 1) = GPrint(1, GPrintLen - 2)
GPrint(1, GPrintLen) = GPrint(1, 0)
GPrint(2, GPrintLen - 1) = GPrint(2, GPrintLen - 2)
GPrint(2, GPrintLen) = GPrint(2, 0)
GExtraTNum = 2
ReDim GExtraText(GExtraTNum)
GExtraText(0) = "Breakpoint number"
GExtraText(1) = "Local 95% confidence interval"
GExtraText(2) = "Local 99% confidence interval"


    
    Erase PValMap
    Form1.Picture7.Refresh
End Sub
Public Sub RecMapOut()
    Dim RecMapSmooth() As Double, Win As Long
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Win = 100
    b = 0
    C = 0
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    For x = 1 To ENumb
        If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Probability > 0 Then
            CNum = 0
            If LongWindedFlag = 0 Then
                SEN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber
            Else
                SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
            End If
            
            For Z = 0 To AddNum - 1
                If Confirm(SEN, Z) > 0 Then
                    CNum = CNum + 1
                End If
            Next Z
            If CNum > ConsensusProg Then
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                RecMap(ST) = RecMap(ST) + 1
                RecMap(EN) = RecMap(EN) + 1

            End If

        
        End If
    
        
    Next x
    PPMax = 0
    For x = 1 To Len(StrainSeq(0))
        If RecMap(x) > PPMax Then PPMax = RecMap(x)
    Next x
    Dim hWin As Long
    hWin = CLng(Win / 2)
    
    If CircularFlag = 1 Then
        ST = CLng(Win / 2)
        EN = Len(StrainSeq(0)) - ST
    Else
        ST = 1
        EN = Len(StrainSeq(0))
    End If
    Dim Tot As Long
    For x = ST To EN
        If x = ST Then
            'do first window
            For Z = ST - hWin To ST + hWin - 1
                If Z < 1 Then
                    Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                ElseIf Z > Len(StrainSeq(0)) Then
                    Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                Else
                    Tot = Tot + RecMap(Z)
                End If
                
            Next Z
            
        Else
            Z = x - hWin
            If Z < 1 Then
                Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
            ElseIf Z > Len(StrainSeq(0)) Then
                Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
            Else
                Tot = Tot - RecMap(Z)
            End If
            Z = x + hWin - 1
            If Z < 1 Then
                Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
            ElseIf Z > Len(StrainSeq(0)) Then
                Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
            Else
                Tot = Tot + RecMap(Z)
            End If
            
        End If
        RecMapSmooth(x) = Tot / Win
    Next x
    Dim SpaceSeq() As Long
    ReDim SpaceSeq(Len(StrainSeq(0)))
    For x = 1 To Len(StrainSeq(0))
        If SeqNum(x, 0) > 50 Then
            Y = Y + 1
            SpaceSeq(Y) = x
        End If
    Next x
    
    Dim TargetLen As Long
    
    If SeqSpacesInFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        'Dim OS1 As Long
        'OS1 = RecSeq * (Len(StrainSeq(0)) + 3)
        Open "RDP5SSFile" + UFTag For Binary As #FF
        Get #FF, (((Len(StrainSeq(0))) - 1) * 4) + 1, TargetLen
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    Else
        TargetLen = SeqSpaces(Len(StrainSeq(0)), 0)
    
    End If
        
        
        For x = 1 To Len(StrainSeq(0)) - TargetLen
        'SSVal(5) = SeqSpaces(ee3, RecSeq)
            
            Print #10, x & "," & Str(RecMapSmooth(SpaceSeq(x)))
        Next x
        
        
    
    
End Sub
Public Sub SaveWMFPlot()

    Dim VOut As String
    WMFName = "c:/testwmf.wmf"
    Dim PolyPoints() As POINTAPI
    Dim Pen2 As Long, SP As Long, EP As Long
    Dim PColIn As Long, HFactor As Double, WFactor As Double
    Dim OldFont As Long, oldpen As Long, PEN As Long, LOffset As Long, TOffset As Long, MhDC As Long, EMFCls As Long
    Dim PntAPI As POINTAPI
    Dim LPn As LOGPEN
    Dim red As Long, Green2 As Long, blue As Long, PA As POINTAPI
    'LPn.lopnColor = RGB(255, 0, 0)
    'LPn.lopnWidth.XPos = 5
    'LPn.lopnWidth.Y = 5
    'LPn.lopnStyle = 0
    PA.x = 0.75
    PA.Y = 0.75
    Dim rct As RECT
    Dim LoFnt As Long
    If CLine = "" Or CLine = " " Then
        If CopyFlag = 0 Then
    
            With Form1.CommonDialog1
                .FileName = ""
                '.InitDir = currentdir
                .DefaultExt = ".emf"   'Specify the default extension.
                'Specify which file extensions will be preferred.
                '.Filter = "DNA Man Multiple Alignment Files (*.msd)|*.msd|Alignment Files (*.ali)|*.ali|RDP Project Files (*.rdp)|*.rdp|Sequence Files (*.seq)|*.seq|all files (*.*)|*.*"
                .Filter = "EMF File (*.emf)|*.emf"
                '.InitDir = "c:/darren/DNA Man/msvstrai/dna project/"
                .Action = 2 'Specify that the "open file" action is required.
                semfname$ = .FileName  'Stores selected file name in the
                'string, fname$.
                semfnameII = .FileTitle
            End With
    
        Else
            If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "tmp2.emf"
            On Error GoTo 0
            semfnameII = "tmp2.emf"
            semfname$ = "tmp2.emf"
        End If
    Else
        If SaveTxtFlag = 12 Then
            semfname$ = InFileX + " breakpoint distribution.emf"
        ElseIf SaveTxtFlag = 22 Then
            semfname$ = InFileX + " breakpoint cluster probability distribution.emf"
        End If
    End If
    Dim hdcRef As Long, hWndX As Long
    hWndX = Form1.Picture7.hwnd
    hdcRef = GetDC(hWndX)
    
    
    
'
'// Determine the picture frame dimensions.
'// iWidthMM is the display width in millimeters.
'// iHeightMM is the display height in millimeters.
'// iWidthPels is the display width in pixels.
'// iHeightPels is the display height in pixels
'
iWidthMM = GetDeviceCaps(hdcRef, HORZSIZE)
iHeightMM = GetDeviceCaps(hdcRef, VERTSIZE)
iWidthPels = GetDeviceCaps(hdcRef, HORZRES)
iHeightPels = GetDeviceCaps(hdcRef, VERTRES)
'
'// Retrieve the coordinates of the client
'// rectangle, in pixels.
'
GetClientRect hWndX, rct
'
'// Convert client coordinates to .01-mm units.
'// Use iWidthMM, iWidthPels, iHeightMM, and
'// iHeightPels to determine the number of
'// .01-millimeter units per pixel in the x-
'//  and y-directions.
'
rct.Left = (rct.Left * iWidthMM * 100) / iWidthPels
rct.Top = (rct.Top * iHeightMM * 100) / iHeightPels
rct.Right = (rct.Right * iWidthMM * 100) / iWidthPels
rct.Bottom = (rct.Bottom * iHeightMM * 100) / iHeightPels
'
 ReleaseDC hWndX, hdcRef
 
'    rct.Left = 0
'    rct.Top = 0
'    rct.Right = 30000
'    rct.Bottom = 12000
            
            
            
            
    Dim AxLen As Long, AxStr As String
    
    If TypeSeqNumber > NextNo Then TypeSeqNumber = 0
    AxLen = GYAxHi(1)
    If AxLen = 0 Then Exit Sub
    If GYAxHi(1) <> Len(StrainSeq(0)) And Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
        AxStr = "Nucleotide position in relation to " + OriginalName(TypeSeqNumber)
    Else
            
        AxStr = "Position in alignment"
    End If
    
    HFactor = 200
    WFactor = 500 / AxLen
    LOffset = 70
    TOffset = 60
    'killfile "c:\test18.emf"
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture7.hdc, semfname$, rct, "")
    Form1.Picture1.AutoRedraw = True
    'Get original Metafile font and pen
    LoFnt = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    OldFont = SelectObject(MhDC, LoFnt)
    PEN = CreatePenIndirect(LPn)
    oldpen = SelectObject(MhDC, PEN)
    
    LPn.lopnColor = 0
    LPn.lopnWidth = PA
    LPn.lopnStyle = 0
    PEN = CreatePenIndirect(LPn)
    Pen2 = SelectObject(MhDC, PEN)
    
    
    'MoveToEx MhDC, 1000, 1000, PntAPI
    'LineTo MhDC, 29000, 11000
    
    'Draw Axes
    MoveToEx MhDC, LOffset - 10, TOffset - 10, PntAPI
    LineTo MhDC, LOffset - 10, TOffset
    LineTo MhDC, LOffset - 5, TOffset
    LineTo MhDC, LOffset - 10, TOffset
    'LineTo MhDC, LOffset - 10, TOffset
    
    LineTo MhDC, LOffset - 10, TOffset + HFactor / 4
    LineTo MhDC, LOffset - 5, TOffset + HFactor / 4
    LineTo MhDC, LOffset - 10, TOffset + HFactor / 4
    
    LineTo MhDC, LOffset - 10, TOffset + HFactor / 2
    LineTo MhDC, LOffset - 5, TOffset + HFactor / 2
    LineTo MhDC, LOffset - 10, TOffset + HFactor / 2
    
    LineTo MhDC, LOffset - 10, TOffset + (HFactor / 4) * 3
    LineTo MhDC, LOffset - 5, TOffset + (HFactor / 4) * 3
    LineTo MhDC, LOffset - 10, TOffset + (HFactor / 4) * 3
    
    
    LineTo MhDC, LOffset - 10, TOffset + HFactor
    LineTo MhDC, LOffset - 5, TOffset + HFactor
    LineTo MhDC, LOffset - 10, TOffset + HFactor
    LineTo MhDC, LOffset - 10, TOffset + HFactor + 10
    LineTo MhDC, LOffset, TOffset + HFactor + 10
    LineTo MhDC, LOffset, TOffset + HFactor + 5
    LineTo MhDC, LOffset, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen / 4, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen / 4, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * AxLen / 4, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen / 2, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen / 2, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * AxLen / 2, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen / 1.333, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen / 1.333, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * AxLen / 1.333, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen, TOffset + HFactor + 5
    LineTo MhDC, LOffset + WFactor * AxLen, TOffset + HFactor + 10
    LineTo MhDC, LOffset + WFactor * AxLen + 10, TOffset + HFactor + 10
    SetBkColor MhDC, RGB(255, 255, 255)
    LoFnt = CreateFont(12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
    SelectObject MhDC, LoFnt
    'If AxLen > Len(StrainSeq(0)) Then
    '    AxLen = Len(StrainSeq(0))
    '    WFactor = 500 / AxLen
    'End If
    
    'x-axis labels
    
    TextOut MhDC, LOffset - 2.4, TOffset + HFactor + 15, "1", 1
    TextOut MhDC, LOffset + WFactor * AxLen / 4 - Len(CStr(CLng(AxLen / 4))) * 3, TOffset + HFactor + 15, CStr((CLng(AxLen / 4))), Len(CStr((CLng(AxLen / 4))))
    TextOut MhDC, LOffset + WFactor * AxLen / 2 - Len(CStr(CLng(AxLen / 2))) * 3, TOffset + HFactor + 15, CStr((CLng(AxLen / 2))), Len(CStr((CLng(AxLen / 2))))
    TextOut MhDC, LOffset + WFactor * AxLen / 1.333 - Len(CStr(CLng(AxLen / 1.333))) * 3, TOffset + HFactor + 15, CStr((CLng(AxLen / 1.333))), Len(CStr((CLng(AxLen / 1.333))))
    TextOut MhDC, LOffset + WFactor * AxLen - Len(CStr(CLng(AxLen))) * 3, TOffset + HFactor + 15, CStr((CLng(AxLen))), Len(CStr((CLng(AxLen))))
    
    
    TextOut MhDC, LOffset + WFactor * AxLen / 2 - Len(AxStr) * 2.4, TOffset + HFactor + 35, AxStr, Len(AxStr)

    'TextOut MhDC, LOffset + WFactor * axlen / 2 - 21 * 4, TOffset + HFactor + 35, AxStr, Len(AxStr)

    SetTextColor MhDC, QBColor(0)
    
    'If ManFlag = 20 Or CurrentCheck = 4 Or CurrentCheck = 6 Or CurrentCheck = 0 Or (CurrentCheck = -1 And ((XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum) Or (XOverList(RelX, RelY).ProgramFlag = 3 Or XOverList(RelX, RelY).ProgramFlag = 3 + AddNum))) Then
        
    Dim Brush As Long, Brush2 As Long, oBrush As Long, LBrush As LOGBRUSH
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Dim LTxt As Long, LTxt2 As Long, LTxt3 As Long
    If Len(Trim(CStr(Int(GPrintMin(1))))) >= Len(Trim(CStr(Int(GPrintMin(0))))) Then
        LTxt = Len(Trim(CStr(Int(GPrintMin(1)))))
    Else
        LTxt = Len(Trim(CStr(Int(GPrintMin(0)))))
    End If
    'ltxt = number of spaces before the decimal
    LTxt2 = (Abs(GPrintMin(1) - GPrintMin(0))) * 10
    If LTxt2 >= 100 Then
        LTxt2 = 1
    ElseIf LTxt2 >= 10 Then
        LTxt2 = 2
    ElseIf LTxt2 >= 1 Then
        LTxt2 = 3
    Else
        LTxt2 = 4
    End If
    LTxt3 = LTxt + 1 + LTxt2
    
    Dim Nudge As Long
    OF = Form1.Picture7.FontSize
    Form1.Picture7.FontSize = 12
    Nudge = (6 - LTxt3) * Form1.Picture7.TextWidth("0")
    Form1.Picture7.FontSize = OF
    
    VOut = Left(Trim$(CStr((CLng(GPrintMin(1) * 1000000) / 1000000))), LTxt3)
    Call MakePVO5(LTxt3, VOut)
    TextOut MhDC, LOffset - 50 + Nudge, TOffset - 6, VOut, Len(VOut)
    
    VOut = Left(Trim$(CStr(CLng(((((GPrintMin(1) - GPrintMin(0)) / 4) * 3 + GPrintMin(0)) * 1000000)) / 1000000)), LTxt3)
    Call MakePVO5(LTxt3, VOut)
    TextOut MhDC, LOffset - 50 + Nudge, TOffset - 6 + HFactor / 4, VOut, Len(VOut)
    
    VOut = Left(Trim$(CStr(CLng(((((GPrintMin(1) - GPrintMin(0)) / 2) + GPrintMin(0)) * 1000000)) / 1000000)), LTxt3)
    Call MakePVO5(LTxt3, VOut)
    TextOut MhDC, LOffset - 50 + Nudge, TOffset - 6 + HFactor / 2, VOut, Len(VOut)
    
    VOut = Left(Trim$(CStr(CLng(((((GPrintMin(1) - GPrintMin(0)) / 4) + GPrintMin(0)) * 1000000)) / 1000000)), LTxt3)
    Call MakePVO5(LTxt3, VOut)
    TextOut MhDC, LOffset - 50 + Nudge, TOffset - 6 + (HFactor / 4) * 3, VOut, Len(VOut)
    
    VOut = Left(Trim$(CStr((CLng(GPrintMin(0) * 1000000) / 1000000))), LTxt3)
    Call MakePVO5(LTxt3, VOut)
    TextOut MhDC, LOffset - 50 + Nudge, TOffset - 6 + HFactor, VOut, Len(VOut)
    
    
    'Draw variable site positions
    
    If UBound(GVarPos, 1) > 0 Then
        For Y = 0 To UBound(GVarPos, 1)
            LPn.lopnColor = GPrintCol(Y)
            LPn.lopnWidth = PA
            LPn.lopnStyle = 0
            PEN = CreatePenIndirect(LPn)
            Pen2 = SelectObject(MhDC, PEN)
            For x = 1 To UBound(GVarPos, 2)
                If GVarPos(Y, x) > 0 Then 'this is necessary because the array is dimentioned to the highest varpos of the three pairs
                    Dummy = MoveToEx(MhDC, LOffset + Decompress(GVarPos(Y, x)) * WFactor, TOffset - 20 + Y * 4, PntAPI)
                    Dummy = LineTo(MhDC, LOffset + Decompress(GVarPos(Y, x)) * WFactor, TOffset - 17 + Y * 4)
                End If
            Next 'X
            DeleteObject (Pen2)
        Next Y
    ElseIf UBound(GVarPos, 2) > 0 Then
        LPn.lopnColor = 0
        LPn.lopnStyle = 0
        LPn.lopnWidth = PA
        PEN = CreatePenIndirect(LPn)
        Pen2 = SelectObject(MhDC, PEN)
        
        For x = 1 To UBound(GVarPos, 2)
            'If GVarPos(0, X) > 2700 Then
            '    X = X
            'End If
            If GVarPos(Y, x) > 0 Then
                Dummy = MoveToEx(MhDC, LOffset + Decompress(GVarPos(0, x)) * WFactor, TOffset - 20, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Decompress(GVarPos(0, x)) * WFactor, TOffset - 15)
            End If
        Next 'X
        DeleteObject (Pen2)
    End If
    
    Dim LongTXT As Long
    LongTXT = 0
    Dim LPX As Long, TOX As String
    LPX = -15
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    
    If GBlockNum > -1 Then
        
        
        
        For x = 0 To GBlockNum
            
            LPn.lopnColor = GBlock(4, x)
            LPn.lopnStyle = 0
            LPn.lopnWidth = PA
            PEN = CreatePenIndirect(LPn)
            Pen2 = SelectObject(MhDC, PEN)
            XX = RGB(255, 210, 210)
            LBrush.lbColor = GBlock(4, x)
'            If GBlock(4, X) = RGB(255, 210, 210) Then 'if it is the recombinant region thing
'                LBrush.lbStyle = 1
'            Else
'                LBrush.lbStyle = 0
'            End If
            
            YP = TOffset
            LBrush.lbStyle = 0
            Brush = CreateBrushIndirect(LBrush)
            Brush2 = SelectObject(MhDC, Brush)
'            If GBlock(4, X) = RGB(255, 190, 190) Then
'            Else
            XX = RGB(255, 210, 210)
            If GBlock(1, x) = 0 And (GBlock(4, x) = RGB(255, 210, 210) Or GBlock(4, x) = 12500735) Then  'if it is the recombinant region thing
                LBrush.lbStyle = 1
                
                Brush = CreateBrushIndirect(LBrush)
                Brush2 = SelectObject(MhDC, Brush)
                Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * WFactor, HFactor + TOffset, LOffset + Decompress(GBlock(2, x)) * WFactor, YP + 10)
                
                LBrush.lbStyle = 0
                Brush = CreateBrushIndirect(LBrush)
                Brush2 = SelectObject(MhDC, Brush)
                Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * WFactor, TOffset + HFactor, LOffset + Decompress(GBlock(2, x)) * WFactor, TOffset + HFactor - 10)
                Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * WFactor, YP, LOffset + Decompress(GBlock(2, x)) * WFactor, YP + 10)
            ElseIf GBlock(1, x) = 0 Then 'ie it is a block on the plot
                Dummy = Rectangle(MhDC, LOffset + Decompress(GBlock(0, x)) * WFactor, TOffset + HFactor, LOffset + Decompress(GBlock(2, x)) * WFactor, YP)
                
            ElseIf GBlock(1, x) = 1 Then 'ie it is a block on the plot
                LPX = LPX + 15
                Dummy = Rectangle(MhDC, LOffset + 25 + AxLen * WFactor, TOffset + LPX, LOffset + 35 + AxLen * WFactor, YP + LPX + 10)
                TOX = "Sites excluded from analysis"
                If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
                TextOut MhDC, LOffset + AxLen * WFactor + 40, TOffset + LPX - 3, TOX, Len(TOX)
            ElseIf GBlock(1, x) = 2 Then 'ie it is a block on the plot
                LPX = LPX + 15
                Dummy = Rectangle(MhDC, LOffset + 25 + AxLen * WFactor, TOffset + LPX, LOffset + 35 + AxLen * WFactor, YP + LPX + 10)
                TOX = "Tract of sequence with a recombinant origin"
                If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
                TextOut MhDC, LOffset + AxLen * WFactor + 40, TOffset + LPX - 3, TOX, Len(TOX)
            ElseIf GBlock(1, x) = 10 Then 'ie it is the 95%CI key
                LPX = LPX + 15
                Dummy = Rectangle(MhDC, LOffset + 25 + AxLen * WFactor, TOffset + LPX, LOffset + 35 + AxLen * WFactor, YP + LPX + 10)
                TOX = "95% Breakpoint confidence interval"
                If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
                TextOut MhDC, LOffset + AxLen * WFactor + 40, TOffset + LPX - 3, TOX, Len(TOX)
            ElseIf GBlock(1, x) = 11 Then 'ie it is the 99% CI key
                LPX = LPX + 15
                Dummy = Rectangle(MhDC, LOffset + 25 + AxLen * WFactor, TOffset + LPX, LOffset + 35 + AxLen * WFactor, YP + LPX + 10)
                TOX = "99% Breakpoint confidence interval"
                If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
                TextOut MhDC, LOffset + AxLen * WFactor + 40, TOffset + LPX - 3, TOX, Len(TOX)
            ElseIf GBlock(1, x) = 3 Then 'ie it is a query sequence reference
                LPX = LPX + 15
                TOX = OriginalName(Form5.Combo1.ListIndex - 1) & " scanned against"
                If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
                TextOut MhDC, LOffset + AxLen * WFactor + 30, TOffset + LPX - 3, TOX, Len(TOX)
            End If
            DeleteObject Brush2
            DeleteObject Pen2
            
        Next x
        
         
    End If
    'If X = 12345 Then
    If GExtraTNum > -1 Then
        For x = 0 To GExtraTNum
            LPX = LPX + 15
            LPn.lopnStyle = 0
            If x > UBound(GPrintCol, 1) Then
                Exit For
            End If
            If ManFlag = -1 And (OVS = 5 Or CurrentCheck = 5 Or (CurrentCheck = -1 And XoverList(RelX, RelY).ProgramFlag = 5)) Then  'need to do something different for siscan
                If x = 0 Or x = 3 Then
                    LPn.lopnColor = Yellow
                ElseIf x = 1 Or x = 4 Then
                    LPn.lopnColor = Green
                ElseIf x = 2 Or x = 5 Then
                    LPn.lopnColor = Purple
                End If
            Else
                LPn.lopnColor = GPrintCol(x)
            End If
            LPn.lopnWidth = PA
            PEN = CreatePenIndirect(LPn)
            Pen2 = SelectObject(MhDC, PEN)
            Dummy = MoveToEx(MhDC, LOffset + 25 + AxLen * WFactor, TOffset + LPX + 5, PntAPI)
            Dummy = LineTo(MhDC, LOffset + 35 + AxLen * WFactor, TOffset + LPX + 5)
            DeleteObject (Pen2)
            TOX = GExtraText(x)
            If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
            TextOut MhDC, LOffset + AxLen * WFactor + 40, TOffset + LPX - 3, TOX, Len(TOX)
        Next x
        
    End If
    'End If
    
    Dim tGCritVal() As Double
    ReDim tGCritVal(10)
    
    If GExtraTNum > -1 Or GBlockNum > -1 Or GCritval(0) > 0 Then
        For x = 0 To UBound(GCritval, 1)
            If GCritval(x) <> 0 Then
                LPX = LPX + 15
                
                tGCritVal(x) = GCritval(x)
                If GCritval(x) > 0 And GCritval(x) < 50 And x = 0 Then
                    LPn.lopnStyle = 2
                    LPn.lopnWidth = PA
                    TOX = "P-Value = " & LowestProb
                    If MCFlag = 0 And x = 0 Then
                        TOX = "Bonferroni corrected " + TOX
                    End If
                ElseIf GCritval(x) > 0 And x = 1 Then
                    LPn.lopnStyle = 2
                    LPn.lopnWidth = PA
                    TOX = "Uncorrected P-Value = " & LowestProb
                ElseIf GCritval(x) > 0 And x = 2 Then
                    LPn.lopnStyle = 4
                    LPn.lopnWidth = PA
                    TOX = "Global 95% confidence limit"
                ElseIf GCritval(x) > 0 And x = 3 Then
                    TOX = "Global 99% confidence limit"
                    LPn.lopnStyle = 2
                    LPn.lopnWidth = PA
                ElseIf GCritval(x) > 0 And x = 4 Then
                    TOX = "P-Value = " & LowestProb
                    If MCFlag = 0 And x = 4 Then
                        TOX = "Bonferroni corrected " + TOX
                    End If
                    LPn.lopnStyle = 2
                    LPn.lopnWidth = PA
                ElseIf GCritval(x) < 0 And x = 5 Then
                    TOX = ""
                    LPX = LPX - 15
                    LPn.lopnStyle = 5
                    LPn.lopnWidth = PA
                ElseIf (GCritval(x) < 0 Or GCritval(x) > 50) And x = 0 Then
                    LPn.lopnStyle = 2
                    LPn.lopnWidth = PA
                    
'                    If GCritval(X) > 0 Then
'                        tGCritVal(X) = -GCritval(X)
'                    Else
'                        tGCritVal(X) = GCritval(X) * -1
'                    End If
                    TOX = "Bootstrap cutoff of " & Abs(GCritval(0)) & "%"
                End If
                If Len(TOX) > LongTXT Then LongTXT = Len(TOX)
                TextOut MhDC, LOffset + AxLen * WFactor + 40, TOffset + LPX - 3, TOX, Len(TOX)
                
                LPn.lopnColor = 0
                LPn.lopnWidth = PA
                PEN = CreatePenIndirect(LPn)
                Pen2 = SelectObject(MhDC, PEN)
                Dummy = MoveToEx(MhDC, LOffset + 25 + AxLen * WFactor, TOffset + LPX + 5, PntAPI)
                Dummy = LineTo(MhDC, LOffset + 35 + AxLen * WFactor, TOffset + LPX + 5)
                DeleteObject (Pen2)
            End If
        Next x
        LongTXT = LongTXT * 5.8
        LPX = LPX + 15
        LPn.lopnStyle = 0
        LPn.lopnColor = 0
        LPn.lopnWidth = PA
        PEN = CreatePenIndirect(LPn)
        Pen2 = SelectObject(MhDC, PEN)
        'this does the line around the legend
        Dummy = MoveToEx(MhDC, LOffset + 20 + AxLen * WFactor, TOffset - 5, PntAPI)
        Dummy = LineTo(MhDC, LOffset + 40 + LongTXT + AxLen * WFactor, TOffset - 5)
        Dummy = LineTo(MhDC, LOffset + 40 + LongTXT + AxLen * WFactor, TOffset + LPX - 2)
        Dummy = LineTo(MhDC, LOffset + 20 + AxLen * WFactor, TOffset + LPX - 2)
        Dummy = LineTo(MhDC, LOffset + 20 + AxLen * WFactor, TOffset - 5)
        DeleteObject Pen2
    End If

    For x = 0 To 10
        If tGCritVal(x) <> 0 Then
        'Draw critical val co
            LPn.lopnColor = 0
            LPn.lopnWidth = PA
            If x = 0 Then
                LPn.lopnStyle = 2
            ElseIf x = 1 Then
                LPn.lopnStyle = 3
            ElseIf x = 2 Then
                LPn.lopnStyle = 2
            ElseIf x = 3 Then
                LPn.lopnStyle = 4
            ElseIf x = 4 Then
                LPn.lopnStyle = 2
            ElseIf x = 5 Then
                LPn.lopnStyle = 2
            End If
            PEN = CreatePenIndirect(LPn)
            SelectObject MhDC, PEN

            'If COff <= GCritval(X) Then
                MoveToEx MhDC, LOffset - 10, TOffset + (1 - (tGCritVal(x) - GPrintMin(0)) / (GPrintMin(1) - GPrintMin(0))) * HFactor, PntAPI
                LineTo MhDC, LOffset + AxLen * WFactor + 10, TOffset + (1 - (tGCritVal(x) - GPrintMin(0)) / (GPrintMin(1) - GPrintMin(0))) * HFactor
            'End If
        End If
    Next x
    
    If GPrintType = 0 Then 'standard line plot
        Dim OriMod1 As Long, OriMod2 As Long, DiX As Double
        If GPrintMin(0) > GPrintMin(1) Then
            OriMod1 = 0
            OriMod2 = -1
            DixA = GPrintMin(0)
            DixB = GPrintMin(1)
        Else
            OriMod1 = 1
            OriMod2 = 1
            DixA = GPrintMin(1)
            DixB = GPrintMin(0)
        End If
        For Z = 0 To GPrintNum
            'Test if its a line
            FirstPos = 0: LastPos = GPrintLen
            For Y = 1 To GPrintLen
                If GPrintPos(Z, Y) > 0 Then
                    FirstPos = Y
                    Exit For
                End If
            Next Y
            For Y = GPrintLen To 0 Step -1
                If GPrintPos(Z, Y) > 0 Then
                    LastPos = Y
                    Exit For
                End If
            Next Y
            
          
            If ((GPrintPos(Z, LastPos) - GPrintPos(Z, FirstPos)) > 1) Or GPrintCol(Z) = 0 Then   'i.e. its a normal plot
            
                
                
                LPn.lopnStyle = 0
                If ManFlag = -1 And (OVS = 5 Or CurrentCheck = 5 Or (CurrentCheck = -1 And XoverList(RelX, RelY).ProgramFlag = 5)) Then  'need to do something different for siscan
                    If Z < 15 Then
                        LPn.lopnColor = PltCol(Z + 1)
                    ElseIf Z < 23 Then
                        LPn.lopnColor = PltCol2(Z - 14)
                    ElseIf Z = 4 Or Z = 9 Then
                        LPn.lopnColor = PltCol(Z) 'GPrintCol(4) 'mPurple 'green'
                    ElseIf Z = 17 Or Z = 21 Then
                        LPn.lopnColor = PltCol2(Z - 15)
                    ElseIf Z = 1 Or Z = 7 Or Z = 15 Then
                        LPn.lopnColor = PltCol(Z) 'GPrintCol(1) ' green 'mPurple
                    ElseIf Z = 18 Then
                        LPn.lopnColor = PltCol2(Z - 15) 'GPrintCol(1) ' green 'mPurple
                    ElseIf Z = 2 Or Z = 8 Then
                        LPn.lopnColor = PltCol(Z) 'GPrintCol(2) 'mYellow
                    ElseIf Z = 16 Or Z = 19 Then
                       LPn.lopnColor = PltCol2(Z - 15)
                    ElseIf Z = 24 Then
                        LPn.lopnColor = RGB(64, 64, 64) 'mYellow
                    Else
                        LPn.lopnColor = RGB(240, 240, 240) 'GPrintCol(Z)
                    End If
                Else
                    LPn.lopnColor = GPrintCol(Z)
                End If
                'If Z = 9 Then
                '    LPn.lopnColor = RGB(255, 0, 0)
                'End If
                PEN = CreatePenIndirect(LPn)
                Pen2 = SelectObject(MhDC, PEN)
                Y = 1
                
                Do
                    If Y <= UBound(GPrintPos, 2) Then
                    
                        If GPrintPos(Z, Y) > 0 Then
                            If OriMod1 = 0 Then
                                If DixB <> 0 Then
                                    Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, (TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB))) * HFactor), PntAPI)
                                Else
                                    Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, HFactor + TOffset + (OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB)))) * HFactor, PntAPI)
                                End If
                            Else
                                Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, (TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB))) * HFactor), PntAPI)
                            End If
                            Exit Do
                            
                        End If
                        Y = Y + 1
                    Else
                        Y = 1
                        If OriMod1 = 0 Then
                            If DixB <> 0 Then
                                Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, (TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB))) * HFactor), PntAPI)
                            Else
                                Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, HFactor + TOffset + (OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB)))) * HFactor, PntAPI)
                            End If
                        Else
                            Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, Y)) * WFactor, (TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB))) * HFactor), PntAPI)
                        End If
                        Exit Do
                    End If
                Loop
                For PosCount = Y To GPrintLen
                'If PosCount = GPrintLen - 1 Then
                '    X = X
                'End If
                  '  If GPrint(z, PosCount) = 0 Then
                  '
                  '      GPrint(z, PosCount) = GPrintMin(1) / 2
                  '
                  '      '19,19,40 = 0
                  '  End If
                    
                    'If PosCount = 302 Then
                    '    X = X
                    'End If
                    If PosCount > GPrintLen - 3 Then
                        x = x
                    End If
                    If GPrintPos(Z, PosCount) <= Len(StrainSeq(0)) Then
                        If Decompress(GPrintPos(Z, PosCount)) > 0 Then 'And Abs(GPrintPos(Z, PosCount) - GPrintPos(Z, PosCount - 1)) < Len(StrainSeq(0)) / 4 Then
    '                      If GPrint(Z, PosCount) > -0.67 Then
    '                        X = X
    '                      End If
    '                    If PosCount > GPrintLen - 4 Then
    '                        x = x
    '                    End If
                            XX = Len(StrainSeq(0))
                          If (OriMod1 = 1) Then
                            If GPrint(Z, PosCount) < GPrintMin(0) Then
                                  GPrint(Z, PosCount) = GPrintMin(0)
                             ElseIf GPrint(Z, PosCount) > GPrintMin(1) Then
                                  GPrint(Z, PosCount) = GPrintMin(1)
                             End If
                          ElseIf OriMod1 = 0 Then
                          
                            If GPrint(Z, PosCount) > (GPrintMin(0)) Then
                                GPrint(Z, PosCount) = (GPrintMin(0))
                            ElseIf GPrint(Z, PosCount) < (GPrintMin(1)) And GPrint(Z, PosCount) >= 0 Then
                                
                                    GPrint(Z, PosCount) = (GPrintMin(1))
                               
                            End If
                          
                          End If
                            XX = UBound(Decompress, 1)
                            If GPrintPos(Z, PosCount) > UBound(Decompress, 1) Then GPrintPos(Z, PosCount) = UBound(Decompress, 1)
                            
                            If OriMod1 = 0 Then
                                '(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, Y) - DixB) / (DixA - DixB))) * HFactor)
                                'Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, (TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor))
                                    If DixB <> 0 Then
                                        Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, (TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor))
                                    Else
                                        Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, HFactor + TOffset + (OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB)))) * HFactor)
                                    End If
    
                                'Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, HFactor + TOffset + (OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB)))) * HFactor)
    
                           Else
                                Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, TOffset + (OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB)))) * HFactor)
                                
                           End If
                           ' Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor, TOffset + ((OriMod2 * (OriMod1 - GPrint(Z, PosCount) - DixB)) / (DixA - DixB)) * HFactor)
    
                            '                                                            LineList(1, PC) = PicHeight - (15 + ((OriMod2 * GPrint(ExtraZ, A) - DixB) / AmB) * PHAdj)
                                                
                            'For ZZ = PosCount To GPrintLen
                            '    XX = GPrintPos(Z, ZZ)
                            '    If GPrint(Z, ZZ) = 0 Then
                            '        X = X
                            '    End If
                            'Next ZZ
                            'X = X
                        End If
                    End If
                Next PosCount
                
                DeleteObject Pen2
            Else ' i.e. its a polygon that needs to be filled
           
                
                LPn.lopnStyle = 0
                LPn.lopnWidth = PA
                LPn.lopnColor = GPrintCol(Z)
                'If Z = 11 Then
                '    LPn.lopnColor = RGB(255, 0, 0)
                'End If
                PEN = CreatePenIndirect(LPn)
                Pen2 = SelectObject(MhDC, PEN)
                
                LBrush.lbColor = GPrintCol(Z)
                
                
                LBrush.lbStyle = 0
                
                Brush = CreateBrushIndirect(LBrush)
                Brush2 = SelectObject(MhDC, Brush)
                
               
                
                ReDim PolyPoints(GPrintLen - 1)
                A = -1
                For PosCount = 1 To GPrintLen
                        If GPrintPos(Z, PosCount) > 0 Then
                            GoOn = 0
                            If PosCount > 0 Then
                                If (CLng(LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor) <> CLng(LOffset + Decompress(GPrintPos(Z, PosCount - 1)) * WFactor)) Or (CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor) <> CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount - 1) - DixB) / (DixA - DixB))) * HFactor)) Then
                                GoOn = 1
                                End If
                            Else
                                GoOn = 1
                            End If
                            If GoOn = 1 Then
                                A = A + 1
                                PolyPoints(A).x = LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor
                                PolyPoints(A).Y = TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor
                            End If
                            x = x
                        End If
                Next PosCount
                
                'PolyPoints(0).X = 100
                'PolyPoints(0).Y = 100
                'PolyPoints(1).X = 200
                'PolyPoints(1).Y = 100
                'PolyPoints(2).X = 200
                'PolyPoints(2).X = 200
                'PolyPoints(3).X = 100
                'PolyPoints(3).Y = 100
               'ReDim Preserve PolyPoints(A)
               If A < 16000 And A > 0 Then ' for some reason ppt crashes if you give it a polygon with >16000 points
                    Polygon MhDC, PolyPoints(0), A
               Else
                    ReDim PolyPoints(GPrintLen - 1)
                    Dim SkipFact As Double
                    SkipFact = CLng(A / 16000) + 1
                    ReDim PolyPoints(GPrintLen - 1)
                     A = -1
                     For PosCount = 0 To GPrintLen Step SkipFact
                             If GPrintPos(Z, PosCount) > 0 Then
                                 GoOn = 0
                                 If PosCount > 0 Then
                                     If (CLng(LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor) <> CLng(LOffset + GPrintPos(Z, PosCount - 1) * WFactor)) Or (CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor) <> CLng(TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount - 1) - DixB) / (DixA - DixB))) * HFactor)) Then
                                     GoOn = 1
                                     End If
                                 Else
                                     GoOn = 1
                                 End If
                                 If GoOn = 1 Then
                                     A = A + 1
                                     PolyPoints(A).x = LOffset + Decompress(GPrintPos(Z, PosCount)) * WFactor
                                     PolyPoints(A).Y = TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - DixB) / (DixA - DixB))) * HFactor
                                 End If
                                 x = x
                             End If
                     Next PosCount
                     
                     'PolyPoints(0).X = 100
                     'PolyPoints(0).Y = 100
                     'PolyPoints(1).X = 200
                     'PolyPoints(1).Y = 100
                     'PolyPoints(2).X = 200
                     'PolyPoints(2).X = 200
                     'PolyPoints(3).X = 100
                     'PolyPoints(3).Y = 100
                    'ReDim Preserve PolyPoints(A)
                    Polygon MhDC, PolyPoints(0), A
                End If
            x = x
            'If GPrintPos(Z, Y) <> GPrintPos(Z, GPrintLen) Then
             '   For PosCount = 0 To Z
                
             ''       'If PosCount = GPrintLen - 1 Then
             '       '    X = X
             '       'End If
             '         '  If GPrint(z, PosCount) = 0 Then
              '        '
              '        '      GPrint(z, PosCount) = GPrintMin(1) / 2
              ''        '
              '        '      '19,19,40 = 0
              '        '  End If
              '
               '
               ''         If GPrintPos(Z, PosCount) > 0 And ((OriMod1 = 1 And GPrint(Z, PosCount) >= GPrintMin(0) And (GPrint(Z, PosCount) <= GPrintMin(1) * 1.1)) Or (OriMod1 = 0 And GPrint(Z, PosCount) <= GPrintMin(0) And GPrint(Z, PosCount) >= GPrintMin(1))) Then
               '
                ''            Dummy = LineTo(MhDC, LOffset + GPrintPos(Z, PosCount) * WFactor, TOffset + OriMod2 * (OriMod1 - ((GPrint(Z, PosCount) - dixb) / (DiXA - dixb))) * HFactor)
                '
                '        End If
                '
                '   Next PosCount
                   
                   
             '   Else
                
             '   End If
             
                DeleteObject Pen2
                DeleteObject Brush2
            End If
        Next Z
        
        x = x
    ElseIf GPrintType = 1 Then 'blocks like in geneconv plot
            
        For Z = 0 To GPrintNum
            LPn.lopnStyle = 0
            LPn.lopnWidth = PA
            
            LPn.lopnColor = GPrintCol(Z)
            PEN = CreatePenIndirect(LPn)
            Pen2 = SelectObject(MhDC, PEN)
            For PosCount = 0 To GPrintLen
                If PosCount > 0 And GPrintPos(Z, 1, PosCount) = 0 Then Exit For
                Dummy = MoveToEx(MhDC, LOffset + Decompress(GPrintPos(Z, 0, PosCount)) * WFactor, TOffset + (1 - (GPrint(Z, PosCount) / GPrintMin(1))) * HFactor, PntAPI)
                Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 1, PosCount)) * WFactor, TOffset + (1 - (GPrint(Z, PosCount) / GPrintMin(1))) * HFactor)
                Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 1, PosCount)) * WFactor, TOffset + (1 - (GPrintMin(0) / GPrintMin(1))) * HFactor)
                Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 0, PosCount)) * WFactor, TOffset + (1 - (GPrintMin(0) / GPrintMin(1))) * HFactor)
                Dummy = LineTo(MhDC, LOffset + Decompress(GPrintPos(Z, 0, PosCount)) * WFactor, TOffset + (1 - (GPrint(Z, PosCount) / GPrintMin(1))) * HFactor)
            Next PosCount
            DeleteObject Pen2
            
        Next Z
    End If
    
    
    
    LoFnt = CreateFont(12, 0, 900, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, "Arial")
    SelectObject MhDC, LoFnt
    'TOffset -6 + HFactor
    
    YC = TOffset - 6 + (HFactor / 4) * 3 + (Len(GLegend) - 16) * 3 '17=5.7; 21=4.2; 16 =6.2
    
    'YC = TOffset + ((HFactor - (Len(GLegend) * 100 / Len(GLegend))) / 2) * 3
    
    TextOut MhDC, LOffset - 70, YC, GLegend, Len(GLegend)
    On Error GoTo 0

    'Clear up and close  emf
    PEN = SelectObject(MhDC, oldpen)
    DeleteObject (PEN)
    
    
    Brush = SelectObject(MhDC, OldBrush)
    DeleteObject (Brush)
            

    
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject (LoFnt)
    
    
    
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    
    
    
    If CopyFlag = 1 Then
        Clipboard.Clear
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        Clipboard.SetData LoadPicture("tmp2.emf"), 3
        
        KillFile "tmp2.emf"
        On Error GoTo 0
    End If

End Sub

Public Sub MultTreeWin()
    Dim OM As Long, OV As Long, OVx As Long, VSMax As Long, otTYF As Long, Index As Long, C As Long, MapBlockNumX As Long, YPos As Long, A As Long, TNum As Long, TType As Long, D As Long, Z As Long, Y As Long, EN As Long, BE As Long, ExtraDX As Long, GoOn As Long, NHFlag As Long, tTF As Long, FF As Long, oTTF As Long, OP As Long, StartVal As Long, TargetVal As Long, oDir As String
    oTTF = TreeTypeFlag
    'If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Dim Bx As Long, By As Long, TTreeTypeFlag As Integer, AddjNum As Integer
    Dim x As Long, OS As Long
    Dim OldFontSize As Double
    OldFontSize = 8.5
    ReDim ColourSeq(PermNextno + MaxEListLen + 2)
    OP = Screen.MousePointer
    AddjNum = 14
    
    Form1.SSPanel1.Caption = "Making trees"
    Form2.SSPanel3.Caption = "Making trees"
    
    Screen.MousePointer = 11
    StartVal = Form1.ProgressBar1
    
    If Form1.ProgressBar1 < 80 Then
        TargetVal = StartVal + 20
    Else
        TargetVal = StartVal + (100 - StartVal) / 2
    End If
   ' XX = Form1.ProgressBar1.Value
    If FastNJFlag = 0 Then
        Form2.Label1(0) = "UPGMA ignoring recombination"
        
        'Do the "Ignoring recombination tree"
    
        If TreeImage(0) = 0 Then
            '"UPGMA Ignoring Recombination" has not yet been drawn
            'TTreeTypeFlag = TreeTypeFlag
            'TreeTypeFlag = 0
            
            
            
            Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
            Call DrawTree
            
            If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
                TreeXUB = UBound(TreeX, 1)
                TreeXInFileFlag = 1
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                FF = FreeFile
                Open "RDP5TreeX" + UFTag For Binary As #FF
                Put #FF, , TreeX()
                Close #FF
                ChDir oDir
                ChDrive oDir
                Erase TreeX
            End If
            
            TreeImage(0) = 1
            
        
        End If
        If UpdateProgressBar = 0 Then
            If Form1.ProgressBar1.Value < 90 Then
                Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * 0.4
                Call UpdateF2Prog
            End If
        End If
    Else
        ReDim TempSeq(NextNo + 2)
        TSeqLen = Len(StrainSeq(0))
        Form2.Label1(0) = "FastNJ tree ignoring recombination"
        'TreeTypeFlag = 0
        tTF = CTF
        CTF = 0
        NHFlag = 0
        If NextNo <= UBound(StrainSeq, 1) Then
            For x = 0 To NextNo
                TempSeq(x) = StrainSeq(x)
            Next x
        ElseIf PermNextno <= UBound(StrainSeq, 1) Then
            For x = 0 To PermNextno
                TempSeq(x) = StrainSeq(x)
            Next x
        End If
        

        F2TreeIndex = 0
        'Form1.SSPanel6(1).Visible = True
        'Form1.SSPanel6(0).Visible = False
        'Form1.SSPanel6(2).Visible = False
        Form1.Refresh
        'DoneTree(0, 0) = 0
        'check and see if its a UPGMA
        
        GoOn = 0
        For x = 1 To TBLen(0, 0)
            If TreeBlocks(0, 0, 0, x) <> TreeBlocks(0, 0, 0, 0) Then
                GoOn = 1
            End If
        Next x
        
        If DoneTree(0, 0) = 1 And GoOn = 1 Then
            
        Else
            AbortFlag = 0
            Call UnModNextno
            Call GetOutie
            
            BusyWithTreeFlag = BusyWithTreeFlag + 1
            Call NJTree2(0)
            If AbortFlag = 1 Then
                If UpdateProgressBar = 0 Then
                    Form1.ProgressBar1.Value = StartVal
                    Form1.SSPanel1.Caption = ""
                    Call UpdateF2Prog
                End If
                Screen.MousePointer = OP
                CTF = tTF
                AbortFlag = 0
                Form2.Command2.Enabled = False
    
                
            End If
            ExtraDX = DoTreeColour(Form2.Picture2(0), 0, 0)
            
    
        End If
    
         'Call NJTree(1)
        Form1.Picture16.ScaleMode = 3
        Form1.Picture16.ForeColor = 0
    
        'For X = 0 To Nextno
        '    'If X <> Seq1 And X <> Seq2 And X <> Seq3 Then
        '    Form1.Picture16.CurrentX = XCord(3, F2TreeIndex, X)
        '    Form1.Picture16.CurrentY = YCord(3, F2TreeIndex, X)
        '    Form1.Picture16.Print (OriginalName(X))
        '    'End If
        'Next 'X
        TreeImage(0) = 1
        If RelX = RelY And RelX = 0 Then
            If UpdateProgressBar = 0 Then
                Form1.ProgressBar1.Value = StartVal
                Call UpdateF2Prog
                Screen.MousePointer = OP
                Exit Sub
            End If
        End If
        
        
        Dim TMX As String
        Call GetModelString(TMX)
        'Form1.Label14 = "ML " + TMX + " tree ignoring recombination"
        
    End If
    
    UnModNextno
    '
    
    ExtraDX = DoTreeColour(Form2.Picture2(0), 0, 0)
    If CurTree(3) = 0 Then
        ExtraDX = DoTreeColour(Form2.Picture2(3), 0, 3)
    End If
    If Form2.VScroll1(0).Max < Form2.Picture2(0).Height Then
        'Form2.VScroll1(0).Value = 0
        If DontChangeVScrollFlag = 0 Then
           ' Form2.VScroll1(1).Value = 0
           ' Form2.VScroll1(2).Value = 0
        End If
        'Form2.VScroll1(3).Value = 100
    End If
    
    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(0).Value, 0, 0, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(0))
    
    
    ModNextno
    'Write over names so that coloured ones can be put in their place
    
    'ExtraDx = DoTreeColour(Form2.Picture2(3), 0, 0)
   
    NextNo = TreeNextno
    
    
    If XoverList(RelX, RelY).Ending <> XoverList(RelX, RelY).Beginning Then

    'Do "UPGMA of All Regions" tree
        If XoverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
            EN = 1
        Else
            EN = XoverList(RelX, RelY).Ending + 1
        End If
        If XoverList(RelX, RelY).Beginning = 1 Then
            BE = Len(StrainSeq(0))
        Else
            BE = XoverList(RelX, RelY).Beginning - 1
        End If
    Else
        EN = 0
        BE = 0
    End If
    Screen.MousePointer = 11
    
    If FastNJFlag = 0 Then
    
        'Form2.Label1(1) = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(EN))) + " - " + Trim$(CStr(Decompress(BE))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
            Form2.Label1(1) = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + ")"
        Else
            If XoverList(RelX, RelY).Ending + 1 > UBound(Decompress, 1) Then
                ReDim Preserve Decompress(XoverList(RelX, RelY).Ending + 1)
                Decompress(XoverList(RelX, RelY).Ending + 1) = Decompress(Len(StrainSeq(0)))
                Recompress(Decompress(XoverList(RelX, RelY).Ending + 1)) = Recompress(Decompress(Len(StrainSeq(0))))
            End If
            
            If XoverList(RelX, RelY).Beginning = 0 Then XoverList(RelX, RelY).Beginning = 1
            If Decompress(XoverList(RelX, RelY).Ending + 1) <> Decompress(Len(StrainSeq(0))) And Decompress(XoverList(RelX, RelY).Ending) <> Decompress(Len(StrainSeq(0))) Then
                If x = x Then
                    If Decompress(XoverList(RelX, RelY).Beginning) <> 1 Then
                        Form2.Label1(1) = "UPGMA of regions derived from major parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                    Else
                        Form2.Label1(1) = "UPGMA of region derived from major parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                    End If
                Else
                
                End If
            Else
                Form2.Label1(1) = "UPGMA of region derived from major parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + ")"
            End If
        End If
        'XX = Form2.Picture2(1).FontSize
        If TreeImage(1) = 0 Then 'And XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            'If the tree hasn't been drawn yet and what we're dealing with is an RDP result.
            CTF = 0
            TreeTypeFlag = 1
            'Save a backup of the refererence sequence number (drawing this tree requires that it find a new set of references)
            OS = SpacerNo
            
            'Call RTSpacerFind
            Call RecUPGMAIV
           ' XX = Form2.Picture2(1).FontSize
            ExtraDX = DoTreeColour(Form2.Picture2(1), 0, 1)
           
            TreeImage(1) = 1
            If XoverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
                EN = 1
            Else
                EN = XoverList(RelX, RelY).Ending + 1
            End If
            If XoverList(RelX, RelY).Beginning = 1 Then
                BE = Len(StrainSeq(0))
            Else
                BE = XoverList(RelX, RelY).Beginning - 1
            End If
            
            
            
            SpacerNo = OS
            
        
        End If
        If UpdateProgressBar = 0 Then
            If Form1.ProgressBar1.Value < 90 Then
                Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * 0.6
                Call UpdateF2Prog
            End If
        End If
    Else
        If BE > 0 Or EN > 0 And BE <> EN Then
            'Form2.Label1(1) = "FastNJ tree of region derived from major parent (" + Trim$(CStr(Decompress(EN))) + " - " + Trim$(CStr(Decompress(BE))) + ")" '"UPGMA of Recombinant Region"
            If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                Form2.Label1(1) = "FastNJ tree of region derived from major parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + ")"
            Else
                If XoverList(RelX, RelY).Ending + 1 <= UBound(Decompress, 1) Then
                    Form2.Label1(1) = "FastNJ tree of regions derived from major parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning - 1))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending + 1))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                Else
                    XoverList(RelX, RelY).Ending = UBound(Decompress, 1) - 1
                End If
            End If

        Else
            Form2.Label1(1) = "FastNJ tree"
        End If
        Dim tStrainseq() As String
        
        
        If TreeImage(1) = 0 And (RelX > 0 Or RelY > 0) And NextNo > -1 Then 'And XOverList(RelX, RelY).ProgramFlag = 0 Or XOverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            
            ReDim tStrainseq(NextNo)
            For x = 0 To NextNo
                tStrainseq(x) = String(Len(StrainSeq(0)), " ")
            Next x
            For x = 0 To NextNo '24
                For Y = 1 To Len(StrainSeq(0))
                    Mid(tStrainseq(x), Y, 1) = Chr(TreeSeqNum(Y, x) - 1)
                Next Y
            Next x
            BTree = XoverList(RelX, RelY).Ending + 1
            ETree = XoverList(RelX, RelY).Beginning - 1
            If BTree >= Len(StrainSeq(0)) Then BTree = 1
            If ETree < 0 Then ETree = Len(StrainSeq(0))
            '8218
            ReDim TempSeq(NextNo)
            For x = 0 To NextNo '8217-7791
                If BTree < ETree Then
                    TempSeq(x) = Mid$(tStrainseq(x), BTree, (ETree - BTree))
                Else
                    TempSeq(x) = Mid$(tStrainseq(x), BTree, Len(StrainSeq(0)) - BTree)
                    TempSeq(x) = TempSeq(x) + Mid$(tStrainseq(x), 1, ETree)
                End If
            Next x
            F2TreeIndex = 1
            'TreeTypeFlag = 1
            CurTree(1) = 0
            CTF = 0
            NHFlag = 1
            BusyWithTreeFlag = BusyWithTreeFlag + 1
            Call NJTree2(0)
            
            'Save a backup of the refererence sequence number (drawing this tree requires that it find a new set of references)
            OS = SpacerNo
    
            
            TreeImage(1) = 1
            ExtraDX = DoTreeColour(Form2.Picture2(1), 0, 1)
                
            TreeImage(1) = 1
            If XoverList(RelX, RelY).Ending = Len(StrainSeq(0)) Then
                EN = 1
            Else
                EN = XoverList(RelX, RelY).Ending + 1
            End If
            If XoverList(RelX, RelY).Beginning = 1 Then
                BE = Len(StrainSeq(0))
            Else
                BE = XoverList(RelX, RelY).Beginning - 1
            End If
            
            
            
            SpacerNo = OS
            
        
        End If
    
    End If
    
    'Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(1).Value, 1, 0, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(1))
    Screen.MousePointer = 11
    
    If FastNJFlag = 0 Then
        'Do the "UPGMA of Recombinant Region" tree
        'Form2.Label1(2) = "UPGMA of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Form2.Label1(2) = "UPGMA of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
        Else
            Form2.Label1(2) = "UPGMA of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
        End If
                
        If TreeImage(2) = 0 Then
            
            Call RecUPGMAII
            ExtraDX = DoTreeColour(Form2.Picture2(2), 0, 2)
            TreeImage(2) = 1
            
        
        End If
        If UpdateProgressBar = 0 Then
            If Form1.ProgressBar1.Value < 90 Then
                Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * 0.6
                Call UpdateF2Prog
            End If
        End If
    Else
        'Form2.Label1(2) = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '"UPGMA of Recombinant Region"
        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Form2.Label1(2) = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
        Else
            Form2.Label1(2) = "FastNJ tree of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
        End If
        If TreeImage(2) = 0 And (RelX > 0 Or RelY > 0) Then
            
            
            ReDim tStrainseq(NextNo)
            For x = 0 To NextNo
                tStrainseq(x) = String(Len(StrainSeq(0)), " ")
            Next x
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    Mid(tStrainseq(x), Y, 1) = Chr(TreeSeqNum(Y, x) - 1)
                Next Y
            Next x
            BTree = BE
            ETree = EN
            For x = 0 To NextNo
                If BTree < ETree Then
                    TempSeq(x) = Mid$(tStrainseq(x), BTree, ETree - BTree)
                Else
                    TempSeq(x) = Mid$(tStrainseq(x), BTree, Len(StrainSeq(0)) - BTree)
                    TempSeq(x) = TempSeq(x) + Mid$(tStrainseq(x), 1, ETree)
                End If
            Next x
            F2TreeIndex = 2
            'TreeTypeFlag = 2
            CurTree(2) = 0
            If TreeTypeFlag <> 3 Then
                CTF = 0
                TreeTypeFlag = 2
            End If
            NHFlag = 2
            BusyWithTreeFlag = BusyWithTreeFlag + 1
            Call NJTree2(0)
            
            ExtraDX = DoTreeColour(Form2.Picture2(2), 0, 2)
            TreeImage(2) = 1
            
        
        End If
    End If
    'XX = Form2.VScroll1(2).Value
    'YY = Form2.VScroll1(2).MaX
    'Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(2).Value, 2, 0, TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(2))
    
    
    Form2.Picture2(3).AutoRedraw = True
    
    Screen.MousePointer = 11
    If x = x Then
        If x = 12345 Then 'TreeImage(3) = 1 Then 'FastNJFlag = 1 Or X = X Then
            'Do the "UPGMA of Non-Recombinant Regions" tree
            Form2.Label1(3) = "FastNJ tree with recombinant regions removed"
            
            
            If TreeImage(3) = 0 Then
                If CurTree(3) = 1 Then
                    'Call DrawUPGMA5
                    'Call DrawFastNJ5(Form2.Picture2(3))
                    Call DrawML7(Form2.Picture2(3))
                ElseIf CurTree(3) = 3 Or CurTree(3) = 2 Then
                    Call DrawML5(Form2.Picture2(3), 5)
                ElseIf CurTree(3) = 4 Then
                    Call DrawML5(Form2.Picture2(3), 4)
                Else
                    TreeTypeFlag = 3
'                    SS = Abs(GetTickCount)
'                    'Call RecUPGMAIV 'this is pointless -could save 20% of treedrawing time if this was ignored.
'                    EE = Abs(GetTickCount)
'                    TT = EE - SS
'                    X = X
                End If
                
                TreeImage(3) = 1
                   
                ExtraDX = DoTreeColour(Form2.Picture2(3), 0, 3)
            End If
            'XX = CurTree(3)
            If UpdateProgressBar = 0 Then
                 If Form1.ProgressBar1.Value < 90 Then
                    Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * 0.4
                    Call UpdateF2Prog
                End If
            End If
        ElseIf TreeImage(3) = 1 Or ADT = 1 Then
            If ADT = 1 Then
                ADT = 0
                TreeImage(3) = 0
            End If
            Form2.Label1(3) = "FastNJ tree of non-recombinant regions"
            
            If TreeImage(3) = 0 Then
                If CurTree(3) = 1 Then
                    'Call DrawUPGMA5
                    'Call DrawFastNJ5(Form2.Picture2(3))
                    Call DrawML7(Form2.Picture2(3))
                ElseIf CurTree(3) = 2 Or CurTree(3) = 3 Then
                    Call DrawML5(Form2.Picture2(3), 5)
                ElseIf CurTree(4) = 2 Then
                
                    Call DrawML5(Form2.Picture2(3), 4)
                Else 'curtree(3)=0
                    'XX = UBound(TempSeq, 1)
                    'XX = CurTree(3)
                    Call UnModNextno
                    If TreeImage(3) = 0 Then
                    
                        Call UnModNextno
                        Call UnModSeqNum(0)
                        ReDim TempSeq(PermNextno)
                        For x = 0 To PermNextno
                            TempSeq(x) = StrainSeq(x)
                        Next x
                        'may need to drop stainseq to the disk here
                        
                        Dim SomeAcceptFlag As Byte
                        SomeAcceptFlag = 0
                        For x = 0 To PermNextno
                            For Y = 1 To CurrentXOver(x)
                                If XoverList(x, Y).Accept = 1 Then
                                    SomeAcceptFlag = 1
                                    Exit For
                                End If
                            Next Y
                            If SomeAcceptFlag = 1 Then Exit For
                        Next x
                        Dim AF As Byte
                        If SomeAcceptFlag = 1 Then
                            Response = MsgBox("Would you like to remove only manually 'accepted' evidence of recombination during tree construction. Pressing the 'No' button will remove all detected evidence of recombination whether manually accepted or not", 36)
                        Else
                            Response = 7
                            
                        End If
                        If Response = 7 Then
                            AF = 0
                        Else
                            AF = 1
                        End If
                        
                        
                        
                        
                        Dim tMissingData() As Byte
                        ReDim tMissingData(Len(StrainSeq(0)), NextNo)
                        For Y = 1 To SEventNumber
                            Bx = BestEvent(Y, 0)
                            By = BestEvent(Y, 1)
'                            If Left(TempSeq(0), 1) = "-" Then
'                                x = x
'                            End If
'                            If Y = 1854 Then
'                                x = x
'                            End If
                            
                            If XoverList(Bx, By).Accept <> 2 And XoverList(Bx, By).Beginning <> XoverList(Bx, By).Ending And (AF = 0 Or (AF = 1 And XoverList(Bx, By).Accept = 1)) Then
                              If Bx <= UBound(TempSeq, 1) Then
                                If TempSeq(Bx) <> "" Then
                                    If By = -1 Then Exit For
                                    BTree = XoverList(Bx, By).Beginning
                                    ETree = XoverList(Bx, By).Ending
                                    Dim LenRegion As Long
                                    
                                    For Z = 0 To PermNextno
                                        If Daught(Y, Z) > 0 Then
                                            If BTree < ETree Then
                                                LenRegion = ETree - BTree + 1
                                                Mid(TempSeq(Z), BTree, LenRegion) = String(LenRegion, "-")
                                                For D = BTree To ETree
                                                    tMissingData(D, Z) = 1
                                                Next D
                                            Else
                                                LenRegion = Len(StrainSeq(0)) - BTree + 1
                                                Mid(TempSeq(Z), BTree, LenRegion) = String(LenRegion, "-")
                                                For D = BTree To Len(StrainSeq(0))
                                                    tMissingData(D, Z) = 1
                                                Next D
                                                LenRegion = ETree
                                                Mid(TempSeq(Z), 1, LenRegion) = String(LenRegion, "-")
                                                For D = 1 To ETree
                                                    tMissingData(D, Z) = 1
                                                Next D
                                            End If
                                        End If
                                    Next Z
                                End If
                              End If
                            End If
                        Next Y
                        
                        
                        
                        
                        F2TreeIndex = 3
                        'TreeTypeFlag = 3
                        CurTree(3) = 0
                        CTF = 0
                        NHFlag = 17
                        PseudoFlag = 1
                        BusyWithTreeFlag = BusyWithTreeFlag + 1
                        Call NJTree2(0)
                        Erase TempSeq
                        TType = 0
                        TNum = 3
                        For x = 0 To NextNo
                            A = x
                            YPos = YCord(TType, TNum, A) - 1
                            MapBlockNumX = MapBlockNumX + 1
                            If MapBlockNumX > UBound(MapBlocks, 4) Then
                                ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                            End If
                            
                            MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                            MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                            MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(220, 220, 220) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
                            For D = 1 To Len(StrainSeq(0))
                                If tMissingData(D, A) = 0 Then
                                    MapBlockNumX = MapBlockNumX + 1
                                    If MapBlockNumX > UBound(MapBlocks, 4) Then
                                        ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                                    End If
                                    
                                    MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
                                    MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                                    MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
                                    For C = D + 1 To Len(StrainSeq(0))
                                        If tMissingData(C, A) = 1 Then
                                           'A = C - 1
                                           MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(C) - 1) / Decompress(Len(StrainSeq(0)))
                                           Exit For
                                        End If
                                        
                                    Next C
                                    D = C - 1
                                    If C = Len(StrainSeq(0)) + 1 Then
                                        MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                                    End If
                                End If
                            Next D
                            
                        Next x
                        
                        
                        Dim b As Long, UBA As Long, UBB As Long, UBC As Long, UBD As Long
'                        ubA = UBound(MapBlocks, 1)
'                        ubB = UBound(MapBlocks, 2)
'                        ubC = UBound(MapBlocks, 3)
'                        ubD = UBound(MapBlocks, 4)
'                        ReDim MapBlocksR(ubC, ubD, ubA, ubB)
'                        For A = 0 To ubA
'                            For B = 0 To ubB
'                                For C = 0 To ubC
'                                    For D = 0 To ubD
'                                        MapBlocksR(C, D, A, B) = MapBlocks(A, B, C, D)
'                                    Next D
'                                Next C
'                            Next B
'                        Next A
                        
                        MapBlockNum(TType, TNum) = MapBlockNumX
                        
                        PseudoFlag = 0
                        TreeImage(3) = 1
                        BusyWithTreeFlag = 0
                    
                    End If
                    
                    
                    
                End If
                
                TreeImage(3) = 1
                   
                ExtraDX = DoTreeColour(Form2.Picture2(3), 0, 3)
                
                Index = 3
                Dim tTYF As Double, TYFM As Integer
                'Call ModOffsets(8.25, Form2.Picture2(Index), tTYF, TYFM)
                
                'If PersistantP2tTYF = 0 Then
                    Call ModOffsets(8.25, Form2.Picture2(Index), tTYF, TYFM)
'                    PersistantP2tTYF = tTYF
'                    PersistantP2TYFM = TYFM
'                Else
'                    tTYF = PersistantP2tTYF
'                    TYFM = PersistantP2TYFM
'                End If
                
                otTYF = tTYF
                With Form2.VScroll1(Index)
                    VSMax = .Max
                    If VSMax <= 0 Then .Value = 0
                    
                    OVx = (.Value / .Max)
                    If OVx < 0 Then OVx = 0
                     
                    OV = .Value
                    OM = VSMax
                    
                    If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBound(TreeDraw, 5) Then
                        VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200
                    Else
                        VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
                    End If
                    If OM = 0 Then OM = 1
                    If VSMax > 32000 Then
                        F2VSScaleFactor(Index) = VSMax / 32000
                        VSMax = 32000
                    Else
                        F2VSScaleFactor(Index) = 1
                    End If
                    
                    
                    If VSMax > 0 Then
                        .Max = VSMax
                        If OVx * VSMax < VSMax Then
                            .Value = (OVx * (VSMax)) '0.168, 12967 ' - 200)) '(.Value / (OM / VSMax))
                            
                        ElseIf VSMax > 0 Then
                            .Value = VSMax
                        End If
                        
                        If .Value > VSMax Then .Value = VSMax
                        
                        If VSMax <= 0 Then
                            .Enabled = False
                        Else
                            .LargeChange = Form2.Picture2(Index).ScaleHeight
                            .Enabled = True
                        End If
                    End If
                    
                End With

                
                
            ElseIf CurTree(3) = 1 Then
                'Call DrawUPGMA5
                'Call DrawFastNJ5(Form2.Picture2(3))
                Call DrawML7(Form2.Picture2(3))
            ElseIf CurTree(3) = 2 Or CurTree(3) = 3 Then
                Call DrawML5(Form2.Picture2(3), 5)
            ElseIf CurTree(3) = 4 Then
                Call DrawML5(Form2.Picture2(3), 4)
            End If
        ElseIf x = 12345 Then
        
            If CurTree(3) = 1 Then
                'Call DrawUPGMA5
                Form2.Command1(Index).Enabled = False
                'Call DrawFastNJ5(Form2.Picture2(3))
                Call DrawML7(Form2.Picture2(3))
            ElseIf CurTree(3) = 3 Or CurTree(3) = 2 Then
                Form2.Command1(Index).Enabled = False
                Call DrawML5(Form2.Picture2(3), 5)
            ElseIf CurTree(3) = 4 Then
                Form2.Command1(Index).Enabled = False
                Call DrawML5(Form2.Picture2(3), 4)
            ElseIf CurTree(3) = 2 Then
                Form2.Command1(Index).Enabled = False
                Call DrawML5(Form2.Picture2(3), 5)
            End If
        
        End If
        If TreeImage(3) = 1 Then
        
            Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(3).Value, 3, CurTree(3), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(3))
        End If
    End If
    BusyWithTreeFlag = 0

   Erase TempSeq
   ' If TreeImage(3) = 1 Then
   '      Call DoTreeColour(Form2.Picture2(3), CurTree(3), 3)
   ' End If
    
    'These are used to colour the branches benieth selected nodes
    BranchFlashFlag = 0
    TreeDrawColBakFlag(0) = 0
    TreeDrawColBakFlag(1) = 0
    TreeDrawColBakFlag(2) = 0
    ReDim TTFlag(3, 4)

    For x = 0 To 3
        TTFlag(x, 0) = 1
    Next 'X
    TreeTypeFlag = oTTF
    
    Form2.Picture2(0).FontSize = OldFontSize
    'Form1.ProgressBar1.Value = 0
    'Form2.ProgressBar1.Value = 0
    CurTree(1) = 0
    CurTree(2) = 0
    'ReDim CurTree(3)
    Form2.Visible = True
    If UpdateProgressBar = 0 Then
        Form1.SSPanel1.Caption = ""
        Form2.SSPanel3.Caption = ""
    End If
    Form2.Enabled = True
    Screen.MousePointer = OP
    Form2.Refresh
    
    x = x
End Sub

Public Sub LXoverB(SFlag, SPF)



    'This subroutine executes LARD
    If LRDRegion > 2 Then LRDRegion = 2
    If LRDRegion < 1 Then LRDRegion = 1
    Dim TSeq(2) As String, x As Long, DF As Integer
    If LRDWin = 1 Then
        olrdwinlen = LRDWinLen
        If ManFlag = -1 And ExeCheckFlag = 1 Then
            If RelX > 0 Or RelY > 0 Then
                BPos = XoverList(RelX, RelY).Beginning
                Epos = XoverList(RelX, RelY).Ending
                If BPos < Epos Then
                    'LRDWinLen = EPos - BPos
                Else
                    'LRDWinLen = EPos + Len(StrainSeq(0)) - BPos
                End If
            End If
        End If
    End If
   ' XX = SeqNum(800, Seq1)
   ' XX = SeqNum(800, Seq2)
   ' XX = SeqNum(2, Seq3)
   'XX = MissingData(800, Seq3)
    For x = 1 To Len(StrainSeq(0))
        
        TSeq(0) = TSeq(0) + Chr(SeqNum(x, Seq1) - 1)
        TSeq(1) = TSeq(1) + Chr(SeqNum(x, Seq2) - 1)
        TSeq(2) = TSeq(2) + Chr(SeqNum(x, Seq3) - 1)
        
    Next x
    
    Dim PID As Long, ProcessID As Long, LastLen As Long, SCount As Long, FLen As Long, NewSurface As Long, Pict As Long, CurPos As Long, Count As Long, retVal As Long, NewPos As Long
    Dim PntAPI As POINTAPI
    Dim OldDir As String, LARDCLine As String, TitleTmp As String

    Const STILL_ACTIVE = &H103
    ReDim LXPos(Len(StrainSeq(0)))
    If SFlag = 0 Then
        Form1.ProgressBar1.Value = 0
        Call UpdateF2Prog
    End If
    'Disables various parts of the display area
    Form1.Picture26.Refresh
    If SFlag = 0 Then
        Call DisableInterface
    End If
    If SFlag = 0 Then
        Form1.ProgressBar1.Value = 3
    
        Form1.SSPanel1.Caption = "Executing LARD"
        Call UpdateF2Prog
    End If
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    OldDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    
    'Writes the alignment file for LARD
    Open "lardin" For Output As #1
    
    
    
    'LRDWin = 1
    'LRDWinLen = 200
    
    
    If LRDWin = 0 Then
        
        NumWins = 1
        
        Print #1, " 3  " + CStr(Len(StrainSeq(0))) ' 200"
        Print #1, "s1"
        Print #1, TSeq(0)
        Print #1, "s2"
        Print #1, TSeq(1)
        Print #1, "s3"
        Print #1, TSeq(2)
        
    Else
        
        'LRDWinLen = 200
        NumWins = (Len(StrainSeq(0)) - LRDWinLen) / LRDStep
        
        For x = 0 To NumWins - 1
            Print #1, " 3  " + CStr(LRDWinLen)
            Z = x * LRDStep + 1
            Print #1, "s1"
            Print #1, Mid$(TSeq(0), Z, LRDWinLen)
            Print #1, "s2"
            Print #1, Mid$(TSeq(1), Z, LRDWinLen)
            Print #1, "s3"
            Print #1, Mid$(TSeq(2), Z, LRDWinLen)
            Print #1, ""
        Next x
    End If
    Close #1
    'Exit Sub
    'Creates a fake outfile and then kills it
    Open "likelihood.surface" For Binary As 1
    Put #1, 1, ""
    Close #1
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "likelihood.surface"
    On Error GoTo 0
    'Creates a fake stackdump file and then kills it
    Open "LARD.EXE.stackdump" For Output As #1
    Close #1
    KillFile "LARD.EXE.stackdump"
    'Constructs the LARD command line
    LARDCLine = "lard.exe"
    
    If LRDWin = 0 Then
        LARDCLine = LARDCLine + " -r" + Trim(Str(CInt(LRDRegion)))
    Else
        LARDCLine = LARDCLine + " -r1"
    End If
    If LRDModel = 2 Then LRDModel = 0
    
    
    If LRDModel = 0 Or LRDModel = 1 Then

        If LRDModel = 0 Then
            LARDCLine = LARDCLine & " -mHKY"
        Else
            LARDCLine = LARDCLine & " -mF84"
        End If

        LARDCLine = LARDCLine & " -t" & LRDTvRat

        If LRDModel = 0 Or (LRDModel = 1 And LRDBaseFreqFlag = 1) Then

            If LRDAFreq <> LRDCFreq Or LRDAFreq <> LRDGFreq Or LRDAFreq <> LRDTFreq Then
                LARDCLine = LARDCLine & " -f" & LRDAFreq & " " & LRDCFreq & " " & LRDGFreq & " " & LRDTFreq
            End If

        End If

    Else
        LARDCLine = LARDCLine & " -mREV"

        If LRDAFreq <> LRDCFreq Or LRDAFreq <> LRDGFreq Or LRDAFreq <> LRDTFreq Then
            LARDCLine = LARDCLine & " -f" & LRDAFreq & " " & LRDCFreq & " " & LRDGFreq & " " & LRDTFreq
        End If

        If LRDACCoeff <> 1 Or LRDAGCoeff <> 1 Or LRDATCoeff <> 1 Or LRDCGCoeff <> 1 Or LRDCTCoeff <> 1 Then
            LARDCLine = LARDCLine & " -t" & LRDACCoeff & " " & LRDAGCoeff & " " & LRDATCoeff & " " & LRDCGCoeff & " " & LRDCTCoeff
        End If

    End If
    
    If LRDWin = 1 Then
        LARDCLine = LARDCLine + " -n" + CStr(Int(NumWins))
        LARDCLine = LARDCLine + " -u" + CStr(CLng(LRDWinLen / 2))
    Else
        LARDCLine = LARDCLine & " -w -s" & LRDStep
        LARDCLine = LARDCLine & " -z" + Trim(Str(CInt(LRDStep * 2)))
    End If
    
    
   

    If LRDCodon1 <> LRDCodon2 Or LRDCodon1 <> LRDCodon3 Then
        LARDCLine = LARDCLine & " -c" & LRDCodon1 & " " & LRDCodon2 & " " & LRDCodon3
    End If

    If LRDCategs > 0 Then
        LARDCLine = LARDCLine & " -g" & LRDCategs
        LARDCLine = LARDCLine & " -a" & LRDShape
    End If
    LARDCLine = LARDCLine & " -vp"
    LARDCLine = LARDCLine & " <lardin"
    'Creates a batch file so that lard can be executed with a command line
    
    
    'LARDCLine = "cmd.exe /c " + LARDCLine + " >c:\test.txt"
    'LARDCLine = "cmd.exe /c ping /? >c:\test.txt"
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Open "lard.bat" For Output As #1
    
    Do
        Pos = InStr(1, LARDCLine, ",")
        If Pos = 0 Then Exit Do
        Mid$(LARDCLine, Pos, 1) = "."
    Loop
    Print #1, LARDCLine
    Close #1
    On Error GoTo 0
    'Checks to see if a previously aborted run of lard was made and terminates it if necessary

    
    
    
    Dim OP As String
    'ProcessID = Shell("lard.bat", 1)
    'OP = GetCommandOutput(LARDCLine, True, True)
    'SS = Abs(GetTickCount)
    
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the LARD scan"
    
    Dim EC As Long
    EC = CInt(Len(StrainSeq(0)) / LRDStep) + 2
    'pvalcalc = 2*lik ratio chisquare with 4 df per breakpoint
    If LRDWin = 1 Then
        ExpectFL = 36 * NumWins
    Else
        If LRDRegion = 2 Then
            
            ExpectFL = EC * EC * 22
                
        End If
    End If
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "likelihood.surface"
    On Error GoTo 0
    
    If LRDWin = 1 Then
        OP = GetCommandOutput("lard.bat", 3, True, False)
    Else
        If LRDRegion = 1 Then
            OP = GetCommandOutput("lard.bat", LRDRegion, True, True)
        Else
            Response = MsgBox("You have opted to use LARD to test for two breakpoints. This scan could take a very long time, during which RDP will become almost completely unresponsive.  Would you like to proceed?", vbYesNo)
            'Exit Sub
            If Response = 7 Then
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                ChDir OldDir
                ChDrive OldDir
                On Error GoTo 0
                Exit Sub
            End If
            OP = GetCommandOutput("lard.bat", LRDRegion, True, True)
        End If
    End If
    'EE = Abs(GetTickCount)
    'TT = EE - SS '3.734,3.735,3.703 -sleep100, 1.703,1.781,1.734-sleep0
    
    Pos = InStr(1, OP, "STATUS_ACCESS_VIOLATION", vbBinaryCompare)
    If Pos > 0 Then
         'LARD has failed
         MsgBox ("Execution of LARD failed because it did not have write access in the directory from which it is being run.  This could happen because of your Windows security settings in the directory where you have RDP installed")
         Form1.ProgressBar1.Value = 0
         Form1.SSPanel1.Caption = ""
         Call UpdateF2Prog
         Call EnableInterface
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
         Exit Sub
    End If
    
    
    If AbortFlag = 1 Then
                OldAbort = 1
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                ChDir OldDir
                ChDrive OldDir
                On Error GoTo 0
                If SFlag = 0 Then
                    Form1.ProgressBar1.Value = 0
                
                    Form1.SSPanel1.Caption = ""
                    Call UpdateF2Prog
                    Call EnableInterface
                    Form1.Command25.Enabled = False
                    Form1.Command25.ToolTipText = ""
                End If
                
                
                
                
                
                'I've temporarily removed this to try stabilise the program
                'GetExitCodeProcess lProcess, tExitCode
                'TerminateProcess lProcess, tExitCode
                'CloseHandle lProcess
                If LRDWin = 1 Then
                    olrdwinlen = LRDWinLen
                    
                End If
                AbortFlag = 0
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                ChDir OldDir
                ChDrive OldDir
                On Error GoTo 0
                Exit Sub
    End If
    XX = Len(OP)
    
    
    Pos = InStr(1, OP, "No recombination: lik=", vbBinaryCompare)
    Pos = Pos + 22
    Pos2 = InStr(Pos + 1, OP, Chr(13), vbBinaryCompare)
    If Pos2 = 0 Then
        Pos2 = InStr(Pos + 1, OP, Chr(10), vbBinaryCompare)
    End If
    If Pos2 - Pos > 20 Then
        Pos2 = InStr(Pos + 1, OP, "Branches", vbBinaryCompare)
    End If
    If Pos > 22 Then
    
        'xxx = Mid$(OP, 582, Pos2 - Pos)
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        MaxL = val(Mid$(OP, Pos, Pos2 - Pos))
        On Error GoTo 0
    'Exit Sub
    End If
    
    ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    
    If LRDWin = 0 Then
    
        Open "likelihood.surface" For Binary As #1
            VarString = String$(LOF(1), " ")
            FLen = LOF(1)
            
            Get #1, 1, VarString
            Close #1
            CurPos = 0
            
            If FLen <> LastLen Then
                LastLen = FLen
                
                If LRDRegion = 1 Then
                
                    ReDim LXPos(0, EC)
                    ReDim LSurface(EC)
                    Do
                        NewPos = InStr(CurPos + 1, VarString, Chr$(9), vbBinaryCompare)
        
                        If NewPos > 0 Then
                            Count = Count + 1
                            
                            If Count > UBound(LXPos, 2) Then
                                ReDim Preserve LXPos(0, Count * 2)
                            End If
                            LXPos(0, Count) = CDbl(Mid$(VarString, CurPos + 1, NewPos - CurPos))
                        Else
                            Exit Do
                        End If
        
                        NewSurface = InStr(NewPos + 1, VarString, Chr$(13), vbBinaryCompare)
        
                        If NewSurface > 0 Then
                            
                            If Count > UBound(LSurface, 1) Then
                                ReDim Preserve LSurface(Count * 2)
                            End If
                            LSurface(Count) = val(Mid$(VarString, NewPos + 1, NewSurface - NewPos))
                            If MaxL = 0 Then
                                MaxL = LSurface(Count)
                                MinL = LSurface(Count) - 50
                                Form1.Picture10.ScaleMode = 3
                                Form1.Picture7.ScaleMode = 3
                                Form1.Picture7.BackColor = BackColours
                                Form1.Picture10.BackColor = BackColours
                                Form1.Picture10.ScaleMode = 3
                                Form1.Picture7.ScaleMode = 3
                                GYAxHi(1) = Decompress(Len(StrainSeq(0)))
                                'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MaxL - MinL, 0, 1, "Log likelihood ratio")
        
                            End If
        
                        Else
                            Count = Count - 1
        
                            If SCount = 0 Then SCount = 2
                            Form1.Picture7.DrawWidth = 1
        
                            If TManFlag = -1 Then
        
                                Call Highlight(0)
        
                            End If
        
                            Form1.Picture7.ForeColor = 0
                            Pict = Form1.Picture7.hdc
'                            MoveToEx Pict, 30 + (Decompress(LXPos(0, SCount))) * xFactor, PicHeight - (15 + (1 - ((LSurface(SCount) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
'
'                            For X = SCount + 1 To Count
'                                LineTo Pict, 30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35))
'                            Next 'X
        
                            Form1.Picture7.Refresh
                            Form1.Picture10.Refresh
                            SCount = Count - 1
                            Exit Do
                        End If
                        If SFlag = 0 Then
                            Form1.ProgressBar1.Value = 95 + (LXPos(0, Count) / Len(StrainSeq(0))) * 5
                            Call UpdateF2Prog
                        End If
                        CurPos = NewSurface + 1
                    Loop
                Else
                    Dim Count2 As Long, Numcounts As Long
                    Numcounts = EC * (EC) / 2 + 1
                    ReDim LXPos(1, Numcounts)
                    Count2 = 1
                    CurPos = 0
                    ReDim LSurface(Numcounts)
                    Do
                        NewPos = InStr(CurPos + 1, VarString, Chr$(9), vbBinaryCompare)
        
                        If NewPos > 0 Then
                            Count = Count + 1
                            
                            co1 = CDbl(Mid$(VarString, CurPos + 1, NewPos - CurPos))
                            CurPos = NewPos
                            NewPos = InStr(CurPos + 1, VarString, Chr$(9), vbBinaryCompare)
                            'newpos2 = InStr(CurPos + 1, VarString, Chr$(13), vbBinaryCompare)
                            'If NewPos > newpos2 Then NewPos = newpos2
                            If NewPos > 0 Then
                                co2 = CDbl(Mid$(VarString, CurPos + 1, NewPos - CurPos))
                            End If
                            CurPos = NewPos
                            
                            
                            If Count > UBound(LXPos, 2) Then ReDim Preserve LXPos(1, Count * 2)
                            LXPos(0, Count) = co1
                            LXPos(1, Count) = co2
                        Else
                            Exit Do
                        End If
        
                        NewSurface = InStr(NewPos + 1, VarString, Chr$(13), vbBinaryCompare)
        
                        If NewSurface > 0 Then
                            
                            If Count > UBound(LSurface, 1) Then ReDim Preserve LSurface(Count * 2)
                            LSurface(Count) = val(Mid$(VarString, NewPos + 1, NewSurface - NewPos))
                            
        
                        Else
                            
                            
        
                            
                            Form1.Picture7.DrawWidth = 1
        
                            If TManFlag = -1 Then
        
                                Call Highlight(0)
        
                            End If
        
                            Form1.Picture7.ForeColor = 0
                            
                            
                            
'                                For X = 1 To Count
'                                    Form1.Picture7.Line (30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))-(30 + (Decompress(LXPos(1, X))) * xFactor, PicHeight - (15 + PicHeight - 35)), 0, B
'                                Next 'X
                            
                            Form1.Picture7.Refresh
                            Form1.Picture10.Refresh
                            SCount = Count - 1
                            Exit Do
                        End If
                        If SFlag = 0 Then
                            Form1.ProgressBar1.Value = 95 + (Count2 / EC) * 5
                            Call UpdateF2Prog
                        End If
                        CurPos = NewSurface + 1
                    Loop
                End If
    
            End If
    Else
        'read positions from op
        ReDim LXPos(0, NumWins)
        ReDim LSurface(NumWins)
        Open "screen.out" For Output As #1
        Print #1, OP
        Close #1
        x = x
        Pos = InStr(1, OP, "cross", vbBinaryCompare)
        If Pos > 0 Then
            LastPos = Pos
            
            For x = 0 To Int(NumWins) - 1
                For Y = 0 To 2
                    Pos = InStr(LastPos + 1, OP, Chr(9), vbBinaryCompare)
                    LastPos = Pos
                    'XX = Mid$(OP, Pos, 20)
                    x = x
                Next Y
                TPos = Pos
                Pos = InStr(LastPos + 1, OP, Chr(9), vbBinaryCompare)
                LastPos = Pos
                
                LSurface(x + 1) = CDbl(Mid$(OP, TPos + 1, Pos - TPos - 1))
                LXPos(0, x + 1) = (LRDStep * x) + LRDWinLen / 2
            Next x
        Else
            'handle this sometime
        End If
    End If
    'MaxL = 0
    MinL = 1000000
    
    
    'If LRDRegion = 2 Then
    '    'get minval at every position along the alignment
    '    Dim maxlik() As Double
    '
        
    'End If
    'If LRDRegion = 1 Then
    
    
   If LRDRegion = 2 Then
        Dim MaxReg() As Double
        ReDim MaxReg(Len(StrainSeq(0)))
        For x = 1 To Count
            MaxReg(LXPos(1, x) - LXPos(0, x)) = MaxL + 1000000
           
        Next x
        For x = 1 To Count
            If MaxReg(LXPos(1, x) - LXPos(0, x)) > LSurface(x) Then
                MaxReg(LXPos(1, x) - LXPos(0, x)) = LSurface(x)
            End If
        Next x
    End If
    
    
   Dim XP1 As Long, XP2 As Long, MinPA As Double, MinPA2 As Double, MinLA As Double, MinLA2 As Double, DB As Long, DE As Long
   
   If ManFlag <> 6 And (RelX > 0 Or RelY > 0) Then
        
        BE = XoverList(RelX, RelY).Beginning
        EN = XoverList(RelX, RelY).Ending
        If LRDRegion = 1 Then
            BE = BE - LRDStep
            EN = EN + LRDStep
        End If
        If EN > Len(StrainSeq(0)) Then EN = EN - Len(StrainSeq(0))
        If BE < 1 Then BE = BE + Len(StrainSeq(0))
        MinLA = 100000000
        MinLA2 = 100000000
        If LRDWin = 0 Then
            If LRDRegion = 1 Then 'look for maxpeaks close to estimated breakpoints
                 For x = 1 To Count
             
                     'If MaxL < LSurface(X) Then
                     '    MaxL = LSurface(X)
                     If MinL > LSurface(x) Then
                         MinL = LSurface(x)
                     End If
                     If BE < EN Then
                     
                        If LXPos(0, x) >= BE And LXPos(0, x) <= EN Then
                            DB = Abs(LXPos(0, x) - BE)
                            If DB > Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE) Then
                                DB = Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE)
                            End If
                            DE = Abs(LXPos(0, x) - EN)
                            If DE > Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN) Then
                                DE = Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN)
                            End If
                            If DB < DE Then
                                If LSurface(x) < MinLA Then
                                    MinLA = LSurface(x)
                                    XP1 = LXPos(0, x)
                                End If
                            Else
                                If LSurface(x) < MinLA2 Then
                                    MinLA2 = LSurface(x)
                                    XP2 = LXPos(0, x)
                                End If
                            End If
                        End If
                     Else
                        If LXPos(0, x) >= BE Or LXPos(0, x) <= EN Then
                            DB = Abs(LXPos(0, x) - BE)
                            If DB < Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE) Then
                                DB = Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE)
                            End If
                            DE = Abs(LXPos(0, x) - EN)
                            If DE < Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN) Then
                                DE = Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN)
                            End If
                            If DB < DE Then
                                If LSurface(x) < MinLA Then
                                    MinLA = LSurface(x)
                                    XP1 = LXPos(0, x)
                                End If
                            Else
                                If LSurface(x) < MinLA2 Then
                                    MinLA2 = LSurface(x)
                                    XP2 = LXPos(0, x)
                                End If
                            End If
                        End If
                     End If
                     'if lxpos(x)
             
                 Next 'X
             Else
                Dim MinlPos() As Double
                'redim MatrixL(
                ReDim MinlPos(Len(StrainSeq(0)))
                For x = 1 To Len(StrainSeq(0))
                    MinlPos(x) = 1000000
                Next x
                For x = 1 To Count
                    If MinL > LSurface(x) Then
                        MinL = LSurface(x)
                    End If
                    If LSurface(x) = MaxReg(LXPos(1, x) - LXPos(0, x)) Then
                        For Y = LXPos(0, x) To LXPos(1, x)
                            If MinlPos(Y) > LSurface(x) Then
                                MinlPos(Y) = LSurface(x)
                            End If
                        Next Y
                    End If
                Next x
                If BE < EN Then
                    For x = BE To EN
                        XP1 = BE
                        XP2 = EN
                        
                        
                        If MinLA > MinlPos(x) Then
                            MinLA = MinlPos(x)
                            
                        End If
                    Next x
                        
                Else
                    If Len(StrainSeq(0)) - BE > EN Then
                        XP1 = 1
                        XP2 = BE
                    Else
                        XP1 = EN
                        XP2 = Len(StrainSeq(0))
                    End If
                        
                    For x = 1 To EN
                        If MinLA > MinlPos(x) Then
                            MinLA = MinlPos(x)
                            
                        End If
                    Next x
                    For x = BE To Len(StrainSeq(0))
                        If MinLA > MinlPos(x) Then
                            MinLA = MinlPos(x)
                            
                        End If
                    Next x
                End If
                        
             End If
        
        Else
            MinL = 0
            MinLA = 0
            MinLA2 = 0
            For x = 1 To NumWins
             
                'If MaxL < LSurface(X) Then
                '    MaxL = LSurface(X)
                If MinL < LSurface(x) Then
                    MinL = LSurface(x)
                End If
                If BE < EN Then
                
                   If LXPos(0, x) >= BE And LXPos(0, x) <= EN Then
                       DB = Abs(LXPos(0, x) - BE)
                       If DB > Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE) Then
                           DB = Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE)
                       End If
                       DE = Abs(LXPos(0, x) - EN)
                       If DE > Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN) Then
                           DE = Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN)
                       End If
                       If DB < DE Then
                           If LSurface(x) > MinLA Then
                               MinLA = LSurface(x)
                               XP1 = LXPos(0, x)
                           End If
                       Else
                           If LSurface(x) > MinLA2 Then
                               MinLA2 = LSurface(x)
                               XP2 = LXPos(0, x)
                           End If
                       End If
                   End If
                Else
                   If LXPos(0, x) <= EN Or LXPos(0, x) >= BE Then
                       DB = Abs(LXPos(0, x) - BE)
                       If DB < Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE) Then
                           DB = Abs(LXPos(0, x) + Len(StrainSeq(0)) - BE)
                       End If
                       DE = Abs(LXPos(0, x) - EN)
                       If DE < Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN) Then
                           DE = Abs(LXPos(0, x) + Len(StrainSeq(0)) - EN)
                       End If
                       If DB < DE Then
                           If LSurface(x) > MinLA Then
                               MinLA = LSurface(x)
                               XP1 = LXPos(0, x)
                           End If
                       Else
                           If LSurface(x) > MinLA2 Then
                               MinLA2 = LSurface(x)
                               XP2 = LXPos(0, x)
                           End If
                       End If
                   End If
                End If
                'if lxpos(x)
        
            Next 'X
             
            'sort out minpa etc for scanwindow
            
        End If
    End If
    Dim MC As Double
    If MCFlag = 0 Then
        MC = MCCorrection * (Len(StrainSeq(0)) / LRDStep)
    Else
        MC = (Len(StrainSeq(0)) / LRDStep)
    End If
    
    If LRDWin = 0 Then
        If LRDRegion = 1 Then
            MinPA = chi2((MaxL - MinLA) * 2, 4) * MC
            MinPA2 = chi2((MaxL - MinLA2) * 2, 4) * MC
        Else
            MinPA = chi2((MaxL - MinLA) * 2, 8) * MC
        End If
    Else
        'window minpa worked out here
        MinPA = chi2(MinLA * 2, 4) * MC
        MinPA2 = chi2(MinLA2 * 2, 4) * MC
    End If
    'XX = chi2(22, 4)
    EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    
    If Confirm(EN, 7) > 0 Then
        If Abs(ConfirmP(EN, 7)) < 300 Then
            PT = 10 ^ (-ConfirmP(EN, 7))
        Else
            PT = 10 ^ 300
        End If
    Else
        PT = 1
    End If
    
    If (Confirm(EN, 7) = 0 Or (Confirm(EN, 7) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 7) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                
                ConfirmP(EN, 7) = -Log10(MinPA)
                
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 7) = -Log10(MinPA2)
                
            End If
            
            'XX = -Log10(0.5)
            'X = X

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            Form1.Refresh
            If DebuggingFlag < 2 Then
                Form1.WindowState = Form1.WindowState
            End If
    End If
    
    
    If LRDWin = 0 Then
        'If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        On Error Resume Next
        Kill "ls.surface"
        
        Name "likelihood.surface" As "ls.surface"
        On Error GoTo 0
        Open "screen.out" For Output As #1
        Print #1, OP
        Close #1
    End If
    
    
    If SFlag = 0 Then
    
        Form1.Picture10.ScaleMode = 3
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.BackColor = BackColours
        Form1.Picture10.BackColor = BackColours
    End If
    
    'put likelihoods into matrixl
    If LRDRegion = 2 And LRDWin = 0 Then
        dims = CLng((Count * 2) ^ 0.5 + 0.5)
        ReDim MatrixL(dims + 1, dims + 1)
        
        Dim XC As Long, YC As Long
        For x = 1 To Count
          XC = CLng(LXPos(0, x) / (LRDStep))
          YC = CLng(LXPos(1, x) / (LRDStep))
          
          MatrixL(XC, YC) = MaxL - LSurface(x)
          MatrixL(YC, XC) = MatrixL(XC, YC)
          
        Next x
        MaxN = FindMaxNS(dims, MatrixL(0, 0))
        
        MatBound(11) = MaxN
        
        Form1.Check1.Enabled = False
        If SFlag = 0 Then
            If ButtonScrollFlag = 0 And CurMatrixFlag = 11 Then DoneMatX(11) = 0
            CurMatrixFlag = 11
            Call DrawLRDMat
        
            Call DoMatCap
        End If
        CurMatrixFlag = 11
    End If
    Call FindSubSeqBS
    
    MaxVGC = 3
    
    If SPF = 1 Then
        If SFlag = 0 Then
        Dim CritLR As Double
        If LRDWin = 0 Then
            DF = 4 * LRDRegion
            CritLR = (GetCritChi((LowestProb / ((MCCorrection * ((Len(StrainSeq(0)) / LRDStep))))), DF)) / 2
            If (MaxL - MinL) < CritLR Then MinL = MaxL - CritLR
            GYAxHi(1) = Decompress(Len(StrainSeq(0)))
            'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MaxL - MinL, 0, 1, "Log likelihood ratio")
        Else
            DF = 4
            CritLR = (GetCritChi(LowestProb / (MCCorrection * (Len(StrainSeq(0)) / LRDWinLen)), DF)) / 2
            If CritLR > MinL Then MinL = CritLR '12.7
            GYAxHi(1) = Decompress(Len(StrainSeq(0)))
            'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MinL, 0, 1, "Log likelihood ratio")
        End If
        
        
        
        '14.161
        
        
        
       
        'Prepare .wmf info
        
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq '96
            GVarPos(0, x) = XDiffPos(x) '57,58,95,101, 105
        Next x
        ReDim GCritval(10)
        GCritval(0) = CritLR
        GLegend = "Log likelihood ratio"
        GExtraTNum = -1
        If LRDWin = 1 Then
            ReDim GPrint(0, NumWins + 1), GPrintCol(0), GPrintPos(0, NumWins + 1)
            
            GPrintLen = NumWins - 1 'how many points to plot
            GPrintCol(0) = 0 'line is black
            GPrintNum = 0 'only one line
            GPrintType = 0 'a normal line plot
            GPrintMin(0) = 0 'bottom val
            GPrintMin(1) = MinL 'upper val
            GBlockNum = -1
            GPrint(0, 0) = MaxL - LSurface(2)
            GPrint(0, 1) = MaxL - LSurface(2)
            For x = 1 To GPrintLen + 1
                
                GPrint(0, x + 1) = LSurface(x)
                GPrintPos(0, x + 1) = LXPos(0, x)
            Next x
        Else
            ReDim GCritval(10)
            GCritval(0) = CritLR
            If LRDRegion = 1 Then
                ReDim GPrint(0, Count), GPrintCol(0), GPrintPos(0, Count)
                GPrintLen = Count - 1 'how many points to plot
                GPrintCol(0) = 0 'line is black
                GPrintNum = 0 'only one line
                GPrintType = 0 'a normal line plot
                GPrintMin(0) = 0
                
                GPrintMin(1) = MaxL - MinL
                GBlockNum = -1
                GPrint(0, 0) = MaxL - LSurface(2)
                GPrint(0, 1) = MaxL - LSurface(2)
                For x = 1 To GPrintLen
                    
                    
                    GPrint(0, x + 1) = (MaxL - LSurface(x))
                    GPrintPos(0, x + 1) = LXPos(0, x + 1)
                Next x
            Else
                
                ReDim GPrint(0, Count), GPrintCol(0), GPrintPos(0, 1, Count)
                GPrintLen = Count - 1 'how many points to plot
                GPrintCol(0) = 0 'line is black
                GPrintNum = 0 'only one line
                GPrintType = 1 'a region plot
                GPrintMin(0) = 0
                GPrintMin(1) = MaxL - MinL
                GBlockNum = -1
                Z = 0
                For x = 1 To GPrintLen
                    If LSurface(x + 1) = MaxReg(LXPos(1, x + 1) - LXPos(0, x + 1)) Then
                        
                        GPrint(0, Z) = MaxL - LSurface(x + 1)
                        GPrintPos(0, 0, Z) = LXPos(0, x + 1)
                        GPrintPos(0, 1, Z) = LXPos(1, x + 1)
                        Z = Z + 1
                    End If
                    
                Next x
                GPrintLen = Z - 1
            End If
        End If
        
        
        Form1.Picture7.ForeColor = RGB(180, 180, 180)
        Form1.Picture7.DrawWidth = 3
        Pict = Form1.Picture7.hdc
        'First do the background
        
        If LRDWin = 1 Then
'            MoveToEx Pict, 30 + (Decompress(LXPos(0, 1))) * xFactor, PicHeight - (15 + (((LSurface(1)) / (MinL))) * (PicHeight - 35)), PntAPI
'
'            For X = 2 To NumWins - 1
'                LineTo Pict, 30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (((LSurface(X)) / (MinL))) * (PicHeight - 35))
'            Next 'X
        Else
            If LRDRegion = 1 Then
'                MoveToEx Pict, 30 + (Decompress(LXPos(0, 1))) * xFactor, PicHeight - (15 + (1 - ((LSurface(1) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
'
'                For X = 2 To Count
'                    LineTo Pict, 30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35))
'                Next 'X
            
            End If
        End If
        If TManFlag = -1 Then
    
            Call Highlight(0)
    
        End If
        'Draw Critical value
        Form1.Picture7.DrawStyle = 2
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.ForeColor = 0
        Pict = Form1.Picture7.hdc
        
        
        
        
        If LRDWin = 1 Then
'            MoveToEx Pict, 25, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35)), PntAPI
'            LineTo Pict, 30 + (Decompress(Len(StrainSeq(0)))) * xFactor, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35))
            CritLR = (GetCritChi(LowestProb / (Len(StrainSeq(0)) / LRDWinLen), DF)) / 2
'            MoveToEx Pict, 25, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35)), PntAPI
'            LineTo Pict, 30 + (Decompress(Len(StrainSeq(0)))) * xFactor, PicHeight - (15 + (CritLR / MinL) * (PicHeight - 35))
    
        Else
'            MoveToEx Pict, 25, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
'            LineTo Pict, 30 + (Decompress(Len(StrainSeq(0)))) * xFactor, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35))
            CritLR = (GetCritChi(LowestProb / (Len(StrainSeq(0)) / LRDStep), DF)) / 2
'            MoveToEx Pict, 25, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
'            LineTo Pict, 30 + (Decompress(Len(StrainSeq(0)))) * xFactor, PicHeight - (15 + (1 - ((MaxL - (CritLR + MinL)) / (MaxL - MinL))) * (PicHeight - 35))
        End If
        Form1.Picture7.DrawStyle = 0
        
        
        
        Form1.Picture7.ForeColor = 0
        Pict = Form1.Picture7.hdc
        If LRDWin = 1 Then
'            MoveToEx Pict, 30 + (Decompress(LXPos(0, 1))) * xFactor, PicHeight - (15 + (((LSurface(1)) / (MinL))) * (PicHeight - 35)), PntAPI
'
'            For X = 2 To NumWins - 1
'                LineTo Pict, 30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (((LSurface(X)) / (MinL))) * (PicHeight - 35))
'            Next 'X
        Else
            If LRDRegion = 1 Then
                'Then do the foreground
'                MoveToEx Pict, 30 + (Decompress(LXPos(0, 1))) * xFactor, PicHeight - (15 + (1 - ((LSurface(1) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI
'
'                For X = 2 To Count
'                    LineTo Pict, 30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35))
'                Next 'X
            Else
               
                Form1.Picture7.DrawWidth = 1
                Pict = Form1.Picture7.hdc
                                    
                                    LLx = -1
                                    'For Y = 1 To Count
                                        If x = 12345 Then
'                                            For X = 1 To Count
'
'                                                Form1.Picture7.Line (30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))-(30 + (Decompress(LXPos(1, X))) * xFactor, PicHeight - (15 + (1 - ((MaxL - MinL) / (MaxL - MinL))) * (PicHeight - 35))), 0, B
'                                            Next X
                                        ElseIf x = 12345 Then
                                            For x = 1 To Count
'                                                If LXPos(0, X) <> LLx Then
'                                                    Dummy = MoveToEx(Pict, 30 + (Decompress(LXPos(1, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)), PntAPI)
'                                                    'Dummy = LineTo(Pict, 30 + (LXPos(1, X)) * XFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))
'                                                Else
'                                                    Dummy = LineTo(Pict, 30 + (Decompress(LXPos(1, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))
'                                                End If
                                                LLx = LXPos(0, x)
                                            
                                            Next 'X
                                        
                                        Else
'                                            For X = 1 To Count
'                                                If LSurface(X) = MaxReg(LXPos(1, X) - LXPos(0, X)) Then
'                                                    Form1.Picture7.Line (30 + (Decompress(LXPos(0, X))) * xFactor, PicHeight - (15 + (1 - ((LSurface(X) - MinL) / (MaxL - MinL))) * (PicHeight - 35)))-(30 + (Decompress(LXPos(1, X))) * xFactor, PicHeight - (15 + (1 - ((MaxL - MinL) / (MaxL - MinL))) * (PicHeight - 35))), 0, B
'                                                End If
'                                            Next X
                                        End If
                                    'Next Y
                                    Form1.Picture7.Refresh
                                    Form1.Picture10.Refresh
                                    
                                    SCount = Count - 1
                                    
                End If
            
            End If
        End If
        ProbY = 1
        If LRDRegion = 1 Or LRDWin = 1 Then
            If MinPA < 1 Then
                ProbTest$ = MinPA
                ProbX = Decompress(XP1)
                If SFlag = 0 Then
                    
                    Call PrintProbability
                    If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                        If MinPA < MinPA2 Then
                            XoverList(RelX, RelY).Probability = MinPA
                        End If
                    End If
                End If
            End If
            If MinPA2 < 1 Then
                ProbTest$ = MinPA2
                ProbX = Decompress(XP2)
                If SFlag = 0 Then
                    Call PrintProbability
                    If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                        If MinPA2 < MinPA Then
                            XoverList(RelX, RelY).Probability = MinPA2
                        End If
                    End If
                End If
            End If
        Else
            If MinPA < 1 Then
                ProbTest$ = MinPA
                ProbX = Decompress(XP1) + (Decompress(XP2) - Decompress(XP1)) / 2
                If SFlag = 0 Then
                    Call PrintProbability
                    If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                        XoverList(RelX, RelY).Probability = MinPA
                    End If
                End If
            End If
        End If
    End If
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    ChDir OldDir
    ChDrive OldDir
    On Error GoTo 0
    'Reenable/disbale all the relevant controlls
    
    If SFlag = 0 Then
        
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
        Call EnableInterface
    End If
    
    
    
   
     
    If LRDWin = 1 Then
        LRDWinLen = olrdwinlen
        
    End If
    
    Form1.Picture21.Width = Form1.Picture7.Width + 100
    Form1.Picture21.Height = Form1.Picture7.Height + 100
    
    
    Call RedrawPlotAA(1)
    
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
    
On Error GoTo 0

End Sub



Public Sub GetCriticalDiff(PR)
Dim C As Long, D As Long, LastChi As Double, x As Long, LastLoChi As Double, LastHiChi As Double, TempChi As Double, hPrb As Double, TPVal As Double, HMChi As Double, A As Long, b As Long, lPrb As Double
If PR = 0 Then
    If MCWinSize < 10 Then
        MCWinSize = pMCWinSize
        HWindowWidth = CLng(MCWinSize / 2)
    End If
Else
     If CWinSize < 10 Then
        CWinSize = pCWinSize
        HWindowWidth = CLng(CWinSize / 2)
    End If
End If
If x = 1234567890 Then
Redo:
    If PR = 0 Then
        HWindowWidth = CLng(pMCWinSize / 2)
    Else
        HWindowWidth = CLng(pCWinSize / 2)
    End If
End If

lPrb = LowestProb / 6

If lPrb < 0.0001 Then lPrb = 0.0001
'lPrb = 0.05
hPrb = lPrb * 1.000000001
lPrb = lPrb * 0.999999999

'Calculate critical Chi
HMChi = 5
LastChi = 1
TPVal = 10
Do While TPVal > lPrb
   HMChi = HMChi * 2
   TPVal = ChiPVal(HMChi)
   If TPVal = 10 ^ -20 Then
      lPrb = TPVal
      Exit Do
    End If
Loop
LastLoChi = 0
LastHiChi = HMChi * 2
Dim LastTPval As Double
Do
    TPVal = ChiPVal(HMChi)
    If TPVal * 1.000000001 > LastTPval And TPVal * 0.9999999999 < LastTPval Then
        Exit Do
    End If
    If TPVal < lPrb Then
        TempChi = HMChi
        HMChi = HMChi - (HMChi - LastLoChi) / 2
        If HMChi = TempChi Then Exit Do
        LastHiChi = TempChi
    ElseIf TPVal > hPrb Then
        TempChi = HMChi
        HMChi = HMChi + (LastHiChi - HMChi) / 2
        If HMChi = TempChi Then Exit Do
        LastLoChi = TempChi
    Else
        Exit Do
    End If
    LastTPval = TPVal
Loop
CriticalChi = HMChi

LastLoChi = 0
LastHiChi = HWindowWidth
CriticalDiff = HWindowWidth / 2
Dim ChiHold As Double
ChiHold = 0
Do
    If CriticalDiff < 2 Then
        CriticalDiff = 2
        Exit Do
    End If
    A = 0
    b = HWindowWidth
    C = CriticalDiff
    D = HWindowWidth - C
    HMChi = (A * D - b * C) ^ 2 * HWindowWidth * 2
    HMChi = HMChi / (A + b)
    HMChi = HMChi / (C + D)
    HMChi = HMChi / (A + C)
    HMChi = HMChi / (b + D)
    If HMChi > CriticalChi Then
        TempChi = CriticalDiff
        CriticalDiff = CriticalDiff - (CriticalDiff - LastLoChi) / 2
        LastHiChi = TempChi
        ChiHold = HMChi
    ElseIf HMChi < CriticalChi Then
        TempChi = CriticalDiff
        CriticalDiff = CriticalDiff + (LastHiChi - CriticalDiff) / 2
        LastLoChi = TempChi
    Else
        Exit Do
    End If
Loop While LastHiChi <> CriticalDiff And CriticalDiff <> LastLoChi
CriticalDiff = CriticalDiff - 1

If ChiHold < CriticalChi And ChiHold <> 0 Then
    HWindowWidth = HWindowWidth * 1.5
    GoTo Redo
End If



End Sub
Public Function CalcChivalue(A As Long, C As Long, TotalLen As Long)
    Dim HMChi As Double
    Dim b As Long, D As Long, TotLen As Long
    b = TotalLen - A
    D = TotalLen - C
    If A + C > 0 And b + D > 0 Then
        HMChi = (A * D - b * C) ^ 2 * TotalLen * 2
        HMChi = HMChi / (A + b)
        HMChi = HMChi / (C + D)
        HMChi = HMChi / (A + C)
        HMChi = HMChi / (b + D)
    Else
        HMChi = 0
    End If
'    If hMChi > 10 Then
'        X = X
'    End If
    CalcChivalue = CSng(HMChi)
    
End Function

Public Function CalcChiValue2(AA As Long, CC As Long, TotalLenA As Long, TotalLenC As Long)
    Dim HMChi As Double, A As Long, C As Long
    Dim TotalLen As Long, b As Long, D As Long, TotLen As Long
    
    A = AA
    C = CC
    If TotalLenA > 0 And TotalLenC > 0 Then
        If TotalLenC < TotalLenA Then
            If TotalLenA > 0 Then
                A = CLng((A / TotalLenA) * TotalLenC)
                TotalLen = TotalLenC
            
            
            End If
        Else
            C = CLng((C / TotalLenC) * TotalLenA)
            TotalLen = TotalLenA
        End If
        b = TotalLen - A
        D = TotalLen - C
        If A + C > 0 And b + D > 0 Then
            HMChi = (A * D - b * C) ^ 2 * (TotalLen * 2)
            HMChi = HMChi / (A + b)
            HMChi = HMChi / (C + D)
            HMChi = HMChi / (A + C)
            HMChi = HMChi / (b + D)
        Else
            HMChi = 0
        End If
    '    If hMChi > 10 Then
    '        X = X
    '    End If
        
    Else
        HMChi = 0
    End If
    CalcChiValue2 = CSng(HMChi)
End Function
Public Sub GetCriticalZ()
Dim Temp As Variant, LastLoZ As Double, LastHiZ As Double, TempZ As Double, hPrb As Double, TPVal As Variant, hMZ As Double, lPrb As Double

Redo:
If LowestProb = 0 Then LowestProb = 0.05
If MCCorrection = 0 Then MCCorrection = 1
If MCFlag = 0 And TManFlag <> 9 Then
        lPrb = LowestProb / MCCorrection
Else
    lPrb = LowestProb
End If

hPrb = lPrb / 0.9999
lPrb = lPrb * 0.9999

'Calculate critical Z
hMZ = 5
TPVal = 10
Do While TPVal > lPrb
   hMZ = hMZ * 2
   If hMZ < 6 Then
    TPVal = NormalZ(hMZ)
   Else
        'If hMZ > 20 Then hMZ = 20
        Temp = ((hMZ - 6) * 10)
        
        If Temp > 170 Then Temp = 170
        Temp = 1.6 ^ Temp
        TPVal = (10 ^ -9) / Temp
   End If
Loop
LastLoZ = 0
LastHiZ = hMZ * 2
Do
    TPVal = NormalZ(hMZ)
    If TPVal < lPrb Then
        If CLng(hMZ * 100000) = CLng(LastLoZ * 100000) Then Exit Do
        TempZ = hMZ
        hMZ = hMZ - (hMZ - LastLoZ) / 2
        LastHiZ = TempZ
    ElseIf TPVal > hPrb Then
        TempZ = hMZ
        hMZ = hMZ + (LastHiZ - hMZ) / 2
        LastLoZ = TempZ
    Else
        Exit Do
    End If
Loop
CriticalZ = hMZ



End Sub

Public Sub CXoverB()
Dim Chivals() As Double, Scores() As Byte, Winscores() As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, Spos As Long, Epos As Long, step As Long, LSeq As Long, Last As Long, NumSites As Long, NumPairs As Long, NumTaxa As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double

oMCWinSize = MCWinSize
oMCWinfract = MCWinFract
AllowExtraSeqsFlag = 0
SpacerNo = 0
AllowExtraSeqsFlag = 0
NumSites = Len(StrainSeq(0))
step = CSteplen
Last = NumSites
tSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
If XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
    If Abs(CLng(Abs(XoverList(RelX, RelY).DHolder))) <= NextNo Then
        Seq1 = CLng(Abs(XoverList(RelX, RelY).DHolder))
    Else
        Call CXoverC(0)
        Exit Sub
    End If
    'XOverList(RelX, RelY).DHolder = 51
    'Seq1 = 6
    'XOverList(RelX, RelY).LHolder = 75
    If Seq1 = tSeq1 Then
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq2 Then
        Seq2 = tSeq1
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq3 Then
        Seq2 = tSeq1
        Seq3 = tSeq2
    End If
Else
    Seq1 = tSeq3
    Seq2 = tSeq1
    Seq3 = tSeq2
End If

ReDim Scores(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
ReDim Chivals(Len(StrainSeq(0)))


ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)


'7.14 of 32
    
LenXoverSeq = 0

'If MCStripGapsFlag = 0 Then
'    LenXoverSeq = FindSubSeqB(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'Else

    'This could be speeded up with better nesting
    LenXoverSeq = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'End If
oCWinSize = CWinSize
oCWinfract = CWinFract

If XoverList(RelX, RelY).ProgramFlag = 4 And ExeCheckFlag = 0 Then
    CWinSize = XoverList(RelX, RelY).LHolder
    WindowWidth = CWinSize
    HWindowWidth = CLng(WindowWidth / 2)
Else
    If OptFlag <> 4 Then
            BE = XoverList(RelX, RelY).Beginning
            EN = XoverList(RelX, RelY).Ending
            If BE < EN Then
                CWinSize = XPosDiff(EN) - XPosDiff(BE) + 1
            Else
                CWinSize = XPosDiff(EN) + (LenXoverSeq - XPosDiff(BE)) + 1
            End If
            
            CWinSize = CWinSize * 2
            CWinFract = CWinSize / LenXoverSeq
    End If
    
    If CProportionFlag = 0 Then
        WindowWidth = CWinSize
        HWindowWidth = CLng(WindowWidth / 2)
    Else
        If Int(CWinFract * LenXoverSeq) > 20 And Int(CWinFract * LenXoverSeq) < (LenXoverSeq / 1.5) Then
            WindowWidth = (Int((CWinFract * LenXoverSeq) / 2) * 2 - 2)
        ElseIf Int(CWinFract * LenXoverSeq) <= 20 Then
    
            If LenXoverSeq > 15 Then
                WindowWidth = 20
            Else
                Exit Sub
            End If
    
        ElseIf Int(CWinFract * LenXoverSeq) >= (LenXoverSeq / 1.5) Then
    
            If LenXoverSeq / 1.5 > 10 Then
                WindowWidth = (Int((LenXoverSeq / 1.5) / 2) * 2 - 2)
            Else
                Exit Sub
            End If
    
        End If
        HWindowWidth = CLng(WindowWidth / 2)
        ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2)
        Call GetCriticalDiff(1)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
            CWinSize = HWindowWidth * 2
        End If
    End If
    
    If HWindowWidth > LenXoverSeq / 2 Then
        HWindowWidth = LenXoverSeq - HWindowWidth + 1
        If HWindowWidth < 3 Then
            HWindowWidth = LenXoverSeq / 2
        End If
    End If
End If
Spos = -HWindowWidth
Epos = LenXoverSeq + HWindowWidth

'9 of 32
Dummy = WinScoreCalc4(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0), XDiffPos(0), SeqNum(0, 0), Winscores(0))

'5,38,71,2704,37,12,51

'If Dummy = 0 Then Exit Sub

'9 of 32
'This could be speeded up with better nesting
MChi = CalcChiVals3(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0), Chivals(0))

x = x
'51.157:33,79
'30.98,431,20,0.75,0 9 15
If MCFlag = 0 Then
    lPrb = LowestProb / MCCorrection
Else
    lPrb = LowestProb
End If

'If ChiPVal(mChi) > lPrb Then Exit Sub
MChi = ChiPVal(MChi) * (LenXoverSeq / (HWindowWidth))
MChi = -Log10(MChi)


MCMinChiP = MChi
    

If MCFlag = 0 Then
    If MCMinChiP < -Log10(LowestProb / MCCorrection) Then MCMinChiP = -Log10(LowestProb / MCCorrection)
Else
    If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
End If

MChi = MCMinChiP


    For Y = 0 To LenXoverSeq
        'If CLng(pCWinSize / 2) > HWindowWidth Then
            Chivals(Y) = ChiPVal(Chivals(Y)) * (LenXoverSeq / (HWindowWidth)) * 3
            'XX = ChiVals(y) * MCCorrection
        'Else
        '    ChiVals(y) = ChiPVal(ChiVals(y)) * (LenXOverSeq / (CLng(pCWinSize / 2))) * 3
        'End If
        'ChiVals(Y) = ChiPVal(ChiVals(Y)) * (LenXoverSeq / (HWindowWidth))
        If Chivals(Y) > 1 Then
            Chivals(Y) = 1
        End If
    Next Y



        
        ReDim GPVTFont(5, 100), GPVText(100)
        GPVTNum = -1

        Form1.Frame17.Visible = False
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.AutoRedraw = True
        Dim PntAPI As POINTAPI
        Dim Pict As Long
        Form1.Picture7 = LoadPicture()
        ReDim MCPrintPos(LenXoverSeq)
        ReDim MCPrintData(LenXoverSeq)
        
        For x = 0 To LenXoverSeq
            MCPrintPos(x) = XDiffPos(x)
        Next x

        YScaleFactor = 0.85
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MChi, 0, 1, "-Log[P(Chi2)]")
        
        PicHeight = (Form1.Picture7.Height * YScaleFactor)
        Form1.Picture7.DrawWidth = 3
        
            
            'Form1.Picture7.Line (0, 0)-(100, 100), 0, BF
            Form1.Picture7.ForeColor = HalfColour
            
            Pict = Form1.Picture7.hdc
'            Dummy = MoveToEx(Pict, (30 + (Decompress(XDiffPos(0)) + (Decompress(XDiffPos(1)) - Decompress(XDiffPos(0))) / 2) * xFactor), -15 + PicHeight - (-Log10(Chivals(0)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(0) = Chivals(0)
            For x = 1 To LenXoverSeq - 1
                MCPrintData(x) = Chivals(x)
'                Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(X)) + (Decompress(XDiffPos(X + 1)) - Decompress(XDiffPos(X))) / 2) * xFactor, -15 + PicHeight - (-Log10(Chivals(X)) / MChi) * (PicHeight - 35))
                
            Next '
        
        Form1.Picture7.DrawWidth = 1
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
        End If
        Form1.Picture7.DrawStyle = 2

        Dim ZP As Double
    
        If ExeCheckFlag = 1 Or MCFlag <> 0 Then
            ZP = LowestProb
'            Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35))), QBColor(0)
        End If
    
'        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35))), QBColor(0)
        Form1.Picture7.DrawStyle = 0
        
        
            
            'Form1.Picture7.Line (0, 0)-(100, 100), 0, BF
            Form1.Picture7.ForeColor = 0
            Pict = Form1.Picture7.hdc
'            Dummy = MoveToEx(Pict, (30 + (Decompress(XDiffPos(0)) + (Decompress(XDiffPos(1)) - Decompress(XDiffPos(0))) / 2) * xFactor), -15 + PicHeight - (-Log10(Chivals(0)) / MChi) * (PicHeight - 35), PntAPI)
            MCPrintData(0) = Chivals(0)
            For x = 1 To LenXoverSeq - 1
                MCPrintData(x) = Chivals(x)
'                Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(X)) + (Decompress(XDiffPos(X + 1)) - Decompress(XDiffPos(X))) / 2) * xFactor, -15 + PicHeight - (-Log10(Chivals(X)) / MChi) * (PicHeight - 35))
                
            Next '
            
    
    
    'Get everything into the standard format for printing and saving
        
        NumLines = 1 'number of lines to print
        ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
    
        ReDim GVarPos(2, LenXoverSeq)
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = XDiffPos(x)
        Next x
        ReDim GCritval(10)
        GCritval(0) = -Log10((LowestProb / MCCorrection))
        GCritval(1) = -Log10((LowestProb))
        GLegend = "-Log[Chi2 P-Val]"
        GPrintLen = LenXoverSeq + 1 'how many points to plot
        GPrintCol(0) = 0 'line is black
        
        GPrintNum = NumLines - 1 '1 line
        GPrintType = 0 'a normal line plot
        
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = MChi  'upper val
        
        For x = 1 To LenXoverSeq - 1
            
                GPrint(0, x) = -Log10(Chivals(x))
                
                GPrintPos(0, x) = (XDiffPos(x) + (XDiffPos(x + 1) - XDiffPos(x)) / 2)
                
            
        Next x
        
        
        'XX = GPrint(1, 0)
        
            GPrint(0, LenXoverSeq) = -Log10(Chivals(0))
            GPrintPos(0, LenXoverSeq) = (XDiffPos(x) + (Len(StrainSeq(0)) - XDiffPos(x)) / 2)
        
'        For X = 0 To NumLines - 1
'            GPrintPos(X, GPrintLen) = Len(StrainSeq(0))
'            GPrint(X, GPrintLen) = (GPrint(X, GPrintLen - 1) + GPrint(X, 1)) / 2
'            GPrintPos(X, GPrintLen - 1) = XDiffPos(LenXOverSeq) + (Len(StrainSeq(0)) - XDiffPos(LenXOverSeq)) / 2
'
'            GPrintPos(X, 0) = 1
'            GPrint(X, 0) = (GPrint(X, GPrintLen - 1) + GPrint(X, 1)) / 2
'        Next X
        GExtraTNum = 0
        ReDim GExtraText(GExtraTNum)
        GExtraText(0) = OriginalName(tSeq1) + " vs " + OriginalName(tSeq2) + " & " + OriginalName(tSeq3)
        
    
      
    'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    'call Highlight (0)
    Dim TB As Long, TE As Long

    If XoverList(RelX, RelY).Beginning - 20 < 0 Then
        TB = XoverList(RelX, RelY).Beginning - 20 + Len(StrainSeq(0))
    Else
        TB = XoverList(RelX, RelY).Beginning - 20
    End If

    If XoverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XoverList(RelX, RelY).Ending + 20 - Len(StrainSeq(0))
    Else
        TE = XoverList(RelX, RelY).Ending + 20
    End If

    Dim Z As Long, MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    If TE > TB Then

        For x = 0 To LenXoverSeq
'
            If XDiffPos(x) >= TB - 50 And XDiffPos(x) < TE + 50 Then

                    If MCPrintData(x) > 0 Then

                        If MCPrintData(x) < MinPA2 And Abs(TE - (XDiffPos(x))) < Abs(TB - (XDiffPos(x))) Then
                            MinPA2 = MCPrintData(x)
                            XP2 = XDiffPos(x)
                        ElseIf MCPrintData(x) < MinPA And Abs(TE - (XDiffPos(x))) > Abs(TB - (XDiffPos(x))) Then
                            MinPA = MCPrintData(x)
                            XP1 = XDiffPos(x)
                        End If
                    End If
                

            End If

        Next 'X
x = x
    Else

        For x = 0 To LenXoverSeq - 1
            'XX = XPosdiff(TB)
            If XDiffPos(x) >= TB - 50 Or XDiffPos(x) <= TE + 50 Then
            

                    If XDiffPos(x) <= TE + 50 Then

                        If MCPrintData(x) > 0 And MCPrintData(x) < MinPA2 And Abs(TE - (XDiffPos(x))) < Abs(XDiffPos(x) + (Len(StrainSeq(0)) - TB)) Then
                            MinPA2 = MCPrintData(x)
                            XP2 = XDiffPos(x)
                        ElseIf MCPrintData(x) > 0 And MCPrintData(x) < MinPA And (Abs(TE - (XDiffPos(x))) > Abs(XDiffPos(x) + (Len(StrainSeq(0)) - TB))) Then
                            MinPA = MCPrintData(x)
                            XP1 = XDiffPos(x)
                        End If

                    ElseIf XDiffPos(x) >= TB - 50 Then

                        If MCPrintData(x) > 0 And MCPrintData(x) < MinPA2 And TE + (Len(StrainSeq(0)) - (XDiffPos(x))) < Abs(XDiffPos(x) - TB) Then
                            MinPA2 = MCPrintData(x)
                            XP2 = XDiffPos(x)
                        ElseIf MCPrintData(x) > 0 And MCPrintData(x) < MinPA And TE + (Len(StrainSeq(0)) - (XDiffPos(x))) > Abs(XDiffPos(x) - TB) Then
                            MinPA = MCPrintData(x)
                            XP1 = XDiffPos(x)
                        End If

                    End If

                

            End If

        Next 'X

    End If
    
    
    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)
  '  If HWindowWidth > 0 Then
  '      MinPA = MinPA * MCCorrection
  '      MinPA2 = MinPA2 * MCCorrection
  '  Else
  '       MinPA = 1
  '        MinPA2 = 1
  '
  '  End If
    
    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrection
        MinPA2 = MinPA2 * MCCorrection
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(4, MinPA)
        MinPA2 = StepDown2(4, MinPA2)
    End If
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    
    If Confirm(EN, 4) > 0 Then
        If Abs(ConfirmP(EN, 4)) < 300 Then
            PT = 10 ^ (-ConfirmP(EN, 4))
        Else
            PT = 10 ^ 300
        End If
    Else
        PT = 1
    End If
    
    If x = x Or (XoverList(RelX, RelY).ProgramFlag <> 4 And XoverList(RelX, RelY).ProgramFlag <> 4 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA

        If (Confirm(EN, 4) = 0 Or (Confirm(EN, 4) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 4) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA2)
            End If

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If

        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

'    Else
'
'        If XoverList(RelX, RelY).BeginP < XoverList(RelX, RelY).EndP Then
'
'            If XoverList(RelX, RelY).SBPFlag <> 1 Then
'                POrder(0) = XoverList(RelX, RelY).BeginP
'                POrder(2) = XoverList(RelX, RelY).Beginning
'            Else
'                POrder(0) = 0
'            End If
'
'            If XoverList(RelX, RelY).SBPFlag <> 2 Then
'                POrder(1) = XoverList(RelX, RelY).EndP
'                POrder(3) = XoverList(RelX, RelY).Ending
'            Else
'                POrder(1) = 0
'            End If
'
'        Else
'
'            If XoverList(RelX, RelY).SBPFlag <> 1 Then
'                POrder(1) = XoverList(RelX, RelY).BeginP
'                POrder(3) = XoverList(RelX, RelY).Beginning
'            Else
'                POrder(1) = 0
'            End If
'
'            If XoverList(RelX, RelY).SBPFlag <> 2 Then
'                POrder(0) = XoverList(RelX, RelY).EndP
'                POrder(2) = XoverList(RelX, RelY).Ending
'            Else
'                POrder(0) = 0
'            End If
'
'        End If

    End If

    For A = 0 To 1
        ProbX = Decompress(POrder(A + 2))

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then
                If DontRedrawPlotsFlag = 0 Then
                    Call PrintProbability
                End If
                If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                    If POrder(0) <= POrder(1) Then
                        XoverList(RelX, RelY).Probability = POrder(0)
                    Else
                        XoverList(RelX, RelY).Probability = POrder(1)
                    End If
                End If
            End If
            If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                BestParent = CheckParent: WinMethod = 4
                BestParentP = MinPA
            End If
            If MinPA2 < BestParentP And MinPA2 < LowestProb And MinPA2 > 0 Then
                BestParent = CheckParent: WinMethod = 4
                BestParentP = MinPA2
            End If
        End If

    Next 'A
CWinSize = oCWinSize
CWinFract = oCWinfract
Seq1 = tSeq1
Seq2 = tSeq2
Seq3 = tSeq3
 MCWinSize = oMCWinSize
MCWinFract = oMCWinfract
ReDim CXoverSeq(2)
Dim TS1 As String, TS2 As String, TS3 As String, YPX As Long, TSX As Long
TS1 = String(LenXoverSeq, " ")
TS2 = String(LenXoverSeq, " ")
TS3 = String(LenXoverSeq, " ")
For x = 1 To LenXoverSeq

    YPX = XDiffPos(x)
    TSX = TreeTrace(Seq1)
    Mid$(TS1, x, 1) = Mid$(StrainSeq(TSX), YPX, 1)
    TSX = TreeTrace(Seq2)
    Mid$(TS2, x, 1) = Mid$(StrainSeq(TSX), YPX, 1)
    TSX = TreeTrace(Seq3)
    Mid$(TS3, x, 1) = Mid$(StrainSeq(TSX), YPX, 1)
Next x
CXoverSeq(0) = TS1
CXoverSeq(1) = TS2
CXoverSeq(2) = TS3

Call RedrawPlotAA(1)


If MinPA < MinPA2 Then
    MinPAGlobal = MinPA
Else
    MinPAGlobal = MinPA2
End If

End Sub
Public Sub CXoverC(SPF)



Dim TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, Spos As Long, Epos As Long, step As Long, LSeq As Long, Last As Long, NumSites As Long, NumPairs As Long, NumTaxa As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double
Dim Z As Long, MinPA As Double, MinPA2 As Double
NumSites = Len(StrainSeq(0))
step = CSteplen
Last = NumSites
tSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
'Dim xdiffposc() As Long
Dim XPosDiff() As Long




ReDim XDiffPosC(Len(StrainSeq(0)) + 200, 2)
ReDim XPosDiff(Len(StrainSeq(0)) + 200, 2)
GDPCFlag = 1

ReDim xLenXoverSeq(2)
NumTaxa = NextNo + 1
'7.14 of 32
    
LenXoverSeq = 0


oMCWinSize = MCWinSize
oMCWinfract = MCWinFract

'If MCStripGapsFlag = 0 Then
'    LenXoverSeq = FindSubSeqB(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), xdiffposc(0), XPosDiff(0))
'Else
'rearrange the seq order so that the correct sequence comes first
If (XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum) Then
    If Abs(CLng(XoverList(RelX, RelY).DHolder)) = Seq2 Then
        CycleNo = 2
    ElseIf Abs(CLng(XoverList(RelX, RelY).DHolder)) = Seq3 Then
        CycleNo = 1
    Else
        CycleNo = 0
    End If

End If
ReDim xLenXoverSeq(2)
For Z = 0 To 2
    If Z = 0 Then
        Seq1 = tSeq1
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Z = 1 Then
        Seq1 = tSeq2
        Seq2 = tSeq1
        Seq3 = tSeq3
    Else
        Seq1 = tSeq3
        Seq2 = tSeq1
        Seq3 = tSeq2
    End If
    'This could be speeded up with better nesting
    xLenXoverSeq(Z) = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPosC(0, Z), XPosDiff(0, Z))
    If xLenXoverSeq(Z) > LenXoverSeq Then LenXoverSeq = xLenXoverSeq(Z)
'End If
Next Z

Dim oCWinSize As Long
oCWinSize = CWinSize
oCWinfract = CWinFract
Dim MAxD As Long, tstD  As Long, winz As Long
MAxD = 0
winz = 4

Dim MinLen As Long, MaxLen As Long
MinLen = 1000000
MaxLen = 0
For x = 0 To 2
    If xLenXoverSeq(x) < MinLen Then MinLen = xLenXoverSeq(x)
    If xLenXoverSeq(x) > MaxLen Then MaxLen = xLenXoverSeq(x)
Next x
If MinLen < 2 Then Exit Sub
If XoverList(RelX, RelY).ProgramFlag = 4 And OptFlag <> 11 And Abs(CLng(XoverList(RelX, RelY).DHolder)) <= NextNo Then
    CWinSize = XoverList(RelX, RelY).LHolder
    If CWinSize < 3 Then
        If oCWinSize < 3 Then
            oCWinSize = 60
            CWinSize = 60
        Else
            CWinSize = oCWinSize
        
        End If
    End If
    WindowWidth = CWinSize
    HWindowWidth = CLng(WindowWidth / 2)
    x = x
Else
    If OptFlag <> 11 Then
        BE = XoverList(RelX, RelY).Beginning
        EN = XoverList(RelX, RelY).Ending
        For Z = 0 To 2
            If BE < EN Then
                If MAxD < XPosDiff(EN, Z) - XPosDiff(BE, Z) + 1 Then
                    MAxD = XPosDiff(EN, Z) - XPosDiff(BE, Z) + 1
                    winz = Z
                End If
            Else
                If MAxD < (XPosDiff(EN, Z) + (xLenXoverSeq(Z) - XPosDiff(BE, Z)) + 1) Then
                    MAxD = XPosDiff(EN, Z) + (xLenXoverSeq(Z) - XPosDiff(BE, Z)) + 1
                    winz = Z
                End If
            End If
        Next Z
    End If

    For Z = 0 To 2
        If (Z = winz And (XoverList(RelX, RelY).ProgramFlag <> 4 And XoverList(RelX, RelY).ProgramFlag <> 4 + AddNum)) Or ((XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum) And CycleNo = Z) Then
        
            If OptFlag <> 11 Then
                    BE = XoverList(RelX, RelY).Beginning
                    EN = XoverList(RelX, RelY).Ending
                    If BE < EN Then
                        CWinSize = XPosDiff(EN, Z) - XPosDiff(BE, Z) + 1
                        'Exit Sub
                    Else
                        CWinSize = XPosDiff(EN, Z) + (LenXoverSeq - XPosDiff(BE, Z)) + 1
                    End If
                    
                    CWinSize = CWinSize * 2
                    CWinFract = CWinSize / LenXoverSeq
            End If
            Exit For
        End If
    Next Z
    If CWinSize > MaxLen / 3 Then CWinSize = MaxLen / 3
End If



    If CProportionFlag = 0 Then
        WindowWidth = CWinSize
        HWindowWidth = CLng(WindowWidth / 2)
    Else
        If Int(CWinFract * LenXoverSeq) > 20 And Int(CWinFract * LenXoverSeq) < (LenXoverSeq / 1.5) Then
            WindowWidth = (Int((CWinFract * LenXoverSeq) / 2) * 2 - 2)
        ElseIf Int(CWinFract * LenXoverSeq) <= 20 Then
    
            If LenXoverSeq > 15 Then
                WindowWidth = 20
            Else
                CWinSize = oCWinSize
                Exit Sub
            End If
    
        ElseIf Int(CWinFract * LenXoverSeq) >= (LenXoverSeq / 1.5) Then
    
            If LenXoverSeq / 1.5 > 10 Then
                WindowWidth = (Int((LenXoverSeq / 1.5) / 2) * 2 - 2)
            Else
                CWinSize = oCWinSize
                Exit Sub
            End If
    
        End If
        HWindowWidth = CLng(WindowWidth / 2)
        'ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
        Call GetCriticalDiff(1)
        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
        CWinSize = HWindowWidth * 2
    End If
End If

If HWindowWidth > LenXoverSeq / 2 Then
    HWindowWidth = LenXoverSeq - HWindowWidth + 1
    If HWindowWidth < 3 Then
        HWindowWidth = LenXoverSeq / 2
    End If
End If

Spos = -HWindowWidth
Epos = LenXoverSeq + HWindowWidth

'9 of 32
Dim omChi As Double
omChi = 0
Dim Longest As Long
Longest = 0
For Z = 0 To 2
    If Longest < xLenXoverSeq(Z) Then
        Longest = xLenXoverSeq(Z)
    End If
    
Next Z
If Longest < CWinSize Then CWinSize = Longest * 0.6666
ReDim Chivals(Len(StrainSeq(0)), 2)
For Z = 0 To 2
    If HWindowWidth < xLenXoverSeq(Z) Then
        If Z = 0 Then
            Seq1 = tSeq1
            Seq2 = tSeq2
            Seq3 = tSeq3
        ElseIf Z = 1 Then
            Seq1 = tSeq2
            Seq2 = tSeq1
            Seq3 = tSeq3
        Else
            Seq1 = tSeq2
            Seq2 = tSeq3
            Seq3 = tSeq1
        End If
        
        'for some reason the order of the sequences is importnant here - if sequences go in in the wrong
        'order all the winscores are zero
        ReDim Scores(Len(StrainSeq(0)), 2) ' 0=s1,s2Matches etc
        ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc

        Dummy = WinScoreCalc4(CriticalDiff, HWindowWidth, xLenXoverSeq(Z), Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, Z), XDiffPosC(0, Z), SeqNum(0, 0), Winscores(0, Z))
        
        
    'If Dummy = 0 Then Exit Sub
    
    '9 of 32
        'This could be speeded up with better nesting
        MChi = CalcChiVals3(CriticalDiff, HWindowWidth, xLenXoverSeq(Z), Len(StrainSeq(0)), Winscores(0, Z), Chivals(0, Z))
        
        
        '13.148,0,22.1833
        'XOverList(RelX, RelY).LHolder = 51
        ''30.98,431,20,0.75,0 9 15
        If omChi < MChi Then
            omChi = MChi
            HC = xLenXoverSeq(Z)
        End If
    End If
    
    If HWindowWidth = 0 Then CWinSize = oCWinSize: Exit Sub
    
    For Y = 1 To xLenXoverSeq(Z)
        'If HWindowWidth < CLng(pCWinSize / 2) Then
            Chivals(Y, Z) = ChiPVal(Chivals(Y, Z)) * (xLenXoverSeq(Z) / (HWindowWidth)) * 3
        'Else
        '    ChiVals(y, Z) = ChiPVal(ChiVals(y, Z)) * (xLenXoverSeq(Z) / (CLng(pCWinSize / 2))) * 3
        'End If
        If Chivals(Y, Z) > 1 Then Chivals(Y, Z) = 1
    Next Y
    
Next Z

Erase Scores
Erase Winscores
        
MChi = omChi
If MCFlag = 0 Then
    lPrb = LowestProb / MCCorrection
Else
    lPrb = LowestProb
End If

'If ChiPVal(mChi) > lPrb Then Exit Sub
MChi = ChiPVal(MChi) * (HC / (HWindowWidth))
MChi = -Log10(MChi)


MCMinChiP = MChi
    

If MCFlag = 0 Then
    If MCMinChiP < -Log10(LowestProb / MCCorrection) Then MCMinChiP = -Log10(LowestProb / MCCorrection)
Else
    If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
End If

MChi = MCMinChiP


 Dim TB As Long, TE As Long

    If XoverList(RelX, RelY).Beginning - 20 < 0 Then
        TB = XoverList(RelX, RelY).Beginning - 20 + Len(StrainSeq(0))
    Else
        TB = XoverList(RelX, RelY).Beginning - 20
    End If

    If XoverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XoverList(RelX, RelY).Ending + 20 - Len(StrainSeq(0))
    Else
        TE = XoverList(RelX, RelY).Ending + 20
    End If

    
    MinPA = 1
    MinPA2 = 1
    For Z = 0 To 2
        If TE > TB Then
    
            For x = 0 To xLenXoverSeq(Z)
    '
                If XDiffPosC(x, Z) >= TB - 50 And XDiffPosC(x, Z) < TE + 50 Then
    
                    
    
                        If Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA2 And Abs(TE - (XDiffPosC(x, Z))) < Abs(TB - (XDiffPosC(x, Z))) Then
                            MinPA2 = Chivals(x, Z)
                            XP2 = XDiffPosC(x, Z)
                        ElseIf Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA And Abs(TE - (XDiffPosC(x, Z))) > Abs(TB - (XDiffPosC(x, Z))) Then
                            MinPA = Chivals(x, Z)
                            XP1 = XDiffPosC(x, Z)
                        End If
    
                    
    
                End If
    
            Next 'X
    
        Else
    
            For x = 1 To LenXoverSeq - 1
                If Chivals(x, Z) > 0 Then
                    If XDiffPosC(x, Z) >= TB - 50 Or XDiffPosC(x, Z) <= TE + 50 Then
        
                        
        
                            If XDiffPosC(x, Z) <= TE + 50 Then
        
                                If Chivals(x, Z) < MinPA2 And Abs(TE - (XDiffPosC(x, Z))) < Abs(XDiffPosC(x, Z) + (Len(StrainSeq(0)) - TB)) Then
                                    MinPA2 = Chivals(x, Z)
                                    XP2 = XDiffPosC(x, Z)
                                ElseIf Chivals(x, Z) < MinPA And (Abs(TE - (XDiffPosC(x, Z))) > Abs(XDiffPosC(x, Z) + (Len(StrainSeq(0)) - TB))) Then
                                    MinPA = Chivals(x, Z)
                                    XP1 = XDiffPosC(x, Z)
                                End If
        
                            ElseIf XDiffPosC(x, Z) >= TB - 50 Then
                                
                                    If Chivals(x, Z) < MinPA2 And TE + (Len(StrainSeq(0)) - (XDiffPosC(x, Z))) < Abs(XDiffPosC(x, Z) - TB) Then
                                        MinPA2 = Chivals(x, Z)
                                        XP2 = XDiffPosC(x, Z)
                                    ElseIf Chivals(x, Z) < MinPA And TE + (Len(StrainSeq(0)) - (XDiffPosC(x, Z))) > Abs(XDiffPosC(x, Z) - TB) Then
                                        MinPA = Chivals(x, Z)
                                        XP1 = XDiffPosC(x, Z)
                                    End If
        
                            End If
        
                        
        
                    End If
                End If
            Next 'X
    
        End If
    Next Z
    
    
    'Dim ProbTest As String
    
    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrection
        MinPA2 = MinPA2 * MCCorrection
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(4, MinPA)
        MinPA2 = StepDown2(4, MinPA2)
    End If







If BestRescanFlag = 1 Then
    If BestRescanP > MinPA And MinPA < LowestProb And MinPA > 0 Then
        BestRescanP = MinPA
    End If
    If BestRescanP > MinPA2 And MinPA2 < LowestProb And MinPA2 > 0 Then
        BestRescanP = MinPA2
    End If
End If
If (SPF = 0 And UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And (BestRescanP = MinPA Or BestRescanP = MinPA2)) Then
        
        ReDim GPVTFont(5, 100), GPVText(100)
        GPVTNum = -1
        
        Dim red As Long, Green As Long, blue As Long
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
                
        
        Form1.Frame17.Visible = False
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.AutoRedraw = True
        Dim PntAPI As POINTAPI
        Dim Pict As Long
        'Form1.Picture7 = LoadPicture()
        ReDim MCPrintPos(LenXoverSeq, 2)
        ReDim MCPrintData(LenXoverSeq, 2)
        For Z = 0 To 2
            For x = 0 To LenXoverSeq
                MCPrintPos(x, Z) = XDiffPosC(x, Z)
            Next x
        Next Z
        YScaleFactor = 0.85
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MChi, 0, 0, "-Log[Chi2 P-Val]")
        
        
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        
        Dim OX As Long, MiY As Long, MaY As Long, YP As Long, XP As Long
        
        
        PicHeight = (Form1.Picture7.Height * YScaleFactor)
        'Form1.Picture7.DrawWidth = 3
        Form1.Picture7.DrawWidth = 3
        hGreen = RGB(CInt(BkR - BkR / 8), CInt(BkG - BkG / 24), CInt(BkB - BkB / 8))
        hRed = RGB(CInt(BkR - BkR / 24), CInt(BkB - BkB / 8), CInt(BkG - BkG / 8))
        hBlue = RGB(CInt(BkR - BkR / 8), CInt(BkG - BkG / 8), CInt(BkB - BkB / 24))
        
'        For Z = 0 To 2
'            If Z = 0 Then
'                Form1.Picture7.ForeColor = hGreen 'hRed
'            ElseIf Z = 1 Then
'                Form1.Picture7.ForeColor = hBlue
'            Else
'                Form1.Picture7.ForeColor = hRed 'hGreen
'            End If
'            Pict = Form1.Picture7.hDC
'            Dummy = MoveToEx(Pict, (30 + (Decompress(xdiffposc(1, Z)) + (Decompress(xdiffposc(2, Z)) - Decompress(xdiffposc(1, Z))) / 2) * xFactor), -15 + PicHeight - (-Log10(Chivals(1, Z)) / MChi) * (PicHeight - 35), PntAPI)
'            MCPrintData(1, Z) = Chivals(1, Z)
'
'            OX = 0
'            For X = 2 To LenXOverSeq - 1
'                MCPrintData(X, Z) = Chivals(X, Z)
'                XP = 30 + (Decompress(xdiffposc(X, Z)) + (Decompress(xdiffposc(X + 1, Z)) - Decompress(xdiffposc(X, Z))) / 2) * xFactor
'                YP = -15 + PicHeight - (-Log10(Chivals(X, Z)) / MChi) * (PicHeight - 35)
'                If XP <> OX Then
'                    MiY = 100000
'                    MaY = 0
'                End If
'                'MCPrintData(Y, X) = Chivals(X, Y)
'                If YP <= PicHeight - 15 And XP >= OX Then
'                    If YP > MaY Or YP < MiY Then
'                        Dummy = LineTo(Pict, XP, YP)
'                        If YP > MaY Then MaY = YP
'                        If YP < MiY Then MiY = YP
'                    End If
'                    OX = XP
'                End If
'            Next '
'        Next 'Z
        
        
        
        
        Form1.Picture7.DrawWidth = 1
        'call Highlight (0)
        Form1.Picture7.DrawStyle = 0
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
        End If
        
        
        

        Dim ZP As Double
    
'        If ExeCheckFlag = 1 Or MCFlag <> 0 Then
'            ZP = LowestProb
'            Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / MChi) * (PicHeight - 35))), QBColor(0)
'        End If
'
'        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / MChi) * (PicHeight - 35))), QBColor(0)
'        Form1.Picture7.DrawStyle = 0
'
       
        
        
'       For Z = 0 To 2
'            If Z = 0 Then
'                Form1.Picture7.ForeColor = green 'red
'            ElseIf Z = 1 Then
'                Form1.Picture7.ForeColor = blue
'            Else
'                Form1.Picture7.ForeColor = red 'green
'            End If
'            Pict = Form1.Picture7.hDC
'            XP = (30 + (Decompress(xdiffposc(1, Z)) + (Decompress(xdiffposc(2, Z)) - Decompress(xdiffposc(1, Z))) / 2) * xFactor)
'            Dummy = MoveToEx(Pict, XP, -15 + PicHeight - (-Log10(Chivals(1, Z)) / MChi) * (PicHeight - 35), PntAPI)
'
'
'            MCPrintData(1, Z) = Chivals(1, Z)
'            OX = 0
'            For X = 2 To LenXOverSeq - 1
'                MCPrintData(X, Z) = Chivals(X, Z)
'                XP = 30 + (Decompress(xdiffposc(X, Z)) + (Decompress(xdiffposc(X + 1, Z)) - Decompress(xdiffposc(X, Z))) / 2) * xFactor
'                YP = -15 + PicHeight - (-Log10(Chivals(X, Z)) / MChi) * (PicHeight - 35)
'                If XP <> OX Then
'                    MiY = 100000
'                    MaY = 0
'                End If
'                'If Chivals(X, Z) = 0 Then
'                '    X = X
'                'End If
'                If YP <= PicHeight - 15 And XP >= OX Then
'                    X = X
'
'                    If YP > MaY Or YP < MiY Then
'                        Dummy = LineTo(Pict, XP, YP)
'                        If YP > MaY Then MaY = YP
'                        If YP < MiY Then MiY = YP
'
'                    End If
'                    OX = XP
'                End If
'            Next '
'        Next 'Z



        Dim SP As Long, EP As Long
       
        
'        For Z = 0 To 2
'
'
'            If Z = 0 Then
'                Form1.Picture7.ForeColor = Green
'                SP = 10
'                EP = 13
'            ElseIf Z = 1 Then
'                Form1.Picture7.ForeColor = blue
'                SP = SP + 3
'                EP = EP + 3
'            Else
'                SP = SP + 3
'                EP = EP + 3
'                Form1.Picture7.ForeColor = red
'            End If
'            Pict = Form1.Picture7.hDC
'            For X = 1 To xLenXoverSeq(Z)
'                MoveToEx Pict, (30 + Decompress(XDiffPosC(X, Z)) * XFactor), SP, PntAPI
'                LineTo Pict, (30 + Decompress(XDiffPosC(X, Z)) * XFactor), EP
'            Next X
'        Next Z
    
        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
        
        Dim LOSpace As Integer, YPos As Integer, TotLen As Integer, L1 As Integer, L2 As Integer, L3 As Integer, DrawLen As Integer, XPos1 As Integer, XPos2 As Integer, XPos3 As Integer
        Dim OFontSize As Double
    
        OFontSize = Form1.Picture7.FontSize
        L1 = Form1.Picture7.TextWidth(OriginalName(Seq1))
        L2 = Form1.Picture7.TextWidth(OriginalName(Seq2))
        L3 = Form1.Picture7.TextWidth(OriginalName(Seq3))
        DrawLen = Form1.Picture7.ScaleWidth - 30
        TotLen = L1 + L2 + L3
    
        If DrawLen > TotLen Then
            LOSpace = (DrawLen - TotLen) / 2
            XPos1 = 25
            XPos2 = XPos1 + L1 + LOSpace
            XPos3 = XPos2 + L2 + LOSpace
        Else
    
            Do Until TotLen < DrawLen
                LastFontSize = Form1.Picture7.FontSize
                Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
                If Form1.Picture7.FontSize = LastFontSize Then Exit Do
                L1 = Form1.Picture7.TextWidth(OriginalName(Seq1))
                L2 = Form1.Picture7.TextWidth(OriginalName(Seq2))
                L3 = Form1.Picture7.TextWidth(OriginalName(Seq3))
                TotLen = L1 + L2 + L3
            Loop
    
            LOSpace = (DrawLen - TotLen) / 2
            XPos1 = 25
            XPos2 = XPos1 + L1 + LOSpace
            XPos3 = XPos2 + L2 + LOSpace
        End If
        If DontRedrawPlotsFlag = 0 Then
            WN1 = tSeq1: WN2 = tSeq2: WN3 = tSeq3
            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
            Call WriteNames2(WN1, WN2, WN3, Green, blue, red)
        End If
    
    
    
    'Get everything into the standard format for printing and saving
        LenXoverSeq = Longest
        NumLines = 6 'number of lines to print
        ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
    
        ReDim GVarPos(2, LenXoverSeq)
        For Y = 0 To 2
            For x = 1 To xLenXoverSeq(Y)
                GVarPos(Y, x) = XDiffPosC(x, Y)
            Next x
        Next Y
        ReDim GCritval(10)
        GCritval(0) = -Log10((LowestProb / MCCorrection))
        GCritval(1) = -Log10((LowestProb))
        GLegend = "-Log[Chi2 P-Val]"
        GPrintLen = LenXoverSeq + 1 'how many points to plot
        GPrintCol(0) = Green 'line is yellow
        GPrintCol(1) = blue 'line is green
        GPrintCol(2) = red ''line is purple
        GPrintCol(3) = Green 'line is yellow
        GPrintCol(4) = blue 'line is green
        GPrintCol(5) = red ''line is purple
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = MChi  'upper val
        
        For Y = 0 To 2
            For x = 1 To xLenXoverSeq(Y) - 1
            
                GPrint(Y, x) = -Log10(Chivals(x, Y))
                GPrint(Y + 3, x) = GPrint(Y, x)
                GPrintPos(Y, x) = (XDiffPosC(x, Y) + (XDiffPosC(x + 1, Y) - XDiffPosC(x, Y)) / 2)
                GPrintPos(Y + 3, x) = (XDiffPosC(x, Y) + (XDiffPosC(x + 1, Y) - XDiffPosC(x, Y)) / 2)
            
            Next x
            For x = xLenXoverSeq(Y) To UBound(GPrint, 2)
                GPrintPos(Y, x) = -100
                GPrintPos(Y + 3, x) = -100
            Next x
        Next Y
        'XX = GPrint(1, 0)
        For Y = 0 To 2
            GPrint(Y, xLenXoverSeq(Y)) = -Log10(Chivals(xLenXoverSeq(Y), Y))
            GPrint(Y + 3, xLenXoverSeq(Y)) = GPrint(Y, xLenXoverSeq(Y))
        Next Y
        Dim PLX As Long
        For x = 0 To NumLines - 1
            If x = x Then
                PLX = GPrintLen
            Else
                PLX = xLenXoverSeq(x)
            End If
            
            GPrintPos(x, PLX) = Len(StrainSeq(0))
            GPrint(x, PLX - 1) = GPrint(x, 1) '(GPrint(X, 1) + GPrint(X, PLX - 2)) / 2
            GPrint(x, PLX) = GPrint(x, 1) '(GPrint(X, 1) + GPrint(X, PLX - 1)) / 2
            
            For Y = 0 To 2
                GPrintPos(x, PLX - 1) = XDiffPosC(xLenXoverSeq(Y), Y) + (Len(StrainSeq(0)) - XDiffPosC(xLenXoverSeq(Y), Y)) / 2
            Next Y
            
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = GPrint(x, 1) '(GPrint(X, 1) + GPrint(X, PLX)) / 2
        Next x
        GExtraTNum = 2
        ReDim GExtraText(GExtraTNum)
        GExtraText(0) = OriginalName(tSeq1)
        GExtraText(1) = OriginalName(tSeq2)
        GExtraText(2) = OriginalName(tSeq3)
        
        
        
        
        Call RedrawPlotAA(1)
    End If
    Dim POrder() As Double

    ReDim POrder(3)

    ProbY = 1
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    
    
    If Confirm(EN, 4) > 0 Then
        If Abs(ConfirmP(EN, 4)) < 300 Then
            PT = 10 ^ (-ConfirmP(EN, 4))
        Else
            PT = 10 ^ 300
        End If
    Else
        PT = 1
    End If
    
    If x = x Or (XoverList(RelX, RelY).ProgramFlag <> 4 And XoverList(RelX, RelY).ProgramFlag <> 4 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA
        
        If (Confirm(EN, 4) = 0 Or (Confirm(EN, 4) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 4) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 4) = -Log10(MinPA2)
            End If
            
            
            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            'Form1.Refresh: Form1.WindowState = Form1.WindowState
        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

'    Else
'
'        If XoverList(RelX, RelY).BeginP < XoverList(RelX, RelY).EndP Then
'
'            If XoverList(RelX, RelY).SBPFlag <> 1 Then
'                POrder(0) = XoverList(RelX, RelY).BeginP
'                POrder(2) = XoverList(RelX, RelY).Beginning
'            Else
'                POrder(0) = 0
'            End If
'
'            If XoverList(RelX, RelY).SBPFlag <> 2 Then
'                POrder(1) = XoverList(RelX, RelY).EndP
'                POrder(3) = XoverList(RelX, RelY).Ending
'            Else
'                POrder(1) = 0
'            End If
'
'        Else
'
'            If XoverList(RelX, RelY).SBPFlag <> 1 Then
'                POrder(1) = XoverList(RelX, RelY).BeginP
'                POrder(3) = XoverList(RelX, RelY).Beginning
'            Else
'                POrder(1) = 0
'            End If
'
'            If XoverList(RelX, RelY).SBPFlag <> 2 Then
'                POrder(0) = XoverList(RelX, RelY).EndP
'                POrder(2) = XoverList(RelX, RelY).Ending
'            Else
'                POrder(0) = 0
'            End If
'
'        End If

    End If

    For A = 0 To 1
        ProbX = Decompress(POrder(A + 2))

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then
                If DontRedrawPlotsFlag = 0 Then
                    Call PrintProbability
                End If
                If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                    If POrder(0) < POrder(1) Then
                        XoverList(RelX, RelY).Probability = POrder(0)
                    Else
                        XoverList(RelX, RelY).Probability = POrder(1)
                    End If
                End If
            End If
            If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                BestParent = CheckParent: WinMethod = 4
                BestParentP = MinPA
            End If
            If MinPA2 < BestParentP And MinPA2 < LowestProb And MinPA2 > 0 Then
                BestParent = CheckParent: WinMethod = 4
                BestParentP = MinPA2
            End If
        End If

    Next 'A
    
    Erase Chivals
    
    
    CWinSize = oCWinSize
    CWinFract = oCWinfract
    
    MCWinSize = oMCWinSize
    MCWinFract = oMCWinfract
    
    Seq1 = tSeq1
    Seq2 = tSeq2
    Seq3 = tSeq3

    If MinPA < MinPA2 Then
        MinPAGlobal = MinPA
    Else
        MinPAGlobal = MinPA2
    End If
    
    
    
End Sub
Public Sub MCXoverG(SPF)
'MAXCHI scan used to check results of other methods via form1.combo1 next to the plot display.



Dim PT As Variant, XP1 As Long, XP2 As Long, BT As Long, YScaleFactor As Single, NumLines As Long, Y As Long, Dummy As Long, BE As Long, EN As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, Spos As Long, Epos As Long, step As Long, LSeq As Long, Last As Long, NumSites As Long, NumPairs As Long, NumTaxa As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double

NumSites = Len(StrainSeq(0))
step = MCSteplen
Last = NumSites

oSeq1 = Seq1
oSeq2 = Seq2
oSeq3 = Seq3
   
'Seq1 = 19
'Seq2 = 16


ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)

NumTaxa = NextNo + 1
'7.14 of 32
    
LenXoverSeq = 0

'If MCStripGapsFlag = 0 Then
'    LenXoverSeq = FindSubSeqB(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'Else

'This could be speeded up with better nesting
LenXoverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'End If
If LenXoverSeq < 2 Then Exit Sub
oMCWinSize = MCWinSize
oMCWinfract = MCWinFract
If XoverList(RelX, RelY).ProgramFlag = 3 And ExeCheckFlag = 0 Then
    MCWinSize = XoverList(RelX, RelY).LHolder
    If MCWinSize < 3 Then
        
    
        If oMCWinSize < 3 Then oMCWinSize = 60
        MCWinSize = oMCWinSize
        
    End If
    WindowWidth = MCWinSize
    HWindowWidth = CLng(WindowWidth / 2)
Else
    If (OptFlag <> 4) Then
            BE = XoverList(RelX, RelY).Beginning
            EN = XoverList(RelX, RelY).Ending
            XPosDiff(Len(StrainSeq(0))) = LenXoverSeq
            If BE < EN Then
                MCWinSize = XPosDiff(EN) - XPosDiff(BE) + 1
            Else
                MCWinSize = XPosDiff(EN) + (LenXoverSeq - XPosDiff(BE)) + 1
            End If
            'MCWinSize = 27
            MCWinSize = MCWinSize * 2
            MCWinFract = MCWinSize / LenXoverSeq
    End If
End If
'there may be a problem with mcwinsize - ie it may be either 1 to0 low or too high - it is probably a rounding problem
If MCProportionFlag = 0 Then
    WindowWidth = MCWinSize
    HWindowWidth = CLng(WindowWidth / 2)
    x = x
Else
    If Int(MCWinFract * LenXoverSeq) > 20 And Int(MCWinFract * LenXoverSeq) < (LenXoverSeq / 1.5) Then
        WindowWidth = (Int((MCWinFract * LenXoverSeq) / 2) * 2 - 2)
    ElseIf Int(MCWinFract * LenXoverSeq) <= 20 Then

        If LenXoverSeq > 15 Then
            WindowWidth = 20
        Else
            MCWinSize = oMCWinSize
            Exit Sub
        End If

    ElseIf Int(MCWinFract * LenXoverSeq) >= (LenXoverSeq / 1.5) Then

        If LenXoverSeq / 1.5 > 10 Then
            WindowWidth = (Int((LenXoverSeq / 1.5) / 2) * 2 - 2)
        Else
            MCWinSize = oMCWinSize
            Exit Sub
        End If

    End If
    HWindowWidth = CLng(WindowWidth / 2)
   
    Call GetCriticalDiff(0)
    If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
        MCWinSize = HWindowWidth * 2
    End If
End If


If HWindowWidth > LenXoverSeq / 2 Then
    HWindowWidth = LenXoverSeq - HWindowWidth + 1
    If HWindowWidth < 3 Then
        HWindowWidth = LenXoverSeq / 2
    End If
End If


If HWindowWidth < 4 Then MCWinSize = oMCWinSize: Exit Sub

Spos = -HWindowWidth
Epos = LenXoverSeq + HWindowWidth

'9 OF 32
'HWindowWidth = 7

    
ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)


'5,490,1652,9594,19,16,8,0,0,0,0
'scores(9594,2),xdiffpos(9794),seqnum(9594,24),winscores(10574,2)
'XX = UBound(XDiffPos, 1)

'Open "test2.csv" For Output As #1
'For X = 0 To Len(StrainSeq(0))
'Print #1, SeqNum(X, 16)
'Next X
'Close #1

Dummy = WinScoreCalc(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffPos(0), SeqNum(0, 0), Winscores(0, 0))

Erase Scores



'If Dummy = 0 Then Exit Sub
'XDiffPos(462) = XDiffPos(462)
'9 of 32
'This could be speeded up with better nesting
ReDim Chivals(Len(StrainSeq(0)), 2)
MChi = CalcChiVals(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0))


Erase Winscores

If MCFlag = 0 Then
    lPrb = (LowestProb / MCCorrection)
Else
    lPrb = LowestProb
End If

'If ChiPVal(mChi) > lPrb Then Exit Sub
MChi = ChiPVal(MChi) * (LenXoverSeq / (HWindowWidth)) * 3


MChi = -Log10(MChi)


MCMinChiP = MChi
    

'If MCFlag = 0 Then
    If MCMinChiP < -Log10((LowestProb / MCCorrection)) Then MCMinChiP = -Log10(LowestProb / MCCorrection)
'Else
'    If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
'End If

MChi = MCMinChiP

For x = 0 To 2
    For Y = 0 To LenXoverSeq
        If CLng(pMCWinSize / 2) > HWindowWidth Then
            Chivals(Y, x) = ChiPVal(Chivals(Y, x)) * (LenXoverSeq / (HWindowWidth)) * 3
        Else
            Chivals(Y, x) = ChiPVal(Chivals(Y, x)) * (LenXoverSeq / (CLng(pMCWinSize / 2))) * 3
        End If
        If Chivals(Y, x) > 1 Then Chivals(Y, x) = 1
    Next Y
Next x
If XDiffPos(0) = 0 Then XDiffPos(0) = XDiffPos(1)
Chivals(LenXoverSeq, 0) = Chivals(0, 0)
Chivals(LenXoverSeq, 1) = Chivals(0, 1)
Chivals(LenXoverSeq, 2) = Chivals(0, 2)

    Dim TB As Long, TE As Long

    If XoverList(RelX, RelY).Beginning - 20 < 0 Then
        TB = XoverList(RelX, RelY).Beginning - 20 + Len(StrainSeq(0))
    Else
        TB = XoverList(RelX, RelY).Beginning - 20
    End If

    If XoverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XoverList(RelX, RelY).Ending + 20 - Len(StrainSeq(0))
    Else
        TE = XoverList(RelX, RelY).Ending + 20
    End If

    Dim Z As Long, MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    If XPosDiff(TB) = 0 Then
        If TB < Len(StrainSeq(0)) / 2 Then
            BT = 1
        Else
            BT = LenXoverSeq
        End If
    Else
        BT = XPosDiff(TB) - 1
    End If
    If XPosDiff(TE) >= LenXoverSeq Then
        ET = 1
    Else
        ET = XPosDiff(TE) + 1
    End If
    Dim DE As Long, DB As Long
    If ET > BT Then
        
        For x = BT To ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then
                If Abs(TB - (XDiffPos(x))) < Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TB) Then
                    DB = Abs(TB - (XDiffPos(x)))
                Else
                    DB = Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TB)
                End If
                
                If Abs(TE - (XDiffPos(x))) < Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TE) Then
                    DE = Abs(TE - (XDiffPos(x)))
                Else
                    DE = Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TE)
                End If
                For Z = 0 To 2
                    
                    
                    
                    If Chivals(x, Z) < MinPA2 And DE < DB Then
                        MinPA2 = Chivals(x, Z)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x, Z) < MinPA And DE > DB Then
                        MinPA = Chivals(x, Z)
                        XP1 = XDiffPos(x)
                    End If

                Next 'Z

            'End If

        Next 'X

    Else

        For x = BT To LenXoverSeq 'ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then
                'XX = XX
                If Abs(TB - (XDiffPos(x))) < Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TB) Then
                    DB = Abs(TB - (XDiffPos(x)))
                Else
                    DB = Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TB)
                End If
                
                If Abs(TE - (XDiffPos(x))) < Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TE) Then
                    DE = Abs(TE - (XDiffPos(x)))
                Else
                    DE = Abs((Len(StrainSeq(0)) - XDiffPos(x)) + TE)
                End If
                
                For Z = 0 To 2
                    
                    If Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA2 And DE < DB Then
                        MinPA2 = Chivals(x, Z)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA And DE > DB Then
                        MinPA = Chivals(x, Z)
                        XP1 = XDiffPos(x)
                    End If

                Next 'Z

            'End If

        Next 'X
        For x = 1 To ET
            'If XDiffPos(X) >= TB And XDiffPos(X) < TE Then
                If Abs(TB - (XDiffPos(x))) < Abs((Len(StrainSeq(0)) - TB) + XDiffPos(x)) Then
                    DB = Abs(TB - (XDiffPos(x)))
                Else
                    DB = Abs((Len(StrainSeq(0)) - TB) + XDiffPos(x))
                End If
                
                If Abs(TE - (XDiffPos(x))) < Abs((Len(StrainSeq(0)) - TE) + XDiffPos(x)) Then
                    DE = Abs(TE - (XDiffPos(x)))
                Else
                    DE = Abs((Len(StrainSeq(0)) - TE) + XDiffPos(x))
                End If
                For Z = 0 To 2

                    If Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA2 And DE < DB Then
                        MinPA2 = Chivals(x, Z)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x, Z) > 0 And Chivals(x, Z) < MinPA And DE > DB Then
                        MinPA = Chivals(x, Z)
                        XP1 = XDiffPos(x)
                    End If

                Next 'Z

            'End If

        Next 'X

    End If
    If MCFlag = 0 Then
        MinPA = MinPA * MCCorrection
        MinPA2 = MinPA2 * MCCorrection
    ElseIf MCFlag = 2 Then
        MinPA = StepDown2(3, MinPA)
        MinPA2 = StepDown2(3, MinPA2)
    End If
    If MinPA < LowestProb Or MinPA2 < LowestProb Then
        If BestRescanFlag = 1 And MinPA > 0 Then
            If BestRescanP > MinPA Then
                BestRescanP = MinPA
            End If
            If BestRescanP > MinPA2 And MinPA2 > 0 Then
                BestRescanP = MinPA2
            End If
        End If
    End If
    If (SPF = 0 And BestRescanFlag = 0 And UpdateIDFlag = 0) Or (BestRescanFlag = 1 And (BestRescanP = MinPA Or BestRescanP = MinPA2)) Then
        ReDim GPVTFont(5, 100), GPVText(100)
         GPVTNum = -1
        Form1.Frame17.Visible = False
        Form1.Picture7.ScaleMode = 3
        Form1.Picture7.AutoRedraw = True
        Dim PntAPI As POINTAPI
        Dim Pict As Long
        'Form1.Picture7 = LoadPicture()
        'ReDim MCPrintPos(LenXoverSeq)
        'ReDim MCPrintData(2, LenXoverSeq)
        Erase MCPrintData
        Erase MCPrintPos
        
        'Get everything into the standard format for printing and saving
        NumLines = 6 'number of lines to print
        ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
    
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = XDiffPos(x)
        Next x
        ReDim GCritval(10)
        GCritval(0) = -Log10((LowestProb / MCCorrection))
        GCritval(1) = -Log10((LowestProb))
        GLegend = "-Log[Chi2 P-Val]"
        GPrintLen = LenXoverSeq + 1 'how many points to plot
        GPrintCol(0) = Yellow 'line is yellow
        GPrintCol(1) = Green 'line is green
        GPrintCol(2) = Purple ''line is purple
        GPrintCol(3) = Yellow 'line is yellow
        GPrintCol(4) = Green 'line is green
        GPrintCol(5) = Purple ''line is purple
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        Dim Div As Double
        Div = (Int(XOverWindowX / 2) * 2 + 1)
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = MChi  'upper val
        
        For x = 1 To LenXoverSeq - 1
            For Y = 0 To 2
                GPrint(Y, x) = -Log10(Chivals(x, Y))
                GPrint(Y + 3, x) = GPrint(Y, x)
                GPrintPos(Y, x) = (XDiffPos(x) + (XDiffPos(x + 1) - XDiffPos(x)) / 2)
                GPrintPos(Y + 3, x) = (XDiffPos(x) + (XDiffPos(x + 1) - XDiffPos(x)) / 2)
            Next Y
        Next x
        
        For Y = 0 To 2
            GPrint(Y, LenXoverSeq) = -Log10(Chivals(LenXoverSeq, Y))
            GPrint(Y + 3, LenXoverSeq) = GPrint(Y, LenXoverSeq)
        Next Y
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            
            GPrintPos(x, GPrintLen - 1) = XDiffPos(LenXoverSeq) + (Len(StrainSeq(0)) - XDiffPos(LenXoverSeq)) / 2
            
            
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
    
    
        
        
       ' For X = 0 To LenXoverSeq
       '     MCPrintPos(X) = XDiffpos(X)
        'Next X

        YScaleFactor = 0.85
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MChi, 0, 1, "-Log[P(Chi2)]")
        
        PicHeight = (Form1.Picture7.Height * YScaleFactor)
        'Form1.Picture7.DrawWidth = 3
        Call Highlight(0)
        'XX = MissingData(7230, Seq1)
        'SS = Abs(GetTickCount)
        
        Dim OX As Long, MiY As Long, MaY As Long, YP As Long, XP As Long
        
        If DontRedrawPlotsFlag = 0 Then
            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
        End If
        
        Call RedrawPlotAA(1)
        
        
    End If
    
    Erase Chivals
    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)

    
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    If Confirm(EN, 3) > 0 Then
        If Abs(ConfirmP(EN, 3)) < 300 Then
            PT = 10 ^ (-ConfirmP(EN, 3))
        Else
            PT = 10 ^ 300
        End If
    Else
        PT = 1
    End If
    
    
    If x = x Or (XoverList(RelX, RelY).ProgramFlag <> 3 And XoverList(RelX, RelY).ProgramFlag <> 3 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA

        If (Confirm(EN, 3) = 0 Or (Confirm(EN, 3) = 1 And (MinPA2 < PT Or MinPA < PT))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 3) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA2)
            End If
            

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            Form1.Refresh
            If DebuggingFlag < 2 Then
                Form1.WindowState = Form1.WindowState
            End If
        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

    Else

        If MinPA < MinPA2 Then

            If XoverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(0) = XoverList(RelX, RelY).Probability
                POrder(2) = XoverList(RelX, RelY).Beginning
            Else
                POrder(0) = 0
            End If

            If XoverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(1) = MinPA2
                POrder(3) = XoverList(RelX, RelY).Ending
            Else
                POrder(1) = 0
            End If

        Else

            If XoverList(RelX, RelY).SBPFlag <> 1 Then
                POrder(1) = MinPA
                POrder(3) = XoverList(RelX, RelY).Beginning
            Else
                POrder(1) = 0
            End If

            If XoverList(RelX, RelY).SBPFlag <> 2 Then
                POrder(0) = XoverList(RelX, RelY).Probability
                POrder(2) = XoverList(RelX, RelY).Ending
            Else
                POrder(0) = 0
            End If

        End If

    End If

    For A = 0 To 1
        ProbX = POrder(A + 2)
        

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then
                If (DontRedrawPlotsFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And (BestRescanP = MinPA Or BestRescanP = MinPA2)) Then

                    Call PrintProbability
                End If
                If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                    If POrder(0) < POrder(1) Then
                        XoverList(RelX, RelY).Probability = POrder(0)
                    Else
                        XoverList(RelX, RelY).Probability = POrder(1)
                    End If
                End If
            End If
            If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                BestParent = CheckParent: WinMethod = 3
                BestParentP = MinPA
            End If
            If MinPA2 < BestParentP And MinPA2 < LowestProb And MinPA2 > 0 Then
                BestParent = CheckParent: WinMethod = 3
                BestParentP = MinPA2
            End If
        End If

    Next 'A
    If MinPA2 < MinPA Then
        MinPAGlobal = MinPA
    Else
        MinPAGlobal = MinPA2
    End If
    MCWinSize = oMCWinSize
    MCWinFract = oMCWinfract
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
End Sub
Public Sub CXoverA(FindallFlag As Byte, BEP, ENP)

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If


Dim HWindowWidth As Long, YScaleFactor As Single, mPrbL As Variant, oActive As Long, oMajP As Long, oMinP As Long, ZZ As Long, ENX As Long, BEX As Long, DoneRedo As Long, SIP As Long, EWarn As Long, BWarn As Long, NumInList As Long, EPV As Double, BPV As Double, XBP As Long, XEP As Long, PPVal As Double, xMPV As Double, oxChi As Double, MPV As Double, HighHomol As Long, Dummy As Long, UB As Long, CurWinPos As Long, CurWin As Double, thMChi As Double, XB As Long, XE As Long, BE As Long, EN As Long, LOT(1) As Double, GoOn As Byte, WasteOfTime As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, step As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim DoneThis As Byte
Dim MaxX As Long, TWinScoresA As Long, TWinScoresB As Long, WinWin As Long
Dim Failcount As Long
Dim HMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long, ZP As Double, PntAPI As POINTAPI, Pict As Long
Dim MaxFailCount As Long, maxz As Long, PBinFlag As Long

PBinFlag = -1

UB = 0
If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
UB = UBound(ChiValsX, 1)
On Error GoTo 0
HWindowWidth = CLng(CWinSize / 2)

If UB = 0 Then
    ReDim ScoresX(Len(StrainSeq(0)))
    ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2)
    'XX = UBound(WinScoresX, 1)
    ReDim ChiValsX(Len(StrainSeq(0)))
    ReDim SmoothChiX(Len(StrainSeq(0)))
End If

'Erase Scores
'Erase Winscores
'Erase Chivals
'Erase SmoothChi
'Erase ScoresX
'Erase WinScoresX
'Erase ChiValsX
'Erase SmoothChiX
'7.14 of 32
'If SEventNumber = 9 Then
'    X = X
'End If

LenXoverSeq = 0

'@

'If UBound(CompressSeq, 2) = NextNo And SEventNumber = 0 Then
'    LenXoverSeq = FindSubSeqMCPB(UBound(FSSMC, 2), UBound(CompressSeq, 1), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), XDiffPos(0), XPosDiff(0), FSSMC(0, 0, 0, 0))
' Else
'    LenXoverSeq = FindSubSeqCP(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
' End If
LenXoverSeq = FindSubSeqDP(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))

If LenXoverSeq < CriticalDiff * 2 Then Exit Sub

If LenXoverSeq < 7 Then
    Exit Sub
End If

Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXoverSeq, CWinFract, CWinSize, HWindowWidth, lHWindowWidth, GoOn, FindallFlag, CProportionFlag, XPosDiff())


If GoOn = 0 Then Exit Sub

If HWindowWidth <> lHWindowWidth Then
    ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2)
    lHWindowWidth = HWindowWidth
End If

'9 of 32

Dummy = WinScoreCalc4(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, ScoresX(0), XDiffPos(0), SeqNum(0, 0), WinScoresX(0))

If Dummy = 0 And ShortOutFlag <> 3 Then Exit Sub

If FindallFlag = 0 And ((LongWindedFlag = 1 And SEventNumber > 0) Or CircularFlag = 0) Then
    If SEventNumber > 0 Then
        If SEventNumber = 1 Then
            ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
        End If
        
        Dummy = MakeBanWinP(UBound(BanWin, 1), Seq1, Seq2, Seq3, HWindowWidth, Len(StrainSeq(0)), LenXoverSeq, BanWin(0), MDMap(0), MissingData(0, 0), XPosDiff(0), XDiffPos(0))
    Else
        'ReDim MDMap(LenXoverSeq + 1), BanWin(LenXoverSeq + HWindowWidth * 2 + 1)
        ReDim MDMap(Len(StrainSeq(0)) + 1), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2 + 1)
    End If
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXoverSeq) = 1
        For x = (LenXoverSeq - HWindowWidth + 2) To LenXoverSeq
            BanWin(x) = 1
        Next x
    End If

    '10.605
    '10.465 using offsets
    MChi = CalcChiVals5(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), WinScoresX(0), ChiValsX(0), BanWin(0))
Else
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
    MChi = CalcChiVals3(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), WinScoresX(0), ChiValsX(0))
End If



'hw=25:25
'lx=252:55
'30.952
'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
If MCProportionFlag = 0 Then
        If (ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Then
            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
            
            Exit Sub
        End If
    Else
        If ((ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then
            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
            Exit Sub
        End If
    End If


If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXoverSeq, HWindowWidth, mtP(), 4)
End If

'Smooth to find peaks (uses a window of positions)
SmoothChiVals3P LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0), SmoothChiX(0)


If LongWindedFlag = 0 Then
    If TreeDistance(Seq1, Seq2) > TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) > TreeDistance(Seq2, Seq3) Then
        HighHomol = 1
        If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
        Else
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
        End If
    ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 2
        If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
        Else
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
        End If
    ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
        HighHomol = 3
        If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
        Else
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
        End If
    End If
End If




MChi = 0
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events
Dim lmPrb As Double
lmPrb = 0
Do
    
    FindMChi3 Len(StrainSeq(0)), LenXoverSeq, MaxX, MaxY, MChi, ChiValsX(0)
    If MChi <= 0 Then
        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
        Exit Sub
    End If
    mPrb = ChiPVal2(MChi)
    If mPrb * (LenXoverSeq / HWindowWidth) * 3 > LowestProb Then
        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
        Exit Sub
    End If
    If mPrb = lmPrb Then
        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
        Exit Sub
    End If
    
    lmPrb = mPrb
    If MCProportionFlag = 0 Then
        If (mPrb * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then
            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
            Exit Sub
        End If
    Else
        If ((mPrb * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then
            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
            Exit Sub
        End If
    End If
    
    If mPrb < LowestProb And mPrb <> 1 Then
        maxz = MaxX
        If MaxX = 0 Then MaxX = 1
        Call MakeTWin(FindallFlag, HWindowWidth, TWin, LenXoverSeq)
        
        MaxFailCount = HWindowWidth * 2
        If MaxFailCount > Int((LenXoverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXoverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        
        Dummy = GetAC(LenXoverSeq, Len(StrainSeq(0)), 0, MaxX, TWin, A, C, ScoresX(0))
        
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXoverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXoverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXoverSeq
            Else
                MaxX = LenXoverSeq - 1
            End If
        End If
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXoverSeq / HWindowWidth)
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXoverSeq + LO
        
        RO = (MaxX + TWin)
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO >= LenXoverSeq Then
            If MDMap(LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                TWin = TWin - 1
                RO = LenXoverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXoverSeq + LO
            End If
        End If
        
                'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        oxChi = MChi
        If FindallFlag = 0 Then
'            XX = Seq1
'            If Seq1 = 0 And Seq2 = 6 And Seq3 = 7 Then
'                X = X
'            End If
            If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                
                Dummy = GrowMChiWin2P(LO, RO, LenXoverSeq, HWindowWidth, TWin, 0, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, ScoresX(0), MDMap(0))
                x = x
            Else
                Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, 0, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, ScoresX(0))
            End If
        Else
            Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, 0, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, ScoresX(0))
        End If
        
        
        If MChi < 0 Then
            MChi = oxChi
        End If
        On Error GoTo 0
       
        
         If WinWin < HWindowWidth Then
            MPV = ChiPVal2P(MChi) * ((LenXoverSeq) / (WinWin))
         Else
                        
                   
            If MChi < 20000 Then
                MPV = ChiPVal2P(MChi) * ((LenXoverSeq) / (HWindowWidth))
            Else
                MPV = 10 ^ -200
            End If
                  
        End If
        '1.063-11  79/33 6543 3
        xMPV = MPV 'MCCorrection * 3
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        If ShortOutFlag = 3 Then
            If MPV <= mtP(4) Then
                mtP(4) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        RO = MaxX + WinWin - 1
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO > LenXoverSeq Then
            If MDMap(RO - LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                RO = LenXoverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXoverSeq
        End If
        
        If MPV < LowestProb Then
            
            PPVal = -1
           
            
            If x = x Then
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) - 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) - 1
                    End If
                End If
                
                ProbabilityXOver = 0
                
                'So.....Which side of the window is the recombinant region?
                'Calculate windows on the other side of the region bounds
                'and find the the highest chi value.
                
                If (LO - WinWin + LenXoverSeq) < 0 Then
                     LO = (-LenXoverSeq + WinWin)
                End If
                
                Dummy = FindSide(TopL, TopR, Len(StrainSeq(0)), LO, RO, WinWin, LenXoverSeq, 0, ScoresX(0), HiLeft, HiRight)
                If HiRight = 0 And HiLeft = 0 Then
                    Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                    Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                    Exit Sub
                End If
                If HiLeft >= HiRight Then
                    'Find "best" matching breakpoint position.
                    CurWinPos = OptLeftBPMC(LO, HiLeft, TopL, MaxX, 0, WinWin, LenXoverSeq, Len(StrainSeq(0)), ScoresX(0), MDMap(0))
                        
                    LO = CurWinPos
                    
                    If LO > LenXoverSeq Then LO = 1
                    If FindallFlag = 1 Then
                        XB = XDiffPos(MaxX)
                        XE = XDiffPos(RO)
'                        If MCFlag = 0 Then
'                            XEP = ChiPVal(ChiValsX(RO))
'                            XEP = XEP * MCCorrection
'                            XEP = XEP * 3
'                            XXX = XEP
'                            XXX = XXX * LenXoverSeq
'                            XXX = XXX / HWindowWidth
'                            If XXX > 10000 Then
'                                XEP = 10000
'                            Else
'                                XEP = XXX
'                            End If
'                            XBP = mPrb
'                            XBP = XBP * MCCorrection
'                            XBP = XBP * 3
'                            XBP = XBP * LenXoverSeq
'                            XBP = XBP / HWindowWidth
'                        Else
'                            XEP = ChiPVal(ChiValsX(RO)) * 3 * LenXoverSeq / HWindowWidth
'                            XBP = mPrb * 3 * LenXoverSeq / HWindowWidth
'
'                        End If
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1
                        MCMaxY = 1
                    Else
                        LoHiFlag = 1
                        MCMaxY = 0
                    End If
                    
                    If LO < 1 Then
                        LO = LO + LenXoverSeq
                    End If
                    
                    If MaxX < 1 Then
                        RO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        RO = MaxX - LenXoverSeq
                    ElseIf MaxX = 1 Then
                        If MDMap(1) = 0 And BanWin(1) = 0 Then
                            RO = MaxX
                        Else
                            RO = LenXoverSeq
                        End If
                    Else
                        RO = MaxX
                    End If
                    
                    If RO > 0 Then
                        RO = RO - 1
                    End If
                    Do While MDMap(RO) <> 0
                        RO = RO - 1
                        If RO < 1 Then RO = LenXoverSeq
                    Loop
                    RO = RO + 1
                    If RO > LenXoverSeq Then RO = LenXoverSeq
                    
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO)
                    Else
                        BE = XDiffPos(LO + 1)
                    End If
                    EN = XDiffPos(RO)
                    If MCFlag = 0 Then
                        tempvar = MCCorrection
                        tempvar = tempvar * 2
                        tempvar = tempvar * LenXoverSeq
                        tempvar = tempvar / HWindowWidth
                        tempvar2 = tempvar * ChiPVal(ChiValsX(LO))
                        tempvar3 = tempvar * mPrb
                        BPV = CDbl(tempvar2) 'ChiPVal(ChiValsX(LO)) * MCCorrection * 3 * LenXoverSeq / HWindowWidth
                        EPV = CDbl(tempvar3) 'mPrb * MCCorrection * 3 * LenXoverSeq / HWindowWidth
                    Else
                        BPV = ChiPVal(ChiValsX(LO)) * 3 * LenXoverSeq / HWindowWidth
                        EPV = mPrb * 3 * LenXoverSeq / HWindowWidth
                    End If
                Else
                    'Find "best" matching breakpoint position.
                    CurWinPos = OptRightBPMC(RO, HiRight, TopR, MaxX, 0, WinWin, LenXoverSeq, Len(StrainSeq(0)), ScoresX(0), MDMap(0))
                        
                    RO = CurWinPos
                                        
                   
                    
                    If RO < 1 Then RO = LenXoverSeq
                    'MaxX = MaxX
                    If FindallFlag = 1 Then
                        XB = XDiffPos(LO)
                        XE = XDiffPos(MaxX)
'                        If MCFlag = 0 Then
'                            XBP = ChiPVal(ChiValsX(LO)) * MCCorrection * 3 * LenXoverSeq / HWindowWidth
'                            XEP = mPrb * MCCorrection * 3 * LenXoverSeq / HWindowWidth
'                        Else
'                            XBP = ChiPVal(ChiValsX(LO)) * 3 * LenXoverSeq / HWindowWidth
'                            XEP = mPrb * 3 * LenXoverSeq / HWindowWidth
'                        End If
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1
                        MCMaxY = 0
                    Else
                        LoHiFlag = 1
                        MCMaxY = 1
                    End If
                    If RO >= LenXoverSeq * 2 Then
                        RO = RO - LenXoverSeq * 2
                    End If
                    If RO > LenXoverSeq Then
                        RO = RO - LenXoverSeq
                    End If
                    
                    If MaxX < 0 Then
                        LO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        LO = MaxX - LenXoverSeq
                    Else
                        LO = MaxX
                    End If
                    
                    If LO < LenXoverSeq Then
                        LO = LO + 1
                    End If
                    Do While MDMap(LO) <> 0
                        LO = LO + 1
                        If LO > LenXoverSeq Then LO = 1
                    Loop
                    LO = LO - 1
                    If LO < 1 Then LO = 1
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO)
                    Else
                        BE = XDiffPos(LO + 1)
                    End If
                    EN = XDiffPos(RO)
                    
                    
                    If MCFlag = 0 Then
                        BPV = mPrb * MCCorrection * 3 * LenXoverSeq / HWindowWidth
                        EPV = ChiPVal(ChiValsX(RO)) * MCCorrection * 3 * LenXoverSeq / HWindowWidth
                    Else
                        BPV = mPrb * 3 * LenXoverSeq / HWindowWidth
                        EPV = ChiPVal(ChiValsX(RO)) * 3 * LenXoverSeq / HWindowWidth
                    End If
                End If
                
                MaxX = pMaxX
               
                'Destroy the completed peaks
                If LO < RO Then
                    If MaxX >= LO And MaxX <= RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                Else
                    If MaxX > LO Or MaxX < RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                End If
                Dummy = DestroyPeaks(0, LenXoverSeq, Len(StrainSeq(0)), LO, RO, SmoothChiX(0), ChiValsX(0))
                ChiValsX(maxz) = 0
                
                ProbabilityXOver = MPV
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                    End If
                End If
                If MPV < LowestProb Then  'it is necessary to destroy the region if it is not accepted
                    
                    
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If NumInList <= TripListLen Then
                                
                                    
                                    If ProgBinRead(4, Worthwhilescan(NumInList)) = 0 Then
                                    
                                        Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 16
                                    End If
                                End If
                                
                            End If
                        End If
                    End If
                    
                    GoOn = 1
                     EWarn = 0: BWarn = 0
'                     If SEventNumber = 8 And Seq1 = 12 Then
'    X = X
'
'End If
                     
                     
                    'thats why this cut must be remade here
                    'store the event
                    If LongWindedFlag = 1 Then
                        If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                           
                        ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                            
                        ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                           
                            
                        ElseIf StoreLPV(4, Seq1) >= StoreLPV(4, Seq2) And StoreLPV(4, Seq1) >= StoreLPV(4, Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(4, Seq2) >= StoreLPV(4, Seq1) And StoreLPV(4, Seq2) >= StoreLPV(4, Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(4, Seq3) >= StoreLPV(4, Seq1) And StoreLPV(4, Seq3) >= StoreLPV(4, Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                    End If
                    
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(4) = oRecombNo(4) + 1
                    
                    If APermFlag = 0 Then
                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 4, ProbabilityXOver, SIP)
                    Else
                        SIP = 1
                    End If
                    ActualFound = 1
                    NewOneFound = 1
                    If SIP < 0 Then
                        If DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(4, Seq1, Seq2, Seq3)
                        End If
                    Else
                        
                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                        XoverList(ActiveSeq, SIP).SBPFlag = 0
                        XoverList(ActiveSeq, SIP).ProgramFlag = 4
                        
                        Call CentreBP(0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, CWinSize / 2, LenXoverSeq)
                        
                        XoverList(ActiveSeq, SIP).Beginning = BE
                        XoverList(ActiveSeq, SIP).Ending = EN
                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                        If PPVal >= 0 Then
                            XoverList(ActiveSeq, SIP).PermPVal = PPVal
                        End If
                        XoverList(ActiveSeq, SIP).BeginP = 0 'BPV
                        XoverList(ActiveSeq, SIP).EndP = 0 'EPV
                        XoverList(ActiveSeq, SIP).DHolder = Seq1
                        
                        
                        'Store the window size used to detect this event
                        XoverList(ActiveSeq, SIP).LHolder = WinWin * 2
                        If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                            If XPosDiff(EN) > LenXoverSeq Then XPosDiff(EN) = LenXoverSeq
                            If XPosDiff(EN) = LenXoverSeq Then
                                ENX = 1
                            Else
                                ENX = XPosDiff(EN) + 1
                            End If
                            If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                                BEX = LenXoverSeq
                            Else
                                BEX = XPosDiff(BE) - 1
                            End If
                            
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB(0, 0, CWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB(0, 0, CWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                            End If
                            If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 3
                            ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1 Or (EWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 2
                            ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1 Or (BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 1
                            End If
                        End If
                        
                        GoOn = 1
                        XB = BE
                        XE = EN
                        If FindallFlag = 1 And SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                            
                            
                            If x = x Then
                            
                                GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                            Else
                                If XB < XE Then
                                    For ZZ = XB To XE
                                        If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next ZZ
                                Else
                                    For ZZ = 1 To XE
                                        If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next ZZ
                                    For ZZ = XB To Len(StrainSeq(0))
                                        If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                            GoOn = 0
                                        End If
                                    Next ZZ
                                End If
                            End If
                        End If
                        If GoOn = 0 And FindallFlag = 1 Then 'erase it if it contained missingdata but only if findall=1
                            CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) - 1
                        Else
                            oActive = ActiveSeq
                            oMajP = ActiveMajorP
                            oMinP = ActiveMinorP
                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 4, SIP)
                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, CWinSize / 2, LenXoverSeq)
                        End If
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(4) = 1
                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                        End If
                        GoOn = 1
                        XB = XoverList(ActiveSeq, SIP).Ending
                        XE = XoverList(ActiveSeq, SIP).Beginning
                        
                        If FindallFlag > 1 And SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                            
                            If x = x Then
                            
                                GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                            Else
                                If XB < XE Then
                                    For ZZ = XB To XE
                                        If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                            GoOn = 0: Exit For
                                        End If
                                    Next ZZ
                                Else
                                    For ZZ = 1 To XE
                                        If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                            GoOn = 0: Exit For
                                        End If
                                    Next ZZ
                                    For ZZ = XB To Len(StrainSeq(0))
                                        If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                            GoOn = 0: Exit For
                                        End If
                                    Next ZZ
                                End If
                            End If
                           
                            If GoOn = 1 Then
                            
                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 4, ProbabilityXOver, SIP)
                                If SIP < 1 Then
                                    SIP = 0 'this "throws" the result away
                                Else
                                    XoverList(ActiveSeq, SIP) = XoverList(ActiveSeq, SIP - 1)
                                    XoverList(ActiveSeq, SIP).SBPFlag = 0
                                    'Call CentreBP(0,0,seq1,seq2,seq3,BE, EN, XPosdiff(), XDiffpos(), BWarn, EWarn, CWinSize / 2, LenXOverSeq)
                                    XoverList(ActiveSeq, SIP).Beginning = XB
                                    
                                    XoverList(ActiveSeq, SIP).Ending = XE
                                    XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                    If PPVal >= 0 Then
                                        XoverList(ActiveSeq, SIP).PermPVal = PPVal
                                    End If
                                    XoverList(ActiveSeq, SIP).BeginP = 0 'XBP
                                    XoverList(ActiveSeq, SIP).EndP = 0 'XEP
                                    XoverList(ActiveSeq, SIP).DHolder = Abs(XoverList(ActiveSeq, SIP).DHolder) 'Seq1
                                    
                                    'Store the window size used to detect this event
                                    If LongWindedFlag = 1 And (SEventNumber > 1 Or CircularFlag = 0) Then
                                        If XPosDiff(EN) = LenXoverSeq Then
                                            ENX = 1
                                        Else
                                            ENX = XPosDiff(EN) + 1
                                        End If
                                        If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                                            BEX = LenXoverSeq
                                        Else
                                            BEX = XPosDiff(BE) - 1
                                        End If
                                        If SEventNumber > 0 Then
                                            If EWarn = 0 Then Call CheckEndsVB(0, 0, CWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB(0, 0, CWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                        End If
                                        If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 3
                                        ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1 Or (EWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                        ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1 Or (BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                        End If
                                        If FindallFlag = 0 Then
                                            If LoHiFlag = 0 Then
                                                LoHiFlag = 1
                                            Else
                                                LoHiFlag = 0
                                            End If
                                            If MCMaxX = 0 Then
                                                MCMaxX = 1
                                            Else
                                                MCMaxX = 0
                                            End If
                                            oActive = ActiveSeq
                                            oMajP = ActiveMajorP
                                            oMinP = ActiveMinorP
                                                
                                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 4, SIP)
                                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, CWinSize / 2, LenXoverSeq)
                                            x = x
                                        Else
                                            SIP = SIP + 1
                                            
                                        End If
                                    End If
                                End If
                            End If
                            
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") And SIP > 0 Then
                                StartPlt(4) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                            End If
                        
                        End If
                         
                        If ShortOutFlag = 1 Then
                            ShortOutput(4) = 1
                            AbortFlag = 1
                            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                            Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(4) = 1
                        
                        
                       
                        ActiveSeq = oActive
                        ActiveMajorP = oMajP
                        ActiveMinorP = oMinP
                        WasteOfTime = 0
                        
                        'Draw the plot if necessary
                        If DoneThis = 0 And ShowPlotFlag = 1 Then
                        
                            mPrbL = -Log10(mPrb)
                            DoneThis = 1
                            GYAxHi(1) = Decompress(Len(StrainSeq(0)))
                            Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(-Log10(mPrb)), 0, 1, "-Log[P(Chi2)]")
                            YScaleFactor = 0.85
                            PicHeight = (Form1.Picture7.Height * YScaleFactor)
                            Form1.Picture7.DrawStyle = 2
                            
                            ZP = LowestProb
                            'Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(ZP) / mPrbL) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(ZP) / mPrbL) * (PicHeight - 35))), QBColor(0)
                            'Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / mPrbL) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb / MCCorrection) / mPrbL) * (PicHeight - 35))), QBColor(0)
                            Form1.Picture7.DrawStyle = 0
                            Form1.Picture7.DrawWidth = 1
                            Pict = Form1.Picture7.hdc
                            Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1)) * XFactor), -15 + PicHeight - (-Log10(ChiPVal(ChiValsX(1))) / mPrbL) * (PicHeight - 35), PntAPI)
                                
                            For x = 2 To LenXoverSeq - 1
                                Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x)) * XFactor, -15 + PicHeight - (-Log10(ChiPVal(ChiValsX(x))) / mPrbL) * (PicHeight - 35))
                            Next '
                            Form1.Picture7.Refresh
                        End If
                    End If
                Else
                    WasteOfTime = WasteOfTime + 1
                    If WasteOfTime = 3 Then
                        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                        Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                        Exit Sub
                    End If
                End If
            Else
                WasteOfTime = WasteOfTime + 1
                If WasteOfTime = 3 Then
                    Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                    Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                    Exit Sub
                End If
            End If
        Else
            WasteOfTime = WasteOfTime + 1
            If WasteOfTime = 3 Then
                Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                Exit Sub
            End If
            RO = pMaxX
            LO = pMaxX
            'destroy the maxx peak
            'XX = ChiValsX(288)
            Dummy = DestroyPeakP(0, Len(StrainSeq(0)), RO, LO, LenXoverSeq, LOT(0), SmoothChiX(0), ChiValsX(0))
            
            If maxz = -1 Then
                Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                Exit Sub
            End If
            ChiValsX(maxz) = 0
            If Dummy = 0 Then
                Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
                Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
                Exit Sub
            End If
        End If
    Else
        Exit Do
        
    End If
    
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop
Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), ChiValsX(0))
Dummy = CleanChiVals2(LenXoverSeq, Len(StrainSeq(0)), SmoothChiX(0))
x = x
End Sub
Public Sub MCXoverFOld(FindallFlag As Byte, BEP, ENP)

Dim HWindowWidth As Long, UB As Long, Dummy As Long, Redox As Long, CurWinPos As Long, NumInList As Long, EWarn As Long, BWarn As Long, SIP As Long
Dim ENX As Long, BEX As Long, ZZ As Long, oActive As Long, oMajP As Long, oMinP As Long, CF As Long, YScaleFactor As Single
Dim Y As Long
If AbortFlag = 1 Then Exit Sub

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If

Dim FullMC As Double, xMPV As Variant, GoOn As Byte, XB As Long, XE As Long, XBP As Double, XEP As Double, DoneRedo As Byte, LOT(1) As Double, BPP As Double, EPP As Double, BPV As Double, EPV As Double, PPVal As Double, BE As Long, EN As Long, DoneThis As Byte
Dim maxz As Long, MaxX As Long, WinWin As Long
Dim Failcount As Long
Dim MPV As Double, HMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long
Dim mPrbL As Double, ZP As Double

Dim WasteOfTime As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim ProbabilityXOver As Double
Dim Pict As Long
Dim PntAPI As POINTAPI
Dim PV As Double, MaxFailCount As Long, PBinFlag As Long


HWindowWidth = CLng(MCWinSize / 2)

'If Seq1 = 0 Or Seq1 = 1 Or Seq1 = 12 Then
'If Seq2 = 0 Or Seq2 = 1 Or Seq2 = 12 Then
'If Seq3 = 0 Or Seq3 = 1 Or Seq3 = 12 Then
'X = X
'End If
'End If
'End If


'13,17
'15,18
PBinFlag = -1


'XX = UBound(PermDiffs, 1)
If (PermDIffs(Seq1, Seq2) < 3 Or PermDIffs(Seq1, Seq3)) < 3 Or PermDIffs(Seq2, Seq3) < 3 Then
    If CLine = "" Or CLine = " " Then
    
       ' Dummy = CleanChiVals(LenXoverSeq, LenStrainSeq(0), Chivals(0, 0))
   
        Exit Sub
    End If
End If


UB = 0
 On Error Resume Next
UB = UBound(Chivals, 1)
On Error GoTo 0
If UB = 0 Then
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
    'XX = UBound(Winscores, 1)
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
End If

'Erase Scores
'Erase Winscores
'Erase Chivals
'Erase SmoothChi
'Erase ScoresX
'Erase WinScoresX
'Erase ChiValsX
'Erase SmoothChiX


'1.641,1.562
'This could be speeded up with better nesting
 If UBound(CompressSeq, 2) = NextNo And SEventNumber = 0 Then
    LenXoverSeq = FindSubSeqMCPB(UBound(FSSMC, 2), UBound(CompressSeq, 1), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), XDiffPos(0), XPosDiff(0), FSSMC(0, 0, 0, 0))
 Else
    LenXoverSeq = FindSubSeqCP(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
 End If

'3.015,3.078



'I must calculate a more severe critical diff for the mccorrection - ie 2 diffs
'must be calculated - one for here and one for later on in calcchivals.
'XX = PermSeqNumInFile

If LenXoverSeq < CriticalDiff * 2 Then
    'Dummy = CleanChiVals(LenXoverSeq, LenStrainSeq(0), Chivals(0, 0))
    Exit Sub
End If
If LenXoverSeq < 7 Then
     'Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
    Exit Sub
End If

'
'If LenXoverSeq < MCWinSize Then
'    x = x
'End If
Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXoverSeq, MCWinFract, MCWinSize, HWindowWidth, lHWindowWidth, GoOn, FindallFlag, MCProportionFlag, XPosDiff())

'3.375,3.281



If GoOn = 0 Then
     'Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
    Exit Sub
End If
'If HWindowWidth <> lHWindowWidth Then
'    '
'    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
'
'    lHWindowWidth = HWindowWidth
'End If


'3.312
'@
Dummy = WinScoreCalcP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffPos(0), SeqNum(0, 0), Winscores(0, 0))

'4.656,4.750

'Exit Sub
'This could be speeded up with better nesting

 

If FindallFlag = 0 And ((LongWindedFlag = 1 And SEventNumber > 0) Or CircularFlag = 0) Then
    If SEventNumber > 0 Then
       ' Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        If SEventNumber = 1 Then
            

            Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
            Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
            'ReDim BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
            
            


        End If
        'SS = Abs(GetTickCount)
        'For X = 0 To 200000
        '
        
        Dummy = MakeBanWinP(UBound(BanWin, 1), Seq1, Seq2, Seq3, HWindowWidth, Len(StrainSeq(0)), LenXoverSeq, BanWin(0), MDMap(0), MissingData(0, 0), XPosDiff(0), XDiffPos(0))
        'Next X
        'EE = Abs(GetTickCount)
        'TT = EE - SS
        'X = X '3837'3541'3339
        
        
        x = x
    Else
        'ReDim MDMap(LenXOverSeq), BanWin(LenXOverSeq + HWindowWidth * 2)
        
        Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
        Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        'BanWin(1) = 1
        'BanWin(Len(StrainSeq(0))) = 1
    End If
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXoverSeq) = 1
        '
        For x = (LenXoverSeq - HWindowWidth + 2) To LenXoverSeq
            BanWin(x) = 1
        Next x
        
    End If

    '10.605
    '10.465 using offsets
    '
    'XX = MaxEListLen
'    For x = 0 To Len(StrainSeq(0))
'        If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
'            x = x
'        End If
'    Next x
'    For x = 0 To LenXoverSeq
'        If MDMap(x) = 1 Then
'            x = x
'        End If
'    Next x
'    For x = 0 To LenXoverSeq
'        If BanWin(x) = 0 Then
'            x = x
'        End If
'    Next x
    'MChi = CalcChiVals4P2(UBound(ChiTable, 1), UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable(0, 0, 0))
    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
        '
        MChi = CalcChiVals4P3(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable2(Chimap(HWindowWidth)))
    Else
        MChi = CalcChiVals4P(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
    End If
    'MChi = CalcChiVals4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
Else
    If SEventNumber = 1 Then
        Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
        Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
    'ElseIf UBound(BanWin, 1) <> Len(StrainSeq(0)) + HWindowWidth * 2 Then
        'Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
    End If
'    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
'        MChi = CalcChiValsP2(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), ChiTable2(ChiMap(HWindowWidth)))
'    Else
        MChi = CalcChiValsP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0))
'    End If
   
End If





'8.203
'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
If MCProportionFlag = 0 Then
        If (ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            Exit Sub
        End If
    Else
        If ((ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            Exit Sub
        End If
    End If
'8.313

If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXoverSeq, HWindowWidth, mtP(), 3)
End If


'Smooth to find peaks (uses a window of positions)


'test if this p version is quicker
'SmoothChiValsP LenXOverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'The p - varsion is slower
'@
SmoothChiValsP LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'9.125,9.172


'Exit Sub


MChi = 0
'
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events


'XX = SEventNumber
Redox = 0
If MCFlag = 0 Then
    FullMC = 3 * LenXoverSeq / HWindowWidth
    FullMC = FullMC * MCCorrection
Else
    FullMC = 3 * LenXoverSeq / HWindowWidth
End If
Do
    Redox = Redox + 1
    '@
    FindMChiP Len(StrainSeq(0)), LenXoverSeq, MaxX, MaxY, MChi, Chivals(0, 0)
    
    '8.828,8.844
    
    If MaxX = -1 Or MaxY = -1 Or Redox > 100 Then
        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
        'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
        Exit Sub
    End If
    
    'The p-version of this seems slower than the old one
    mPrb = ChiPVal2(MChi)
    If MCProportionFlag = 0 Then
    '
        If (mPrb * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
            Exit Sub
        End If
    Else
        If ((mPrb * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
            Exit Sub
        End If
    End If
    '8.907
    'Exit Sub
    'XX = XPosDiff(2688)
    '10.000
    'Exit Sub
    
    If mPrb < LowestProb Then
        '
        maxz = MaxX
        
        If MaxX = 0 Then MaxX = 1
       
        Call MakeTWin(FindallFlag, HWindowWidth, TWin, LenXoverSeq)
        
        
        MaxFailCount = HWindowWidth * 2
        If MaxFailCount > Int((LenXoverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXoverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        '
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        ''
        Dummy = GetAC(LenXoverSeq, Len(StrainSeq(0)), MaxY, MaxX, TWin, A, C, Scores(0, 0))
        
        
        'Now find the other breakpoint.
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXoverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXoverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXoverSeq
            Else
                MaxX = LenXoverSeq - 1
            End If
        End If
        
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXoverSeq / HWindowWidth)
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXoverSeq + LO
        '
        RO = (MaxX + TWin)
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO >= LenXoverSeq Then
            If MDMap(LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                TWin = TWin - 1
                RO = LenXoverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXoverSeq + LO
                        
            End If
        End If
        'XX = MDMap(1)
        'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        '
        If FindallFlag = 0 Then
            
            
            If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                'better use of floats might help here - also the p-version gives a slightly different result to the non-p version
                'These routines give slightly different results to the vc5 versions
                
                'compilerdiffs
                '
                'If X = X Then
                    ''
                    'lo=147, ro=166, lenxover = 240, A=5, C=7, topl=46, topr = 84; toplo 63, topro 10
                    'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                    Dummy = GrowMChiWin2P2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0), ChiTable2(0), Chimap(0))
'                    If WinWin > 1000 Then
'                        WinWin = 1000
'                    End If
'XX = CircularFlag
                    If WinWin < HWindowWidth Then
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                        'MPV = MPV
                    Else
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                        'MPV = MPV
                    End If
                    'MPV = MPV * MCCorrection
                    '5.6988-4,3.118, 1912, 4755, 35, 4655
                    x = x
'                Else
'                    '20.9878
'                    '6.8674 x 10-4
'                    Dummy = GrowMChiWin2(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
'                    X = X
'                End If
                'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                x = x
            Else
                'compilerdiffs
                'Dummy = GrowMChiWinP(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                
                
                If x = x Then
                    If x = x Then
                        Dummy = GrowMChiWinP2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), ChiTable2(0), Chimap(0))
'                        If WinWin > 1000 Then
'                            WinWin = 1000
'                        End If
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            If MChi < 20000 Then
                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            Else
'                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                                XX = ChiPVal2(20000)
                                MPV = 10 ^ -200
                            End If
                            'MPV = MPV
                        End If
                    Else
                        Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
'                        If WinWin > 1000 Then
'                            WinWin = 1000
'                        End If
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            'MPV = MPV
                        End If
                        'Dummy = GrowMChiWin(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                    End If
                
                End If
                x = x
            End If
        Else
'            Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
'            If WinWin < HWindowWidth Then
'                MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
'                'MPV = MPV
'            Else
'                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                'MPV = MPV
'            End If
            Dummy = GrowMChiWinP2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), ChiTable2(0), Chimap(0))
'            If WinWin > 1000 Then
'                WinWin = 1000
'            End If
            If WinWin < HWindowWidth Then '35,35,57
                MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                'MPV = MPV
            Else
                If MChi < 20000 Then
                    MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                Else
'                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                                XX = ChiPVal2(20000)
                    MPV = 10 ^ -200
                End If
                'MPV = MPV
            End If
           
        End If
        'xMPV
       
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        xMPV = MPV 'MCCorrection * 3
        '
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        
        If BQPV > xMPV Then
            BQPV = xMPV
        End If
        
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        '
        On Error GoTo 0
        
        If ShortOutFlag = 3 Then
            If MPV <= mtP(3) Then
                mtP(3) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        RO = MaxX + WinWin - 1
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO > LenXoverSeq Then
            If MDMap(RO - LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                RO = LenXoverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXoverSeq
        End If
        '34.42
        
        
        '
        If MPV < LowestProb Then
            
            
            PPVal = -1
            
            
            If x = x Then
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) - 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) - 1
                    End If
                End If
                
                ProbabilityXOver = 0
                
                'So.....Which side of the window is the recombinant region?
                'Calculate windows on the other side of the region bounds
                'and find the the highest chi value.
                
                If (LO - WinWin + LenXoverSeq) < 0 Then
                     LO = (-LenXoverSeq + WinWin)
                End If
                ''
                
                Dummy = FindSide(TopL, TopR, Len(StrainSeq(0)), LO, RO, WinWin, LenXoverSeq, MaxY, Scores(0, 0), HiLeft, HiRight)
                If HiLeft < 0 Or HiRight < 0 Then
                    x = x
                End If
                If HiLeft >= HiRight Then
                    '                    'Find "best" matching breakpoint position.
                    CurWinPos = OptLeftBPMC(LO, HiLeft, TopL, MaxX, MaxY, WinWin, LenXoverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                    LO = CurWinPos '325,226,233,308,308
                    
                    If LO > LenXoverSeq Then LO = 1
                    If FindallFlag = 1 Then
                        XB = XDiffPos(MaxX)
                        XE = XDiffPos(RO)
                        
                        XEP = ChiPVal(Chivals(RO, MaxY)) * FullMC
                        XBP = mPrb * FullMC
                        
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    End If
                    
                    If LO < 1 Then
                        LO = LO + LenXoverSeq
                    End If
                    
                    If MaxX < 1 Then
                        RO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        RO = MaxX - LenXoverSeq
                    ElseIf MaxX = 1 Then
                        If MDMap(1) = 0 And BanWin(1) = 0 Then
                            RO = MaxX
                        Else
                            RO = LenXoverSeq
                        End If
                    Else
                        RO = MaxX
                    End If
                    
                    If RO > 0 Then
                        RO = RO - 1
                    End If
                    Do While MDMap(RO) <> 0
                        RO = RO - 1
                        If RO < 1 Then RO = LenXoverSeq
                    Loop
                    RO = RO + 1
                    If RO > LenXoverSeq Then RO = LenXoverSeq
                    
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO)
                    Else
                        BE = XDiffPos(LO + 1)
                    End If
                    EN = XDiffPos(RO)
                    
                        
                    BPV = ChiPVal(Chivals(LO, MaxY)) * FullMC
                    EPV = mPrb * FullMC
                    
                    
                Else
                    'Find "best" matching breakpoint position.
                    '1:55 with this, 1:20 without it - I need to get a working port of this finished
                    
                    CurWinPos = OptRightBPMC(RO, HiRight, TopR, MaxX, MaxY, WinWin, LenXoverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                    'CurWinPos = Dummy '45
                    RO = CurWinPos '115,106,90,103,111,142,101,111
                    
                    If RO < 1 Then RO = LenXoverSeq
                    If FindallFlag > 0 Then
                        XB = XDiffPos(LO)
                        XE = XDiffPos(MaxX)
                        
                        XBP = ChiPVal(Chivals(LO, MaxY)) * FullMC
                        XEP = mPrb * FullMC
                        
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    End If
                    If RO >= LenXoverSeq * 2 Then
                        RO = RO - LenXoverSeq * 2
                    End If
                    If RO > LenXoverSeq Then
                        RO = RO - LenXoverSeq
                    End If
                    
                    If MaxX < 0 Then
                        LO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        LO = MaxX - LenXoverSeq
                    Else
                        LO = MaxX
                    End If
                    
                    If LO < LenXoverSeq Then
                        LO = LO + 1
                    End If
                    Do While MDMap(LO) <> 0
                        LO = LO + 1
                        If LO > LenXoverSeq Then LO = 1
                    Loop
                    LO = LO - 1
                    If LO < 1 Then LO = 1
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO)
                    Else
                        BE = XDiffPos(LO + 1)
                    End If
                    EN = XDiffPos(RO)
                    
                    BPV = mPrb * FullMC
                    EPV = ChiPVal(Chivals(RO, MaxY)) * FullMC
                    
                    
                End If
                
                MaxX = pMaxX
                
                'Destroy the completed peaks
                If LO < RO Then
                    If MaxX >= LO And MaxX <= RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                Else
                    If MaxX > LO Or MaxX < RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                End If
                'Destroy the completed peaks
                Dummy = DestroyPeaks(MaxY, LenXoverSeq, Len(StrainSeq(0)), LO, RO, SmoothChi(0, 0), Chivals(0, 0))
                Chivals(maxz, MaxY) = 0
                
                ProbabilityXOver = MPV
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                    End If
                End If
                If MPV < LowestProb Then   'it is necessary to destroy the region if it is not accepted
                    
                                            'thats why this cut must be remade here
                    'store the event
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If NumInList <= TripListLen Then
                                
                                    If ProgBinRead(3, Worthwhilescan(NumInList)) = 0 Then
                                    
                                        Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 8
                                    End If
                                End If
                            End If
                        End If
                    End If
                    
                    
                    EWarn = 0: BWarn = 0
                        If LongWindedFlag = 1 Then
                            If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                               
                            ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                                
                            ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                               
                                
                            ElseIf StoreLPV(3, Seq1) >= StoreLPV(3, Seq2) And StoreLPV(3, Seq1) >= StoreLPV(3, Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                            ElseIf StoreLPV(3, Seq2) >= StoreLPV(3, Seq1) And StoreLPV(3, Seq2) >= StoreLPV(3, Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                            ElseIf StoreLPV(3, Seq3) >= StoreLPV(3, Seq1) And StoreLPV(3, Seq3) >= StoreLPV(3, Seq2) Then
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                            End If
                        End If
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(3) = oRecombNo(3) + 1
                    
'                    If Seq1 = 2 And Seq2 = 24 And Seq3 = 44 Then
'                        x = x
'                    End If
                    If APermFlag = 0 Then
                        '
                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 3, ProbabilityXOver, SIP)
                        
                    Else
                        SIP = 1
                    End If
                    
                    ActualFound = 1
                    NewOneFound = 1
                    If SIP < 0 Then
                        
                        If DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(3, Seq1, Seq2, Seq3)
                            'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                            Exit Sub
                        End If
                    Else
                        '
                        If ActiveSeq > UBound(XoverList, 1) Then
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                            'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                            Exit Sub
                        End If
                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq '19,3
                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                        XoverList(ActiveSeq, SIP).SBPFlag = 0
                        XoverList(ActiveSeq, SIP).ProgramFlag = 3
                        
                        Call CentreBP(0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                        XoverList(ActiveSeq, SIP).Beginning = BE
                        XoverList(ActiveSeq, SIP).Ending = EN
                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                        If PPVal >= 0 Then
                            XoverList(ActiveSeq, SIP).PermPVal = PPVal
                        End If
                        XoverList(ActiveSeq, SIP).BeginP = 0 'BPV
                        XoverList(ActiveSeq, SIP).EndP = 0 'EPV
                        XoverList(ActiveSeq, SIP).DHolder = 0
                        'Store the window size used to detect this event
                        XoverList(ActiveSeq, SIP).LHolder = WinWin * 2
                        
                        'XX = XOverList(29, 76).Ending
                        If LongWindedFlag = 1 And (SEventNumber > 1 Or CircularFlag = 0) Then
                            If XPosDiff(EN) > LenXoverSeq Then XPosDiff(EN) = LenXoverSeq
                            If XPosDiff(EN) = LenXoverSeq Then
                                ENX = 1
                            Else
                                ENX = XPosDiff(EN) + 1
                            End If
                            If ENX > LenXoverSeq Then ENX = ENX - LenXoverSeq
                            
                            If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                                BEX = LenXoverSeq
                            Else
                                BEX = XPosDiff(BE) - 1
                            End If
                            If BEX < 1 Then BEX = LenXoverSeq + BEX
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                            End If
                            If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 3
                            ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1 Or (EWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 2
                            ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1 Or (BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 1
                            End If
                        End If
                        GoOn = 1
                        XB = BE
                        XE = EN
                        If FindallFlag = 1 Then
                            
                            If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                If x = x Then
                                    '
                                    GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                                
                                Else
                                
                                    If XB < XE Then
                                        For ZZ = XB To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    Else
                                        For ZZ = 1 To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                        For ZZ = XB To Len(StrainSeq(0))
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    End If
                                End If
                            End If
                        End If
                        
                        
                        If GoOn = 0 And FindallFlag = 1 Then 'erase it if it contained missingdata but only if findall=1
                            CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) - 1
                        Else
                            
                            'For some reason this is REALLY slow -I've disabled it
                            oActive = ActiveSeq
                            oMajP = ActiveMajorP
                            oMinP = ActiveMinorP
                            '@
                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                            x = x
                        End If
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(3) = 1
                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                        End If
                        
                        If FindallFlag = 1 Then
                            GoOn = 1
                            XE = XoverList(ActiveSeq, SIP).Beginning
                            XB = XoverList(ActiveSeq, SIP).Ending
                            
                            If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                If x = x Then
                                    GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                                Else
                                    If XB < XE Then
                                        For ZZ = XB To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    Else
                                        For ZZ = 1 To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                        For ZZ = XB To Len(StrainSeq(0))
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    End If
                                End If
                            End If
                            If GoOn = 1 Then
                                
                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 3, ProbabilityXOver, SIP)
                                'If SIP < 1 Then
                                '    SIP = 0 'this "throws" the result away
                                'End If
                                If SIP > 0 Then
                                    If ActiveSeq > UBound(XoverList, 1) Then
                                        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                                        'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                                        Exit Sub
                                    End If
                                    XoverList(ActiveSeq, SIP) = XoverList(ActiveSeq, SIP - 1)
                                    XoverList(ActiveSeq, SIP).SBPFlag = 0
                                    
                                    Call CentreBP(0, 0, Seq1, Seq2, Seq3, XB, XE, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                                    XoverList(ActiveSeq, SIP).Beginning = XB
                                    XoverList(ActiveSeq, SIP).Ending = XE '19,4
                                    XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                    If PPVal >= 0 Then
                                        XoverList(ActiveSeq, SIP).PermPVal = PPVal
                                    End If
                                    XoverList(ActiveSeq, SIP).BeginP = 0 'XBP
                                    XoverList(ActiveSeq, SIP).EndP = 0 'XEP
                                    XoverList(ActiveSeq, SIP).DHolder = 0
                                    'Store the window size used to detect this event
                                    If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                                        If XPosDiff(EN) = LenXoverSeq Then
                                            ENX = 1
                                        Else
                                            ENX = XPosDiff(EN) + 1
                                        End If
                                        If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                                            BEX = LenXoverSeq
                                        Else
                                            BEX = XPosDiff(BE) - 1
                                        End If
                                        
                                        If SEventNumber > 0 Then
                                            If EWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                        End If
                                        If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 3
                                        ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1 Or (EWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                        ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1 Or (BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                        End If
                                        
                                        If LoHiFlag = 0 Then
                                            LoHiFlag = 1
                                        Else
                                            LoHiFlag = 0
                                        End If
                                        If MCMaxX = 0 Then
                                            MCMaxX = 1
                                        Else
                                            MCMaxX = 0
                                        End If
                                        If FindallFlag = 0 Then
                                            oActive = ActiveSeq
                                            oMajP = ActiveMajorP
                                            oMinP = ActiveMinorP
                                            
                                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                                        End If
                                    End If
                                End If
                            End If
                            
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(3) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                            End If
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(3) = 1
                            AbortFlag = 1
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                            'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(3) = 1
                        
                        
                        
                        ActiveSeq = oActive
                        ActiveMajorP = oMajP
                        ActiveMinorP = oMinP
                        WasteOfTime = 0
                        
                        'Draw the plot if necessary
                        If DoneThis = 0 And ShowPlotFlag = 1 Then
                        
                            DoneThis = 1
                            If MCFlag = 0 Then
                                CF = MCCorrection
                            Else
                                CF = 1
                            End If
                            CF = CF * Int((LenXoverSeq / HWindowWidth) + 0.49) * 3
                            mPrbL = -Log10(mPrb * CF)
                            
                            ZP = -Log10(LowestProb / MCCorrection)
                            
                            If mPrbL < ZP Then mPrbL = ZP
                            
                            Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(mPrbL), 0, 1, "-Log[P(Chi2)]")
                            YScaleFactor = 0.85
                            PicHeight = (Form1.Picture7.Height * YScaleFactor)
                            Form1.Picture7.DrawStyle = 2
                            
                            ZP = -Log10(LowestProb)
                            
                            Form1.Picture7.DrawStyle = 0
                            Form1.Picture7.DrawWidth = 1
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(Seq1): WNStr(2) = OriginalName(Seq2): WNStr(3) = OriginalName(Seq3)
                            Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                            For Y = 0 To 2
                                If Y = 0 Then
                                    Form1.Picture7.ForeColor = Yellow
                                ElseIf Y = 1 Then
                                    Form1.Picture7.ForeColor = Green
                                ElseIf Y = 2 Then
                                    Form1.Picture7.ForeColor = Purple
                                End If
                                Pict = Form1.Picture7.hdc
                                If -Log10(ChiPVal(Chivals(1, Y)) * CF) > 0 Then
                                    Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1)) * XFactor), -15 + PicHeight - (-Log10(ChiPVal(Chivals(1, Y)) * CF) / (mPrbL)) * (PicHeight - 35), PntAPI)
                                Else
                                    Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1)) * XFactor), -15 + PicHeight, PntAPI)
                                End If
                                For x = 2 To LenXoverSeq - 1
                                    If -Log10(ChiPVal(Chivals(x, Y)) * CF) > 0 Then
                                        Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x)) * XFactor, -15 + PicHeight - (-Log10(ChiPVal(Chivals(x, Y)) * CF) / mPrbL) * (PicHeight - 35))
                                    Else
                                        Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x)) * XFactor, -15 + PicHeight)
                                    End If
                                Next '
                            Next '
                            Form1.Picture7.Refresh
                        End If
                    
                        
                    End If
                Else
                    WasteOfTime = WasteOfTime + 1
                    If WasteOfTime = 3 Then
                        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                        'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                        Exit Sub
                    End If
                End If
            Else
                WasteOfTime = WasteOfTime + 1
                If WasteOfTime = 3 Then
                    Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                    'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                    Exit Sub
                End If
            End If
        Else
            WasteOfTime = WasteOfTime + 1
            If WasteOfTime = 3 Then
                Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                Exit Sub
            End If
            
            RO = pMaxX
            LO = pMaxX
            'XX = Chivals(420, 2)
            'destroy the maxx peak
            Dummy = DestroyPeakP(MaxY, Len(StrainSeq(0)), RO, LO, LenXoverSeq, LOT(0), SmoothChi(0, 0), Chivals(0, 0))
            '
            If maxz = -1 Or MaxY = -1 Then
                Dummy2 = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                'Dummy2 = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                Exit Sub
            End If
            Chivals(maxz, MaxY) = 0
            If Dummy = 0 Then
                Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
                Exit Sub
            End If
        End If
    Else
        Exit Do
    End If
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop
Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
'Dummy = CleanChiVals(Len(StrainSeq(0)), Len(StrainSeq(0)), SmoothChi(0, 0))
End Sub

Public Sub MCXoverFIV(Element As Long, LenXoverSeq As Long, FindallFlag As Byte, BEP, ENP)
If AbortFlag = 1 Then Exit Sub

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If

Dim FullMC As Long, xMPV As Variant, GoOn As Byte, XB As Long, XE As Long, XBP As Double, XEP As Double, DoneRedo As Byte, LOT(1) As Double, BPP As Double, EPP As Double, BPV As Double, EPV As Double, PPVal As Double, BE As Long, EN As Long, DoneThis As Byte
Dim maxz As Long, MaxX As Long, WinWin As Long
Dim Failcount As Long
Dim MPV As Double, HMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long
Dim mPrbL As Double, ZP As Double

Dim WasteOfTime As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim ProbabilityXOver As Double
Dim Pict As Long
Dim PntAPI As POINTAPI
Dim PV As Double, MaxFailCount As Long
'If SEventNumber = 0 Then
'If Seq1 = 4 Or Seq1 = 5 Or Seq1 = 24 Then
'If Seq2 = 5 Or Seq2 = 4 Or Seq2 = 24 Then
'If Seq3 = 24 Or Seq3 = 4 Or Seq3 = 5 Then
'X = X
'End If
'End If
'End If
'End If

'13,17
'15,18


'
If (PermDIffs(Seq1, Seq2) < 3 Or PermDIffs(Seq1, Seq3)) < 3 Or PermDIffs(Seq2, Seq3) < 3 Then
    If CLine = "" Or CLine = " " Then
        Exit Sub
    End If
End If


UB = 0
If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
UB = UBound(Chivals, 1)
On Error GoTo 0
If UB = 0 Then
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
    'XX = UBound(Winscores, 1)
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
End If

'Erase Scores
'Erase Winscores
'Erase Chivals
'Erase SmoothChi
'Erase ScoresX
'Erase WinScoresX
'Erase ChiValsX
'Erase SmoothChiX


'1.641,1.562
'This could be speeded up with better nesting
''''''
'LenXOverSeq = FindSubSeqCP(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))

'3.015,3.078



'I must calculate a more severe critical diff for the mccorrection - ie 2 diffs
'must be calculated - one for here and one for later on in calcchivals.
'XX = PermSeqNumInFile

If LenXoverSeq < CriticalDiff * 2 Then Exit Sub

If LenXoverSeq < 7 Then
    
    Exit Sub
End If

'
'Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXOverSeq, MCWinFract, MCWinSize, HWindowWidth, lHWindowWidth, GoOn, FindallFlag, MCProportionFlag, XPosDiff())
Call MakeWindowSize2(Element, BEP, ENP, CriticalDiff, LenXoverSeq, MCWinFract, MCWinSize, HWindowWidth, lHWindowWidth, GoOn, FindallFlag, MCProportionFlag, XPosDiff())

'3.375,3.281



If GoOn = 0 Then Exit Sub

'If HWindowWidth <> lHWindowWidth Then
'    '
'    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
'
'    lHWindowWidth = HWindowWidth
'End If


'3.312
'''

Dummy = WinScoreCalcP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffPos(0, Element), SeqNum(0, 0), Winscores(0, 0))

'4.656,4.750


'This could be speeded up with better nesting

 

If FindallFlag = 0 And ((LongWindedFlag = 1 And SEventNumber > 0) Or CircularFlag = 0) Then
    If SEventNumber > 0 Then
       ' Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        If SEventNumber = 1 Then
            

            Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
            'ReDim BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
            
            


        End If
        'SS = Abs(GetTickCount)
        'For X = 0 To 200000
        
        Dummy = MakeBanWinP(UBound(BanWin, 1), Seq1, Seq2, Seq3, HWindowWidth, Len(StrainSeq(0)), LenXoverSeq, BanWin(0), MDMap(0), MissingData(0, 0), XPosDiff(0, Element), XDiffPos(0, Element))
        'Next X
        'EE = Abs(GetTickCount)
        'TT = EE - SS
        'X = X '3837'3541'3339
        
        
        x = x
    Else
        'ReDim MDMap(LenXOverSeq), BanWin(LenXOverSeq + HWindowWidth * 2)
        
        Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
        Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        
    End If
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXoverSeq) = 1
        For x = (LenXoverSeq - HWindowWidth + 2) To LenXoverSeq
            BanWin(x) = 1
        Next x
        
    End If

    '10.605
    '10.465 using offsets
    '
    
    
    'MChi = CalcChiVals4P2(UBound(ChiTable, 1), UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable(0, 0, 0))
    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
        MChi = CalcChiVals4P3(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable2(Chimap(HWindowWidth)))
    Else
        MChi = CalcChiVals4P(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
    End If
    'MChi = CalcChiVals4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
Else
    If SEventNumber = 1 Then
        Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
        Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
    'ElseIf UBound(BanWin, 1) <> Len(StrainSeq(0)) + HWindowWidth * 2 Then
        'Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
    End If
'    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
'        MChi = CalcChiValsP2(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), ChiTable2(ChiMap(HWindowWidth)))
'    Else
        MChi = CalcChiValsP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0))
'    End If
   
End If




'8.203
'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
If MCProportionFlag = 0 Then
        If (ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Then Exit Sub
    Else
        If ((ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then Exit Sub
    End If
'8.313

If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXoverSeq, HWindowWidth, mtP(), 3)
End If


'Smooth to find peaks (uses a window of positions)


'test if this p version is quicker
'SmoothChiValsP LenXOverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'The p - varsion is slower
'''
SmoothChiVals LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'9.125,9.172





MChi = 0
'
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events


'XX = SEventNumber
Redox = 0
If MCFlag = 0 Then
    FullMC = MCCorrection * 3 * LenXoverSeq / HWindowWidth
Else
    FullMC = 3 * LenXoverSeq / HWindowWidth
End If
Do
    Redox = Redox + 1
    '
    FindMChiP Len(StrainSeq(0)), LenXoverSeq, MaxX, MaxY, MChi, Chivals(0, 0)
    
    '8.828,8.844
    
    If MaxX = -1 Or MaxY = -1 Or Redox > 100 Then
        Exit Sub
    End If
    
    'The p-version of this seems slower than the old one
    mPrb = ChiPVal2(MChi)
    If MCProportionFlag = 0 Then
    '
        If (mPrb * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then Exit Sub
    Else
        If ((mPrb * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then Exit Sub
    End If
    '8.907
    'Exit Sub
    'XX = XPosDiff(2688)
    '10.000
    'Exit Sub
    If mPrb < LowestProb Then
        '
        maxz = MaxX
        
        If MaxX = 0 Then MaxX = 1
       
        Call MakeTWin(FindallFlag, HWindowWidth, TWin, LenXoverSeq)
        
        
        MaxFailCount = HWindowWidth * 2
        If MaxFailCount > Int((LenXoverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXoverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        '
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        ''
        Dummy = GetAC(LenXoverSeq, Len(StrainSeq(0)), MaxY, MaxX, TWin, A, C, Scores(0, 0))
        
        
        'Now find the other breakpoint.
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXoverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXoverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXoverSeq
            Else
                MaxX = LenXoverSeq - 1
            End If
        End If
        
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXoverSeq / HWindowWidth)
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXoverSeq + LO
        '
        RO = (MaxX + TWin)
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO >= LenXoverSeq Then
            If MDMap(LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                TWin = TWin - 1
                RO = LenXoverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXoverSeq + LO
                        
            End If
        End If
        'XX = MDMap(1)
        'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        If FindallFlag = 0 Then
            
            
            If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                'better use of floats might help here - also the p-version gives a slightly different result to the non-p version
                'These routines give slightly different results to the vc5 versions
                
                'compilerdiffs
                '
                'If X = X Then
                    ''
                    'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                    Dummy = GrowMChiWin2P2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0), ChiTable2(0), Chimap(0))
                    If WinWin < HWindowWidth Then
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                        'MPV = MPV
                    Else
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                        'MPV = MPV
                    End If
                    'MPV = MPV * MCCorrection
                    '5.6988-4,3.118, 1912, 4755, 35, 4655
                    x = x
'                Else
'                    '20.9878
'                    '6.8674 x 10-4
'                    Dummy = GrowMChiWin2(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
'                    X = X
'                End If
                'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                x = x
            Else
                'compilerdiffs
                'Dummy = GrowMChiWinP(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                
                
                If x = x Then
                    If x = x Then
                        Dummy = GrowMChiWinP2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), ChiTable2(0), Chimap(0))
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            'MPV = MPV
                        End If
                    Else
                        Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            'MPV = MPV
                        End If
                        'Dummy = GrowMChiWin(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                    End If
                Else
                    Dummy = GrowMChiWin(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                End If
                x = x
            End If
           
        End If
        'xMPV
       
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        xMPV = MPV 'MCCorrection * 3
        '
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        '
        On Error GoTo 0
        
        If ShortOutFlag = 3 Then
            If MPV <= mtP(3) Then
                mtP(3) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        RO = MaxX + WinWin - 1
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO > LenXoverSeq Then
            If MDMap(RO - LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                RO = LenXoverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXoverSeq
        End If
        '34.42
        '
        If MPV < LowestProb Then
            
            
            PPVal = -1
            
            
            If x = x Then
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) - 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) - 1
                    End If
                End If
                
                ProbabilityXOver = 0
                
                'So.....Which side of the window is the recombinant region?
                'Calculate windows on the other side of the region bounds
                'and find the the highest chi value.
                
                If (LO - WinWin + LenXoverSeq) < 0 Then
                     LO = (-LenXoverSeq + WinWin)
                End If
                ''
                Dummy = FindSide(TopL, TopR, Len(StrainSeq(0)), LO, RO, WinWin, LenXoverSeq, MaxY, Scores(0, 0), HiLeft, HiRight)
                
                If HiLeft >= HiRight Then
                    '                    'Find "best" matching breakpoint position.
                    CurWinPos = OptLeftBPMC(LO, HiLeft, TopL, MaxX, MaxY, WinWin, LenXoverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                    LO = CurWinPos '325,226,233,308,308
                    
                    If LO > LenXoverSeq Then LO = 1
                    If FindallFlag = 1 Then
                        XB = XDiffPos(MaxX, Element)
                        XE = XDiffPos(RO, Element)
                        
                        XEP = ChiPVal(Chivals(RO, MaxY)) * FullMC
                        XBP = mPrb * FullMC
                        
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    End If
                    
                    If LO < 1 Then
                        LO = LO + LenXoverSeq
                    End If
                    
                    If MaxX < 1 Then
                        RO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        RO = MaxX - LenXoverSeq
                    ElseIf MaxX = 1 Then
                        If MDMap(1) = 0 And BanWin(1) = 0 Then
                            RO = MaxX
                        Else
                            RO = LenXoverSeq
                        End If
                    Else
                        RO = MaxX
                    End If
                    
                    If RO > 0 Then
                        RO = RO - 1
                    End If
                    Do While MDMap(RO) <> 0
                        RO = RO - 1
                        If RO < 1 Then RO = LenXoverSeq
                    Loop
                    RO = RO + 1
                    If RO > LenXoverSeq Then RO = LenXoverSeq
                    
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO, Element)
                    Else
                        BE = XDiffPos(LO + 1, Element)
                    End If
                    EN = XDiffPos(RO, Element)
                    
                        
                    BPV = ChiPVal(Chivals(LO, MaxY)) * FullMC
                    EPV = mPrb * FullMC
                    
                    
                Else
                    'Find "best" matching breakpoint position.
                    '1:55 with this, 1:20 without it - I need to get a working port of this finished
                    
                    CurWinPos = OptRightBPMC(RO, HiRight, TopR, MaxX, MaxY, WinWin, LenXoverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                    'CurWinPos = Dummy '45
                    RO = CurWinPos '115,106,90,103,111,142,101,111
                    
                    If RO < 1 Then RO = LenXoverSeq
                    If FindallFlag > 0 Then
                        XB = XDiffPos(LO, Element)
                        XE = XDiffPos(MaxX, Element)
                        
                        XBP = ChiPVal(Chivals(LO, MaxY)) * FullMC
                        XEP = mPrb * FullMC
                        
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    End If
                    If RO >= LenXoverSeq * 2 Then
                        RO = RO - LenXoverSeq * 2
                    End If
                    If RO > LenXoverSeq Then
                        RO = RO - LenXoverSeq
                    End If
                    
                    If MaxX < 0 Then
                        LO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        LO = MaxX - LenXoverSeq
                    Else
                        LO = MaxX
                    End If
                    
                    If LO < LenXoverSeq Then
                        LO = LO + 1
                    End If
                    Do While MDMap(LO) <> 0
                        LO = LO + 1
                        If LO > LenXoverSeq Then LO = 1
                    Loop
                    LO = LO - 1
                    If LO < 1 Then LO = 1
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO, Element)
                    Else
                        BE = XDiffPos(LO + 1, Element)
                    End If
                    EN = XDiffPos(RO, Element)
                    
                    BPV = mPrb * FullMC
                    EPV = ChiPVal(Chivals(RO, MaxY)) * FullMC
                    
                    
                End If
                
                MaxX = pMaxX
                
                'Destroy the completed peaks
                If LO < RO Then
                    If MaxX >= LO And MaxX <= RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                Else
                    If MaxX > LO Or MaxX < RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                End If
                'Destroy the completed peaks
                Dummy = DestroyPeaks(MaxY, LenXoverSeq, Len(StrainSeq(0)), LO, RO, SmoothChi(0, 0), Chivals(0, 0))
                Chivals(maxz, MaxY) = 0
                
                ProbabilityXOver = MPV
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                    End If
                End If
                If MPV < LowestProb Then   'it is necessary to destroy the region if it is not accepted
                    
                                            'thats why this cut must be remade here
                    'store the event
                    EWarn = 0: BWarn = 0
                        If LongWindedFlag = 1 Then
                            If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                               
                            ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                                
                            ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                               
                                
                            ElseIf StoreLPV(3, Seq1) >= StoreLPV(3, Seq2) And StoreLPV(3, Seq1) >= StoreLPV(3, Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                            ElseIf StoreLPV(3, Seq2) >= StoreLPV(3, Seq1) And StoreLPV(3, Seq2) >= StoreLPV(3, Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                            ElseIf StoreLPV(3, Seq3) >= StoreLPV(3, Seq1) And StoreLPV(3, Seq3) >= StoreLPV(3, Seq2) Then
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                            End If
                        End If
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(3) = oRecombNo(3) + 1
                    
                    
                    If APermFlag = 0 Then
                        '
                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 3, ProbabilityXOver, SIP)
                        
                    Else
                        SIP = 1
                    End If
                    ActualFound = 1
                    NewOneFound = 1
                    If SIP < 0 Then
                        If DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(3, Seq1, Seq2, Seq3)
                        End If
                    Else
                        '
                       
                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                        XoverList(ActiveSeq, SIP).SBPFlag = 0
                        XoverList(ActiveSeq, SIP).ProgramFlag = 3
                        
                        Call CentreBP2(Element, 0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                        XoverList(ActiveSeq, SIP).Beginning = BE
                        XoverList(ActiveSeq, SIP).Ending = EN
                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                        If PPVal >= 0 Then
                            XoverList(ActiveSeq, SIP).PermPVal = PPVal
                        End If
                        XoverList(ActiveSeq, SIP).BeginP = 0
                        XoverList(ActiveSeq, SIP).EndP = 0
                        XoverList(ActiveSeq, SIP).DHolder = 0
                        'Store the window size used to detect this event
                        XoverList(ActiveSeq, SIP).LHolder = WinWin * 2
                        
                        'XX = XOverList(29, 76).Ending
                        If LongWindedFlag = 1 And (SEventNumber > 1 Or CircularFlag = 0) Then
                            If XPosDiff(EN, Element) > LenXoverSeq Then XPosDiff(EN, Element) = LenXoverSeq
                            If XPosDiff(EN, Element) = LenXoverSeq Then
                                ENX = 1
                            Else
                                ENX = XPosDiff(EN, Element) + 1
                            End If
                            If ENX > LenXoverSeq Then ENX = ENX - LenXoverSeq
                            
                            If XPosDiff(BE, Element) = 1 Or XPosDiff(BE, Element) = 0 Then
                                BEX = LenXoverSeq
                            Else
                                BEX = XPosDiff(BE, Element) - 1
                            End If
                            If BEX < 1 Then BEX = LenXoverSeq + BEX
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB2(Element, 0, 0, MCWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB2(Element, 0, 0, MCWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                            End If
                            If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN, Element)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE, Element)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 3
                            ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN, Element)) = 1 Or (EWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 2
                            ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE, Element)) = 1 Or (BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 1
                            End If
                        End If
                        GoOn = 1
                        XB = BE
                        XE = EN
                        If FindallFlag = 1 Then
                            
                            If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                If x = x Then
                            
                                    GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                                
                                Else
                                
                                    If XB < XE Then
                                        For ZZ = XB To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    Else
                                        For ZZ = 1 To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                        For ZZ = XB To Len(StrainSeq(0))
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    End If
                                End If
                            End If
                        End If
                        
                        
                        If GoOn = 0 And FindallFlag = 1 Then 'erase it if it contained missingdata but only if findall=1
                            CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) - 1
                        Else
                            
                            'For some reason this is REALLY slow -I've disabled it
                            oActive = ActiveSeq
                            oMajP = ActiveMajorP
                            oMinP = ActiveMinorP
                            '
                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                            Call CentreBP2(Element, 0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                            
                        End If
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(3) = 1
                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                        End If
                        
                        If FindallFlag = 1 Then
                            GoOn = 1
                            XE = XoverList(ActiveSeq, SIP).Beginning
                            XB = XoverList(ActiveSeq, SIP).Ending
                            
                            If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                If x = x Then
                                    GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                                Else
                                    If XB < XE Then
                                        For ZZ = XB To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    Else
                                        For ZZ = 1 To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                        For ZZ = XB To Len(StrainSeq(0))
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    End If
                                End If
                            End If
                            If GoOn = 1 Then
                                
                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 3, ProbabilityXOver, SIP)
                                'If SIP < 1 Then
                                '    SIP = 0 'this "throws" the result away
                                'End If
                                If SIP > 0 Then
                                    XoverList(ActiveSeq, SIP) = XoverList(ActiveSeq, SIP - 1)
                                    XoverList(ActiveSeq, SIP).SBPFlag = 0
                                    
                                    Call CentreBP2(Element, 0, 0, Seq1, Seq2, Seq3, XB, XE, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                                    XoverList(ActiveSeq, SIP).Beginning = XB
                                    XoverList(ActiveSeq, SIP).Ending = XE
                                    XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                    If PPVal >= 0 Then
                                        XoverList(ActiveSeq, SIP).PermPVal = PPVal
                                    End If
                                    XoverList(ActiveSeq, SIP).BeginP = 0
                                    XoverList(ActiveSeq, SIP).EndP = 0
                                    XoverList(ActiveSeq, SIP).DHolder = 0
                                    'Store the window size used to detect this event
                                    If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                                        If XPosDiff(EN, Element) = LenXoverSeq Then
                                            ENX = 1
                                        Else
                                            ENX = XPosDiff(EN, Element) + 1
                                        End If
                                        If XPosDiff(BE, Element) = 1 Or XPosDiff(BE, Element) = 0 Then
                                            BEX = LenXoverSeq
                                        Else
                                            BEX = XPosDiff(BE, Element) - 1
                                        End If
                                        
                                        If SEventNumber > 0 Then
                                            If EWarn = 0 Then Call CheckEndsVB2(Element, 0, 0, MCWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB2(Element, 0, 0, MCWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                        End If
                                        If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN, Element)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE, Element)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 3
                                        ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN, Element)) = 1 Or (EWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                        ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE, Element)) = 1 Or (BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                        End If
                                        
                                        If LoHiFlag = 0 Then
                                            LoHiFlag = 1
                                        Else
                                            LoHiFlag = 0
                                        End If
                                        If MCMaxX = 0 Then
                                            MCMaxX = 1
                                        Else
                                            MCMaxX = 0
                                        End If
                                        If FindallFlag = 0 Then
                                            oActive = ActiveSeq
                                            oMajP = ActiveMajorP
                                            oMinP = ActiveMinorP
                                            
                                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                                            Call CentreBP2(Element, 0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                                        End If
                                    End If
                                End If
                            End If
                            
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(3) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                            End If
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(3) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(3) = 1
                        
                        
                        
                        ActiveSeq = oActive
                        ActiveMajorP = oMajP
                        ActiveMinorP = oMinP
                        WasteOfTime = 0
                        
                        'Draw the plot if necessary
                        If DoneThis = 0 And ShowPlotFlag = 1 Then
                        
                            DoneThis = 1
                            If MCFlag = 0 Then
                                CF = MCCorrection
                            Else
                                CF = 1
                            End If
                            CF = CF * Int((LenXoverSeq / HWindowWidth) + 0.49) * 3
                            mPrbL = -Log10(mPrb * CF)
                            
                            ZP = -Log10(LowestProb / MCCorrection)
                            
                            If mPrbL < ZP Then mPrbL = ZP
                            
                            Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(mPrbL), 0, 1, "-Log[P(Chi2)]")
                            YScaleFactor = 0.85
                            PicHeight = (Form1.Picture7.Height * YScaleFactor)
                            Form1.Picture7.DrawStyle = 2
                            
                            ZP = -Log10(LowestProb)
                            
                            Form1.Picture7.DrawStyle = 0
                            Form1.Picture7.DrawWidth = 1
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(Seq1): WNStr(2) = OriginalName(Seq2): WNStr(3) = OriginalName(Seq3)
                            Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                            For Y = 0 To 2
                                If Y = 0 Then
                                    Form1.Picture7.ForeColor = Yellow
                                ElseIf Y = 1 Then
                                    Form1.Picture7.ForeColor = Green
                                ElseIf Y = 2 Then
                                    Form1.Picture7.ForeColor = Purple
                                End If
                                Pict = Form1.Picture7.hdc
                                If -Log10(ChiPVal(Chivals(1, Y)) * CF) > 0 Then
                                    Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1, Element)) * XFactor), -15 + PicHeight - (-Log10(ChiPVal(Chivals(1, Y)) * CF) / (mPrbL)) * (PicHeight - 35), PntAPI)
                                Else
                                    Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1, Element)) * XFactor), -15 + PicHeight, PntAPI)
                                End If
                                For x = 2 To LenXoverSeq - 1
                                    If -Log10(ChiPVal(Chivals(x, Y)) * CF) > 0 Then
                                        Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x, Element)) * XFactor, -15 + PicHeight - (-Log10(ChiPVal(Chivals(x, Y)) * CF) / mPrbL) * (PicHeight - 35))
                                    Else
                                        Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x, Element)) * XFactor, -15 + PicHeight)
                                    End If
                                Next '
                            Next '
                            Form1.Picture7.Refresh
                        End If
                    
                        
                    End If
                Else
                    WasteOfTime = WasteOfTime + 1
                    If WasteOfTime = 3 Then Exit Sub
                End If
            Else
                WasteOfTime = WasteOfTime + 1
                If WasteOfTime = 3 Then Exit Sub
            End If
        Else
            WasteOfTime = WasteOfTime + 1
            If WasteOfTime = 3 Then Exit Sub
            
            
            RO = pMaxX
            LO = pMaxX
            '
            'destroy the maxx peak
            Dummy = DestroyPeak(MaxY, Len(StrainSeq(0)), RO, LO, LenXoverSeq, LOT(0), SmoothChi(0, 0), Chivals(0, 0))
            '
            If maxz = -1 Or MaxY = -1 Then Exit Sub
            '
            Chivals(maxz, MaxY) = 0
            If Dummy = 0 Then Exit Sub
            
        End If
    Else
        Exit Do
    End If
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop

End Sub
Public Sub MCXoverJ()
    
    Dim x As Long, Y As Long, retVal As Long
    Dim DA As Long, Ma As Long, Mi As Long, Z As Long, Scores() As Byte, Chivals() As Double, Winscores() As Long

    ReDim SubSetF(NextNo)
    ReDim SubSetR(NextNo + 1)
    
    If Seq1 = Seq2 Then Seq1 = Seq3
    
    LSeq = Len(StrainSeq(0))
    IncludeSeq = 0
    ReDim TempSeq(NextNo) As String
    ReDim RevSeq(NextNo)
    'Set up copies of sequences that can be edited and rearranged etc
    TempSeq(0) = StrainSeq(Form5.Combo1.ListIndex - 1)
    RevSeq(0) = Form5.Combo1.ListIndex - 1
    NumberOfSeqs = 1

    For x = 0 To NextNo

        If Selected(x) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(x)
            RevSeq(NumberOfSeqs) = x
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X
    TS = TempSeq(1)
    TempSeq(1) = TempSeq(2)
    TempSeq(2) = TS
    NumberOfSeqs = NumberOfSeqs - 1
    LSeq = Len(StrainSeq(0))

    If MCStripGapsFlag = 1 Then

        For x = 1 To LSeq

            For Z = 0 To NumberOfSeqs

                If Mid$(TempSeq(Z), x, 1) = "-" Then

                    For A = 0 To NumberOfSeqs
                        Mid$(TempSeq(A), x, 1) = "-"
                    Next 'A

                    Exit For
                End If

            Next 'Z

        Next 'X

    End If

    'Find sites used by MaxChi

    Call FindSubSeqMCIII

    
    'Remember that this method requires a set window size
    '(unlike the maxchi triplet scan).
    
    HWindowWidth = CLng(MCWinSize / 2)
    
    'Call GetCriticalDiff
    
    Dim PntAPI As POINTAPI
    'Prepare arrays
    'I MUST MOD THESE FOR JUST 1 SEQ PAIR
    ReDim Scores(Len(StrainSeq(0))) ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)))
    
    ReDim MCPrintPos(LenXoverSeq)
    ReDim MCPrintData(NumberOfSeqs, LenXoverSeq)
    
    Dim MaxX As Long, TWinScoresA As Long, TWinScoresB As Long, WinWin As Long
    Dim MaxY As Integer, Failcount As Integer
    Dim TMChi As Double, HMChi As Double
    Dim HiLeft As Double, HiRight As Double
    Dim pMaxX As Long
    Dim MChi As Double, mmChi As Double
    mmChi = 0
    Seq1 = RevSeq(0)
    For x = 1 To NumberOfSeqs
        Seq2 = RevSeq(x)
        'This could be speeded up with better nesting
        Dummy = WinScoreCalc2(1, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffPos(0), SeqNum(0, 0), Winscores(0))
        'This could be speeded up with better nesting
        MChi = CalcChiVals2(1, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0), Chivals(0))
        If mmChi < MChi Then mmChi = MChi
        For Y = 0 To LenXoverSeq
            MCPrintData(x - 1, Y) = ChiPVal(Chivals(Y))
            'If Y > 10 Then
            '    If MCPrintData(X - 1, Y) = MCPrintData(X - 1, Y - 10) And MCPrintData(X - 1, Y) = MCPrintData(X - 1, Y - 5) Then
            '        X = X
            '    End If
            '
            'End If
        Next Y
    Next x
    MChi = mmChi
    MCMinChiP = ChiPVal(MChi)
    
    If MCMinChiP > 0 Then
        MCMinChiP = -Log10(MCMinChiP)
    ElseIf MCMinChiP = 0 Then
        MCMinChiP = -Log10(0.000000001)
    End If

    If MCFlag = 0 Then
        If MCMinChiP < -Log10(LowestProb / ((NumberOfSeqs) * (NumberOfSeqs - 1) / 2)) Then MCMinChiP = -Log10(LowestProb / ((NumberOfSeqs) * (NumberOfSeqs - 1) / 2))
    Else
        If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
    End If
    
    

    Pict = Form1.Picture7.hdc
    
    
        
    For x = 0 To LenXoverSeq
        MCPrintPos(x) = XDiffPos(x)
    Next x
    
    'Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MCMinChiP), 0, 0, "-Log[P(Chi2)]")
    
    Pict = Form1.Picture7.hdc
    
    'Dummy = DrawDiffs(Pict, Len(MCXoverSeq(0)), XFactor, MCXDiffPos(0))
    
    PosCount = 0
    'Form1.Picture7.DrawWidth = 3
    
    
    
    MChi = MCMinChiP
    Pict = Form1.Picture7.hdc
    
'    For Y = 0 To NumberOfSeqs - 1
'        Form1.Picture7.ForeColor = FFillCol(RevSeq(Y + 1))
'        Pict = Form1.Picture7.hdc
'        X = 1
'        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffpos(X)) + (Decompress(XDiffpos(X + 1)) - Decompress(XDiffpos(X))) / 2) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, 1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
'
'        For X = 2 To LenXoverSeq - 1
'            Dummy = LineTo(Pict, 30 + (Decompress(XDiffpos(X)) + (Decompress(XDiffpos(X + 1)) - Decompress(XDiffpos(X))) / 2) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, X)) / MCMinChiP) * (PicHeight - 35)))
'
'        Next X
'    Next Y
    
    

    PosCount = 0
    Form1.Picture7.DrawWidth = 1
'    For Y = 0 To NumberOfSeqs - 1
'        Form1.Picture7.ForeColor = SeqCol(RevSeq(Y + 1))
'        Pict = Form1.Picture7.hdc
'        X = 1
'        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffpos(X)) + (Decompress(XDiffpos(X + 1)) - Decompress(XDiffpos(X))) / 2) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, 1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
'
'        For X = 2 To LenXoverSeq - 1
'            Dummy = LineTo(Pict, 30 + (Decompress(XDiffpos(X)) + (Decompress(XDiffpos(X + 1)) - Decompress(XDiffpos(X))) / 2) * XFactor, PicHeight - (15 + (-Log10(MCPrintData(Y, X)) / MCMinChiP) * (PicHeight - 35)))
'
'        Next X
'    Next Y
    
    'draw p-val cutoff
    'Form1.Picture7.DrawStyle = 2

'    If ExeCheckFlag = 1 Or MCFlag <> 0 Then
'        MCMaxP = LowestProb
'        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
'    End If

    MCMaxP = LowestProb / ((NumberOfSeqs) * (NumberOfSeqs) / 2)
'    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
'    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.DrawStyle = 0
    Form1.ProgressBar1.Value = 95
    Call UpdateF2Prog
    'shade detected region

    Call Highlight(0)
        
        
    'Get everything into the standard format for printing and saving
        NumLines = NumberOfSeqs 'number of lines to print
        ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
    
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = XDiffPos(x)
        Next x
        ReDim GCritval(10)
        
        
        MCMaxP = LowestProb / NumberOfSeqs
        GCritval(0) = -Log10(MCMaxP)
        
        GCritval(1) = -Log10(LowestProb)
        GLegend = "-Log[Chi2 P-Val]"
        GPrintLen = LenXoverSeq + 1 'how many points to plot
        For x = 0 To NumberOfSeqs - 1
            GPrintCol(x) = SeqCol(RevSeq(x + 1))
        Next x
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = MChi  'upper val
        GBlockNum = 0
        ReDim GBlock(4, 0)
        GBlock(1, 0) = 3 'this is not actually a block - it is the legend saying which sequence is the query sequence
        For x = 1 To LenXoverSeq - 1
            For Y = 0 To NumLines - 1
                GPrint(Y, x) = -Log10(MCPrintData(Y, x))
                GPrintPos(Y, x) = (XDiffPos(x) + (XDiffPos(x + 1) - XDiffPos(x)) / 2)
            Next Y
        Next x
        
        For Y = 0 To NumLines - 1
            GPrint(Y, LenXoverSeq) = -Log10(MCPrintData(Y, LenXoverSeq))
            
        Next Y
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            GPrintPos(x, GPrintLen - 1) = XDiffPos(LenXoverSeq) + (Len(StrainSeq(0)) - XDiffPos(LenXoverSeq)) / 2
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
    
    
        GExtraTNum = NumLines - 1
        ReDim GExtraText(GExtraTNum)
        
        For x = 1 To NumLines
            GExtraText(x - 1) = OriginalName(RevSeq(x))
            
        Next x
    ManFlag = 4
    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
    Call RedrawPlotAA(1)
    Form1.ProgressBar1.Value = 100
    Form1.Picture7.Refresh
    Form1.Picture10.Refresh
    Counter = Counter + 1
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.SSPanel8.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Picture21.Width = Form1.Picture7.Width + 100
Form1.Picture21.Height = Form1.Picture7.Height + 100
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5

End Sub
Public Sub MCXoverI()

    'pairwise maxchi
    Dim x As Long, Y As Long, retVal As Long
    Dim DA As Long, Ma As Long, Mi As Long, Z As Long

    ReDim SubSetF(NextNo)
    ReDim SubSetR(NextNo + 1)
    
    If Seq1 = Seq2 Then Seq1 = Seq3
    
    IncludeSeq = 0

    FindSubSeqMCII
    'Exit Sub
    'Remember that this method requires a set window size
    '(unlike the maxchi triplet scan).
    oMCWinSize = MCWinSize
    oMCWinfract = MCWinFract
    If OptFlag <> 4 Then
            BE = XoverList(RelX, RelY).Beginning
            EN = XoverList(RelX, RelY).Ending
            If BE < EN Then
                MCWinSize = (XPosDiff(EN) - XPosDiff(BE)) + 1
            Else
                MCWinSize = XPosDiff(EN) + (LenXoverSeq - XPosDiff(BE)) + 1
            End If
            
            MCWinSize = MCWinSize * 2
            MCWinFract = MCWinSize / LenXoverSeq
    End If
    HWindowWidth = CLng(MCWinSize / 2)
    'HWindowWidth = 51
    'First get critical difference and critical chivals
    Call GetCriticalDiff(0)
    If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
        MCWinSize = HWindowWidth * 2
    End If
    'Prepare arrays
    'I MUST MOD THESE FOR JUST 1 SEQ PAIR
    ReDim Scores(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)))
    
   

    
    Dim MaxX As Long, TWinScoresA As Long, TWinScoresB As Long, WinWin As Long
    Dim MaxY As Integer, Failcount As Integer
    Dim TMChi As Double, HMChi As Double
    Dim HiLeft As Double, HiRight As Double
    Dim pMaxX As Long
    Dim MChi As Double
    Seq3 = Seq1
    Dim XDiffPos2() As Long
    ReDim XDiffPos2(Len(StrainSeq(0)))
    If MCStripGapsFlag = 1 Then
        'This could be speeded up with better nesting
        Dummy = WinScoreCalc2(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffPos(0), SeqNum(0, 0), Winscores(0))
        'LenXOverSeq2 = LenXoverSeq
    Else
        'This could be speeded up with better nesting
        Dummy = WinScoreCalc3(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffPos(0), SeqNum(0, 0), Winscores(0), XDiffPos2(0))
        LenXoverSeq = Dummy
        For Z = 1 To LenXoverSeq
            XDiffPos(Z) = XDiffPos2(Z)
        Next Z
    End If
    
    'Dummy = WinScoreCalc2(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Scores(0), XDiffPos(0), SeqNum(0, 0), WinScores(0))
    'This could be speeded up with better nesting
    MChi = CalcChiVals2(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0), Chivals(0))

    MCMinChiP = ChiPVal(MChi)
    MCMinChiP = MCMinChiP * (LenXoverSeq / (HWindowWidth))
    If MCMinChiP > 0 Then
        MCMinChiP = -Log10(MCMinChiP)
    ElseIf MCMinChiP = 0 Then
        MCMinChiP = -Log10(0.000000001)
    End If

    If MCFlag = 0 Then
        If MCMinChiP < -Log10(LowestProb / MCCorrect) Then MCMinChiP = -Log10(LowestProb / MCCorrect)
    Else
        If MCMinChiP < -Log10(LowestProb) Then MCMinChiP = -Log10(LowestProb)
    End If
    
    Dim PntAPI As POINTAPI

    Pict = Form1.Picture7.hdc
    
    ReDim MCPrintPos(LenXoverSeq)
    ReDim MCPrintData(LenXoverSeq)
        
    For x = 0 To LenXoverSeq
        MCPrintPos(x) = XDiffPos(x)
    Next x
    
    ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    
    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MCMinChiP), 0, 0, "-Log[P(Chi2)]")
    
    Pict = Form1.Picture7.hdc
    If MCStripGapsFlag = 1 Then
        Dummy = DrawDiffs(Pict, Len(MCXoverSeq(0)), XFactor, MCXDiffPos(0))
    Else
        Dummy = DrawDiffs(Pict, Len(MCXoverSeq(0)), XFactor, XDiffPos2(0))
    End If
    PosCount = 0
    Form1.Picture7.DrawWidth = 3
    'Min = 10
    For Y = 1 To LenXoverSeq
        Chivals(Y) = ChiPVal(Chivals(Y)) * (LenXoverSeq / (HWindowWidth))
        If Chivals(Y) > 1 Then Chivals(Y) = 1
        'If ChiVals(Y) < Min Then Min = ChiVals(Y)
    Next Y
    MChi = MCMinChiP
    Pict = Form1.Picture7.hdc
    Form1.Picture7.ForeColor = RGB(180, 180, 180)
    Dummy = MoveToEx(Pict, 30 + Decompress((XDiffPos(1))) * XFactor, PicHeight - (15 + (-Log10(Chivals(1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
    MCPrintData(1) = Chivals(1)
    For x = 2 To LenXoverSeq - 1
        Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(x))) * XFactor, PicHeight - (15 + (-Log10(Chivals(x)) / MCMinChiP) * (PicHeight - 35)))
        MCPrintData(x) = Chivals(x)
    Next x
    
    

    PosCount = 0
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = 0
    Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + (-Log10(Chivals(1)) / MCMinChiP) * (PicHeight - 35)), PntAPI)
    For x = 2 To LenXoverSeq - 1
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(x))) * XFactor, PicHeight - (15 + (-Log10(Chivals(x)) / MCMinChiP) * (PicHeight - 35)))
    Next x
    
    'draw p-val cutoff
    Form1.Picture7.DrawStyle = 2

    If ExeCheckFlag = 1 Or MCFlag <> 0 Then
        MCMaxP = LowestProb
        Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    End If

    MCMaxP = LowestProb / MCCorrect
    
    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(MCMaxP) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.Line (25, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35)))-(Form1.Picture7.ScaleWidth - 5, PicHeight - (15 + (-Log10(LowestProb) / MCMinChiP) * (PicHeight - 35))), QBColor(0)
    Form1.Picture7.DrawStyle = 0
    Form1.ProgressBar1.Value = 95
    Call UpdateF2Prog
    'shade detected region
    Call UpdateF2Prog
    Call Highlight(0)
    'MCMaxP = LowestProb
    
    Dim TB As Long, TE As Long

    If XoverList(RelX, RelY).Beginning - 40 < 0 Then
        TB = XoverList(RelX, RelY).Beginning - 40 + Len(StrainSeq(0))
    Else
        TB = XoverList(RelX, RelY).Beginning - 40
    End If

    If XoverList(RelX, RelY).Ending + 20 > Len(StrainSeq(0)) Then
        TE = XoverList(RelX, RelY).Ending + 40 - Len(StrainSeq(0))
    Else
        TE = XoverList(RelX, RelY).Ending + 40
    End If

    Dim MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    
    If TE > TB Then

        For x = 0 To LenXoverSeq
            
            If XDiffPos(x) >= TB And XDiffPos(x) < TE Then

                    If Chivals(x) < MinPA2 And Abs(TE - XDiffPos(x)) < Abs(TB - XDiffPos(x)) Then
                        MinPA2 = Chivals(x)
                        XP2 = XDiffPos(x)
                    ElseIf Chivals(x) < MinPA And Abs(TE - XDiffPos(x)) > Abs(TB - XDiffPos(x)) Then
                        MinPA = Chivals(x)
                        XP1 = XDiffPos(x)
                    End If

            End If

        Next 'X

    Else

        For x = 0 To LenXoverSeq

            If XDiffPos(x) >= TB Or XDiffPos(x) <= TE Then

                    If XDiffPos(x) < TE Then

                        If Chivals(x) < MinPA2 And Abs(TE - XDiffPos(x)) < Abs(XDiffPos(x) + (Len(StrainSeq(0)) - TB)) Then
                            MinPA2 = Chivals(x)
                            XP2 = XDiffPos(x)
                        ElseIf ChiPVal(Chivals(x)) < MinPA And Abs(TE - XDiffPos(x)) > Abs(XDiffPos(x) + (Len(StrainSeq(0)) - TB)) Then
                            MinPA = Chivals(x)
                            XP1 = XDiffPos(x)
                        End If

                    Else

                        If Chivals(x) < MinPA2 And TE + (Len(StrainSeq(0)) - XDiffPos(x)) < Abs(XDiffPos(x) - TB) Then
                            MinPA2 = Chivals(x)
                            XP2 = XDiffPos(x)
                        ElseIf Chivals(x) < MinPA And TE + (Len(StrainSeq(0)) - XDiffPos(x)) > Abs(XDiffPos(x) - TB) Then
                            MinPA = Chivals(x)
                            XP1 = XDiffPos(x)
                        End If

                    End If

            End If

        Next 'X

    End If

    'Dim ProbTest As String
    ProbY = 1

    Dim POrder() As Double

    ReDim POrder(3)

    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrect
        MinPA2 = MinPA2 * MCCorrect
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(3, MinPA)
        MinPA2 = StepDown2(3, MinPA2)
    End If
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    pt1 = -Log10(MinPA)
    pt2 = -Log10(MinPA2)
    If x = x Or (XoverList(RelX, RelY).ProgramFlag <> 3 And XoverList(RelX, RelY).ProgramFlag <> 3 + AddNum) Or ExeCheckFlag = 1 Then
        ProbTest$ = MinPA

        If (Confirm(EN, 3) = 0 Or (Confirm(EN, 3) = 1 And (pt2 > ConfirmP(EN, 3) Or pt1 > ConfirmP(EN, 3)))) And (MinPA2 < 1 Or MinPA < 1) Then
            Confirm(EN, 3) = 1
            If (MinPA < MinPA2 And MinPA > 0) Or MinPA2 = 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA)
            ElseIf MinPA2 > 0 Then
                ConfirmP(EN, 3) = -Log10(MinPA2)
            End If
            

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            Form1.Refresh
            If DebuggingFlag < 2 Then
                Form1.WindowState = Form1.WindowState
            End If
        End If

        If MinPA <= MinPA2 Then
            POrder(0) = MinPA
            POrder(1) = MinPA2
            POrder(2) = XP1
            POrder(3) = XP2
        Else
            POrder(0) = MinPA2
            POrder(1) = MinPA
            POrder(2) = XP2
            POrder(3) = XP1
        End If

'    Else
'        'POrder(0) = 0
'        If XoverList(RelX, RelY).BeginP < XoverList(RelX, RelY).EndP Then
'
'            If XoverList(RelX, RelY).SBPFlag <> 1 Then
'                POrder(0) = XoverList(RelX, RelY).BeginP
'                POrder(2) = XoverList(RelX, RelY).Beginning
'            Else
'                POrder(0) = 0
'            End If
'
'            If XoverList(RelX, RelY).SBPFlag <> 2 Then
'                POrder(1) = XoverList(RelX, RelY).EndP
'                POrder(3) = XoverList(RelX, RelY).Ending
'            Else
'                POrder(1) = 0
'            End If
'
'        Else
'
'            If XoverList(RelX, RelY).SBPFlag <> 1 Then
'                POrder(1) = XoverList(RelX, RelY).BeginP
'                POrder(3) = XoverList(RelX, RelY).Beginning
'            Else
'                POrder(1) = 0
'            End If
'
'            If XoverList(RelX, RelY).SBPFlag <> 2 Then
'                POrder(0) = XoverList(RelX, RelY).EndP
'                POrder(2) = XoverList(RelX, RelY).Ending
'            Else
'                POrder(0) = 0
'            End If
'
'        End If

    End If

    For A = 0 To 1
        ProbX = Decompress(POrder(A + 2))

        If POrder(A) > 0 And (POrder(A) < 1) Then
            ProbTest = POrder(A)

            If SPF = 0 Then
                Call PrintProbability
                If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                    If POrder(0) < POrder(1) Then
                        XoverList(RelX, RelY).Probability = POrder(0)
                    Else
                        XoverList(RelX, RelY).Probability = POrder(1)
                    End If
                End If
            End If
            If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                BestParent = CheckParent: WinMethod = 3
                BestParentP = MinPA
            End If
            If MinPA2 < BestParentP And MinPA2 < LowestProb And MinPA2 > 0 Then
                BestParent = CheckParent: WinMethod = 3
                BestParentP = MinPA2
            End If
        End If

    Next 'A
    MCWinSize = oMCWinSize
    MCWinFract = oMCWinfract
    
    

    Form1.ProgressBar1.Value = 100
    Form1.Picture7.Refresh
    Form1.Picture10.Refresh
    Counter = Counter + 1
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Form1.SSPanel8.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Call UpdateF2Prog

End Sub


Public Sub PXover()



Dim PT As Long, PPWinLen As Long, PPStripGaps As Long, IncSelf As Byte, PPPerms As Long
Dim Length As Long
PT = Abs(GetTickCount)
'Nextno = 5
PPWinLen = 80
PPStripGaps = 0
IncSelf = 0



    NumberOfSeqs = 1
    ReDim TempSeq(NextNo + 1) As String
    ReDim RevSeq(NextNo + 1)
    For x = 0 To NextNo

        If Selected(x) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(x)
            RevSeq(NumberOfSeqs) = x
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X

    NumberOfSeqs = NumberOfSeqs - 1
    
    


ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
Y = 0
If PPStripGaps = 0 Then
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        If Identical(x) = 0 Then
            Y = Y + 1
            XPosDiff(x) = Y
            XDiffPos(Y) = x
        End If
    Next x
Else
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        If Identical(x) = 0 Then
            GoOn = 1
            For Z = 0 To NextNo
                If SeqNum(x, Z) = 46 Then
                    GoOn = 0
                    Exit For
                End If
            Next Z
            If GoOn = 1 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
            End If
        End If
    Next x
End If
Dim WinLen


Dim PDstMat() As Long
ReDim PDstMat(NextNo, NextNo, 1)

LenXoverSeq = Y
WinLen = CInt(PPWinLen / 2)
If WinLen > LenXoverSeq / 2 Then WinLen = CInt(LenXoverSeq / 2)
'Exit Sub
Dim WinScore() As Double
ReDim WinScore(LenXoverSeq, NextNo)
'Do matrix for the first half of first window

For x = 0 To NextNo
    For Y = x + 1 To NextNo
            
            For Z = LenXoverSeq - WinLen + 1 To LenXoverSeq
               
                If SeqNum(XDiffPos(Z), x) <> SeqNum(XDiffPos(Z), Y) And SeqNum(XDiffPos(Z), x) <> 46 And SeqNum(XDiffPos(Z), Y) <> 46 Then
                    PDstMat(x, Y, 0) = PDstMat(x, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, x, 0) = PDstMat(x, Y, 0)
    Next Y
Next x

'Do matrix for the second half of first window
For x = 0 To NextNo
    For Y = x + 1 To NextNo
            
            For Z = 1 To WinLen
                If SeqNum(XDiffPos(Z), x) <> SeqNum(XDiffPos(Z), Y) And SeqNum(XDiffPos(Z), x) <> 46 And SeqNum(XDiffPos(Z), Y) <> 46 Then
                    PDstMat(x, Y, 1) = PDstMat(x, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, x, 1) = PDstMat(x, Y, 1)
    Next Y
Next x
Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'If x = 12345 Then
'    Nextno = 8
'    PDstMat(0, 1, 0) = 0
'    PDstMat(0, 2, 0) = 78
'    PDstMat(0, 3, 0) = 148
'    PDstMat(0, 4, 0) = 147
'    PDstMat(0, 5, 0) = 170
'    PDstMat(0, 6, 0) = 178
'    PDstMat(0, 7, 0) = 182
'    PDstMat(0, 8, 0) = 163
'
'    PDstMat(0, 1, 1) = 193
'    PDstMat(0, 2, 1) = 85 '200
'    PDstMat(0, 3, 1) = 143 '199
'    PDstMat(0, 4, 1) = 153 '198
'    PDstMat(0, 5, 1) = 192 '84
'    PDstMat(0, 6, 1) = 193 '0
'    PDstMat(0, 7, 1) = 203 '145
'    PDstMat(0, 8, 1) = 187 '139
'    SumX = 0
'    SumY = 0
'    SumXY = 0
'    SumX2 = 0
'    SumY2 = 0
'    For Y = 1 To Nextno
'
'            SumX = SumX + PDstMat(0, Y, 0)
'            SumY = SumY + PDstMat(0, Y, 1)
'            SumXY = SumXY + (PDstMat(0, Y, 0) * PDstMat(0, Y, 1))
'            SumX2 = SumX2 + PDstMat(0, Y, 0) * PDstMat(0, Y, 0)
'            SumY2 = SumY2 + PDstMat(0, Y, 1) * PDstMat(0, Y, 1)
'
'    Next Y
'    'Nextno = 9
'
'        WinScore(1, 0) = ((Nextno * SumXY) - (SumX * SumY)) / _
'        (Sqr(Nextno * SumX2 - SumX * SumX) * Sqr(Nextno * SumY2 - SumY * SumY))
'        x = x
'        Exit Sub
'End If
'calc Correlation coefficient and put into winscore as the first window pos
For x = 0 To NextNo
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NextNo
        If A <> Y Or IncSelf = 1 Then
            SumX = SumX + PDstMat(A, Y, 0)
            SumY = SumY + PDstMat(A, Y, 1)
            SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
            SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
            SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
            
        End If
    Next Y
    If IncSelf = 1 Then
        NextNo = NextNo + 1
    End If
    If SumX2 > 0 And SumY2 > 0 Then
        WinScore(x, A) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
        'Exit Sub
    Else
        WinScore(x, A) = 1
    End If
    If IncSelf = 1 Then
        NextNo = NextNo - 1
    End If
   
Next x



Dim Begin1 As Long, End2 As Long

For x = 2 To LenXoverSeq
    End2 = x + WinLen - 1
    Begin1 = x - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXoverSeq + Begin1
    If End2 > LenXoverSeq Then End2 = End2 - LenXoverSeq
    For Z = 0 To NextNo
        For Y = Z + 1 To NextNo
            If SeqNum(XDiffPos(Begin1), Y) <> 46 And SeqNum(XDiffPos(Begin1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffPos(Begin1), Y) <> SeqNum(XDiffPos(Begin1), Z))
            End If
            If SeqNum(XDiffPos(x - 1), Y) <> 46 And SeqNum(XDiffPos(x - 1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffPos(x - 1), Y) <> SeqNum(XDiffPos(x - 1), Z))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffPos(x - 1), Y) <> SeqNum(XDiffPos(x - 1), Z))
            End If
            
            If SeqNum(XDiffPos(End2), Y) <> 46 And SeqNum(XDiffPos(End2), Z) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffPos(End2), Y) <> SeqNum(XDiffPos(End2), Z))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
        For A = 0 To NextNo
           SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NextNo
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            If IncSelf = 1 Then
                NextNo = NextNo + 1
            End If
            If SumX2 > 0 And SumY2 > 0 Then
                WinScore(x, A) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                'Exit Sub
            Else
                WinScore(x, A) = 1
            End If
            If IncSelf = 1 Then
                NextNo = NextNo - 1
            End If
        Next A
    
Next x


           ' For X = 0 To MCPerms
           '     'Make Randomised version of scores
           '     For Z = 1 To LenR * 2
           '         Curnt = LO + Z - 1
           '         If Curnt > LenXoverSeq Then Curnt = Curnt - LenXoverSeq
           '         MCPScore(Z) = Scores(Curnt, MaxY)
            '    Next Z
          '      For Z = 1 To LenR * 2
          '          Randum = CLng(((LenR * 2 - 1) * Rnd) + 1)
          '          If Randum > LenXoverSeq Then Randum = Randum - LenXoverSeq
          '          Tempnt = MCPScore(Z)
          '          MCPScore(Z) = MCPScore(Randum)
          '          MCPScore(Randum) = Tempnt
          '      Next Z
          
          
          
          
          
Dim MaxRVal As Double, MinRVal As Double
MinRVal = 1000
MaxRVal = -1000
For x = 0 To NextNo
    For Y = 1 To LenXoverSeq
        If WinScore(Y, x) > MaxRVal Then
            MaxRVal = WinScore(Y, x)
        ElseIf WinScore(Y, x) < MinRVal Then
            MinRVal = WinScore(Y, x)
        End If
    Next Y
Next x
If x = 12345 Then
    
    Dim PntAPI As POINTAPI, Pict As Long
    DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxRVal), CSng(MinRVal), 0, "Correlation coefficient"
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For x = 6 To LenXoverSeq
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(x))) * XFactor, PicHeight - (15 + ((WinScore(x, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next x
    Next Y
    Form1.Picture7.DrawWidth = 1
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For x = 6 To LenXoverSeq
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(x))) * XFactor, PicHeight - (15 + ((WinScore(x, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next x
    Next Y
Else
    'Get everything into the standard format for printing and saving
    NumLines = NumberOfSeqs 'number of lines to print
    ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
    
    ReDim GVarPos(0, LenXoverSeq)
    For x = 1 To LenXoverSeq
        GVarPos(0, x) = XDiffPos(x)
    Next x
        
    ReDim GCritval(10)
    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        
        'MCMaxP = LowestProb / NumberOfSeqs
    GCritval(0) = 0.5 '-Log10(MCMaxP)
    
    GCritval(1) = 0.75 '-Log10(LowestProb)
    GLegend = "Correlation coefficient"
    GPrintLen = LenXoverSeq + 1 'how many points to plot
    For x = 0 To NumberOfSeqs - 1
        GPrintCol(x) = SeqCol(RevSeq(x + 1))
    Next x
    GPrintNum = NumLines - 1 'six lines
    GPrintType = 0 'a normal line plot
        
    GPrintMin(0) = MinRVal 'bottom val
    GPrintMin(1) = MaxRVal 'upper val
    GBlockNum = -1
'        ReDim GBlock(4, 0)
'        GBlock(1, 0) = 3 'this is not actually a block - it is the legend saying which sequence is the query sequence
    For x = 1 To LenXoverSeq - 1
        For Y = 0 To NumLines - 1
            GPrint(Y, x) = ((WinScore(x, Y) - MinRVal) / (MaxRVal - MinRVal))
            GPrintPos(Y, x) = XDiffPos(x)
        Next Y
    Next x
    
    For Y = 0 To NumLines - 1
        GPrint(Y, LenXoverSeq) = ((WinScore(LenXoverSeq, Y) - MinRVal) / (MaxRVal - MinRVal))
        
    Next Y
    For x = 0 To NumLines - 1
        GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
        GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        GPrintPos(x, GPrintLen - 1) = XDiffPos(LenXoverSeq)
        GPrintPos(x, 0) = 1
        GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
    Next x
    
    
    GExtraTNum = NumLines - 1
    ReDim GExtraText(GExtraTNum)
    
    For x = 1 To NumLines
        GExtraText(x - 1) = OriginalName(RevSeq(x))
        
    Next x
'    Form1.Picture10.Enabled = True
'    Form1.Picture7.Enabled = True
'    Form1.Picture10.AutoRedraw = True
'    Form1.Picture7.AutoRedraw = True
    ManFlag = 10
    Call RedrawPlotAA(1)
'    Form1.Picture7.Refresh
'    Form1.Picture10.Refresh
End If
End Sub
Public Sub PXoverB()



Dim PPCorrect As Long, PLimit As Long, PPCO As Double, PPWinLen As Long, PPStripGaps As Long, IncSelf As Byte, PPPerms As Long, PPSeed As Long
Dim Length As Long

'Nextno = 5
PPWinLen = 170
PPStripGaps = 1
IncSelf = 0
PPSeed = 3
PPPerms = 1000
PPCO = 0.05


ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
Y = 0
If PPStripGaps = 0 Then
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        If Identical(x) = 0 Then
            Y = Y + 1
            XPosDiff(x) = Y
            XDiffPos(Y) = x
        End If
    Next x
Else
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        If Identical(x) = 0 Then
            GoOn = 1
            For Z = 0 To NextNo
                If SeqNum(x, Z) = 46 Then
                    GoOn = 0
                    Exit For
                End If
            Next Z
            If GoOn = 1 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
            End If
        End If
    Next x
End If
Dim WinLen


Dim PDstMat() As Long
ReDim PDstMat(NextNo, NextNo, 1)

LenXoverSeq = Y
WinLen = CInt(PPWinLen / 2)
If WinLen > LenXoverSeq / 2 Then WinLen = CInt(LenXoverSeq / 2)

PPCorrect = (NextNo + 1) * (LenXoverSeq) / PPWinLen
PLimit = PPPerms * (PPCO / PPCorrect) + 1
PLimit = PPPerms
Dim WinScore() As Double
ReDim WinScore(LenXoverSeq, NextNo)

'Make RndTemplate
Dim RndTemplate() As Long
ReDim RndTemplate(PPWinLen, PPPerms)
For Y = 1 To PPPerms
    For x = 1 To WinLen * 2
        RndTemplate(x, Y) = x
    Next x
Next Y
Dim Randum As Long, Tempnt As Long
Rnd (-BSRndNumSeed)
For Y = 1 To PPPerms
    For x = 1 To WinLen * 2
        Randum = CLng(((PPWinLen - 1) * Rnd) + 1)
        
        Tempnt = RndTemplate(x, Y)
        RndTemplate(x, Y) = RndTemplate(Randum, Y)
        RndTemplate(Randum, Y) = Tempnt
    Next x
Next Y
Dim SwapSites() As Long, NumSwaps() As Long
ReDim SwapSites(PPPerms, WinLen, 1)
ReDim NumSwaps(PPPerms)
For Y = 1 To PPPerms
    NumSwaps(Y) = 0
    For x = 1 To WinLen
        If RndTemplate(x, Y) > WinLen Then
            NumSwaps(Y) = NumSwaps(Y) + 1
            SwapSites(Y, NumSwaps(Y), 0) = RndTemplate(x, Y) - WinLen
        End If
    Next x
    NumSwaps(Y) = 0
    For x = WinLen + 1 To WinLen * 2
        If RndTemplate(x, Y) < WinLen + 1 Then
            NumSwaps(Y) = NumSwaps(Y) + 1
            SwapSites(Y, NumSwaps(Y), 1) = RndTemplate(x, Y) - WinLen
        End If
    Next x
    x = x
Next Y
'Exit Sub
For x = 0 To NextNo
    For Y = x + 1 To NextNo
            For Z = (LenXoverSeq - WinLen + 1) To LenXoverSeq
                If SeqNum(XDiffPos(Z), x) <> SeqNum(XDiffPos(Z), Y) And SeqNum(XDiffPos(Z), x) <> 46 And SeqNum(XDiffPos(Z), Y) <> 46 Then
                    PDstMat(x, Y, 0) = PDstMat(x, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, x, 0) = PDstMat(x, Y, 0)
    Next Y
Next x

'Do matrix for the second half of first window
For x = 0 To NextNo
    For Y = x + 1 To NextNo
            
            For Z = 1 To WinLen
                If SeqNum(XDiffPos(Z), x) <> SeqNum(XDiffPos(Z), Y) And SeqNum(XDiffPos(Z), x) <> 46 And SeqNum(XDiffPos(Z), Y) <> 46 Then
                    PDstMat(x, Y, 1) = PDstMat(x, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, x, 1) = PDstMat(x, Y, 1)
    Next Y
Next x

Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc Correlation coefficient and put into winscore as the first window pos
For x = 0 To NextNo
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NextNo
                If x <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(x, Y, 0)
                    SumY = SumY + PDstMat(x, Y, 1)
                    SumXY = SumXY + PDstMat(x, Y, 0) * PDstMat(x, Y, 1)
                    SumX2 = SumX2 + PDstMat(x, Y, 0) * PDstMat(x, Y, 0)
                    SumY2 = SumY2 + PDstMat(x, Y, 1) * PDstMat(x, Y, 1)
                    
                End If
    Next Y
    If IncSelf = 1 Then
        NextNo = NextNo + 1
    End If
    If SumX2 > 0 And SumY2 > 0 Then
        WinScore(1, x) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
    Else
        WinScore(x, 1) = 1
    End If
    If IncSelf = 1 Then
        NextNo = NextNo - 1
    End If
Next x

'do perms for first two windows
Dim tPDstMat() As Long, S1 As Byte, s2 As Byte, Offset As Long, Pos As Long, PermScore As Double, OC() As Long
Offset = 1
ReDim OC(NextNo)
If x = 12345 Then
    For b = 1 To PPPerms
            
        ReDim tPDstMat(NextNo, NextNo, 1)
        
        For x = 0 To NextNo
            If OC(x) < PLimit Then
                For Y = x + 1 To NextNo
                
                    tPDstMat(x, Y, 1) = PDstMat(x, Y, 1)
                    tPDstMat(x, Y, 0) = PDstMat(x, Y, 0)
                    For Z = 1 To NumSwaps(b)
                        If SwapSites(b, Z, 0) = 0 Then Exit For
                        Pos = SwapSites(b, Z, 0) + Offset
                        If Pos > LenXoverSeq Then Pos = Pos - LenXoverSeq
                        'first win
                        S1 = SeqNum(XDiffPos(Pos), Y)
                        s2 = SeqNum(XDiffPos(Pos), x)
                        
                        If S1 <> s2 Then
                            If S1 <> 46 And s2 <> 46 Then
                                tPDstMat(x, Y, 1) = tPDstMat(x, Y, 1) - 1
                                tPDstMat(x, Y, 0) = tPDstMat(x, Y, 0) + 1
                                
                            End If
                        End If
                        'second win
                        Pos = SwapSites(b, Z, 1) + Offset
                        
                        If Pos < 1 Then Pos = Pos + LenXoverSeq
                        S1 = SeqNum(XDiffPos(Pos), Y)
                        s2 = SeqNum(XDiffPos(Pos), x)
                        
                        If S1 <> s2 Then
                            If S1 <> 46 And s2 <> 46 Then
                                tPDstMat(x, Y, 1) = tPDstMat(x, Y, 1) + 1
                                tPDstMat(x, Y, 0) = tPDstMat(x, Y, 0) - 1
                                
                            End If
                        End If
                    Next Z
               
                    tPDstMat(Y, x, 1) = tPDstMat(x, Y, 1)
                    tPDstMat(Y, x, 0) = tPDstMat(x, Y, 0)
                 
                Next Y
            End If
        Next x
        For x = 0 To NextNo
            If OC(x) < PLimit Then
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                    For Y = 0 To NextNo
                        If x <> Y Or IncSelf = 1 Then
                            
                            SumX = SumX + tPDstMat(x, Y, 0)
                            SumY = SumY + tPDstMat(x, Y, 1)
                            SumXY = SumXY + tPDstMat(x, Y, 0) * tPDstMat(x, Y, 1)
                            SumX2 = SumX2 + tPDstMat(x, Y, 0) * tPDstMat(x, Y, 0)
                            SumY2 = SumY2 + tPDstMat(x, Y, 1) * tPDstMat(x, Y, 1)
                            
                        End If
                    Next Y
                    If IncSelf = 1 Then
                        NextNo = NextNo + 1
                    End If
                    If SumX2 > 0 And SumY2 > 0 Then
                        PermScore = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                        'Exit Sub
                    Else
                        WinScore(x, A) = 1
                    End If
                    If IncSelf = 1 Then
                        NextNo = NextNo - 1
                    End If
                    If PermScore < WinScore(1, x) Then OC(x) = OC(x) + 1
                End If
        Next x
    Next b
End If
Dim OutString() As String, TempString As String
ReDim OutString(NextNo)
Dim Begin1 As Long, End2 As Long
Open "test.csv" For Output As #1
For x = 2 To LenXoverSeq
    
    Offset = x
    End2 = x + WinLen - 1
    Begin1 = x - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXoverSeq + Begin1
    If End2 > LenXoverSeq Then End2 = End2 - LenXoverSeq
    For Z = 0 To NextNo
        
        For Y = Z + 1 To NextNo
            If SeqNum(XDiffPos(Begin1), Y) <> 46 And SeqNum(XDiffPos(Begin1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffPos(Begin1), Y) <> SeqNum(XDiffPos(Begin1), Z))
            End If
            If SeqNum(XDiffPos(x - 1), Y) <> 46 And SeqNum(XDiffPos(x - 1), Z) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffPos(x - 1), Y) <> SeqNum(XDiffPos(x - 1), Z))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffPos(x - 1), Y) <> SeqNum(XDiffPos(x - 1), Z))
            End If
            
            If SeqNum(XDiffPos(End2), Y) <> 46 And SeqNum(XDiffPos(End2), Z) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffPos(End2), Y) <> SeqNum(XDiffPos(End2), Z))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
    For A = 0 To NextNo
        OutString(A) = ""
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NextNo
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            
            If IncSelf = 1 Then
                NextNo = NextNo + 1
            End If
            If SumX2 > 0 And SumY2 > 0 Then
                WinScore(x, A) = ((NextNo * SumXY) - (SumX * SumY)) / (Sqr(NextNo * SumX2 - SumX * SumX) * Sqr(NextNo * SumY2 - SumY * SumY))
                'Exit Sub
            Else
                WinScore(x, A) = 1
            End If
            If IncSelf = 1 Then
                NextNo = NextNo - 1
            End If
            OutString(A) = OutString(A) + Str(WinScore(x, A))
    Next A
    ReDim OC(NextNo)
    If ((x - 1) / 5) = Int((x - 1) / 5) Then
        For b = 1 To PPPerms
            
            ReDim tPDstMat(NextNo, NextNo, 1)
            
            
            For A = 0 To NextNo
                If OC(A) < PLimit Then
                    For Y = A + 1 To NextNo
                        tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                        tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                        For Z = 1 To NumSwaps(b)
                            If SwapSites(b, Z, 0) = 0 Then Exit For
                            Pos = SwapSites(b, Z, 0) + Offset
                            
                            If Pos > LenXoverSeq Then Pos = Pos - LenXoverSeq
                            'first win
                            S1 = SeqNum(XDiffPos(Pos), Y)
                            s2 = SeqNum(XDiffPos(Pos), A)
                            
                            If S1 <> s2 Then
                                If S1 <> 46 And s2 <> 46 Then
                                    tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) - 1
                                    tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) + 1
                                    
                                End If
                            End If
                            'second win
                            Pos = SwapSites(b, Z, 1) + Offset
                            
                            
                            
                            If Pos < 1 Then Pos = Pos + LenXoverSeq
                            S1 = SeqNum(XDiffPos(Pos), Y)
                            s2 = SeqNum(XDiffPos(Pos), A)
                            
                            If S1 <> s2 Then
                                If S1 <> 46 And s2 <> 46 Then
                                    tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) + 1
                                    tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) - 1
                                    
                                End If
                            End If
                        Next Z
                        tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                        tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                    Next Y
                End If
            Next A
            For A = 0 To NextNo
                If OC(A) < PLimit Then
                    SumA = 0
                    SumY = 0
                    SumAY = 0
                    SumA2 = 0
                    SumY2 = 0
                            For Y = 0 To NextNo
                                If A <> Y Or IncSelf = 1 Then
                                    
                                    SumA = SumA + tPDstMat(A, Y, 0)
                                    SumY = SumY + tPDstMat(A, Y, 1)
                                    SumAY = SumAY + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 1)
                                    SumA2 = SumA2 + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 0)
                                    SumY2 = SumY2 + tPDstMat(A, Y, 1) * tPDstMat(A, Y, 1)
                                    
                                End If
                            Next Y
                            If IncSelf = 1 Then
                                NextNo = NextNo + 1
                            End If
                            If SumA2 > 0 And SumY2 > 0 Then
                                PermScore = ((NextNo * SumAY) - (SumA * SumY)) / (Sqr(NextNo * SumA2 - SumA * SumA) * Sqr(NextNo * SumY2 - SumY * SumY))
                            Else
                                WinScore(A, A) = 1
                            End If
                            If IncSelf = 1 Then
                                NextNo = NextNo - 1
                            End If
                            If PermScore < WinScore(x, A) Then OC(A) = OC(A) + 1
                End If
            Next A
        Next b
        
        For A = 0 To NextNo
            OutString(A) = "," + OutString(A) + "," + Str((OC(A) / PPPerms))
        Next A
        TempString = Str(XDiffPos(x)) & ","
        For A = 0 To NextNo
            TempString = TempString + OutString(A)
        Next A
        Form1.SSPanel1.Caption = Str(x) & " of " & Str(LenXoverSeq) & " windows examined"
        Form1.ProgressBar1.Value = x / LenXoverSeq * 100
        Call UpdateF2Prog
        Print #1, TempString
    End If
Next x

Close #1
           

If x = x Then
    Dim MaxRVal As Double, MinRVal As Double
    MinRVal = 1000
    MaxRVal = -1000
    For x = 0 To NextNo
        For Y = 1 To LenXoverSeq
            If WinScore(Y, x) > MaxRVal Then
                MaxRVal = WinScore(Y, x)
            ElseIf WinScore(Y, x) < MinRVal Then
                MinRVal = WinScore(Y, x)
            End If
        Next Y
    Next x
    Dim PntAPI As POINTAPI, Pict As Long
    DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxRVal), CSng(MinRVal), 0, "Correlation coefficient"
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For x = 6 To LenXoverSeq
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(x))) * XFactor, PicHeight - (15 + ((WinScore(x, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next x
    Next Y
    Form1.Picture7.DrawWidth = 1
    Pict = Form1.Picture7.hdc
    
    For Y = 0 To NextNo
        Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((WinScore(1, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)), PntAPI)
        
        For x = 6 To LenXoverSeq
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(x))) * XFactor, PicHeight - (15 + ((WinScore(x, Y) - MinRVal) / (MaxRVal - MinRVal)) * (PicHeight - 35)))
            
        Next x
    Next Y
End If
End Sub
Public Sub PXoverF()

Dim PCategory() As Double, SumA As Long, SumA2 As Long, SumAY As Long, PPPermsX As Long, PScore() As Double, NS As Long, PT As Long, Cutoff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long
PT = Abs(GetTickCount)




Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"
Call UpdateF2Prog
'Get variable sites
Call FindSubSeqPP
ReDim LRank(NumberOfSeqs), RRank(NumberOfSeqs)
If IncSelf = 0 Then
    NS = NumberOfSeqs
Else
    NS = NumberOfSeqs + 1
End If
PPCO = 0.05
If MCFlag = 0 Then
    Cutoff = (LowestProb / NumberOfSeqs) * PPPerms
Else
    Cutoff = (LowestProb) * PPPerms
End If

If Cutoff = 0 Then Cutoff = 1


Dim WinLen As Long, PDstMat() As Long

ReDim PDstMat(NumberOfSeqs, NumberOfSeqs, 1)

WinLen = CInt(PPWinLen / 2)
If WinLen > LenXoverSeq / 2 Then WinLen = CInt(LenXoverSeq / 2)

If MCFlag = 0 Then
    PPCorrect = (NumberOfSeqs + 1) * (LenXoverSeq / PPWinLen)
Else
    PPCorrect = LenXoverSeq / PPWinLen / 2
End If

PLimit = PPPerms * (PPCO / PPCorrect)

If PLimit = 0 Then
    PLimit = 5
    PPPermsX = (1 / (PPCO / PPCorrect)) * 5
Else
    PPPermsX = PPPerms
End If

ReDim PPWinScore(LenXoverSeq, NumberOfSeqs)
ReDim PScore(LenXoverSeq, NumberOfSeqs)

'Make RndTemplate
If x = x Then
    Dim RndTemplate() As Long
    ReDim RndTemplate(PPWinLen, PPPermsX)
    For Y = 1 To PPPermsX
        For x = 1 To WinLen * 2
            RndTemplate(x, Y) = x
        Next x
    Next Y
End If
Dim Randum As Long, Tempnt As Long
Rnd (-BSRndNumSeed)
If x = x Then
    For Y = 1 To PPPermsX
        For x = 1 To WinLen * 2
            Randum = CLng(((PPWinLen - 1) * Rnd) + 1)
            If Randum = 0 Or Randum > WinLen * 2 Then
                x = x
            End If
            Tempnt = RndTemplate(x, Y)
            RndTemplate(x, Y) = RndTemplate(Randum, Y)
            RndTemplate(Randum, Y) = Tempnt
            
            
        Next x
        x = x
    Next Y
End If

'Work out which and how many sites are swapped between halves of windows
Dim SwapSites() As Long, NumSwaps() As Long
ReDim SwapSites(PPPermsX, WinLen, 1)
ReDim NumSwaps(PPPermsX)
Dim DiffRecord() As Long
ReDim DiffRecord(NumberOfSeqs)
If x = x Then
    For Y = 1 To PPPermsX
        NumSwaps(Y) = 0
        For x = 1 To WinLen
            If RndTemplate(x, Y) > WinLen Then
                NumSwaps(Y) = NumSwaps(Y) + 1
                SwapSites(Y, NumSwaps(Y), 0) = RndTemplate(x, Y) - WinLen
            End If
        Next x
        NumSwaps(Y) = 0
        For x = WinLen + 1 To WinLen * 2
            If RndTemplate(x, Y) <= WinLen Then
                NumSwaps(Y) = NumSwaps(Y) + 1
                SwapSites(Y, NumSwaps(Y), 1) = RndTemplate(x, Y) - WinLen
            End If
        Next x
        x = x
    Next Y
End If
'Do matrix for the first half of first window
For x = 0 To NumberOfSeqs
    For Y = x + 1 To NumberOfSeqs
            For Z = (LenXoverSeq - WinLen + 1) To LenXoverSeq
                If SeqNum(XDiffPos(Z), RevSeq(x)) <> SeqNum(XDiffPos(Z), RevSeq(Y)) And SeqNum(XDiffPos(Z), RevSeq(x)) <> 46 And SeqNum(XDiffPos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(x, Y, 0) = PDstMat(x, Y, 0) + 1
                End If
                
            Next Z
            PDstMat(Y, x, 0) = PDstMat(x, Y, 0)
    Next Y
Next x

'Do matrix for the second half of first window
For x = 0 To NumberOfSeqs
    For Y = x + 1 To NumberOfSeqs
            
            For Z = 1 To WinLen
                If SeqNum(XDiffPos(Z), RevSeq(x)) <> SeqNum(XDiffPos(Z), RevSeq(Y)) And SeqNum(XDiffPos(Z), RevSeq(x)) <> 46 And SeqNum(XDiffPos(Z), RevSeq(Y)) <> 46 Then
                    PDstMat(x, Y, 1) = PDstMat(x, Y, 1) + 1
                End If
                
            Next Z
            PDstMat(Y, x, 1) = PDstMat(x, Y, 1)
    Next Y
Next x

Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc Correlation coefficient and put into ppwinscore as the first window pos
For x = 0 To NumberOfSeqs
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NumberOfSeqs
                If x <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(x, Y, 0)
                    SumY = SumY + PDstMat(x, Y, 1)
                    SumXY = SumXY + PDstMat(x, Y, 0) * PDstMat(x, Y, 1)
                    SumX2 = SumX2 + PDstMat(x, Y, 0) * PDstMat(x, Y, 0)
                    SumY2 = SumY2 + PDstMat(x, Y, 1) * PDstMat(x, Y, 1)
                End If
    Next Y
    
    If SumX2 > 0 And SumY2 > 0 Then
        PPWinScore(1, x) = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
        PPWinScore(1, x) = PPWinScore(1, x) + (10 ^ -14)
        x = x
    Else
        PPWinScore(1, x) = 1
    End If
    DiffRecord(x) = SumX + SumY
Next x
Dim MDiff As Long
MDiff = 0
For x = 0 To NumberOfSeqs
    If DiffRecord(x) > MDiff Then MDiff = DiffRecord(x)
    
Next x
ReDim PCategory(NumberOfSeqs, MDiff)
'For X = 0 To NumberOfSeqs
'    PCategory(X, DiffRecord(X)) = PPWinScore(1, X)
'Next X
'do perms for first two windows
Dim tPDstMat() As Long, S1 As Byte, s2 As Byte, Offset As Long, Pos As Long, PermScore As Double, OC() As Long
Offset = 1
ReDim OC(NumberOfSeqs)
SS = Abs(GetTickCount)
If x = x Then
    For b = 1 To PPPermsX
            
        ReDim tPDstMat(NumberOfSeqs, NumberOfSeqs, 1)
        
        For x = 0 To NumberOfSeqs
            'If OC(X) < PLimit Then
                For Y = x + 1 To NumberOfSeqs
                    If OC(x) < PLimit Or OC(Y) < PLimit Then
                        tPDstMat(x, Y, 1) = PDstMat(x, Y, 1)
                        tPDstMat(x, Y, 0) = PDstMat(x, Y, 0)
                        tPDstMat(Y, x, 1) = tPDstMat(x, Y, 1)
                        tPDstMat(Y, x, 0) = tPDstMat(x, Y, 0)
                        For Z = 1 To NumSwaps(b)
                            If SwapSites(b, Z, 0) = 0 Then Exit For
                            Pos = SwapSites(b, Z, 0) + Offset - 1
                            If Pos > LenXoverSeq Then Pos = Pos - LenXoverSeq
                            'first win
                            S1 = SeqNum(XDiffPos(Pos), RevSeq(Y))
                            s2 = SeqNum(XDiffPos(Pos), RevSeq(x))
                            
                            If S1 <> s2 Then
                                If S1 <> 46 And s2 <> 46 Then
                                    tPDstMat(x, Y, 1) = tPDstMat(x, Y, 1) - 1
                                    tPDstMat(x, Y, 0) = tPDstMat(x, Y, 0) + 1
                                    
                                End If
                            End If
                            'second win
                            Pos = SwapSites(b, Z, 1) + Offset - 1
                            
                            If Pos < 1 Then Pos = Pos + LenXoverSeq
                            S1 = SeqNum(XDiffPos(Pos), RevSeq(Y))
                            s2 = SeqNum(XDiffPos(Pos), RevSeq(x))
                            
                            If S1 <> s2 Then
                                If S1 <> 46 And s2 <> 46 Then
                                    tPDstMat(x, Y, 1) = tPDstMat(x, Y, 1) + 1
                                    tPDstMat(x, Y, 0) = tPDstMat(x, Y, 0) - 1
                                    
                                End If
                            End If
                        Next Z
                        If tPDstMat(x, Y, 1) < 0 Or tPDstMat(x, Y, 0) < 0 Then
                            x = x
                        End If
                        tPDstMat(Y, x, 1) = tPDstMat(x, Y, 1)
                        tPDstMat(Y, x, 0) = tPDstMat(x, Y, 0)
                    End If
                Next Y
            'Else
            '    For Y = X + 1 To NumberOfSeqs
            '
            '        tPDstMat(X, Y, 1) = PDstMat(X, Y, 1)
            '        tPDstMat(X, Y, 0) = PDstMat(X, Y, 0)
            '        tPDstMat(Y, X, 1) = tPDstMat(X, Y, 1)
            '        tPDstMat(Y, X, 0) = tPDstMat(X, Y, 0)
            '    Next Y
            'End If
        Next x
        
        For x = 0 To NumberOfSeqs
            If OC(x) < PLimit Then
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                    For Y = 0 To NumberOfSeqs
                        If x <> Y Or IncSelf = 1 Then
                            SumX = SumX + tPDstMat(x, Y, 0)
                            SumY = SumY + tPDstMat(x, Y, 1)
                            SumXY = SumXY + tPDstMat(x, Y, 0) * tPDstMat(x, Y, 1)
                            SumX2 = SumX2 + tPDstMat(x, Y, 0) * tPDstMat(x, Y, 0)
                            SumY2 = SumY2 + tPDstMat(x, Y, 1) * tPDstMat(x, Y, 1)
                        End If
                    Next Y
                    If DiffRecord(x) <> SumX + SumY Then
                        x = x
                    End If
                    If SumX2 > 0 And SumY2 > 0 Then
                        PermScore = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                        'Exit Sub
                    Else
                        PermScore = 1
                    End If
                    
                    If PermScore <= PPWinScore(1, x) Then OC(x) = OC(x) + 1
                    
                
                End If
                If PCategory(x, SumX) = 0 Then
                    PCategory(x, SumX) = PermScore
                
                ElseIf PCategory(x, SumX) <> PermScore Then
                    x = x
                    
                    'PermScore = ((NS * SumXY) - (SumX * SumY)) / ((NS * SumX2 - SumX * SumX) ^ 0.5 * (NS * SumY2 - SumY * SumY) ^ 0.5)
                    PCategory(x, SumX) = PCategory(x, SumX) * -1
                    
                    
                ElseIf PCategory(x, SumX) = PermScore Then
                    x = x
                End If
        Next x
        
    Next b
    For x = 0 To NumberOfSeqs
        If OC(x) >= PLimit Then
                PScore(1, x) = 1
        Else
               PScore(1, x) = OC(x) / PPPermsX
        End If
    Next x
End If
EE = Abs(GetTickCount)
TT = EE - SS
'78
Dim OutString() As String, TempString As String
ReDim OutString(NumberOfSeqs)
Dim Begin1 As Long, End2 As Long
'Open "test.csv" For Output As #1
For x = 2 To LenXoverSeq
    
    Offset = x
    End2 = x + WinLen - 1
    Begin1 = x - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXoverSeq + Begin1
    If End2 > LenXoverSeq Then End2 = End2 - LenXoverSeq
    For Z = 0 To NumberOfSeqs
        
        For Y = Z + 1 To NumberOfSeqs
            If SeqNum(XDiffPos(Begin1), RevSeq(Y)) <> 46 And SeqNum(XDiffPos(Begin1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + Int(SeqNum(XDiffPos(Begin1), RevSeq(Y)) <> SeqNum(XDiffPos(Begin1), RevSeq(Z)))
            End If
            If SeqNum(XDiffPos(x - 1), RevSeq(Y)) <> 46 And SeqNum(XDiffPos(x - 1), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - Int(SeqNum(XDiffPos(x - 1), RevSeq(Y)) <> SeqNum(XDiffPos(x - 1), RevSeq(Z)))
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + Int(SeqNum(XDiffPos(x - 1), RevSeq(Y)) <> SeqNum(XDiffPos(x - 1), RevSeq(Z)))
            End If
            
            If SeqNum(XDiffPos(End2), RevSeq(Y)) <> 46 And SeqNum(XDiffPos(End2), RevSeq(Z)) <> 46 Then
                PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - Int(SeqNum(XDiffPos(End2), RevSeq(Y)) <> SeqNum(XDiffPos(End2), RevSeq(Z)))
            End If
            PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
            PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
        Next Y
     Next Z
     'A = Z
        
    For A = 0 To NumberOfSeqs
        OutString(A) = ""
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            For Y = 0 To NumberOfSeqs
                If A <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(A, Y, 0)
                    SumY = SumY + PDstMat(A, Y, 1)
                    SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                    SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                    SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                'PPWinScore(X, A) = ((numberofseqs * SumXY) - (SumX * SumY)) / (Sqr(numberofseqs * SumX2 - SumX * SumX) * Sqr(numberofseqs * SumY2 - SumY * SumY))
                'cc = ((numberofseqs * SumXY) - (SumX * SumY)) / (Sqr(numberofseqs * SumX2 - SumX * SumX) * Sqr(numberofseqs * SumY2 - SumY * SumY))
                AA = ((NS * SumXY) - (SumX * SumY))
                BB = (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                
                If BB > 0 Then
                    PPWinScore(x, A) = AA / BB + (10 ^ -14)
                Else
                    PPWinScore(x, A) = 1
                End If
                x = x
                'Exit Sub
            Else
                PPWinScore(x, A) = 1
            End If
            DiffRecord(A) = SumX + SumY
            'OutString(A) = OutString(A) + Str(ppwinscore(X, A))
    Next A
    ReDim OC(NumberOfSeqs)
    If x = x Then '((X - 1) / 5) = Int((X - 1) / 5) Then
        For b = 1 To PPPermsX
            
            ReDim tPDstMat(NumberOfSeqs, NumberOfSeqs, 1)
            
            
            For A = 0 To NumberOfSeqs
                '
                    For Y = A + 1 To NumberOfSeqs
                        If OC(A) < PLimit Or OC(Y) < PLimit Then
                
                            tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                            tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                            tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                            tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                            For Z = 1 To NumSwaps(b)
                                If SwapSites(b, Z, 0) = 0 Then Exit For
                                Pos = SwapSites(b, Z, 0) + Offset - 1
                                
                                If Pos > LenXoverSeq Then Pos = Pos - LenXoverSeq
                                'first win
                                S1 = SeqNum(XDiffPos(Pos), RevSeq(Y))
                                s2 = SeqNum(XDiffPos(Pos), RevSeq(A))
                                
                                If S1 <> s2 Then
                                    If S1 <> 46 And s2 <> 46 Then
                                        tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) - 1
                                        tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) + 1
                                        
                                    End If
                                End If
                                'second win
                                Pos = SwapSites(b, Z, 1) + Offset - 1
                                
                                
                                
                                If Pos < 1 Then Pos = Pos + LenXoverSeq
                                S1 = SeqNum(XDiffPos(Pos), RevSeq(Y))
                                s2 = SeqNum(XDiffPos(Pos), RevSeq(A))
                                
                                If S1 <> s2 Then
                                    If S1 <> 46 And s2 <> 46 Then
                                        tPDstMat(A, Y, 1) = tPDstMat(A, Y, 1) + 1
                                        tPDstMat(A, Y, 0) = tPDstMat(A, Y, 0) - 1
                                        
                                    End If
                                End If
                            Next Z
                            tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                            tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                        End If
                    Next Y
                'Else
                '    For Y = A + 1 To NumberOfSeqs
                '
               '
               '             tPDstMat(A, Y, 1) = PDstMat(A, Y, 1)
                '            tPDstMat(A, Y, 0) = PDstMat(A, Y, 0)
                '            tPDstMat(Y, A, 1) = tPDstMat(A, Y, 1)
                 '           tPDstMat(Y, A, 0) = tPDstMat(A, Y, 0)
                  '  Next Y
                'End If
            Next A
            For A = 0 To NumberOfSeqs
                If OC(A) < PLimit Then
                    SumA = 0
                    SumY = 0
                    SumAY = 0
                    SumA2 = 0
                    SumY2 = 0
                            For Y = 0 To NumberOfSeqs
                                If A <> Y Or IncSelf = 1 Then
                                    
                                    SumA = SumA + tPDstMat(A, Y, 0)
                                    SumY = SumY + tPDstMat(A, Y, 1)
                                    SumAY = SumAY + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 1)
                                    SumA2 = SumA2 + tPDstMat(A, Y, 0) * tPDstMat(A, Y, 0)
                                    SumY2 = SumY2 + tPDstMat(A, Y, 1) * tPDstMat(A, Y, 1)
                                    
                                End If
                            Next Y
                           
                            If SumA2 > 0 And SumY2 > 0 Then
                                PermScore = ((NS * SumAY) - (SumA * SumY)) / (Sqr(NS * SumA2 - SumA * SumA) * Sqr(NS * SumY2 - SumY * SumY))
                            Else
                                PermScore = 1
                            End If
                            
                            If PermScore < PPWinScore(x, A) Then OC(A) = OC(A) + 1
                    If DiffRecord(A) <> SumA + SumY Then
                        x = x
                    End If
                    
                End If
                
            Next A
        Next b
        For Z = 0 To NumberOfSeqs
            If OC(Z) >= PLimit Then
                PScore(x, Z) = 1
            Else
               PScore(x, Z) = OC(Z) / PPPermsX
            End If
        Next Z
        
        'TempString = Str(XDiffPos(X)) & ","
        
        Form1.SSPanel1.Caption = Str(x) & " of " & Str(LenXoverSeq) & " windows examined"
        Form1.ProgressBar1.Value = x / LenXoverSeq * 100
        Call UpdateF2Prog
        'Print #1, TempString
    End If
Next x

'Close #1
           
'smooth plot over 10nt window
Dim SmoothScore() As Double, NextScore As Long
ReDim SmoothScore(LenXoverSeq, NumberOfSeqs)
For x = 0 To NumberOfSeqs
    'smooth first window
    For Y = -4 To 6
        If Y < 1 Then
            Pos = LenXoverSeq + Y
        Else
            Pos = Y
        End If
        SmoothScore(1, x) = SmoothScore(1, x) + PScore(Pos, x)
    Next Y
    'SmoothScore(Y, X) = SmoothScore(Y, X) / 11
    'do next 4 windows
    For Y = 2 To 5
        Start = LenXoverSeq - 6 + Y
        Pos = Y + 5
        SmoothScore(Y, x) = SmoothScore(Y - 1, x) - PScore(Start, x) + PScore(Pos, x)
    Next Y
    For Y = 6 To LenXoverSeq - 5
        Start = Y - 5
        Pos = Y + 5
        SmoothScore(Y, x) = SmoothScore(Y - 1, x) - PScore(Start, x) + PScore(Pos, x)
    Next Y
    For Y = LenXoverSeq - 4 To LenXoverSeq
        Start = Y - 5
        Pos = (Y + 5) - LenXoverSeq
        SmoothScore(Y, x) = SmoothScore(Y - 1, x) - PScore(Start, x) + PScore(Pos, x)
    Next Y
    For Y = 1 To LenXoverSeq
        SmoothScore(Y, x) = SmoothScore(Y, x) / 11
    Next Y
Next x
Dim MaxRVal As Double, MinRVal As Double
'Do Plots
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlation coefficients
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, lP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = -1000
For x = 0 To NumberOfSeqs
    ZZZ = 0
    MissNo = 0
    If ShowPlotFlag = 1 Then
    ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
        If x = 123456 Then
    
            If MinRValX = 1000 Then
                For Z = 0 To NumberOfSeqs
                    For Y = 1 To LenXoverSeq
                        If PPWinScore(Y, Z) > MaxRVal Then
                            MaxRVal = PPWinScore(Y, Z)
                        ElseIf PPWinScore(Y, Z) < MinRValX Then
                            MinRValX = PPWinScore(Y, Z)
                        End If
                    Next Y
                Next Z
            End If
            DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxRVal), CSng(MinRValX), 0, "Correlation coefficient"
            Form1.Picture7.DrawWidth = 3
            Pict = Form1.Picture7.hdc
            
            For Y = x To x
                
                Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
                For Z = 6 To LenXoverSeq Step 5
                    Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                    
                Next Z
            Next Y
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
            
            For Y = 0 To NumberOfSeqs
                Form1.Picture7.ForeColor = QuaterColour
                If Y <> x Then
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXoverSeq Step 5
                        Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
                End If
            Next Y
            Y = x
            Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
            
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
            For Z = 6 To LenXoverSeq Step 5
                Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
            Next Z
        Else 'plot smoothed values
            If MinRValX = 1000 Then
            ReDim SmoothBak(LenXoverSeq, NumberOfSeqs)
                For Z = 0 To NumberOfSeqs
                    For Y = 1 To LenXoverSeq
                        SmoothBak(Y, Z) = SmoothScore(Y, Z)
                        If SmoothScore(Y, Z) > MaxRVal Then
                            MaxRVal = SmoothScore(Y, Z)
                        ElseIf SmoothScore(Y, Z) < MinRValX Then
                            MinRValX = SmoothScore(Y, Z)
                        End If
                    Next Y
                Next Z
            End If
            DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxRVal), CSng(MinRValX), 1, "Correlation coefficient"
            Form1.Picture7.DrawWidth = 3
            Pict = Form1.Picture7.hdc
            
            Y = x
                Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
                Pict = Form1.Picture7.hdc
                Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
                For Z = 2 To LenXoverSeq
                    Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                    
                Next Z
            
            Form1.Picture7.DrawWidth = 1
            Pict = Form1.Picture7.hdc
            
            For Y = 0 To NumberOfSeqs
                
                If Y <> x Then
                    Form1.Picture7.ForeColor = FFillCol(Y) 'ThreeQuaterColour 'FFillCol(Y)
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXoverSeq
                        Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
                End If
            Next Y
            Y = x
            Form1.Picture7.ForeColor = SeqCol(Y) 'FFillCol(Y)
                    Pict = Form1.Picture7.hdc
                    Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((SmoothBak(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
                    For Z = 6 To LenXoverSeq
                        Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((SmoothBak(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
                        
                    Next Z
        
        End If
        Form1.Picture7.Refresh
    End If
    Do
        
        'find next lowest score
        MinRVal = 1
        For Y = 1 To LenXoverSeq
            If SmoothScore(Y, x) < MinRVal Then
                MinRVal = SmoothScore(Y, x)
                MinPos = Y
            End If
        Next Y
        MinRVal = PPWinScore(MinPos, x)
         
        'Set up the scoreing for this window  and incrimentally increase its size until
        'Correlation coefficients stop dropping
        
        'Start with a window size of 10 on each side of the partition
        SubWinLen = Int(WinLen / 2)
        MissNum = 0
        Do While SubWinLen < WinLen Or MissNum < 10
            'Do matrix for the first half of window
            A = x
            If ZZZ = 6 And x = 3 Then
                x = x
            End If
            If SubWinLen = Int(WinLen / 2) Then
                For Y = 0 To NumberOfSeqs
                
                        PDstMat(A, Y, 0) = 0
                        For Z = (MinPos - SubWinLen) To MinPos - 1
                            If Z < 1 Then
                                Pos = LenXoverSeq + Z
                            Else
                                Pos = Z
                            End If
                            If SeqNum(XDiffPos(Pos), RevSeq(A)) <> SeqNum(XDiffPos(Pos), RevSeq(Y)) And SeqNum(XDiffPos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffPos(Pos), RevSeq(Y)) <> 46 Then
                                PDstMat(A, Y, 0) = PDstMat(A, Y, 0) + 1
                            End If
                            
                        Next Z
                        PDstMat(Y, A, 0) = PDstMat(A, Y, 0)
                        
                Next Y
            
            
                'Do matrix for the second half of window
                A = x
                For Y = 0 To NumberOfSeqs
                        PDstMat(A, Y, 1) = 0
                        For Z = MinPos To MinPos + SubWinLen - 1
                            If Z > LenXoverSeq Then
                                Pos = Z - LenXoverSeq
                            Else
                                Pos = Z
                            End If
                            If SeqNum(XDiffPos(Pos), RevSeq(A)) <> SeqNum(XDiffPos(Pos), RevSeq(Y)) And SeqNum(XDiffPos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffPos(Pos), RevSeq(Y)) <> 46 Then
                                PDstMat(A, Y, 1) = PDstMat(A, Y, 1) + 1
                            End If
                            
                        Next Z
                        PDstMat(Y, A, 1) = PDstMat(A, Y, 1)
                Next Y
        
            Else
                Z = (MinPos - SubWinLen)
                If Z < 1 Then
                    Pos = LenXoverSeq + Z
                Else
                    Pos = Z
                End If
                For Y = 0 To NumberOfSeqs
                    If SeqNum(XDiffPos(Pos), RevSeq(A)) <> SeqNum(XDiffPos(Pos), RevSeq(Y)) And SeqNum(XDiffPos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffPos(Pos), RevSeq(Y)) <> 46 Then
                        PDstMat(A, Y, 0) = PDstMat(A, Y, 0) + 1
                    End If
                    
                    PDstMat(Y, A, 0) = PDstMat(A, Y, 0)
                Next Y
                Z = MinPos + SubWinLen - 1
                If Z > LenXoverSeq Then
                    Pos = Z - LenXoverSeq
                Else
                    Pos = Z
                End If
                For Y = 0 To NumberOfSeqs
                    If SeqNum(XDiffPos(Pos), RevSeq(A)) <> SeqNum(XDiffPos(Pos), RevSeq(Y)) And SeqNum(XDiffPos(Pos), RevSeq(A)) <> 46 And SeqNum(XDiffPos(Pos), RevSeq(Y)) <> 46 Then
                        PDstMat(A, Y, 1) = PDstMat(A, Y, 1) + 1
                    End If
                    PDstMat(Y, A, 1) = PDstMat(A, Y, 1)
                Next Y
            End If
        
        'calc Correlation coefficient and put into corr
            A = x
            SumX = 0
            SumY = 0
            SumXY = 0
            SumX2 = 0
            SumY2 = 0
            
            For Y = 0 To NumberOfSeqs
                If Y <> A Or IncSelf = 1 Then
                            SumX = SumX + PDstMat(A, Y, 0)
                            SumY = SumY + PDstMat(A, Y, 1)
                            SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                            SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                            SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                    
                End If
                        
            Next Y
            
            
            If SumX2 > 0 And SumY2 > 0 Then
                
                AA = (((NS) * SumXY) - (SumX * SumY))
                BB = (Sqr((NS) * SumX2 - SumX * SumX) * Sqr((NS) * SumY2 - SumY * SumY))
                If BB = 0 Then
                    Corr = 1
                Else
                    Corr = AA / BB
                End If
            Else
                Corr = 1
            End If
            
            If (Corr <= MinRVal + 0.0000000001) Then
                If x = 3 Then
                    XDiffPos(MinPos) = XDiffPos(MinPos)
                End If
                MissNum = 0
                WinWinLen = SubWinLen
                MinRVal = Corr
                For Y = 0 To NumberOfSeqs
                    pLeftDist(Y) = PDstMat(A, Y, 0)
                    
                    pRightDist(Y) = PDstMat(A, Y, 1)
                Next Y
            ElseIf SubWinLen >= WinLen Then
                MissNum = MissNum + 1
                
            End If
            
            SubWinLen = SubWinLen + 1
            
        Loop
        'Check with permutations to see whether the minrval is significant or not
            WinStartPos = MinPos - WinWinLen
            
            NumHits = 0
            ZZZ = ZZZ + 1
            For Y = 1 To PPPermsX
                
                For Z = 0 To NumberOfSeqs
                    If Y > 1 And (RightDist(Z) < 0 Or LeftDist(Z) < 0 Or RightDist(Z) > WinWinLen Or LeftDist(Z) > WinWinLen) Then
                        x = x
                        Exit Sub
                        
                    End If
                    RightDist(Z) = pRightDist(Z)
                    LeftDist(Z) = pLeftDist(Z)
                    
                Next Z
                
                ReDim RandWin(WinWinLen * 2)
                For Z = 1 To WinWinLen * 2
                    RandWin(Z) = Z
                Next Z
                For Z = 0 To WinWinLen * 2 - 1
                    Randum = CLng(((WinWinLen * 2 - 1) * Rnd))
                    If Randum = WinWinLen * 2 Then
                        x = x
                    ElseIf Randum = 0 Then
                        x = x
                    End If
                    Tmp = RandWin(Z)
                    RandWin(Z) = RandWin(Randum)
                    RandWin(Randum) = Tmp
                   
                Next Z
                For Z = 0 To WinWinLen - 1
                    Randum = RandWin(Z)
                    If Randum > WinWinLen - 1 Then
                        
                        P2 = WinStartPos + Randum
                        
                        If P2 < 1 Then
                            P2 = P2 + LenXoverSeq
                        ElseIf P2 > LenXoverSeq Then
                            P2 = P2 - LenXoverSeq
                        End If
                        
                        S1 = SeqNum(XDiffPos(P2), RevSeq(A))
                        For b = 0 To NumberOfSeqs
                            s2 = SeqNum(XDiffPos(P2), RevSeq(b))
                            If S1 <> s2 Then
                                If S1 <> 46 And s2 <> 46 Then
                                    RightDist(b) = RightDist(b) - 1
                                    
                                    LeftDist(b) = LeftDist(b) + 1
                                Else
                                    x = x
                                End If
                                
                            End If
                        Next b
                    End If
                Next Z
                
                For Z = WinWinLen To WinWinLen * 2 - 1
                    Randum = RandWin(Z)
                    
                    If Randum <= WinWinLen - 1 Then
                        
                        P2 = WinStartPos + Randum
                        
                        If P2 < 1 Then
                            P2 = P2 + LenXoverSeq
                        ElseIf P2 > LenXoverSeq Then
                            P2 = P2 - LenXoverSeq
                        End If
                        
                        S1 = SeqNum(XDiffPos(P2), RevSeq(A))
                        For b = 0 To NumberOfSeqs
                            s2 = SeqNum(XDiffPos(P2), RevSeq(b))
                            If S1 <> s2 Then
                                If S1 <> 46 And s2 <> 46 Then
                                    RightDist(b) = RightDist(b) + 1
                                    LeftDist(b) = LeftDist(b) - 1
                                    
                                End If
                                
                            End If
                        Next b
                    End If
                    LeftDist(0) = LeftDist(0)
                    If LeftDist(0) = -1 Then
                        x = x
                    End If
                Next Z
                
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                For b = 0 To NumberOfSeqs
                       If b <> x Or IncSelf = 1 Then
                                SumX = SumX + LeftDist(b)
                                SumY = SumY + RightDist(b)
                                SumXY = SumXY + LeftDist(b) * RightDist(b)
                                
                                SumX2 = SumX2 + LeftDist(b) * LeftDist(b)
                                SumY2 = SumY2 + RightDist(b) * RightDist(b)
                      End If
                Next b
                
                If SumX2 > 0 And SumY2 > 0 Then
                    Corr = (((NS + 1) * SumXY) - (SumX * SumY)) / (Sqr((NS + 1) * SumX2 - SumX * SumX) * Sqr((NS + 1) * SumY2 - SumY * SumY))
                Else
                    Corr = 1
                End If
               
                If Corr <= MinRVal Then
                    NumHits = NumHits + 1
                    If NumHits > Cutoff Then
                        ProbVal = 1
                        Exit For
                    End If
                End If
                
            Next Y
            
            ProbVal = NumHits / PPPermsX
            If MCFlag = 0 Then
                ProbVal = ProbVal * NumberOfSeqs
           
            End If
            
            If MCFlag = 0 Then
                
                ProbVal = ProbVal * NumberOfSeqs
            ElseIf MCFlag = 2 Then
            
                Dim ProbabilityXOver As Double
                If ProbVal = 0 Then
                
                    ProbabilityXOver = (1 / PPPermsX) - (10 ^ (-10))
                Else
                    ProbabilityXOver = ProbVal
                End If
                
                If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                    PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                    PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                End If
            
            End If
             
            If ProbVal > LowestProb Then
            'Exit Sub
                MissNo = MissNo + 1
                If MissNo = 5 Then
                    Exit Do
                Else 'delete this peak
                    Start = MinPos
                    
                    Do
                        LStart = Start
                        Start = Start - 1
                        If Start < 1 Then Start = LenXoverSeq
                        If SmoothScore(Start, x) < SmoothScore(LStart, x) Then Exit Do
                    Loop
                    LO = LStart
                    Start = MinPos
                    Do
                        LStart = Start
                        Start = Start + 1
                        If Start > LenXoverSeq Then Start = 1
                        If SmoothScore(Start, x) < SmoothScore(LStart, x) Then Exit Do
                    Loop
                    If LO < Start Then
                        For Z = LO To Start
                            SmoothScore(Z, x) = 1
                        Next Z
                    Else
                        For Z = LO To LenXoverSeq
                            SmoothScore(Z, x) = 1
                        Next Z
                        For Z = 1 To Start
                            SmoothScore(Z, x) = 1
                        Next Z
                    End If
                End If
                
            Else
                MissNo = 0
                Call UpdateXOList(RevSeq(x), CurrentXOver(), XoverList())
                
                'Keep track of signal numbers
                oRecombNo(100) = oRecombNo(100) + 1
                oRecombNo(6) = oRecombNo(6) + 1
                
                'Find which side second BP is on
                XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Daughter = RevSeq(x)
                XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).ProgramFlag = 6
                If ProbVal >= 0 Then
                    XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).PermPVal = ProbVal
                End If
                If ProbVal > 0 Then
                    XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Probability = ProbVal
                Else
                    If MCFlag = 0 Then
                        XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Probability = (1 / PPPermsX) * NumberOfSeqs - (10 ^ (-10))
                    Else
                        XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Probability = (1 / PPPermsX) - 1 ^ 10 - 10
                    End If
                End If
                
                
                lP = MinPos - SubWinLen - 1
                RP = MinPos + SubWinLen - 1
                If lP < 1 Then lP = LenXoverSeq + lP
                If RP > LenXoverSeq Then RP = RP - LenXoverSeq
                If PPWinScore(lP, A) <= PPWinScore(RP, A) Then 'ie left is most likely
                    XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Beginning = XDiffPos(lP)
                    XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Ending = XDiffPos(MinPos)
                    OriFlag = 0
                Else
                    XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Beginning = XDiffPos(MinPos)
                    XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Ending = XDiffPos(RP)
                    OriFlag = 1
                End If
                
                
                'Find best parents by looking for sequences with biggest
                'change in rank on either side of breakpoint
                Dim DiffDist() As Double, LODist As Double, HiDist As Double, Hi As Long
                ReDim DiffDist(NumberOfSeqs)
              '  TL = 0
              '  TR = 0
              '  For Z = 0 To numberofseqs
              '      TL = TL + LeftDist(Z)
              '      TR = TR + RightDist(Z)
              '  Next Z
              '  For Z = 0 To numberofseqs
              '      DiffDist(Z) = LeftDist(Z) / TL - RightDist(Z) / TR
              '      X = X
              '  Next Z
                
                For Z = 0 To NumberOfSeqs
                'Z = X
                    LRank(Z) = 0
                    RRank(Z) = 0
                    For b = 0 To NumberOfSeqs
                        If pLeftDist(b) <= pLeftDist(Z) Then LRank(Z) = LRank(Z) + 1
                        If pRightDist(b) <= pRightDist(Z) Then RRank(Z) = RRank(Z) + 1
                        x = x
                    Next b
                    x = x
                Next Z
                'Exit Sub
                
                
                For Z = 0 To NumberOfSeqs
                    DiffDist(Z) = LRank(Z) - RRank(Z)
                    'Exit Sub
                Next Z
                
                
                'delete region
                    
                    Start = XPosDiff(XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Beginning)
                    'Start = MinPos
                        circ = 0
                        Do
                            LStart = Start
                            Start = Start - 1
                            If Start < 1 Then
                                Start = LenXoverSeq
                                circ = circ + 1
                                If circ = 2 Then Exit Do
                            End If
                            If SmoothScore(Start, x) < SmoothScore(LStart, x) Then Exit Do
                        Loop
                        If circ = 2 Then Exit Do
                        LO = LStart
                        Start = XPosDiff(XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Ending)
                        Do
                            LStart = Start
                            Start = Start + 1
                            If Start > LenXoverSeq Then Start = 1
                            If SmoothScore(Start, x) < SmoothScore(LStart, x) Then Exit Do
                        Loop
                        If LO < Start Then
                            For Z = LO To Start
                                SmoothScore(Z, x) = 1
                            Next Z
                        Else
                            For Z = LO To LenXoverSeq
                                SmoothScore(Z, x) = 1
                            Next Z
                            For Z = 1 To Start
                                SmoothScore(Z, x) = 1
                            Next Z
                        End If
                
                LODist = 100000
                HiDist = 100000
                LO = -1
                Hi = -1
                For Z = 0 To NumberOfSeqs
                    
                    If DiffDist(Z) < 0 And Z <> x And LODist > pLeftDist(Z) Then
                        LODist = pLeftDist(Z)
                        LO = Z
                    End If
                    If DiffDist(Z) > 0 And Z <> x And HiDist > pRightDist(Z) Then
                        HiDist = pRightDist(Z)
                        Hi = Z
                    End If
                    
                Next Z
                
                
                
                If LO = -1 Or Hi = -1 Then
                    'I need to look at movement around the trendline
                    
        
                    x = x
                Else
                    If OriFlag = 1 Then
                        XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).MinorP = RevSeq(Hi)
                        XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).MajorP = RevSeq(LO)
                    
                    Else
                        XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).MinorP = RevSeq(LO)
                        XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).MajorP = RevSeq(Hi)
                    End If
                    
                    
                        D = XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).Daughter
                        Mi = XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).MinorP
                        Ma = XoverList(RevSeq(x), CurrentXOver(RevSeq(x))).MajorP
                        
                        
                        If D = Ma Or D = Mi Or Ma > NextNo Or Ma > NextNo Then
                            x = x
                            Exit Sub
                        End If
                        
                        FindDaughter D, Mi, Ma, 0, 0, 6, CurrentXOver(RevSeq(x))
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(6) = 1
                            Call UpdatePlotB(D, Ma, Mi, CurrentXOver(RevSeq(x)))
    
                        End If
                End If
            End If
            
            
        XDiffPos(MinPos) = XDiffPos(MinPos)
        ET = Abs(GetTickCount)
        
        If ET - LT > 500 Then
            Form1.ProgressBar1.Value = x / NumberOfSeqs * 100
            If Form1.ProgressBar1.Value = 0 Then Form1.ProgressBar1.Value = 1
            Form1.Label50(14).Caption = DoTimeII(ET - PT)
            Form1.Label50(12).Caption = DoTimeII(ET - ST)
            UpdateRecNums (SEventNumber)
            If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                StartPlt(6) = 1
                oRec = oRecombNo(100)
                Call UpdatePlotC
            End If
            LT = ET
            Form1.SSPanel13.Caption = "Approximately " & DoTime((ET - PT) * (100 / Form1.ProgressBar1.Value) - (ET - PT)) & " remaining"
            Form1.SSPanel1.Caption = Str(x) & " of" & Str(NumberOfSeqs) & " sequences examined"
            Call UpdateF2Prog
            DoEvents 'covered by currentlyrunning
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running PHYLPRO scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
            End If
            
            If AbortFlag = 1 Then
            
                Exit For
            End If
        End If
    Loop
    
Next x

Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
If TotalPPRecombinants > 0 Then ProgF(6) = 1
End Sub



Public Sub FindSubSeqPP()

ReDim SubMaskSeq(NextNo + 1)
ReDim RevSeq(NextNo)
'If IndividualB <> -1 Then
    
NumberOfSeqs = 0
If RelX <> 0 Or RelY <> 0 Then
    For x = 0 To PermNextno
        If pMaskSeq(x) <= 1 Then
            SubMaskSeq(NumberOfSeqs) = x
            RevSeq(x) = NumberOfSeqs
            NumberOfSeqs = NumberOfSeqs + 1
        End If
    Next 'X
Else
    For x = 0 To PermNextno
        If MaskSeq(x) <= 1 Then
            SubMaskSeq(NumberOfSeqs) = x
            RevSeq(x) = NumberOfSeqs
            NumberOfSeqs = NumberOfSeqs + 1
        End If
    Next 'X
End If
NumberOfSeqs = NumberOfSeqs - 1
ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
Y = 0
Dim BakDist As Long
BakDist = 1
Dim Match() As Long
ReDim Match(255)
If CurrentCheck <> -1 Or (RelX = 0 And RelY = 0) Or Len(PPXOSeq(0)) > 0 Then
    If PPStripGaps = 0 Then
        For x = 1 To Len(StrainSeq(0))
            XPosDiff(x) = Y
            'ReDim Match(255)
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(x, RevSeq(Z))) = Match(SeqNum(x, RevSeq(Z))) + 1
                'If Match(SeqNum(X, RevSeq(Z))) <> 46 Then
                    If Match(SeqNum(x, RevSeq(Z))) + Match(46) < Z + 1 Then Exit For
                'Else
                
                'End If
            Next Z
            If Z < NumberOfSeqs + 1 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
            End If
        Next x
    Else
        For x = 1 To Len(StrainSeq(0))
            XPosDiff(x) = Y
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(x, RevSeq(Z))) = Match(SeqNum(x, RevSeq(Z))) + 1
                If Match(SeqNum(x, RevSeq(Z))) < Z + 1 Or Match(46) > 0 Then Exit For
            Next Z
            If Z < NumberOfSeqs + 1 And Match(46) = 0 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
            End If
        Next x
    End If
Else
    ReDim PPXOSeq(NextNo)
    If PPStripGaps = 0 Then
        For x = 1 To Len(StrainSeq(0))
            XPosDiff(x) = Y
            'ReDim Match(255)
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(x, RevSeq(Z))) = Match(SeqNum(x, RevSeq(Z))) + 1
                If Match(SeqNum(x, RevSeq(Z))) + Match(46) < Z + 1 Then Exit For
            Next Z
            If Z < NumberOfSeqs + 1 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                For Z = 0 To NumberOfSeqs
                    PPXOSeq(RevSeq(Z)) = PPXOSeq(RevSeq(Z)) + Mid$(StrainSeq(RevSeq(Z)), x, 1)
                Next Z
            End If
        Next x
    Else
        For x = 1 To Len(StrainSeq(0))
            XPosDiff(x) = Y
            Match(46) = 0
            Match(66) = 0
            Match(68) = 0
            Match(72) = 0
            Match(85) = 0
            For Z = 0 To NumberOfSeqs
                Match(SeqNum(x, RevSeq(Z))) = Match(SeqNum(x, RevSeq(Z))) + 1
                If Match(SeqNum(x, RevSeq(Z))) < Z + 1 Or Match(46) > 0 Then Exit For
            Next Z
            If Z < NumberOfSeqs + 1 And Match(46) = 0 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                For Z = 0 To NumberOfSeqs
                    PPXOSeq(RevSeq(Z)) = PPXOSeq(RevSeq(Z)) + Mid$(StrainSeq(RevSeq(Z)), x, 1)
                Next Z
            End If
        Next x
    End If
End If
LenXoverSeq = Y

End Sub

Public Sub PXoverD(CFlag)



Dim NS As Long, PT As Long, Cutoff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long, PPWinScoreT() As Single
PT = Abs(GetTickCount)
ReDim LRank(NumberOfSeqs), RRank(NumberOfSeqs)
Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"
Call UpdateF2Prog



'numberofseqs = 5

Form1.SSPanel1.Caption = "Executing PhylPro"
'Get variable sites
Call FindSubSeqPP

If IncSelf = 0 Then
    NS = NumberOfSeqs
Else
    NS = NumberOfSeqs + 1
End If

Dim WinLen As Long, PDstMat() As Single

ReDim PDstMat(NumberOfSeqs, NumberOfSeqs, 1)
If ExeCheckFlag = 1 And OptFlag <> 13 Then
    If XPosDiff(XoverList(RelX, RelY).Ending) > XPosDiff(XoverList(RelX, RelY).Beginning) Then
        WinLen = XPosDiff(XoverList(RelX, RelY).Ending) - XPosDiff(XoverList(RelX, RelY).Beginning)
    Else
        WinLen = XPosDiff(XoverList(RelX, RelY).Ending) + (LenXoverSeq - XPosDiff(XoverList(RelX, RelY).Beginning))
    End If
Else
 WinLen = CInt(PPWinLen / 2)
End If

If WinLen > LenXoverSeq / 2 Then WinLen = CInt(LenXoverSeq / 2)


ReDim PPWinScoreT(LenXoverSeq, NumberOfSeqs)
SS = Abs(GetTickCount)
If x = x Then
    Dummy = MakePDstMat(NumberOfSeqs, Len(StrainSeq(0)), LenXoverSeq, WinLen, XDiffPos(0), RevSeq(0), SeqNum(0, 0), PDstMat(0, 0, 0))
Else
    'Do matrix for the first half of first window
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
                For Z = (LenXoverSeq - WinLen + 1) To LenXoverSeq
                    If SeqNum(XDiffPos(Z), RevSeq(x)) <> SeqNum(XDiffPos(Z), RevSeq(Y)) And SeqNum(XDiffPos(Z), RevSeq(x)) <> 46 And SeqNum(XDiffPos(Z), RevSeq(Y)) <> 46 Then
                        PDstMat(x, Y, 0) = PDstMat(x, Y, 0) + 1
                    End If
                    
                Next Z
                PDstMat(Y, x, 0) = PDstMat(x, Y, 0)
        Next Y
    Next x
    
    'Do matrix for the second half of first window
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
                
                For Z = 1 To WinLen
                    If SeqNum(XDiffPos(Z), RevSeq(x)) <> SeqNum(XDiffPos(Z), RevSeq(Y)) And SeqNum(XDiffPos(Z), RevSeq(x)) <> 46 And SeqNum(XDiffPos(Z), RevSeq(Y)) <> 46 Then
                        PDstMat(x, Y, 1) = PDstMat(x, Y, 1) + 1
                    End If
                    
                Next Z
                PDstMat(Y, x, 1) = PDstMat(x, Y, 1)
        Next Y
    Next x
End If
EE = Abs(GetTickCount)
TT = EE - SS
x = x '7.321
Dim SumX As Double, SumY As Double, SumXY As Double, SumX2 As Double, SumY2 As Double

'calc Correlation coefficient and put into PPWinScoreTTas the first window pos
For x = 0 To NumberOfSeqs
    SumX = 0
    SumY = 0
    SumXY = 0
    SumX2 = 0
    SumY2 = 0
    For Y = 0 To NumberOfSeqs
                If x <> Y Or IncSelf = 1 Then
                    SumX = SumX + PDstMat(x, Y, 0)
                    SumY = SumY + PDstMat(x, Y, 1)
                    SumXY = SumXY + PDstMat(x, Y, 0) * PDstMat(x, Y, 1)
                    SumX2 = SumX2 + PDstMat(x, Y, 0) * PDstMat(x, Y, 0)
                    SumY2 = SumY2 + PDstMat(x, Y, 1) * PDstMat(x, Y, 1)
                    
                End If
    Next Y
    
    If SumX2 > 0 And SumY2 > 0 Then
        PPWinScoreT(1, x) = ((NS * SumXY) - (SumX * SumY)) / (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
    Else
        PPWinScoreT(1, x) = 1
    End If
    
Next x



Dim Begin1 As Long, End2 As Long
SS = Abs(GetTickCount)
For x = 2 To LenXoverSeq
    
    Offset = x
    End2 = x + WinLen - 1
    Begin1 = x - WinLen - 1
    If Begin1 < 1 Then Begin1 = LenXoverSeq + Begin1
    If End2 > LenXoverSeq Then End2 = End2 - LenXoverSeq
    If x = x Then
        Dummy = UpdatePDstMat(x, Begin1, End2, NumberOfSeqs, Len(StrainSeq(0)), SeqNum(0, 0), XDiffPos(0), RevSeq(0), PDstMat(0, 0, 0))
    Else
        For Z = 0 To NumberOfSeqs
            
            For Y = Z + 1 To NumberOfSeqs
                If SeqNum(XDiffPos(Begin1), RevSeq(Y)) <> 46 And SeqNum(XDiffPos(Begin1), RevSeq(Z)) <> 46 Then
                    If SeqNum(XDiffPos(Begin1), RevSeq(Y)) <> SeqNum(XDiffPos(Begin1), RevSeq(Z)) Then
                    PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) - 1 ' Int(SeqNum(XDiffpos(Begin1), RevSeq(y)) <> SeqNum(XDiffpos(Begin1), RevSeq(Z)))
                    End If
                    
                End If
                If SeqNum(XDiffPos(x - 1), RevSeq(Y)) <> 46 And SeqNum(XDiffPos(x - 1), RevSeq(Z)) <> 46 Then
                    If SeqNum(XDiffPos(x - 1), RevSeq(Y)) <> SeqNum(XDiffPos(x - 1), RevSeq(Z)) Then
                    PDstMat(Z, Y, 0) = PDstMat(Z, Y, 0) + 1 '- Int(SeqNum(XDiffpos(X - 1), RevSeq(y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
                    PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) - 1 '+ Int(SeqNum(XDiffpos(X - 1), RevSeq(y)) <> SeqNum(XDiffpos(X - 1), RevSeq(Z)))
                    End If
                End If
                
                If SeqNum(XDiffPos(End2), RevSeq(Y)) <> 46 And SeqNum(XDiffPos(End2), RevSeq(Z)) <> 46 Then
                    If SeqNum(XDiffPos(End2), RevSeq(Y)) <> SeqNum(XDiffPos(End2), RevSeq(Z)) Then
                    PDstMat(Z, Y, 1) = PDstMat(Z, Y, 1) + 1 '- Int(SeqNum(XDiffpos(End2), RevSeq(y)) <> SeqNum(XDiffpos(End2), RevSeq(Z)))
                    End If
                End If
                PDstMat(Y, Z, 0) = PDstMat(Z, Y, 0)
                PDstMat(Y, Z, 1) = PDstMat(Z, Y, 1)
            Next Y
         Next Z
    End If
     'A = Z
    If x = x Then
        Dummy = PPRegression(IncSelf, x, LenXoverSeq, NumberOfSeqs, NS, PDstMat(0, 0, 0), PPWinScoreT(0, 0))
    Else
        For A = 0 To NumberOfSeqs
           
                SumX = 0
                SumY = 0
                SumXY = 0
                SumX2 = 0
                SumY2 = 0
                For Y = 0 To NumberOfSeqs
                    If A <> Y Or IncSelf = 1 Then
                        SumX = SumX + PDstMat(A, Y, 0)
                        SumY = SumY + PDstMat(A, Y, 1)
                        SumXY = SumXY + PDstMat(A, Y, 0) * PDstMat(A, Y, 1)
                        SumX2 = SumX2 + PDstMat(A, Y, 0) * PDstMat(A, Y, 0)
                        SumY2 = SumY2 + PDstMat(A, Y, 1) * PDstMat(A, Y, 1)
                        
                    End If
                Next Y
                
                
                If SumX2 > 0 And SumY2 > 0 Then
                    AA = ((NS * SumXY) - (SumX * SumY))
                    BB = (Sqr(NS * SumX2 - SumX * SumX) * Sqr(NS * SumY2 - SumY * SumY))
                    
                    If BB > 0 Then
                        PPWinScoreT(x, A) = AA / BB
                    Else
                        PPWinScoreT(x, A) = 1
                    End If
                Else
                    PPWinScoreT(x, A) = 1
                End If
                
                'OutString(A) = OutString(A) + Str(PPWinScoreT(X, A))
        Next A
    End If
    If AbortFlag = 1 Then Call EnableInterface: Exit Sub
    SS = Abs(GetTickCount)
    If Abs(SS - LS) > 500 Then
        LS = SS
        Form1.ProgressBar1.Value = 10 + (x / LenXoverSeq) * 80
        Form1.SSPanel1.Caption = "Executing PhylPro (" + Trim(Str(x)) + " of " + Trim(Str(LenXoverSeq)) + " windows examined)"
        Call UpdateF2Prog
    End If
Next x
EE = Abs(GetTickCount)

TT = EE - SS '66.859,37.156,25.7,0.65

x = x
'Close #1
           

Dim MaxRVal As Double, MinRVal As Double
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlation coefficients
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, lP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = 1
For Z = 0 To NumberOfSeqs
    If Z = Seq1 Or Z = Seq2 Or Z = Seq3 Then
        For Y = 1 To LenXoverSeq
            If PPWinScoreT(Y, Z) > MaxRVal Then
                MaxRVal = PPWinScoreT(Y, Z)
            ElseIf PPWinScoreT(Y, Z) < MinRValX Then
                MinRValX = PPWinScoreT(Y, Z)
            End If
        Next Y
    End If
Next Z
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
'DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxRVal), CSng(MinRValX), 1, "Correlation coefficient"
MRV = MinRValX

MaRV = MaxRVal
Dim red As Long, Green As Long, blue As Long
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        
'If x = 12345 Then
'    Form1.Picture7.DrawWidth = 3
'    Pict = Form1.Picture7.hdc
'
'    For x = 0 To 2
'        If x = 0 Then
'            Y = Seq1
'        ElseIf x = 1 Then
'            Y = Seq2
'        ElseIf x = 2 Then
'            Y = Seq3
'        End If
'        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
'        Pict = Form1.Picture7.hdc
'        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScoreT(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
'
'        For Z = 2 To LenXoverSeq 'Step 5
'            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScoreT(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
'        Next Z
'    Next x
'End If
Form1.Picture7.DrawWidth = 1
Pict = Form1.Picture7.hdc
If CFlag = 1 Then
    

    For Y = 0 To NumberOfSeqs
        Form1.Picture7.ForeColor = ThreeQuaterColour
        If Y <> Seq1 And Y <> Seq2 And Y <> Seq3 Then
            Pict = Form1.Picture7.hdc
            Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScoreT(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                        
            For Z = 6 To LenXoverSeq Step 5
                Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScoreT(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
            Next Z
        End If
    Next Y
End If

Call Highlight(0)
XX = PermNextno
'For X = 0 To 2
'    If X = 0 Then
'        Y = TreeTrace(Seq1)
'        Form1.Picture7.ForeColor = Green
'    ElseIf X = 1 Then
'        Y = TreeTrace(Seq2)
'        Form1.Picture7.ForeColor = blue
'    ElseIf X = 2 Then
'        Y = TreeTrace(Seq3)
'        Form1.Picture7.ForeColor = red
'    End If
'     'FFillCol(Y)
'    Pict = Form1.Picture7.hDC
'    Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScoreT(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
'
'    For Z = 2 To LenXOverSeq 'Step 5
'        Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScoreT(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
'    Next Z
'Next X
 
 WN1 = TreeTrace(Seq1): WN2 = TreeTrace(Seq2): WN3 = TreeTrace(Seq3)
 WNStr(1) = OriginalName(TreeTrace(Seq1)): WNStr(2) = OriginalName(TreeTrace(Seq2)): WNStr(3) = OriginalName(TreeTrace(Seq3))
' Call WriteNames2(TreeTrace(Seq1), TreeTrace(Seq2), TreeTrace(Seq3), Green, blue, red)
       

        
Form1.Picture7.Refresh
 Form1.ProgressBar1.Value = 0
 Form1.SSPanel1.Caption = ""
 Call UpdateF2Prog
   'Get everything into the standard format for printing and saving
        If CFlag = 0 Then
            NumLines = 3
        ElseIf CFlag = 1 Then
            NumLines = NumberOfSeqs + 4 'number of lines to print
        End If
        ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)
    
        ReDim GVarPos(0, LenXoverSeq)
        'For Y = 0 To 2
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = Decompress(Recompress(XDiffPos(x)))
        Next x
        'Next Y
        ReDim GCritval(10)
        GCritval(0) = 0 '-Log10((LowestProb / MCCorrection))
        GLegend = "Correlation coefficient"
        GPrintLen = LenXoverSeq + 1 'how many points to plot
        
        
        GPrintCol(0) = Green 'line is green
        GPrintCol(1) = blue 'line is blue
        GPrintCol(2) = red ''line is red
        If CFlag = 1 Then
            For x = 0 To NumberOfSeqs
                GPrintCol(x + 3) = RGB(196, 196, 196) ''line is grey
            Next x
        End If
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        
        GPrintMin(0) = MinRValX 'bottom val
        GPrintMin(1) = MaxRVal  'upper val
        If CFlag = 1 Then
            For Y = 0 To NumberOfSeqs
                For x = 1 To LenXoverSeq - 1
                
                    GPrint(Y + 3, x) = PPWinScoreT(x, Y)
                    
                    GPrintPos(Y + 3, x) = (XDiffPos(x) + (XDiffPos(x + 1) - XDiffPos(x)) / 2)
                
                Next x
                GPrint(Y + 3, 0) = GPrint(Y + 3, 1)
            Next Y
        
        End If
        For Z = 0 To 2
            If Z = 0 Then
                Y = TreeTrace(Seq1)
            ElseIf Z = 1 Then
                Y = TreeTrace(Seq2)
            Else
                Y = TreeTrace(Seq3)
            End If
            
            For x = 0 To LenXoverSeq - 1
            
                GPrint(Z, x) = PPWinScoreT(x, Y)
                
                GPrintPos(Z, x) = (XDiffPos(x) + (XDiffPos(x + 1) - XDiffPos(x)) / 2)
            
            Next x
            GPrint(Z, 0) = GPrint(Z, 1)
        Next Z
        'XX = GPrint(1, 0)
        'For Y = 0 To NumLines - 1
        '    GPrint(Y, LenXOverSeq(Y)) = -Log10(ChiVals(xLenXoverSeq(Y), Y))
        '    GPrint(Y + 3, xLenXoverSeq(Y)) = GPrint(Y, xLenXoverSeq(Y))
        'Next Y
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = GPrint(x, 1)
            
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = GPrint(x, 1)
        Next x
        GExtraTNum = 3
        ReDim GExtraText(GExtraTNum)
        GExtraText(0) = OriginalName(Seq1)
        GExtraText(1) = OriginalName(Seq2)
        GExtraText(2) = OriginalName(Seq3)
        GExtraText(3) = "Other sequences"
        Erase PPWinScore
        Erase PPWinScoreT
        Call RedrawPlotAA(1)
End Sub
Public Sub PXoverE()



Dim NS As Long, PT As Long, Cutoff As Long, LRank() As Long, RRank() As Long, LO As Long, LStart As Long, PPCorrect As Long, PLimit As Long, PPCO As Double
Dim Length As Long
PT = Abs(GetTickCount)
ReDim LRank(NextNo), RRank(NextNo)
Form1.ProgressBar1.Value = 10
Form1.SSPanel1.Caption = "Executing PhylPro"
Call UpdateF2Prog
'Get variable sites




Call FindSubSeqPP


Dim MaxRVal As Double, MinRVal As Double
Dim PntAPI As POINTAPI, Pict As Long


'Find Minimum Correlations
Dim SmoothBak() As Double, MinRValX As Double, TL As Double, tr As Double, OriFlag As Byte, RandWin() As Long, ProbVal As Double, NumHits As Long, WinStartPos As Long, LeftDist() As Long, RightDist() As Long, pLeftDist() As Long, pRightDist() As Long, MinPos As Long, WinWinLen As Long, SubWinLen As Long, Corr As Double, MissNum As Long
Dim MissNo As Long, lP As Long, RP As Long
ReDim LeftDist(NumberOfSeqs), RightDist(NumberOfSeqs), pLeftDist(NumberOfSeqs), pRightDist(NumberOfSeqs)
MinRValX = 1000
MaxRVal = -1000
For Z = 0 To NumberOfSeqs
    For Y = 1 To LenXoverSeq
        If PPWinScore(Y, Z) > MaxRVal Then
            MaxRVal = PPWinScore(Y, Z)
        ElseIf PPWinScore(Y, Z) < MinRValX Then
            MinRValX = PPWinScore(Y, Z)
            'If MinRValX < 0 Then
            '    X = X
            'End If
        End If
    Next Y
Next Z




ReDim GPVTFont(5, 100), GPVText(100)
GPVTNum = -1
DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxRVal), CSng(MinRValX), 1, "Correlation coefficient"
MRV = MinRValX
MaRV = MaxRVal
Dim red As Long, Green As Long, blue As Long
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
        
If x = 12345 Then
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
                
    For x = 0 To 2
        If x = 0 Then
            Y = Seq1
        ElseIf x = 1 Then
            Y = Seq2
        ElseIf x = 2 Then
            Y = Seq3
        End If
        Form1.Picture7.ForeColor = FFillCol(Y) 'FFillCol(Y)
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
        For Z = 2 To LenXoverSeq 'Step 5
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
        Next Z
    Next x
End If
Form1.Picture7.DrawWidth = 1
Pict = Form1.Picture7.hdc
            
For Y = 0 To NumberOfSeqs
    Form1.Picture7.ForeColor = ThreeQuaterColour
    If Y <> Seq1 And Y <> Seq2 And Y <> Seq3 Then
        Pict = Form1.Picture7.hdc
        Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                    
        For Z = 2 To LenXoverSeq
            Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
        Next Z
    End If
Next Y
Call Highlight(0)
For x = 0 To 2
    If x = 0 Then
        Y = Seq1
        Form1.Picture7.ForeColor = Green
    ElseIf x = 1 Then
        Y = Seq2
        Form1.Picture7.ForeColor = blue
    ElseIf x = 2 Then
        Y = Seq3
        Form1.Picture7.ForeColor = red
    End If
     'FFillCol(Y)
    Pict = Form1.Picture7.hdc
    Dummy = MoveToEx(Pict, 30 + (Decompress(XDiffPos(1))) * XFactor, PicHeight - (15 + ((PPWinScore(1, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)), PntAPI)
                
    For Z = 2 To LenXoverSeq 'Step 5
        Dummy = LineTo(Pict, 30 + (Decompress(XDiffPos(Z))) * XFactor, PicHeight - (15 + ((PPWinScore(Z, Y) - MinRValX) / (MaxRVal - MinRValX)) * (PicHeight - 35)))
    Next Z
Next x

 OFontSize = Form1.Picture7.FontSize
    L1 = Form1.Picture7.TextWidth(OriginalName(Seq1))
    L2 = Form1.Picture7.TextWidth(OriginalName(Seq2))
    L3 = Form1.Picture7.TextWidth(OriginalName(Seq3))
    DrawLen = Form1.Picture7.ScaleWidth - 30
    TotLen = L1 + L2 + L3

    If DrawLen > TotLen Then
        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    Else

        Do Until TotLen < DrawLen
            LastFontSize = Form1.Picture7.FontSize
            Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
            If Form1.Picture7.FontSize = LastFontSize Then Exit Do
            L1 = Form1.Picture7.TextWidth(OriginalName(Seq1))
            L2 = Form1.Picture7.TextWidth(OriginalName(Seq2))
            L3 = Form1.Picture7.TextWidth(OriginalName(Seq3))
            TotLen = L1 + L2 + L3
        Loop

        LOSpace = (DrawLen - TotLen) / 2
        XPos1 = 25
        XPos2 = XPos1 + L1 + LOSpace
        XPos3 = XPos2 + L2 + LOSpace
    End If
       
YPos = Form1.Picture7.Height * (0.92)
    Form1.Picture7.ForeColor = ThreeQuaterColour
    Form1.Picture7.CurrentX = XPos1 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print OriginalName(Seq1)
    Form1.Picture7.CurrentX = XPos2 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print OriginalName(Seq2)
    Form1.Picture7.CurrentX = XPos3 - 1
    Form1.Picture7.CurrentY = YPos - 1
    Form1.Picture7.Print OriginalName(Seq3)
    Form1.Picture7.ForeColor = QuaterColour
    Form1.Picture7.CurrentX = XPos1 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print OriginalName(Seq1)
    Form1.Picture7.CurrentX = XPos2 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print OriginalName(Seq2)
    Form1.Picture7.CurrentX = XPos3 + 1
    Form1.Picture7.CurrentY = YPos + 1
    Form1.Picture7.Print OriginalName(Seq3)
    Form1.Picture7.CurrentX = XPos1
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = red 'RGB(255, 0, 0)
    Form1.Picture7.Print OriginalName(Seq1)
    Form1.Picture7.CurrentX = XPos2
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = Green 'RGB(0, 255, 0)
    Form1.Picture7.Print OriginalName(Seq2)
    Form1.Picture7.CurrentX = XPos3
    Form1.Picture7.CurrentY = YPos
    Form1.Picture7.ForeColor = blue 'RGB(0, 0, 255)
    Form1.Picture7.Print OriginalName(Seq3)
    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFontSize
Form1.ProgressBar1 = 0
Form1.SSPanel1 = ""
Call UpdateF2Prog
Form1.Picture7.Refresh
    
        
        
End Sub
Public Sub DrawBSPlotsII()
    'Draws plots for the automated bootscan


    Dim PntAPI As POINTAPI
    Dim Pict As Long, x As Long, PosCount As Long, Zero As Long, One As Long, Two As Long
Zero = 0
One = 1
Two = 2
MinPA = ProbabilityXOver
    'Draw the axes
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
           
    LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
    
    
    
    
    If BestRescanFlag = 1 Then
        If BestRescanP > MinPA And MinPA < LowestProb And MinPA > 0 Then
            BestRescanP = MinPA
        End If
        
    End If
    
    If (UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, 100, 0, 1, "Bootstrap support (%)")
        
        'Dimension arrays for drawing metafiles
        ReDim MCPrintPos(Len(StrainSeq(0)))
        ReDim MCPrintData(2, Len(StrainSeq(0)))
        PosCount = 0
    
        Do While PltPos(PosCount + 1) > 0
            MCPrintPos(PosCount) = PltPos(PosCount)
            MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSBootReps) * 100
            MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSBootReps) * 100
            MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSBootReps) * 100
            PosCount = PosCount + 1
        Loop
    
        'Draw the line fade
    '    Form1.Picture7.DrawWidth = 3
    '
    '    For X = 2 To 0 Step -1
    '
    '        If X = 2 Then
    '            Form1.Picture7.ForeColor = LPurple
    '        ElseIf X = 1 Then
    '            Form1.Picture7.ForeColor = LGreen
    '        Else
    '            Form1.Picture7.ForeColor = LYellow
    '        End If
    '
    '        Pict = Form1.Picture7.hDC
    ''        PosCount = 0
    ''        Do While PltPos(PosCount + 2) > 0
    ''            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
    ''
    '''                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
    '''                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount + 1)) * xFactor, 20 + (1 - PltVal(X, PosCount + 1) / BSBootReps) * (PicHeight - 35))
    ''
    ''            End If
    ''            PosCount = PosCount + 1
    ''        Loop
    '
    '    Next 'X
    
        'Form1.ProgressBar1.Value = 93
        Form1.Picture7.DrawWidth = 1
        'Highlight the recombinant region
        If DontRedrawPlotsFlag = 0 Then
            If (RelX > 0 Or RelY > 0) And RunFlag = 1 Then
        
                Call Highlight(0)
        
            End If
        End If
        'Do cutoff line
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.DrawStyle = 2
    '    MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
    '    LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
        Form1.Picture7.DrawStyle = 0
    
        'Do the foregreound plot
    
    '    For X = 0 To 2
    '
    '        If X = 0 Then
    '            Form1.Picture7.ForeColor = Yellow
    '        ElseIf X = 1 Then
    '            Form1.Picture7.ForeColor = green
    '        Else
    '            Form1.Picture7.ForeColor = Purple
    '        End If
    '
    '        Pict = Form1.Picture7.hDC
    '
    '
    '
    '        'Dummy = MoveToEx(Pict, 30 + PltPos(0) * XFactor, 20 + (1 - PltVal(X, 0) / BSBootReps) * (PicHeight - 35), PntAPI)
    '        PosCount = 0
    '
    ''        Do While PltPos(PosCount + 2) > 0
    ''            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
    ''
    '''                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
    '''                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount + 1)) * xFactor, 20 + (1 - PltVal(X, PosCount + 1) / BSBootReps) * (PicHeight - 35))
    ''
    ''            End If
    ''            PosCount = PosCount + 1
    ''        Loop
    '
    '    Next 'X
    
        'Form1.ProgressBar1.Value = 100
        'Do the key
        'Get everything into the standard format for printing and saving
        
        
        
            ReDim GPVTFont(5, 100), GPVText(100)
            GPVTNum = -1
            PosCount = PosCount - 1
            NumLines = 6 'number of lines to print
            ReDim GPrint(NumLines - 1, PosCount + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, PosCount + 1)
    '********************************************************
            ReDim GVarPos(0, LenXoverSeq)
            For x = 0 To LenXoverSeq 'LenXOverSeq
                GVarPos(0, x) = XDiffPos(x)
            Next x
            ReDim GCritval(10)
            GCritval(0) = BSCutOff * 100
            GLegend = "Bootstrap support (%)"
            GPrintLen = PosCount + 1 'how many points to plot
            GPrintCol(0) = Yellow 'line is yellow
            GPrintCol(1) = Green 'line is green
            GPrintCol(2) = Purple ''line is purple
            GPrintCol(3) = Yellow 'line is yellow
            GPrintCol(4) = Green 'line is green
            GPrintCol(5) = Purple ''line is purple
            GPrintNum = NumLines - 1 'six lines
            GPrintType = 0 'a normal line plot
            Dim Div As Double
            Div = (Int(XOverWindowX / 2) * 2 + 1)
            GPrintMin(0) = 0 'bottom val
            GPrintMin(1) = 100 'upper val
            
            MCPrintPos(PosCount) = PltPos(PosCount)
            MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSBootReps) * 100
            MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSBootReps) * 100
            MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSBootReps) * 100
            Dim LastX As Long, MCPP As Long
            LastX = 1
            RS = XoverList(RelX, RelY).Beginning
            RE = XoverList(RelX, RelY).Ending
            Call ModSeqNum(RS, RE, 1)
            For x = 1 To PosCount
                MCPP = MCPrintPos(x)
                'If MissingData(MCPP, Seq1) = 0 And MissingData(MCPP, Seq2) = 0 And MissingData(MCPP, Seq3) = 0 Then
                    For Y = 0 To 2
                        GPrint(Y, x) = MCPrintData(Y, x)
                        GPrint(Y + 3, x) = MCPrintData(Y, x)
                        GPrintPos(Y, x) = MCPP
                        GPrintPos(Y + 3, x) = MCPP
                        'LastX = X
                    Next Y
    '            Else
    '                For Y = 0 To 2
    '                    GPrint(Y, X) = MCPrintData(Y, LastX)
    '                    GPrint(Y + 3, X) = MCPrintData(Y, LastX)
    '                    GPrintPos(Y, X) = MCPP
    '                    GPrintPos(Y + 3, X) = MCPP
    '                    LastX = X
    '                Next Y
    '            End If
            Next x
            Call UnModSeqNum(0)
            ProbabilityXOver = XoverList(RelX, RelY).Probability
            
            For x = 0 To NumLines - 1
                GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
                GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
                GPrintPos(x, 0) = 1
                GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            Next x
            
        
      
        If TManFlag = -1 Then
            If DontRedrawPlotsFlag = 0 Then
                If DoScans(0, 2) = 1 And ((Form1.Combo1.ListIndex = 2 And ExeCheckFlag = 1) Or ExeCheckFlag = 0) Then
                    WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                    WNStr(1) = OriginalName(Seq1): WNStr(2) = OriginalName(Seq2): WNStr(3) = OriginalName(Seq3)
                    Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
        
                Else
        
                    WN1 = RevSeq(Seq1): WN2 = RevSeq(Seq2): WN3 = RevSeq(Seq3)
                    WNStr(1) = OriginalName(RevSeq(Seq1)): WNStr(2) = OriginalName(RevSeq(Seq2)): WNStr(3) = OriginalName(RevSeq(Seq3))
                    Call WriteNames(RevSeq(Seq1), RevSeq(Seq2), RevSeq(Seq3), Yellow, Green, Purple)
        
                End If
            End If
        End If
        Call RedrawPlotAA(1)
        If x = x Then
            RS = XoverList(RelX, RelY).Beginning
            RE = XoverList(RelX, RelY).Ending
            If RE > RS Then
                ProbX = Decompress(RS) + (Decompress(RE) - Decompress(RS)) / 2
            Else
                If Len(StrainSeq(0)) - RS > RE Then
                    ProbX = Decompress(RS) + (Decompress(Len(StrainSeq(0))) - Decompress(RS)) / 2
                Else
                    ProbX = 1 + Decompress(RE) / 2
                End If
            End If
            If BSCutOff < 0.9 Then
                ProbY = 1
            Else
                ProbY = 0.85
            End If
            ProbTest = ProbabilityXOver
            MinPA = ProbabilityXOver
            
             
            
            If MinPA > 0 Then
                If MinPA < 1 Then
                    If SPF = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call PrintProbability
                        End If
                    End If
                    If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                        BestParent = CheckParent: WinMethod = 2
                        BestParentP = MinPA
                    End If
                    
                End If
            ElseIf UpdateIDFlag = 1 Then
                MinPA = XoverList(RelX, RelY).Probability
                If SPF = 0 Then
                    If DontRedrawPlotsFlag = 0 Then
                        Call PrintProbability
                    End If
                End If
                If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                    BestParent = CheckParent: WinMethod = 2
                    BestParentP = MinPA
                End If
            End If
        End If
    End If
    MinPAGlobal = MinPA
    
    'Form1.Picture7.Refresh
    'Form1.Picture10.Refresh
End Sub
Public Sub DrawBSPlotsIII(SPF, FindallFlag As Byte)
    Dim MinPA As Double
    Dim PntAPI As POINTAPI
    Dim Zero As Long, Pict As Long
    Dim One As Long, Two As Long, PosCount As Long
    
    
    'Does Plots for the "re-bootscan check"
    
    
    
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
           
    LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
   ' X = X
    
    
    
    RE = XoverList(RelX, RelY).Ending
    RS = XoverList(RelX, RelY).Beginning
    
    If (BSPValFlag > 0 And TManFlag = -1) Or BestRescanFlag = 1 Then
            
            'I disabled this because it screws up the variable site view in the sequence display
            ' - it does not match up with the variable sites found with findsubseqbs
           
            
            
            LSeq = Len(StrainSeq(0))
            ActiveSeq = Seq3
            ActiveMajorP = Seq1
            ActiveMinorP = Seq2
            If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB = NextNo
            On Error GoTo 0
            If UB = -1 Then Exit Sub
            If UB < ActiveSeq Then
               ActiveSeq = TreeTrace(ActiveSeq)
            End If
            If UB < ActiveMinorP Then
                ActiveMinorP = TreeTrace(ActiveMinorP)
            End If
            If UB < ActiveMajorP Then
                ActiveMajorP = TreeTrace(ActiveMajorP)
            End If
            
            
            If ActiveSeq > NextNo Or ActiveMajorP > NextNo Or ActiveMinorP > NextNo Then
                ModNextno
            End If
            Dim NJSubDistance() As Single
            ReDim NJSubDistance(NextNo, NextNo)
            Dummy = DistanceCalcE(ActiveMajorP, NextNo, LSeq + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(ActiveMinorP, NextNo, LSeq + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(ActiveSeq, NextNo, LSeq + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dim ScoreP As Byte, HMChi As Double, XOverLen As Long
            If ActiveSeq <= UBound(NJSubDistance, 1) And ActiveMajorP <= UBound(NJSubDistance, 1) And ActiveMinorP <= UBound(NJSubDistance, 1) Then
                If NJSubDistance(ActiveSeq, ActiveMinorP) > NJSubDistance(ActiveSeq, ActiveMajorP) And NJSubDistance(ActiveSeq, ActiveMinorP) > NJSubDistance(ActiveMajorP, ActiveMinorP) Then
                    Hi1 = ActiveSeq
                    Hi2 = ActiveMinorP
                    LO = ActiveMajorP
                ElseIf NJSubDistance(ActiveSeq, ActiveMajorP) > NJSubDistance(ActiveSeq, ActiveMinorP) And NJSubDistance(ActiveSeq, ActiveMajorP) > NJSubDistance(ActiveMajorP, ActiveMinorP) Then
                    Hi1 = ActiveSeq
                    Hi2 = ActiveMajorP
                    LO = ActiveMinorP
                Else
                    Hi1 = ActiveMajorP
                    Hi2 = ActiveMinorP
                    LO = ActiveSeq
                    'Temp = ActiveSeq
                    'ActiveSeq = ActiveMajorP
                    'ActiveMajorP = Temp
                End If
            Else
                Exit Sub
            End If
            If (Hi1 = Seq1 And Hi2 = Seq2) Or (Hi2 = Seq1 And Hi1 = Seq2) Then
                'If XOverList(RelX, RelY).OutsideFlag < 2 Then
                    ScoreP = 0
                'Else
                '    If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                '        ScoreP = 1
                '    Else
                '        ScoreP = 2
                '    End If
                'End If
            ElseIf (Hi1 = Seq1 And Hi2 = Seq3) Or (Hi2 = Seq1 And Hi1 = Seq3) Then
                'If XOverList(RelX, RelY).OutsideFlag < 2 Then
                    ScoreP = 1
                'Else
                '    If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                '        ScoreP = 0
                '    Else
                '        ScoreP = 2
                '    End If
                'End If
            ElseIf (Hi1 = Seq3 And Hi2 = Seq2) Or (Hi2 = Seq3 And Hi1 = Seq2) Then
                'If XOverList(RelX, RelY).OutsideFlag < 2 Then
                    ScoreP = 2
                'Else
                '    If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                '        ScoreP = 0
                '    Else
                '        ScoreP = 1
                '    End If
                'End If
            End If
                
                
                Dim PS As Long, PE As Long, OKPair(2) As Byte
                PS = CLng(RS / BSStepSize) - 1
                PE = CLng(RE / BSStepSize) + 1
                If PS < 1 Then PS = 1
                If PE > PS Then
                    For x = PS To PE
                        If PltPos(x + 2) = 0 Then Exit For
                        For Y = 0 To 2
                            If (PltVal(Y, x) / BSBootReps) >= BSCutOff Then
                                OKPair(Y) = 1
                            End If
                        Next Y
                    Next x
                Else
                    For x = 1 To PE
                        If PltPos(x + 2) = 0 Then Exit For
                        For Y = 0 To 2
                            If (PltVal(Y, x) / BSBootReps) >= BSCutOff Then
                                OKPair(Y) = 1
                            End If
                        Next Y
                    Next x
                    For x = PS To CLng(Len(StrainSeq(0)) / BSStepSize) - 1
                        If PltPos(x + 2) = 0 Then Exit For
                        For Y = 0 To 2
                            If (PltVal(Y, x) / BSBootReps) >= BSCutOff Then
                                OKPair(Y) = 1
                            End If
                        Next Y
                    Next x
                End If
                
                
                
                If RS < RE Then
                    XOverLen = XPosDiff(RE) - XPosDiff(RS)
                    For x = XPosDiff(RS) To XPosDiff(RE)
                        A = A + Scores(x, ScoreP)
                    Next x
                    For x = 1 To XPosDiff(RS) - 1
                        C = C + Scores(x, ScoreP)
                    Next x
                    For x = XPosDiff(RE) + 1 To LenXoverSeq
                        C = C + Scores(x, ScoreP)
                    Next x
                Else
                    XOverLen = XPosDiff(RE) + (LenXoverSeq - XPosDiff(RS))
                    For x = XPosDiff(RE) + 1 To XPosDiff(RS) - 1
                        C = C + Scores(x, ScoreP)
                    Next x
                    For x = 1 To XPosDiff(RE)
                        A = A + Scores(x, ScoreP)
                    Next x
                    For x = XPosDiff(RS) To LenXoverSeq
                        A = A + Scores(x, ScoreP)
                    Next x
                End If
            
            If BSPValFlag = 1 Then
                'Using binomial dist
                'IndProb = C / (LenXoverSeq - XOverLen) '0.25 ' ((1 - Distance(hi1, Hi2))) / ((1 - Distance(hi1, LO)) + (1 - Distance(Hi2, LO)) + (1 - Distance(hi1, Hi2)))
                IndProb = (C + A)
                If LenXoverSeq = 0 Then Exit Sub
                IndProb = IndProb / (LenXoverSeq)
                'LenXoverSeq = CLng(d1 + d2 + d3 - Abs(d2 - d3) - Abs(d1 - d2) - Abs(d1 - d3))
                If XOverLen > 2 Then
                                        If XOverLen >= 170 Then
                                            A = CLng(A * 169 / XOverLen)
                                            AFact = XOverLen / 169
                                            XOverLen = 169
                                            
                                        Else
                                            AFact = 1
                                        End If
                        'C routine that calculates the probability of the "recomination" having occured by chance.
                    ProbabilityXOver = ProbCalc(Fact(0), XOverLen, A, IndProb, LenXoverSeq)
                    If ProbabilityXOver > 1 Then
                        ProbabilityXOver = 1
                    End If
                                
                    ProbabilityXOver = ProbabilityXOver ^ AFact
                '11,10,0.177,304'9.507
                x = x
                Else
                    ProbabilityXOver = 1
                End If
                
            ElseIf BSPValFlag = 2 Then
                
                    C = CLng(C * (XOverLen / LenXoverSeq))
                    b = XOverLen - A
                    D = XOverLen - C
                    If (A + C > 0) And (b + D > 0) Then
                        HMChi = (A * D - b * C) ^ 2 * XOverLen * 2
                        HMChi = HMChi / (A + b)
                        HMChi = HMChi / (C + D)
                        HMChi = HMChi / (A + C)
                        HMChi = HMChi / (b + D)
                        If HMChi > 0 Then
                            ProbabilityXOver = ChiPVal(HMChi)
                        Else
                            ProbabilityXOver = 1
                        End If
                    Else
                       ProbabilityXOver = 1
                    End If
                    'ProbabilityXOver = ProbabilityXOver * (LenXoverSeq / (XOverLen * 2))
                
                
            End If
            
            If pMCFlag = 0 Then
                ProbabilityXOver = ProbabilityXOver * MCCorrection
            ElseIf pMCFlag = 2 Then
                ProbabilityXOver = StepDown2(2, ProbabilityXOver)
            End If
            
    
            If RE > RS Then
                ProbX = Decompress(RS) + (Decompress(RE) - Decompress(RS)) / 2
            Else
                If Len(StrainSeq(0)) - RS > RE Then
                    ProbX = Decompress(RS) + (Decompress(Len(StrainSeq(0))) - Decompress(RS)) / 2
                Else
                    ProbX = 1 + Decompress(RE) / 2
                End If
            End If
            If BSCutOff < 0.9 Then
                ProbY = 1
            Else
                ProbY = 0.85
            End If
            ProbTest = ProbabilityXOver
            MinPA = ProbabilityXOver
            If MinPA > 0 And (OKPair(0) = 1 Or OKPair(1) = 1 Or OKPair(2) = 1) Then
                If MinPA < 1 Then
                    If SPF = 0 Then
                        If DontRedrawPlotsFlag = 0 Then

                            'Call PrintProbability
                        End If
                        If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                            XoverList(RelX, RelY).Probability = ProbabilityXOver
                        End If
                    End If
                    If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                        BestParent = CheckParent: WinMethod = 2
                        BestParentP = MinPA
                    End If
                    
                End If
                If LongWindedFlag = 0 Then
                    EN = XoverList(RelX, RelY).Eventnumber
                Else
                    EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
                End If
                
                If XoverList(RelX, RelY).ProgramFlag <> 2 And XoverList(RelX, RelY).ProgramFlag <> 2 + AddNum Then
                    If Confirm(EN, 2) > 0 Then
                        If Abs(ConfirmP(EN, 2)) < 300 Then
                            PT = 10 ^ (-ConfirmP(EN, 2))
                        Else
                            PT = 10 ^ 300
                        End If
                    Else
                        PT = 1
                    End If
                    
                    If (Confirm(EN, 2) = 0 Or (Confirm(EN, 2) = 1 And MinPA < PT)) And MinPA < 1 Then
                        Confirm(EN, 2) = 1
                        ConfirmP(EN, 2) = -Log10(MinPA)
                        
            
                        If Form1.HScroll3.Value = 0 Then
                            Form1.HScroll3.Value = 1
                        Else
                            Form1.HScroll3.Value = 0
                        End If
                        
                    End If
            
                End If
            End If
    End If
    
    If BestRescanFlag = 1 And MinPA < BestRescanP And MinPA < LowestProb And MinPA > 0 Then
        BestRescanP = MinPA
    End If
    
    Zero = 0
    One = 1
    Two = 2
    If (FindallFlag = 0 And SPF = 0 And BestRescanFlag = 0 And UpdateIDFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
        
        ReDim GPVTFont(5, 100), GPVText(100)
        GPVTNum = -1
        s1colb = LYellow
        s1col = Yellow
        s2colb = LGreen
        s2col = Green
        s3colb = LPurple
        s3col = Purple
        
        
        
        
        
        'Draw the axes
        'Form1.Picture7.Picture = LoadPicture()
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, 100, 0, 1, "Bootstrap support (%)")
    
        Form1.Picture7.DrawWidth = 3
        PosCount = 0
        ReDim MCPrintPos(Len(StrainSeq(0)))
        ReDim MCPrintData(2, Len(StrainSeq(0)))
    
        Do While PltPos(PosCount + 2) > 0
            'Exit Sub
            MCPrintPos(PosCount) = PltPos(PosCount)
            MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSBootReps) * 100
            MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSBootReps) * 100
            MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSBootReps) * 100
            PosCount = PosCount + 1
            Pict = Form1.Picture7.hdc
            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
'                Form1.Picture7.ForeColor = s3colb
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount - 1)) * xFactor, 20 + (1 - PltVal(2, PosCount - 1) / BSBootReps) * (PicHeight - 35), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, 20 + (1 - PltVal(2, PosCount) / BSBootReps) * (PicHeight - 35))
'                Form1.Picture7.ForeColor = s2colb
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount - 1)) * xFactor, 20 + (1 - PltVal(1, PosCount - 1) / BSBootReps) * (PicHeight - 35), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, 20 + (1 - PltVal(1, PosCount) / BSBootReps) * (PicHeight - 35))
'                Form1.Picture7.ForeColor = s1colb
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount - 1)) * xFactor, 20 + ((1 - PltVal(0, PosCount - 1) / BSBootReps) * (PicHeight - 35)), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, (20 + ((1 - PltVal(0, PosCount) / BSBootReps) * (PicHeight - 35))))
            End If
        Loop
    
        Form1.Picture7.DrawWidth = 1
        If DontRedrawPlotsFlag = 0 Then

            Call Highlight(0)
        End If
        'Draw cutoff line
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.DrawStyle = 2
        
       
        MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
        LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
        Form1.Picture7.DrawStyle = 0
    
        PosCount = 0
    
        Do While PltPos(PosCount + 2) > 0
            MCPrintPos(PosCount) = PltPos(PosCount)
            MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSBootReps) * 100
            MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSBootReps) * 100
            MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSBootReps) * 100
            PosCount = PosCount + 1
            Pict = Form1.Picture7.hdc
            If MissingData(PosCount * BSStepSize, Seq1) = 0 And MissingData(PosCount * BSStepSize, Seq2) = 0 And MissingData(PosCount * BSStepSize, Seq3) = 0 Then
'                Form1.Picture7.ForeColor = s1col
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount - 1)) * xFactor, 20 + ((1 - PltVal(0, PosCount - 1) / BSBootReps) * (PicHeight - 35)), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, (20 + ((1 - PltVal(0, PosCount) / BSBootReps) * (PicHeight - 35))))
'                Form1.Picture7.ForeColor = s3col
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount - 1)) * xFactor, 20 + (1 - PltVal(2, PosCount - 1) / BSBootReps) * (PicHeight - 35), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, 20 + (1 - PltVal(2, PosCount) / BSBootReps) * (PicHeight - 35))
'                Form1.Picture7.ForeColor = s2col
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount - 1)) * xFactor, 20 + (1 - PltVal(1, PosCount - 1) / BSBootReps) * (PicHeight - 35), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * xFactor, 20 + (1 - PltVal(1, PosCount) / BSBootReps) * (PicHeight - 35))
            End If
        Loop
    
    
    
        PosCount = PosCount - 1
        'Get everything into the standard format for printing and saving
        NumLines = 6 'number of lines to print
        ReDim GPrint(NumLines - 1, PosCount + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, PosCount + 1)
    
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = XDiffPos(x)
        Next x
        ReDim GCritval(10)
        GCritval(0) = BSCutOff * 100
        GLegend = "Bootstrap support (%)"
        GPrintLen = PosCount + 1 'how many points to plot
        GPrintCol(0) = Yellow 'line is yellow
        GPrintCol(1) = Green 'line is green
        GPrintCol(2) = Purple ''line is purple
        GPrintCol(3) = Yellow 'line is yellow
        GPrintCol(4) = Green 'line is green
        GPrintCol(5) = Purple ''line is purple
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        Dim Div As Double
        Div = (Int(XOverWindowX / 2) * 2 + 1)
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = 100 'upper val
        
        MCPrintPos(PosCount) = PltPos(PosCount)
        MCPrintData(0, PosCount) = (PltVal(Zero, PosCount) / BSBootReps) * 100
        MCPrintData(1, PosCount) = (PltVal(One, PosCount) / BSBootReps) * 100
        MCPrintData(2, PosCount) = (PltVal(Two, PosCount) / BSBootReps) * 100
        
        For x = 1 To PosCount
            For Y = 0 To 2
                GPrint(Y, x) = MCPrintData(Y, x)
                GPrint(Y + 3, x) = MCPrintData(Y, x)
                GPrintPos(Y, x) = MCPrintPos(x)
                GPrintPos(Y + 3, x) = MCPrintPos(x)
            Next Y
        Next x
        
        
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
    
    End If
    
    
    
    If BestRescanFlag = 0 Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
    
        If TManFlag = -1 And SPF = 0 And DontRedrawPlotsFlag = 0 Then
    
            If DoScans(0, 2) = 1 And ((Form1.Combo1.ListIndex = 2 And ExeCheckFlag = 1) Or ExeCheckFlag = 0) Then
                If WN1 < UBound(SubMaskSeq, 1) Then
                    WN1 = SubMaskSeq(Seq1)
                Else
                    WN1 = TreeTrace(Seq1)
                End If
                If WN2 < UBound(SubMaskSeq, 1) Then
                    WN2 = SubMaskSeq(Seq2)
                Else
                    WN2 = TreeTrace(Seq2)
                End If
                If WN3 < UBound(SubMaskSeq, 1) Then
                    WN3 = SubMaskSeq(Seq3)
                Else
                    WN3 = TreeTrace(Seq3)
                End If

                WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
                Call WriteNames(WN1, WN2, WN3, s1col, s2col, s3col)
    
            Else
                WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
                Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
    
            End If
    
        End If
     Call PrintProbability
        Call RedrawPlotAA(1)
        
        MinPAGlobal = MinPA
    End If
     
    
End Sub



Public Sub BootscanChecking()
Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking Bootscan results
    OptFlag = -1
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11 'Hourglass
    End If
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 2 Or AllCheckFlag = 1 Then

        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else
            'Only draw it if it has not already been drawn

            
                'Sort out plot colours
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                
                Call FindSubSeqBS
                
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                

            

        End If
    ElseIf CurrentCheck = 0 Then
        XOverWindowX = CDbl(Form3.Text2.Text)
        xSpacerFlag = SpacerFlag
        
        Call XOverIII(0)
        
        SpacerFlag = xSpacerFlag
        
        Call FindSubSeqBS
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
        Call FindSubSeqBS
        
    ElseIf CurrentCheck = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        Call GCCheck(0)
        
        Call FindSubSeqBS
    ElseIf CurrentCheck = 16 Then
        Call TSXOverC
        Call FindSubSeqBS
    

    ElseIf CurrentCheck = 3 Then
        'Only draw it if it has not already been drawn

        
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            

       

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqBS
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        
            
            Call LXoverB(0, 1)

            

    ElseIf CurrentCheck = 7 Then



    ElseIf CurrentCheck = 8 Then

        Call DXoverE
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

       
            Call TXover3

           

        

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqBS
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)
    End If

    'Need to get a string of variable sites for the sequence display.

    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    AllowExtraSeqsFlag = 0
    SpacerNo = 0
    Screen.MousePointer = 0 'Change back to default
End Sub

Public Sub RDPChecking()
    Dim WeightMod() As Long, Scratch() As Integer, OS1 As Long, OS2 As Long, OS3 As Long
    'This is the subroutine that is called when checking RDP results
    
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    OptFlag = -1
    'Call ModSeqNum(XOverList(RelX, RelY).Beginning, XOverList(RelX, RelY).Ending, 0)
    'Call ModNextno
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 0 Or AllCheckFlag = 1 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        XX = Seq2
        Call XOverIII(0)
       
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        'If togglex = 0 Then
            Call GCCheck(0)
            
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        Call FindSubSeqRDP
      
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
        Call FindSubSeqRDP
     ElseIf CurrentCheck = 16 Then
        Call TSXOverC
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 2 Then
        
        
        'Erase XDiffpos
        'Erase XPosDiff
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then
            Call FindSubSeqBS
            Call BSXoverl(0)

        Else

            
                
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

               

            

        End If
        
        Call FindSubSeqRDP

    ElseIf CurrentCheck = 3 Then
        
        
        
        
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())


        
        
       ' Call FindSubSeqRDP

    ElseIf CurrentCheck = 4 Then
        
        Call MCXoverG(0)
        
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 5 Then
        
        Call SSXoverB(0)
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 6 Then

       
            
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)
            
            Call FindSubSeqRDP

           

        

    ElseIf CurrentCheck = 7 Then

  

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            
            Call TXover3

           
            
            Call FindSubSeqRDP

        
    ElseIf CurrentCheck = 10 Then
        
        Call CXoverC(0)
        Call FindSubSeqRDP
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2

    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)
    End If
    Dim AH(2) As Long
    If CurrentCheck <> 0 Then
        If SpacerFlag > 0 And SpacerNo > 0 Then
            ReDim XoverSeqNumW(Len(StrainSeq(0)) + XoverWindow * 2, 2)
            ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
            ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
            'C routine for finding information rich subsequences (it does the same thing as the
            'VB routine FindSubSeqRDP())
            'Call FindSubSeqRDP
            'This could be speeded up with better nesting
            LenXoverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
        Else
    
            Call FindSubSeqRDP
    
        End If
    End If
    Erase XoverSeqNum
    Erase XoverSeqNumW
    Erase XOverHomologyNum
    '@
    If oPointer <> Screen.MousePointer Then
        Screen.MousePointer = oPointer
    End If
    
    
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    
End Sub

Public Sub PhylProChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking RDP results
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    OptFlag = -1
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        
        Call XOverIII(0)
        
        SpacerFlag = xSpacerFlag
        Call FindSubSeqPP
    ElseIf CurrentCheck = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        'If togglex = 0 Then
            Call GCCheck(0)
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        Call FindSubSeqPP
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
        
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else

            
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                

            

        End If
        
        Call FindSubSeqPP

    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
       
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

           

       
        
        Call FindSubSeqPP

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqPP
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
        Call FindSubSeqPP
    ElseIf CurrentCheck = 6 Then

        
            
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)
            
            Call FindSubSeqPP

            

        
        Call FindSubSeqPP
    ElseIf CurrentCheck = 7 Then


    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqPP
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            
            Call TXover3

            
            
            Call FindSubSeqPP

        
    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqPP
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)

    End If
    Dim AH(2) As Long
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqpP)
        'Call FindSubSeqpP
        'This could be speeded up with better nesting
        ReDim XoverSeqNumW(Len(StrainSeq(0)) + XoverWindow * 2, 2)
        ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
        ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
        LenXoverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
    Else

        Call FindSubSeqPP

    End If
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
End Sub
Public Sub GCChecking2()
Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking RDP results
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    OptFlag = -1
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 1 Or AllCheckFlag = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        'If togglex = 0 Then
            Call GCCheck(0)
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        
        Call XOverIII(0)
        Call FindSubSeqGC2
        SpacerFlag = xSpacerFlag
    
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 16 Then
        Call TSXOverC
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else

            
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())


            

        End If
        
        Call FindSubSeqGC2

    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
       
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            

        
        
        Call FindSubSeqGC2

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        
            
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)
            
            Call FindSubSeqGC2

            

       

    ElseIf CurrentCheck = 7 Then


    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            
            Call TXover3

           
            
            Call FindSubSeqGC2

        
    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqGC2
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)

    End If
    Dim AH(2) As Long
    'XX = UBound(XOverSeqNumW, 1)
    'yy = UBound(XOverSeqNumW, 2)
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqRDP)
        'call FindSubSeqGC2
        'This could be speeded up with better nesting
        ReDim XoverSeqNumW(Len(StrainSeq(0)) + XoverWindow * 2, 2)
        ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
        ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        UB = 0
        UB = UBound(ValidSpacer, 1)
        If UB = 0 Then
            ReDim ValidSpacer(NextNo)
        End If
        On Error GoTo 0
        LenXoverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
    Else

        Call FindSubSeqGC2

    End If
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
End Sub
Public Sub MaxChiChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking MaxChi results with triplet scanning
    OptFlag = -1
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 4 Or AllCheckFlag = 1 Then

        Call MCXoverG(0)
    ElseIf CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        Call XOverIII(0)
        
        Call GetXOSMC
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
        Call GetXOSMC
    ElseIf CurrentCheck = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        Call GCCheck(0)

        Call GetXOSMC
     ElseIf CurrentCheck = 16 Then
        Call TSXOverC
        Call GetXOSMC
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else
            
            
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                

            
        End If
        
        Call GetXOSMC
        
    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            

        
        
        Call GetXOSMC

    
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 6 Then

        
            'Call ModSeqNum(0)
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)

            
            
            Call GetXOSMC
            'Call UnModSeqNum(0)
        
    ElseIf CurrentCheck = 7 Then

        

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call GetXOSMC
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            
            Call TXover3

            
            
            Call GetXOSMC

       

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call GetXOSMC
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)

    End If
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    SpacerNo = 0
    AllowExtraSeqsFlag = 0
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
End Sub
Public Sub ChimaeraChecking()
    'This is the subroutine that is called when checking Chimaera results with triplet scanning
    Dim WeightMod() As Long, Scratch() As Integer
    OptFlag = -1
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 10 Or AllCheckFlag = 1 Then

        Call CXoverC(0)
        
        Call FindSubSeqChi
    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
        Call FindSubSeqChi
    ElseIf CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        Call XOverIII(0)
        
        Call FindSubSeqChi
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
        Call FindSubSeqChi
    ElseIf CurrentCheck = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        Call GCCheck(0)

        Call FindSubSeqChi

    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else
            
            
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

                

           

        End If
        
        Call FindSubSeqChi
        
    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

           

        
        
        Call FindSubSeqChi

    
        
    ElseIf CurrentCheck = 5 Then

        Call SSXoverB(0)
        
        Call FindSubSeqChi
        
    ElseIf CurrentCheck = 6 Then

        
            
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)

            
            Call FindSubSeqChi

      
    ElseIf CurrentCheck = 7 Then

        

    ElseIf CurrentCheck = 16 Then
        Call TSXOverC
        Call FindSubSeqChi
    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqChi
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            XX = LenXoverSeq
            Call TXover3

            
            
            Call FindSubSeqChi

        
    
        
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)
    End If
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    SpacerNo = 0
    AllowExtraSeqsFlag = 0
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
End Sub

Public Sub SiScanChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking MaxChi results with triplet scanning
    OptFlag = -1
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 5 Or AllCheckFlag = 1 Then

        Call SSXoverB(0)
    ElseIf CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        Call XOverIII(0)
        
        Call FindSubSeqSS(1, SSOLoSeq)
        
        SpacerFlag = xSpacerFlag
    ElseIf CurrentCheck = 1 Then
        If Len(StrainSeq(0)) >= 30000 Then
            Call GCCompare
        End If
        Call GCCheck(0)

        Call FindSubSeqSS(1, SSOLoSeq)
     ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
       Call FindSubSeqSS(1, SSOLoSeq)
     ElseIf CurrentCheck = 16 Then
        Call TSXOverC
        Call FindSubSeqSS(1, SSOLoSeq)
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else
            
            
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

               
            

        End If
        
        Call FindSubSeqSS(1, SSOLoSeq)
        
    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
       
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
           
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

            

       
        
        Call FindSubSeqSS(1, SSOLoSeq)

    ElseIf CurrentCheck = 4 Then

        Call MCXoverG(0)
        
    
    ElseIf CurrentCheck = 6 Then

        
            
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)

            
            
            Call FindSubSeqSS(1, SSOLoSeq)

        
    ElseIf CurrentCheck = 7 Then

        

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        
        Call FindSubSeqSS(1, SSOLoSeq)
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            
            Call TXover3

            
            
            Call FindSubSeqSS(1, SSOLoSeq)

       

    ElseIf CurrentCheck = 10 Then

        Call CXoverC(0)
        Call FindSubSeqSS(1, SSOLoSeq)
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2
    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)

    End If
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    SpacerNo = 0
    AllowExtraSeqsFlag = 0
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
End Sub
Public Sub MaxChiCheckingII()
    'This is the subroutine that is called when checking MaxChi results when
    'entire dataset was scanned simmultaneously
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If

    If CurrentCheck = 20 Then

        Call GCDraw

    ElseIf CurrentCheck = 21 And NoMCFlag = 0 Then

        Call MCXoverI

    ElseIf CurrentCheck = 22 Then

        

    ElseIf CurrentCheck = 23 Then

        Call DXoverG

    ElseIf CurrentCheck = 24 Then

        Call RecOverview2

    End If
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1.Value = 0
        Call UpdateF2Prog
    End If
    
    
End Sub
Public Sub DoCombo(TypeA As Byte)
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
    If TypeA = 0 Then
        Form1.Combo1.Enabled = True
         Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
        Form1.Combo1.Clear
        Form1.Combo1.BackColor = QBColor(15)
        Form1.Combo1.AddItem "RDP", 0
        Form1.Combo1.AddItem "GENECONV", 1
        Form1.Combo1.AddItem "Bootscan", 2
        Form1.Combo1.AddItem "Re-Bootscan", 3
        Form1.Combo1.AddItem "MaxChi", 4
        Form1.Combo1.AddItem "Chimaera", 5
        Form1.Combo1.AddItem "SiScan", 6
        Form1.Combo1.AddItem "3Seq", 7
        Form1.Combo1.AddItem "BURT", 8
        Form1.Combo1.AddItem "PhylPro", 9
        Form1.Combo1.AddItem "VisRD Highway", 10
        Form1.Combo1.AddItem "VisRD Occupancy", 11
        Form1.Combo1.AddItem "TOPAL DSS", 12
        Form1.Combo1.AddItem "Distance Plot", 13
        Form1.Combo1.AddItem "LARD", 14
        
        
        
        Form1.Combo1.AddItem "Overview", 15
        Form1.Combo1.AddItem "Recomb. Event Map", 16
        'Form1.Combo1.AddItem "Event Density", 14
        Form1.Combo1.AddItem "Breakpnt Distribtn", 17
        Form1.Combo1.AddItem "Breakpnt P-Distributn", 18
    Else
        Form1.Combo1.Clear
        Form1.Combo1.BackColor = QBColor(15)
        Form1.Combo1.AddItem "GENECONV", 0
        Form1.Combo1.AddItem "MaxChi", 1
        Form1.Combo1.AddItem "PhylPro", 2
        'Form1.Combo1.AddItem "Reticulate", 3
        Form1.Combo1.AddItem "Distance Plot", 3
        Form1.Combo1.AddItem "Overview", 4
    End If
    
    DontDoComboFlag = 1

    If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
        Form1.Combo1.ListIndex = 0
    ElseIf XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
        Form1.Combo1.ListIndex = 7
    ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Then
        If pGCTripletflag = 0 Then
            Form1.Combo1.ListIndex = 0
        Else
            Form1.Combo1.ListIndex = 1
        End If
    ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Then
        Form1.Combo1.ListIndex = 2
    ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then

        If MCTripletFlag = 0 Then
            Form1.Combo1.ListIndex = 4
        Else
            Form1.Combo1.ListIndex = 1
        End If
    ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Then
        Form1.Combo1.ListIndex = 5
    ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
        Form1.Combo1.ListIndex = 6
        ElseIf XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then
        Form1.Combo1.ListIndex = 9
    End If
    DontDoComboFlag = 0
    Form1.Combo1.Enabled = True
    If XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
         Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    End If
    

End Sub
Public Sub GCChecking()
    'This is the subroutine that is called when checking GENECONV results
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If

    If CurrentCheck = 20 Then

        Call GCDraw

    ElseIf CurrentCheck = 21 And NoMCFlag = 0 Then

        If XoverList(RelX, RelY).OutsideFlag = 0 Then

            If (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And XoverList(RelX, RelY).OutsideFlag = 1 Then
            Else

                Call MCXoverI
                 Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
            End If

        End If

    ElseIf CurrentCheck = 22 Then

        

    ElseIf CurrentCheck = 23 Then
        SS = Abs(GetTickCount)
        Call DXoverG
        EE = Abs(GetTickCount)
        TT = EE - SS
    ElseIf CurrentCheck = 24 Then

        Call RecOverview2

    End If

    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1.Value = 0
        Call UpdateF2Prog
    End If
    
End Sub

Public Sub ResizeForm3()
    Dim QuarterFrame As Long, TextWidth As Long, TextLeft As Long, ButtonWidth As Long, ButtonLeft As Long, FullFrame As Long, HalfFrame As Long, HalfLeft As Long, FullLeft As Long
    
    With Form3
        '.Left = 700
        '.Top = 100
        'ZZ = .Width
        .Width = 10000
        .Height = 6500
        'Sort out spacing of the background area
        .Frame1.Left = 0
        .Frame1.Top = 0
        
        .Frame1.Width = .Width
        .Frame1.Height = .Height
        .TabStrip1.Left = 0
        .TabStrip1.Height = .Frame1.Height
        
        .TabStrip1.Width = .Frame1.Width
        
        .TabStrip1.Top = 0
        .TabStrip2.Left = 0
        .TabStrip2.Height = .Frame1.Height
        .TabStrip2.Width = .Frame1.Width
        .TabStrip2.Top = 0
        .TabStrip2.TabFixedWidth = .TabStrip2.Width - 4 * Screen.TwipsPerPixelX
        .TabStrip2.Font.Size = 12
        .TabStrip2.Font.Bold = True

        Dim x As Integer

        For x = 0 To 15
            .Frame2(x).Top = 950
            .Frame2(x).Left = 200
            .Frame2(x).Width = .Width - 400
            .Frame2(x).Height = 4650
        Next 'X

        '.frame2(0) - General .options
        
        FullFrame = .Width - 600 '8190
        FullLeft = 100
        HalfFrame = ((FullFrame - FullLeft) / 2) '3995
        HalfLeft = HalfFrame + FullLeft * 2
        QuarterFrame = HalfFrame - FullLeft * 2
        ButtonWidth = .Command7.Width
        ButtonLeft = HalfFrame - ButtonWidth - FullLeft
        TextWidth = 500
        TextLeft = HalfFrame - FullLeft - TextWidth
       
        
        
        
        
        
        
       
        
        '.frame9.Left = 100
        '.frame9.Top = 1800
        '.frame9.Width = 5900
        '.frame9.Height = 700
        
        .Frame27.Left = HalfLeft
        .Frame27.Top = 200
        .Frame27.Width = HalfFrame
        .Frame27.Height = 2750
        
        .Check10.Left = 200
        .Check10.Top = 300
        
        .Check9.Left = 200
        .Check9.Top = 650
        
        .Check11.Left = 200
        .Check11.Top = 900
        
        .Check13.Left = 200
        .Check13.Top = 1250
        
        
        .Label15.Left = 200
        .Label15.Top = 1700
        .Label15.Width = 3000
        .Label15.Height = 350
        .Command8.Top = 1650
        .Command8.Left = ButtonLeft
        
        .Label20.Left = 200
        .Label20.Top = 2050
        .Label20.Width = 3000
        .Label20.Height = 350
        .Command5.Top = 2000
        .Command5.Left = ButtonLeft
        
        .Label43.Left = 200
        .Label43.Top = 2400
        .Command7.Top = 2350
        .Command7.Left = ButtonLeft
        
        .Frame10.Left = 100
        .Frame10.Top = 200
        .Frame10.Width = HalfFrame
        .Frame10.Height = 1350
        
        .Command2.Left = ButtonLeft
        .Command2.Top = 250
        '.command2.Width = 1000
        '.command2.Height = 350
        .Label16.Left = 200
        .Label16.Top = 300
        .Label16.Width = 2100
        .Label16.Height = 350
        .Text3.Left = TextLeft
        .Text3.Top = 600
        .Text3.Width = 500
        .Text3.Height = 300
        .Label18.Left = 200
        .Label18.Top = 650
        .Label18.Width = 3000
        .Label18.Height = 350
        .Label23.Left = 200
        .Label23.Top = 1000
        .Label23.Width = 2500
        .Label23.Height = 350
        .Command16.Top = 950
        .Command16.Left = ButtonLeft
        
        
        
        .Frame8.Top = 1600
        .Frame8.Left = 100
        .Frame8.Width = HalfFrame
        .Frame8.Height = 1350
        .Combo5.Left = 200
        .Combo5.Top = 300
        .Combo5.Width = HalfFrame - 400
        .Label1(53).Top = 300
        .Label1(53).Left = 200
        .Text1(37).Top = 250
        .Text1(37).Left = TextLeft
        .Text1(37).Width = TextWidth
        .Text1(37).Height = 200
        
        .Label1(54).Top = 650
        .Label1(54).Left = 200
        
        
        .Command3.Left = ButtonLeft
        .Command3.Top = 600
        
        .Frame9.Left = 100
        .Frame9.Top = 3050
        .Frame9.Width = FullFrame
        .Frame9.Height = 1500

        Dim ColBoxDim As Integer

        '            .label50.Top = 300
        '           .label50.Left = 600
        ColBoxDim = 200
        .Check4.Left = 250
        .Check4.Top = 200
        .Check14.Left = 450
        .Check14.Top = 200
        
        .Picture26(0).Width = ColBoxDim
        .Picture26(0).Height = ColBoxDim
        .Picture26(0).Left = .Check4.Left + 1425
        .Picture26(0).Top = 250
        .Picture26(0).BackColor = ProgColour(0)
        
        .Check5.Left = 250
        .Check5.Top = 550
        .Check15.Left = 450
        .Check15.Top = 550
        
        .Picture26(1).Width = ColBoxDim
        .Picture26(1).Height = ColBoxDim
        .Picture26(1).Left = .Check5.Left + 1425
        .Picture26(1).Top = 600
        .Picture26(1).BackColor = ProgColour(1)
        
        .Check3.Left = 2175
        .Check3.Top = 200
        .Check18.Left = 2375
        .Check18.Top = 200
        
        .Picture26(4).Width = ColBoxDim
        .Picture26(4).Height = ColBoxDim
        .Picture26(4).Left = .Check3.Left + 1425
        .Picture26(4).Top = 250
        .Picture26(4).BackColor = ProgColour(4)
        
        .Check2.Left = 2175
        .Check2.Top = 550
        .Check17.Left = 2375
        .Check17.Top = 550
        
        .Picture26(3).Width = ColBoxDim
        .Picture26(3).Height = ColBoxDim
        .Picture26(3).Left = .Check2.Left + 1425
        .Picture26(3).Top = 600
        .Picture26(3).BackColor = ProgColour(3)
        
        .Check1.Left = 4100
        .Check1.Top = 200
        .Check16.Left = 4300
        .Check16.Top = 200
        
        .Picture26(2).Width = ColBoxDim
        .Picture26(2).Height = ColBoxDim
        .Picture26(2).Left = .Check1.Left + 1425
        .Picture26(2).Top = 250
        .Picture26(2).BackColor = ProgColour(2)
        
        .Check6.Left = 4100
        .Check6.Top = 550
        .Check19.Left = 4300
        .Check19.Top = 550
        
        .Picture26(5).Width = ColBoxDim
        .Picture26(5).Height = ColBoxDim
        .Picture26(5).Left = .Check6.Left + 1425
        .Picture26(5).Top = 600
        .Picture26(5).BackColor = ProgColour(5)
        
        .Check12.Left = 6025
        .Check12.Top = 200
        .Check20.Left = 6225
        .Check20.Top = 200
        
        .Picture26(6).Width = ColBoxDim
        .Picture26(6).Height = ColBoxDim
        .Picture26(6).Left = .Check12.Left + 1425
        .Picture26(6).Top = 250
        .Picture26(6).BackColor = ProgColour(8) 'ProgColour(6)
        '.Picture26(6).Enabled = False
        
        .Check21.Left = 6025
        .Check21.Top = 550
        .Check22.Left = 6025
        .Check22.Top = 550
        
        .Picture26(7).Width = ColBoxDim
        .Picture26(7).Height = ColBoxDim
        .Picture26(7).Left = .Check21.Left + 1425
        .Picture26(7).Top = 600
        .Picture26(7).BackColor = ProgColour(7)
        
        For x = 0 To 6
        .Picture26(x).ZOrder
        Next x
        .Picture27.Height = 250
        .Picture27.Width = FullFrame - 500
        .Picture27.Left = 250
        .Picture27.Top = 1150
        .Label60.Top = 900
        .Label60.Left = 250
        .Label60.Width = 4000
        
        '.option buttons
        .Frame12.Top = 200
        .Frame12.Left = 100
        .Frame12.Width = FullFrame
        .Frame12.Height = 3000

        For x = 0 To 4
            .Frame4(x).Top = 200
            .Frame4(x).Left = 4000
            .Frame4(x).Visible = False
        Next 'X

        .Frame4(SpacerFlag).Visible = True
        .Option2.Top = 300
        .Option2.Left = 210
        .Option3.Top = 700
        .Option3.Left = 210
        .Option4.Top = 1100
        .Option4.Left = 210
        .Option5.Top = 1500
        .Option5.Left = 210
        .Option6.Top = 1900
        .Option6.Left = 210
        
        '.labels for .option buttons
        .Label4.Top = 300
        .Label4.Left = 600
        .Label5.Top = 700
        .Label5.Left = 600
        .Label6.Top = 1100
        .Label6.Left = 600
        .Label7.Top = 1500
        .Label7.Left = 600
        .Frame3.Left = 480
        .Frame3.Top = 1900
        .Frame11.Top = 3300
        .Frame11.Left = 100
        .Frame11.Width = FullFrame
        .Frame11.Height = 1250
        .Text2.Left = TextLeft
        .Text2.Top = 200
        .Text2.Width = TextWidth
        .Text2.Height = 300
        .Label17.Left = 250
        .Label17.Top = 250
        .Label17.Width = 1000
        .Label17.Height = 350
        .Label49.Top = 550
        .Label49.Left = 250
        .Text7 = MiDistance * 100
        .Text8 = MaDistance * 100
        .Text7.Top = 800
        .Text7.Left = 250
        .Text7.Width = 600
        .Label25.Top = 850
        .Label25.Left = 850
        .Text8.Top = 800
        .Text8.Left = 1300
        .Text8.Width = 600
        .Label24.Top = 850
        .Label24.Left = 1950
        
        
        '.frame2(2) - GC .options

        For x = 0 To 8
            .Command28(x).MouseIcon = Form1.Command18.MouseIcon
            .Command28(x).MousePointer = 99
        Next 'X

        .Frame14.Top = 200
        .Frame14.Left = 100
        .Frame14.Width = HalfFrame
        .Frame14.Height = 1800
        
        .Label39.Top = 220
        .Label39.Left = 100
        .Command28(8).Top = 200
        .Command28(8).Left = ButtonLeft
        
        .Label29.Top = 520
        .Label29.Left = 100
        .Command28(2).Top = 500
        .Command28(2).Left = ButtonLeft
        
        .Label32.Top = 820
        .Label32.Left = 100
        .Command28(4).Top = 800
        .Command28(4).Left = ButtonLeft
        
        .Label31.Top = 1120
        .Label31.Left = 100
        .Command28(3).Top = 1100
        .Command28(3).Left = ButtonLeft
        
        .Label47.Top = 1420
        .Label47.Left = 100
        .Text21.Top = 1400
        .Text21.Left = 1800
        .Text21.Width = 600
        .Label48.Top = 1420
        .Label48.Left = 2500
        .Text22.Top = 1400
        .Text22.Left = 2700
        .Text22.Width = 600
        .Frame13.Top = 2150
        .Frame13.Left = 100
        .Frame13.Width = HalfFrame
        .Frame13.Height = 2400
        .Label26.Top = 220
        .Label26.Left = 100
        
        
        
        
        
        .Label27.Top = 520
        .Label27.Left = 100
        .Command28(0).Top = 500
        .Command28(0).Left = ButtonLeft
        .Label33.Top = 820
        .Label33.Left = 100
        
        
        
        .Command29.Top = 800
        .Command29.Width = 990
        .Command29.Left = HalfFrame - FullLeft - .Command29.Width
        
        .Command28(5).Top = 800
        .Command28(5).Left = .Command29.Left - .Command28(5).Width
        
        .Label34.Top = 1120
        .Label34.Left = 100
        .Command28(6).Top = 1100
        .Command28(6).Left = ButtonLeft
        .Label30.Top = 1420
        .Label30.Left = 100
        .Text10.Top = 1400
        .Text10.Left = TextLeft
        .Text10.Width = TextWidth
        .Text10.Height = 290
        .Label35.Top = 1720
        .Label35.Left = 100
        .Text11.Top = 1700
        .Text11.Left = TextLeft
        .Text11.Width = TextWidth
        .Text11.Height = 290
        .Label28.Top = 2020
        .Label28.Left = 100
        .Command28(1).Top = 2000
        .Command28(1).Left = ButtonLeft
        .Frame15.Top = 200
        .Frame15.Left = HalfLeft
        .Frame15.Width = HalfFrame
        .Frame15.Height = 2800
        .Label36.Top = 220
        .Label36.Left = 100
        .Text12.Top = 200
        .Text12.Left = TextLeft
        .Text12.Width = TextWidth
        .Text12.Height = 200
        .Label38.Top = 520
        .Label38.Left = 100
        .Text14.Top = 600
        .Text14.Left = TextLeft
        .Text14.Width = TextWidth
        .Text14.Height = 200
        .Label37.Top = 1020
        .Label37.Left = 100
        .Text13.Top = 1100
        .Text13.Left = TextLeft
        .Text13.Width = TextWidth
        .Text13.Height = 200
        .Label40.Top = 1520
        .Label40.Left = 100
        .Text15.Top = 1500
        .Text15.Left = TextLeft
        .Text15.Width = TextWidth
        .Text15.Height = 200
        .Label41.Top = 1820
        .Label41.Left = 100
        .Text16.Top = 1800
        .Text16.Left = TextLeft
        .Text16.Width = TextWidth
        .Text16.Height = 200
        .Label42.Top = 2120
        .Label42.Left = 100
        .Text17.Top = 2100
        .Text17.Left = TextLeft
        .Text17.Width = TextWidth
        .Text17.Height = 200
        .Label44.Top = 2420
        .Label44.Left = 100
        .Text18.Top = 2400
        .Text18.Left = TextLeft
        .Text18.Width = TextWidth
        .Text18.Height = 200
        .Frame16.Top = 3150
        .Frame16.Left = HalfLeft
        .Frame16.Width = HalfFrame
        .Frame16.Height = 1400
        .Label45.Top = 220
        .Label45.Left = 100
        .Text19.Top = 300
        .Text19.Left = TextLeft
        .Text19.Width = TextWidth
        .Text19.Height = 200
        .Label46.Top = 720
        .Label46.Left = 100
        .Text20.Top = 700
        .Text20.Left = TextLeft
        .Text20.Width = TextWidth
        .Text20.Height = 200
        .Label59.Top = 1020
        .Label59.Left = 100
        .Command28(7).Left = ButtonLeft
        .Command28(7).Top = 1000
        
        'Bootscan .options
        .Frame5.Top = 150
        .Frame5.Left = 100
        .Frame5.Width = HalfFrame
        .Frame5.Height = 2350
        .Label1(0).Top = 220
        .Label1(0).Left = 100
        .Text1(0).Top = 200
        .Text1(0).Left = TextLeft
        .Text1(0).Width = TextWidth
        .Text1(0).Height = 200
        .Label1(1).Top = 520
        .Label1(1).Left = 100
        .Text1(1).Top = 500
        .Text1(1).Left = TextLeft
        .Text1(1).Width = TextWidth
        .Text1(1).Height = 200
        .Label1(37).Top = 820
        .Label1(37).Left = 100
        .Command28(23).Top = 800
        .Command28(23).Left = ButtonLeft
        .Label1(2).Top = 1120
        .Label1(2).Left = 100
        .Text1(2).Top = 1100
        .Text1(2).Left = TextLeft
        .Text1(2).Width = TextWidth
        .Text1(2).Height = 200
        .Label1(3).Top = 1420
        .Label1(3).Left = 100
        .Text1(3).Top = 1400
        .Text1(3).Left = TextLeft
        .Text1(3).Width = TextWidth
        .Text1(3).Height = 200
        .Label1(6).Top = 1720
        .Label1(6).Left = 100
        .Text1(5).Top = 1700
        .Text1(5).Left = TextLeft
        .Text1(5).Width = TextWidth
        .Text1(5).Height = 200
        
        .Label1(48).Top = 2020
        .Label1(48).Left = 100
        .Command28(28).Top = 2000
        .Command28(28).Left = ButtonLeft
        
        .Frame7(0).Top = 150
        .Frame7(0).Left = HalfLeft
        .Frame7(0).Width = HalfFrame
        .Frame7(0).Height = 2350
        .Label1(4).Top = 220
        .Label1(4).Left = 100
        .Command28(9).Top = 200
        .Command28(9).Left = ButtonLeft
        .Label1(5).Top = 520
        .Label1(5).Left = 100
        .Text1(4).Top = 500
        .Text1(4).Left = TextLeft
        .Text1(4).Width = TextWidth
        .Text1(4).Height = 200
        .Label1(39).Top = 820
        .Label1(39).Left = 100
        .Text1(28).Top = 800
        .Text1(28).Left = TextLeft
        .Text1(28).Width = TextWidth
        .Text1(28).Height = 200
        .Frame21(5).Top = 1100
        .Frame21(5).Left = 100
        .Frame21(5).Width = QuarterFrame
        .Frame21(5).Height = 1125
        .Label21(34).Top = 220
        .Label21(34).Left = 100
        .Command28(24).Top = 200
        .Command28(24).Left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(32).Top = 520
        .Label21(32).Left = 100
        .Text23(28).Top = 500
        .Text23(28).Left = 1000
        .Text23(28).Width = TextWidth
        .Text23(28).Height = 200
        .Label21(30).Top = 820
        .Label21(30).Left = 100
        .Text23(26).Top = 800
        .Text23(26).Left = 1000
        .Text23(26).Width = TextWidth
        .Text23(26).Height = 200
        .Label21(31).Top = 520
        .Label21(31).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(27).Top = 500
        .Text23(27).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(27).Width = TextWidth
        .Text23(27).Height = 200
        .Label21(33).Top = 820
        .Label21(33).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(29).Top = 800
        .Text23(29).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(29).Width = TextWidth
        .Text23(29).Height = 200
        .Frame17.Top = 150
        .Frame17.Left = HalfLeft
        .Frame17.Width = HalfFrame
        .Frame17.Height = 4375
        .Label1(8).Top = 220
        .Label1(8).Left = 100
        .Text1(6).Top = 200
        .Text1(6).Left = TextLeft
        .Text1(6).Width = TextWidth
        .Text1(6).Height = 200
        .Label1(9).Top = 520
        .Label1(9).Left = 100
        .Text1(7).Top = 500
        .Text1(7).Left = TextLeft
        .Text1(7).Width = TextWidth
        .Text1(7).Height = 200
        .Label1(38).Top = 820
        .Label1(38).Left = 100
        .Command28(25).Top = 800
        .Command28(25).Left = ButtonLeft
        .Label1(12).Top = 1120
        .Label1(12).Left = 100
        .Text1(10).Top = 1100
        .Text1(10).Left = TextLeft
        .Text1(10).Width = TextWidth
        .Text1(10).Height = 200
        .Check7.Top = 1350
        .Check7.Left = 100
        .Check8.Top = 1950
        .Check8.Left = 100
        .Frame18.Top = 2300
        .Frame18.Left = 100
        .Frame18.Width = QuarterFrame
        .Frame18.Height = 1100
        .Label1(14).Top = 220
        .Label1(14).Left = 100
        .Text1(11).Top = 200
        .Text1(11).Left = QuarterFrame - TextWidth - FullLeft
        .Text1(11).Width = TextWidth
        .Text1(11).Height = 200
        .Label1(7).Top = 220
        .Label1(7).Left = 100
        .Text1(8).Top = 200
        .Text1(8).Left = QuarterFrame - TextWidth - FullLeft
        .Text1(8).Width = TextWidth
        .Text1(8).Height = 200
        .Label1(15).Top = 520
        .Label1(15).Left = 100
        .Text1(12).Top = 500
        .Text1(12).Left = QuarterFrame - TextWidth - FullLeft
        .Text1(12).Width = TextWidth
        .Text1(12).Height = 200
        .Label1(10).Top = 520
        .Label1(10).Left = 100
        .Text1(9).Top = 500
        .Text1(9).Left = QuarterFrame - TextWidth - FullLeft
        .Text1(9).Width = TextWidth
        .Text1(9).Height = 200
        
        'MaxChi .options
        .Frame23.Top = 200
        .Frame23.Left = 100
        .Frame23.Width = HalfFrame
        .Frame23.Height = 2200
        .Label1(13).Top = 320
        .Label1(13).Left = 100
        .Command28(13).Top = 300
        .Command28(13).Left = ButtonLeft
        .Label1(11).Top = 720
        .Label1(11).Left = 100
        .Command28(12).Top = 700
        .Command28(12).Left = ButtonLeft
        .Label1(27).Top = 1120
        .Label1(27).Left = 100
        .Text1(21).Top = 1100
        .Text1(21).Left = TextLeft
        .Text1(21).Width = TextWidth
        .Text1(21).Height = 200
        
        .Label1(16).Top = 1520
        .Label1(16).Left = 100
        .Command28(14).Top = 1500
        .Command28(14).Left = ButtonLeft
        
        
        
        
        
        
        'Chimaera options
        .Frame28(0).Top = 200
        .Frame28(0).Left = 100
        .Frame28(0).Width = HalfFrame
        .Frame28(0).Height = 1300
        
        .Label1(55).Top = 320
        .Label1(55).Left = 100
        .Command28(39).Top = 300
        .Command28(39).Left = ButtonLeft
        .Label1(56).Top = 720
        .Label1(56).Left = 100
        .Text1(36).Top = 700
        .Text1(36).Left = TextLeft
        .Text1(36).Width = TextWidth
        .Text1(36).Height = 200
        
        
        'VisRD options
        .Frame28(1).Top = 200
        .Frame28(1).Left = 100
        .Frame28(1).Width = HalfFrame
        .Frame28(1).Height = 750
        
        
        .Label1(70).Top = 320
        .Label1(70).Left = 100
        .Text1(44).Top = 300
        .Text1(44).Left = TextLeft
        .Text1(44).Width = TextWidth
        .Text1(44).Height = 200
        
        
        'SiScan
        
        .Frame26(0).Top = 200
        .Frame26(0).Left = 100
        .Frame26(0).Width = HalfFrame
        .Frame26(0).Height = 1950
        
        .Label22(0).Top = 320
        .Label22(0).Left = 100
        
        .Text24(0).Top = 300
        .Text24(0).Left = TextLeft
        .Text24(0).Width = TextWidth
        .Text24(0).Height = 200
        
        .Label22(1).Top = 720
        .Label22(1).Left = 100
        
        .Text24(1).Top = 700
        .Text24(1).Left = TextLeft
        .Text24(1).Width = TextWidth
        .Text24(1).Height = 200
        
        
        .Label22(3).Top = 1120
        .Label22(3).Left = 100
        
        .Command28(33).Top = 1080
        .Command28(33).Left = ButtonLeft
        
        .Label22(4).Top = 1520
        .Label22(4).Left = 100
        
        .Command28(36).Top = 1480
        .Command28(36).Left = ButtonLeft
        
        .Frame26(2).Top = 200
        .Frame26(2).Left = HalfLeft
        .Frame26(2).Width = HalfFrame
        .Frame26(2).Height = 1950
        
        .Label22(2).Top = 320
        .Label22(2).Left = 100
        
        .Text24(2).Top = 300
        .Text24(2).Left = TextLeft
        .Text24(2).Width = TextWidth
        .Text24(2).Height = 200
        
        .Label22(8).Top = 720
        .Label22(8).Left = 100
        
        .Text24(4).Top = 700
        .Text24(4).Left = TextLeft
        .Text24(4).Width = TextWidth
        .Text24(4).Height = 200
        
        .Label22(7).Top = 1120
        .Label22(7).Left = 100
        
        .Text24(3).Top = 1100
        .Text24(3).Left = TextLeft
        .Text24(3).Width = TextWidth
        .Text24(3).Height = 200
        
        .Label22(6).Top = 1520
        .Label22(6).Left = 100
        
        .Command28(34).Top = 1480
        .Command28(34).Left = ButtonLeft
        
        .Frame26(1).Top = 2200
        .Frame26(1).Left = 100
        .Frame26(1).Width = HalfFrame
        .Frame26(1).Height = 720
        
        .Label22(5).Top = 300
        .Label22(5).Left = 100
        
        .Command28(35).Top = 280
        .Command28(35).Left = ButtonLeft
        
        'Phylpro Options
        .Frame30(0).Top = 200
        .Frame30(0).Left = 100
        .Frame30(0).Width = HalfFrame
        .Frame30(0).Height = 1520
        
        .Label14(0).Left = 100
        .Label14(0).Top = 320
        .Text4(0).Top = 300
        .Text4(0).Left = TextLeft
        .Text4(0).Width = TextWidth
        .Text4(0).Height = 200
        
        .Label14(1).Left = 100
        .Label14(1).Top = 720
        .Command28(37).Top = 680
        .Command28(37).Left = ButtonLeft
        
        .Label14(2).Left = 100
        .Label14(2).Top = 1120
        .Command28(38).Top = 1080
        .Command28(38).Left = ButtonLeft
        
        .Frame30(1).Top = 1820
        .Frame30(1).Left = 100
        .Frame30(1).Width = HalfFrame
        .Frame30(1).Height = 1120
        
        .Label14(3).Left = 100
        .Label14(3).Top = 320
        .Text4(1).Top = 300
        .Text4(1).Left = TextLeft
        .Text4(1).Width = TextWidth
        .Text4(1).Height = 200
        
        .Label14(4).Left = 100
        .Label14(4).Top = 720
        .Text4(2).Top = 700
        .Text4(2).Left = TextLeft
        .Text4(2).Width = TextWidth
        .Text4(0).Height = 200
        
        'LARD .options
        .Frame19.Top = 200
        .Frame19.Left = 100
        .Frame19.Width = FullFrame
        .Frame19.Height = 3000
        
        .Label21(0).Top = 320
        .Label21(0).Left = 100
        .Command28(10).Top = 280
        .Command28(10).Left = ButtonLeft
        .Label21(6).Top = 620
        .Label21(6).Left = 100
        .Text23(5).Top = 600
        .Text23(5).Left = TextLeft
        .Text23(5).Width = TextWidth
        .Text23(5).Height = 200
        .Label21(7).Top = 920
        .Label21(7).Left = 100
        .Text23(6).Top = 900
        .Text23(6).Left = TextLeft
        .Text23(6).Width = TextWidth
        .Text23(6).Height = 200
        .Label21(12).Top = 1220
        .Label21(12).Left = 100
        .Text23(11).Top = 1200
        .Text23(11).Left = TextLeft
        .Text23(11).Width = TextWidth
        .Text23(11).Height = 200
        .Frame21(2).Top = 1520
        .Frame21(2).Left = 100
        .Frame21(2).Width = QuarterFrame
        .Frame21(2).Height = 1320
        .Label21(16).Top = 320
        .Label21(16).Left = 100
        .Text23(13).Top = 300
        .Text23(13).Left = 1070
        .Text23(13).Width = TextWidth
        .Text23(13).Height = 200
        .Label21(18).Top = 620
        .Label21(18).Left = 100
        .Text23(15).Top = 600
        .Text23(15).Left = 1070
        .Text23(15).Width = TextWidth
        .Text23(15).Height = 200
        .Label21(14).Top = 920
        .Label21(14).Left = 100
        .Text23(16).Top = 900
        .Text23(16).Left = 1070
        .Text23(16).Width = TextWidth
        .Text23(16).Height = 200
        .Label21(17).Top = 320
        .Label21(17).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(14).Top = 300
        .Text23(14).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(14).Width = TextWidth
        .Text23(14).Height = 200
        .Label21(15).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Label21(15).Top = 600
        .Text23(12).Top = 600
        .Text23(12).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(12).Width = TextWidth
        .Text23(12).Height = 200
        .Label21(19).Top = 920
        .Label21(19).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(17).Top = 900
        .Text23(17).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(17).Width = TextWidth
        .Text23(17).Height = 200
        .Frame21(1).Top = 200
        .Frame21(1).Left = HalfLeft
        .Frame21(1).Width = QuarterFrame
        .Frame21(1).Height = 1320
        .Label21(13).Top = 320
        .Label21(13).Left = 100
        .Command28(11).Top = 280
        .Command28(11).Left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(10).Top = 620
        .Label21(10).Left = 100
        .Text23(9).Top = 600
        .Text23(9).Left = 1070
        .Text23(9).Width = TextWidth
        .Text23(9).Height = 200
        .Label21(8).Top = 920
        .Label21(8).Left = 100
        .Text23(7).Top = 900
        .Text23(7).Left = 1070
        .Text23(7).Width = TextWidth
        .Text23(7).Height = 200
        .Label21(9).Top = 620
        .Label21(9).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(8).Top = 600
        .Text23(8).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(8).Width = TextWidth
        .Text23(8).Height = 200
        .Label21(11).Top = 920
        .Label21(11).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(10).Top = 900
        .Text23(10).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(10).Width = TextWidth
        .Text23(10).Height = 200
        .Frame21(0).Top = 1520
        .Frame21(0).Left = HalfLeft
        .Frame21(0).Width = QuarterFrame
        .Frame21(0).Height = 1320
        .Label21(3).Top = 320
        .Label21(3).Left = 100
        .Text23(2).Top = 300
        .Text23(2).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(2).Width = TextWidth
        .Text23(2).Height = 200
        .Label21(4).Top = 620
        .Label21(4).Left = 100
        .Text23(3).Top = 600
        .Text23(3).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(3).Width = TextWidth
        .Text23(3).Height = 200
        .Label21(5).Top = 920
        .Label21(5).Left = 100
        .Text23(4).Top = 900
        .Text23(4).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(4).Width = TextWidth
        .Text23(4).Height = 200
        .Frame20.Top = 3300
        .Frame20.Left = 100
        .Frame20.Width = FullFrame
        .Frame20.Height = 1250
        .Label21(1).Top = 320
        .Label21(1).Left = 100
        .Label21(41).Top = .Label21(4).Top
        .Label21(41).Left = .Label21(1).Left
        
        
        .Text23(0).Top = 300
        .Text23(0).Left = TextLeft
        .Text23(0).Width = TextWidth
        .Text23(0).Height = 200
        .Label21(2).Top = 320
        .Label21(2).Left = HalfLeft
        .Command28(40).Top = 300
        .Command28(40).Left = 7700
        .Label21(40).Top = .Label21(41).Top
        .Label21(40).Left = HalfLeft
        .Command28(41).Top = 600
        .Command28(41).Left = 7700
        
        .Text23(1).Top = 600
        .Text23(1).Left = TextLeft
        .Text23(1).Width = TextWidth
        .Text23(1).Height = 200
        'Reticulate .options
        
        
        '.Frame6(1).Top = 150
        '.Frame6(1).left = 100 'halfleft
        '.Frame6(1).Width = HalfFrame
        '.Frame6(1).Height = 2700
       
        
        .Frame25(0).Top = 150 '.Combo1.Top + .Combo1.Height + 10
        .Frame25(0).Left = 100
        .Frame25(0).Width = FullFrame
        
        
        .Combo1.Top = 300
        .Combo1.Width = 3000
        .Combo1.Left = ButtonLeft - .Combo1.Width + .Command28(29).Width
        
        '.Combo1.Top = 260
        '.Combo1.Width = 2800
        '.Combo1.left = ButtonLeft - .Combo1.Width + .Command28(29).Width
        
        .Combo1.AddItem "Compaibility matrix (Ingrid Jakobsen)"
        .Combo1.AddItem "Compaibility matrix (Trevor Bruen)"
        .Combo1.AddItem "Compaibility matrix (Robinson-Foulds)"
        .Combo1.AddItem "Compaibility matrix (Shimodaira-Hasegawa)"
        .Combo1.AddItem "Modularity matrix"
        .Combo1.AddItem "Recombination matrix"
        .Combo1.AddItem "Recombinant region count matrix"
        .Combo1.AddItem "Breakpoint matrix"
        .Combo1.AddItem "Breakpoint distribution plot"
        .Combo1.ListIndex = 0
        
        .Label3.Top = 320
        .Label3.Left = 100
        
        .Label1(17).Top = 720
        .Label1(17).Left = 100
        
        .Command28(15).Top = 700
        .Command28(15).Left = ButtonLeft
        
        .Label1(22).Top = 1120
        .Label1(22).Left = 100
        .Combo2.Top = 1100
        .Combo2.Left = .Command28(15).Left - (.Combo2.Width - .Command28(15).Width)
        
        .Label1(26).Top = 1520
        .Label1(26).Left = 100
        .Text5(0).Top = 1500
        .Text5(0).Left = .Command28(15).Left - (.Text5(0).Width - .Command28(15).Width)
        
        .Label1(57).Top = 1920
        .Label1(57).Left = 100
        
        For x = 1 To 8
            .Text5(x).Top = 1900
            .Text5(x).Left = .Command28(15).Left - (.Text5(1).Width - .Command28(15).Width)
        Next x
        
        .Text5(9).Top = 2300
        .Text5(9).Left = .Command28(15).Left - (.Text5(1).Width - .Command28(15).Width)
        
        .Label1(73).Top = 2320
        .Label1(73).Left = 100
        
        .Label1(58).Top = 2720
        .Label1(58).Left = 100
        
        .Picture1.Height = .Text5(1).Height
        .Picture1.Width = .Combo2.Width - .Command28(15).Width
        .Picture1.Left = .Combo2.Left
        .Picture1.Top = 2700
        
        .Command28(19).Left = .Command28(15).Left
        .Command28(19).Width = .Command28(15).Width
        .Command28(19).Height = .Command28(15).Height
        .Command28(19).Top = 2700
        
        .Frame25(0).Height = .Picture1.Top + 420
        
        'Recombination rate options
        
        .Label2(0).Top = 320
        .Label2(0).Left = 100
        
        .Text6(0).Top = 300
        .Text6(0).Left = TextLeft
        .Text6(0).Width = TextWidth * 2
        .Text6(0).Height = 200
        
        .Label2(1).Top = 720
        .Label2(1).Left = 100
                
        .Text6(1).Top = 700
        .Text6(1).Left = TextLeft
        .Text6(1).Width = TextWidth * 2
        .Text6(1).Height = 200
        
        .Label2(2).Top = 1120
        .Label2(2).Left = 100
        
        .Text6(2).Top = 1100
        .Text6(2).Left = TextLeft
        .Text6(2).Width = TextWidth * 2
        .Text6(2).Height = 200
        
        .Label2(3).Top = 1520
        .Label2(3).Left = 100
        
        .Text6(3).Top = 1500
        .Text6(3).Left = TextLeft
        .Text6(3).Width = TextWidth * 2
        .Text6(3).Height = 200
        
        .Label2(4).Top = 1920
        .Label2(4).Left = 100
        
        .Command28(42).Top = 1880
        .Command28(42).Left = .Text6(0).Left + .Text6(0).Width - ButtonWidth
                
        .Label2(5).Top = 2320
        .Label2(5).Left = 100
        
        
        .Text6(4).Top = 2300
        .Text6(4).Left = TextLeft
        .Text6(4).Width = TextWidth * 2
        .Text6(4).Height = 200
        
        .Label2(6).Top = 2720
        .Label2(6).Left = 100
                
        .Text6(5).Top = 2700
        .Text6(5).Left = TextLeft
        .Text6(5).Width = TextWidth * 2
        .Text6(5).Height = 200
        
        'SCHEMA options
        
        
        .Frame29(2).Top = 300
        .Frame29(2).Left = 100
        .Frame29(2).Width = FullFrame
        .Frame29(2).Height = 1200
        
        .Label2(7).Top = 320
        .Label2(7).Left = 100
        
        .Text6(6).Top = 320
        .Text6(6).Left = TextLeft - TextWidth
        .Text6(6).Width = TextWidth * 2
        .Text6(6).Height = 200
        
        .Label19.Top = 720
        .Label19.Left = 100
        .Combo4.Top = 720
        .Combo4.Left = TextLeft - TextWidth * 3
        .Combo4.Width = TextWidth * 4
        '.Combo4.Height = 200
        
        .Frame29(0).Top = 1600
        .Frame29(0).Left = 100
        .Frame29(0).Width = FullFrame
        .Frame29(0).Height = 700
        
        .Label2(13).Top = 320
        .Label2(13).Left = 100
        
        .Text6(11).Top = 300
        .Text6(11).Left = TextLeft
        .Text6(11).Width = TextWidth
        .Text6(11).Height = 200
        
        .Frame29(1).Top = 2400
        .Frame29(1).Left = 100
        .Frame29(1).Width = FullFrame
        .Frame29(1).Height = 1200
        
        .Label2(9).Top = 320
        .Label2(9).Left = 100
        
        
        .Text6(7).Top = 300
        .Text6(7).Left = TextLeft
        .Text6(7).Width = TextWidth
        .Text6(7).Height = 200
        
        .Label2(8).Top = 720
        .Label2(8).Left = 100
        
        .Command28(50).Top = 700
        .Command28(50).Left = ButtonLeft
        
        
        'Distance plot .options
        .Frame24(0).Top = 200
        .Frame24(0).Left = 100
        .Frame24(0).Width = HalfFrame
        .Frame24(0).Height = 1100
        .Label1(18).Top = 320
        .Label1(18).Left = 100
        .Text1(13).Top = 300
        .Text1(13).Left = TextLeft
        .Text1(13).Width = TextWidth
        .Text1(13).Height = 200
        .Label1(19).Top = 720
        .Label1(19).Left = 100
        .Text1(14).Top = 700
        .Text1(14).Left = TextLeft
        .Text1(14).Width = TextWidth
        .Text1(14).Height = 200
        .Frame24(1).Top = 1300
        .Frame24(1).Left = 100
        .Frame24(1).Width = HalfFrame
        .Frame24(1).Height = 3120
        .Label1(21).Top = 320
        .Label1(21).Left = 100
        .Command28(18).Top = 280
        .Command28(18).Left = ButtonLeft
        .Label1(20).Top = 720
        .Label1(20).Left = 100
        .Text1(15).Top = 700
        .Text1(15).Left = TextLeft
        .Text1(15).Width = TextWidth
        .Text1(15).Height = 200
        .Label1(40).Top = 1120
        .Label1(40).Left = 100
        .Text1(29).Top = 1100
        .Text1(29).Left = TextLeft
        .Text1(29).Width = TextWidth
        .Text1(29).Height = 200
        .Frame21(3).Top = 1500
        .Frame21(3).Left = 100
        .Frame21(3).Width = QuarterFrame
        .Frame21(3).Height = 1520
        .Label21(20).Top = 320
        .Label21(20).Left = 100
        .Command28(17).Top = 280
        .Command28(17).Left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(22).Top = 720
        .Label21(22).Left = 100
        .Text23(19).Top = 700
        .Text23(19).Left = 1020
        .Text23(19).Width = TextWidth
        .Text23(19).Height = 200
        .Label21(23).Top = 1120
        .Label21(23).Left = 100
        .Text23(20).Top = 1100
        .Text23(20).Left = 1020
        .Text23(20).Width = TextWidth
        .Text23(20).Height = 200
        .Label21(24).Top = 720
        .Label21(24).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(21).Top = 700
        .Text23(21).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(21).Width = TextWidth
        .Text23(21).Height = 200
        .Label21(21).Top = 1120
        .Label21(21).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(18).Top = 1100
        .Text23(18).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(18).Width = TextWidth
        .Text23(18).Height = 200
        'TOPAL .options
        .Frame24(3).Top = 200
        .Frame24(3).Left = 100
        .Frame24(3).Width = HalfFrame
        .Frame24(3).Height = 1500
        .Label1(30).Top = 320
        .Label1(30).Left = 100
        .Text1(22).Top = 300
        .Text1(22).Left = TextLeft
        .Text1(22).Width = TextWidth
        .Text1(22).Height = 200
        .Label1(29).Top = 720
        .Label1(29).Left = 100
        .Text1(19).Top = 700
        .Text1(19).Left = TextLeft
        .Text1(19).Width = TextWidth
        .Text1(19).Height = 200
        .Label1(31).Top = 1120
        .Label1(31).Left = 100
        .Text1(23).Top = 1100
        .Text1(23).Left = TextLeft
        .Text1(23).Width = TextWidth
        .Text1(23).Height = 200
        .Frame24(2).Top = 200
        .Frame24(2).Left = HalfLeft
        .Frame24(2).Width = HalfFrame
        .Frame24(2).Height = 3120
        .Label1(25).Top = 320
        .Label1(25).Left = 100
        .Command28(21).Top = 280
        .Command28(21).Left = ButtonLeft
        .Label1(28).Top = 720
        .Label1(28).Left = 100
        .Text1(16).Top = 700
        .Text1(16).Left = TextLeft
        .Text1(16).Width = TextWidth
        .Text1(16).Height = 200
        .Label1(41).Top = 1120
        .Label1(41).Left = 100
        .Text1(30).Top = 1100
        .Text1(30).Left = TextLeft
        .Text1(30).Width = TextWidth
        .Text1(30).Height = 200
        .Frame21(4).Top = 1500
        .Frame21(4).Left = 100
        .Frame21(4).Width = QuarterFrame
        .Frame21(4).Height = 1520
        .Label21(29).Top = 320
        .Label21(29).Left = 100
        .Command28(20).Top = 280
        .Command28(20).Left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(27).Top = 720
        .Label21(27).Left = 100
        .Text23(24).Top = 700
        .Text23(24).Left = 1020
        .Text23(24).Width = TextWidth
        .Text23(24).Height = 200
        .Label21(26).Top = 1120
        .Label21(26).Left = 100
        .Text23(23).Top = 1100
        .Text23(23).Left = 1020
        .Text23(23).Width = TextWidth
        .Text23(23).Height = 200
        .Label21(25).Top = 720
        .Label21(25).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(22).Top = 700
        .Text23(22).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(22).Width = TextWidth
        .Text23(22).Height = 200
        .Label21(28).Top = 1120
        .Label21(28).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(25).Top = 1100
        .Text23(25).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(25).Width = TextWidth
        .Text23(25).Height = 200
        .Frame24(4).Top = 1800
        .Frame24(4).Left = 100
        .Frame24(4).Width = HalfFrame
        .Frame24(4).Height = 1500
        .Label1(34).Top = 320
        .Label1(34).Left = 100
        .Command28(22).Top = 280
        .Command28(22).Left = ButtonLeft
        .Label1(33).Top = 720
        .Label1(33).Left = 100
        .Text1(25).Top = 700
        .Text1(25).Left = TextLeft
        .Text1(25).Width = TextWidth
        .Text1(25).Height = 200
        .Label1(32).Top = 1120
        .Label1(32).Left = 100
        .Text1(26).Top = 1100
        .Text1(26).Left = TextLeft
        .Text1(26).Width = TextWidth
        .Text1(26).Height = 200
        .Frame24(5).Top = 3400
        .Frame24(5).Left = 100
        .Frame24(5).Width = HalfFrame
        .Frame24(5).Height = 1100
        .Label1(36).Top = 320
        .Label1(36).Left = 100
        .Text1(27).Top = 300
        .Text1(27).Left = TextLeft
        .Text1(27).Width = TextWidth
        .Text1(27).Height = 200
        .Label1(35).Top = 720
        .Label1(35).Left = 100
        .Text1(24).Top = 700
        .Text1(24).Left = TextLeft
        .Text1(24).Width = TextWidth
        .Text1(24).Height = 200
        'bootstrap .options
        
        .Frame6(0).Top = 3000
        .Frame6(0).Left = 100
        .Frame6(0).Width = HalfFrame
        .Frame6(0).Height = 1500
        
        .Label1(71).Top = 320
        .Label1(71).Left = 100
        .Command28(48).Top = 300
        .Command28(48).Left = ButtonLeft
        '.Command28.Width = X
        '.Command28.Height = X
        
        .Label1(45).Top = 720
        .Label1(45).Left = 100
        .Text1(33).Top = 700
        .Text1(33).Left = TextLeft
        .Text1(33).Width = TextWidth
        .Text1(33).Height = 200
        .Label1(46).Top = 1120
        .Label1(46).Left = 100
        .Text1(34).Top = 1100
        .Text1(34).Left = TextLeft
        .Text1(34).Width = TextWidth
        .Text1(34).Height = 200
        
        
        'MCMC .options
        .Frame6(2).Top = 1800
        .Frame6(2).Left = HalfLeft
        .Frame6(2).Width = HalfFrame
        .Frame6(2).Height = 2700
        .Label1(64).Top = 320
        .Label1(64).Left = 100
        .Text1(39).Top = 300
        .Text1(39).Left = TextLeft - TextWidth
        .Text1(39).Width = TextWidth * 2
        .Text1(39).Height = 200
        
        .Label1(65).Top = 720
        .Label1(65).Left = 100
        
        .Text1(38).Top = 700
        .Text1(38).Left = TextLeft
        .Text1(38).Width = TextWidth
        .Text1(38).Height = 200
        .Label1(63).Top = 1120
        .Label1(63).Left = 100
        
        
        .Text1(40).Top = 1100
        .Text1(40).Left = TextLeft
        .Text1(40).Width = TextWidth
        .Text1(40).Height = 200
        .Label1(66).Top = 1520
        .Label1(66).Left = 100
        
        
        .Text1(41).Top = 1500
        .Text1(41).Left = TextLeft
        .Text1(41).Width = TextWidth
        .Text1(41).Height = 200
        
        
        .Label1(67).Top = 1920
        .Label1(67).Left = 100
        .Text1(42).Top = 1900
        .Text1(42).Left = TextLeft
        .Text1(42).Width = TextWidth
        .Text1(42).Height = 200
        
        
        .Label1(68).Top = 2320
        .Label1(68).Left = 100
        .Text1(43).Top = 2300
        .Text1(43).Left = TextLeft
        .Text1(43).Width = TextWidth
        .Text1(43).Height = 200
        
        
        .Frame6(1).Top = 150
        .Frame6(1).Left = 100 'halfleft
        .Frame6(1).Width = HalfFrame
        .Frame6(1).Height = 2700
        
        .Label1(23).Left = 100
        .Label1(23).Top = 320
        .Combo3.Top = 300
        .Combo3.Width = 3350
        .Combo3.Left = ButtonLeft - .Combo3.Width + .Command28(29).Width
        
        
        .Combo3.Clear
        .Combo3.AddItem "Neighbor joining"
        '.Combo3.AddItem "Least squares (FITCH)"
        .Combo3.AddItem "Max likelihood (PHYML/RAxML/FastTree)"
        .Combo3.AddItem "Bayesian (MrBayes)"
        .Combo3.ListIndex = 0
        
        .Label1(47).Top = 720
        .Label1(47).Left = 100
        .Text1(35).Top = 700
        .Text1(35).Left = TextLeft
        .Text1(35).Width = TextWidth
        .Text1(35).Height = 200
        .Label1(49).Top = 1120
        .Label1(49).Left = 100
        .Command28(29).Top = 1100
        .Command28(29).Left = ButtonLeft
        .Label1(50).Top = 1520
        .Label1(50).Left = 100
        .Command28(30).Top = 1500
        .Command28(30).Left = ButtonLeft
        .Label1(51).Top = 1920
        .Label1(51).Left = 100
        .Command28(31).Top = 1900
        .Command28(31).Left = ButtonLeft
        .Label1(52).Top = 2320
        .Label1(52).Left = 100
        .Command28(32).Top = 2300
        .Command28(32).Left = ButtonLeft
        
        .Frame7(1).Top = 150 '2250
        .Frame7(1).Left = HalfLeft '100
        .Frame7(1).Width = HalfFrame
        .Frame7(1).Height = 3075
        .Label1(44).Top = 320
        .Label1(44).Left = 100
        .Command28(27).Top = 300
        .Command28(27).Left = ButtonLeft
        .Label1(43).Top = 720
        .Label1(43).Left = 100
        .Text1(32).Top = 700
        .Text1(32).Left = TextLeft
        .Text1(32).Width = TextWidth
        .Text1(32).Height = 200
        .Label1(42).Top = 1120
        .Label1(42).Left = 100
        .Text1(31).Top = 1100
        .Text1(31).Left = TextLeft
        .Text1(31).Width = TextWidth
        .Text1(31).Height = 200
        .Frame21(6).Top = 1500
        .Frame21(6).Left = 100
        .Frame21(6).Width = QuarterFrame
        .Frame21(6).Height = 1475
        .Label21(35).Top = 320
        .Label21(35).Left = 100
        .Command28(26).Top = 300
        .Command28(26).Left = QuarterFrame - ButtonWidth - FullLeft
        .Label21(37).Top = 720
        .Label21(37).Left = 100
        .Text23(31).Top = 700
        .Text23(31).Left = 1000
        .Text23(31).Width = TextWidth
        .Text23(31).Height = 200
        .Label21(39).Top = 1120
        .Label21(39).Left = 100
        .Text23(33).Top = 1100
        .Text23(33).Left = 1000
        .Text23(33).Width = TextWidth
        .Text23(33).Height = 200
        .Label21(38).Top = 720
        .Label21(38).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(32).Top = 700
        .Text23(32).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(32).Width = TextWidth
        .Text23(32).Height = 200
        .Label21(36).Top = 1120
        .Label21(36).Left = QuarterFrame - TextWidth - FullLeft - 900
        .Text23(30).Top = 1100
        .Text23(30).Left = QuarterFrame - TextWidth - FullLeft
        .Text23(30).Width = TextWidth
        .Text23(30).Height = 200
        
        'ML specific model options
        .Frame7(2).Top = 150 '2250
        .Frame7(2).Left = HalfLeft '100
        .Frame7(2).Width = HalfFrame
        .Frame7(2).Height = 3100
        
        .Label1(69).Top = 320
        .Label1(69).Left = 100
        .Command28(47).Top = 300
        .Command28(47).Left = ButtonLeft
        
        .Label1(24).Top = 720
        .Label1(24).Left = 100
        .Command28(43).Top = 700
        .Command28(43).Left = ButtonLeft
        
        
        
        .Label1(59).Top = 1120
        .Label1(59).Left = 100
        .Text1(17).Top = 1100
        .Text1(17).Left = TextLeft
        .Text1(17).Width = TextWidth
        .Text1(17).Height = 200
        
        .Label1(60).Top = 1520
        .Label1(60).Left = 100
        .Text1(18).Top = 1500
        .Text1(18).Left = TextLeft
        .Text1(18).Width = TextWidth
        .Text1(18).Height = 200
        
        .Label21(46).Top = 1920
        .Label21(46).Left = 100
        .Command28(44).Top = 1900
        .Command28(44).Left = ButtonLeft
        
        .Label21(42).Top = 2320
        .Label21(42).Left = 100
        .Text23(34).Top = 2300
        .Text23(34).Left = TextLeft
        .Text23(34).Width = TextWidth
        .Text23(34).Height = 200
        
        .Text23(35).Top = 2300
        .Text23(35).Left = TextLeft
        .Text23(35).Width = TextWidth
        .Text23(35).Height = 200
        
        .Label21(52).Top = 2720
        .Label21(52).Left = 100
        .Text23(42).Top = 2700
        .Text23(42).Left = TextLeft
        .Text23(42).Width = TextWidth
        .Text23(42).Height = 200
         
        
        'tree search strat
        
        .Frame22.Top = 3400 '2250
        .Frame22.Left = HalfLeft '100
        .Frame22.Width = HalfFrame
        .Frame22.Height = 700
        
        .Label1(72).Top = 320
        .Label1(72).Left = 100
        .Command28(49).Top = 300
        .Command28(49).Left = ButtonLeft
        
        'Bayesian specific model options
        .Frame7(3).Top = 150 '2250
        .Frame7(3).Left = HalfLeft '100
        .Frame7(3).Width = HalfFrame
        .Frame7(3).Height = 1600
        .Label1(61).Top = 320
        .Label1(61).Left = 100
        .Command28(45).Top = 300
        .Command28(45).Left = ButtonLeft
        
        .Label21(51).Top = 720
        .Label21(51).Left = 100
        .Command28(46).Top = 700
        .Command28(46).Left = ButtonLeft
        
        
        
        .Label1(62).Top = 1120
        .Label1(62).Left = 100
        .Text1(20).Top = 1100
        .Text1(20).Left = TextLeft
        .Text1(20).Width = TextWidth
        .Text1(20).Height = 200
        
        'OK and Cancel Buttons
        .Command11.Height = 350
        .Command11.Top = .Frame2(0).Height + .Frame2(0).Top + (.Frame1.Height - (.Frame2(0).Top + .Frame2(0).Height) - .Command11.Height) / 2
        .Command11.Width = 1000
        .Command11.Left = (.Frame1.Width - .Command11.Width * 3) / 2
        .Command1.Top = .Command11.Top
        .Command1.Left = .Command11.Left
        
        .Command6.Top = .Command11.Top
        .Command6.Left = .Command11.Left + .Command11.Width + 50
        .Command6.Width = .Command11.Width
        .Command6.Height = .Command11.Height
        .Command4.Top = .Command11.Top
        .Command4.Left = .Command6.Left + .Command6.Width + 50
        .Command4.Width = .Command11.Width
        .Command4.Height = .Command11.Height
    End With

End Sub

Public Sub ResizeForm2()
    If CLine <> "" And CLine <> " " And CLine <> "EXCEPTION18102001" Then
        Exit Sub
    End If

    Dim OVx0 As Boolean, OVx1 As Boolean, OVx2 As Boolean, OVx3 As Boolean
    ReDim Preserve CurTree(4)
    ShowMapsFlag = 1
    Form1.ScaleMode = 1
    
    If Form2.Height < (300 * Screen.TwipsPerPixelY) Then
        Exit Sub
    End If
'    OVx0 = Form2.SSPanel1(0).Visible
'    OVx1 = Form2.SSPanel1(1).Visible
'    OVx2 = Form2.SSPanel1(2).Visible
'    OVx3 = Form2.SSPanel1(3).Visible
'
'    Form2.SSPanel1(0).Visible = False
'    Form2.SSPanel1(1).Visible = False
'    Form2.SSPanel1(2).Visible = False
'    Form2.SSPanel1(3).Visible = False
    
    Dim SizeMod As Single, F1S6W As Long, Index As Long, VSMax As Long, OV As Long, OM As Long, OVx As Single
    F1S6W = (FullSCreenWidth * 0.95) / 4 - 20 * Screen.TwipsPerPixelX 'Form1.SSPanel6(1).Width
    If F1S6W < 3000 Then
         F1S6W = FullSCreenWidth / 3 - 20 * Screen.TwipsPerPixelX 'Form1.SSPanel6(1).Width
    End If
    If ShowMapsFlag = 0 Then
        SizeMod = 0
    Else
        SizeMod = F1S6W / 3
    End If
    Dim OVis(3) As Boolean
    With Form2
'        OVis(0) = .SSPanel1(0).Visible
'        OVis(1) = .SSPanel1(1).Visible
'        OVis(2) = .SSPanel1(2).Visible
'        OVis(3) = .SSPanel1(3).Visible
'        .SSPanel1(0).Visible = False
'        .SSPanel1(1).Visible = False
'        .SSPanel1(2).Visible = False
'        .SSPanel1(3).Visible = False
        .ScaleMode = 1
        '.Top = 0
        If Form2.WindowState = 1 Then Form2.WindowState = 0
        Form2OHeight = Form2.Height
        
        Form2OWidth = 2 * F1S6W + SizeMod * 2 + 20 * Screen.TwipsPerPixelX
        .ScaleWidth = 2 * F1S6W + SizeMod * 2 + 20 * Screen.TwipsPerPixelX
        .ScaleMode = 1
        
        .SSPanel1(0).Left = 0 '4 * Screen.TwipsPerPixelX
        .SSPanel1(0).Top = 4 * Screen.TwipsPerPixelY
        .SSPanel1(0).Height = (.ScaleHeight - Form1.SSPanel7.Height - 8 * Screen.TwipsPerPixelY)
        .SSPanel1(0).Width = F1S6W + SizeMod
        .SSPanel1(1).Left = 0
        
        .SSPanel1(1).Top = 4 * Screen.TwipsPerPixelY
        .SSPanel1(1).Height = .SSPanel1(0).Height
        .SSPanel1(1).Width = F1S6W + SizeMod
        .SSPanel1(2).Left = .SSPanel1(0).Left + .SSPanel1(0).Width + 4 * Screen.TwipsPerPixelX '4 * Screen.TwipsPerPixelX
        .SSPanel1(2).Top = .SSPanel1(1).Top
        .SSPanel1(2).Height = .SSPanel1(0).Height
        .SSPanel1(2).Width = F1S6W + SizeMod
        
        '.SSPanel1(2).ZOrder
        .SSPanel1(3).Left = .SSPanel1(0).Left + .SSPanel1(0).Width + 4 * Screen.TwipsPerPixelX
        .SSPanel1(3).Top = .SSPanel1(1).Top
        .SSPanel1(3).Height = .SSPanel1(0).Height
        .SSPanel1(3).Width = F1S6W + SizeMod

        Dim x As Integer

        For x = 0 To 3
            .Command1(x).Height = Form1.Command1.Height
            .Command1(x).Width = Form1.Command1.Height
            .Command1(x).Top = 4 * Screen.TwipsPerPixelY
            .Command1(x).Left = .SSPanel1(0).Width - .Command1(x).Width - 4 * Screen.TwipsPerPixelX
        Next 'X

        For x = 0 To 3
            .Label1(x).Left = 4 * Screen.TwipsPerPixelX
            .Label1(x).Width = .SSPanel1(x).Width - .Label1(x).Left * 2 - .Command1(x).Width '.Command1(0).Left - 4 * Screen.TwipsPerPixelX
            .Label1(x).Height = Form1.Command1.Height + 2 * Screen.TwipsPerPixelY
            .Label1(x).Top = 7 * Screen.TwipsPerPixelY
            
            .Label5(x).Left = 4 * Screen.TwipsPerPixelX
            .Label5(x).Width = .Picture2(x).Width * 0.9 '.Command1(0).Left - 4 * Screen.TwipsPerPixelX
            .Label5(x).Height = Form1.Command1.Height + 2 * Screen.TwipsPerPixelY
            .Label5(x).Top = 23 * Screen.TwipsPerPixelY
            
        Next 'X
        Form2.FontSize = .Label5(0).FontSize

        If SmallF2LabelFlag = 1 Then
            For x = 0 To 3
                .Label5(x).Caption = "NB: May not be recombination"
                .Label1(x).Width = .Command1(0).Left - 4 * Screen.TwipsPerPixelX
            Next x
        
        End If
        
        
        For x = 0 To 1
            .SSPanel5(x).Top = .SSPanel1(0).Height - 85 * Screen.TwipsPerPixelY
            .SSPanel5(x).Left = 4 * Screen.TwipsPerPixelY
            .SSPanel5(x).Width = .SSPanel1(0).Width - Form1.VScroll1.Width - 12 * Screen.TwipsPerPixelX
            .SSPanel5(x).Height = 80 * Screen.TwipsPerPixelY
            .SSPanel5(x).BackColor = Form1.BackColor
        Next x
        If ShowMapsFlag = 0 Then
            .Picture3(0).Visible = False
            .Picture3(1).Visible = False
            .Picture3(2).Visible = False
            .Picture3(3).Visible = False
        Else
            .Picture3(0).Visible = True
            .Picture3(1).Visible = True
            .Picture3(2).Visible = True
            .Picture3(3).Visible = True
        
        End If
        For x = 0 To 3
            
            
            
            .Picture2(x).Left = 4 * Screen.TwipsPerPixelY
            .Picture2(x).Width = .SSPanel1(0).Width - SizeMod - Form1.VScroll1.Width - 12 * Screen.TwipsPerPixelX
            .Picture2(x).Top = .Label1(x).Top + .Label1(x).Height + 20 * Screen.TwipsPerPixelX
            If x = 1 Or x = 2 Then
                .Picture2(x).Height = .SSPanel1(0).Height - .Picture2(x).Top - 8 * Screen.TwipsPerPixelX - .SSPanel5(0).Height
            Else
                .Picture2(x).Height = .SSPanel1(0).Height - .Picture2(x).Top - 4 * Screen.TwipsPerPixelX
            End If
            .Picture2(x).ScaleMode = 3
            
            .Picture3(x).Left = .Picture2(x).Left + .Picture2(x).Width
            .Picture3(x).Width = SizeMod
            .Picture3(x).Top = .Picture2(x).Top
            .Picture3(x).Height = .Picture2(x).Height
            .Picture3(x).ScaleMode = 3
            
            
            
            '.Picture2(X).Top = 0
            '.Picture2(X).Left = 0
            '.Picture2(X).Height = Form1.Picture16.Height
            '.Picture2(X).Width = 3400 * HAddjust
            .VScroll1(x).Left = .Picture2(0).Left + .Picture2(0).Width + SizeMod + 4 * Screen.TwipsPerPixelX
            .VScroll1(x).Width = Form1.VScroll1.Width
            .VScroll1(x).Height = .Picture2(x).Height
            .VScroll1(x).Top = .Picture2(x).Top
            Index = x
            
            
            
            With .VScroll1(Index)
                
                VSMax = .Max
                
                OV = .Value
                OM = VSMax
                OVx = OV / OM
                If VSMax <= 0 Then .Value = 0
                Dim otTYF As Double, TYFM As Integer
                Call ModOffsets(8.25, Form2.Picture2(Index), otTYF, TYFM)
                
                If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBound(TreeDraw, 5) Then
                    VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200
                    VSC1NC = 0
                Else
                    VSC1NC = 1
                    VSMax = 0 '-Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
                End If
                If OM = 0 Then OM = 1
                If VSMax > 32000 Then
                    F2VSScaleFactor(Index) = VSMax / 32000
                    VSMax = 32000
                Else
                    F2VSScaleFactor(Index) = 1
                End If
                
                
                If VSMax > 0 Then
                    .Max = VSMax
                    If OVx * VSMax < VSMax Then
                        If Index = 0 Or Index = 3 Or DontUpdateVS1ValFlag = 0 Then
                            VSC1NC = 1
                            .Value = OVx * VSMax
                            VSC1NC = 0
                        End If
                    ElseIf VSMax > 0 Then
                        If Index = 0 Or Index = 3 Or DontUpdateVS1ValFlag = 0 Then
                            VSC1NC = 1
                            .Value = VSMax
                            VSC1NC = 0
                        End If
                    End If
                    If .Value > VSMax Then
                        VSC1NC = 1
                        .Value = VSMax
                        VSC1NC = 0
                    End If
                    If VSMax <= 0 Then
                        .Enabled = False
                    Else
                        .LargeChange = Form2.Picture2(Index).ScaleHeight
                        .Enabled = True
                    End If
                
                
                
                End If
                If TDLen(Index, CurTree(Index), 1) > 0 Then
                    If ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200 <= Form2.Picture2(Index).ScaleHeight Then
                         If .Value > 0 Then .Value = 0
                        .Enabled = False
                    Else
                        .Enabled = True
                        
                        '.VScroll1(X).Max = -.Picture2(X).ScaleHeight + (Nextno + 6) * 17
                        '.VScroll1(X).LargeChange = .Picture2(X).ScaleHeight
                    End If
                Else
                    .Enabled = False
                End If
                If .Enabled = True Then
                
                    If .Value > 0 Then
                        'F2ResizeFlag = 1
                        VSC1NC = 1
                       .Value = .Value - 1
                        'F2ResizeFlag = 0
                        VSC1NC = 0
                        .Value = .Value + 1
                    Else
                        'F2ResizeFlag = 1
                        VSC1NC = 1
                        .Value = 1
                        'F2ResizeFlag = 0
                        VSC1NC = 0
                        .Value = .Value - 1
                    End If
                End If
                '.Max = VSMax
            End With
            .Picture4(x).Top = .Picture2(x).Top - 20 * Screen.TwipsPerPixelY
            .Picture4(x).Left = .Picture3(x).Left - 20 * Screen.TwipsPerPixelX
            .Picture4(x).Width = .Picture3(x).Width + 39 * Screen.TwipsPerPixelX
            .Picture4(x).Height = 20 * Screen.TwipsPerPixelY
            .Picture4(x).BackColor = .Picture3(x).BackColor
            .Picture4(x).Picture = LoadPicture()
            .Picture4(x).AutoRedraw = 1
            .Picture4(x).ScaleMode = 3

            .Picture4(x).Line (25, 16)-(Form2.Picture4(x).ScaleWidth - 24, 16), RGB(0, 0, 0)
            .Picture4(x).Line (25, 14)-(25, 19), RGB(0, 0, 0)
            .Picture4(x).Line (Form2.Picture4(x).ScaleWidth - 24, 14)-(Form2.Picture4(x).ScaleWidth - 24, 19), RGB(0, 0, 0)
            .Picture4(x).Line (25 + (Form2.Picture4(x).ScaleWidth - 24 - 25) / 2, 14)-(25 + (Form2.Picture4(x).ScaleWidth - 24 - 25) / 2, 19), RGB(0, 0, 0)
        Next 'X
        VSC1NC = 0
        For x = 0 To 1
            
            
            .Label2(x).Top = 50
            .Label3(x).Top = 350
            .Label4(x).Top = 650
            .Label2(x).Left = 4 * Screen.TwipsPerPixelY
            .Label3(x).Left = 4 * Screen.TwipsPerPixelY
            .Label4(x).Left = 4 * Screen.TwipsPerPixelY
            
            .Command6(x).Height = Form1.Command1.Height
            .Command6(x).Width = Form1.Command1.Width
            .Command6(x).MouseIcon = Form1.Command1.MouseIcon
            .Command6(x).MousePointer = Form1.Command1.MousePointer
            .Command6(x).Top = 4 * Screen.TwipsPerPixelY
            .Command6(x).Left = .SSPanel5(x).Width - .Command6(x).Width - 4 * Screen.TwipsPerPixelX
            .Command6(x).BackColor = Form1.BackColor
        Next x
        
        .SSPanel2.Left = 0
        .SSPanel2.Top = .SSPanel1(0).Top + .SSPanel1(0).Height + 5 * Screen.TwipsPerPixelX
        .SSPanel2.Height = Form1.SSPanel7.Height
        'XX = .ScaleWidth
        .SSPanel2.Width = .SSPanel1(0).Width * 2 + 15 * Screen.TwipsPerPixelX
        .SSPanel3.Top = Form1.SSPanel1.Top
        .SSPanel3.Left = Form1.SSPanel1.Left
        .SSPanel3.Width = .SSPanel1(1).Width - 30 * HAddjust
        
        .SSPanel3.Height = Form1.SSPanel1.Height
        .Command2.Height = .SSPanel3.Height
        .Command2.Top = .SSPanel3.Top
        .Command2.Width = 900 * HAddjust
        .Command2.Left = .SSPanel2.Width - .Command2.Width - 30 * HAddjust
        .Command2.MouseIcon = Form1.Command1.MouseIcon
        
        .Command5.Height = .SSPanel3.Height
        .Command5.Top = .SSPanel3.Top
        .Command5.Width = .Command1(0).Width
        .Command5.Left = .Command2.Left - .Command5.Width
        .Command5.MouseIcon = Form1.Command1.MouseIcon
        
        .Command4.Height = .SSPanel3.Height
        .Command4.Top = .SSPanel3.Top
        .Command4.Width = .Command1(0).Width
        .Command4.Left = .Command5.Left - .Command4.Width
        .Command4.MouseIcon = Form1.Command1.MouseIcon
        
        .Command9.Height = .SSPanel3.Height
        .Command9.Top = .SSPanel3.Top
        .Command9.Width = .Command1(0).Width
        .Command9.Left = .Command4.Left - .Command5.Width
        .Command9.MouseIcon = Form1.Command1.MouseIcon
        
        .Command8.Height = .SSPanel3.Height
        .Command8.Top = .SSPanel3.Top
        .Command8.Width = .Command1(0).Width
        .Command8.Left = .Command9.Left - .Command4.Width
        .Command8.MouseIcon = Form1.Command1.MouseIcon
        
        .SSPanel4.Left = .SSPanel3.Left + .SSPanel3.Width + 30 * HAddjust
        .SSPanel4.Top = .SSPanel3.Top
        .SSPanel4.Height = .SSPanel3.Height
        If .SSPanel2.Width - .SSPanel4.Left - 30 * HAddjust - .Command2.Width - .Command4.Width - .Command5.Width - .Command9.Width - .Command8.Width > 0 Then
            .SSPanel4.Width = .SSPanel2.Width - .SSPanel4.Left - 30 * HAddjust - .Command2.Width - .Command4.Width - .Command5.Width - .Command9.Width - .Command8.Width + 5 * HAddjust
        Else
            .SSPanel4.Width = 0
        End If
        .ProgressBar1.Height = .SSPanel4.Height - 60 * VAddjust
        .ProgressBar1.Top = 30 * VAddjust
        .ProgressBar1.Left = 30 * HAddjust
        'XX = .Command8.Left
        If .Command8.Left - 2600 * HAddjust >= 0 Then
            .ProgressBar1.Width = .SSPanel4.Width - 60 * HAddjust
        End If
'        .SSPanel1(0).Visible = OVis(0)
'        .SSPanel1(1).Visible = OVis(1)
'        .SSPanel1(2).Visible = OVis(2)
'        .SSPanel1(3).Visible = OVis(3)
    End With
'    Form2.SSPanel1(0).Visible = OVx0
'    Form2.SSPanel1(1).Visible = OVx1
'    Form2.SSPanel1(2).Visible = OVx2
'    Form2.SSPanel1(3).Visible = OVx3
End Sub
Public Sub OrderBreakPoints()
'Exit Sub
Dim Eventnumber As Long, BEP As Long, BeP2 As Long, ENP As Long, ENP2 As Long, OF As Byte, OF2 As Byte, Ma2 As Long, Mi2 As Long, LenXOver As Long, BE As Long, EN As Long, BE2 As Long, EN2 As Long, GroupEvents() As Long, BackEventsA() As Long, BackEventsB() As Long

ReDim GroupEvents(NextNo, XOverListSize)
'ReDim BackEventsA( oRecombNo(100) )
'ReDim BackEventsB( oRecombNo(100) )

Form1.SSPanel1.Caption = "Finding Unique Events"
Eventnumber = 0
'Group Events
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If GroupEvents(x, Y) = 0 Then
            Eventnumber = Eventnumber + 1
            GroupEvents(x, Y) = Eventnumber
            BE = XoverList(x, Y).Beginning
            EN = XoverList(x, Y).Ending
            'Mi = XOverList(X, Y).MinorP
            
            If BE > EN Then EN = Len(StrainSeq(0)) + EN
            ENP = EN
            BEP = BE
            LenXOver = EN - BE
            EN = EN - LenXOver / 4
            BE = BE + LenXOver / 4
            For Z = Y + 1 To CurrentXOver(x)
                If GroupEvents(x, Z) = 0 Then
                            BE2 = XoverList(x, Z).Beginning
                            EN2 = XoverList(x, Z).Ending
                            If BE2 < EN2 Then
                                If EN > Len(StrainSeq(0)) Then
                                    BE2 = BE2 + Len(StrainSeq(0))
                                    EN2 = EN2 + Len(StrainSeq(0))
                                End If
                            Else
                                If EN > Len(StrainSeq(0)) Then
                                    EN2 = EN2 + Len(StrainSeq(0))
                                Else
                                    BE2 = BE2 - Len(StrainSeq(0))
                                End If
                            End If
                            LenXOver = EN2 - BE2
                            ENP2 = EN2
                            BeP2 = BE2
                            EN2 = EN2 - LenXOver / 4
                            BE2 = BE2 + LenXOver / 4
                            If (BE2 < EN And EN2 > BE) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                                'add check for parentals etc.
                                GroupEvents(x, Z) = Eventnumber
                            End If
                    End If
                    
                Next Z
           
        End If
    Next Y
    Form1.ProgressBar1.Value = ((x / NextNo) * 0.2) * 100
    Call UpdateF2Prog
Next x

Dim Eventholder As Long, EventPos() As Long, EventTraceA() As Long, EventTraceB() As Long

ReDim EventTraceA(Eventnumber, oRecombNo(100) + oRecombNo(1))
ReDim EventTraceB(Eventnumber, oRecombNo(100) + oRecombNo(1))
ReDim EventPos(Eventnumber)
Dim EventBegin() As Long, EventEnd() As Long
'ReDim EventBegin(EventNumber)
'ReDim EventEnd(EventNumber)

For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        Eventholder = GroupEvents(x, Y)
        EventPos(Eventholder) = EventPos(Eventholder) + 1
        EventTraceA(Eventholder, EventPos(Eventholder)) = x
        EventTraceB(Eventholder, EventPos(Eventholder)) = Y
    Next Y
Next x

'Group events for different sequences

For x = 1 To Eventnumber
    For b = 1 To EventPos(x)
        BE = XoverList(EventTraceA(x, b), EventTraceB(x, b)).Beginning
        EN = XoverList(EventTraceA(x, b), EventTraceB(x, b)).Ending
        
        Mi = XoverList(EventTraceA(x, b), EventTraceB(x, b)).MinorP
        Ma = XoverList(EventTraceA(x, b), EventTraceB(x, b)).MajorP
        OF = XoverList(EventTraceA(x, b), EventTraceB(x, b)).OutsideFlag
        If BE > EN Then EN = Len(StrainSeq(0)) + EN
                
        LenXOver = EN - BE
        BEP = BE
        ENP = EN
        EN = EN - LenXOver / 4
        BE = BE + LenXOver / 4
        For Y = x + 1 To Eventnumber
            For A = 1 To EventPos(Y)
                BE2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).Beginning
                EN2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).Ending
                Mi2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).MinorP
                Ma2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).MajorP
                OF2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).OutsideFlag
                
                If BE2 < EN2 Then
                    If EN > Len(StrainSeq(0)) Then
                        BE2 = BE2 + Len(StrainSeq(0))
                        EN2 = EN2 + Len(StrainSeq(0))
                    End If
                Else
                    If EN > Len(StrainSeq(0)) Then
                        EN2 = EN2 + Len(StrainSeq(0))
                    Else
                        BE2 = BE2 - Len(StrainSeq(0))
                    End If
                End If
                LenXOver = EN2 - BE2
                BeP2 = BE2
                ENP2 = EN2
                EN2 = EN2 - LenXOver / 4
                BE2 = BE2 + LenXOver / 4
                If BE2 < EN And EN2 > BE Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                    'Now check for parentals etc.
                    If (Mi = Mi2 And OF2 <> 2 And OF <> 2) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                        For Z = 1 To EventPos(Y)
                            EventPos(x) = EventPos(x) + 1
                            EventTraceA(x, EventPos(x)) = EventTraceA(Y, Z)
                            EventTraceB(x, EventPos(x)) = EventTraceB(Y, Z)
                            GroupEvents(EventTraceA(x, EventPos(x)), EventTraceB(x, EventPos(x))) = GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) ' = X
                            GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) = 0
                            EventTraceA(Y, Z) = 0
                            EventTraceB(Y, Z) = 0
                            
                            
                        Next Z
                        A = EventPos(Y)
                            EventPos(Y) = 0
                            Y = Eventnumber
                        
                    End If
                End If
            Next A
        Next Y
    Next b
    Form1.ProgressBar1.Value = 20 + ((x / Eventnumber) * 0.2) * 100
    T = Abs(GetTickCount)
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = "Sorting  " & x & " of " & Eventnumber & " Events"
    End If
    Call UpdateF2Prog
Next x

Dim HiScore As Double, WinPar As Long, MiC2 As Long, NumScore As Long, MaScore As Long, MiScore As Long, BPosScoreMa() As Double, BPosScoreMi() As Double, Mac As Long, MiC As Long, DC As Long, DoneSeqArray() As Long, MaPArray() As Long, MiPArray() As Long, DArray() As Long
Dim OLFlag As Byte, SC As Double, MC As Double, NB As Long, NE As Long, MinB As Long, MaxB As Long, MinE As Long, MaxE As Long
Dim NJSubDistance() As Single
ReDim NJSubDistance(NextNo, NextNo)
'Dim MaMiDist() As Double '
'Dim MiDDist() As Double
'Dim MaDDist() As Double
Dim MinDist() As Double
Dim MaxDist() As Double




For x = 1 To Eventnumber
    If EventPos(x) > 0 Then
        ReDim DoneSeqArray(NextNo + 1)
        ReDim MaPArray(EventPos(x))
        ReDim MiPArray(EventPos(x))
        ReDim DArray(EventPos(x))
        ReDim MinDist(NextNo)
        ReDim MaxDist(NextNo)
        For Z = 0 To NextNo
            MinDist(Z) = 100
        Next Z
        'ReDim mamidist(EventPos(X))
        'ReDim MiDDist(EventPos(X))
        'ReDim MaDDist(EventPos(X))
        Mac = 0
        MiC = 0
        DC = 0
        OLFlag = 0
        MaxB = -Len(StrainSeq(0))
        MinB = 2 * Len(StrainSeq(0))
        MaxE = -Len(StrainSeq(0))
        MinE = 2 * Len(StrainSeq(0))
        For b = 1 To EventPos(x)
           RelX = EventTraceA(x, b)
           RelY = EventTraceB(x, b)
           Ma = XoverList(RelX, RelY).MajorP
           Mi = XoverList(RelX, RelY).MinorP
           D = XoverList(RelX, RelY).Daughter
           BE = XoverList(RelX, RelY).Beginning
           EN = XoverList(RelX, RelY).Ending
           OF = XoverList(RelX, RelY).OutsideFlag
           
           If BE > EN Then
                OLFlag = 1
                EN = Len(StrainSeq(0)) + EN
           Else
                If MaxE > Len(StrainSeq(0)) Then
                    BE = BE + Len(StrainSeq(0))
                    EN = EN + Len(StrainSeq(0))
                End If
           End If
           
           
            If MaxE < EN Then MaxE = EN
            If MinE > EN Then MinE = EN
            If MinB > BE Then MinB = BE
            If MaxB < BE Then MaxB = BE
            
            If Ma <= NextNo And Mi <= NextNo Then
                Dummy = DistanceCalcE(Ma, NextNo, Len(StrainSeq(0)) + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                Dummy = DistanceCalcE(Mi, NextNo, Len(StrainSeq(0)) + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                 If NJSubDistance(Ma, D) > MaxDist(Ma) Then MaxDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) > MaxDist(Mi) Then MaxDist(Mi) = NJSubDistance(Mi, D)
                 If NJSubDistance(Ma, D) < MinDist(Ma) Then MinDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) < MinDist(Mi) Then MinDist(Mi) = NJSubDistance(Mi, D)
                'MaMiDist(B) = NJSubDistance(Ma, Mi)
                'MaDDist(B) = NJSubDistance(Ma, D)
                'MiDDist(B) = NJSubDistance(Mi, D)
                If NJSubDistance(Mi, D) > NJSubDistance(Ma, D) And NJSubDistance(Mi, D) > NJSubDistance(Ma, Mi) And Distance(Ma, D) > Distance(Mi, D) And Distance(Ma, D) > Distance(Mi, Ma) Or OF > 0 Then
                    If DoneSeqArray(Ma) = 0 And OF <> 1 Then
                             DoneSeqArray(Ma) = 1
                             Mac = Mac + 1
                             MaPArray(Mac) = Ma
                             'MaDDist(MaC) = MaDDist(B)
                             
                     End If
                     If DoneSeqArray(Mi) = 0 And OF <> 2 Then
                             DoneSeqArray(Mi) = 1
                             MiC = MiC + 1
                             MiPArray(MiC) = Mi
                             'MiDDist(MiC) = MiDDist(B)
                     End If
                     If DoneSeqArray(D) = 0 Then
                         DoneSeqArray(D) = 1
                         DC = DC + 1
                         DArray(DC) = D
                     End If
               '      For Z = 1 To MaC
               '         If MaPArray(Z) = Ma And MaDDist(Z) < MaDDist(B) Then
               '             MaDDist(Z) = MaDDist(B)
               '             Exit For
               '         End If
               '      Next Z
               '      For Z = 1 To MiC
               '         If MiPArray(Z) = Mi And MiDDist(Z) < MiDDist(B) Then
               '             MiDDist(Z) = MiDDist(B)
               '             Exit For
               '         End If
               '      Next Z
                End If
            End If
        Next b
        'Weed out any obviously sub-optimal parentals/daughters
       MiC2 = 0
       'Find minor parent with the hi score
       HiScore = 0
       WinPar = -1
       For b = 1 To MiC
            If MaxDist(MiPArray(b)) >= HiScore Then
                HiScore = MaxDist(MiPArray(b))
                WinPar = MiPArray(b)
            End If
       Next b
       For b = 1 To MiC
                    If MaxDist(MiPArray(b)) > MinDist(WinPar) Then
                        MiC2 = MiC2 + 1
                        MiPArray(MiC2) = MiPArray(b)
                    End If
        Next b
        If MiC <> MiC2 Then
            MiC = MiC2
        End If
        'Now find the best breakpoint to explain all the data
       
        Pos = 0
        If MiC > 0 And Mac > 0 Then
            If MaxB > MinE Then
                
                MidP = Int((MaxB - MinE) / 2)
                MaxB = MaxB - MidP
                MinE = MaxB + 1
                'MaxB = MinE - 1
            End If
            If MaxB < MinB Then MinB = MaxB
            If MinE > MaxE Then MaxE = MinE
            If MinB <> MaxB Then
                If MinB > MaxB Then
                
                    MaxB = Len(StrainSeq(0)) + MaxB
                
                End If
                ReDim BPosScoreMa(MaxB - MinB)
                ReDim BPosScoreMi(MaxB - MinB)
                    For Y = MinB To MaxB
                        If Y > Len(StrainSeq(0)) Then
                            PosN = Y - Len(StrainSeq(0))
                        Else
                            PosN = Y
                        End If
                        NumScore = 0
                        For A = 1 To Mac
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                    Else
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                        End If
                        NumScore = 0
                        For A = 1 To MiC
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                    Else
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                        End If
                        Pos = Pos + 1
                    Next Y
                    NB = MaxB
                    SC = 0
                    MC = -Len(StrainSeq(0)) * 2
                    For Y = MaxB To MinB Step -1
                       
                        If BPosScoreMi(Y - MinB) <> BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) <> 0 And BPosScoreMa(Y - MinB) <> 0 Then
                            SC = SC + (BPosScoreMi(Y - MinB) - BPosScoreMa(Y - MinB))
                            If SC >= MC Then
                                MC = SC
                                 If Y > Len(StrainSeq(0)) Then
                                    NB = Y - Len(StrainSeq(0))
                                Else
                                    NB = Y
                                End If
                            End If
                        End If
                        'If BPosScoreMi(Y - MinB) > BPosScoreMa(Y - MinB) Then
                        '    NB = Y
                       ' ElseIf BPosScoreMi(Y - MinB) < BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) < 0 Then
                       '     Exit For
                       ' End If
                    Next Y
               
               
                'If MC > 0 Then
                    For b = 1 To EventPos(x)
                        If NB > Len(StrainSeq(0)) Then NB = NB - Len(StrainSeq(0))
                        RelX = EventTraceA(x, b)
                        RelY = EventTraceB(x, b)
                        XoverList(RelX, RelY).Beginning = NB
                        
                    Next b
                'End If
            End If
            Pos = 0
            ReDim BPosScoreMa(MaxE - MinE)
            ReDim BPosScoreMi(MaxE - MinE)
            If MinE <> MaxE Then
                If MinE > MaxE Then
                    MaxE = Len(StrainSeq(0)) + MaxE
                End If
                For Y = MinE To MaxE
                    If Y > Len(StrainSeq(0)) Then
                        PosN = Y - Len(StrainSeq(0))
                    Else
                        PosN = Y
                    End If
                    NumScore = 0
                    For A = 1 To Mac
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                Else
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                    End If
                    NumScore = 0
                    For A = 1 To MiC
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                Else
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                    End If
                    Pos = Pos + 1
                Next Y
                NE = MinE
                SC = 0
                MC = -Len(StrainSeq(0)) * 2
                For Y = MinE To MaxE
                    
                    If BPosScoreMi(Y - MinE) <> BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) <> 0 And BPosScoreMa(Y - MinE) <> 0 Then
                        SC = SC + (BPosScoreMi(Y - MinE) - BPosScoreMa(Y - MinE))
                        If SC >= MC Then
                            
                            MC = SC
                            If Y > Len(StrainSeq(0)) Then
                                NE = Y - Len(StrainSeq(0))
                            Else
                                NE = Y
                            End If
                        End If
                    End If
                    'If BPosScoreMi(Y - MinE) > BPosScoreMa(Y - MinE) Then
                    '    NE = Y
                   ' ElseIf BPosScoreMi(Y - MinE) < BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) < 0 Then
                    '    Exit For
                   ' End If
                Next Y
                If NE > Len(StrainSeq(0)) Then
                    NE = NE - Len(StrainSeq(0))
                End If
                'If MC > 0 Then
                    For b = 1 To EventPos(x)
                        RelX = EventTraceA(x, b)
                        RelY = EventTraceB(x, b)
                        XoverList(RelX, RelY).Ending = NE
                    Next b
                'End If
            End If
        
        End If
    End If
    Form1.ProgressBar1.Value = 40 + ((x / Eventnumber) * 0.6) * 100
    T = Abs(GetTickCount)
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = x * 2 & " of " & Eventnumber * 2 & " Breakpoints Adjusted"
    End If
    Call UpdateF2Prog
Next x




End Sub
Public Sub OrderBreakPointsII()
'Exit Sub
'(1)Find order in which events occured.  Basically which branches of tree involved and
'take the root of those branches - maybe use recombination free tree to find ordering.
'(2)Work from the latest event back to the earliest and progressively mask events.
'(3)masking will prevent "mixed" events and will remove sequences (or at elast bits of them)
'from consideration when determining breakpoints.
'(4)Mask could include an event identifier
'(5)work from oldest to newest events and capture all sequences displaying evidence of these events
'if masking was done properly it will be possible to decide which sequences still (or at least should)
'have bits of evidence from overlapped events

Dim Eventnumber As Long, BEP As Long, BeP2 As Long, ENP As Long, ENP2 As Long, OF As Byte, OF2 As Byte, Ma2 As Long, Mi2 As Long, LenXOver As Long, BE As Long, EN As Long, BE2 As Long, EN2 As Long, GroupEvents() As Long, BackEventsA() As Long, BackEventsB() As Long

ReDim GroupEvents(NextNo, XOverListSize)
'ReDim BackEventsA( oRecombNo(100) )
'ReDim BackEventsB( oRecombNo(100) )

Form1.SSPanel1.Caption = "Finding Unique Events"
Eventnumber = 0
'Group Events
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If GroupEvents(x, Y) = 0 Then
            Eventnumber = Eventnumber + 1
            GroupEvents(x, Y) = Eventnumber
            BE = XoverList(x, Y).Beginning
            EN = XoverList(x, Y).Ending
            'Mi = XOverList(X, Y).MinorP
            
            If BE > EN Then EN = Len(StrainSeq(0)) + EN
            ENP = EN
            BEP = BE
            LenXOver = EN - BE
            EN = EN - LenXOver / 4
            BE = BE + LenXOver / 4
            For Z = Y + 1 To CurrentXOver(x)
                If GroupEvents(x, Z) = 0 Then
                            BE2 = XoverList(x, Z).Beginning
                            EN2 = XoverList(x, Z).Ending
                            If BE2 < EN2 Then
                                If EN > Len(StrainSeq(0)) Then
                                    BE2 = BE2 + Len(StrainSeq(0))
                                    EN2 = EN2 + Len(StrainSeq(0))
                                End If
                            Else
                                If EN > Len(StrainSeq(0)) Then
                                    EN2 = EN2 + Len(StrainSeq(0))
                                Else
                                    BE2 = BE2 - Len(StrainSeq(0))
                                End If
                            End If
                            LenXOver = EN2 - BE2
                            ENP2 = EN2
                            BeP2 = BE2
                            EN2 = EN2 - LenXOver / 4
                            BE2 = BE2 + LenXOver / 4
                            If (BE2 < EN And EN2 > BE) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                                'add check for parentals etc.
                                GroupEvents(x, Z) = Eventnumber
                            End If
                    End If
                    
                Next Z
           
        End If
    Next Y
    Form1.ProgressBar1.Value = ((x / NextNo) * 0.2) * 100
    Call UpdateF2Prog
Next x

Dim Eventholder As Long, EventPos() As Long, EventTraceA() As Long, EventTraceB() As Long

ReDim EventTraceA(Eventnumber, oRecombNo(100))
ReDim EventTraceB(Eventnumber, oRecombNo(100))
ReDim EventPos(Eventnumber)
Dim EventBegin() As Long
Dim EventEnd() As Long
'ReDim EventBegin(EventNumber)
'ReDim EventEnd(EventNumber)

For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        Eventholder = GroupEvents(x, Y)
        EventPos(Eventholder) = EventPos(Eventholder) + 1
        EventTraceA(Eventholder, EventPos(Eventholder)) = x
        EventTraceB(Eventholder, EventPos(Eventholder)) = Y
    Next Y
Next x

'Group events for different sequences

For x = 1 To Eventnumber
    For b = 1 To EventPos(x)
        BE = XoverList(EventTraceA(x, b), EventTraceB(x, b)).Beginning
        EN = XoverList(EventTraceA(x, b), EventTraceB(x, b)).Ending
        
        Mi = XoverList(EventTraceA(x, b), EventTraceB(x, b)).MinorP
        Ma = XoverList(EventTraceA(x, b), EventTraceB(x, b)).MajorP
        OF = XoverList(EventTraceA(x, b), EventTraceB(x, b)).OutsideFlag
        If BE > EN Then EN = Len(StrainSeq(0)) + EN
                
        LenXOver = EN - BE
        BEP = BE
        ENP = EN
        EN = EN - LenXOver / 4
        BE = BE + LenXOver / 4
        For Y = x + 1 To Eventnumber
            For A = 1 To EventPos(Y)
                BE2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).Beginning
                EN2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).Ending
                Mi2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).MinorP
                Ma2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).MajorP
                OF2 = XoverList(EventTraceA(Y, A), EventTraceB(Y, A)).OutsideFlag
                
                If BE2 < EN2 Then
                    If EN > Len(StrainSeq(0)) Then
                        BE2 = BE2 + Len(StrainSeq(0))
                        EN2 = EN2 + Len(StrainSeq(0))
                    End If
                Else
                    If EN > Len(StrainSeq(0)) Then
                        EN2 = EN2 + Len(StrainSeq(0))
                    Else
                        BE2 = BE2 - Len(StrainSeq(0))
                    End If
                End If
                LenXOver = EN2 - BE2
                BeP2 = BE2
                ENP2 = EN2
                EN2 = EN2 - LenXOver / 4
                BE2 = BE2 + LenXOver / 4
                If BE2 < EN And EN2 > BE Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                    'Now check for parentals etc.
                    If (Mi = Mi2 And OF2 <> 2 And OF <> 2) Or (BeP2 > BEP - 10 And BeP2 < BEP + 10) Or (ENP2 > ENP - 10 And ENP2 < ENP + 10) Then
                        For Z = 1 To EventPos(Y)
                            EventPos(x) = EventPos(x) + 1
                            EventTraceA(x, EventPos(x)) = EventTraceA(Y, Z)
                            EventTraceB(x, EventPos(x)) = EventTraceB(Y, Z)
                            GroupEvents(EventTraceA(x, EventPos(x)), EventTraceB(x, EventPos(x))) = GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) ' = X
                            GroupEvents(EventTraceA(Y, Z), EventTraceB(Y, Z)) = 0
                            EventTraceA(Y, Z) = 0
                            EventTraceB(Y, Z) = 0
                            
                            
                        Next Z
                        A = EventPos(Y)
                            EventPos(Y) = 0
                            Y = Eventnumber
                        
                    End If
                End If
            Next A
        Next Y
    Next b
    Form1.ProgressBar1.Value = 20 + ((x / Eventnumber) * 0.2) * 100
    T = Abs(GetTickCount)
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = "Sorting  " & x & " of " & Eventnumber & " Events"
    End If
    Call UpdateF2Prog
Next x

Dim HiScore As Double, WinPar As Long, MiC2 As Long, NumScore As Long, MaScore As Long, MiScore As Long, BPosScoreMa() As Double, BPosScoreMi() As Double, Mac As Long, MiC As Long, DC As Long, DoneSeqArray() As Long, MaPArray() As Long, MiPArray() As Long, DArray() As Long
Dim OLFlag As Byte, SC As Double, MC As Double, NB As Long, NE As Long, MinB As Long, MaxB As Long, MinE As Long, MaxE As Long
Dim NJSubDistance() As Single
ReDim NJSubDistance(NextNo, NextNo)
'Dim MaMiDist() As Double '
'Dim MiDDist() As Double
'Dim MaDDist() As Double
Dim MinDist() As Double
Dim MaxDist() As Double



For x = 1 To Eventnumber
    If EventPos(x) > 0 Then
        ReDim DoneSeqArray(NextNo + 1)
        ReDim MaPArray(EventPos(x))
        ReDim MiPArray(EventPos(x))
        ReDim DArray(EventPos(x))
        ReDim MinDist(NextNo)
        ReDim MaxDist(NextNo)
        For Z = 0 To NextNo
            MinDist(Z) = 100
        Next Z
        'ReDim mamidist(EventPos(X))
        'ReDim MiDDist(EventPos(X))
        'ReDim MaDDist(EventPos(X))
        Mac = 0
        MiC = 0
        DC = 0
        OLFlag = 0
        MaxB = -Len(StrainSeq(0))
        MinB = 2 * Len(StrainSeq(0))
        MaxE = -Len(StrainSeq(0))
        MinE = 2 * Len(StrainSeq(0))
        For b = 1 To EventPos(x)
           RelX = EventTraceA(x, b)
           RelY = EventTraceB(x, b)
           Ma = XoverList(RelX, RelY).MajorP
           Mi = XoverList(RelX, RelY).MinorP
           D = XoverList(RelX, RelY).Daughter
           BE = XoverList(RelX, RelY).Beginning
           EN = XoverList(RelX, RelY).Ending
           OF = XoverList(RelX, RelY).OutsideFlag
           
           If BE > EN Then
                OLFlag = 1
                EN = Len(StrainSeq(0)) + EN
           Else
                If MaxE > Len(StrainSeq(0)) Then
                    BE = BE + Len(StrainSeq(0))
                    EN = EN + Len(StrainSeq(0))
                End If
           End If
           
           
            If MaxE < EN Then MaxE = EN
            If MinE > EN Then MinE = EN
            If MinB > BE Then MinB = BE
            If MaxB < BE Then MaxB = BE
            
            If Ma <= NextNo And Mi <= NextNo Then
                Dummy = DistanceCalcE(Ma, NextNo, Len(StrainSeq(0)) + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                Dummy = DistanceCalcE(Mi, NextNo, Len(StrainSeq(0)) + 1, XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                 If NJSubDistance(Ma, D) > MaxDist(Ma) Then MaxDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) > MaxDist(Mi) Then MaxDist(Mi) = NJSubDistance(Mi, D)
                 If NJSubDistance(Ma, D) < MinDist(Ma) Then MinDist(Ma) = NJSubDistance(Ma, D)
                 If NJSubDistance(Mi, D) < MinDist(Mi) Then MinDist(Mi) = NJSubDistance(Mi, D)
                'MaMiDist(B) = NJSubDistance(Ma, Mi)
                'MaDDist(B) = NJSubDistance(Ma, D)
                'MiDDist(B) = NJSubDistance(Mi, D)
                If NJSubDistance(Mi, D) > NJSubDistance(Ma, D) And NJSubDistance(Mi, D) > NJSubDistance(Ma, Mi) And Distance(Ma, D) > Distance(Mi, D) And Distance(Ma, D) > Distance(Mi, Ma) Or OF > 0 Then
                    If DoneSeqArray(Ma) = 0 And OF <> 1 Then
                             DoneSeqArray(Ma) = 1
                             Mac = Mac + 1
                             MaPArray(Mac) = Ma
                             'MaDDist(MaC) = MaDDist(B)
                             
                     End If
                     If DoneSeqArray(Mi) = 0 And OF <> 2 Then
                             DoneSeqArray(Mi) = 1
                             MiC = MiC + 1
                             MiPArray(MiC) = Mi
                             'MiDDist(MiC) = MiDDist(B)
                     End If
                     If DoneSeqArray(D) = 0 Then
                         DoneSeqArray(D) = 1
                         DC = DC + 1
                         DArray(DC) = D
                     End If
               '      For Z = 1 To MaC
               '         If MaPArray(Z) = Ma And MaDDist(Z) < MaDDist(B) Then
               '             MaDDist(Z) = MaDDist(B)
               '             Exit For
               '         End If
               '      Next Z
               '      For Z = 1 To MiC
               '         If MiPArray(Z) = Mi And MiDDist(Z) < MiDDist(B) Then
               '             MiDDist(Z) = MiDDist(B)
               '             Exit For
               '         End If
               '      Next Z
                End If
            End If
        Next b
        'Weed out any obviously sub-optimal parentals/daughters
       MiC2 = 0
       'Find minor parent with the hi score
       HiScore = 0
       WinPar = -1
       For b = 1 To MiC
            If MaxDist(MiPArray(b)) >= HiScore Then
                HiScore = MaxDist(MiPArray(b))
                WinPar = MiPArray(b)
            End If
       Next b
       For b = 1 To MiC
                    If MaxDist(MiPArray(b)) > MinDist(WinPar) Then
                        MiC2 = MiC2 + 1
                        MiPArray(MiC2) = MiPArray(b)
                    End If
        Next b
        If MiC <> MiC2 Then
            MiC = MiC2
        End If
        'Now find the best breakpoint to explain all the data
       
        Pos = 0
        If MiC > 0 And Mac > 0 Then
            If MaxB > MinE Then
                
                MidP = Int((MaxB - MinE) / 2)
                MaxB = MaxB - MidP
                MinE = MaxB + 1
                'MaxB = MinE - 1
            End If
            If MaxB < MinB Then MinB = MaxB
            If MinE > MaxE Then MaxE = MinE
            If MinB <> MaxB Then
                If MinB > MaxB Then
                
                    MaxB = Len(StrainSeq(0)) + MaxB
                
                End If
                ReDim BPosScoreMa(MaxB - MinB)
                ReDim BPosScoreMi(MaxB - MinB)
                    For Y = MinB To MaxB
                        If Y > Len(StrainSeq(0)) Then
                            PosN = Y - Len(StrainSeq(0))
                        Else
                            PosN = Y
                        End If
                        NumScore = 0
                        For A = 1 To Mac
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                    Else
                                        BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                        End If
                        NumScore = 0
                        For A = 1 To MiC
                            For C = 1 To DC
                                If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                    If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                    Else
                                        BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                    End If
                                    NumScore = NumScore + 1
                                End If
                            Next C
                        Next A
                        If NumScore > 0 Then
                            BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                        End If
                        Pos = Pos + 1
                    Next Y
                    NB = MaxB
                    SC = 0
                    MC = -Len(StrainSeq(0)) * 2
                    For Y = MaxB To MinB Step -1
                       
                        If BPosScoreMi(Y - MinB) <> BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) <> 0 And BPosScoreMa(Y - MinB) <> 0 Then
                            SC = SC + (BPosScoreMi(Y - MinB) - BPosScoreMa(Y - MinB))
                            If SC >= MC Then
                                MC = SC
                                 If Y > Len(StrainSeq(0)) Then
                                    NB = Y - Len(StrainSeq(0))
                                Else
                                    NB = Y
                                End If
                            End If
                        End If
                        'If BPosScoreMi(Y - MinB) > BPosScoreMa(Y - MinB) Then
                        '    NB = Y
                       ' ElseIf BPosScoreMi(Y - MinB) < BPosScoreMa(Y - MinB) And BPosScoreMi(Y - MinB) < 0 Then
                       '     Exit For
                       ' End If
                    Next Y
               
               
                'If MC > 0 Then
                    For b = 1 To EventPos(x)
                        If NB > Len(StrainSeq(0)) Then NB = NB - Len(StrainSeq(0))
                        RelX = EventTraceA(x, b)
                        RelY = EventTraceB(x, b)
                        XoverList(RelX, RelY).Beginning = NB
                        
                    Next b
                'End If
            End If
            Pos = 0
            ReDim BPosScoreMa(MaxE - MinE)
            ReDim BPosScoreMi(MaxE - MinE)
            If MinE <> MaxE Then
                If MinE > MaxE Then
                    MaxE = Len(StrainSeq(0)) + MaxE
                End If
                For Y = MinE To MaxE
                    If Y > Len(StrainSeq(0)) Then
                        PosN = Y - Len(StrainSeq(0))
                    Else
                        PosN = Y
                    End If
                    NumScore = 0
                    For A = 1 To Mac
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MaPArray(A)) <> 46 Then
                                If SeqNum(PosN, MaPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) - 1
                                Else
                                    BPosScoreMa(Pos) = BPosScoreMa(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMa(Pos) = BPosScoreMa(Pos) / NumScore
                    End If
                    NumScore = 0
                    For A = 1 To MiC
                        For C = 1 To DC
                            If SeqNum(PosN, DArray(C)) <> 46 And SeqNum(PosN, MiPArray(A)) <> 46 Then
                                If SeqNum(PosN, MiPArray(A)) <> SeqNum(PosN, DArray(C)) Then
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) - 1
                                Else
                                    BPosScoreMi(Pos) = BPosScoreMi(Pos) + 1
                                End If
                                NumScore = NumScore + 1
                            End If
                        Next C
                    Next A
                    If NumScore > 0 Then
                        BPosScoreMi(Pos) = BPosScoreMi(Pos) / NumScore
                    End If
                    Pos = Pos + 1
                Next Y
                NE = MinE
                SC = 0
                MC = -Len(StrainSeq(0)) * 2
                For Y = MinE To MaxE
                    
                    If BPosScoreMi(Y - MinE) <> BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) <> 0 And BPosScoreMa(Y - MinE) <> 0 Then
                        SC = SC + (BPosScoreMi(Y - MinE) - BPosScoreMa(Y - MinE))
                        If SC >= MC Then
                            
                            MC = SC
                            If Y > Len(StrainSeq(0)) Then
                                NE = Y - Len(StrainSeq(0))
                            Else
                                NE = Y
                            End If
                        End If
                    End If
                    'If BPosScoreMi(Y - MinE) > BPosScoreMa(Y - MinE) Then
                    '    NE = Y
                   ' ElseIf BPosScoreMi(Y - MinE) < BPosScoreMa(Y - MinE) And BPosScoreMi(Y - MinE) < 0 Then
                    '    Exit For
                   ' End If
                Next Y
                If NE > Len(StrainSeq(0)) Then
                    NE = NE - Len(StrainSeq(0))
                End If
                'If MC > 0 Then
                    For b = 1 To EventPos(x)
                        RelX = EventTraceA(x, b)
                        RelY = EventTraceB(x, b)
                        XoverList(RelX, RelY).Ending = NE
                    Next b
                'End If
            End If
        
        End If
    End If
    Form1.ProgressBar1.Value = 40 + ((x / Eventnumber) * 0.6) * 100
    T = Abs(GetTickCount)
    If T - LT > 500 Then
        LT = T
        Form1.SSPanel1.Caption = x * 2 & " of " & Eventnumber * 2 & " Breakpoints Adjusted"
    End If
    Call UpdateF2Prog
Next x


End Sub
Public Sub BenchMark()
Exit Sub
    Dim Counter As Double, RelSpeed As Single, BMark As Long
    Dim CString As String
    Dim BB As Long, EE As Long
    BMark = 0
    CString = String$(10000, "A")
    BB = Abs(GetTickCount)

    Do
        BMark = BMark + 1
        Counter = Counter + 786467
        Counter = Counter * 10
        Counter = Counter / 10
        Counter = Counter ^ 2
        Counter = Sqr(Counter)
        Counter = Counter - 786467
        CString = Left$(CString, 9000)
        CString = Right$(CString, 8000)
        CString = Mid$(CString, 2000, 5000)
        CString = CString + CString
        EE = Abs(GetTickCount)

        If (EE - BB) > 1000 Then Exit Do
    Loop

    RelSpeed = BMark / 1200
End Sub
Public Sub ScanBSPlots(CycleCount As Long, FindallFlag As Byte)
     Dim SIP As Long, SplitX As Long, NumInList As Long, BWarn As Long, EWarn As Long, OverlapNum As Integer, GoOnFlag As Integer
    Dim HiSeqs(2, 2) As Long
    Dim AD As Long, AMi As Long, AMa As Long, EN As Long, BE As Long, PPVal As Double, PVal As Double, FirstFull As Long, LastFull As Long, Z As Long, DA As Long, Mi As Long, Ma As Long, YE As Long
    Dim TotalProb As Double, MedHomol As Double, LowHomol As Double, HighHomol As Double
    Dim TS As Integer, ProbCounter As Integer
    Dim S1 As Long, s2 As Long, S3 As Long, SeqLen As Long, PosCount As Long, CurPos As Long, Y As Long, x As Long
    Dim oActive As Integer
    Dim oMajP As Integer, oMinP As Integer
    Dim PBinFlag As Long
    
    PBinFlag = -1
    
    SeqLen = Len(StrainSeq(0))
    'Work out which sequences are most likely to share a recombinant region
    
    YE = (SeqLen - BSStepWin) / BSStepSize
    'I have to be very careful here - if this routine is accessed via bsxoverr then
    'I must use submasks for everything.  If it is accessed through bsxovers then I must
    'use the unprocessed seq numbers
    
    If SEventNumber = 0 And FindallFlag = 0 And DontWorryAboutSplitsFlag = 0 Then
        S1 = SubMaskSeq(Seq1): s2 = SubMaskSeq(Seq2): S3 = SubMaskSeq(Seq3)
    Else
        S1 = Seq1: s2 = Seq2: S3 = Seq3
    End If
    
    If S1 > UBound(Distance, 1) Then
        If S1 <= UBound(TreeTrace, 1) Then
            S1 = TreeTrace(S1)
        Else
            S1 = 0
        End If
    End If
    If s2 > UBound(Distance, 1) Then
        If s2 <= UBound(TreeTrace, 1) Then
            s2 = TreeTrace(s2)
        Else
            s2 = 0
        End If
        'S2 = TreeTrace(S2)
    End If
    If S3 > UBound(Distance, 1) Then
        If S3 <= UBound(TreeTrace, 1) Then
            S3 = TreeTrace(S3)
        Else
            S3 = 0
        End If
        'S3 = TreeTrace(S3)
    End If
    
    AvHomol(0) = Distance(S1, s2)
    AvHomol(1) = Distance(S1, S3)
    AvHomol(2) = Distance(s2, S3)
    
    If AvHomol(0) = AvHomol(1) And AvHomol(0) = AvHomol(2) Then

        If Distance(S1, s2) > Distance(S1, S3) And Distance(S1, s2) > Distance(s2, S3) Then
            AvHomol(0) = AvHomol(0) + 0.01

            If Distance(S1, S3) > Distance(s2, S3) Then
                AvHomol(2) = AvHomol(2) - 0.01
            Else
                AvHomol(1) = AvHomol(1) - 0.01
            End If

        ElseIf Distance(S1, S3) > Distance(S1, s2) And Distance(S1, S3) > Distance(s2, S3) Then
            AvHomol(1) = AvHomol(1) + 0.01

            If Distance(S1, s2) > Distance(s2, S3) Then
                AvHomol(2) = AvHomol(2) - 0.01
            Else
                AvHomol(0) = AvHomol(0) - 0.01
            End If

        ElseIf Distance(S1, S3) > Distance(S1, S3) And Distance(s2, S3) > Distance(S1, s2) Then
            AvHomol(2) = AvHomol(2) + 0.01

            If Distance(S1, s2) > Distance(S1, S3) Then
                AvHomol(1) = AvHomol(1) - 0.01
            Else
                AvHomol(0) = AvHomol(0) - 0.01
            End If

        End If

    ElseIf AvHomol(0) = AvHomol(1) Then

        If Distance(S1, s2) > Distance(S1, S3) Then
            AvHomol(0) = AvHomol(0) + 0.01
        Else
            AvHomol(1) = AvHomol(1) + 0.01
        End If

    ElseIf AvHomol(0) = AvHomol(2) Then

        If Distance(S1, s2) > Distance(s2, S3) Then
            AvHomol(0) = AvHomol(0) + 0.01
        Else
            AvHomol(2) = AvHomol(2) + 0.01
        End If

    ElseIf AvHomol(1) = AvHomol(2) Then

        If Distance(S1, S3) > Distance(s2, S3) Then
            AvHomol(1) = AvHomol(1) + 0.01
        Else
            AvHomol(2) = AvHomol(2) + 0.01
        End If

    End If

    If AvHomol(0) >= AvHomol(1) And AvHomol(0) >= AvHomol(2) Then
        HighHomol = 0
        If AvHomol(1) > AvHomol(2) Then
            MedHomol = 1: LowHomol = 2: ActiveSeq = S1: ActiveMajorP = s2: ActiveMinorP = S3
        Else
            MedHomol = 2: LowHomol = 1: ActiveSeq = s2: ActiveMajorP = S1: ActiveMinorP = S3
        End If

    ElseIf AvHomol(1) >= AvHomol(0) And AvHomol(1) >= AvHomol(2) Then
        HighHomol = 1
        If AvHomol(0) > AvHomol(2) Then
            MedHomol = 0: LowHomol = 2: ActiveSeq = S1: ActiveMajorP = S3: ActiveMinorP = s2
        Else
            MedHomol = 2: LowHomol = 0: ActiveSeq = S3: ActiveMajorP = S1: ActiveMinorP = s2
        End If

    ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(0) Then
        HighHomol = 2
        If AvHomol(0) > AvHomol(1) Then
            MedHomol = 0: LowHomol = 1: ActiveSeq = s2: ActiveMajorP = S3: ActiveMinorP = S1
        Else
            MedHomol = 1: LowHomol = 0: ActiveSeq = S3: ActiveMajorP = s2: ActiveMinorP = S1
        End If

        
    End If
    
    
    
    If FindallFlag = 0 Then
        PosCount = GoOnA(CycleCount)
    Else
        ReDim GoOnA(0), GoOnB(0)
        PosCount = 1
        CycleCount = 0
        GoOnA(0) = 1
        GoOnB(0) = UBound(PltVal, 2) - 1
    End If
    
    
    'Exit Sub
    

    OverlapNum = (BSStepWin / BSStepSize)
   
'    If Seq1 = 15 And Seq2 = 18 And Seq3 = 24 Then
'        x = x 'clecount = 2200
'        XX = UBound(GoOnB)
'        XX = GoOnA(1500) '1
'        XX = GoOnB(1500) '481
'        XX = PltVal(0, 320) '58
'        XX = PltVal(1, 320) '4
'        XX = PltVal(2, 320) '31
'    End If
    For Y = (BSStepWin + BSStepSize * GoOnA(CycleCount)) To (BSStepWin + BSStepSize * GoOnB(CycleCount)) Step BSStepSize
            PVal = 100000000
            
            
            EWarn = 0: BWarn = 0
            
            If PltVal(MedHomol, PosCount) >= BSCutOff * BSBootReps Then
                Call MakeBSEvent(Y, GoOnA(), GoOnB(), BSStepSize, BSStepWin, BSBootReps, BSCutOff, CycleCount, PltVal(), OverlapNum, BE, EN, PosCount, MedHomol, HighHomol, LowHomol, PPVal, PVal, BSPValFlag, EWarn, BWarn)
            ElseIf PltVal(LowHomol, PosCount) >= BSCutOff * BSBootReps Then 'This is the other possibility
                Call MakeBSEvent(Y, GoOnA(), GoOnB(), BSStepSize, BSStepWin, BSBootReps, BSCutOff, CycleCount, PltVal(), OverlapNum, BE, EN, PosCount, LowHomol, HighHomol, MedHomol, PPVal, PVal, BSPValFlag, EWarn, BWarn)
            ElseIf PltVal(HighHomol, PosCount) >= BSCutOff * BSBootReps Then  'This is the third possibility
                Call MakeBSEvent(Y, GoOnA(), GoOnB(), BSStepSize, BSStepWin, BSBootReps, BSCutOff, CycleCount, PltVal(), OverlapNum, BE, EN, PosCount, HighHomol, MedHomol, LowHomol, PPVal, PVal, BSPValFlag, EWarn, BWarn)
            End If
            
            
            If (BSPValFlag = 0 And PVal < (1 - BSCutOff)) Or (BSPValFlag > 0 And PVal > 0 And PVal < LowestProb) Then
                'Keep track of signal numbers
                'XX = XOverlist(0, 1).Probability
                
                If SEventNumber = 0 Then
                    If FastestFlag = 1 Then
                        If PBinFlag = -1 Then
                            If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                            PBinFlag = 1
                            If ProgBinRead(2, Worthwhilescan(NumInList)) = 0 Then
                            
                                Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 4
                            End If
                            
                        End If
                    End If
                End If
                
                oRecombNo(100) = oRecombNo(100) + 1
                oRecombNo(2) = oRecombNo(2) + 1
                If CurrentXOver(S1) <= CurrentXOver(s2) And CurrentXOver(S1) <= CurrentXOver(S3) Then
                    AD = S1: AMi = s2: AMa = S3
                ElseIf CurrentXOver(s2) <= CurrentXOver(S1) And CurrentXOver(s2) <= CurrentXOver(S3) Then
                    AD = s2: AMi = S1: AMa = S3
                Else
                    AD = S3: AMi = S1: AMa = s2
                End If
                If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                    AD = S1: AMi = s2: AMa = S3
                   
                ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                    AD = s2: AMi = S1: AMa = S3
                    
                ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                    AD = S3: AMi = S1: AMa = s2
                ElseIf StoreLPV(2, Seq1) >= StoreLPV(2, Seq2) And StoreLPV(2, Seq1) >= StoreLPV(2, Seq3) Then
                    AD = S1: AMi = s2: AMa = S3
                ElseIf StoreLPV(2, Seq2) >= StoreLPV(2, Seq1) And StoreLPV(2, Seq2) >= StoreLPV(2, Seq3) Then
                    AD = s2: AMi = S1: AMa = S3
                ElseIf StoreLPV(2, Seq3) >= StoreLPV(2, Seq1) And StoreLPV(2, Seq3) >= StoreLPV(2, Seq2) Then
                    AD = S3: AMi = S1: AMa = s2
                End If
                If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                    SplitX = 0
                    
                    Z = CheckSplit2(10, Len(StrainSeq(0)), BE, EN, S1, s2, S3, SplitX, MissingData(0, 0))
                
                End If
                
                If APermFlag = 0 Then
                    Call UpdateXOList3(AD, CurrentXOver(), XoverList(), 2, PVal, SIP)
                Else
                    SIP = 1
                End If
                
                
                If SIP > 0 Then
                    Dim ADx As Long
                    If AD > UBound(XoverList, 1) Then
                       ADx = TreeTrace(AD)
                    Else
                        ADx = AD
                    End If
                    XoverList(ADx, SIP).Daughter = ADx '15
                    XoverList(ADx, SIP).MajorP = AMi '19
                    XoverList(ADx, SIP).MinorP = AMa '22
                    XoverList(ADx, SIP).Beginning = BE '4790
                    XoverList(ADx, SIP).Ending = EN '1396
                    XoverList(ADx, SIP).ProgramFlag = 2
                    XoverList(ADx, SIP).Probability = PVal '10-24
                    If PPVal >= 0 Then
                        XoverList(ADx, SIP).PermPVal = PPVal
                    End If
                    XoverList(ADx, SIP).DHolder = 0
                    
                   
                    Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ADx, SIP).Beginning, XoverList(ADx, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
                    Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ADx, SIP)
                    'redo p-val calculation?
                    
                    
                    If ShortOutFlag = 1 Then
                        ShortOutput(2) = 1
                        AbortFlag = 1
                        Exit Sub
                    End If
                    If ShortOutFlag = 50 Then ShortOutput(2) = 1
                    If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                        StartPlt(2) = 1
                        Call UpdatePlotB(AD, AMa, AMi, SIP)
                                            
                    End If
                End If
                
            End If
        
            PosCount = PosCount + 1
        
            If PosCount > UBound(PltVal, 2) Then Exit For
    Next ' Y
    If ShowPlotFlag = 1 Or UpdateIDFlag = 1 Then
        s1col = Yellow: s2col = Green: s3col = Purple: s1colb = mYellow: s2colb = LGreen: s3colb = LPurple
        Call DrawBSPlotsII
        WN1 = S1: WN2 = s2: WN3 = S3
        WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
        Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
        'Call WriteNames(S1, S2, S3, Yellow, Green, Purple)
        Form1.Frame17.Visible = False
    End If
End Sub

Public Sub BSXoverR()

    SS = Abs(GetTickCount)
    Dim FF2 As Long, Largest As Double, Smallest As Double, S1 As Long, s2 As Long, S3 As Long
    Dim Modification As Double, DoneThis() As Byte, NumDone() As Double, MidNode() As Double, TallyDist As Double, MaxCurPos As Long, TB(1) As Long, MD As Double, oRec As Long, b As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqnum() As Integer
    
    Dim OrderArray() As Byte
    Dim t0() As Integer, T1() As Integer, T2() As Integer
    Dim SZE As Long
    Dim TotalCycles As Long
    Dim Cnt As Long
    'Dim GoOnA() As Byte
    Dim FCount As Long
    Dim COffCount As Long
    Dim HiS As Long, LoS1 As Long, LoS2 As Long
    Dim Scratch() As Integer
    Dim bttSeqNum() As Integer
    Dim SP As Long
    Dim L1 As Long, L2 As Long
    Dim BSFileBuffer() As Integer
    Dim FCNT As Long, FCNT2 As Long
    Dim BufferSize As Long
    Dim LastT As Long
    ReDim DstOut(BSBootReps - 1)
    'Start the timer
    STartT = Abs(GetTickCount)
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    oDir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    
    
    'Dim NTree As Tree
    
    'Dim SubGrpMaskseq() As Byte
    ReDim MidNode(2)
    'ReDim SubMaskSeq(NextNo + 1), SubGrpMaskseq(NextNo + 1)
    ReDim RevSeq(NextNo)
    'If IndividualB <> -1 Then
    
'    If IndividualA <> -1 Then
'        NumberOfSeqs = 0
'        For x = 0 To NextNo
'            If MaskSeq(x) <= 1 Then
'                SubMaskSeq(NumberOfSeqs) = x
'                RevSeq(x) = NumberOfSeqs
'                NumberOfSeqs = NumberOfSeqs + 1
'            End If
'        Next 'X
'
'        NumberOfSeqs = NumberOfSeqs - 1
'        ReDim tSeqnum(Len(StrainSeq(0)), NumberOfSeqs)
'        For x = 0 To NumberOfSeqs
'            For Y = 1 To Len(StrainSeq(0))
'                tSeqnum(Y, x) = SeqNum(Y, SubMaskSeq(x))
'            Next Y
'        Next x
'    Else
        'If sequences have been disabled/masked
        NumberOfSeqs = 0

        For x = 0 To NextNo

            If MaskSeq(x) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = x
                RevSeq(x) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
            End If

        Next 'X

        NumberOfSeqs = NumberOfSeqs - 1
        'XX = UBound(ActualSeqSize)
        If NumberOfSeqs > 400 Then 'need to subsample
            Dim MustDrop As Long, MAxD As Single, WinS As Long
            ReDim BSMask(NextNo)
            For x = 0 To NextNo
                BSMask(x) = MaskSeq(x)
            Next x
            MustDrop = NumberOfSeqs - 400
            For Z = 1 To MustDrop
                MAxD = 0
                For x = 0 To NextNo
                    If BSMask(x) <= 1 Then
                        For Y = x + 1 To NextNo
                            If BSMask(Y) <= 0 Then
                                If Distance(x, Y) > MAxD Then
                                    MAxD = Distance(x, Y)
                                    'If ActualSeqSize(x) > ActualSeqSize(Y) Then
                                        WinS = Y
                                    'Else
                                    '    WinS = x
                                    'End If
                                End If
                            End If
                        Next Y
                    End If
                Next x
                
                BSMask(WinS) = 2
                SS = GetTickCount
                If Abs(SS - LL) > 500 Then
                    LL = SS
                    Form1.SSPanel1.Caption = Str(Z) + " of " + Trim(Str(MustDrop)) + " sequences masked during subsampling"
                    DoEvents
                End If
            Next Z
            
            NumberOfSeqs = 0

            For x = 0 To NextNo
    
                If BSMask(x) <= 1 Then
                    SubMaskSeq(NumberOfSeqs) = x
                    RevSeq(x) = NumberOfSeqs
                    NumberOfSeqs = NumberOfSeqs + 1
                End If
    
            Next 'X
    
            NumberOfSeqs = NumberOfSeqs - 1
        End If
        
        
        
        ReDim tSeqnum(Len(StrainSeq(0)), NumberOfSeqs)
        For x = 0 To NumberOfSeqs
            For Y = 1 To Len(StrainSeq(0))
                tSeqnum(Y, x) = SeqNum(Y, SubMaskSeq(x))
            Next Y
        Next x
    
    
    
    'End If
    
    NameLen = Len(Trim$(CStr(NumberOfSeqs)))
    If NameLen < 2 Then NameLen = 2
    If x = x Then
        'NumberOfSeqs = 500
        sz = NumberOfSeqs * (NumberOfSeqs + 1)
        sz = sz * (NumberOfSeqs - 1)
        sz = sz / 6
        SZE = CLng(sz)
        'SZE = CLng((NumberOfSeqs * (NumberOfSeqs + 1) * (NumberOfSeqs - 1)) / 6)
       
        
        
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        'SZE = 500
        ReDim OrderArray(SZE)
        ReDim GoOnA(SZE)
        ReDim GoOnB(SZE)
            
        UB = -1
        UB = UBound(GoOnB, 1)
        If UB = -1 Then
            MsgBox ("There is not enough available memory to run Bootscan in primary scanning mode. It will be be run in secondary scanning mode instead.")
            Erase OrderArray
            Erase GoOnA
            Erase GoOnB
            DoScans(0, 2) = 0
            DoScans(1, 2) = 1
            Exit Sub
        End If
        
        On Error GoTo 0
        
        
        Cnt = 0
        
        
        
        For Seq1 = 0 To NumberOfSeqs - 2
            For Seq2 = Seq1 + 1 To NumberOfSeqs - 1
                For Seq3 = Seq2 + 1 To NumberOfSeqs
                    If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                        OrderArray(Cnt) = 0
                    ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                        OrderArray(Cnt) = 1
                    ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) Then
                        OrderArray(Cnt) = 2
                    End If
                    Cnt = Cnt + 1
                Next
            Next
        Next
    ElseIf UseALFlag = 1 And x = 12345 Then
        SZE = TripListLen
        ReDim OrderArray(SZE)
        SZE = CLng((NumberOfSeqs * (NumberOfSeqs + 1)) / 2)
        'ReDim GoOnA(SZE)
        'ReDim GoOnB(SZE)
        
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    
        'ReDim OrderArray(SZE)
        ReDim GoOnA(SZE)
        ReDim GoOnB(SZE)
            
        UB = -1
        UB = UBound(GoOnB, 1)
        If UB = -1 Then
            MsgBox ("There is not enough available memory to run Bootscan in primary scanning mode. It will be be run in secondary scanning mode instead.")
            Erase OrderArray
            Erase GoOnA
            Erase GoOnB
            DoScans(0, 2) = 0
            DoScans(1, 2) = 1
            Exit Sub
        End If
        
        On Error GoTo 0
        
        Cnt = 0
        
        ReDim Preserve Analysislist(2, TripListLen)
        If TripListLen > 1000000 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5AnalysisList" + UFTag For Binary As #FF
            Get #FF, , Analysislist
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            'Erase AnalysisList
        End If
        For x = 0 To TripListLen
            Seq1 = Analysislist(0, x)
            Seq2 = Analysislist(1, x)
            Seq3 = Analysislist(2, x)
            If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                OrderArray(Cnt) = 0
            ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                OrderArray(Cnt) = 1
            ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) Then
                OrderArray(Cnt) = 2
            End If
            Cnt = Cnt + 1
        Next x
    End If
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "RDP5BSScanData" + UFTag
    KillFile "RDP5bsfile2" + UFTag
    On Error GoTo 0
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(BSStepWin)
    ReDim Prod2(BSStepWin)
    ReDim Prod3(BSStepWin)
    ReDim Alias(BSStepWin)
    ReDim Ally(BSStepWin)
    ReDim Location(BSStepWin)
    ReDim Px(NumberOfSeqs, BSStepWin)
    ReDim ttSeqNum(BSStepWin, NumberOfSeqs)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    ReDim DistVal(BSBootReps + 1)
    ReDim Num1(BSBootReps + 1)
    ReDim Num2(BSBootReps + 1)
    ReDim DEN(BSBootReps + 1)
    ReDim num(BSBootReps + 1)
    ReDim WeightMod(BSBootReps, BSStepWin - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
    ReDim Scratch(BSStepWin)
    'Do
        Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
       
    'Loop
    COffCount = (1 - BSCutOff) * BSBootReps
    
    
    Rnd (-BSRndNumSeed)

    NumWins = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    ReDim BSFilePos(NextNo, NextNo)
    ReDim PltPos(NumWins + 1)
    'Work out nt positions at the center of every window

    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    MaxCurPos = NumberOfSeqs * 4
    FF = FreeFile
    
    
    
    'Open "RDP5BSScanData" + UFTag For Binary As #FF
    Dim hbfFile As HugeBinaryFile, hbfFile2 As HugeBinaryFile
    Set hbfFile = New HugeBinaryFile
    hbfFile.OpenFile "RDP5BSScanData" + UFTag
    



    ReDim bttSeqNum(BSStepWin, NumberOfSeqs)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
    ReDim NodeLen(MaxCurPos)
    ReDim TempNodeOrder(MaxCurPos)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    
    'Work out file read/write parameters
    Cnt = 0
    For x = 0 To NumberOfSeqs
        For Y = x + 1 To NumberOfSeqs
            BSFilePos(SubMaskSeq(x), SubMaskSeq(Y)) = Cnt
            BSFilePos(SubMaskSeq(Y), SubMaskSeq(x)) = Cnt
            Cnt = Cnt + 1
        Next 'Y
    Next 'X
    BSRWSize = BSBootReps * 2
    BSRSize = BSRWSize * (NumWins + 1)
    BSWinRWChunk = BSRWSize * (NumberOfSeqs + 1) * (NumberOfSeqs) / 2
    GlobalMemoryStatus MemSit
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    
    BufferSize = APhys / 16
    BSRWBuffer = CLng(BufferSize / BSWinRWChunk)
    ReDim BSFileBuffer(BSRWBuffer * BSWinRWChunk)
    FCNT = 0
    Dim ValidX() As Single, DiffsX() As Single
    For b = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), b, BSStepSize, BSStepWin, ttSeqNum(0, 0), tSeqnum(0, 0)
        If BSSubModelFlag <> 3 Then
            
            If BSSubModelFlag = 0 Then
                ReDim ValidX(BSBootReps), DiffsX(BSBootReps), DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
                
                Dummy = FastBootDistIP(0, BSBootReps, NumberOfSeqs, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), ttSeqNum(0, 0), DstMat(0, 0, 0))
            Else
                ReDim Weight(BSBootReps, BSStepWin)
                
                BootDist BSBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, NumberOfSeqs + 1, BSStepWin, ttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), num(0), WeightMod(0, 0)
            End If
        Else

            For x = 0 To BSBootReps - 1
                
                If x > 0 Then
                    SP = 0

                    For Z = 0 To BSStepWin - 1

                        For A = 1 To WeightMod(x, Z)
                            SP = SP + 1

                            For Y = 0 To NumberOfSeqs
                                bttSeqNum(SP, Y) = ttSeqNum(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSStepWin

                        For Y = 0 To NumberOfSeqs
                            bttSeqNum(Z, Y) = ttSeqNum(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSBootReps, BSStepWin)
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, NumberOfSeqs + 1, BSStepWin, bttSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

                For Y = 0 To NumberOfSeqs - 1

                    For Z = Y + 1 To NumberOfSeqs
                        DstMat(x, Y, Z) = tMat(Y, Z)
                        DstMat(x, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

            Next 'X

        End If
        
        If BSTypeFlag > 0 Then
            
            For x = 0 To BSBootReps - 1
               
                Dim Hi As Double, Hi2 As Double
                Dim AbBe() As Byte
                ReDim AbBe(MaxCurPos)
                GoOn = 0
                Hi = 0
                Hi2 = 0
                For Y = 0 To NumberOfSeqs
                    For Z = 0 To NumberOfSeqs
                        tMat(Y, Z) = DstMat(x, Y, Z)
                        If DstMat(x, Y, Z) > 0 Then
                            If Hi = 0 Then
                                Hi = DstMat(x, Y, Z)
                            ElseIf Hi2 = 0 And DstMat(x, Y, Z) <> Hi Then
                                Hi2 = DstMat(x, Y, Z)
                                If Hi <> DstMat(x, Y, Z) Then
                                    GoOn = 1
                                End If
                            ElseIf Hi > 0 And Hi2 > 0 And DstMat(x, Y, Z) <> Hi And DstMat(x, Y, Z) <> Hi2 Then
                                
                                    GoOn = 1
                                
                            End If
                        End If
                    Next 'Z

                Next 'Y
                
                ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                If GoOn = 1 Then
                    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)
                    ReDim ColTotals(NumberOfSeqs)
                    Dim Treearray() As Single
                    ReDim Treearray(NumberOfSeqs, NumberOfSeqs)
                    LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 2, NumberOfSeqs + 1, tMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                    
                    LTree = LTree + 1
                    
                    
                    ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                    Call Tree2Array(0, NameLen, NumberOfSeqs, LTree, SHolder(), TMat2())
                        
                     
                End If
                    
                
                'find largest and smallest distances and then standardise so that they fall between 32000 and 0
                Smallest = 1000
                Largest = -1000
                For Seq1 = 0 To NumberOfSeqs - 1
    
                    For Seq2 = Seq1 + 1 To NumberOfSeqs
                        If TMat2(Seq1, Seq2) < Smallest Then
                            
                            Smallest = TMat2(Seq1, Seq2)
                        ElseIf TMat2(Seq1, Seq2) > Largest Then
                            Largest = TMat2(Seq1, Seq2)
                        End If
                        
                    Next 'Seq2
    
                Next 'Seq1
                
                
                If (Largest - Smallest) > 0 Then
                    Modification = 1 / (Largest - Smallest)
                Else
                    Modification = 0
                End If
                If Modification > 0 Then
                
                    For Seq1 = 0 To NumberOfSeqs - 1
        
                        For Seq2 = Seq1 + 1 To NumberOfSeqs
                            'TMat2(Seq1, Seq2) = (TMat2(Seq1, Seq2) - Smallest) * Modification
                            'If TMat2(Seq1, Seq2) < 0.000032 Then TMat2(Seq1, Seq2) = 0
                            DstMat(x, Seq1, Seq2) = TMat2(Seq1, Seq2)
                            DstMat(x, Seq2, Seq1) = DstMat(x, Seq1, Seq2)
                        Next 'Seq2
        
                    Next 'Seq1
                Else
                    For Seq1 = 0 To NumberOfSeqs - 1
        
                        For Seq2 = Seq1 + 1 To NumberOfSeqs
                            DstMat(x, Seq1, Seq2) = TMat2(Seq1, Seq2)
                            DstMat(x, Seq2, Seq1) = DstMat(x, Seq1, Seq2)
                        Next 'Seq2
        
                    Next 'Seq1
                
                End If

            
            Next 'X

        End If
        Cnt = 0
        XX = FF
        Dim TempByte() As Byte, TempByte2() As Byte, TempSingle() As Single, TempInt() As Integer
        'ReDim testbyte(10000)
        For x = 0 To NumberOfSeqs - 1
            For Y = x + 1 To NumberOfSeqs
                    'this coluld be speeded up with better nesting of if then's

                Dummy = ScanPositive(b, BSCutOff, COffCount, x, Y, NumberOfSeqs, BSBootReps, GoOnA(Cnt), GoOnB(Cnt), OrderArray(Cnt), DstMat(0, 0, 0))
                
                SingleToInt x, Y, BSBootReps, NumberOfSeqs, DstMat(0, 0, 0), BSFileBuffer(FCNT) 'DstOut(0)
                FCNT = FCNT + BSBootReps
                If FCNT >= BSRWBuffer * BSWinRWChunk - BSBootReps Then
                    ReDim Preserve BSFileBuffer(FCNT - 1)
                    'XX = Seek(FF)
                    TempByte() = AnyArrayToBytes(BSFileBuffer())
                    'XX = UBound(TempByte)
                    'XX = UBound(BSFileBuffer)
                    hbfFile.WriteBytes TempByte() 'BSFileBuffer()
                    'XX = UBound(TempInt)
                    'XX = UBound(TempInt())
                    'XX = TempByte(8)
                    'XX = TempByte2(6)
                    'hbffile.ReadBytes SortArray() 'bytBuf
                    'Put #FF, , BSFileBuffer()
                    ReDim BSFileBuffer(BSRWBuffer * BSWinRWChunk)
                    FCNT = 0
                End If
                Cnt = Cnt + Dummy
            Next 'Y
        Next 'X
       
        
        'Update progress indicaters
        
        BSEnd = Abs(GetTickCount)
        If Abs(BSEnd - LastT) > 500 Or AbortFlag = 1 Then ' Give an update on progress every half second
            LastT = BSEnd
            Hold = ((b + 1) * 0.6) / (NumWins + 1)
            With Form1
                .ProgressBar1 = (b / NumWins) * 60
                .SSPanel1.Caption = b & " of " & NumWins & " windows examined"
                .SSPanel13.Caption = "Approximately " & DoTime(((Abs(BSEnd - STartT) / Hold) - Abs(BSEnd - STartT))) & " remaining"
                .Label50(4).Caption = DoTimeII(Abs(BSEnd - Abs(BSStart)))
                .Label50(12).Caption = DoTimeII(Abs(BSEnd - Abs(ST)))
                .WindowState = .WindowState 'covered by currentlyrunning
            End With
            
            If (CLine <> "" And CLine <> " ") Then
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole vbClearLine
                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                GetConsoleScreenBufferInfo hOutput, scrbuf
                WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
            End If
            
            If AbortFlag = 1 Then
                hbfFile.CloseFile
                Set hbfFile = Nothing
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                KillFile "RDP5BSScanData" + UFTag
                On Error GoTo 0
                'Close #FF
                Close #FF2
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                
                ChDir oDir
                ChDrive oDir
                On Error GoTo 0
                CurWothwhilePos = 0
                Exit Sub
                
                                                   
            End If
        End If
        'Erase DstMat
    Next 'B
    
    ReDim Preserve BSFileBuffer(FCNT - 1)
    'hbffile.WriteBytes BSFileBuffer()
    TempByte() = AnyArrayToBytes(BSFileBuffer())
    hbfFile.WriteBytes TempByte() 'BSFileBuffer()
    'Put #FF, , BSFileBuffer()
    MD = MD
    'Close #FF
    
    Erase DstMat
    Erase bttSeqNum
    Erase tMat
    Erase SHolder
    Erase NodeLen
    Erase TempNodeOrder
    Erase Weight
    Erase NodeOrder
    Erase DoneNode
    
    Erase TMat2
    
  
    Erase Prod1
    Erase Prod2
    Erase Prod3
    Erase Alias
    Erase Ally
    Erase Location
    Erase Px
    Erase ttSeqNum
    Erase DistVal
    Erase Num1
    Erase Num2
    Erase DEN
    Erase num
    Erase WeightMod
    Erase OrderArray
    Erase BSFileBuffer
    Dim ReadNo As Long
    ReadNo = (BSRWBuffer * BSWinRWChunk) / (2 * BSBootReps * (NumWins))
    'ReadNo = 2
    ReDim BSFileBuffer(BSBootReps * (NumWins) * ReadNo - 1)
    Dim Pos As Currency, Spos As Currency, PosA As Long, SortArray() As Integer
    ReDim SortArray(BSBootReps * ReadNo)
    '(BSBootReps * (NumWins + 1) - 1)
    ReDim TempByte((BSBootReps * ReadNo + 1) * 2 - 1)
    S1 = 0
    s2 = 1
    Pos = 1
    'PosA = 0
    Dim NumPairs As Long
    NumPairs = NumberOfSeqs * (NumberOfSeqs + 1) / 2
    
    ' If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    'For X = 500 To 2000
    '
    '
    '    Close #X
    '
    'Next X
    'On Error GoTo 0
    
    'For X = 10 To 500
   '
   '
   '     Close #X
   '
   ' Next X
    
    'If AbortFlag = 1 Then
        
    'End If
    
    FF2 = FreeFile
    'for x =
    BSFileName = "RDP5bsfile2" + UFTag
    Set hbfFile2 = New HugeBinaryFile
    hbfFile2.OpenFile BSFileName
    'Open BSFileName For Binary As #FF2
    
    Spos = 1
    'hbfFile2.SeekAbsolute 1
    For x = 1 To NumPairs Step ReadNo
            Pos = Spos
            For Y = 0 To NumWins - 1
                PosA = 0
                XX = UBound(SortArray)
                hbfFile.SeekAbsolute (Pos - 1)
                hbfFile.ReadBytes TempByte()
                SortArray() = AnyArrayToInteger(TempByte)
                'SortArray() 'bytBuf
                'Get #FF, Pos, SortArray()
                PosA = ReSortArray(Y, NumWins, PosA, ReadNo, BSBootReps, BSFileBuffer(0), SortArray(0))
                Pos = Pos + BSWinRWChunk
                XX = SortArray(16) '2385,2434,1756,2194,2256
                'pos = 60001,120001,180001
                'posa=65000
                '2385,2098,2434,1953,1756
                
            Next Y
            
            BSEnd = Abs(GetTickCount) 'Take the time
            If BSEnd - LastT > 500 Or AbortFlag = 1 Then ' Give an update on progress every half second
                LastT = BSEnd
                If AbortFlag = 1 Then
                        hbfFile.CloseFile
                        Set hbfFile = Nothing
                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                        KillFile "RDP5BSScanData" + UFTag
                        On Error GoTo 0
                        'Close #FF
                        hbfFile2.CloseFile
                        
                        Set hbfFile2 = Nothing
                        
                        'Close #FF2
                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                        ChDir oDir
                        ChDrive oDir
                        On Error GoTo 0
                        CurWothwhilePos = 0
                        Exit Sub
                End If
                                
                'Write progress to the screen
                                
                With Form1
                                    '.ProgressBar1 = 60 + (B / MCCorrection) * 40
                                    .SSPanel1.Caption = x & " of " & NumPairs & " pairs sorted"
                                   '.SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - StartT) / Hold) - (BSEnd - StartT))) & " remaining"
                                    '.label50(5).Caption = cstr(TotalBSRecombinants)
                                    '.label50(13).Caption = cstr( oRecombNo(100) )
                                    .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                    .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                    .Refresh: .WindowState = .WindowState
                End With
            
            End If
            Spos = Spos + ReadNo * BSBootReps * 2
            TempByte2() = AnyArrayToBytes(BSFileBuffer())
            hbfFile2.WriteBytes TempByte2() 'BSFileBuffer()
            
            'Put #FF2, , BSFileBuffer()
    Next x
    
hbfFile.CloseFile
Set hbfFile = Nothing
'Close #FF
If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
KillFile "RDP5BSScanData" + UFTag
On Error GoTo 0
Erase SortArray
Erase BSFileBuffer
'Close #FF2
'Exit Sub
STartT = Abs(GetTickCount)
    SS = Abs(GetTickCount)
    Dim GrpTest As Long
    'Open "RDP5BSScanData" For Binary Access Read As #FF Len = BSBootReps
    
    ReDim t0(BSBootReps * (NumWins + 1) - 1)
    ReDim T1(BSBootReps * (NumWins + 1) - 1)
    ReDim T2(BSBootReps * (NumWins + 1) - 1)
    
   
    Dim OverlapNumB As Integer
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim PltVal(2, NumWins)
    OverlapNumB = (BSStepWin / BSStepSize)
    b = 0
    ReDim TempByte((BSBootReps * (NumWins + 1) - 1) * 2 + 1)
    If IndividualB <> -1 Then
        Seq1 = RevSeq(IndividualA)
            Seq2 = RevSeq(IndividualB)
                'ReDim BSFileBuffer(BSBootReps * (NumWins) * (NumberOfSeqs - Seq1) - 1)
                'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq1 + 1)) * BSBootReps * (NumWins) * 2 + 1), BSFileBuffer()
                                        
                        For Seq3 = 0 To NumberOfSeqs
                            
                            If SelGrpFlag = 1 Then
                                If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
                                    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                    hbfFile2.CloseFile
                                    Set hbfFile2 = Nothing
                                    'Close #FF
                                    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                    KillFile BSFileName
                                    On Error GoTo 0
                                    'Close #FF2
                                    Close #FF
                                    ChDir oDir
                                    ChDrive oDir
                                    On Error GoTo 0
                                    Exit Sub
                                End If
                            End If
                            
                            If MaskSeq(SubMaskSeq(Seq3)) <= 1 And Seq3 <> Seq1 And Seq3 <> Seq2 Then
                                If GoOnA(TotalCycles) > 0 Then
                                    
                                    If MaskSeq(SubMaskSeq(Seq3)) <= 1 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                            'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1)
                                            Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2))
                                            Pos = Pos * BSBootReps
                                            Pos = Pos * NumWins
                                            Pos = Pos * 2 + 1
                                            hbfFile2.SeekAbsolute Pos
                                            hbfFile2.ReadBytes TempByte()
                                            t0() = AnyArrayToInteger(TempByte)
                                            'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                                            'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1)
                                            Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3))
                                            Pos = Pos * BSBootReps
                                            Pos = Pos * NumWins
                                            Pos = Pos * 2 + 1
                                            hbfFile2.SeekAbsolute Pos
                                            hbfFile2.ReadBytes TempByte()
                                            T1() = AnyArrayToInteger(TempByte)
                                            'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                            Pos = BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3))
                                            Pos = Pos * BSBootReps
                                            Pos = Pos * NumWins
                                            Pos = Pos * 2 + 1
                                            hbfFile2.SeekAbsolute Pos
                                            hbfFile2.ReadBytes TempByte()
                                            T2() = AnyArrayToInteger(TempByte)
                                           'Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  'For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                 'Next 'Y
                                           Else
                                                'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                'Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           tSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            s2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                            'Call FindSubSeqBS
                                           
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                b = b + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount) 'Take the time
                                If Abs(BSEnd - GlobalTimer) > 500 Then ' Give an update on progress every half second
                                    GlobalTimer = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        
                                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                        Close #FF
                                        hbfFile2.CloseFile
                                        Set hbfFile2 = Nothing
                                        'Close #FF
                                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                        KillFile BSFileName
                                        On Error GoTo 0
                                        'Close #FF2
                                        ChDir oDir
                                        ChDrive oDir
                                        On Error GoTo 0
                                        x = GetNumInList(Seq1, Seq2, Seq3)
                                        If CurWothwhilePos > x Then CurWothwhilePos = x
                                        Exit Sub
                                    End If
                                    
                                    Hold = b / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        If 60 + (b / MCCorrection) * 40 <= 100 Then
                                            .ProgressBar1 = 60 + (b / MCCorrection) * 40
                                            .SSPanel1.Caption = b & " of " & MCCorrection & " triplets examined"
                                            .SSPanel13.Caption = "Approximately " & DoTime(((Abs(BSEnd - STartT) / Hold) - Abs(BSEnd - STartT))) & " remaining"
                                        End If
                                        UpdateRecNums (SEventNumber)
                                        .Label50(4).Caption = DoTimeII(Abs(BSEnd - BSStart)) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label50(12).Caption = DoTimeII(Abs(BSEnd - ST)) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        .Refresh: .WindowState = .WindowState
                                    End With
                                    If (CLine <> "" And CLine <> " ") Then
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole vbClearLine
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                    End If
                                End If
                            End If
                        Next 'Seq3
                    
    ElseIf IndividualA <> -1 Then
        Seq1 = RevSeq(IndividualA)
                For Seq2 = 0 To NumberOfSeqs - 1
                    If Seq2 <> Seq1 And MaskSeq(SubMaskSeq(Seq2)) <= 1 Then
                        
                        For Seq3 = Seq2 + 1 To NumberOfSeqs
                            If MaskSeq(SubMaskSeq(Seq3)) <= 1 And Seq3 <> Seq1 Then
                                If GoOnA(TotalCycles) > 0 Then
                                    
                                    If MaskSeq(SubMaskSeq(Seq3)) <= 1 And MaskSeq(SubMaskSeq(Seq2)) <= 1 Then
                                          
                                          If GoOnA(TotalCycles) > OverlapNumB Then
                                                GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                            Else
                                                GoOnA(TotalCycles) = 1
                                            End If
                                            
                                            If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                            Else
                                                GoOnB(TotalCycles) = NumWins
                                            End If
                                           
                                           
                                           
                                           'Establish the position of each relevent value in the distance matrices
                                            'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1)
                                            Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2))
                                            Pos = Pos * BSBootReps
                                            Pos = Pos * NumWins
                                            Pos = Pos * 2 + 1
                                            hbfFile2.SeekAbsolute Pos
                                            hbfFile2.ReadBytes TempByte()
                                            t0() = AnyArrayToInteger(TempByte)
                                            'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                                            'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1)
                                            Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3))
                                            Pos = Pos * BSBootReps
                                            Pos = Pos * NumWins
                                            Pos = Pos * 2 + 1
                                            hbfFile2.SeekAbsolute Pos
                                            hbfFile2.ReadBytes TempByte()
                                            T1() = AnyArrayToInteger(TempByte)
                                            'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                            Pos = BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3))
                                            Pos = Pos * BSBootReps
                                            Pos = Pos * NumWins
                                            Pos = Pos * 2 + 1
                                            hbfFile2.SeekAbsolute Pos
                                            hbfFile2.ReadBytes TempByte()
                                            T2() = AnyArrayToInteger(TempByte)
                                           'Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
'                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
'                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
'                                           Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                                           If ShowPlotFlag = 1 Then
                                                 'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                                                  'For Y = 0 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                 'Next 'Y
                                           Else
                                                'For Y = GoOnA(TotalCycles) To GoOnB(TotalCycles)
                            '                      'For Y = 1 To NumWins
                            '                           'GetPltVal BSBootReps, Y, BSFileBuffer(((Seq2 - Seq1 - 1) * BSBootReps * NumWins + (Y * BSBootReps))), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                          'this coluld be speeded up with better nesting of if then's

                                                      'GetPltVal BSBootReps, Y, T0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
                                                      GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                'Next 'Y
                                           End If
                      '                           GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), T0(0), T1(0), T2(0), PltVal(0, 0)
                          
                                           'Look for evidence of recombination when the entire plot is completed
                                           tSeq1 = Seq1
                                           tSeq2 = Seq2
                                           tSeq3 = Seq3
                                            S1 = SubMaskSeq(Seq1)
                                            s2 = SubMaskSeq(Seq2)
                                            S3 = SubMaskSeq(Seq3)
                                            LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                            
                                           ' Call FindSubSeqBS
                                           Call ScanBSPlots(TotalCycles, 0)
                                       
            '                           Else
            '                               X = X
            '                           End If
                                        
                                   End If
                                End If
                                b = b + 1
                                TotalCycles = TotalCycles + 1
                                'PBCount = PBCount + 1
                                BSEnd = Abs(GetTickCount) 'Take the time
                                If Abs(BSEnd - GlobalTimer) > 500 Then ' Give an update on progress every half second
                                    GlobalTimer = BSEnd
                                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                        StartPlt(2) = 1
                                        oRec = oRecombNo(100)
                                        Call UpdatePlotC
                                    End If
                                    
                                    If AbortFlag = 1 Then
                                        Close #FF
                                        hbfFile2.CloseFile
                                        Set hbfFile2 = Nothing
                                        'Close #FF
                                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                                        KillFile BSFileName
                                        On Error GoTo 0
                                        'Close #FF2
                                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                                        ChDir oDir
                                        ChDrive oDir
                                        On Error GoTo 0
                                        x = GetNumInList(Seq1, Seq2, Seq3)
                                        If CurWothwhilePos > x Then CurWothwhilePos = x
                                        Exit Sub
                                    End If
                                    
                                    Hold = b / MCCorrection 'Work out proportion of cycles completed
                                    'Write progress to the screen
                                    
                                    With Form1
                                        .ProgressBar1 = 60 + (b / MCCorrection) * 40
                                        .SSPanel1.Caption = b & " of " & MCCorrection & " triplets examined"
                                        .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - STartT) / Hold) - (BSEnd - STartT))) & " remaining"
                                        UpdateRecNums (SEventNumber)
                                        .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                        .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                        .Refresh: .WindowState = .WindowState
                                    End With
                                    If (CLine <> "" And CLine <> " ") Then
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole vbClearLine
                                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                        GetConsoleScreenBufferInfo hOutput, scrbuf
                                        WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                    End If
                
                                End If
                            End If
                        Next 'Seq3
                    End If
                Next 'Seq2

    Else
        If UseALFlag = 1 And x = 12345 Then 'this doesnt work becaus ethe goona and goonb arrays are not properly updated
            'is it necessery to redim this here?
            
            
            For x = 0 To TripListLen
                Seq1 = Analysislist(0, x)
                Seq2 = Analysislist(1, x)
                Seq3 = Analysislist(2, x)
                
               ' If GoOn = 1 Then
                                               
                    'Establish the position of each relevent value in the distance matrices
                    'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1)
                    Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2))
                    Pos = Pos * BSBootReps
                    Pos = Pos * NumWins
                    Pos = Pos * 2 + 1
                    hbfFile2.SeekAbsolute Pos
                    hbfFile2.ReadBytes TempByte()
                    t0() = AnyArrayToInteger(TempByte)
                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                    'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1)
                    Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3))
                    Pos = Pos * BSBootReps
                    Pos = Pos * NumWins
                    Pos = Pos * 2 + 1
                    hbfFile2.SeekAbsolute Pos
                    hbfFile2.ReadBytes TempByte()
                    T1() = AnyArrayToInteger(TempByte)
                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                    Pos = BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3))
                    Pos = Pos * BSBootReps
                    Pos = Pos * NumWins
                    Pos = Pos * 2 + 1
                    hbfFile2.SeekAbsolute Pos
                    hbfFile2.ReadBytes TempByte()
                    T2() = AnyArrayToInteger(TempByte)
                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
'                     Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
'                     Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
'                     Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
                     If ShowPlotFlag = 1 Then
                          GetPltVal2 BSBootReps, 0, NumWins, t0(0), T1(0), T2(0), PltVal(0, 0)
                     Else
                          
                          GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                     End If
                     
                     'Look for evidence of recombination when the entire plot is completed
                     tSeq1 = Seq1
                     tSeq2 = Seq2
                     tSeq3 = Seq3
                      S1 = SubMaskSeq(Seq1)
                      s2 = SubMaskSeq(Seq2)
                      S3 = SubMaskSeq(Seq3)
                      
                      
                      LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                      'Call FindSubSeqBS
                     ' zz = 0
                     'For X = 0 To Len(StrainSeq(0))
                     '     zz = zz + Scores(X, 2)
                     'Next X
                     Call ScanBSPlots(TotalCycles, 0)
                     'B = B + 1
                 'End If
                
                BSEnd = Abs(GetTickCount) 'Take the time
                If BSEnd - GlobalTimer > 500 Then ' Give an update on progress every half second
                    b = x
                    GlobalTimer = BSEnd
                    If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                        StartPlt(2) = 1
                        oRec = oRecombNo(100)
                        Call UpdatePlotC
                    End If
                    
                    If AbortFlag = 1 Then
                        Close #FF
                        hbfFile2.CloseFile
                        Set hbfFile2 = Nothing
                        'Close #FF
                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                        KillFile BSFileName
                        On Error GoTo 0
                        'Close #FF2
                        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

                        ChDir oDir
                        ChDrive oDir
                        x = GetNumInList(Seq1, Seq2, Seq3)
                        If CurWothwhilePos > x Then CurWothwhilePos = x
                        On Error GoTo 0
                        Exit Sub
                    End If
                    
                    Hold = b / MCCorrection 'Work out proportion of cycles completed
                    'Write progress to the screen
                    
                    With Form1
                        PBV = (b / TripListLen)
                        If PBV > 1 Then PBV = 1
                        .ProgressBar1 = 60 + PBV * 40
                        .SSPanel1.Caption = b & " of " & TripListLen & " triplets examined"
                        .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - STartT) / Hold) - (BSEnd - STartT))) & " remaining"
                        UpdateRecNums (SEventNumber)
                        .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                        .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                        .Refresh: .WindowState = .WindowState
                    End With
                    If (CLine <> "" And CLine <> " ") Then
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole vbClearLine
                        hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                        GetConsoleScreenBufferInfo hOutput, scrbuf
                        WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                    End If
                End If
            Next x
            TT = Abs(GetTickCount)
            If TT - GlobalTimer > 500 Then
              GlobalTimer = TT
                Form1.SSPanel1.Caption = Trim(Str(TripListLen)) & " of " & Trim(Str(TripListLen)) & " triplets reexamined"
                Form1.SSPanel1.Refresh
                Form1.Refresh
                If DebuggingFlag < 2 Then
                    Form1.WindowState = Form1.WindowState
                End If
            End If
        Else
         
            For Seq1 = 0 To NumberOfSeqs - 2
                'If MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                    'ReDim BSFileBuffer(BSBootReps * (NumWins) * (NumberOfSeqs - Seq1) - 1)
                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq1 + 1)) * BSBootReps * (NumWins) * 2 + 1), BSFileBuffer()
                    For Seq2 = Seq1 + 1 To NumberOfSeqs - 1
                        'If Then
                            
                            For Seq3 = Seq2 + 1 To NumberOfSeqs
                                If MaskSeq(SubMaskSeq(Seq3)) = 0 And MaskSeq(SubMaskSeq(Seq2)) = 0 And MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                                    
                                    If GoOnA(TotalCycles) > 0 Then
                                        GoOnA(TotalCycles) = 1
                                        GoOnB(TotalCycles) = NumWins
                                        If MaskSeq(SubMaskSeq(Seq3)) = 0 And MaskSeq(SubMaskSeq(Seq2)) = 0 And MaskSeq(SubMaskSeq(Seq1)) = 0 Then
                                              
                                              If GoOnA(TotalCycles) > OverlapNumB Then
                                                    GoOnA(TotalCycles) = GoOnA(TotalCycles) - OverlapNumB
                                                Else
                                                    GoOnA(TotalCycles) = 1
                                                End If
                                                
                                                If GoOnB(TotalCycles) + OverlapNumB < NumWins Then
                                                    GoOnB(TotalCycles) = GoOnB(TotalCycles) + OverlapNumB
                                                Else
                                                    GoOnB(TotalCycles) = NumWins
                                                End If
                                                
                                                If QvRFlag = 1 Then
                                                    GoOn = 0
                                                    If ReferenceList(Seq1) = 0 Then
                                                        If ReferenceList(Seq2) <> 0 And ReferenceList(Seq3) <> 0 And ReferenceList(Seq2) <> ReferenceList(Seq3) Then GoOn = 1
                                                    ElseIf ReferenceList(Seq2) = 0 Then
                                                        If ReferenceList(Seq1) <> 0 And ReferenceList(Seq3) <> 0 And ReferenceList(Seq1) <> ReferenceList(Seq3) Then GoOn = 1
                                                    ElseIf ReferenceList(Seq3) = 0 Then
                                                        If ReferenceList(Seq2) <> 0 And ReferenceList(Seq1) <> 0 And ReferenceList(Seq2) <> ReferenceList(Seq1) Then GoOn = 1
                                                    End If
                                                ElseIf SelGrpFlag > 0 Then
                                                    GoOn = 1
                                                    GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                                    If GrpTest < 2 Then
                                                        GoOn = 0
                                                    End If
                                                Else
                                                    GoOn = 1
                                                End If
                                                If GoOn = 1 Then
                                                
                                                XX = UBound(t0)
                                               
                                               'Establish the position of each relevent value in the distance matrices
                                                    'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1)
                                                    Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2))
                                                    Pos = Pos * BSBootReps
                                                    Pos = Pos * NumWins
                                                    Pos = Pos * 2
                                                    hbfFile2.SeekAbsolute Pos
                                                    hbfFile2.ReadBytes TempByte()
                                                    t0() = AnyArrayToInteger(TempByte)
                                                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
                                                    'Pos = (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1)
                                                    Pos = BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3))
                                                    Pos = Pos * BSBootReps
                                                    Pos = Pos * NumWins
                                                    Pos = Pos * 2
                                                    hbfFile2.SeekAbsolute Pos
                                                    hbfFile2.ReadBytes TempByte()
                                                    T1() = AnyArrayToInteger(TempByte)
                                                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
                                                    Pos = BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3))
                                                    Pos = Pos * BSBootReps
                                                    Pos = Pos * NumWins
                                                    Pos = Pos * 2
                                                    
                                                    hbfFile2.SeekAbsolute Pos
                                                    hbfFile2.ReadBytes TempByte()
                                                    T2() = AnyArrayToInteger(TempByte)
                                                    'Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
'                                                    Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq2)) * BSBootReps * (NumWins) * 2 + 1), T0()
'                                                    Get #FF2, (BSFilePos(SubMaskSeq(Seq1), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T1()
'                                                    Get #FF2, (BSFilePos(SubMaskSeq(Seq2), SubMaskSeq(Seq3)) * BSBootReps * (NumWins) * 2 + 1), T2()
'                                                    If Seq1 = 0 And Seq2 = 1 And Seq3 = 2 Then
'                                                        For AA = 0 To UBound(t0)
'                                                            If TAIX(AA) <> t0(AA) Then
'                                                                x = x
'                                                            End If
'                                                        Next AA
'                                                        x = x
'                                                    End If
                                                    '1,96201,2308801
'                                                    If Seq1 = 10 And Seq2 = 19 And Seq3 = 23 Then
'                                                        XX = t0(33000) '0
'                                                        XX = T1(33000) '765
'                                                        XX = T2(33000) '765
'                                                        XX = UBound(t0) '48200
'
'                                                    End If
                                                    If ShowPlotFlag = 1 Then
                                                         GetPltVal2 BSBootReps, 0, NumWins, t0(0), T1(0), T2(0), PltVal(0, 0)
                                                    Else
                                                         
                                                         GetPltVal2 BSBootReps, GoOnA(TotalCycles), GoOnB(TotalCycles), t0(0), T1(0), T2(0), PltVal(0, 0)
                                                    End If
                                                    
                                                    'Look for evidence of recombination when the entire plot is completed
                                                    tSeq1 = Seq1
                                                    tSeq2 = Seq2
                                                    tSeq3 = Seq3
                                                     S1 = SubMaskSeq(Seq1)
                                                     s2 = SubMaskSeq(Seq2)
                                                     S3 = SubMaskSeq(Seq3)
                                                     
                                                     
                                                     LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                                     'Call FindSubSeqBS
                                                    ' zz = 0
                                                    'For X = 0 To Len(StrainSeq(0))
                                                    '     zz = zz + Scores(X, 2)
                                                    'Next X
                                                    Call ScanBSPlots(TotalCycles, 0)
                                                    b = b + 1
                                                End If
                                           
                '                           Else
                '                               X = X
                '                           End If
                                            
                                       End If
                                    End If
                                    
                                    TotalCycles = TotalCycles + 1
                                    'PBCount = PBCount + 1
                                    BSEnd = Abs(GetTickCount) 'Take the time
                                    If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                        LastT = BSEnd
                                        If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(2) = 1
                                            oRec = oRecombNo(100)
                                            Call UpdatePlotC
                                        End If
                                        
                                        If AbortFlag = 1 Then
                                            Close #FF
                                            hbfFile2.CloseFile
                                            Set hbfFile2 = Nothing
                                            'Close #FF
                                            
                                            'Close #FF2
                                            If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    
                                            ChDir oDir
                                            ChDrive oDir
                                            On Error GoTo 0
                                            x = GetNumInList(Seq1, Seq2, Seq3)
                                            If CurWothwhilePos > x Then CurWothwhilePos = x
                                            Exit Sub
                                        End If
                                        If b > 0 Then
'                                            If UseALFlag > 0 Then
'                                                Hold = B / TripListLen 'Work out proportion of cycles completed
'
'                                            Else
                                                Hold = b / MCCorrection 'Work out proportion of cycles completed
'                                            End If
                                        
                                        'Write progress to the screen
                                        
                                            With Form1
'                                                If UseALFlag = 1 Then
'                                                    pbv = (B / TripListLen)
'                                                Else
'                                                    pbv = (B / MCCorrection)
'                                                End If
                                                If PBV > 1 Then PBV = 1
                                                .ProgressBar1 = 60 + Hold * 40
                                                If UseALFlag = 1 And x = 12345 Then
                                                    .SSPanel1.Caption = b & " of " & Trim(Str(TripListLen)) & " triplets examined"
                                                Else
                                                    .SSPanel1.Caption = b & " of " & Trim(Str(MCCorrection)) & " triplets examined"
                                                End If
                                                .SSPanel13.Caption = "Approximately " & DoTime((((BSEnd - STartT) / Hold) - (BSEnd - STartT))) & " remaining"
                                                UpdateRecNums (SEventNumber)
                                                .Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                                                .Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                                                .Refresh: .WindowState = .WindowState
                                            End With
                                            If (CLine <> "" And CLine <> " ") Then
                                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                                WriteToConsole vbClearLine
                                                hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                                                GetConsoleScreenBufferInfo hOutput, scrbuf
                                                WriteToConsole "Running BOOT scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                                            End If
                                        End If
                        
                                    End If
                                Else
                                    TotalCycles = TotalCycles + 1
                                End If
                                
                                
                            Next 'Seq3
                        'End If
                    Next 'Seq2
                'End If
            Next 'Seq1
        End If
    End If
    Erase GoOnA
    Erase GoOnB
    Erase PltVal
    
    
                            BSEnd = Abs(GetTickCount) 'Take the time
                            'If BSEnd - LastT > 500 Then ' Give an update on progress every half second
                                LastT = BSEnd
                                
                                
                                'Write progress to the screen
 TT = Abs(GetTickCount)
 If Abs(TT - GlobalTimer) > 500 Or x = x Then
    GlobalTimer = TT
 
        With Form1
            UpdateRecNums (SEventNumber)
            .Label50(4).Caption = DoTimeII(Abs(BSEnd - Abs(BSStart))) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
            .Label50(12).Caption = DoTimeII(Abs(BSEnd - Abs(ST))) 'Str$((Int((BSEnd - ST) / 100)) / 10)
            .Refresh: .WindowState = .WindowState
        End With
         
                            'End If
    End If
    
    '3.127
    EE = Abs(GetTickCount)
    TT = EE - SS
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Close #FF
    hbfFile2.CloseFile
    Set hbfFile2 = Nothing
    'Close #FF
   
    'Close #FF2
    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
    
End Sub

Public Sub BSXoverM(SPF, FindallFlag As Byte, WeightMod() As Long)
    'Exit Sub
    'SS = Abs(GetTickCount)
    Dim S1 As Long, s2 As Long, S3 As Long, OT As Long, nt As Long, Y As Long, x As Long, LSeq As Long, btTempSeq2() As Integer, OX(1) As Long, MaY(2) As Long, MiY(2) As Long, XP(1) As Long, YP(1, 2) As Long
    Dim A As Long, Dummy As Long, Z As Long, Pict As Long, SP As Long
    Dim b As Long, LTree As Long, STartT As Long, NumWins As Long
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
   
    Dim tMat() As Single, TMat2() As Single, SHolder() As Byte, TempSeq2() As Integer, PntAPI As POINTAPI
    Dim ValidX() As Single, DiffsX() As Single
    BSBootReps = BSBootReps
    BSStepWin = BSStepWin
    
    If BSStepWin > Len(StrainSeq(0)) Then
        BSStepWin = CLng(Len(StrainSeq(0)) / 4)
    End If
    BSStepSize = BSStepSize
    If BSStepSize > BSStepWin / 2 Then BSStepSize = CLng(BSStepWin / 2)
    
    
    OX(0) = 0
    OX(1) = 0
    
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, 2)
    
    '*************************************Make a C++ version**********************************************
    '@
    For x = 1 To LSeq
        TempSeq2(x, 0) = SeqNum(x, Seq1)
        TempSeq2(x, 1) = SeqNum(x, Seq2)
        TempSeq2(x, 2) = SeqNum(x, Seq3)
    Next
    
    NumberOfSeqs = 3
    
    If FindallFlag = 0 And SPF = 0 And UpdateIDFlag = 0 And BestRescanFlag = 0 Then
        Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 100, 0, 1, "Bootstrap support (%)")
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
            'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
        End If
        Form1.Picture8.Enabled = False
        Form1.Picture10.Enabled = False
        Form1.Combo1.Enabled = False
         Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
        Form1.SSPanel2.Enabled = False
        Form1.Picture5.Enabled = False
        Form1.Command6(0).Enabled = False
        Form1.Command25.Enabled = True
        Form1.Command25.ToolTipText = "Stop the BOOTSCAN"
        
        'Do cutoff line
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.DrawStyle = 2
        Pict = Form1.Picture7.hdc
        MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
        LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
        Form1.Picture7.DrawStyle = 0
    End If
     
    
    ReDim TTempSeq2(BSStepWin, 2)
    ReDim DstMat(BSBootReps, 2, 2)
    
    ReDim tMat(2, 2)
    ReDim SHolder((3 + 1) * 40 * 2)
    ReDim DstMat(BSBootReps, 2, 2)
'    If Len(StrainSeq(0)) <> Decompress(Len(StrainSeq(0))) Then
'        BSSubModelFlag = 0
'    End If
    If BSSubModelFlag = 3 Then BSSubModelFlag = 0
    If BSSubModelFlag > 0 Then
        ReDim DistVal(BSBootReps + 1)
        ReDim XX1(3), XX2(3)
        ReDim Prod1(BSStepWin), Prod2(BSStepWin), Prod3(BSStepWin)
        ReDim Alias(BSStepWin), Ally(BSStepWin)
        ReDim Location(BSStepWin)
        ReDim Px(2, BSStepWin)
        ReDim num(BSBootReps + 1), Num1(BSBootReps + 1), Num2(BSBootReps + 1)
        ReDim DEN(BSBootReps + 1)
        ReDim Weight(BSBootReps, BSStepWin)
    Else
        ReDim ValidX(BSBootReps), DiffsX(BSBootReps)
    End If
    
    
    
    
    NumWins = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    'ReDim PltVal(NumberOfSeqs, NumWins)
    ReDim PltPos(NumWins + 1), PltVal(2, NumWins)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

'    ot = Abs(GetTickCount)
    
    For b = 0 To NumWins
        '@'@'@
        MakeSubAlign 2, Len(StrainSeq(0)), b, BSStepSize, BSStepWin, TTempSeq2(0, 0), TempSeq2(0, 0)

        If BSSubModelFlag <> 3 Then
            '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
            If BSSubModelFlag = 0 Then
                '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'$'$'@'@'@'&
                Dummy = FastBootDistIP(0, BSBootReps, 2, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), TTempSeq2(0, 0), DstMat(0, 0, 0))

                'Dummy = FastBootDistIP(0, BSBootReps, 2, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), TTempSeq2(0, 0), DstMat(0, 0, 0))
                '21.86 - fastbootdist
                '19.80 - fastbootdistp
            Else
                BootDist BSBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, 3, BSStepWin, TTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), num(0), WeightMod(0, 0)
            End If
            DoEvents
        Else

            

            ReDim btTempSeq2(BSStepWin, 2)

            For x = 0 To BSBootReps - 1

                If x > 0 Then
                    SP = 0

                    For Z = 0 To BSStepWin - 1

                        For A = 1 To WeightMod(x, Z)
                            SP = SP + 1

                            For Y = 0 To 2
                                btTempSeq2(SP, Y) = TTempSeq2(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSStepWin

                        For Y = 0 To 2
                            btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSBootReps, BSStepWin)
                ReDim tMat(2, 2)
                If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, 3, BSStepWin, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)
                On Error GoTo 0
                For Y = 0 To 1

                    For Z = Y + 1 To 2
                        DstMat(x, Y, Z) = tMat(Y, Z)
                        DstMat(x, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

                Erase tMat
            Next 'X

        End If

        'If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        'DstMat(0, 0, 0) = DstMat(0, 0, 0)
        'On Error GoTo 0

        If BSTypeFlag > 0 Then
            ReDim tMat(3, 3)
            ReDim SHolder((3 + 1) * 40 * 2)

            For x = 0 To BSBootReps - 1

                For Y = 0 To 2

                    For Z = 0 To 2
                        tMat(Y, Z) = DstMat(x, Y, Z)
                    Next 'Z

                Next 'Y

                For Y = 0 To 2
                    tMat(Y, 3) = 6
                    tMat(3, Y) = 6
                Next Y
                ReDim ColTotals(3)
                Dim Treearray() As Single
                ReDim Treearray(3, 3)
                LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 0, 4, tMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                LTree = LTree + 1
                A = LTree

                Do
                    If SHolder(A) = 41 Then
                        Exit Do
                    End If
                    A = A - 1
                Loop
                
                'Convert the treeinfo (stared in newic format as an ascii array
                'in sholder) into a 2-d array describing the topology of a midpoint
                'rooted version of the tree
                SHolder(A + 1) = 59
                LTree = A + 1
                ReDim TMat2(3, 3)
                
                Call Tree2Array(0, 2, NumberOfSeqs, LTree, SHolder(), TMat2())
            Next 'X

        End If
        
        
        
        '50.42
        If x = x Then
            '@'@'@
            Dummy = GetPltValX(b, BSBootReps, DstMat(0, 0, 0), PltVal(0, 0))
        Else
            For x = 0 To BSBootReps - 1
                If DstMat(x, 0, 1) < 2 And DstMat(x, 0, 2) < 2 And DstMat(x, 1, 2) < 2 Then
                
                    If DstMat(x, 0, 1) < DstMat(x, 0, 2) And DstMat(x, 0, 1) < DstMat(x, 1, 2) Then
                            PltVal(0, b) = PltVal(0, b) + 1
                    ElseIf DstMat(x, 0, 2) < DstMat(x, 0, 1) And DstMat(x, 0, 2) < DstMat(x, 1, 2) Then
                            PltVal(1, b) = PltVal(1, b) + 1
                    ElseIf DstMat(x, 1, 2) < DstMat(x, 0, 1) And DstMat(x, 1, 2) < DstMat(x, 0, 2) Then
                            PltVal(2, b) = PltVal(2, b) + 1
                    End If
                End If
    
            Next 'x
        End If
        
       '50.58
               
        If FindallFlag = 0 And SPF = 0 And BestRescanFlag = 0 Then
            If b > 0 And PltPos(b) > 0 And PltPos(b) < Len(StrainSeq(0)) Then
                Pict = Form1.Picture7.hdc
                XP(0) = 30 + Decompress(PltPos(b - 1)) * XFactor
                XP(1) = 30 + Decompress(PltPos(b)) * XFactor
                YP(0, 0) = 20 + (1 - PltVal(2, b - 1) / BSBootReps) * (PicHeight - 35)
                YP(1, 0) = 20 + (1 - PltVal(2, b) / BSBootReps) * (PicHeight - 35)
                
                If XP(0) <> OX(0) Or XP(1) <> OX(1) Then
                    MiY(0) = 100000
                    MiY(1) = 100000
                    MiY(2) = 100000
                    MaY(0) = 0
                    MaY(1) = 0
                    MaY(2) = 0
                End If
                
                If YP(0, 0) > MaY(0) Or YP(1, 0) > MaY(0) Or YP(0, 0) < MiY(0) Or YP(1, 0) < MiY(0) Then
                    Form1.Picture7.ForeColor = Purple
'                    Dummy = MoveToEx(Pict, XP(0), YP(0, 0), PntAPI)
'                    Dummy = LineTo(Pict, XP(1), YP(1, 0))
                    If YP(0, 0) > MaY(0) Then MaY(0) = YP(0, 0)
                    If YP(1, 0) > MaY(0) Then MaY(0) = YP(1, 0)
                    If YP(0, 0) < MiY(0) Then MiY(0) = YP(0, 0)
                    If YP(1, 0) < MiY(0) Then MiY(0) = YP(1, 0)
                End If
                
                YP(0, 1) = 20 + (1 - PltVal(1, b - 1) / BSBootReps) * (PicHeight - 35)
                YP(1, 1) = 20 + (1 - PltVal(1, b) / BSBootReps) * (PicHeight - 35)
                If YP(0, 1) > MaY(1) Or YP(1, 1) > MaY(1) Or YP(0, 1) < MiY(1) Or YP(1, 1) < MiY(1) Then
                    Form1.Picture7.ForeColor = Green
'                    Dummy = MoveToEx(Pict, XP(0), YP(0, 1), PntAPI)
'                    Dummy = LineTo(Pict, XP(1), YP(1, 1))
                    If YP(0, 1) > MaY(1) Then MaY(1) = YP(0, 1)
                    If YP(1, 1) > MaY(1) Then MaY(1) = YP(1, 1)
                    If YP(0, 1) < MiY(1) Then MiY(1) = YP(0, 1)
                    If YP(1, 1) < MiY(1) Then MiY(1) = YP(1, 1)
                End If
                YP(0, 2) = 20 + ((1 - PltVal(0, b - 1) / BSBootReps) * (PicHeight - 35))
                YP(1, 2) = 20 + ((1 - PltVal(0, b) / BSBootReps) * (PicHeight - 35))
                If YP(0, 2) > MaY(2) Or YP(1, 2) > MaY(2) Or YP(0, 2) < MiY(2) Or YP(1, 2) < MiY(2) Then
                    Form1.Picture7.ForeColor = Yellow
'                    Dummy = MoveToEx(Pict, XP(0), YP(0, 2), PntAPI)
'                    Dummy = LineTo(Pict, XP(1), YP(1, 2))
                    If YP(0, 2) > MaY(2) Then MaY(2) = YP(0, 2)
                    If YP(1, 2) > MaY(2) Then MaY(2) = YP(1, 2)
                    If YP(0, 2) < MiY(2) Then MiY(2) = YP(0, 2)
                    If YP(1, 2) < MiY(2) Then MiY(2) = YP(1, 2)
                End If
                OX(0) = XP(0)
                OX(1) = XP(1)
                   ' Form1.Picture7.Refresh
                
            End If
        
            If AbortFlag = 1 Then
                AbortFlag = 0
                Form1.Command25.Enabled = False
                Form1.Command25.ToolTipText = ""
                If UpdateProgressBar = 0 Then
                
                    Form1.ProgressBar1.Value = 0
                    Form1.SSPanel1.Caption = ""
                    Call UpdateF2Prog
                End If
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.Picture23(1).Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6(0).Enabled = True
                Exit Sub
            End If
        
            'Update progress indicaters
            nt = Abs(GetTickCount)
            If Abs(nt - OT) > 500 Then
                OT = nt
                'If B / 5 = Int(B / 5) And SPF = 0 Then
                    If UpdateProgressBar = 0 Then
                    With Form1
                        .ProgressBar1 = (b / NumWins) * 100
                        .SSPanel1.Caption = b & " of " & NumWins & " windows examined"
                        .Refresh: .WindowState = .WindowState
                    End With
                    End If
                    
                'End If
            End If
        
        End If

        'Erase DstMat
    Next 'B
    '57.89
    Erase TempSeq2
    If FindallFlag = 0 Then
        Call DrawBSPlotsIII(SPF, FindallFlag)
        FindSubSeqBS
        If SPF = 0 Then
            If UpdateProgressBar = 0 Then
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Call UpdateF2Prog
            End If
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6(0).Enabled = True
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
        End If
    Else
        ReDim Scores(Len(StrainSeq(0)), 2)
        If UBound(SubMaskSeq, 1) < PermNextno Then
            ReDim Preserve SubMaskSeq(PermNextno)
        End If
        If FindallFlag = 0 And SEventNumber = 0 And DontWorryAboutSplitsFlag = 0 Then
            S1 = SubMaskSeq(Seq1)
            s2 = SubMaskSeq(Seq2)
            S3 = SubMaskSeq(Seq3)
        Else
            S1 = Seq1
            s2 = Seq2
            S3 = Seq3
        
        End If
        
        LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), S1, s2, S3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
        
        '57.83
        Call ScanBSPlots(1, 1)
        '61.01
        x = x
    End If
    '1.39
    
    
    
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    
End Sub
Public Sub BSXoverN()
    SS = Abs(GetTickCount)

    Dim IncrementX As Single, NumHigh As Long, HiVal As Single, HiSeq As Long, Modi As Double, DoneThis() As Byte, NumDone() As Double, MidNode(2) As Double, TallyDist As Double, MaxCurPos As Long, TB(1) As Long, MD As Double, b As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
 
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    ReDim DstOut(BSBootReps - 1)
    
    'Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 100, 0, 0, "Bootstrap support (%)")
    
    'Do cutoff line
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.DrawStyle = 2
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
    LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
    Form1.Picture7.DrawStyle = 0
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the Bootscan"
    
    LSeq = Len(StrainSeq(0))
    ReDim RevSeq(NextNo)
    
    NumberOfSeqs = 1
    For x = 0 To NextNo

        If Selected(x) = 1 Then
            RevSeq(NumberOfSeqs) = x
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    ReDim TempSeq2(LSeq, NumberOfSeqs)
    Y = Form5.Combo1.ListIndex - 1
    For x = 1 To LSeq
        TempSeq2(x, 0) = SeqNum(x, Y)
    Next
    
    Z = 1
    For Y = 0 To NextNo
        If Selected(Y) = 1 Then
            For x = 1 To LSeq
                TempSeq2(x, Z) = SeqNum(x, Y)
            Next
            Z = Z + 1
        End If
    Next
    
    'Call DoLegend
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(BSStepWin)
    ReDim Prod2(BSStepWin)
    ReDim Prod3(BSStepWin)
    ReDim Alias(BSStepWin)
    ReDim Ally(BSStepWin)
    ReDim Location(BSStepWin)
    ReDim Px(NumberOfSeqs, BSStepWin)
    ReDim TTempSeq2(BSStepWin, NumberOfSeqs)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    ReDim DistVal(BSBootReps + 1)
    ReDim Num1(BSBootReps + 1)
    ReDim Num2(BSBootReps + 1)
    ReDim DEN(BSBootReps + 1)
    ReDim num(BSBootReps + 1)
    ReDim WeightMod(BSBootReps, BSStepWin - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)

    For Y = 0 To BSBootReps

        For x = 1 To BSStepWin
            WeightMod(Y, x - 1) = 1
        Next 'X

    Next 'Y

    Rnd (-BSRndNumSeed)

    Dim Scratch() As Integer

    For Y = 1 To BSBootReps
        ReDim Scratch(BSStepWin)
        RndNum2 = CLng(BSStepWin / 4) + CLng(((BSStepWin / 4) * Rnd))

        For x = 1 To RndNum2

            Do
                RndNum = CLng(((BSStepWin - 1) * Rnd) + 1)
            Loop While Scratch(RndNum - 1) = 1

            Scratch(RndNum - 1) = 1
            WeightMod(Y, RndNum - 1) = 0

            Do
                RndNum = CLng(((BSStepWin - 1) * Rnd) + 1)
            Loop While WeightMod(Y, RndNum - 1) = 0

            WeightMod(Y, RndNum - 1) = WeightMod(Y, RndNum - 1) + 1
            Scratch(RndNum - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    
    ReDim PltPos(NumWins + 1)
    'Work out nt positions at the center of every window

    For Z = 0 To NumWins - 1
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    FF = FreeFile
    ReDim PltVal(NumberOfSeqs, NumWins)
    ReDim DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
    Dim AbBe() As Long
    Dim ValidX() As Single, DiffsX() As Single
    For b = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), b, BSStepSize, BSStepWin, TTempSeq2(0, 0), TempSeq2(0, 0)

        If BSSubModelFlag <> 3 Then
            If BSSubModelFlag = 0 Then
                ReDim ValidX(BSBootReps), DiffsX(BSBootReps), DstMat(BSBootReps, NumberOfSeqs, NumberOfSeqs)
                Dummy = FastBootDistIP(0, BSBootReps, NumberOfSeqs, BSStepWin, DiffsX(0), ValidX(0), WeightMod(0, 0), TTempSeq2(0, 0), DstMat(0, 0, 0))
                
            
            
            Else
                ReDim Weight(BSBootReps, BSStepWin)
                BootDist BSBootReps, BSCoeffVar, BSTTRatio, BSSubModelFlag, NumberOfSeqs + 1, BSStepWin, TTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0, 0), DistVal(0), Num1(0), Num2(0), DEN(0), num(0), WeightMod(0, 0)
            End If
        Else

            Dim btTempSeq2() As Integer
            Dim SP As Long

            ReDim btTempSeq2(BSStepWin, NumberOfSeqs)

            For x = 0 To BSBootReps - 1

                If x > 0 Then
                    SP = 0

                    For Z = 0 To BSStepWin - 1

                        For A = 1 To WeightMod(x, Z)
                            SP = SP + 1

                            For Y = 0 To NumberOfSeqs
                                btTempSeq2(SP, Y) = TTempSeq2(Z + 1, Y)
                            Next 'Y

                        Next 'A

                    Next 'Z

                Else

                    For Z = 1 To BSStepWin

                        For Y = 0 To NumberOfSeqs
                            btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
                        Next 'Y

                    Next 'Z

                End If

                ReDim Weight(BSBootReps, BSStepWin)
                ReDim tMat(NumberOfSeqs, NumberOfSeqs)
                DNADIST BSCoeffVar, BSTTRatio, BSFreqFlag, BSSubModelFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT, NumberOfSeqs + 1, BSStepWin, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

                For Y = 0 To NumberOfSeqs - 1

                    For Z = Y + 1 To NumberOfSeqs
                        DstMat(x, Y, Z) = tMat(Y, Z)
                        DstMat(x, Z, Y) = tMat(Y, Z)
                    Next 'Z

                Next 'Y

                Erase tMat
            Next 'X

        End If

        'If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        'DstMat(0, 0, 0) = DstMat(0, 0, 0)
        'On Error GoTo 0

        If BSTypeFlag > 0 Then
            ReDim tMat(NumberOfSeqs, NumberOfSeqs)
            ReDim SHolder((NumberOfSeqs + 1) * 40 * 2)

            For x = 0 To BSBootReps - 1
                
                For Y = 0 To NumberOfSeqs

                    For Z = 0 To NumberOfSeqs
                        tMat(Y, Z) = DstMat(x, Y, Z)
                    Next 'Z

                Next 'Y

                ReDim ColTotals(NumberOfSeqs)
                Dim Treearray() As Single
                ReDim Treearray(NumberOfSeqs, NumberOfSeqs)
                LTree = NEIGHBOUR(BSTypeFlag - 1, 0, BSRndNumSeed, 0, NumberOfSeqs + 1, tMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                LTree = LTree + 1
                A = LTree

                Do

                    If SHolder(A) = 41 Then
                        Exit Do
                    End If

                    A = A - 1
                Loop

                SHolder(A + 1) = 59
                LTree = A + 1
                'Dim ttr As String
                TTr = ""
                
                For A = 1 To LTree + 1
                   TTr = TTr + Chr(SHolder(A - 1))
                Next A
                MaxCurPos = NumberOfSeqs * 4
                'SHolder(57) = Asc(59)
                ReDim NodeOrder(MaxCurPos)
                ReDim NodeLen(MaxCurPos)
                ReDim DoneNode(MaxCurPos)
                ReDim TempNodeOrder(MaxCurPos)
                
                ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                NameLen = Len(Trim$(CStr(NumberOfSeqs + 1))) + 1
                ReDim AbBe(MaxCurPos)
                ReDim NumDone(MaxCurPos)
                
                
                
               Call Tree2Array(0, NameLen, NumberOfSeqs, LTree, SHolder(), TMat2())
                
               If x = 12345 Then
                'TreeToArray NameLen, NumberOfSeqs, LTree, SHolder(0), TMat2(0, 0), NodeOrder(0), DoneNode(0), TempNodeOrder(0), RootNode(0, 0), NodeLen(0), NumDone(0)
                    Done0 = 0
                    For ZZ = 0 To MaxCurPos
                        If NodeOrder(ZZ) = 0 And Done0 = 1 Then
                            NodeOrder(ZZ) = NumberOfSeqs + 1
                            Exit For
                        ElseIf NodeOrder(ZZ) = 0 And Done0 = 0 Then
                           Done0 = 1
                        End If
                    Next ZZ
                    
                    If x = x Then
                        
                        
                        ReDim NumDone(MaxCurPos)
                        ReDim DoneThis(MaxCurPos)
                        
                        
                       
                    'Dim DXTmat2() As Double
                    ReDim TMat2(NumberOfSeqs, NumberOfSeqs)
                     For Y = 0 To MaxCurPos
                        NodeLen(Y) = CLng(NodeLen(Y) * 10000) / 10000
                     Next Y
                    For Y = 0 To MaxCurPos
                    
                    
                        If NodeOrder(Y) = NumberOfSeqs + 1 And Y > 2 Then Exit For
                        For Z = 0 To MaxCurPos
                            NumDone(Z) = 1
                        Next Z
                        If NodeOrder(Y) <= NumberOfSeqs Then
                        
                            TallyDist = NodeLen(NodeOrder(Y))
                            For Z = Y + 1 To MaxCurPos
                                If NodeOrder(Z) = NumberOfSeqs + 1 Then Exit For
                                If NodeOrder(Z) > NumberOfSeqs Then
                                    TallyDist = TallyDist + NodeLen(NodeOrder(Z)) * NumDone(NodeOrder(Z))
                                    NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                    
                                Else
                                    TMat2(NodeOrder(Y), NodeOrder(Z)) = (CLng((TallyDist + NodeLen(NodeOrder(Z))) * 10000)) / 10000
                                    TMat2(NodeOrder(Z), NodeOrder(Y)) = TMat2(NodeOrder(Y), NodeOrder(Z))
                                End If
                            Next Z
                        End If
                    Next Y
                        
                        
                        
                        
                        'Find greatest distance between seqs in tree
                        MD = 0
                        For Seq1 = 0 To NumberOfSeqs - 1
                            For Seq2 = Seq1 + 1 To NumberOfSeqs
                                If MD < TMat2(Seq1, Seq2) Then
                                    MD = TMat2(Seq1, Seq2)
                                    TB(0) = Seq1
                                    TB(1) = Seq2
                                End If
                            Next
                        Next
                        
                        MD = (CLng(MD * 100000) / 2) / 100000
                        For Y = 0 To MaxCurPos
                            NumDone(Y) = 1
                        Next Y
                        
                        'Find Midpoint of the Tree
                        For Y = 0 To MaxCurPos
                         If NodeOrder(Y) = TB(0) Then
                             
                             Pos = Y + 1
                             Do
                                    'mark the route
                                 If NodeOrder(Pos) > NumberOfSeqs Then
                                     NumDone(NodeOrder(Pos)) = NumDone(NodeOrder(Pos)) * -1
                                 Else
                                     If NodeOrder(Pos) = TB(1) Then
                                       Exit Do
                                     End If
                                 End If
                                 Pos = Pos + 1
                             Loop
                             TallyDist = NodeLen(NodeOrder(Y))
                             If TallyDist < MD Then
                                For Z = Y + 1 To Pos
                                    If NodeOrder(Z) > NumberOfSeqs Or NodeOrder(Z) = NodeOrder(Pos) Then
                                        If NumDone(NodeOrder(Z)) = -1 Or NodeOrder(Z) = NodeOrder(Pos) Then
                                            NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                            If TallyDist + NodeLen(NodeOrder(Z)) < MD Then
                                               TallyDist = TallyDist + NodeLen(NodeOrder(Z))
                                            Else
                                                Inside = 0
                                                C = Z
                                                Do While C > 0
                                                    C = C - 1
                                                    If NodeOrder(C) = NodeOrder(Z) Then
                                                        Inside = 1
                                                        Exit Do
                                                    End If
                                                    
                                                Loop
                                                'midpoint found
                                                If Inside = 0 Then
                                                    MidNode(0) = Z
                                                    MidNode(1) = MD - TallyDist
                                                    MidNode(2) = NodeLen(NodeOrder(Z)) - MidNode(1)
                                                    Exit For
                                                ElseIf Inside = 1 Then
                                                    MidNode(0) = Z
                                                    MidNode(2) = MD - TallyDist
                                                    MidNode(1) = NodeLen(NodeOrder(Z)) - MidNode(2)
                                                    Exit For
                                                End If
                                            End If
                                        End If
                                    End If
                                Next Z
                            Else
                                MidNode(0) = Y
                                MidNode(2) = MD
                                MidNode(1) = NodeLen(NodeOrder(Y)) - MidNode(2)
                            End If
                             Exit For
                         ElseIf NodeOrder(Y) = TB(1) Then
                            Pos = Y + 1
                             
                             'mark the route between the most distant sequences
                             Do
                               
                                 If NodeOrder(Pos) > NumberOfSeqs Then
                                     NumDone(NodeOrder(Pos)) = NumDone(NodeOrder(Pos)) * -1
                                 Else
                                     If NodeOrder(Pos) = TB(0) Then
                                       Exit Do
                                     End If
                                 End If
                                 Pos = Pos + 1
                             Loop
                             
                             'TallyDist = 0
                            TallyDist = NodeLen(NodeOrder(Y))
                            If TallyDist < MD Then
                                For Z = Y + 1 To Pos
                                    If NodeOrder(Z) > NumberOfSeqs Or NodeOrder(Z) = NodeOrder(Pos) Then
                                        If NumDone(NodeOrder(Z)) = -1 Or NodeOrder(Z) = NodeOrder(Pos) Then
                                            NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                            If TallyDist + NodeLen(NodeOrder(Z)) < MD Then
                                               TallyDist = TallyDist + NodeLen(NodeOrder(Z))
                                            Else
                                                Inside = 0
                                                C = Z
                                                Do While C > 0
                                                    C = C - 1
                                                    If NodeOrder(C) = NodeOrder(Z) Then
                                                        Inside = 1
                                                        Exit Do
                                                    End If
                                                    
                                                Loop
                                                'midpoint found
                                                If Inside = 0 Then
                                                    MidNode(0) = Z
                                                    MidNode(1) = MD - TallyDist
                                                    MidNode(2) = NodeLen(NodeOrder(Z)) - MidNode(1)
                                                    Exit For
                                                ElseIf Inside = 1 Then
                                                    MidNode(0) = Z
                                                    MidNode(2) = MD - TallyDist
                                                    MidNode(1) = NodeLen(NodeOrder(Z)) - MidNode(2)
                                                    Exit For
                                                End If
                                                
                                            End If
                                        End If
                                    End If
                                Next Z
                            Else
                                MidNode(0) = Y
                                MidNode(2) = MD
                                MidNode(1) = NodeLen(NodeOrder(Y)) - MidNode(2)
                            End If
                            Exit For
                             
                         End If
                     Next Y
                     
                     'Find out which sequences are "above" and which are "below" the midnode
                     
                     For Y = 0 To MaxCurPos
                        If NodeOrder(Y) = NodeOrder(MidNode(0)) Then Exit For
                        AbBe(Y) = 1
                     Next Y
                     For Y = MaxCurPos To 0 Step -1
                        If Y = MaxCurPos Then
                            Do While NodeOrder(Y) = 0
                                Y = Y - 1
                            Loop
                        End If
                        If NodeOrder(Y) = NodeOrder(MidNode(0)) Then Exit For
                        AbBe(Y) = 3
                     Next Y
                     For Y = MaxCurPos To 0 Step -1
                        If Y = MaxCurPos Then
                            Do While NodeOrder(Y) = 0
                                Y = Y - 1
                            Loop
                        End If
                        If AbBe(Y) = 0 Then
                            AbBe(Y) = 2
                        End If
                     Next Y
                     'now modify the tree distance matrix to reflect equil distances from the root
                     'In effect its lengthening the terminal branches so that the distance between
                     'sequences in a distance matrix will reflect their reletive positions in the tree
                     'in relation to the midpoint "root"
                     'first do the "left" part of the tree
                     For Y = 0 To MaxCurPos
                        
                            If NodeOrder(Y) <= NumberOfSeqs And DoneThis(NodeOrder(Y)) = 0 And AbBe(Y) > 0 Then
                                DoneThis(NodeOrder(Y)) = 1
                                TallyDist = 0
                                For Z = 0 To MaxCurPos
                                    NumDone(Z) = 1
                                Next Z
                                If NodeOrder(Y) = NodeOrder(MidNode(0)) Then
                                
                                Else
                                    TallyDist = TallyDist + NodeLen(NodeOrder(Y))
                                    NumDone(NodeOrder(Y)) = NumDone(NodeOrder(Y)) * -1
                                    If AbBe(Y) = 2 Or AbBe(Y) = 1 Then
                                        For Z = Y + 1 To MaxCurPos
                                            
                                            If NodeOrder(Z) = NodeOrder(MidNode(0)) Then
                                                TallyDist = TallyDist + MidNode(AbBe(Y))
                                                Modi = CLng((MD - TallyDist) * 100000) / 100000
                                                If Modi < 0 Then
                                                    x = x
                                                    Modi = 0
                                                End If
                                                C = NodeOrder(Y)
                                                For A = 0 To NumberOfSeqs
                                                    If A <> C Then
                                                        If (A = 0 And C = 2) Or (A = 2 And C = 0) Then
                                                            x = x
                                                        End If
                                                        TMat2(A, C) = TMat2(A, C) + Modi
                                                        TMat2(C, A) = TMat2(A, C)
                                                        If TMat2(A, C) < 0 And Modi < 0 Then
                                                            x = x
                                                        End If
                                                    End If
                                                Next A
                                                Exit For
                                            ElseIf NodeOrder(Z) > NumberOfSeqs Then
                                                'there is still a very big problem with this - its ading more distances than it should
                                                TallyDist = TallyDist + NodeLen(NodeOrder(Z)) * NumDone(NodeOrder(Z))
                                                NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                            End If
                                        Next Z
                                    Else
                                        For Z = Y - 1 To 0 Step -1
                                            
                                            If NodeOrder(Z) = NodeOrder(MidNode(0)) Then
                                                TallyDist = TallyDist + MidNode(1)
                                                Modi = CLng((MD - TallyDist) * 100000) / 100000
                                                If Modi < 0 Then
                                                    x = x
                                                    Modi = 0
                                                End If
                                                C = NodeOrder(Y)
                                                For A = 0 To NumberOfSeqs
                                                    If A <> C Then
                                                        If (A = 0 And C = 2) Or (A = 2 And C = 0) Then
                                                            x = x
                                                        End If
                                                        TMat2(A, C) = TMat2(A, C) + Modi
                                                        TMat2(C, A) = TMat2(A, C)
                                                        
                                                    End If
                                                Next A
                                                Exit For
                                            ElseIf NodeOrder(Z) > NumberOfSeqs Then
                                                'there is still a very big problem with this - its ading more distances than it should
                                                TallyDist = TallyDist + NodeLen(NodeOrder(Z)) * NumDone(NodeOrder(Z))
                                                NumDone(NodeOrder(Z)) = NumDone(NodeOrder(Z)) * -1
                                                
                                                
                                            End If
                                        Next Z
                                    End If
                                End If
                            ElseIf AbBe(Y) = 0 Then
                                Exit For
                            End If
                        
                     Next Y
                     
                            
                    End If
               End If
                For S1x = 0 To NumberOfSeqs - 1

                    For s2x = S1x + 1 To NumberOfSeqs
                        DstMat(x, S1x, s2x) = TMat2(S1x, s2x)
                        DstMat(x, s2x, S1x) = DstMat(x, S1x, s2x)
                    Next 'Seq2

                Next 'Seq1

            Next 'X

        End If
        
        For Y = 0 To BSBootReps - 1

            'For B = 0 To NumSets - 1
                'Read the distance values
                HiVal = 100

                If TopDistFlag = 0 Then
                    HiSeq = -1
                    For Z = 1 To NumberOfSeqs
                        
                        If HiVal > DstMat(Y, 0, Z) Then
                            HiVal = DstMat(Y, 0, Z)
                            HiSeq = Z
                        End If

                    Next 'Z
                    NumHigh = 0
                    For Z = 1 To NumberOfSeqs
                        If DstMat(Y, 0, Z) = HiVal Then
                            NumHigh = NumHigh + 1
                        End If
                    Next Z
                    IncrementX = 1 / NumHigh
                    For Z = 1 To NumberOfSeqs
                        If DstMat(Y, 0, Z) = HiVal Then
                            PltVal(Z, b) = PltVal(Z, b) + IncrementX
                        End If
                    Next Z
                    

                Else
                    
                    For Z = 1 To NumberOfSeqs
                        
                        If HiVal >= DstMat(Y, 0, Z) Then
                            HiVal = DstMat(Y, 0, Z)
                            HiSeq = Z
                        End If

                    Next 'Z
                    
                    A = HiSeq

                    For Z = 1 To NumberOfSeqs

                        If Z <> A Then
                            

                            If DstMat(Y, A, Z) < HiVal Then
                                NoScoreFlag = 1
                                Exit For
                            End If

                        End If

                    Next 'Z

                    If NoScoreFlag = 0 Then
                        NumHigh = 0
                        For Z = 1 To NumberOfSeqs
                            If DstMat(Y, 0, Z) = HiVal Then
                                NumHigh = NumHigh + 1
                            End If
                        Next Z
                        If NumHigh > 1 Then
                            x = x
                        End If
                        IncrementX = 1 / NumHigh
                        For Z = 1 To NumberOfSeqs
                            If DstMat(Y, 0, Z) = HiVal Then
                                PltVal(Z, b) = PltVal(Z, b) + IncrementX
                            End If
                        Next Z
                    Else
                        
                        
                        
                        NoScoreFlag = 0
                    End If

                End If

            'Next 'X

        Next 'Y

        If b > 0 And PltPos(b) > 0 And PltPos(b) < Len(StrainSeq(0)) Then
            Pict = Form1.Picture7.hdc
'            For X = 1 To NumberOfSeqs
'                Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
'                Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(b - 1)) * XFactor, 20 + (1 - PltVal(X, b - 1) / BSBootReps) * (PicHeight - 35), PntAPI)
'                Dummy = LineTo(Pict, 30 + Decompress(PltPos(b)) * XFactor, 20 + (1 - PltVal(X, b) / BSBootReps) * (PicHeight - 35))
'            Next X
'            Form1.Picture7.Refresh
        End If
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6(0).Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        If b / 5 = Int(b / 5) Then

            With Form1
                .ProgressBar1 = (b / NumWins) * 100
                .SSPanel1.Caption = b & " of " & NumWins & " windows examined"
                
            End With

        End If
        
        'Form1.Refresh
'        If DebuggingFlag < 2 Then
'            Form1.WindowState = Form1.WindowState
'        End If
        'Erase DstMat
    Next 'B
    Call DrawManBSPlot
    'Call DrawBSPlotsIII
    Form1.Picture21.Width = Form1.Picture7.Width + 100
    Form1.Picture21.Height = Form1.Picture7.Height + 100
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5

    
    EE = Abs(GetTickCount)
    TT = EE - SS
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
End Sub

Public Function MakePrintSeqLen() As Long
     '@
     PrintSeqLen = (3 + Form1.Picture9.ScaleWidth / Form1.Picture1.TextWidth("G"))
     MakePrintSeqLen = PrintSeqLen
    
End Function

Public Sub ResizeForm1()
    
'    RF1Count = RF1Count + 1
'    Form1.Caption = RF1Count
'    Form1.Refresh
    If DoingShellFlag > 0 And OKToResizeF1 = 0 Then 'OKToResizeF1 = 1
        Exit Sub
    End If
    If UpdateProgressBar = 1 Then
        Exit Sub
    End If
    If Form1.Command3.Visible = True And Form1.Command3.Enabled = True Then
    '@
    Form1.Command3.SetFocus
    End If
    Dim GoOn As Byte

    'Resizes the interface to suit the current windows screen resolution
    If F1BusyResizing = 1 Then
        Exit Sub
    End If
    F1BusyResizing = 1
    If CurrentlyRunningFlag = 1 Then
        F1BusyResizing = 0
        Exit Sub
    End If
    
    On Error Resume Next
    If Form1.Width < ((Form1.Command12(1).Width * 2.1) + 1000) * 2 + 500 Then
        
        Form1.Width = ((Form1.Command12(1).Width * 2.1) + 1000) * 2 + 500
        
        GoOn = 1
    End If
    'XX = Form1.Command12(1).Height * 8 + 3000
    If Form1.Height < Form1.Command12(1).Height * 8 + 3000 Then
        Form1.Height = Form1.Command12(1).Height * 8 + 3000
        GoOn = 1
    End If
    On Error GoTo 0
    
    
    'XX = Form1.Height
    'If GoOn = 1 Then Exit Sub
    Dim ScreenTwipsPerPixelX  As Long, ODDKey As Byte, OV1 As Byte, OV2 As Byte, OV0 As Byte, OHE As Byte, OVE As Byte
    Dim A As Long, DontRefreshSeqsFlag As Byte, DontRefreshP6Flag As Byte
    Dim x As Long, SS60 As Byte, SS61 As Byte, SS62 As Byte
    'ssxx = Abs(GetTickCount)
    ScreenTwipsPerPixelX = Screen.TwipsPerPixelX
    TwipPerPix = ScreenTwipsPerPixelX
    Form1.ScaleMode = 1
    Form1.Picture12.Visible = False
    With Form1
        SS60 = .SSPanel6(0).Visible
        SS61 = .SSPanel6(1).Visible
        SS62 = .SSPanel6(2).Visible
        If SS60 + SS61 + SS62 = 0 Then
            SS60 = 1
        End If
        .SSPanel6(0).Visible = False
        '@
        .SSPanel6(1).Visible = False
        .SSPanel6(2).Visible = False
        .SSPanel3.Visible = False
        '@
        .SSPanel8.Visible = False
        '@
        .SSPanel5.Visible = False
        .SSPanel7.Visible = False 'progressbar panel
        .SSPanel4.Visible = False
        
        Dim RedoPicsFlag As Byte
        
        
        If NextNo > 0 Then
            RedoPicsFlag = 1
            If F1MDF = 0 And F1RF = 0 Then
                .Picture1.Picture = LoadPicture()
                .Picture2.Picture = LoadPicture()
                .Picture16.Picture = LoadPicture()
                '.Picture26.Picture = LoadPicture()
    
                If .Picture16.Picture <> 0 Then .Picture16.Picture = LoadPicture()
            

                If RunFlag = 1 Then
    
                    If Form2.Visible = True Then Unload Form2
                    
                    .Picture7.Picture = LoadPicture()
                    .Picture10.Picture = LoadPicture()
                    .Picture19.Picture = LoadPicture()
                    .Picture20.Picture = LoadPicture()
                    ORFFlag = 0
                    .Picture6.Picture = LoadPicture()
                    .VScroll2.Value = 0
                End If
            End If

        End If
        If F1MDF = 0 And F1RF = 0 Then
            .Text5.Text = XOverWindowX
            .Text1.Text = LowestProb
         End If
        
        If RedoPicsFlag = 0 Then
            .SSPanel6(0).Enabled = False
            .SSPanel6(1).Enabled = False
            .SSPanel6(2).Enabled = False
            .SSPanel3.Enabled = False
            .SSPanel4.Enabled = False
            .SSPanel5.Enabled = False
            .Picture7.Enabled = False
        Else
            .SSPanel6(0).Enabled = True
            .SSPanel6(1).Enabled = True
            .SSPanel6(2).Enabled = True
            .SSPanel3.Enabled = True
            .SSPanel4.Enabled = True

            If RunFlag = 1 Then
                .SSPanel5.Enabled = True
                .Picture7.Enabled = True
            End If

        End If
        
        .Command9.Visible = True
        .Command10.Visible = True
        .Command5.Visible = True
        '.command9.style = 0
        .Command9.BackColor = Form3.Command4.BackColor
        .Command10.BackColor = Form3.Command4.BackColor
        .Command5.BackColor = Form3.Command4.BackColor
        'Adjust arrangement and sizes of controlls on the screen according to the
        'current screen resolution and font sizes.
        
        .Picture13.FontSize = 8.25
        .Picture2.FontSize = 7
        .Picture7.FontSize = 7

        If Screen.Height = 7200 Then

            If ScreenTwipsPerPixelX = 12 Then   'ie 800 X 600 resolution with large fonts
                VAddjust = 7050 / 9000
                HAddjust = Screen.Width / 12000
                
            Else       'ie 640 X 480 resolution with small fonts
                VAddjust = 7050 / 9000
                HAddjust = Screen.Width / 12000
                
                'PrintSeqLen = 58 * HAddjust / TYF
                
            End If

        ElseIf Screen.Height = 9000 Then  'ie 800 X 600 resolution with small fonts
            HAddjust = 1
            VAddjust = 1
            .Label58.FontSize = 8
            'PrintSeqLen = 58 / TYF
            
        ElseIf Screen.Height = 9216 Then  'ie 1024 X 758 resolution with large fonts
            VAddjust = 9316 / 9000
            HAddjust = Screen.Width / 12000
            .Picture1.Top = 0
            .Picture13.FontSize = 6
            'PrintSeqLen = 70 * HAddjust / TYF
            
            .Picture1.Font.Name = "Courier New"
            .Picture1.FontSize = 8
            P1FontSize = .Picture1.FontSize
            .Picture2.FontSize = 5
            .Picture7.FontSize = 5
            .Command7.FontSize = 7
            
        ElseIf Screen.Height >= 11520 Then  'ie 1024 X 768 resolution with small fonts
            VAddjust = 11700 / 9000
            HAddjust = Screen.Width / 12000
            'PrintSeqLen = 58 * HAddjust / TYF
            
        Else
            VAddjust = Screen.Height / 9000
            HAddjust = Screen.Width / 12000
            'PrintSeqLen = 58 * HAddjust / TYF
            
        End If
        
        
        If Screen.Height = 7200 Then

            SmallF2LabelFlag = 1
        ElseIf Screen.Height < 9000 Then  'ie 800 X 600 resolution with small fonts

            SmallF2LabelFlag = 2
            'PrintSeqLen = 58 / TYF
        ElseIf Screen.Height = 9000 Then  'ie 800 X 600 resolution with small fonts

            SmallF2LabelFlag = 2
            'PrintSeqLen = 58 / TYF
            
        ElseIf Screen.Height = 9216 Then  'ie 1024 X 758 resolution with large fonts

            SmallF2LabelFlag = 2
        ElseIf Screen.Height < 11520 Then 'ie 1024 X 758 resolution with large fonts

            SmallF2LabelFlag = 2
        ElseIf Screen.Height < 20000 Then  'ie 1024 X 768 resolution with small fonts
           
            SmallF2LabelFlag = 3
        Else
            
            SmallF2LabelFlag = 0
        End If
        
        If ScreenTwipsPerPixelX = 12 Then
            .Label58.FontSize = 6
            .Label58.Height = 200
            
            .Picture1.Font.Name = "Courier New"
            .Picture1.FontSize = 8
            P1FontSize = .Picture1.FontSize
            .Picture13.FontSize = 6
            .Label14.FontSize = 7
            'PrintSeqLen = 58 / TYF
            .Command1.FontSize = 8
            .Command18.FontSize = 8
            .Command22.FontSize = 8
            .Command12(0).FontSize = 8
            .Command12(1).FontSize = 8
            .Command9.FontSize = 8
            .Command10.FontSize = 8
            .Command38.FontSize = 8
            .Label1.FontSize = 7
            .Label15.FontSize = 7
            .Label21.FontSize = 6
            .Frame7.FontSize = 6.5
            .Frame6.FontSize = 6.5
            .Picture3.FontSize = 7
            .Picture2.FontSize = 6
            .Picture7.FontSize = 6
            .Command7.FontSize = 7
             Dim ZZ As Long
             For ZZ = 0 To 2
                .Command13(ZZ).FontSize = 7
                
                .Command4(ZZ).FontSize = 7
                
                .Command8(ZZ).FontSize = 7
               
            Next ZZ
            RowSpace = 250
            .Label54(6).FontSize = 6
            .Label54(0).FontSize = 6
            .Label54(1).FontSize = 6
            .Label54(9).FontSize = 6
            .Label50(14).FontSize = 6
            .Label50(15).FontSize = 6
            .Label54(2).FontSize = 6
            .Label54(3).FontSize = 6
            .Label54(4).FontSize = 6
            .Label54(5).FontSize = 6
            .Label54(8).FontSize = 6
            .Label54(7).FontSize = 6
            .Label50(0).FontSize = 6
            .Label50(1).FontSize = 6
            .Label50(2).FontSize = 6
            .Label50(3).FontSize = 6
            .Label50(4).FontSize = 6
            .Label50(5).FontSize = 6
            .Label50(6).FontSize = 6
            .Label50(7).FontSize = 6
            .Label50(8).FontSize = 6
            .Label50(9).FontSize = 6
            .Label50(10).FontSize = 6
            .Label50(11).FontSize = 6
            .Label50(12).FontSize = 6
            .Label50(13).FontSize = 6
        Else
            .Label58.FontSize = 8.25
            .Label58.Height = 285
            
            .Picture1.Font.Name = "Courier"
            '.Picture.Font = ""
            .Picture1.FontSize = 9.75
            P1FontSize = .Picture1.FontSize
            .Picture13.FontSize = 8.25
            .Label14.FontSize = 8.25
            'PrintSeqLen = 58 / TYF
            .Command1.FontSize = 8.25
            .Command18.FontSize = 8.25
            .Command22.FontSize = 8.25
            .Command7.FontSize = 8.25
            .Command38.FontSize = 8.25
            .Command12(0).FontSize = 8.25
            .Command12(1).FontSize = 8.25
            .Command9.FontSize = 8.25
            .Command10.FontSize = 8.25
            .Label1.FontSize = 8.25
            .Label15.FontSize = 8.25
            .Label21.FontSize = 8.25
            .Frame7.FontSize = 8.25
            .Frame6.FontSize = 8.25
            .Picture2.FontSize = 6.75
            .Picture7.FontSize = 6.75
            For ZZ = 0 To 2
                .Command13(ZZ).FontSize = 8.25
                
                .Command4(ZZ).FontSize = 8.25
                
                .Command8(ZZ).FontSize = 8.25
               
            Next ZZ


            If Screen.Height > 7200 Then
                If Screen.Height > 9050 Then
                    RowSpace = 350
                Else
                    RowSpace = 300
                End If
                .Label54(6).FontSize = 8.25
                .Label54(0).FontSize = 8.25
                .Label54(1).FontSize = 8.25
                .Label54(9).FontSize = 8.25
                .Label50(14).FontSize = 8.25
                .Label50(15).FontSize = 8.25
                .Label54(2).FontSize = 8.25
                .Label54(3).FontSize = 8.25
                .Label54(4).FontSize = 8.25
                .Label54(5).FontSize = 8.25
                .Label54(8).FontSize = 8.25
                .Label54(7).FontSize = 8.25
                .Label50(0).FontSize = 8.25
                .Label50(1).FontSize = 8.25
                .Label50(2).FontSize = 8.25
                .Label50(3).FontSize = 8.25
                .Label50(4).FontSize = 8.25
                .Label50(5).FontSize = 8.25
                .Label50(6).FontSize = 8.25
                .Label50(7).FontSize = 8.25
                .Label50(8).FontSize = 8.25
                .Label50(9).FontSize = 8.25
                .Label50(10).FontSize = 8.25
                .Label50(11).FontSize = 8.25
                .Label50(12).FontSize = 8.25
                .Label50(13).FontSize = 8.25
            Else
                RowSpace = 250
                .Label54(6).FontSize = 6
                .Label54(0).FontSize = 6
                .Label54(1).FontSize = 6
                .Label54(9).FontSize = 6
                .Label50(14).FontSize = 6
                .Label50(15).FontSize = 6
                .Label54(2).FontSize = 6
                .Label54(3).FontSize = 6
                .Label54(4).FontSize = 6
                .Label54(5).FontSize = 6
                .Label54(8).FontSize = 6
                .Label54(7).FontSize = 6
                .Label50(0).FontSize = 6
                .Label50(1).FontSize = 6
                .Label50(2).FontSize = 6
                .Label50(3).FontSize = 6
                .Label50(4).FontSize = 6
                .Label50(5).FontSize = 6
                .Label50(6).FontSize = 6
                .Label50(7).FontSize = 6
                .Label50(8).FontSize = 6
                .Label50(9).FontSize = 6
                .Label50(10).FontSize = 6
                .Label50(11).FontSize = 6
                .Label50(12).FontSize = 6
                .Label50(13).FontSize = 6
            End If

        End If

        'Do comparison Table

        Dim LeftCorner As Long
        Dim TopCorner As Long
        Dim ColSpace As Integer

        LeftCorner = 800
        TopCorner = 0
        ColSpace = 1500
        If F1MDF > 0 Or F1RF > 0 Then
            .Frame17.Visible = False
        
        End If
        
        .Line44(0).X1 = (ColSpace * 0 + LeftCorner) * HAddjust
        .Line44(0).Y1 = (RowSpace * 0.75 + TopCorner) * VAddjust
        .Line44(0).X2 = (ColSpace * 3 + LeftCorner) * HAddjust
        .Line44(0).Y2 = (RowSpace * 0.75 + TopCorner) * VAddjust
        .Line44(1).X1 = (ColSpace * 0 + LeftCorner) * HAddjust
        .Line44(1).Y1 = (RowSpace * 6.75 + TopCorner) * VAddjust
        .Line44(1).X2 = (ColSpace * 3 + LeftCorner) * HAddjust
        .Line44(1).Y2 = (RowSpace * 6.75 + TopCorner) * VAddjust
        .Line44(2).X1 = (ColSpace * 0 + LeftCorner) * HAddjust
        .Line44(2).Y1 = (RowSpace * 8 + TopCorner) * VAddjust
        .Line44(2).X2 = (ColSpace * 3 + LeftCorner) * HAddjust
        .Line44(2).Y2 = (RowSpace * 8 + TopCorner) * VAddjust
        
        
        ' .picture7.Line ((ColSpace * 1 + LeftCorner) * HAddjust, (RowSpace * 1 + TopCorner) * VAddjust)-((ColSpace * 3 + LeftCorner) * HAddjust, (RowSpace * 1 + TopCorner) * VAddjust), QBColor(0)
        '.Label21.FontSize = .Label21.FontSize * VAddjust
        'If .Label21.FontSize > .Command1.FontSize Then .Label21.FontSize = .Command1.FontSize
        
        If F1MDF = 0 And F1RF = 0 Then
            'Sort out spacing of .command buttons (buttons in .sspanel2)
            .SSPanel2.Left = 2 * Screen.TwipsPerPixelX
            .SSPanel2.Top = 2 * Screen.TwipsPerPixelY
            .SSPanel2.Width = 605 * Screen.TwipsPerPixelX
            
            If (Screen.Height / Screen.TwipsPerPixelY) < 1080 Then
                .SSPanel2.Height = 28 * Screen.TwipsPerPixelY
            Else
                .SSPanel2.Height = 34 * Screen.TwipsPerPixelY
            End If
            .HScroll3.Top = .SSPanel2.Top + 2
            .HScroll3.Left = .SSPanel2.Left + 2
            .HScroll3.Max = 1
            'Open Button
            .Command1.Top = 2 * Screen.TwipsPerPixelY
            .Command1.Height = .SSPanel2.Height - 4 * Screen.TwipsPerPixelY
            .Command1.Left = 5 * Screen.TwipsPerPixelX
            .Command1.Width = 70 * Screen.TwipsPerPixelX
            .Command2(0).Top = .Command1.Top
            .Command2(0).Height = .Command1.Height
            .Command2(0).Left = 74 * Screen.TwipsPerPixelX
            .Command2(0).Width = 16 * Screen.TwipsPerPixelX
            'Save Button
            .Command18.Left = 90 * Screen.TwipsPerPixelX
            .Command18.Width = 85 * Screen.TwipsPerPixelX
            .Command18.Top = .Command1.Top
            .Command18.Height = .Command1.Height
            .Command2(1).Top = .Command1.Top
            .Command2(1).Height = .Command1.Height
            .Command2(1).Left = 159 * Screen.TwipsPerPixelX
            .Command2(1).Width = 16 * Screen.TwipsPerPixelX
            .Command2(1).Visible = False
            'Xover button
            
            .Command22.Left = 175 * Screen.TwipsPerPixelX
            .Command22.Width = 85 * Screen.TwipsPerPixelX
            .Command22.Top = .Command1.Top
            .Command22.Height = .Command1.Height
            .Command2(2).Top = .Command1.Top
            .Command2(2).Height = .Command1.Height
            .Command2(2).Left = 244 * Screen.TwipsPerPixelX
            .Command2(2).Width = 16 * Screen.TwipsPerPixelX
            .Command2(2).Visible = False
            'Draw Tree
            .Command7.Left = 260 * Screen.TwipsPerPixelX
            .Command7.Width = 85 * Screen.TwipsPerPixelX
            .Command7.Top = .Command1.Top
            .Command7.Height = .Command1.Height
            
            .Command2(3).Top = .Command1.Top
            .Command2(3).Height = .Command1.Height
            .Command2(3).Left = 329 * Screen.TwipsPerPixelX
            .Command2(3).Width = 16 * Screen.TwipsPerPixelX
            .Command2(3).Visible = False
            'matrices
            .Command38.Left = 345 * Screen.TwipsPerPixelX
            .Command38.Width = 85 * Screen.TwipsPerPixelX
            .Command38.Top = .Command1.Top
            .Command38.Height = .Command1.Height
            
            .Command2(4).Top = .Command1.Top
            .Command2(4).Height = .Command1.Height
            .Command2(4).Left = 414 * Screen.TwipsPerPixelX
            .Command2(4).Width = 16 * Screen.TwipsPerPixelX
            .Command2(4).Visible = False
            
            'save?
            .Command3.Top = .Command1.Top
            .Command3.Height = .Command1.Height
            .Command3.Left = 160 * HAddjust
            .Command3.Width = 800 * HAddjust
            .Command1.MouseIcon = .Command18.MouseIcon
            .Command1.MousePointer = 99
            
            .Command12(0).Left = 430 * Screen.TwipsPerPixelX
            .Command12(0).Width = 85 * Screen.TwipsPerPixelX
            .Command12(0).Top = .Command1.Top
            .Command12(0).Height = .Command1.Height
            .Command12(1).Left = 515 * Screen.TwipsPerPixelX
            .Command12(1).Width = 85 * Screen.TwipsPerPixelX
            .Command12(1).Top = .Command1.Top
            .Command12(1).Height = .Command1.Height
            .Command12(1).MouseIcon = .Command18.MouseIcon
            .Command12(1).MousePointer = 99
        End If
        'Arrange homology panel/window (.sspanel4)
        
        .SSPanel4.Left = .SSPanel2.Left
        .SSPanel4.Top = .SSPanel2.Height + 3 * Screen.TwipsPerPixelY
        .SSPanel4.Height = .SSPanel2.Height + 2 * Screen.TwipsPerPixelY
        
        If F1MDF = 0 And F1RF = 0 Then
            SSP4Fract = 0.7
            .SSPanel4.Width = .ScaleWidth * 0.7
            If .SSPanel4.Width < ((.Command12(1).Width * 2.1) + 1000) * 2 + 5 Then
                .SSPanel4.Width = ((.Command12(1).Width * 2.1) + 1000) * 2 + 5
            End If
            'XX = .SSPanel4.Width / Form1.ScaleWidth
            'XX = XX
        ElseIf F1RF = 1 Then
            'XX = .SSPanel4.Width
            'If SSP4Fract < 0.3 Then
            '    SSP4Fract = 0.3
            'End If
            .SSPanel4.Width = .ScaleWidth * SSP4Fract
        ElseIf F1MDF > 0 Then
            'XX = .SSPanel4.Width
            'If SSP4Fract < 0.3 Then
            '    SSP4Fract = 0.3
            'End If
            .SSPanel4.Width = .ScaleWidth * SSP4Fract
        End If
        If .SSPanel4.Width < (.Command12(1).Width * 2.1) + 1000 Then '290 * Screen.TwipsPerPixelX Then
            .SSPanel4.Width = (.Command12(1).Width * 2.1) + 1000 '290 * Screen.TwipsPerPixelX
'            If .ScaleWidth < .SSPanel4.Width * 2 Then
'                .ScaleWidth = .SSPanel4.Width * 2
'            End If
            
            SSP4Fract = .SSPanel4.Width / .ScaleWidth
        End If
        If SSP4Fract > 0.5 Then
            If (.ScaleWidth - .SSPanel4.Width) - 5 < (.Command12(1).Width * 2.1) + 1000 Then
                x = x
                SSP4Fract = (.ScaleWidth - ((.Command12(1).Width * 2.1) + 1000 + 5)) / .ScaleWidth
                .SSPanel4.Width = .ScaleWidth * SSP4Fract
                If .SSPanel4.Width < (.Command12(1).Width * 2.1) + 1000 Then '290 * Screen.TwipsPerPixelX Then
                    .SSPanel4.Width = (.Command12(1).Width * 2.1) + 1000 '290 * Screen.TwipsPerPixelX
        '            If .ScaleWidth < .SSPanel4.Width * 2 Then
        '                .ScaleWidth = .SSPanel4.Width * 2
        '            End If
                    
                    SSP4Fract = .SSPanel4.Width / .ScaleWidth
                End If
                
                
            End If
        End If
        
        .SSPanel11.Width = 100 * Screen.TwipsPerPixelX
        .SSPanel11.Left = .SSPanel4.Width - .SSPanel11.Width - 4 * Screen.TwipsPerPixelX
        .SSPanel11.Top = 3 * Screen.TwipsPerPixelY
        .SSPanel11.Height = .SSPanel4.Height - 6 * Screen.TwipsPerPixelY
        .Command6(1).Top = .SSPanel11.Top
        .Command6(1).Height = .SSPanel11.Height
        .Command6(1).Width = .SSPanel11.Height
        .Command6(1).Left = .SSPanel11.Left - .Command6(1).Width - 4 * Screen.TwipsPerPixelX
        .Command6(1).MouseIcon = .Command18.MouseIcon
        .Command6(1).MousePointer = 99
        
        .Label15.Left = 2 * Screen.TwipsPerPixelX
        .Label15.Width = .SSPanel11.Width - 4 * Screen.TwipsPerPixelX
        
        .Label15.Height = .TextHeight("O") '+ 2 * Screen.TwipsPerPixelY '.SSPanel11.Height - 8 * Screen.TwipsPerPixelY
        .Label15.Top = (.SSPanel11.Height - .Label15.Height) / 2 '.Picture1.TextHeight(O) + 2 * Screen.TwipsPerPixelY
        
        .Picture4.Top = .SSPanel11.Top
        .Picture4.Height = .SSPanel11.Height
        .Picture4.Left = 4 * Screen.TwipsPerPixelX
        .Picture4.Width = .Command6(1).Left - 8 * Screen.TwipsPerPixelX
        
        .Picture11.Top = .SSPanel11.Top
        .Picture11.Height = .SSPanel11.Height
        .Picture11.Left = .Picture4.Left
        .Picture11.Width = .Picture4.Width
        'Arrange .progressbar panel (.sspanel7)
        .SSPanel7.Height = 30 * Screen.TwipsPerPixelY
        'XX = .SSPanel7.Height
        'XX = TaskBarHeight
        'XX = Form1.ScaleHeight
        'yy = Form1.Height
        If .WindowState = 2 Then
            .SSPanel7.Top = .ScaleHeight - .SSPanel7.Height 'Form1OHeight - .SSPanel7.Height + 12 * Screen.TwipsPerPixelY
        ElseIf Form1.WindowState = 0 Then
            .SSPanel7.Top = .ScaleHeight - .SSPanel7.Height
        End If
        .SSPanel7.Left = 0
        .SSPanel7.Width = .ScaleWidth
        .SSPanel1.Left = 4 * Screen.TwipsPerPixelX
        .SSPanel1.Width = 500 * Screen.TwipsPerPixelX
        .SSPanel1.Top = 4 * Screen.TwipsPerPixelY
        .SSPanel1.Height = .SSPanel7.Height - 8 * Screen.TwipsPerPixelY
        .SSPanel12.Left = .SSPanel1.Width + 8 * Screen.TwipsPerPixelX
        .SSPanel12.Height = .SSPanel1.Height
        .SSPanel12.Top = .SSPanel1.Top
        If .SSPanel7.Width - (.SSPanel12.Left + 4 * Screen.TwipsPerPixelX) > 0 Then
            .SSPanel12.Width = .SSPanel7.Width - (.SSPanel12.Left + 4 * Screen.TwipsPerPixelX)
        Else
            .SSPanel12.Width = 0
        End If
        .ProgressBar1.ZOrder
        .ProgressBar1.Left = 3 * Screen.TwipsPerPixelX
        If .SSPanel12.Width - 6 * Screen.TwipsPerPixelX > 0 Then
            .ProgressBar1.Width = .SSPanel12.Width - 6 * Screen.TwipsPerPixelX
        Else
            .ProgressBar1.Width = 0
        End If
        .ProgressBar1.Height = .SSPanel12.Height - 6 * Screen.TwipsPerPixelY
        .ProgressBar1.Top = 3 * Screen.TwipsPerPixelY
        .SSPanel13.Left = 3 * Screen.TwipsPerPixelX
        .SSPanel13.Height = .ProgressBar1.Height
        .SSPanel13.Top = .ProgressBar1.Top
        .SSPanel13.Width = 225 * Screen.TwipsPerPixelX
        .SSPanel13.Font = .SSPanel1.Font

        
        If F1MDF > 0 Or F1RF > 0 Then
            OV0 = .SSPanel6(0).Visible
            OV1 = .SSPanel6(1).Visible
            OV2 = .SSPanel6(2).Visible
            For x = 0 To 2
                .SSPanel6(x).Visible = False
            Next x
        End If
        'Arrange recombination info panel (.sspanel6(0))
        
        
        
        
        
        If F1MDF = 0 And F1RF = 0 Then
            
            For x = 0 To 2
                .SSPanel6(x).Left = .SSPanel4.Width + .SSPanel4.Left + 4 * Screen.TwipsPerPixelX
                .SSPanel6(x).Top = .SSPanel4.Top
                
                .SSPanel6(x).Height = .SSPanel4.Height + (.SSPanel7.Top - (.SSPanel4.Top + .SSPanel4.Height) - 12 * Screen.TwipsPerPixelY) / 1.8
                
                .SSPanel6(x).Width = .ScaleWidth - .SSPanel6(x).Left
                
            Next 'X
            'If .SSPanel6(0).Height < 2115 Then
            '    .SSPanel6(0).Height = 2115
            'E
            
            SSP6Fract = .SSPanel6(0).Height / .ScaleHeight
        ElseIf F1MDF > 0 Then
            
            'XX = .SSPanel6(0).Height '2115
            If .SSPanel6(0).Height < 2115 Then .SSPanel6(0).Height = 2115
            SSP6Fract = .SSPanel6(0).Height / .ScaleHeight
            For x = 0 To 2
                .SSPanel6(x).Left = .SSPanel4.Width + .SSPanel4.Left + 4 * Screen.TwipsPerPixelX
                .SSPanel6(x).Top = .SSPanel4.Top
                    
                .SSPanel6(x).Height = .SSPanel6(0).Height
                
                
                If .ScaleWidth - .SSPanel6(x).Left > 0 Then
                    .SSPanel6(x).Width = .ScaleWidth - .SSPanel6(x).Left
                Else
                    .SSPanel6(x).Width = 0
                End If
            Next x
            
         ElseIf F1RF = 1 Then
            
            'If .Height < .Command12(1).Height * 8 + 3000 Then
            '    .Height = .Command12(1).Height * 8 + 3000
            'End If
            
            If .SSPanel6(0).Height < 2115 Then .SSPanel6(0).Height = 2115
            SSP6Fract = .SSPanel6(0).Height / .ScaleHeight
            'XX = .SSPanel6(0).Height
            
            
            
            If SSP6Fract < 0.5 Then
                    
            Else
                If (.ScaleHeight * (1 - SSP6Fract)) < 3000 Then
                    SSP6Fract = (1 - (3000 / .ScaleHeight))
                End If
            End If
            
            
            For x = 0 To 2
                .SSPanel6(x).Left = .SSPanel4.Width + .SSPanel4.Left + 4 * Screen.TwipsPerPixelX
                .SSPanel6(x).Top = .SSPanel4.Top
                .SSPanel6(x).Height = .ScaleHeight * SSP6Fract
                .SSPanel6(x).Width = .ScaleWidth - .SSPanel6(x).Left
                
            Next x
        End If
        'Arrange all buttons
        If F1MDF = 0 And F1RF = 0 Then
            .SSPanel6(0).ZOrder
        End If
        For x = 0 To 2
            .Command13(x).Top = .Command6(0).Top
            .Command13(x).Width = (.SSPanel6(0).Width - 2 * Screen.TwipsPerPixelX) / 3
            .Command13(x).Height = .Command1.Height
        Next 'X

        .Command13(0).Left = 1 * Screen.TwipsPerPixelX
        .Command13(1).Left = .Command13(0).Left + .Command13(0).Width
        .Command13(2).Left = .Command13(1).Left + .Command13(1).Width
        If .SSPanel6(0).Width - 24 * Screen.TwipsPerPixelY > 0 Then
            .SSPanel16.Width = .SSPanel6(0).Width - 24 * Screen.TwipsPerPixelY
        Else
            .SSPanel16.Width = 0
        End If
        .SSPanel16.Top = .Command13(0).Top + .Command13(0).Height + 4 * Screen.TwipsPerPixelY
        .SSPanel16.Left = 4 * Screen.TwipsPerPixelY
        .SSPanel16.Height = 22 * Screen.TwipsPerPixelY
        If F1MDF = 0 And F1RF = 0 Then
            .SSPanel16.Caption = ""
            .SSPanel16.ForeColor = BackColours
            .SSPanel16.BackColor = HalfColour
            .SSPanel16.Font.Bold = True
        End If
        
        .Picture32.Top = .Command13(0).Top + .Command13(0).Height + 30 * Screen.TwipsPerPixelY
        .Picture32.Left = 4 * Screen.TwipsPerPixelY
        If .SSPanel6(0).Width - 24 * Screen.TwipsPerPixelY > 0 Then
            .Picture32.Width = .SSPanel6(0).Width - 24 * Screen.TwipsPerPixelY
        Else
            .Picture32.Width = 0
        End If
        PrintCharLenFlag = 0 'this ensures that text in picturebox2 is scaled properly
        .Picture32.Height = .SSPanel6(0).Height - .Picture32.Top - 4 * Screen.TwipsPerPixelY
        .Picture32.ScaleMode = 1
        .VScroll4.Top = .Picture32.Top
        .VScroll4.Width = 12 * Screen.TwipsPerPixelY
        .VScroll4.Left = .SSPanel6(0).Width - .VScroll4.Width - 4 * Screen.TwipsPerPixelY
        .VScroll4.Height = .Picture32.Height
        If (F1MDF > 0 Or F1RF > 0) And P2DHeight > 0 Then
            If P2DHeight - (.Picture32.ScaleHeight / Screen.TwipsPerPixelY) > 0 Then
                .VScroll4.Max = P2DHeight - (.Picture32.ScaleHeight / Screen.TwipsPerPixelY)
            End If
        End If
        .VScroll4.Min = 0
        .VScroll4.LargeChange = .Picture32.ScaleHeight / Screen.TwipsPerPixelY
        .VScroll4.SmallChange = 13
        If F1MDF = 0 And F1RF = 0 Then
            .VScroll4.Enabled = False
            .Picture2.Top = 0
        
        End If
        
        'XX = .SSPanel6(0).Height
        .Picture2.Left = 0
        .Picture2.Width = .Picture32.ScaleWidth
        .Picture2.Height = 15000
        .Picture2.ScaleMode = 1
        .Picture2.MouseIcon = .Command1.MouseIcon
        'Arrange Tree Panel (.sspanel6(1))
        
        
        '''''''''''''''''''''''''''''''''0.015, 0.016
        For x = 0 To 2
            .Command8(x).Top = .Command6(0).Top
            .Command8(x).Width = (.SSPanel6(0).Width - 2 * Screen.TwipsPerPixelX) / 3
            .Command8(x).Height = .Command1.Height
        Next 'X

        .Command8(1).Left = 1 * Screen.TwipsPerPixelX
        .Command8(0).Left = .Command13(0).Left + .Command13(0).Width
        .Command8(2).Left = .Command13(1).Left + .Command13(1).Width
        .Command17.Height = .Command6(1).Height
        .Command17.Width = .Command6(1).Width
        .Command17.Left = .SSPanel6(0).Width - .Command17.Width - 4 * Screen.TwipsPerPixelX
        
        .Command17.Top = .Command8(0).Top + .Command8(0).Height + 4 * Screen.TwipsPerPixelY
        .Command6(3).Top = .Command17.Top
        .Command33(2).Top = .Command17.Top
        .Command33(3).Top = .Command17.Top
        
        .Command6(3).Height = .Command17.Height
        .Command33(2).Height = .Command17.Height
        .Command33(3).Height = .Command17.Height
        
        .Command33(2).MouseIcon = .Command1.MouseIcon
        .Command33(2).MousePointer = 99
        .Command33(3).MouseIcon = .Command1.MouseIcon
        .Command33(3).MousePointer = 99
        .Command6(3).Width = .Command17.Width
        .Command33(2).Width = .Command17.Width
        .Command33(3).Width = .Command17.Width
        
        .Command6(3).Left = .Command17.Left - .Command6(3).Width
        .Command33(2).Left = .Command6(3).Left - .Command6(3).Width
        .Command33(3).Left = .Command33(2).Left - .Command6(3).Width
        
        .Label14.Top = .Command17.Top + 3 * Screen.TwipsPerPixelY
        .Label14.Left = 4 * Screen.TwipsPerPixelX
        .Label14.Height = .Command17.Height
        If .Command33(3).Left - 8 * Screen.TwipsPerPixelX > 0 Then
            .Label14.Width = .Command33(3).Left - 8 * Screen.TwipsPerPixelX
        Else
            .Label14.Width = 0
        End If
        .VScroll1.Top = .Command17.Top + .Command17.Height + 4 * Screen.TwipsPerPixelY
        .VScroll1.Width = 12 * Screen.TwipsPerPixelY
        .VScroll1.Left = .SSPanel6(1).Width - .VScroll1.Width - 4 * Screen.TwipsPerPixelY
        .VScroll1.Height = .SSPanel6(1).Height - .VScroll1.Top - 4 * Screen.TwipsPerPixelY
        
        
        '''''''''''''''''0.015
        If (F1MDF > 0 Or F1RF > 0) And OV1 = True Then
            If .VScroll1 = 0 Then
                If .VScroll1.Max > 0 Then
                    .VScroll1 = 1
                End If
            Else
                If .VScroll1.Max > 0 Then
                    .VScroll1 = .VScroll1 - 1
                End If
            End If
        End If
        ''''''''''''0.015
        
        
        .Picture16.Top = .VScroll1.Top
        .Picture16.Left = 4 * Screen.TwipsPerPixelY
        .Picture16.Height = .VScroll1.Height
        If .VScroll1.Left - 8 * Screen.TwipsPerPixelX > 0 Then
            .Picture16.Width = .VScroll1.Left - 8 * Screen.TwipsPerPixelX
        Else
            .Picture16.Width = 0
        End If
        .Picture16.ScaleMode = 1
        

        .Command28.Top = 0
        .Command28.Left = 0
        .Command28.Width = .Command1.Width
        .Command28.Height = .Command1.Height
        'Arrange Compatibility Matrix Panel
        'Arrange all buttons

        For x = 0 To 2
            .Command4(x).Top = .Command6(0).Top
            .Command4(x).Width = (.SSPanel6(0).Width - 2 * Screen.TwipsPerPixelX) / 3
            .Command4(x).Height = .Command1.Height
        Next 'X
        '4(0), 8(0), 13(0)
        'XX = .TextWidth("Recombination Info")
        'XX = .Command4(0).Width
        If .TextWidth("Recombination Info") > .Command4(0).Width Then
            
            If .TextWidth("Recomb info") > .Command4(0).Width Then
                If .TextWidth("R info") > .Command4(0).Width Then
                    .Command4(0).Caption = "RI"
                    .Command8(0).Caption = "RI"
                    If RIMode = 1 Then
                        .Command13(2).Caption = "RI"
                    End If
                Else
                    .Command4(0).Caption = "R info"
                    .Command8(0).Caption = "R info"
                    If RIMode = 1 Then
                        .Command13(2).Caption = "R info"
                    End If
                End If
            Else
                .Command4(0).Caption = "Recomb info"
                .Command8(0).Caption = "Recomb info"
                If RIMode = 1 Then
                    .Command13(2).Caption = "Recomb info"
                End If
            End If
        
        
        Else
            .Command4(0).Caption = "Recombination info"
            .Command8(0).Caption = "Recombination info"
            If RIMode = 1 Then
                .Command13(2).Caption = "Recombination info"
            End If
        End If
        
''''''''''''''''''''''0.109
        


        .Command4(0).Left = 1 * Screen.TwipsPerPixelX
        .Command4(1).Left = .Command13(0).Left + .Command13(0).Width
        .Command4(2).Left = .Command13(1).Left + .Command13(1).Width
        .Label4.Top = .Command17.Top + 3 * Screen.TwipsPerPixelY
        .Label4.Left = Form1.Picture26.Left  '4 * Screen.TwipsPerPixelX
        .Label4.Width = .Picture26.Width
        If .TextWidth(.Label4.Caption) > .Label4.Width Then
            .Label4.Height = .Command17.Height * 2
        Else
            .Label4.Height = .Command17.Height
        End If
        If .Command6(3).Left - 8 * Screen.TwipsPerPixelX > 0 Then
            '.Label4.Width = .Command6(3).Left - 8 * Screen.TwipsPerPixelX
        Else
            .Label4.Width = 0
        End If
        .Picture29.Top = .Command1.Height + .Label4.Height + .Command4(0).Top + 8 * Screen.TwipsPerPixelY
        .Picture17.Width = .VScroll1.Width + 2 * Screen.TwipsPerPixelX
        
         
        '''''''''''''''''''0.109
        
        'If RETFlag <= 2 Or X = 123435 Then

            If .SSPanel6(0).Height - .Picture29.Top - 4 * Screen.TwipsPerPixelY - 50 - .HScroll4.Height < .SSPanel6(1).Width - .Picture17.Width * 5 - 8 * Screen.TwipsPerPixelX Then
                .Picture29.Height = .SSPanel6(0).Height - .Picture29.Top - 4 * Screen.TwipsPerPixelY - 50 - .HScroll4.Height
                .Picture29.Width = .Picture29.Height
                .Picture29.Left = 4 * Screen.TwipsPerPixelY '50 '(.SSPanel6(2).Width - .Picture29.Width) / 2
            Else
                If .SSPanel6(1).Width - .Picture17.Width * 5 - 8 * Screen.TwipsPerPixelX > 0 Then
                    .Picture29.Width = .SSPanel6(1).Width - .Picture17.Width * 5 - 8 * Screen.TwipsPerPixelX
                Else
                    .Picture29.Width = 0
                End If
                .Picture29.Left = 4 * Screen.TwipsPerPixelY '50 '4 * Screen.TwipsPerPixelX
                .Picture29.Height = .Picture29.Width
            End If

            If .Picture29.Height - 5 * Screen.TwipsPerPixelX > 0 Then
                .Picture26.Height = .Picture29.Height - 5 * Screen.TwipsPerPixelX
            Else
                .Picture26.Height = 0
            End If
            .Picture26.Width = .Picture29.Width + 15 * Screen.TwipsPerPixelX
            
            If F1MDF = 0 And F1RF = 0 Then
                .Picture26.Top = 0
                .Picture26.Left = 0
                .Picture26.BackColor = .BackColor
            End If
            
        'Else
        ' .Picture29.left = 1 * Screen.TwipsPerPixelX + (.SSPanel6(2).Width - .Picture29.Width) / 2
        ' .Picture29.Height = .SSPanel6(0).Height - .Picture29.Top - 1 * Screen.TwipsPerPixelY - 50 - HScroll4.Height
        'End If
        '.Picture29.Top = .Picture29.Top + (.SSPanel6(1).Height - .Picture29.Top - .Picture29.Height) / 2
        .HScroll4.Top = .Picture29.Top + .Picture29.Height + 50
        .HScroll4.Height = 12 * Screen.TwipsPerPixelY
        .HScroll4.Left = .Picture29.Left
        .HScroll4.Width = .Picture29.Width
        
        .Picture17.Top = .Picture29.Top + 10 * Screen.TwipsPerPixelY
        .Picture17.Height = .Picture29.Height / 2
        
        .Picture17.Left = .Picture29.Left + .Picture29.Width + 50
        If F1MDF = 0 And F1RF = 0 Then
            .Picture17.BackColor = .BackColor
        End If
       
      
        '''''''''''''''''''''''''''''0.140,0.124
        
        .Line1(0).Y1 = .Picture17.Top + 1 * Screen.TwipsPerPixelY
        .Line1(0).Y2 = .Line1(0).Y1
        .Line1(1).Y1 = .Picture17.Top + (.Picture17.Height - 2 * Screen.TwipsPerPixelY) / 4 + 1 * Screen.TwipsPerPixelY
        .Line1(2).Y1 = .Picture17.Top + (.Picture17.Height - 2 * Screen.TwipsPerPixelY) / 2 + 1 * Screen.TwipsPerPixelY
        .Line1(3).Y1 = .Picture17.Top + .Picture17.Height - 2 * Screen.TwipsPerPixelY - (.Picture17.Height - 2 * Screen.TwipsPerPixelY) / 4
        .Line1(4).Y1 = .Picture17.Top + .Picture17.Height - 2 * Screen.TwipsPerPixelY
        
        .Line1(1).Y2 = .Line1(1).Y1
        .Line1(2).Y2 = .Line1(2).Y1
        .Line1(3).Y2 = .Line1(3).Y1
        .Line1(4).Y2 = .Line1(4).Y1
        
        
        
        .Line1(0).X1 = .Picture17.Left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(1).X1 = .Picture17.Left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(2).X1 = .Picture17.Left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(3).X1 = .Picture17.Left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        .Line1(4).X1 = .Picture17.Left + .Picture17.Width + 2 * Screen.TwipsPerPixelX
        
        .Line1(0).X2 = .Picture17.Left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(1).X2 = .Picture17.Left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(2).X2 = .Picture17.Left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(3).X2 = .Picture17.Left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        .Line1(4).X2 = .Picture17.Left + .Picture17.Width + 7 * Screen.TwipsPerPixelX
        
        
            ''''''''''''''''''''''''''0.109
'        For X = 0 To 4
'            .Line1(X).Visible = False
'        Next X
        
        .Label6(0).Left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(1).Left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(2).Left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(3).Left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        .Label6(4).Left = .Line1(0).X2 + 2 * Screen.TwipsPerPixelX
        
        .Label6(0).Top = .Line1(0).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(1).Top = .Line1(1).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(2).Top = .Line1(2).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(3).Top = .Line1(3).Y1 - 5 * Screen.TwipsPerPixelY
        .Label6(4).Top = .Line1(4).Y1 - 5 * Screen.TwipsPerPixelY
        
        
        .Picture18.Top = .Picture29.Top + 10 * Screen.TwipsPerPixelY
        .Picture18.Height = .Picture29.Height / 2
        .Picture18.Width = .VScroll1.Width + 2 * Screen.TwipsPerPixelX
        
        
        If F1MDF = 0 And F1RF = 0 Then
            .Picture18.Left = .SSPanel6(0).Left
            .Picture18.BackColor = .BackColor
        
'        Else
'            .Picture18.Left = .SSPanel6(0).Left
'            .Picture18.BackColor = .BackColor
        End If
        
        
        .Check1.Left = .Picture17.Left
        .Check1.Top = .Picture17.Top + .Picture17.Height + 50
        
        
        .VScroll5.Width = .VScroll1.Width
        .VScroll5.Left = .Picture17.Left
        
        .VScroll5.Top = .Check1.Top + .Check1.Height + 50
        If (.Picture29.Top + .Picture29.Height - .VScroll5.Top) >= 0 Then
            .VScroll5.Height = (.Picture29.Top + .Picture29.Height - .VScroll5.Top)
        End If
        '3797
        .SSPanel15.ZOrder
        
        
        .SSPanel15.Left = .VScroll5.Left + .VScroll5.Width + 50
        
        If .VScroll5.Top > .Check1.Top + .Check1.Height + 50 Then
            .SSPanel15.Top = .VScroll5.Top
        Else
            .SSPanel15.Top = .Check1.Top + .Check1.Height + 50
        End If
        
        If (.Picture29.Top + .Picture29.Height - .SSPanel15.Top) >= 0 Then
            .SSPanel15.Height = (.Picture29.Top + .Picture29.Height - .SSPanel15.Top)
        End If
        If .SSPanel6(0).Width - 50 - .SSPanel15.Left > 0 Then
            .SSPanel15.Width = .SSPanel6(0).Width - 50 - .SSPanel15.Left
        Else
            .SSPanel15.Width = 0
        End If
        If .SSPanel15.Width > 800 Then
            '.SSPanel15.left = .SSPanel15.left + (.SSPanel15.Width - 800) / 2
            .SSPanel15.Width = 800
        End If
        
        ''''''''''''''''''''''''''''0.109,0.093
        
        Dim LOSpace As Single, Extra As Single
        LOSpace = Form1.SSPanel15.Height - ((Form1.Label7(0).Height - 50) * 3)
        LOSpace = LOSpace / 4
        'XX = Form1.Label7(0).Height
        If LOSpace < 0 Then
            Extra = (LOSpace * 4) / 2
            LOSpace = 0
            
        Else
            Extra = 0
        End If
            
        
        For x = 0 To 2
            .Label7(x).Left = 50
            If .SSPanel15.Width - 100 > 0 Then
                .Label7(x).Width = .SSPanel15.Width - 100
            Else
                .Label7(x).Width = 0
            End If
            '    .Label7(X).Top = 100 + ((.SSPanel15.Height - 100) / 3) * (X)
            .Label7(x).Top = ((.Label7(0).Height - 50) * (x)) + (Extra * x) + LOSpace * (x + 1)
        Next x
        
        .Command39(1).Top = .HScroll4.Top
        .Command39(1).Left = .SSPanel15.Left
        .Command39(1).Width = .SSPanel15.Width / 2
        .Command39(1).Height = .HScroll4.Height
        .Command39(1).MouseIcon = .Command1.MouseIcon
        .Command39(1).MousePointer = 99
        .Command39(0).Top = .Command39(1).Top
        .Command39(0).Left = .Command39(1).Left + .Command39(1).Width
        .Command39(0).Width = .Command39(1).Width
        .Command39(0).Height = .Command39(1).Height
        .Command39(0).MouseIcon = .Command1.MouseIcon
        .Command39(0).MousePointer = 99
        If F1MDF = 0 And F1RF = 0 Then
            .HScroll4.Enabled = False
            .VScroll5.Enabled = False
        ElseIf CurMatrixFlag < 255 Then
            'If CurMatrixFlag < 255 Then
                '.HScroll4.Max = (MatZoom(CurMatrixFlag) * .Picture26.ScaleHeight) * 2 - .Picture26.ScaleHeight
            'End If
            OHE = .HScroll4.Enabled
            OVE = .VScroll5.Enabled
            ODDKey = DontDoKey
            DontDoKey = 0
            If OV2 = True Then
                DoMatrixWhileResizing = 1
                DoVS5 = 0
            Else
                DoMatrixWhileResizing = 0
            End If
            If SS62 = True Then
                DoMatrixWhileResizing = 1
                DoVS5 = 0
            End If
            DontRefreshFlag = 1
            If .HScroll4 = 0 Then
                If .HScroll4.Max = 0 Then
                    .HScroll4.Max = 1
                End If
                H1C = 1
                .HScroll4 = 1
                H1C = 0
                .HScroll4 = 0
                .HScroll4.Max = 0
                
            Else
                H1C = 1
                .HScroll4 = .HScroll4 - 1
                H1C = 0
                .HScroll4 = .HScroll4 + 1
            End If
            'Form1.Picture26.Refresh
            DoMatrixWhileResizing = 0
            DontRefreshFlag = 0
            DontDoKey = ODDKey
            .HScroll4.Enabled = OHE
            .VScroll5.Enabled = OVE
        End If
        
        
        '''''''''''''''''''''''''''''''''''''''''''''''''''0.109
        If F1MDF > 0 Or F1RF > 0 Then
           ' XX = .SSPanel6(0).Visible
           ' yy = .SSPanel6(1).Visible
           ' ZZ = .SSPanel6(2).Visible
        
            .SSPanel6(0).Visible = OV0
            .SSPanel6(1).Visible = OV1
            .SSPanel6(2).Visible = OV2
        End If
        
        'Arrange Sequence Window (.sspanel3)
        .SSPanel3.Visible = False
        .SSPanel3.Left = .SSPanel2.Left
        .SSPanel3.Width = .SSPanel4.Width
        .SSPanel3.Top = .SSPanel4.Top + .SSPanel4.Height + 4 * Screen.TwipsPerPixelY
        .SSPanel3.Height = .SSPanel6(0).Height - .SSPanel4.Height - 4 * Screen.TwipsPerPixelY
        .Command6(0).Top = .Picture4.Top
        .Command6(0).Height = .Picture4.Height
        .Command6(0).Width = .Picture4.Height
        .Command6(0).Left = .SSPanel3.Width - .Command6(0).Width - 4 * Screen.TwipsPerPixelX
        .Command6(0).MouseIcon = .Command18.MouseIcon
        .Command6(0).MousePointer = 99
        .Picture14.Top = .Picture4.Top
        .Picture14.Height = .Picture4.Height
        .Picture14.Left = .Picture4.Left
        .Picture14.Width = .Picture4.Width
        .Label21.Top = 1 * Screen.TwipsPerPixelY
        .Label21.Height = .Command6(0).Height + 3 * Screen.TwipsPerPixelY
        .Label21.Left = .Picture4.Left + .Picture4.Width + 4 * Screen.TwipsPerPixelX
        .Label21.Width = .Command6(0).Left - .Label21.Left - 4 * Screen.TwipsPerPixelX
        
        .Picture1.Font.Name = "Courier"
        P1FontSize = .Picture1.FontSize
        'XX = Form1.Picture1.FontSize
        .Picture14.ScaleMode = 1
        .Picture13.Top = 0
        '.Picture13.left = 0
        '.Picture1.Font.Name = "Courier New"
        
        .Picture13.Width = .Picture14.Width
        .Picture13.Height = .Picture14.ScaleHeight
        .Picture13.Left = -35
        
        .HScroll1.Left = .Picture4.Left
        .HScroll1.Width = .Picture4.Width
        .HScroll1.Height = 12 * Screen.TwipsPerPixelY
        .HScroll1.Top = .SSPanel3.Height - .HScroll1.Height - 4 * Screen.TwipsPerPixelY
        
        If F1MDF = 0 And F1RF = 0 Then
            .HScroll1.Max = 99
        End If
        .VScroll3.Top = 2 * .Command6(0).Top + .Command6(0).Height
        .VScroll3.Width = 12 * Screen.TwipsPerPixelX
        .VScroll3.Left = .SSPanel3.Width - .VScroll3.Width - 4 * Screen.TwipsPerPixelX
        .VScroll3.Height = .HScroll1.Top - .VScroll3.Top - 4 * Screen.TwipsPerPixelX
        If F1MDF = 0 And F1RF = 0 Then
            .VScroll3.SmallChange = 2
            .VScroll3.LargeChange = 10
        Else
            
        End If
        .Picture8.Left = .Label21.Left
        .Picture8.Top = .VScroll3.Top
        .Picture8.Height = .VScroll3.Height
        .Picture8.Width = .VScroll3.Left - .Picture8.Left - 4 * Screen.TwipsPerPixelX
        .Picture8.ScaleMode = 1
        .Picture9.Top = .VScroll3.Top
        .Picture9.Height = .VScroll3.Height
        .Picture9.Left = .Picture4.Left
        .Picture9.Width = .Picture4.Width
        .Picture9.ScaleMode = 1
        If AncSeqFlag = 1 Then
            .VScroll3.Height = (.HScroll1.Top - .VScroll3.Top - 4 * Screen.TwipsPerPixelX) / 2
            .Picture8.Height = .VScroll3.Height
            .Picture9.Height = .VScroll3.Height
            
            'Set up DIBsection for Picture1
            
            
            .Picture22.Top = .VScroll3.Top + .VScroll3.Height + 50
            .Picture22.Left = .Picture9.Left
            .Picture22.Height = .Picture9.Height - 50
            .Picture22.Width = .Picture8.Left + .Picture8.Width - .Picture22.Left
            'Picture22.Visible = True
        End If
        '''''''''''''''''''''''''''''0.093,0.110
        
'        If .Picture9.Width > .Picture1.Width Or .Picture9.Height > .Picture1.Height Then
'            DontRefreshSeqsFlag = 0
'        Else
'            DontRefreshSeqsFlag = 1
'        End If
        DontRefreshSeqsFlag = 0
        .Picture1.Top = 0
        .Picture1.Left = 0
        .Picture1.ScaleMode = 1
        
        
        Dim oLeftPos
        oLeftPos = WinLeft
        PrintSeqLen = MakePrintSeqLen
        .Picture3.Left = 1 * Screen.TwipsPerPixelX
        .Picture3.Top = 0
        .Picture3.Width = .Picture8.Width
        .Picture8.ScaleMode = 3
        'XX = .Picture8.ScaleHeight
        .Picture3.ScaleMode = 3
        .Picture3.Height = .Picture8.ScaleHeight
        .Command33(1).Left = .Picture8.Left
        .Command33(1).Top = .HScroll1.Top
        .Command33(1).Height = .HScroll1.Height
        .Command33(1).Width = .Picture8.Width / 2
        .Command33(1).MouseIcon = .Command1.MouseIcon
        .Command33(1).MousePointer = 99
        .Command33(0).Left = .Picture8.Left + .Picture8.Width / 2
        .Command33(0).Top = .HScroll1.Top
        .Command33(0).Height = .HScroll1.Height
        .Command33(0).Width = .Picture8.Width / 2
        .Command33(0).MouseIcon = .Command1.MouseIcon
        .Command33(0).MousePointer = 99
        
        '.SSPanel3.Visible = True

        'Arrange XOver Plot panel (.sspanel8)
        .SSPanel8.Visible = False
        If .SSPanel7.Top - (.SSPanel3.Top + .SSPanel3.Height + 4 * Screen.TwipsPerPixelY) - 4 * Screen.TwipsPerPixelY > 0 Then
            .SSPanel8.Height = .SSPanel7.Top - (.SSPanel3.Top + .SSPanel3.Height + 4 * Screen.TwipsPerPixelY) - 4 * Screen.TwipsPerPixelY
        Else
            .SSPanel8.Height = 0
        End If
        .SSPanel8.Top = .SSPanel3.Top + .SSPanel3.Height + 4 * Screen.TwipsPerPixelY
        
        .SSPanel8.Left = 0
        .SSPanel8.Width = .SSPanel3.Width
        
        .Picture10.Left = .Picture4.Left
        .Picture10.Top = .Picture4.Top
        If .SSPanel8.Height - .Picture10.Top - 4 * Screen.TwipsPerPixelY > 0 Then
            .Picture10.Height = .SSPanel8.Height - .Picture10.Top - 4 * Screen.TwipsPerPixelY
        Else
            .SSPanel8.Height = 0
        End If
        .Picture10.Width = .Picture4.Width
        .Picture10.ScaleMode = 1
        
        
        .Picture7.AutoRedraw = True
        .Picture7.DrawWidth = 1
         
        
        .Picture7.Width = .Picture10.ScaleWidth - 20 * Screen.TwipsPerPixelX
       'XX = .Image1(1).Width
        
       '''''''''''''''''''''''''''''''''''''0.031
        
            If ORFFlag = 0 Then
                .Picture7.Height = .Picture10.ScaleHeight
                .Picture7.Top = -1
            Else
                .Picture7.Height = .Picture10.ScaleHeight - .Picture19.Height + 5 * Screen.TwipsPerPixelY
                .Picture7.Top = .Picture19.Height - 5
            End If
        
            
     
        .Picture7.Left = 20 * Screen.TwipsPerPixelX
        .Picture7.MouseIcon = .Command1.MouseIcon
        
        
        
            
        '''''''''''''''''''''''''''''''''''''''0.031
        

           ''''''''''''''''''''''''''''''''''''0.140
            
        .Frame17.Top = 0
        .Frame17.Left = 0
        .Frame17.Width = .Picture7.ScaleWidth
        .Frame17.Height = .Picture7.ScaleHeight * VAddjust
       
        'Arrange Settings for plot Panel
        '.SSPanel10.Visible = False
        '.SSPanel9.Visible = False
        .SSPanel10.Left = .Picture8.Left
        .SSPanel10.Left = .Picture8.Left
        .SSPanel10.Width = .SSPanel8.Width - .SSPanel10.Left - 4 * Screen.TwipsPerPixelX
        .SSPanel10.Top = .Picture10.Top
        .SSPanel10.Height = .Picture10.Height
        
        
        .Picture23(2).Left = 0
        .Picture23(2).Top = 0
        .Picture23(2).Width = .SSPanel10.Width
        .Picture23(2).Height = .SSPanel10.Height
        
        
        
        'Arrange Components of panel
        .SSPanel9.Left = 4 * Screen.TwipsPerPixelX
        .SSPanel9.Width = .SSPanel10.Width - 8 * Screen.TwipsPerPixelX
        .SSPanel9.Top = 4 * Screen.TwipsPerPixelX
        .SSPanel9.Height = .SSPanel11.Height
        .Label1.Top = .Label15.Top
        .Label1.Left = 1 * Screen.TwipsPerPixelX
        .Label1.Width = .SSPanel9.Width - 2 * Screen.TwipsPerPixelX
        .Label1.Height = .Label15.Height
        
         
         
        '.SSPanel16.Caption
        If F1MDF = 0 And F1RF = 0 Then
            .Frame6.Left = .SSPanel9.Left
            .Frame6.Width = .SSPanel9.Width
            .Frame6.Top = .SSPanel9.Top + .SSPanel9.Height + 4 * Screen.TwipsPerPixelY
            .Frame6.Height = 48 * Screen.TwipsPerPixelY
            .Frame6.Visible = False
            
            
            
            
            .Picture23(0).Top = .Frame6.Top + 16 * Screen.TwipsPerPixelY
            .Picture23(0).Left = .Frame6.Left + 4 * Screen.TwipsPerPixelX
            .Picture23(0).Height = .Combo1.Height + 3 * Screen.TwipsPerPixelY
            .Picture23(0).Width = .Frame6.Width - 10 * Screen.TwipsPerPixelY
            .Picture23(0).BackColor = .BackColor
            
            
            
            .Picture23(2).AutoRedraw = True
            .Picture23(2).BackColor = .BackColor
            '.Picture23(2).Line (.Frame6.Left + Screen.TwipsPerPixelX, .Frame6.Top + 7 * Screen.TwipsPerPixelY)-(.Frame6.Left + .Frame6.Width + Screen.TwipsPerPixelX, .Frame6.Top + .Frame6.Height + Screen.TwipsPerPixelY), vb3DHighlight, B
            '.Picture23(2).Line (.Frame6.Left, .Frame6.Top + 6 * Screen.TwipsPerPixelY)-(.Frame6.Left + .Frame6.Width, .Frame6.Top + .Frame6.Height), vb3DShadow, B
            '.Picture23(2).Line (.Frame6.Left + 7 * Screen.TwipsPerPixelX, .Frame6.Top)-(.Frame6.Left + 11 * Screen.TwipsPerPixelX + .Picture23(2).TextWidth("Highest P"), .Frame6.Top + .Picture23(2).TextHeight("Highest P")), Form1.BackColor, BF
           '
           ' .Picture23(2).ForeColor = 0
           ' .Picture23(2).CurrentX = .Frame6.Left + 10 * Screen.TwipsPerPixelX
           ' .Picture23(2).CurrentY = .Frame6.Top
            '.Picture23(2).Print "Highest P"
            
            
            
            
            
            .Text1.Top = 0
            .Text1.Left = 0
            .Text1.Height = .Combo1.Height
            .Text1.Width = .Frame6.Width - 8 * Screen.TwipsPerPixelY
            .Frame7.Left = .SSPanel9.Left
            .Frame7.Width = .SSPanel9.Width
            
            .Command25.Left = 100
            .Command25.Width = .Text1.Width
            .Command25.Top = .SSPanel9.Top + .SSPanel9.Height + 5 * Screen.TwipsPerPixelY
            .Command25.Height = .Command1.Height '- 2 * Screen.TwipsPerPixelY
            .Command25.MouseIcon = .Command18.MouseIcon
            .Command25.MousePointer = 99
            .Command25.Enabled = False
            
            .Frame7.Top = .Command25.Top + .Command25.Height + 50 '.Frame6.Height + 15 * Screen.TwipsPerPixelY
            .Frame7.Height = (.Command1.Height + 10 * Screen.TwipsPerPixelY) * 3 '103 * Screen.TwipsPerPixelY
            .Frame7.Visible = False
            
                        
            .Picture23(2).Line (.Frame7.Left + Screen.TwipsPerPixelX, .Frame7.Top + 7 * Screen.TwipsPerPixelY)-(.Frame7.Left + .Frame7.Width + Screen.TwipsPerPixelX, .Frame7.Top + .Frame7.Height + Screen.TwipsPerPixelY), vb3DHighlight, B
            .Picture23(2).Line (.Frame7.Left, .Frame7.Top + 6 * Screen.TwipsPerPixelY)-(.Frame7.Left + .Frame7.Width, .Frame7.Top + .Frame7.Height), vb3DShadow, B
            .Picture23(2).Line (.Frame7.Left + 7 * Screen.TwipsPerPixelX, .Frame7.Top)-(.Frame7.Left + 11 * Screen.TwipsPerPixelX + .Picture23(2).TextWidth("Check using"), .Frame7.Top + .Picture23(2).TextHeight("Check using")), .BackColor, BF

            
            
            .Picture23(2).ForeColor = 0
            .Picture23(2).CurrentX = .Frame7.Left + 10 * Screen.TwipsPerPixelX
            .Picture23(2).CurrentY = .Frame7.Top
            .Picture23(2).Print "Check using"
            
            .Combo1.Clear
            .Combo1.BackColor = .BackColor
            .Combo1.Enabled = False
            
            
            
            
            .Picture23(1).Top = .Command25.Top + .Command25.Height + 300 '.Frame7.Top + 18 * Screen.TwipsPerPixelY
            .Picture23(1).Left = .Frame7.Left + 4 * Screen.TwipsPerPixelX
            .Picture23(1).Height = .Frame7.Height - 20 * Screen.TwipsPerPixelY
            .Picture23(1).Width = .Frame7.Width - 6 * Screen.TwipsPerPixelY
            .Picture23(1).BackColor = .BackColor
            
            .Combo1.Left = 0
            .Combo1.Width = .Text1.Width
            .Combo1.Top = 0
            '.Combo1.Height = .Text1.Height
            
            
            
            .Command29(0).Left = 0
            .Command29(0).Width = .Text1.Width
            .Command29(0).Top = .Combo1.Height + 4 * Screen.TwipsPerPixelY
            .Command29(0).Height = .Command1.Height '- 2 * Screen.TwipsPerPixelY
            .Command29(0).MouseIcon = .Command18.MouseIcon
            .Command29(0).MousePointer = 99
            .Command29(0).Enabled = False
            
            .Command29(1).Left = 0
            .Command29(1).Width = .Text1.Width
            .Command29(1).Top = .Combo1.Height + .Command29(0).Height + 8 * Screen.TwipsPerPixelY
            .Command29(1).Height = .Command1.Height '- 2 * Screen.TwipsPerPixelY
            .Command29(1).MouseIcon = .Command18.MouseIcon
            .Command29(1).MousePointer = 99
            .Command29(1).Enabled = False
            
'            .Slider1.Top = .Frame7.Top + .Frame7.Height + 4 * Screen.TwipsPerPixelY
'            .Slider1.Height = .Command29(0).Height
'            .Slider1.Width = .Command29(0).Width
'            .Slider1.Left = 0
        End If
        
       
        
        .Frame6.Visible = False
        .Picture23(0).Visible = False
        
        .Picture20.ScaleMode = 3
        
        '.SSPanel8.Visible = True
        .Picture10.ScaleMode = 1
        .Picture19.ScaleMode = 3
        .Picture19.Top = 0
        .Picture19.ScaleHeight = 23 * Screen.TwipsPerPixelY * VAddjust
        .Picture19.Left = .Picture7.Left + 30 * Screen.TwipsPerPixelX
        
        If (.Picture7.Width - 40 * Screen.TwipsPerPixelX) > 0 Then
            .Picture19.Width = (.Picture7.Width - 40 * Screen.TwipsPerPixelX) 'Form1.Picture4.ScaleHeight + 3
        End If
        
        .Picture20.Top = 0
        .Picture20.Height = .Picture19.Height
        .Picture20.AutoRedraw = True
        .Picture20.ForeColor = 0
        .Picture20.DrawMode = 13
        .Picture20.DrawWidth = 1
        .Picture20.Left = .Picture19.Left
        .Picture20.Width = .Picture19.Width
        
        
        
        If (F1MDF > 0 Or F1RF > 0) And ((RelX > 0 Or RelY > 0) Or ManFlag > -1) Then
            If CurrentCheck = 40 Then
                If ManFlag = -1 Then
                    If ORFFlag = 1 Then
                        Call DrawORFsP20
                    End If
                    Call DrawVisRDPlot(1, XoverList(RelX, RelY).MajorP, XoverList(RelX, RelY).MinorP, RelX)
                    Form1.Picture7.Refresh
                End If
            Else
                Call RedrawPlotAA(1)
            
            End If
            'Call RedrawPlot(1)
        End If
        
        
        'Arrange recombination .picture panel (.sspanel5)
        .SSPanel5.Visible = False
        .SSPanel5.Top = .SSPanel8.Top
        .SSPanel5.Left = .SSPanel6(0).Left
        .SSPanel5.Height = .SSPanel8.Height
        .SSPanel5.Width = .SSPanel6(0).Width
        '.picture5.Visible = False
        '.command9.ZOrder
        If F1MDF = 0 And F1RF = 0 Then
            If SEventNumber = 0 Then
                .Label58.Caption = ""
            End If
        End If
        .Label58.Height = .Command1.Height
        .Label58.Width = 90 * Screen.TwipsPerPixelX
        .Label58.Top = .SSPanel5.Height - .Label58.Height - 5 * Screen.TwipsPerPixelY
        .Label58.Left = 4 * Screen.TwipsPerPixelX
        .Command6(2).Width = .Command6(0).Width
        .Command6(2).Left = .Label58.Left + .Label58.Width + 4 * Screen.TwipsPerPixelX
        .Command6(2).Height = .Command6(0).Height
        .Command6(2).Top = .Label58.Top
        .Command6(2).MouseIcon = .Command18.MouseIcon
        .Command6(2).MousePointer = 99
        If F1MDF = 0 And F1RF = 0 Then
            .Command6(2).Enabled = False
            .Command5.Enabled = False
            .Command9.Enabled = False
            .Command10.Enabled = False
        End If
        .Command5.Width = .Command6(2).Width '* 1.75
        .Command5.Left = .Command6(2).Left + .Command6(2).Width
        .Command5.Height = .Command6(2).Height
        .Command5.Top = .Command6(2).Top
        .Command5.BackColor = .BackColor
        .Command5.MouseIcon = .Command18.MouseIcon
        .Command9.MouseIcon = .Command18.MouseIcon
        
        .Command9.Width = .Command6(2).Width '* 1.75
        .Command9.Left = .Command5.Left + .Command5.Width
        .Command9.Height = .Command6(2).Height
        .Command9.Top = .Command6(2).Top
        .Command9.BackColor = .BackColor
        
        .Command10.MouseIcon = .Command18.MouseIcon
        .Command10.Width = .Command6(2).Width * 2.5 '* 1.75
        .Command10.Left = .Command9.Left + .Command9.Width
        .Command10.Height = .Command6(2).Height
        .Command10.Top = .Command6(2).Top
        .Command10.BackColor = .BackColor
        
        .VScroll2.Width = 12 * Screen.TwipsPerPixelX
        .VScroll2.Left = .SSPanel5.Width - .VScroll2.Width - 4 * Screen.TwipsPerPixelX
        If .Label58.Top - 5 * Screen.TwipsPerPixelY > 0 Then
            .VScroll2.Height = .Label58.Top - 5 * Screen.TwipsPerPixelY
        Else
            .VScroll2.Height = 0
        End If
        
        
        
        .VScroll2.Top = .Picture4.Top
        .Picture5.Top = .VScroll2.Top
        .Picture5.Left = .Picture4.Left
        .Picture5.Height = .VScroll2.Height
        If .VScroll2.Left - 8 * Screen.TwipsPerPixelY > 0 Then
            .Picture5.Width = .VScroll2.Left - 8 * Screen.TwipsPerPixelY
        Else
            .Picture5.Width = 0
        End If
        .Picture10.ScaleMode = 1
        .HScroll2.Left = .Command10.Left + .Command10.Width + 4 * Screen.TwipsPerPixelX
        If .VScroll2.Left - .HScroll2.Left - 4 * Screen.TwipsPerPixelX > 1 Then
            
            .HScroll2.Width = .VScroll2.Left - .HScroll2.Left - 4 * Screen.TwipsPerPixelX
        Else
            .HScroll2.Width = 1
        End If
        .HScroll2.Top = .Command6(2).Top
        .HScroll2.Height = 12 * Screen.TwipsPerPixelY
        .Picture6.Top = 0 * VAddjust
        .Picture6.Left = 0 * HAddjust
        '.picture6.ScaleHeight = 2500 * VAddjust
        'If .Picture5.ScaleWidth < 4200 Then
        If .Picture6.Width <> (.Picture5.ScaleWidth + 100) Then
            DontRefreshP6Flag = 1
        Else
            DontRefreshP6Flag = 0
        End If
        .Picture6.Width = .Picture5.ScaleWidth + 100
        .Picture6.Height = .Picture5.ScaleHeight + 100
        'Else
        '    .Picture6.ScaleWidth = 4200
        'End If
        '.Picture6.BorderStyle = 1
        
        .Picture6.FontSize = 6.75 * Screen.TwipsPerPixelY / 14
        If .Picture5.Width <= .HScroll2.Max Then
            .HScroll2.LargeChange = .Picture5.Width
        Else
            .HScroll2.LargeChange = .HScroll2.Max
        End If
        .Label58.Height = .Label58.Height - 4 * Screen.TwipsPerPixelX
        .Label58.Top = .Label58.Top + 2 * Screen.TwipsPerPixelX
        
        '.SSPanel5.Visible = True
        
        
        
        '''''''''''''''''''''''''''''''''''0.124
        
        
        
        If RedoPicsFlag = 1 Then

            Call DoInterface
       
           
            ''''''''''''''''''''''''''''''''''''''0.187,0.172
           ' XX = Form1.Picture7.Top
'XX = Form1.Picture7.Enabled
            '.Timer3.Enabled = False
            RedoPicsFlag = 0
            If F1MDF = 0 And F1RF = 0 Then
                .Picture1.Picture = LoadPicture()
            End If
            .Picture4.Enabled = True
            .Picture11.Enabled = True
            
            '.SSPanel11.Visible = True
            'Call SeqCols
            
            '''''''''''''''''''''''''''''''0.172, 0.187
            SS = Abs(GetTickCount)
            'For X = 1 To 1000
            If Len(StrainSeq(0)) > 500 Then
                Call CalcIdentity3(0)
            Else
                Call CalcIdentity3(0)
            End If
            'Next X
            EE = Abs(GetTickCount)
            'TT = EE - SS '5438
            x = x
            '''''''''''''''''''''''''''''''0.187
            .Command6(1).Enabled = True
            If IDDsiplayMode = 1 Then
                .Picture4.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
                .Picture11.ToolTipText = "Average pairwise identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 1 Then
                .Picture4.ToolTipText = "Average Tajima D (window size =" + CStr(FullWindowSize) + ")"
                .Picture11.ToolTipText = "Average Tajima D identity (window size =" + CStr(FullWindowSize) + ")"
            ElseIf IDDisplayMode = 2 Then
                .Picture4.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
                .Picture11.ToolTipText = "Average GC content (window size =" + CStr(FullWindowSize) + ")"
            End If
            'If F1MDF = 0 Or X = X Then
'                H1C = 1
'                If (oLeftPos / HScroll1Mod) >= 1 Then
'                    DontDoH1Inc = 1
'                    .HScroll1.Value = oLeftPos / HScroll1Mod
'                    DontDoH1Inc = 0
'                Else
'                    .HScroll1.Value = 1
'                End If
                H1C = 1
                If DontRefreshSeqsFlag = 0 Or F1RF = 1 Then
                    If .HScroll1.Value > .HScroll1.Min Then
                        DontDoH1Inc = 1
                        H1C = 1
                        .HScroll1.Value = .HScroll1.Value - 1
                       
                        H1C = 0
                          DontDoH1Inc = 1
                        .HScroll1.Value = .HScroll1.Value + 1
                         DontDoH1Inc = 0
                        x = x
                    Else
                       H1C = 1
                        DontDoH1Inc = 1
                    ''''''''''''''''''''''''''''''0.171
                        If .HScroll1.Max < 1 Then .HScroll1.Max = 1
                        If .HScroll1.Value < .HScroll1.Max Then
                            .HScroll1.Value = .HScroll1.Value + 1
                        
                ''''''''''''''''''''''''''''''''0.203, 0.187
                             DontDoH1Inc = 1
                            H1C = 0
                            .HScroll1.Value = .HScroll1.Value - 1
                            DontDoH1Inc = 0
                        ElseIf .HScroll1.Value > 1 Then
                            .HScroll1.Value = .HScroll1.Value - 1
                        
                ''''''''''''''''''''''''''''''''0.203, 0.187
                             DontDoH1Inc = 1
                            H1C = 0
                            .HScroll1.Value = .HScroll1.Value + 1
                            DontDoH1Inc = 0
                            
                        End If
                '''''''''''''''''''''''''''''''''0.530,0.515
                         
                    End If
                
                Else
                    x = x
                End If
            'End If
           
            ''''''''''''''''''''''''''''''''''''''0.41,0.121
        
            If RunFlag = 1 And CurrentlyRunningFlag = 0 Then
                If x = x Then
                    
                    If DontRefreshP6Flag = 1 Then
                        If NextNo < 30 And SEventNumber < 100 Then
                            RedoIntegrateXOversFlag = 4
                        Else
                            RedoIntegrateXOversFlag = 4
                        End If
                        .Timer6.Enabled = True
                    ElseIf RedoIntegrateXOversFlag > 0 Then
                        RedoIntegrateXOversFlag = 4
                        'RedoIntegrateXOversFlag = 0
                    End If
                    Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, OriginalName(), -Form1.VScroll2.Value, Form1.Picture6) 'IntegrateXOvers(0)
                    
                    If F1MDF = 0 And F1RF = 0 Then
                        .Picture10.ScaleMode = 3
                        .Picture7.ScaleMode = 3
                        .Picture10.BackColor = BackColours
                        .Picture7.BackColor = BackColours
                        For x = 0 To 3
                            TreeImage(x) = 0
                            'Exit Sub
                        Next 'X
        
                        For x = 0 To 3
                            For A = 0 To 3
                                DoneTree(x, A) = 0
                            Next A
                        Next x
                    
                    End If
                    
    
                    
    
                    Dim Y As Integer

                End If
            End If

            '.Visible = True
            '.Timer3.Enabled = True
        End If
        
    End With
    
    
    
    Form1.AutoRedraw = True
    Form1.ScaleMode = 1
    F1Hotspot(0) = Form1.SSPanel3.Left + Form1.SSPanel3.Width - 50
    F1Hotspot(1) = Form1.SSPanel3.Left + Form1.SSPanel3.Width + 75
    F1Hotspot(2) = Form1.SSPanel3.Top + Form1.SSPanel3.Height - 50
    F1Hotspot(3) = Form1.SSPanel3.Top + Form1.SSPanel3.Height + 75
   ' Form1.Line (Form1.SSPanel3.left + Form1.SSPanel3.Width - 100, Form1.SSPanel3.Top + Form1.SSPanel3.Height + 20)-(Form1.SSPanel3.left + Form1.SSPanel3.Width + 150, Form1.SSPanel3.Top + Form1.SSPanel3.Height + 20), 0
   ' Form1.Line (Form1.SSPanel3.left + Form1.SSPanel3.Width + 20, Form1.SSPanel3.Top + Form1.SSPanel3.Height - 100)-(Form1.SSPanel3.left + Form1.SSPanel3.Width + 20, Form1.SSPanel3.Top + Form1.SSPanel3.Height + 150), 0
'XX = Form1.VScroll5.Top
    
        
    If NextNo > 0 Then
        XPicAddjust = (Form1.Picture5.ScaleWidth - 10) / Len(StrainSeq(0))
        If RelX > 0 Or RelY > 0 Then
            PermXVal = 6 + CLng(XoverList(RelX, RelY).Beginning * XPicAddjust)
        End If
        If RIMode = 1 Then
            If SEventNumber > 0 Then
                Call MakeSummary
                
            End If
        Else
            If SEventNumber > 1 And (RelX <> 0 Or RelY <> 0) And ManFlag = -1 Then
                RecSeq = RelX
                PAVal = RelY
                Call MakeRecombinationInfo(RecSeq, PAVal)
            ElseIf ManFlag > -1 Then
                Call DoLegend
            End If
        End If
    End If
    If ManFlag > -1 And x = 12345 Then
        'Form1.Picture21.Visible = True
        '@
        Form1.Picture21.Picture = LoadPicture()
        Form1.Picture21.Width = Form1.Picture7.Width + 100
        Form1.Picture21.Height = Form1.Picture7.Height + 100
        '@'@'@'@'@
        Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
        'Form1.Picture21.ZOrder
        x = x
   End If
'    With Form1
'        .SSPanel3.Visible = True
'        .SSPanel8.Visible = True
'        .SSPanel5.Visible = True
'        .SSPanel7.Visible = True
'        .SSPanel4.Visible = True
'    End With
    
'XX = Form1.ScaleHeight
Form1.SSPanel1.Caption = ""
'Form1.Refresh
'Form1.WindowState = Form1.WindowState

With Form1
    '@
    .SSPanel6(0).Visible = SS60
    .SSPanel6(1).Visible = SS61
    .SSPanel6(2).Visible = SS62
    .SSPanel1.Visible = True
    .SSPanel3.Visible = True
    
    .SSPanel8.Visible = True
    
    .SSPanel5.Visible = True
    .SSPanel7.Visible = True
    .SSPanel4.Visible = True
    .ProgressBar1.Value = 0
    .SSPanel1.Caption = ""
    Call UpdateF2Prog
    '.Refresh
    If F1MDF = 0 And F1RF = 0 Then
        .Refresh
    
    End If
End With

F1BusyResizing = 0
 ''''''''''''''''''''''''''''''0.172


End Sub

Public Sub DrawManBSPlot()

    Dim PosCount As Long, Pict As Long, x As Long
    Dim PntAPI As POINTAPI
    Dim YScaleFactor As Double

    Form1.Picture7.ScaleMode = 3
    Form1.Picture10.BackColor = BackColours
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    SeqLen = Len(StrainSeq(0))

    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 100, 0, 0, "Bootstrap support (%)")
    
    'Do cutoff line
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.DrawStyle = 2
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 25, 20 + (1 - BSCutOff) * (PicHeight - 35), PntAPI
    LineTo Pict, Form1.Picture7.ScaleWidth - 5, 20 + (1 - BSCutOff) * (PicHeight - 35)
    Form1.Picture7.DrawStyle = 0
    
    
'    Form1.Picture7.DrawWidth = 3
'
'    For X = 1 To NumberOfSeqs
'        PosCount = 1
'        Form1.Picture7.ForeColor = FFillCol(RevSeq(X))
'        Pict = Form1.Picture7.hdc
'        Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)
'        'Exit Sub
'
'        Do While PltPos(PosCount + 2) <= Len(StrainSeq(0)) And PltPos(PosCount + 2) > 0
'            PosCount = PosCount + 1
'            Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35))
'            'Exit Sub
'        Loop
'
'    Next 'X

    Form1.Picture7.DrawWidth = 1

'    For X = 1 To NumberOfSeqs
        x = 1
        PosCount = 1
'        Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
'        Pict = Form1.Picture7.hdc
'        Dummy = MoveToEx(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35), PntAPI)

        Do While PltPos(PosCount + 2) <= Len(StrainSeq(0)) And PltPos(PosCount + 2) > 0
            PosCount = PosCount + 1
'            Dummy = LineTo(Pict, 30 + Decompress(PltPos(PosCount)) * XFactor, 20 + (1 - PltVal(X, PosCount) / BSBootReps) * (PicHeight - 35))

        Loop

'    Next 'X
    'Get everything into the standard format for printing and saving
        PosCount = PosCount - 1
        NumLines = NumberOfSeqs  'number of lines to print
        GBlockNum = 0
        ReDim GBlock(4, 0)
        GBlock(1, 0) = 3 'this is not actually a block - it is the legend saying which sequence is the query sequence
        ReDim GPrint(NumLines - 1, PosCount + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, PosCount + 1)
    
        ReDim GVarPos(0, 0)
        
        ReDim GCritval(10)
        GCritval(0) = -BSCutOff * 100
        GLegend = "Bootstrap support (%)"
        GPrintLen = PosCount + 1 'how many points to plot
        For x = 1 To NumLines
            GPrintCol(x - 1) = SeqCol(RevSeq(x))
        Next x
        
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        Dim Div As Double
        Div = (Int(XOverWindowX / 2) * 2 + 1)
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = 100 'upper val
        
        
        For x = 1 To PosCount
            For Y = 1 To NumLines
                GPrint(Y - 1, x) = PltVal(Y, x)
                
                GPrintPos(Y - 1, x) = PltPos(x)
                
            Next Y
        Next x
        
        
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
        GExtraTNum = NumLines - 1
        ReDim GExtraText(GExtraTNum)
        
        For x = 1 To NumLines
            GExtraText(x - 1) = OriginalName(RevSeq(x))
            
        Next x
        Call RedrawPlotAA(1)
        
        Form1.Picture7.Refresh
        Form1.Picture10.Refresh
End Sub
Public Sub FindSubSeqSS(MakeString, oSeq As Long)
Y = 0
'Nextno = Nextno
ReDim SSSubSeq(3)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
ReDim XDiffPos(Len(StrainSeq(0)) + 200)
Dim SS0 As String, SS1 As String, SS2 As String, SS3 As String
SS0 = String(Len(StrainSeq(0)), " ")
SS1 = String(Len(StrainSeq(0)), " ")
SS2 = String(Len(StrainSeq(0)), " ")
SS3 = String(Len(StrainSeq(0)), " ")
'SS4 = String(Len(StrainSeq(0)), " ")
If MakeString = 1 Then
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        
        'Exit Sub
        If PScores(x) > 0 Then
            Y = Y + 1
            XDiffPos(Y) = x
            XPosDiff(x) = Y
            Mid$(SS0, Y, 1) = Chr(SeqNum(x, Seq1) - 1)
            Mid$(SS1, Y, 1) = Chr(SeqNum(x, Seq2) - 1)
            Mid$(SS2, Y, 1) = Chr(SeqNum(x, Seq3) - 1)
            'SSSubSeq(0) = SSSubSeq(0) + Chr(SeqNum(X, Seq1) - 1)
            'SSSubSeq(1) = SSSubSeq(1) + Chr(SeqNum(X, Seq2) - 1)
            'SSSubSeq(2) = SSSubSeq(2) + Chr(SeqNum(X, Seq3) - 1)
            If RelX > 0 Or RelY > 0 Then
                If oSeq <= NextNo Or XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
                    If SeqNum(x, oSeq) > 0 Then
                        Mid$(SS3, Y, 1) = Chr(SeqNum(x, oSeq) - 1)
                        'SSSubSeq(3) = SSSubSeq(3) + Chr(SeqNum(X, oSeq) - 1)
                    Else
                        Mid$(SS3, Y, 1) = "-"
                        'SSSubSeq(3) = SSSubSeq(3) + "-"
                    End If
                End If
            Else
                If oSeq <= NextNo Then
                    Mid$(SS3, Y, 1) = Chr(SeqNum(x, oSeq) - 1)
                    'SSSubSeq(3) = SSSubSeq(3) + Chr(SeqNum(X, oSeq) - 1)
                End If
            End If
        End If
    Next x
Else
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        
        'Exit Sub
        If PScores(x) > 0 Then
            Y = Y + 1
            XDiffPos(Y) = x
            XPosDiff(x) = Y
        End If
    Next x
End If
LenXoverSeq = Y
SSSubSeq(0) = SS0
SSSubSeq(1) = SS1
SSSubSeq(2) = SS2
SSSubSeq(3) = SS3
End Sub
Public Sub SSXoverB(SPF)
If BestRescanFlag = 1 Then Exit Sub 'siscan is terrible at this - it yields tons of false positives
SSSS = Abs(GetTickCount)
Dim FMaxZ As Double, oSeq As Long, MCPrintPos() As Long, MCPrintData() As Double
Dim TraceSub() As Long
Dim TB As Long, TE As Long
If NextNo <= 1 Then Exit Sub
ReDim TraceSub(NextNo)
'XX = UBound(Distance, 1)
 '   XX = UBound(TreeDistance, 1)
For x = 0 To NextNo
    TraceSub(x) = x
Next x
Call OrderSeqs(tSeq1, tSeq2, tSeq3, Seq1, Seq2, Seq3, TraceSub())


SS = Abs(GetTickCount)
ossoutlyerflag = SSOutlyerFlag
Dim maxz As Double, wps As Byte, WinNum As Long, LSeq As Long, RndNum As Long
Dim ZPScoreHolder() As Double, ZSScoreHolder() As Double, PScoreHolder() As Long, SScoreHolder() As Long
Dim CUR As Byte, CorrectP As Double

LSeq = Len(StrainSeq(0))
If (SSWinLen * 10) > UBound(Decompress, 1) Then
    SSWinLen = UBound(Decompress, 1) / 10
End If
Dim oPointer As Long
oPointer = Screen.MousePointer
If Screen.MousePointer <> 11 Then
    Screen.MousePointer = 11
End If

If SPF = 0 Then
    Form1.SSPanel1.Caption = "Performing SiScan"
End If


If MCFlag = 0 And TManFlag <> 9 Then
    CorrectP = LowestProb / MCCorrection
Else
    CorrectP = 1
End If

If CriticalZ = 0 Then Call GetCriticalZ
Dim VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, VRandConv(15, 12) As Byte, Seq34Conv() As Byte

ReDim VRandTemplate(0, 0)
GlobalMemoryStatus MemSit
Dim LmB As Variant
APhys = Abs(MemSit.dwTotalPhys)
If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
LmB = Len(StrainSeq(0))
LmB = LmB * SSNumPerms
LmB = LmB * 12
'SSNumPerms = 1000
If APhys < LmB Then
    OP = SSNumPerms
    SSNumPerms = APhys / (Len(StrainSeq(0)) * 12)
    pSSNumPerms = SSNumPerms
    If SSNumPerms < 50 Then
        If CLine = "" Or CLine = " " Then
            MsgBox ("There is not enough free memory available to perform a SiScan right now.  Perhaps if you close some programs the situation will improve.")
        End If
        SSNumPerms = OP
        pSSNumPerms = SSNumPerms
        Exit Sub
    End If
    If CLine = "" Or CLine = " " Then
        MsgBox ("You have specified that you would like to do a Sisscan with " + Trim(Str(OP)) + " permutations. There is, however, only enough available memory to do a scan with " + Trim(Str(SSNumPerms)) + " permitations.")
    End If
End If
ReDim HRandTemplate(SSWinLen), TakenPos(SSWinLen), VRandTemplate(Len(StrainSeq(0)), SSNumPerms), DoGroupP(1, 3), DoGroupS(1, 3), DG1(15), DG2(14), Seq34Conv(5, 5)

Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())


SSS = Abs(GetTickCount)

TotalSSRecombinants = 0

If SSStep = 0 Then SSStep = 100

WinNum = CLng(LSeq / SSStep + 1)



'Triplet specific stuff
ReDim SScoreHolder(WinNum, 14)
ReDim PScoreHolder(WinNum, 15)
ReDim ZPScoreHolder(WinNum, 15)
ReDim ZSScoreHolder(WinNum, 14)

Dim SHPos As Long
Dim PermPScores() As Long
Dim SeqScore3() As Integer
ReDim SeqScore3(LSeq)
Dim MeanPScore() As Double
ReDim MeanPScore(15)
'Dim PScores() As Byte
Dim YPos As Byte
Dim SDPScore() As Double
ReDim SDPScore(15)
Dim HN1 As Byte
Dim HN2 As Byte
Dim HN3 As Byte
Dim Hi As Integer
Dim HV As Integer, LV1 As Integer, LV2 As Integer, HP As Integer, LP1 As Integer, LP2 As Integer
Dim Tally() As Long
'ReDim PermPScores(SSNumPerms, 15)
Dim PermSScores() As Long
ReDim PermSScores(SSNumPerms, 14)

Dim PScores2() As Byte, PScores3() As Long
SSOLSeq = ""
SSOLSeqName = ""


If SSOutlyerFlag = 2 Then
    Call GetOutie
    oSeq = Outie
    SSOLSeq = StrainSeq(oSeq)
    SSOLSeqName = OriginalName(oSeq)
ElseIf SSOutlyerFlag = 3 Then
    oSeq = ManSSOLSeq
ElseIf SSOutlyerFlag = 0 Then
    oSeq = NextNo + 1
'ElseIf SSOutlyerFlag = 1 Then
'    oSeq = XOverList(RelX, RelY).LHolder
'    SSOLSeq = StrainSeq(oSeq)
'    SSOLSeqName = originalname(oSeq)
End If


C = 0

FHPos = 0


If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
UB = 0
UB = UBound(Distance, 1)

If UB = 0 Or UB < Seq1 Or UB < Seq2 Or UB < Seq3 Then Exit Sub

On Error GoTo 0



If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) And Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
    ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
    HV = 0: LV1 = 1: LV2 = 2
    HP = 2: LP1 = 3: LP2 = 4
ElseIf Distance(Seq1, Seq3) > Distance(Seq1, Seq2) And Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
    ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
    HV = 1: LV1 = 0: LV2 = 2
    HP = 3: LP1 = 2: LP2 = 4
Else
    ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
    HV = 2: LV1 = 0: LV2 = 1
    HP = 4: LP1 = 2: LP2 = 3
End If
            
'Calculate 3 sequence scores
ReDim PScores(Len(StrainSeq(0)))
'This could be speeded up with better nesting
Get3Score SSGapFlag, Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), SeqScore3(0)

Dim OLS As Integer, InS As Integer, CTD As Double
ReDim PScores2(LSeq)



If (RelX > 0 Or RelY > 0) Then
    If (XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum) And CLng(XoverList(RelX, RelY).DHolder) > -1000000 And CLng(Abs(CLng(XoverList(RelX, RelY).DHolder))) <= NextNo Then
        oSeq = Abs(CLng(XoverList(RelX, RelY).DHolder))
        SSOLSeq = StrainSeq(TreeTrace(oSeq))
        SSOLSeqName = OriginalName(TreeTrace(oSeq))
    ElseIf (XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum) And (CLng(XoverList(RelX, RelY).DHolder) > NextNo) Then
        SSOutlyerFlag = 0
        oSeq = NextNo + 1
        SSOLSeq = String(Len(StrainSeq(0)), " ")
        SSOLSeqName = "Randomised"
    Else
    
        If x = x Then
            SSOutlyerFlag = pSSOutlyerFlag
            Call GetSSOutlyer(oSeq, 1, TraceSub())
                
        Else
            If SSOutlyerFlag = 1 Then ' Find outlyer seq if necessary 0 = use rndseq, 2 = use most distant seq
                
                Do
                    If TreeDistance(Seq1, Seq2) > TreeDistance(Seq1, Seq3) Then
                        InS = Seq1: OLS = Seq3
                    ElseIf TreeDistance(Seq1, Seq3) > TreeDistance(Seq1, Seq2) Then
                        InS = Seq1: OLS = Seq2
                    ElseIf TreeDistance(Seq2, Seq3) > TreeDistance(Seq1, Seq2) Then
                        InS = Seq2: OLS = Seq1
                    End If
                    CTD = 0
                    For x = 0 To NextNo
                        If TreeDistance(OLS, x) < TreeDistance(OLS, InS) And TreeDistance(OLS, x) >= CTD And x <> OLS Then
                            If TreeDistance(OLS, x) = CTD Then
                                If Distance(OLS, x) > Distance(OLS, oSeq) Then
                                    oSeq = x
                                    CTD = TreeDistance(OLS, x)
                                    SSOLSeq = StrainSeq(oSeq)
                                    SSOLSeqName = OriginalName(oSeq)
                                End If
                            Else
                                oSeq = x
                                CTD = TreeDistance(OLS, x)
                                SSOLSeq = StrainSeq(oSeq)
                                SSOLSeqName = OriginalName(oSeq)
                            End If
                        End If
                    Next x
                    
                    If CTD > 0 Then
                        Exit Do
                    Else
                        SSOutlyerFlag = 0
                        SSOLSeq = String(Len(StrainSeq(0)), " ")
                        SSOLSeqName = "Randomised"
                        Exit Do
                    End If
                Loop
            ElseIf SSOutlyerFlag = 0 Then
                SSOLSeq = String(Len(StrainSeq(0)), " ")
                SSOLSeqName = "Randomised"
            End If
        End If
    End If
Else

    If NextNo = 2 Or SSOutlyerFlag = 0 Then
        SSOutlyerFlag = 0
        oSeq = NextNo + 1
        SSOLSeq = String(Len(StrainSeq(0)), " ")
        SSOLSeqName = "Randomised"
    End If
End If
            


SSOLoSeq = oSeq
            
'Construct horizontal randomisation array (used for every window)to generate the
'fourth randomised sequence
            
Dim ZMax As Double, ZMin As Double

ZMax = -10
ZMin = 10

Dim RegPeak() As Byte
ReDim RegPeak(Len(StrainSeq(0)))
BE = XoverList(RelX, RelY).Beginning
EN = XoverList(RelX, RelY).Ending
If BE < EN Then
    For x = BE To EN
        RegPeak(x) = 1
    Next x
Else
    For x = BE To Len(StrainSeq(0))
        RegPeak(x) = 1
    Next x
    For x = 1 To EN
        RegPeak(x) = 1
    Next x
End If
'Examine the windows
If oSeq = -1 Then oSeq = Outie
If x = x Then 'SPF = 0 Then
'    If SPF = 0 Then
'        Form1.ProgressBar1 = 20
'    End If
    For x = 1 To LSeq - SSWinLen Step SSStep
        'Quick check to see if this window is worth examining
        SHPos = CLng(x / SSStep)
        If FHPos = 0 Then FHPos = SHPos
        If SSOutlyerFlag = 0 Then
            
            'ReDim Preserve SeqNum(Len(StrainSeq(0)), Nextno + 1)
            
            If x = 12345 Then
                ReDim PScores3(15)
                
                oSeq = NextNo + 1
                
                GetPScoresRnd x, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0), HRandTemplate(0)
                
                For Y = 0 To SSWinLen - 1
                    Mid(SSOLSeq, x + Y, 1) = Mid$(StrainSeq(Seq1), x + HRandTemplate(Y + 1), 1)
                Next ' Y
            Else
            
                For Y = 0 To SSWinLen - 1
                    HN = SeqScore3(x + Y)
                    Hi = x + HRandTemplate(Y + 1)
                    Hi = SeqNum(Hi, Seq1)
                    Mid(SSOLSeq, x + Y, 1) = Mid$(StrainSeq(Seq1), x + HRandTemplate(Y + 1), 1)
                    SeqNum(x + Y, NextNo + 1) = Hi
                    If SeqNum(x + Y, Seq1) = Hi Then
                        PScores(Y + 1) = Seq34Conv(HN, 1)
                    Else
                        Select Case HN
                            Case 1
                                If SeqNum(x + Y, Seq2) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 2)
                                ElseIf SeqNum(x + Y, Seq3) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 3)
                                Else
                                    PScores(Y + 1) = Seq34Conv(HN, 4)
                                End If
                            Case 2
                                If SeqNum(x + Y, Seq3) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 3)
                                Else
                                    PScores(Y + 1) = Seq34Conv(HN, 4)
                                End If
                            Case 3, 4
                                If SeqNum(x + Y, Seq2) = Hi Then
                                    PScores(Y + 1) = Seq34Conv(HN, 2)
                                Else
                                    PScores(Y + 1) = Seq34Conv(HN, 4)
                                End If
                            Case 5
                                PScores(Y + 1) = Seq34Conv(HN, 4)
                        End Select
                    End If
                Next ' Y
            End If
        Else
            If x = 31901 Then
                x = x
            End If
            GetPScores x, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
        End If
                        
                        
                        
                        
        'Do Perms
        'Calculate actual scores
        ReDim PermPScores(SSNumPerms, 15)
        
'        XX = UBound(VRandTemplate, 2)
'        XX = UBound(VRandConv, 1)
        
        'Dummy = DoPermsX(Len(StrainSeq(0)), SSWinLen, SSNumPerms, PScores(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
        
        Dummy = DoPermsXP(Len(StrainSeq(0)), SSWinLen, SSNumPerms, PScores(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
       XD = MakeZValue2(SHPos, WinNum, 15, SSNumPerms, SSNumPerms, DG1(0), PermPScores(0, 0), ZPScoreHolder(0, 0))
                        
        DoSums SSNumPerms, SSNumPerms, PermSScores(0, 0), PermPScores(0, 0)
                                        
                                        
        XX = UBound(PScores, 1)
        
                                        
        SScoreHolder(SHPos, 1) = PermSScores(0, 1)
        SScoreHolder(SHPos, 2) = PermSScores(0, 2)
        SScoreHolder(SHPos, 3) = PermSScores(0, 3)
        SScoreHolder(SHPos, 4) = PermSScores(0, 4)
        SScoreHolder(SHPos, 5) = PermSScores(0, 5)
        SScoreHolder(SHPos, 7) = PermSScores(0, 7)
        XX = PermPScores(0, 9)
        XD = MakeZValue2(SHPos, WinNum, 12, SSNumPerms, SSNumPerms, DG2(0), PermSScores(0, 0), ZSScoreHolder(0, 0))
                    
        For Z = 1 To 15
            If ZPScoreHolder(SHPos, Z) > ZMax Then
                ZMax = ZPScoreHolder(SHPos, Z)
            ElseIf ZPScoreHolder(SHPos, Z) < ZMin Then
                ZMin = ZPScoreHolder(SHPos, Z)
            End If
            If RegPeak(x) = 1 Then
               If ZPScoreHolder(SHPos, Z) > FMaxZ Then
                    FMaxZ = ZPScoreHolder(SHPos, Z)
               End If
            End If
        Next Z
        
        For Z = 1 To 12
            If ZSScoreHolder(SHPos, Z) > ZMax Then
                ZMax = ZSScoreHolder(SHPos, Z)
            ElseIf ZSScoreHolder(SHPos, Z) < ZMin Then
                ZMin = ZSScoreHolder(SHPos, Z)
            End If
            If RegPeak(x) = 1 Then
               If ZSScoreHolder(SHPos, Z) > FMaxZ Then
                    FMaxZ = ZSScoreHolder(SHPos, Z)
               End If
            End If
        Next Z
'        If SPF = 0 Then
'            '@
'            Form1.ProgressBar1 = 20 + (X / Len(StrainSeq(0))) * 75
'        End If
        
    Next 'x
End If
'FMaxZ = ZMax
ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200), PScores(Len(StrainSeq(0)))

GetPScores 1, Len(StrainSeq(0)), Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)

For x = 1 To Len(StrainSeq(0))
    PScores(x) = Abs(PScores(x) * (DG1(PScores(x)) - 1))
Next x


If TManFlag <> 9 Then
    
    TB = XoverList(RelX, RelY).Beginning
    TE = XoverList(RelX, RelY).Ending
    maxz = 0
    
    
    
    
    Dim MinPA As Double, MinPA2 As Double
    MinPA = 1
    MinPA2 = 1
    If ExeCheckFlag = 1 Or OptFlag = 9 Or XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
        Dim LRegion As Long
        If TB < TE Then
            LRegion = TE - TB + 1
        Else
            LRegion = TE + (Len(StrainSeq(0)) - TB + 1)
        End If
        'If LRegion > Len(StrainSeq(0)) / 4 Then LRegion = Len(StrainSeq(0)) / 4
        

        If SSOutlyerFlag = 0 Then
            ReDim PScores3(15)
            Dim HRandTemplate2() As Long
            ReDim HRandTemplate2(LRegion)
            ReDim TakenPos(LRegion)
            For Z = 1 To LRegion
                RndNum = Int((LRegion * Rnd) + 1)
                If TakenPos(RndNum) = 0 Then
                    HRandTemplate2(Z) = RndNum
                    TakenPos(RndNum) = 1
                Else 'find next available position to the right
                    Y = RndNum
                    Do While TakenPos(Y) = 1
                        Y = Y + 1
                        If Y > LRegion Then Y = 1
                    Loop
                    HRandTemplate2(Z) = Y
                    TakenPos(Y) = 1
                End If
            Next 'X
            
            GetPScoresRnd TB, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0), HRandTemplate2(0)
            
            
        Else
            ReDim PScores3(15)
            If UBound(SeqNum, 2) < Seq1 Or UBound(SeqNum, 2) < Seq2 Or UBound(SeqNum, 2) < Seq3 Or UBound(SeqNum, 2) < oSeq Then
               If UBound(SeqNum, 2) < Seq1 Then
                    ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq1)
                End If
                If UBound(SeqNum, 2) < Seq2 Then
                    ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq2)
                End If
                If UBound(SeqNum, 2) < Seq3 Then
                    ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq3)
                End If
                If UBound(SeqNum, 2) < oSeq Then
                    ReDim Preserve SeqNum(Len(StrainSeq(0)), oSeq)
                End If
            End If
            GetPScores2 TB, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
            'GetPScores2 TB, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores2(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
            
            '31901,4766
            'GetPScores X, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)

        End If
        
      
        Dim tZPScore() As Double, tZSScore() As Double
        ReDim tZPScore(1, 15)
        ReDim tZSScore(1, 14)
        ReDim PermPScores(SSNumPerms, 15)
    
        
        
        Dummy = DoPerms3(Len(StrainSeq(0)), LRegion, SSNumPerms, SSNumPerms, PScores3(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
        
        
        MakeZValue2 0, 1, 15, SSNumPerms, SSNumPerms, DG1(0), PermPScores(0, 0), tZPScore(0, 0)
        
        DoSums SSNumPerms, SSNumPerms, PermSScores(0, 0), PermPScores(0, 0)
        
        
        
        
        
        
        
        'For X = 0 To 12
        '    DG2(0) = 0
        'Next X
        
        'Calculate Z Scores
        MakeZValue2 0, 1, 12, SSNumPerms, SSNumPerms, DG2(0), PermSScores(0, 0), tZSScore(0, 0)
        
        
       
        
       maxz = 0
        WinP = 0
        wps = 0
        
        'If X = X Then
            For Z = 0 To 15
                If tZPScore(0, Z) > maxz Then '7=2.2'8=-81'10=1.4'14=3.65
                    maxz = Abs(tZPScore(0, Z)) '5=9.33; 14=12.89
                    WinP = Z
                    WinScore = Z
                    wps = 1
                End If
            Next Z
            For Z = 0 To 14
                If tZSScore(0, Z) > maxz Then '7=3.5:7=12.89
                    maxz = Abs(tZSScore(0, Z))
                    WinP = Z
                    WinScore = Z
                    wps = 2
                End If
            Next Z
            x = x
        'Else
        
        
            For Z = 0 To 1
                'If tZPScore(0, DoGroupP(Z, HV)) < tZPScore(0, DoGroupP(Z, LV1)) Or tZPScore(0, DoGroupP(Z, HV)) < tZPScore(0, DoGroupP(Z, LV2)) Then
                    
                    For Y = 0 To 2
                        If Y <> HV Then
                            If Abs(tZPScore(0, DoGroupP(Z, Y))) > maxz Then
                                
                                maxz = Abs(tZPScore(0, DoGroupP(Z, Y)))
                                WinScore = DoGroupP(Z, Y)
                                wps = 1
                            End If
                        End If
                    Next Y
                'End If
            Next Z
            For Z = 0 To 1
                'If tZSScore(0, DoGroupS(Z, HV)) < tZSScore(0, DoGroupS(Z, LV1)) Or tZSScore(0, DoGroupS(Z, HV)) < tZSScore(0, DoGroupS(Z, LV2)) Then
                    For Y = 0 To 2
                            If Y <> HV Then
                                If Abs(tZSScore(0, DoGroupS(Z, Y))) > maxz Then
                                    maxz = Abs(tZSScore(0, DoGroupS(Z, Y)))
                                    WinScore = DoGroupS(Z, Y)
                                    wps = 2
                                End If
                            End If
                    Next Y
                'End If
            Next Z
            x = x
        'End If
        
        'i 've disabled this because it was giving megascores even for non-recombinants
        'If maxz < FMaxZ Then maxz = FMaxZ
        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            sizer = (XoverList(RelX, RelY).Ending - XoverList(RelX, RelY).Beginning)
        Else
            sizer = (XoverList(RelX, RelY).Ending + Len(StrainSeq(0)) - XoverList(RelX, RelY).Beginning)
        End If
        WinP = NormalZ(maxz)
        WinP = WinP * (Len(StrainSeq(0)) / SSWinLen)
        If MCFlag = 0 Then
            WinP = WinP * MCCorrection
        ElseIf pMCFlag = 2 Then
            WinP = StepDown2(5, WinP)
        End If
        ProbTest = Str(WinP)
        MinPA = WinP
    Else
        ProbTest = XoverList(RelX, RelY).Probability
        
    End If
    
    If TB < TE Then
        ProbX = Decompress(TB) + (Decompress(TE) - Decompress(TB)) / 2
    Else
        ProbX = 1 + (Decompress(TE) - 1) / 2
    End If
    'Dim ProbTest As String
    ProbY = 1

    
    If MinPA < 1 Then
    
        
        If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
            BestParent = CheckParent: WinMethod = 5
            BestParentP = MinPA
        End If
        
    End If
End If

If BestRescanFlag = 1 Then
    If BestRescanP > MinPA And MinPA < LowestProb And MinPA > 0 Then
        BestRescanP = MinPA
    End If
End If


Call FindSubSeqSS(1, oSeq) '(oSeq)

If (SPF = 0 And UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
    ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    If ZMax < CriticalZ Then ZMax = CriticalZ
    If ZMin > -CriticalZ Then ZMin = -CriticalZ
    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
    'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, ZMax, ZMin, 1, "Z - Score")
    
    SSUp = ZMax
    SSLo = ZMin
    
    Form1.Picture7.DrawWidth = 3
    
    Dim PntAPI As POINTAPI
    
    Y = 4
    
    
    ReDim MCPrintPos(Len(StrainSeq(0))), MCPrintData(1, 15, (Len(StrainSeq(0)) / SSStep) + SSWinLen), PltCol(15), PltCol2(12)
    'Exit Sub
    For x = 0 To 15
        PltCol(x) = RGB(240, 240, 240)
    Next x
    For x = 0 To 9
        PltCol2(x) = RGB(240, 240, 240)
    Next x
    
    Dim mYellow As Long, mPurple As Long, mGreen As Long, Green As Long
    'RGB(0, CInt(BkG - BkG / 3), CInt(BkB - BkB / 3))
    Green = RGB(0, CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
    mYellow = RGB(225, 225, CInt(BkB - BkB / 2))
    mPurple = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
    
    If ManFlag = -1 And CurrentCheck = 5 And XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag + AddNum <> 5 Then
        mGreen = RGB(CInt(BkR - BkR / 1.5), CInt(BkG - BkG / 3), CInt(BkB - BkB / 3))
    Else
        mGreen = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 6))
     
    End If
    
    If tSeq1 = Seq3 And tSeq2 = Seq2 Then
        PltCol(2) = mPurple 'mYellow
        PltCol(3) = mGreen 'mPurple
        PltCol(5) = mYellow 'mgreen
        PltCol(8) = mPurple 'mYellow
        PltCol(9) = mGreen 'mPurple
        PltCol(10) = mYellow 'mgreen
        PltCol2(1) = mPurple 'mYellow
        PltCol2(2) = mGreen 'mPurple
        PltCol2(3) = mYellow 'mgreen
        PltCol2(4) = mPurple 'mYellow
        PltCol2(5) = mGreen 'mPurple
        PltCol2(7) = mYellow 'mgreen
    ElseIf tSeq1 = Seq2 And tSeq2 = Seq3 Then
        PltCol(2) = mGreen 'mYellow
        PltCol(3) = mPurple
        PltCol(5) = mYellow 'mgreen
        PltCol(8) = mGreen 'mYellow
        PltCol(9) = mPurple
        PltCol(10) = mYellow 'mgreen
        PltCol2(1) = mGreen 'mYellow
        PltCol2(2) = mPurple
        PltCol2(3) = mYellow 'mgreen
        PltCol2(4) = mGreen 'mYellow
        PltCol2(5) = mPurple
        PltCol2(7) = mYellow 'mgreen
    ElseIf tSeq1 = Seq1 And tSeq2 = Seq2 Then
        PltCol(2) = mYellow
        PltCol(3) = mGreen 'mPurple
        PltCol(5) = mPurple 'mgreen
        PltCol(8) = mYellow
        PltCol(9) = mGreen 'mPurple
        PltCol(10) = mPurple 'mgreen
        PltCol2(1) = mYellow
        PltCol2(2) = mGreen 'mPurple
        PltCol2(3) = mPurple 'mgreen
        PltCol2(4) = mYellow
        PltCol2(5) = mGreen 'mPurple
        PltCol2(7) = mPurple 'mgreen
    ElseIf tSeq1 = Seq1 And tSeq2 = Seq3 Then
        PltCol(2) = mGreen 'mPurple 'mYellow
        PltCol(3) = mYellow 'mgreen 'mPurple
        PltCol(5) = mPurple 'mYellow 'mgreen
        PltCol(8) = mGreen 'mPurple 'mYellow
        PltCol(9) = mYellow 'mgreen 'mPurple
        PltCol(10) = mPurple 'mYellow 'mgreen
        PltCol2(1) = mGreen 'mPurple 'mYellow
        PltCol2(2) = mYellow 'mgreen 'mPurple
        PltCol2(3) = mPurple 'mYellow 'mgreen
        PltCol2(4) = mGreen 'mPurple 'mYellow
        PltCol2(5) = mYellow 'mgreen 'mPurple
        PltCol2(7) = mPurple 'mYellow 'mgreen
    ElseIf tSeq1 = Seq2 And tSeq2 = Seq1 Then
        PltCol(2) = mYellow
        PltCol(3) = mPurple
        PltCol(5) = mGreen
        PltCol(8) = mYellow
        PltCol(9) = mPurple
        PltCol(10) = mGreen
        PltCol2(1) = mYellow
        PltCol2(2) = mPurple
        PltCol2(3) = mGreen
        PltCol2(4) = mYellow
        PltCol2(5) = mPurple
        PltCol2(7) = mGreen
    ElseIf tSeq2 = Seq1 And tSeq3 = Seq2 Then
        'this has been wrong once before
        PltCol(2) = mPurple 'mYellow
        PltCol(3) = mYellow 'mgreen 'mPurple
        PltCol(5) = mGreen
        PltCol(8) = mPurple 'mYellow
        PltCol(9) = mYellow 'mgreen 'mPurple
        PltCol(10) = mGreen
        PltCol2(1) = mPurple 'mYellow
        PltCol2(2) = mYellow 'mgreen 'mPurple
        PltCol2(3) = mGreen
        PltCol2(4) = mPurple 'mYellow
        PltCol2(5) = mYellow 'mgreen 'mPurple
        PltCol2(7) = mGreen
    Else
        PltCol(2) = mGreen 'mPurple 'mYellow
        PltCol(3) = mYellow 'mgreen 'mPurple
        PltCol(5) = mPurple 'mYellow 'mgreen
        PltCol(8) = mGreen 'mPurple 'mYellow
        PltCol(9) = mYellow 'mgreen 'mPurple
        PltCol(10) = mPurple 'mYellow 'mgreen
        PltCol2(1) = mGreen 'mPurple 'mYellow
        PltCol2(2) = mYellow 'mgreen 'mPurple
        PltCol2(3) = mPurple 'mYellow 'mgreen
        PltCol2(4) = mGreen 'mPurple 'mYellow
        PltCol2(5) = mYellow 'mgreen 'mPurple
        PltCol2(7) = mPurple 'mYellow 'mgreen
    End If
    
    If SPF = 0 Then
        
        NumLines = 25 'number of lines to print
        ReDim GPrintCol(NumLines - 1)
        
        ReDim Preserve PltCol(30)
        
        For x = 1 To 15
            GPrintCol(x - 1) = PltCol(x)
        Next x
        For x = 1 To 9
            GPrintCol(x + 14) = PltCol2(x)
        Next x
    End If
    ReDim PltCol3(15)
    
    'Form1.ProgressBar1 = 100
    
    For x = 0 To 15
        PltCol3(x) = PltCol(x)
        XX = RGB(240, 240, 240)
        If PltCol3(x) = Green Then
            PltCol3(x) = mGreen
        
        ElseIf PltCol(x) = RGB(240, 240, 240) Then
            PltCol3(x) = HalfColour
        End If
    Next x
    Dim HLT(2)
    Dim FST As Byte
    If TManFlag <> 9 Then
        If XoverList(RelX, RelY).ProgramFlag <> 0 And XoverList(RelX, RelY).LHolder <> 0 + AddNum And XoverList(RelX, RelY).LHolder >= 11 And XoverList(RelX, RelY).LHolder <= 13 Then
            FST = 0
            HLT(0) = 1
            HLT(1) = 2
            HLT(2) = 3
            For Z = 1 To 3
                If PltCol2(Z) = mPurple Then
                    PltCol2(Z) = LPurple
                    'PltCol3(Z) = Purple
                ElseIf PltCol2(Z) = mYellow Then
                    PltCol2(Z) = LYellow
                    'PltCol3(Z) = Yellow
                ElseIf PltCol2(Z) = Green Then
                    PltCol2(Z) = LGreen
                    'PltCol3(Z) = Green
                End If
            Next Z
            
            
            'PltCol2(1) = LGreen
            'PltCol2(2) = LPurple
            'PltCol2(3) = LYellow
            
            'PltCol3(2) = Green
            'PltCol3(3) = Purple
            
            PltCol3(7) = Green
            PltCol3(6) = Purple
            
            PltCol3(8) = Green
            PltCol3(9) = Purple
            PltCol3(10) = Yellow
            PltCol3(4) = Yellow
            PltCol3(5) = Yellow
            
            
            If DG1(11) = 0 Then
                PltCol3(11) = RGB(230, 230, 160)
            End If
            
        ElseIf XoverList(RelX, RelY).LHolder >= 14 And XoverList(RelX, RelY).LHolder <= 17 Then
            FST = 0
            HLT(0) = 4
            HLT(1) = 5
            HLT(2) = 7
            For Z = 4 To 7
                If PltCol2(Z) = mPurple Then
                    PltCol2(Z) = LPurple
                   ' PltCol3(Z) = Purple
                ElseIf PltCol2(Z) = mYellow Then
                    PltCol2(Z) = LYellow
                   ' PltCol3(Z) = Yellow
                ElseIf PltCol2(Z) = Green Then
                    PltCol2(Z) = LGreen
                   ' PltCol3(Z) = Green
                End If
            Next Z
            
            PltCol3(2) = PltCol2(4)
            PltCol3(3) = PltCol2(5)
            PltCol3(5) = PltCol2(7)
            PltCol3(8) = PltCol2(4)
            PltCol3(9) = PltCol2(5)
            PltCol3(10) = PltCol2(7)
            PltCol3(12) = PltCol2(4)
            PltCol3(13) = PltCol2(5)
            PltCol3(14) = PltCol2(7)
            
            For Z = 1 To 14
                If PltCol3(Z) = LPurple Then
                    PltCol3(Z) = Purple
                ElseIf PltCol3(Z) = LYellow Then
                    PltCol3(Z) = Yellow
                ElseIf PltCol3(Z) = LGreen Then
                    PltCol3(Z) = Green
                End If
            
            Next Z
            'If DG1(11) = 0 Then
            
            
            '    PltCol3(11) = RGB(230, 160, 160)
            'End If
        ElseIf XoverList(RelX, RelY).LHolder >= 2 And XoverList(RelX, RelY).LHolder <= 5 Then
            FST = 1
            HLT(0) = 2
            HLT(1) = 3
            HLT(2) = 5
            
            For Z = 2 To 5
                If PltCol(Z) = mPurple Then
                    PltCol(Z) = LPurple
                    PltCol3(Z) = Purple
                ElseIf PltCol(Z) = mYellow Then
                    PltCol(Z) = LYellow
                    PltCol3(Z) = Yellow
                ElseIf PltCol(Z) = Green Then
                    PltCol(Z) = LGreen
                    PltCol3(Z) = Green
                End If
            Next Z
            
            'PltCol(2) = LGreen
            'PltCol(3) = LPurple
            'PltCol(5) = LYellow
            
            'PltCol3(2) = Green
            'PltCol3(3) = Purple
            'PltCol3(5) = Yellow
            'If DG1(11) = 0 Then
            '    PltCol3(11) = RGB(230, 160, 160)
            'End If
        ElseIf XoverList(RelX, RelY).LHolder >= 8 And XoverList(RelX, RelY).LHolder <= 10 Then
            FST = 1
            HLT(0) = 8
            HLT(1) = 9
            HLT(2) = 10
            For Z = 8 To 10
                If PltCol(Z) = mPurple Then
                    PltCol(Z) = LPurple
                    PltCol3(Z) = Purple
                ElseIf PltCol(Z) = mYellow Then
                    PltCol(Z) = LYellow
                    PltCol3(Z) = Yellow
                ElseIf PltCol(Z) = Green Then
                    PltCol(Z) = LGreen
                    PltCol3(Z) = Green
                End If
            Next Z
            
            'PltCol(8) = LGreen
            'PltCol(9) = LPurple
            'PltCol(10) = LYellow
            'PltCol3(8) = Green
            'PltCol3(9) = Purple
            'PltCol3(10) = Yellow
            'If DG1(11) = 0 Then
            '    PltCol3(11) = RGB(230, 160, 160)
            'End If
        End If
    End If
    
    Form1.Picture7.DrawWidth = 3
    CUR = 0
    
    
    If RelX > 0 Or RelY > 0 Then
        If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            If FST = 0 Then
                Do
                    Form1.Picture7.ForeColor = PltCol2(HLT(CUR))
                    Y = HLT(CUR)
                    Pict = Form1.Picture7.hdc

'                        MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'                        SPos = 1
'                        For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
'                            LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
'                            SPos = SPos + 1
'                        Next X

                    CUR = CUR + 1
                    If CUR = 3 Then Exit Do
                Loop
            Else
'                Do
'                    Form1.Picture7.ForeColor = PltCol(HLT(CUR))
'                    Y = HLT(CUR)
'                    Pict = Form1.Picture7.hDC
'
'                    MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'                    SPos = 1
'                    For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
'                        LineTo Pict, (30 + (X + Decompress((SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
'                        SPos = SPos + 1
'                    Next X
'                    CUR = CUR + 1
'                    If CUR = 3 Then Exit Do
'                Loop
            End If
        End If
    End If
    Form1.Picture7.DrawWidth = 1
    If DontRedrawPlotsFlag = 0 Then
                                          
        Call Highlight(0)
        WN1 = tSeq1: WN2 = tSeq2: WN3 = tSeq3
        WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
        Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
    End If
    'Call WriteNames(tSeq1, tSeq2, tSeq3, Yellow, Green, Purple)
    
    x = x
    
    Spos = 0
    For x = 1 To LSeq - SSWinLen Step SSStep
        MCPrintPos(Spos) = x + SSWinLen / 2
        Spos = Spos + 1
    Next x
    
    For Y = 1 To 15
        If PltCol(Y) = PltCol(15) Then
            Form1.Picture7.ForeColor = PltCol(Y)
            Pict = Form1.Picture7.hdc
            'If DG1(Y) = 0 and Then
'                MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
                MCPrintData(0, Y, 0) = ZPScoreHolder(0, Y)
                Spos = 1
                For x = SSStep + 1 To LSeq - SSWinLen Step SSStep
                    'If ZPScoreHolder(SPos, Y) > 0 Then
'                        LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                    'End If
                    MCPrintData(0, Y, Spos) = ZPScoreHolder(Spos, Y)
                    Spos = Spos + 1
                    
                Next x
            'End If
        End If
    Next Y
    
    Form1.Picture7.DrawWidth = 1
    'Zero Line
    'Form1.Picture7.ForeColor = RGB(0, 0, 0)
    'Pict = Form1.Picture7.hdc
    'MoveToEx Pict, 25, (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
    'LineTo Pict, (30 + Len(StrainSeq(0)) * XFactor), (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    'Critical Z lines
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Pict = Form1.Picture7.hdc
'    MoveToEx Pict, 25, (PicHeight - (15 + ((CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'    LineTo Pict, (30 + Decompress(Len(StrainSeq(0))) * xFactor), (PicHeight - (15 + ((CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
'
'    Form1.Picture7.ForeColor = RGB(0, 0, 0)
'    Pict = Form1.Picture7.hDC
'    MoveToEx Pict, 25, (PicHeight - (15 + ((-CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'    LineTo Pict, (30 + Decompress(Len(StrainSeq(0))) * xFactor), (PicHeight - (15 + ((-CriticalZ - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    Form1.Picture7.DrawStyle = 0
    
    
    For Y = 1 To 9
        If PltCol2(Y) = PltCol2(9) Then
            Form1.Picture7.ForeColor = PltCol2(Y)
            Pict = Form1.Picture7.hdc
'            MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
            MCPrintData(1, Y, 0) = ZSScoreHolder(0, Y)
            Spos = 1
            For x = SSStep + 1 To LSeq - SSWinLen Step SSStep
'                LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                MCPrintData(1, Y, Spos) = ZSScoreHolder(Spos, Y)
                Spos = Spos + 1
            Next x
        End If
    Next Y
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Pict = Form1.Picture7.hdc
'    MoveToEx Pict, 25, (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'    LineTo Pict, (30 + Decompress(Len(StrainSeq(0))) * xFactor), (PicHeight - (15 + ((0 - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
    
    For Y = 1 To 15
        If PltCol(Y) <> PltCol(15) Then
            Form1.Picture7.ForeColor = PltCol(Y)
            If SPF = 0 Then
                GPrintCol(Y - 1) = PltCol(Y)
            End If
            Pict = Form1.Picture7.hdc
'            MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
            MCPrintData(0, Y, 0) = ZPScoreHolder(0, Y)
            Spos = 1
            For x = SSStep + 1 To LSeq - SSWinLen Step SSStep
'                LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                '@
                MCPrintData(0, Y, Spos) = ZPScoreHolder(Spos, Y)
                Spos = Spos + 1
            Next x
        End If
    Next Y
    
    For Y = 1 To 9
        If PltCol2(Y) <> PltCol2(9) Then
            Form1.Picture7.ForeColor = PltCol2(Y)
            If SPF = 0 Then
                GPrintCol(Y + 14) = PltCol2(Y)
            End If
            Pict = Form1.Picture7.hdc
            If (SSWinLen / 2) <= UBound(Decompress, 1) Then
                MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * XFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
            End If
            MCPrintData(1, Y, 0) = ZSScoreHolder(0, Y)
            Spos = 1
            For x = SSStep + 1 To LSeq - SSWinLen Step SSStep
'                LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
                MCPrintData(1, Y, Spos) = ZSScoreHolder(Spos, Y)
                Spos = Spos + 1
            Next x
        End If
    Next Y
    Form1.Picture7.DrawWidth = 1
    
    
    'Zero Line
    
    
    Form1.Picture7.DrawStyle = 0
    
    Y = 4
    CUR = 0
    
    If RelX > 0 Or RelY > 0 Then
        If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Then
            If FST = 0 Then
                For Z = 0 To 1
                    If Z = 0 Then
                        Form1.Picture7.DrawWidth = 2
                        For A = 0 To 2
                            If PltCol2(HLT(A)) = mGreen Or PltCol2(HLT(A)) = Green Or PltCol2(HLT(A)) = LGreen Then
                                PltCol2(HLT(A)) = LGreen
                            ElseIf PltCol2(HLT(A)) = mPurple Or PltCol2(HLT(A)) = Purple Or PltCol2(HLT(A)) = LPurple Then
                                PltCol2(HLT(A)) = mPurple
                            Else
                                PltCol2(HLT(A)) = mYellow
                            End If
                        
                        Next A
                    Else
                        Form1.Picture7.DrawWidth = 1
                        For A = 0 To 2
                            If PltCol2(HLT(A)) = mGreen Or PltCol2(HLT(A)) = Green Or PltCol2(HLT(A)) = LGreen Then
                                PltCol2(HLT(A)) = Green
                            ElseIf PltCol2(HLT(A)) = mPurple Or PltCol2(HLT(A)) = Purple Or PltCol2(HLT(A)) = LPurple Then
                                PltCol2(HLT(A)) = Purple
                            Else
                                PltCol2(HLT(A)) = Yellow
                            End If
                        
                        Next A
                    End If
                    CUR = 0
'                    Do
'                        Form1.Picture7.ForeColor = PltCol2(HLT(CUR))
'                        Y = HLT(CUR)
'                        Pict = Form1.Picture7.hDC
'
''                        MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'                        SPos = 1
'                        For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
''                            LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZSScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
'                            SPos = SPos + 1
'                        Next X
'                        CUR = CUR + 1
'                        If CUR = 3 Then Exit Do
'                    Loop
                    x = x
                Next Z
            Else
                For Z = 0 To 1
                    If Z = 0 Then
                        Form1.Picture7.DrawWidth = 2
                        PltCol(HLT(0)) = LGreen
                        PltCol(HLT(1)) = mPurple
                        PltCol(HLT(2)) = mYellow
                    Else
                        Form1.Picture7.DrawWidth = 1
                        PltCol(HLT(0)) = Green
                        PltCol(HLT(1)) = Purple
                        PltCol(HLT(2)) = Yellow
                    End If
                    CUR = 0
'                    Do
'                        Form1.Picture7.ForeColor = PltCol(HLT(CUR))
'                        Y = HLT(CUR)
'                        Pict = Form1.Picture7.hDC
'
''                        MoveToEx Pict, (30 + Decompress((SSWinLen / 2)) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(0, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35))), PntAPI
'                        SPos = 1
'                        For X = SSStep + 1 To LSeq - SSWinLen Step SSStep
''                            LineTo Pict, (30 + Decompress((X + (SSWinLen / 2))) * xFactor), (PicHeight - (15 + ((ZPScoreHolder(SPos, Y) - ZMin) / (ZMax - ZMin)) * (PicHeight - 35)))
'                            SPos = SPos + 1
'                        Next X
'                        CUR = CUR + 1
'                        If CUR = 3 Then Exit Do
'                    Loop
                Next Z
            End If
        End If
    End If
    PltCol3(0) = RGB(64, 64, 64)
End If

If (SPF = 0 And UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
        PosCount = (Len(StrainSeq(0)) / SSStep) + SSWinLen
        NumLines = 25 'number of lines to print
        ReDim GPrint(NumLines - 1, PosCount + 1), GPrintPos(NumLines - 1, PosCount + 1)
    
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq
            If XDiffPos(x) > 0 Then
                GVarPos(0, x - 1) = (XDiffPos(x))
            Else
                Exit For
            End If
        Next x
        If x < 2 Then Exit Sub
        ReDim Preserve GVarPos(0, x - 2)
        ReDim GCritval(10)
        GCritval(4) = CriticalZ
        GCritval(5) = -CriticalZ
        GLegend = "Z - score"
        GPrintLen = PosCount + 1 'how many points to plot
        If x = x Then
            GPrintCol(0) = RGB(20, 20, 20)
            GPrintCol(1) = PltCol(2) '            RGB(CInt(BkR - BkR / 3), 0, CInt(BkB - BkB / 3))
            GPrintCol(2) = PltCol(3) ' RGB(0, CInt(BkG - BkG / 3), CInt(BkB - BkB / 3))
            GPrintCol(3) = RGB(40, 40, 40)
            GPrintCol(4) = PltCol(5) 'RGB(255, 215, 0)
            GPrintCol(5) = RGB(60, 60, 60)
            GPrintCol(6) = RGB(80, 80, 80)
            GPrintCol(7) = RGB(CInt(BkR - BkR / 4), 0, CInt(BkB - BkB / 2))
            GPrintCol(8) = RGB(0, CInt(BkG - BkG / 4), CInt(BkB - BkB / 2))
            GPrintCol(9) = RGB(255, 185, 0)
            GPrintCol(10) = RGB(100, 100, 100)
            GPrintCol(11) = RGB(120, 120, 120)
            GPrintCol(12) = RGB(140, 140, 140)
            GPrintCol(13) = RGB(160, 160, 160)
            GPrintCol(14) = RGB(180, 180, 180)
            GPrintCol(15) = RGB(CInt(BkR - BkR / 5), 0, CInt(BkB - BkB / 1.5))
            GPrintCol(16) = RGB(0, CInt(BkG - BkG / 5), CInt(BkB - BkB / 1.5))
            GPrintCol(17) = RGB(255, 145, 0)
            GPrintCol(18) = RGB(CInt(BkR - BkR / 6), 0, CInt(BkB - BkB / 1.25))
            GPrintCol(19) = RGB(0, CInt(BkG - BkG / 6), CInt(BkB - BkB / 1.25))
            GPrintCol(20) = RGB(200, 200, 200)
            GPrintCol(21) = RGB(255, 105, 0)
            GPrintCol(22) = RGB(220, 220, 220)
            GPrintCol(23) = RGB(240, 240, 240)
            GPrintCol(24) = RGB(198, 0, 0)
        End If
        
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        
        GPrintMin(0) = ZMin 'bottom val
        GPrintMin(1) = ZMax 'upper val
        
        
    
    
       'Exit Sub
        
        ReDim Preserve MCPrintPos(PosCount)
        For x = 0 To PosCount
            
            For Y = 0 To 24
                GPrintPos(Y, x + 1) = MCPrintPos(x)
            Next Y
        Next x
        
        For x = 0 To PosCount
            For Y = 1 To 15
                GPrint(Y - 1, x + 1) = MCPrintData(0, Y, x)
                
            Next Y
        Next x
        For x = 0 To PosCount
            For Y = 1 To 9
                GPrint(Y + 14, x + 1) = MCPrintData(1, Y, x)
                
            Next Y
        Next x
        For x = 0 To PosCount
            
                GPrint(24, x + 1) = 0
                
            
        Next x
        GPrintPos(24, 0) = 1
        GPrintPos(24, 1) = 1
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
    
    
        GExtraTNum = 23
        ReDim GExtraText(GExtraTNum)
        GExtraText(0) = "P1"
        GExtraText(1) = "P2 (" & OriginalName(tSeq2) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(2) = "P3 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(3) = "P4"
        GExtraText(4) = "P5 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq2) & ")"
        GExtraText(5) = "P6"
        GExtraText(6) = "P7"
        GExtraText(7) = "P8 (" & OriginalName(tSeq2) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(8) = "P9 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(9) = "P10 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq2) & ")"
        GExtraText(10) = "P11"
        GExtraText(11) = "P12"
        GExtraText(12) = "P13"
        GExtraText(13) = "P14"
        GExtraText(14) = "P15"
        GExtraText(15) = "S1 (" & OriginalName(tSeq2) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(16) = "S2 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(17) = "S3 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq2) & ")"
        GExtraText(18) = "S4 (" & OriginalName(tSeq2) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(19) = "S5 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq3) & ")"
        GExtraText(20) = "S6"
        GExtraText(21) = "S7 (" & OriginalName(tSeq1) & " - " & OriginalName(tSeq2) & ")"
        GExtraText(22) = "S8"
        GExtraText(23) = "S9"
        GExtraText(23) = ""
        
        
        
    End If

If BestRescanFlag = 0 Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
    Dim oOVS As Long
    oOVS = OVS
    OVS = 5
    Call RedrawPlotAA(1)
    OVS = oOVS
    If SPF = 0 And DontRedrawPlotsFlag = 0 Then Call PrintProbability
End If





If RelX > 0 Or RelY > 0 Then
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    If XoverList(RelX, RelY).ProgramFlag <> 5 And XoverList(RelX, RelY).ProgramFlag <> 5 + AddNum Then
        If Confirm(EN, 5) > 0 Then
            If Abs(ConfirmP(EN, 5)) < 300 Then
                PT = 10 ^ (-ConfirmP(EN, 5))
            Else
                PT = 10 ^ 300
            End If
        Else
            PT = 1
        End If
                
        If (Confirm(EN, 5) = 0 Or (Confirm(EN, 5) = 1 And MinPA < PT)) And MinPA < 1 Then
            Confirm(EN, 5) = 1
            ConfirmP(EN, 5) = -Log10(MinPA)
            

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            Form1.Refresh
            If DebuggingFlag < 2 Then
                Form1.WindowState = Form1.WindowState
            End If
        End If

    End If

End If

If MinPA < MinPA2 Then
    MinPAGlobal = MinPA
Else
    MinPAGlobal = MinPA2
End If


SSOutlyerFlag = ossoutlyerflag

Form1.Picture21.Width = Form1.Picture7.Width + 100
Form1.Picture21.Height = Form1.Picture7.Height + 100
Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5



Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
If SPF = 0 And UpdateProgressBar = 0 Then
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
    Form1.SSPanel1.Caption = ""
   ' Form1.ProgressBar1 = 0
End If
eeee = Abs(GetTickCount)
tttt = eeee - SSSS
'17859
'8000 - better nesting
'7890 'use of int s
x = x
End Sub


Public Sub BSXoverl(SPF)
    'Routine used to retrieve automated bootscan data from the file "RDP5BSScanData"
    If SPF = 1 Then Exit Sub
    Dim NumSets As Long, Y As Long, x As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long
    Dim oDir As String
    ProbabilityXOver = 100
    BSTypeFlag = pBSTypeFlag
    BSStepSize = pBSStepSize
    BSStepWin = pBSStepWin
    BSBootReps = pBSBootReps
    Form1.SSPanel1.Caption = "Retrieving Bootscan Data"
     If BestRescanFlag = 0 Then
        
        Form1.ProgressBar1.Value = 5
    End If
    Call UpdateF2Prog
    'Set appropriate directory location
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    oDir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    NumberOfSeqs = 0
    ReDim Preserve pMaskSeq(NextNo), SubMaskSeq(NextNo), RevSeq(NextNo)
    
        For x = 0 To NextNo

            If pMaskSeq(x) <= 1 Then
                SubMaskSeq(NumberOfSeqs) = x
                RevSeq(x) = NumberOfSeqs
                NumberOfSeqs = NumberOfSeqs + 1
                
            End If

        Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    NumSets = Int(Len(StrainSeq(0)) / BSStepSize) + 2
    ReDim PltPos(NumSets + 1)

    Dim NSets As Long

    NSets = NumSets - 1

    For Z = 0 To NSets
        PltPos(Z) = CLng(BSStepSize * Z)
    Next 'Z

    Dim FF As Integer

    FF = FreeFile
    Open BSFileName For Binary Access Read As #FF
    ReDim PltVal(2, NumSets)

    Dim t0() As Integer
    Dim T1() As Integer
    Dim T2() As Integer
    ReDim t0(BSBootReps * (NumSets + 1) - 1)
    ReDim T1(BSBootReps * (NumSets + 1) - 1)
    ReDim T2(BSBootReps * (NumSets + 1) - 1)
    'ReDim T0(BSBootReps - 1)
    'ReDim T1(BSBootReps - 1)
    'ReDim T2(BSBootReps - 1)
    Get #FF, (BSFilePos(TreeTrace(Seq1), TreeTrace(Seq2)) * BSBootReps * (NumSets) * 2 + 1), t0()
    Get #FF, (BSFilePos(TreeTrace(Seq1), TreeTrace(Seq3)) * BSBootReps * (NumSets) * 2 + 1), T1()
    Get #FF, (BSFilePos(TreeTrace(Seq2), TreeTrace(Seq3)) * BSBootReps * (NumSets) * 2 + 1), T2()
                                       
    For Y = 0 To NumSets
        'this coluld be speeded up with better nesting of if then's
        GetPltVal BSBootReps, Y, t0((Y) * BSBootReps), T1((Y) * BSBootReps), T2((Y) * BSBootReps), PltVal(0, 0)
        If BestRescanFlag = 0 Then
        
            Form1.ProgressBar1.Value = 5 + (Y / NumSets) * 80
            Call UpdateF2Prog
        End If
    Next 'Y
    

   ' For Y = 0 To NumSets
   '     Get #FF, BSFilePos(Seq1, Seq2) * BSRWSize + Y * BSWinRWChunk + 1, T0()
   '     Get #FF, BSFilePos(Seq1, Seq3) * BSRWSize + Y * BSWinRWChunk + 1, T1()
   '     Get #FF, BSFilePos(Seq2, Seq3) * BSRWSize + Y * BSWinRWChunk + 1, T2()
   '     GetPltVal BSBootReps, Y, T0(0), T1(0), T2(0), PltVal(0, 0)
   '     Form1.ProgressBar1.Value = 5 + (Y / NumSets) * 80
   ' Next 'Y

    Close #FF
    
    Call DrawBSPlotsII

    
    'PltVal(0, 16) = X
    Form1.SSPanel1.Caption = ""
    BSTypeFlag = xBSTypeFlag
    BSStepSize = xBSStepSize
    BSStepWin = xBSStepWin
    BSBootReps = xBSBootReps
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir$
    ChDrive oDir$
    On Error GoTo 0
End Sub
Public Sub DXoverB()


ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1

    Dim PosCount As Long, Counter As Long, Y As Long, x As Long
    Dim YScaleFactor As Double
    Dim Header As String, T As String

    Form1.ProgressBar1 = 10
    Call UpdateF2Prog
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
    Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the distance scan"
    Form1.SSPanel1.Caption = "Executing DNADist (Phylip)"
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    oDir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    Dim SeqLen As Long

    PosCount = 0

    Dim TempSeq() As String
    Dim Boots() As String
    Dim BootName() As String
    Dim PntAPI As POINTAPI

    SeqLen = Len(StrainSeq(0))
    Form1.Picture7.Enabled = True
    SeqLen = Len(StrainSeq(0))
    ReDim Boots(NextNo + 1)
    ReDim TempSeq(3)
    ReDim BootName(NextNo + 1)
    BootName(0) = "A0        "
    BootName(1) = "A1        "
    BootName(2) = "A2        "
    TempSeq(0) = StrainSeq(Seq1) + StrainSeq(Seq1)
    TempSeq(1) = StrainSeq(Seq2) + StrainSeq(Seq2)
    TempSeq(2) = StrainSeq(Seq3) + StrainSeq(Seq3)
    Counter = 0
    NumPerms = ((NextNo * (NextNo - 1) * (NextNo - 2)) / 2)

    Dim tBSResults() As Double

    ReDim tBSResults(2)

    Dim xtBSResults() As Long

    ReDim xtBSResults(2)

    Dim xxtBSResults() As Long

    ReDim xxtBSResults(2)

    If BSCCenterFlag = 1 And x = 12345 Then

        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Y = XoverList(RelX, RelY).Beginning + Int((XoverList(RelX, RelY).Ending - XoverList(RelX, RelY).Beginning) / 2)
            Y = Y + Int(DPWindow / 2)

            If Y > DPWindow Then

                Do
                    x = Y - DPWindow

                    If x < 1 Then
                        Exit Do
                    Else
                        Y = x
                    End If

                Loop

                Y = Y + DPWindow
                StartWin = Y
            Else
                Y = DPWindow
            End If

        Else
            Y = DPWindow
        End If

    Else
        Y = DPWindow
    End If

    Dim NoInfoFlag() As Integer

    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(2, Len(StrainSeq(0)))
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfile"
    Print #1, "rename outfile outfilex"
    Close #1
    KillFile "outfile"
    KillFile "outfilex"
    KillFile "infile"
    On Error GoTo 0
    
    Header$ = "   " + CStr(3) + "  " + CStr(DPWindow)
    'Close #1
    Open "infile" For Output As #1
    ReDim NoInfoFlag(3)
    Counter = 0

    Do While Y < SeqLen + Int(DPWindow / 2)
        Counter = Counter + 1
        Print #1, Header$

        For x = 0 To 2
            T$ = Mid$(TempSeq(x), Y - (DPWindow - 1), DPWindow)
            Boots(x) = BootName(x) + T$
            Print #1, Boots(x)
        Next 'X

        Y = Y + DPStep
        PosCount = PosCount + 1
    Loop

    Close #1
    Open "optfile" For Output As #1

    If DPModelFlag = 0 Then
        Print #1, "d"
        Print #1, "d"
        Print #1, "d"
    ElseIf DPModelFlag = 1 Then
    ElseIf DPModelFlag = 2 Then
        Print #1, "d"
    ElseIf DPModelFlag = 3 Then
        Print #1, "d"
        Print #1, "d"
    End If

    If DPModelFlag <> 0 Then
        Print #1, "t"
        Print #1, Trim$(CStr(DPTVRatio))
    Else
        Print #1, "t"
        Print #1, "0.5"
    End If

    If DPBFreqFlag <> 0 And DPModelFlag = 3 Then
        Print #1, "f"
        Print #1, Trim$(CStr(DPBFreqA)) & " " & Trim$(CStr(DPBFreqC)) & " " & Trim$(CStr(DPBFreqG)) & " " & Trim$(CStr(DPBFreqT))
    End If

    Print #1, "l"
    Print #1, "m"
    Print #1, Trim$(CStr(Counter))
    Print #1, "2"
    Print #1, "y"

    If DPModelFlag = 2 Then
        Print #1, DPCoeffVar
    End If

    Close #1
    ShellAndClose "dnadist.bat", 0
    Form1.ProgressBar1 = 60
    Call UpdateF2Prog
    Open "outfilex" For Binary Access Read As #1
    'Exit Sub

    If LOF(1) < 10 Then
        Close #1
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1.Value = 0
        Call UpdateF2Prog
        Form1.Picture10.Enabled = True
        Form1.Frame7.Enabled = True
        Form1.Picture23(1).Enabled = True
        Form1.SSPanel2.Enabled = True
        Form1.Picture8.Enabled = True
        Form1.Picture5.Enabled = True
        Form1.Command6(0).Enabled = True
        Form1.Command25.Enabled = False
        Form1.Command25.ToolTipText = ""
        Exit Sub
    End If

    Dim GetInteger As Integer
    Dim Getstring As String

    Getstring = String$(10, " ")

    For x = 0 To Counter - 1
        Input #1, GetInteger
        'Close #1
        'Exit Sub
        Input #1, Getstring
        Input #1, Getstring
        MCPrintPos(x) = x * DPStep + DPWindow / 2
        MCPrintData(0, x) = (CDbl(Right$(Getstring, 6)))
        Input #1, Getstring
        MCPrintData(1, x) = (CDbl(Mid$(Getstring, 13, 6)))
        MCPrintData(2, x) = (CDbl(Right$(Getstring, 6)))
    Next 'X

    Close #1
    Form1.ProgressBar1 = 80
    Call UpdateF2Prog
    MinDistX = 10
    MaxDistX = 0

    For x = 0 To 2

        For Y = 0 To Counter - 1

            If MCPrintData(x, Y) > MaxDistX Then

                If MCPrintData(x, Y) > 2 Then
                    MCPrintData(x, Y) = 2
                    MaxDistX = MCPrintData(x, Y)
                Else
                    MaxDistX = MCPrintData(x, Y)
                End If

            End If

        Next 'Y

    Next 'X

    Form1.Picture7.ScaleMode = 3

    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 0, CSng(MaxDistX), 0, "Distance")

    If CurrentCheck = 8 Then
        WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
        WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
        Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)

    End If

    Form1.Picture7.DrawWidth = 3

    For x = 0 To 2

        If x = 0 Then
            Form1.Picture7.ForeColor = LYellow
        ElseIf x = 1 Then
            Form1.Picture7.ForeColor = LGreen
        Else
            Form1.Picture7.ForeColor = LPurple
        End If

        MoveToEx Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI

        For Y = 1 To Counter - 1
            LineTo Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, Y) / MaxDistX)) * (PicHeight - 35))
        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    Call Highlight(0)

    For x = 0 To 2

        If x = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf x = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If

        MoveToEx Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI

        For Y = 1 To Counter - 1
            'Picture7.ForeColor = green
            LineTo Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, Y) / MaxDistX)) * (PicHeight - 35))
        Next 'Y

    Next 'X

    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    
    Call UpdateF2Prog
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
End Sub
Public Sub DXoverF()
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    SS = Abs(GetTickCount)

    Dim b As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    Dim btTempSeq2() As Integer
    Dim SP As Long, Pict As Long
    
    
    ReDim RevSeq(NextNo)
    
    NumberOfSeqs = 1
    For x = 0 To NextNo

        If Selected(x) = 1 Then
            RevSeq(NumberOfSeqs) = x
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X
    NumberOfSeqs = NumberOfSeqs - 1
    
    ReDim DstOut(0)
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, NumberOfSeqs)
    Y = Form5.Combo1.ListIndex - 1
    For x = 1 To LSeq
        TempSeq2(x, 0) = SeqNum(x, Y)
    Next
    
    Z = 1
    For Y = 0 To NextNo
        If Selected(Y) = 1 Then
            For x = 1 To LSeq
                TempSeq2(x, Z) = SeqNum(x, Y)
            Next
            Z = Z + 1
        End If
    Next
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
     
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the distance scan"
    Form1.SSPanel1.Caption = "Plotting Distances"
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(DPWindow)
    ReDim Prod2(DPWindow)
    ReDim Prod3(DPWindow)
    ReDim Alias(DPWindow)
    ReDim Ally(DPWindow)
    ReDim Location(DPWindow)
    ReDim Px(NumberOfSeqs, DPWindow)
    ReDim TTempSeq2(DPWindow, NumberOfSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim num(1)
    ReDim WeightMod(0, DPWindow - 1)
    ReDim tMat(NumberOfSeqs, NumberOfSeqs)
    
    For Y = 0 To 0

        For x = 1 To DPWindow
            WeightMod(Y, x - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / DPStep) + 2
    
    ReDim MCPrintPos(NumWins + 1)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        MCPrintPos(Z) = CLng(DPStep * Z)
    Next 'Z

    ReDim MCPrintData(NumberOfSeqs, NumWins)
    For b = 0 To NumWins
        
        MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), b, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
        
        ReDim btTempSeq2(DPWindow, NumberOfSeqs)
            
        x = 0
                
        For Z = 1 To DPWindow

            For Y = 0 To NumberOfSeqs
                btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
            Next 'Y

        Next 'Z

        ReDim Weight(0, DPWindow)
        ReDim tMat(NumberOfSeqs, NumberOfSeqs)
        DNADIST DPCoeffVar, DPTVRatio, DPBFreqFlag, DPModelFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT, NumberOfSeqs + 1, DPWindow, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

        For Z = 1 To NumberOfSeqs
            If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
            MCPrintData(Z, b) = tMat(0, Z)
            On Error GoTo 0
        Next
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6(0).Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        'If B / 5 = Int(B / 5) Then
        Form1.ProgressBar1 = (b / NumWins) * 100
        'End If
        Call UpdateF2Prog
        Form1.Refresh
        If DebuggingFlag < 2 Then
            Form1.WindowState = Form1.WindowState
        End If

        'Erase DstMat
    Next 'B

    MinDistX = 10
    MaxDistX = 0

    For x = 1 To NumberOfSeqs

        For Y = 0 To NumWins - 1

            If MCPrintData(x, Y) > MaxDistX And MCPrintData(x, Y) <> 10 Then

                If MCPrintData(x, Y) > 2 Then
                    MCPrintData(x, Y) = 2
                    MaxDistX = MCPrintData(x, Y)
                Else
                    MaxDistX = MCPrintData(x, Y)
                End If

            End If

        Next 'Y

    Next 'X
    smoothflag = 1
    If smoothflag = 1 Then
        Dim VarSiteSmooth2() As Single
        ReDim VarSiteSmooth2(NumberOfSeqs, NumWins + 10)
        Call SmoothIt2D(MCPrintData(), VarSiteSmooth2(), 1, NumWins - 1, 0, NumberOfSeqs)
        For Y = 0 To NumberOfSeqs
            For x = 1 To NumWins
                MCPrintData(Y, x) = VarSiteSmooth2(Y, x)
            Next x
        Next Y
    
    End If
    Form1.Picture7.ScaleMode = 3
    'MaxDistX = 0.05
    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 0, CSng(MaxDistX), 0, "Distance")
    'Call DoAxes(0, Len(strainseq(0)), -1,0, 0.05, 0, "RDP5Distance")

    Form1.Picture7.DrawWidth = 3
    
'    For X = 1 To NumberOfSeqs
'        Pict = Form1.Picture7.hDC
'        Form1.Picture7.ForeColor = FFillCol(RevSeq(X))
'        Dummy = MoveToEx(Pict, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)
'
'        For Y = 1 To NumWins - 1
'            'Picture7.ForeColor = green
'            If MCPrintPos(Y) <= UBound(Decompress, 1) Then
'                If MCPrintData(X, Y) > MaxDistX Then
'
'                ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
'                    MoveToEx Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
'                Else
'                    XX = UBound(Decompress, 1)
'                    LineTo Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
'                End If
'            End If
'        Next 'Y
'
'    Next 'X
'
'    Form1.Picture7.DrawWidth = 1

'    For X = 1 To NumberOfSeqs
'        Form1.Picture7.ForeColor = SeqCol(RevSeq(X))
'        Dummy = MoveToEx(Pict, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)
'
'        For Y = 1 To NumWins - 1
'            'Picture7.ForeColor = green
'            If MCPrintPos(Y) <= UBound(Decompress, 1) Then
'                If MCPrintData(X, Y) > MaxDistX Then
'
'                ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
'                    MoveToEx Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
'                Else
'                    LineTo Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
'                End If
'            End If
'        Next 'Y
'
'    Next 'X
    
    'Get everything into the standard format for printing and saving
    NumLines = NumberOfSeqs  'number of lines to print
    ReDim GPrint(NumLines - 1, NumWins + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, NumWins + 1)

    ReDim GVarPos(0, 0)
    
    ReDim GCritval(10)
    
    GLegend = "Distance"
    GPrintLen = NumWins + 1 'how many points to plot
    GPrintNum = NumLines - 1 'six lines
    GPrintType = 0 'a normal line plot
    
    GPrintMin(0) = MaxDistX  'bottom val
    GPrintMin(1) = 0 'upper val
    
    For x = 0 To NumWins
        For Y = 0 To NumLines - 1
            If MCPrintData(Y, x) <= GPrintMin(0) Then
                GPrint(Y, x + 1) = MCPrintData(Y + 1, x) - MaxDistX
                x = x
            Else
                GPrint(Y, x + 1) = GPrintMin(0)
                
            End If
            GPrintPos(Y, x + 1) = MCPrintPos(x)
            
        Next Y
    Next x
    
    
    For x = 0 To NumLines - 1
        GPrintPos(x, GPrintLen) = GPrintPos(x, GPrintLen - 1)
        
        GPrint(x, GPrintLen) = GPrint(x, GPrintLen - 1)
        GPrintPos(x, 0) = 1
        GPrint(x, 0) = GPrint(x, 1)
    Next x
    
    GBlockNum = 0
    ReDim GBlock(4, 0)
    GBlock(1, 0) = 3 'this is not actually a block - it is the legend saying which sequence is the query sequence
    For x = 0 To NumberOfSeqs - 1
        GPrintCol(x) = SeqCol(RevSeq(x + 1))
    Next x
    
    GExtraTNum = NumLines - 1
    ReDim GExtraText(GExtraTNum)
        
    For x = 1 To NumLines
        GExtraText(x - 1) = OriginalName(RevSeq(x))
    Next x
    
    Form1.Picture7.Refresh
    XX = Form1.Picture21.ScaleHeight
    
    dumx = 0
    For x = 0 To UBound(GPrint, 1)
        For Y = 0 To UBound(GPrint, 2)
            If GPrint(x, Y) > dumx Then dumx = GPrint(x, Y)
        Next Y
    Next x
    
    'XX = GPrint(2, 3)
    Form1.Picture7.DrawWidth = 1
    Call RedrawPlotAA(1)
    Form1.Picture21.Height = Form1.Picture7.Height + 50
    Form1.Picture21.Width = Form1.Picture7.Width + 50
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5

    EE = Abs(GetTickCount)
    TT = EE - SS
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
End Sub
Public Sub DXoverE()
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    SS = Abs(GetTickCount)

    Dim b As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    Dim btTempSeq2() As Integer
    Dim SP As Long

    ReDim DstOut(0)
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, 2)

    For x = 1 To LSeq
        TempSeq2(x, 0) = SeqNum(x, Seq1)
        TempSeq2(x, 1) = SeqNum(x, Seq2)
        TempSeq2(x, 2) = SeqNum(x, Seq3)
    Next
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
     
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the distance scan"
    Form1.SSPanel1.Caption = "Plotting Distances"
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(DPWindow)
    ReDim Prod2(DPWindow)
    ReDim Prod3(DPWindow)
    ReDim Alias(DPWindow)
    ReDim Ally(DPWindow)
    ReDim Location(DPWindow)
    ReDim Px(2, DPWindow)
    ReDim TTempSeq2(DPWindow, 2)
    ReDim DistVal(0 + 1)
    ReDim Num1(0 + 1)
    ReDim Num2(0 + 1)
    ReDim DEN(0 + 1)
    ReDim num(0 + 1)
    ReDim WeightMod(0, DPWindow - 1)
    ReDim tMat(2, 2)
    ReDim SHolder((3 + 1) * 40 * 2)

    For Y = 0 To 0

        For x = 1 To DPWindow
            WeightMod(Y, x - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / DPStep) + 2
    
    ReDim MCPrintPos(NumWins + 1)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        MCPrintPos(Z) = CLng(DPStep * Z)
    Next 'Z

    ReDim MCPrintData(2, NumWins)
    For b = 0 To NumWins
        
        MakeSubAlign 2, Len(StrainSeq(0)), b, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
        
        ReDim btTempSeq2(DPWindow, 2)
            
        x = 0
                
        For Z = 1 To DPWindow

            For Y = 0 To 2
                btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
            Next 'Y

        Next 'Z

        ReDim Weight(0, DPWindow)
        ReDim tMat(2, 2)
        DNADIST DPCoeffVar, DPTVRatio, DPBFreqFlag, DPModelFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT, 3, DPWindow, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

        MCPrintData(0, b) = tMat(0, 1)
        MCPrintData(1, b) = tMat(0, 2)
        MCPrintData(2, b) = tMat(1, 2)
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6(0).Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        'If B / 5 = Int(B / 5) Then
        Form1.ProgressBar1 = (b / NumWins) * 100
        'End If
        Call UpdateF2Prog
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        

        'Erase DstMat
    Next 'B

    MinDistX = 10
    MaxDistX = 0
    realmax = 0
    For x = 0 To 2

        For Y = 0 To NumWins - 1
            If MCPrintData(x, Y) > realmax Then
                realmax = MCPrintData(x, Y)
            End If
            If MCPrintData(x, Y) > MaxDistX And MCPrintData(x, Y) < 10 Then

                If MCPrintData(x, Y) > 2 Then
                    MCPrintData(x, Y) = 2
                    MaxDistX = MCPrintData(x, Y)
                Else
                    MaxDistX = MCPrintData(x, Y)
                End If

            End If

        Next 'Y

    Next 'X
    
    
    
    
    Form1.Picture7.ScaleMode = 3
    
    'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, 0, MaxDistX, 1, "Distance")

    If CurrentCheck = 8 Then
        WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
        WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
        Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)

    End If

    Form1.Picture7.DrawWidth = 3

    For x = 0 To 2

        If x = 0 Then
            Form1.Picture7.ForeColor = LYellow
        ElseIf x = 1 Then
            Form1.Picture7.ForeColor = LGreen
        Else
            Form1.Picture7.ForeColor = LPurple
        End If

'        MoveToEx Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(0)) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI
'
'        For Y = 1 To NumWins - 1
'            If MCPrintData(X, Y) > MaxDistX Then
'
'            ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
'                MoveToEx Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
'            Else
'                If MCPrintPos(Y) <= Len(StrainSeq(0)) Then
'                    LineTo Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
'                Else
'                    LineTo Form1.Picture7.hDC, 30 + Decompress(Len(StrainSeq(0))) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
'                End If
'            End If
'        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    Call Highlight(0)

    For x = 0 To 2

        If x = 0 Then
            Form1.Picture7.ForeColor = Yellow
        ElseIf x = 1 Then
            Form1.Picture7.ForeColor = Green
        Else
            Form1.Picture7.ForeColor = Purple
        End If

'        MoveToEx Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(0)) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI
'
'        For Y = 1 To NumWins - 1
'            If MCPrintData(X, Y) > MaxDistX Then
'
'            ElseIf MCPrintData(X, Y - 1) > MaxDistX Then
'                MoveToEx Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35)), PntAPI
'            Else
'                If MCPrintPos(Y) <= Len(StrainSeq(0)) Then
'                    LineTo Form1.Picture7.hDC, 30 + Decompress(MCPrintPos(Y)) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
'                Else
'                    LineTo Form1.Picture7.hDC, 30 + Decompress(Len(StrainSeq(0))) * xFactor, PicHeight - (15 + (1 - (MCPrintData(X, Y) / MaxDistX)) * (PicHeight - 35))
'                End If
'            End If
'        Next 'Y
'
    Next 'X
'
    
    'Get everything into the standard format for printing and saving
    NumLines = 3 'number of lines to print
    ReDim GPrint(NumLines - 1, NumWins + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, NumWins + 1)

    ReDim GVarPos(0, LenXoverSeq)
    For x = 1 To LenXoverSeq
        GVarPos(0, x) = XDiffPos(x)
        
    Next x
    ReDim GCritval(10)
    GCritval(0) = 0
    GLegend = "Distance"
    GPrintLen = NumWins + 1 'how many points to plot
    GPrintCol(0) = Yellow 'line is yellow
    GPrintCol(1) = Green 'line is green
    GPrintCol(2) = Purple ''line is purple
'    GPrintCol(3) = Yellow 'line is yellow
'    GPrintCol(4) = Green 'line is green
'    GPrintCol(5) = Purple ''line is purple
    GPrintNum = NumLines - 1 'six lines
    GPrintType = 0 'a normal line plot
    
    GPrintMin(0) = MaxDistX  'bottom val
    GPrintMin(1) = 0 'upper val
    
    For x = 0 To NumWins
        For Y = 0 To 2
            If MCPrintData(Y, x) <> 0 Then
                x = x
            End If
            If MCPrintData(Y, x) <= GPrintMin(0) Then
                GPrint(Y, x) = MCPrintData(Y, x) - MaxDistX
                'GPrint(Y + 3, X) = MCPrintData(Y, X) - MaxDistX
            Else
                GPrint(Y, x) = GPrintMin(0)
                'GPrint(Y + 3, X) = GPrintMin(0)
            End If
            GPrintPos(Y, x) = MCPrintPos(x)
            'GPrintPos(Y + 3, X) = MCPrintPos(X)
        Next Y
    Next x
    
    
'    For X = 0 To NumLines - 1
'        GPrintPos(X, GPrintLen) = GPrintPos(X, GPrintLen - 1)
'        GPrint(X, GPrintLen) = GPrint(X, GPrintLen - 1)
'        GPrintPos(X, 0) = 1
'        GPrint(X, 0) = GPrint(X, 1)
'    Next X
    
    
    Form1.Picture7.Refresh

    
    EE = Abs(GetTickCount)
    TT = EE - SS
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
    
    Call RedrawPlotAA(1)
    Form1.Picture7.Refresh
    
End Sub
Public Sub DXoverG()
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    SS = Abs(GetTickCount)

    Dim b As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim NumSp As Long, RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, TTempSeq2() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Integer
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer
    
    Dim TempSeq2() As Integer
    Dim PntAPI As POINTAPI
    Dim btTempSeq2() As Integer
    Dim SP As Long
    
    If Seq1 = Seq2 And Seq1 = Seq3 Then Exit Sub
    If Seq1 = NextNo + 1 Or Seq2 = NextNo + 1 Or Seq3 = NextNo + 1 Then Exit Sub
    
    ReDim DstOut(0)
    LSeq = Len(StrainSeq(0))
    ReDim TempSeq2(LSeq, 1)
    
    If Seq1 <> Seq2 Then
        For x = 1 To LSeq
            TempSeq2(x, 0) = SeqNum(x, Seq1)
            TempSeq2(x, 1) = SeqNum(x, Seq2)
        Next
    Else
        For x = 1 To LSeq
            TempSeq2(x, 0) = SeqNum(x, Seq1)
            TempSeq2(x, 1) = SeqNum(x, Seq3)
        Next
    End If
    
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
     
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the distance scan"
    Form1.SSPanel1.Caption = "Plotting Distances"
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(DPWindow)
    ReDim Prod2(DPWindow)
    ReDim Prod3(DPWindow)
    ReDim Alias(DPWindow)
    ReDim Ally(DPWindow)
    ReDim Location(DPWindow)
    ReDim Px(1, DPWindow)
    ReDim TTempSeq2(DPWindow, 1)
    ReDim DistVal(0 + 1)
    ReDim Num1(0 + 1)
    ReDim Num2(0 + 1)
    ReDim DEN(0 + 1)
    ReDim num(0 + 1)
    ReDim WeightMod(0, DPWindow - 1)
    ReDim tMat(1, 1)

    For Y = 0 To 0

        For x = 1 To DPWindow
            WeightMod(Y, x - 1) = 1
        Next 'X

    Next 'Y

    NumWins = Int(Len(StrainSeq(0)) / DPStep) + 2
    
    ReDim MCPrintPos(NumWins + 1)
    
    'Work out nt positions at the center of every window
    For Z = 0 To NumWins - 1
        MCPrintPos(Z) = CLng(DPStep * Z)
    Next 'Z

    ReDim MCPrintData(NumWins)
    For b = 0 To NumWins
        
        MakeSubAlign 1, Len(StrainSeq(0)), b, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
        
        ReDim btTempSeq2(DPWindow, 1)
            
        x = 0
                
        For Z = 1 To DPWindow

            For Y = 0 To 1
                btTempSeq2(Z, Y) = TTempSeq2(Z, Y)
            Next 'Y

        Next 'Z

        ReDim Weight(0, DPWindow)
        ReDim tMat(1, 1)
        DNADIST DPCoeffVar, DPTVRatio, DPBFreqFlag, DPModelFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT, 2, DPWindow, btTempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), tMat(0, 0)

        MCPrintData(b) = tMat(0, 1)
        
        If AbortFlag = 1 Then
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6(0).Enabled = True
            Exit Sub
        End If
        
        
        'Update progress indicaters
        'If B / 5 = Int(B / 5) Then
        Form1.ProgressBar1 = (b / NumWins) * 100
        'End If
        Call UpdateF2Prog
        Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

        'Erase DstMat
    Next 'B

    MinDistX = 10
    MaxDistX = 0

    

        For Y = 0 To NumWins - 1

            If MCPrintData(Y) > MaxDistX Then

                If MCPrintData(Y) > 2 Then
                    MCPrintData(Y) = 2
                    MaxDistX = MCPrintData(Y)
                Else
                    MaxDistX = MCPrintData(Y)
                End If

            End If

        Next 'Y

    Form1.Picture7.ScaleMode = 3
    
    Call FindSubSeqBSII
    
    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 0, CSng(MaxDistX), 1, "Distance")

    Form1.Picture7.DrawWidth = 3
    Form1.Picture7.ForeColor = RGB(168, 168, 168)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To NumWins - 1
        Dummy = LineTo(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To NumWins - 1
        Dummy = LineTo(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    'Next 'x

    Call Highlight(0)

    Form1.Picture7.Refresh

    
    EE = Abs(GetTickCount)
    TT = EE - SS
    '8.474 - Fel 100,20,10 d
    '0.892 - JC 100,20,10 d
    '0.988 - Kim 100,20,10 d
    '1.387 - Jin 100, 20, 10 d
    '76.235 - Fel 100,20,100 d
    '1.510 - JC 100,20,100 d
    '4.972 - Kim 100,20,100 d
    '8.446 - Jin 100, 20, 100 d
    '91.986 - Fel 100,20,100 n
    '15.992 - JC 100,20,100 n
    '20.174 - Kim 100,20,100 n
    '28.969 wo plot, 29.156 w plot
    '7875,8406,7859,8703
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
End Sub
Public Sub DXoverD()

ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1

    Dim Counter As Long, x As Long, PosCount As Long, Y As Long, Z As Long
    Dim YScaleFactor As Double
    Dim oDir As String, Header As String, T As String

    Form1.ProgressBar1 = 10
    Call UpdateF2Prog
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
     
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the distanec scan"
    Form1.SSPanel1.Caption = "Executing DNADist (Phylip)"
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    oDir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    Dim SeqLen As Long

    PosCount = 0

    Dim TempSeq() As String
    Dim Boots() As String
    Dim BootName() As String
    Dim PntAPI As POINTAPI

    SeqLen = Len(StrainSeq(0))
    Form1.Picture7.Enabled = True
    ReDim Boots(NextNo + 1)
    ReDim TempSeq(NextNo)
    ReDim BootName(NextNo + 1)
    ReDim RevSeq(NextNo + 1)
    TempSeq(0) = StrainSeq(Form5.Combo1.ListIndex - 1)
    NumberOfSeqs = 1

    For x = 0 To NextNo

        If Selected(x) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(x)
            RevSeq(NumberOfSeqs) = x
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X

    NumberOfSeqs = NumberOfSeqs - 1

    For x = 0 To NumberOfSeqs
        TempSeq(x) = Right$(TempSeq(x), DPWindow / 2 + 1) + TempSeq(x) + Left$(TempSeq(x), DPWindow / 2 + 1)
    Next 'X

    Counter = 0
    NumPerms = ((NextNo * (NextNo - 1) * (NextNo - 2)) / 2)

    Dim tBSResults() As Double

    ReDim tBSResults(2)

    Dim xtBSResults() As Long

    ReDim xtBSResults(2)

    Dim xxtBSResults() As Long

    ReDim xxtBSResults(2)
    'Dim DPStep As Integer
    Y = DPWindow

    Dim NoInfoFlag() As Integer

    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(NumberOfSeqs, Len(StrainSeq(0)))
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfile"
    Print #1, "rename outfile outfilex"
    Close #1
    KillFile "outfile"
    KillFile "outfilex"
    KillFile "infile"
    On Error GoTo 0
    
    Header$ = "   " + CStr(NumberOfSeqs + 1) + "  " + CStr(DPWindow)
    
    'Close #1
    Open "infile" For Output As #1
    ReDim NoInfoFlag(NextNo)
    Counter = 0

    Do While Y < SeqLen + DPWindow
        Counter = Counter + 1
        Print #1, Header$

        For x = 0 To NumberOfSeqs
            BootName(x) = "A" & Trim$(CStr(x))
            BootName(x) = BootName(x) + String$(10 - (Len(BootName(x))), " ")
            T$ = Mid$(TempSeq(x), Y - (DPWindow - 1), DPWindow)
            Boots(x) = BootName(x) + T$
            Print #1, Boots(x)
        Next 'X

        Y = Y + DPStep
        PosCount = PosCount + 1
    Loop

    Close #1
    Open "optfile" For Output As #1

    If DPModelFlag = 0 Then
        Print #1, "d"
        Print #1, "d"
        Print #1, "d"
    ElseIf DPModelFlag = 1 Then
    ElseIf DPModelFlag = 2 Then
        Print #1, "d"
    ElseIf DPModelFlag = 3 Then
        Print #1, "d"
        Print #1, "d"
    End If

    If DPModelFlag <> 0 Then
        Print #1, "t"
        Print #1, Trim$(CStr(DPTVRatio))
    Else
        Print #1, "t"
        Print #1, "0.5"
    End If

    If DPBFreqFlag <> 0 And DPModelFlag = 3 Then
        Print #1, "f"
        Print #1, Trim$(CStr(DPBFreqA)) & " " & Trim$(CStr(DPBFreqC)) & " " & Trim$(CStr(DPBFreqG)) & " " & Trim$(CStr(DPBFreqT))
    End If

    Print #1, "l"
    Print #1, "m"
    Print #1, Trim$(CStr(Counter))
    Print #1, "2"
    Print #1, "y"

    If DPModelFlag = 2 Then
        Print #1, DPCoeffVar
    End If

    Close #1
    ShellAndClose "dnadist.bat", 0
    Form1.ProgressBar1 = 60
    Call UpdateF2Prog
    Open "outfilex" For Binary Access Read As #1
    'Exit Sub

    Dim GetInteger As Integer
    Dim Getstring As String

    Getstring = String$(10, " ")

    For x = 0 To Counter - 1
        Input #1, GetInteger
        Input #1, Getstring
        Input #1, Getstring
        MCPrintPos(x) = x * DPStep '+ DPWindow / 2 - dpeindow
        MCPrintData(1, x) = (CDbl(Right$(Getstring, 6)))

        For Z = 2 To NumberOfSeqs
            Input #1, Getstring
            MCPrintData(Z, x) = (CDbl(Mid$(Getstring, 13, 6)))
            'MCPrintData(2, X) = (CDbl(Right$(GetString, 6)))
        Next 'Z

    Next 'X

    Close #1
    Form1.ProgressBar1 = 80
    Call UpdateF2Prog
    MinDistX = 10
    MaxDistX = 0

    For x = 1 To NumberOfSeqs

        For Y = 0 To Counter - 1

            If MCPrintData(x, Y) > MaxDistX Then

                If MCPrintData(x, Y) > 2 Then
                    MCPrintData(x, Y) = 2
                    MaxDistX = MCPrintData(x, Y)
                Else
                    MaxDistX = MCPrintData(x, Y)
                End If

            End If

        Next 'Y

    Next 'X

    Form1.Picture7.ScaleMode = 3
    Form1.Picture10.BackColor = BackColours
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3

    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 0, CSng(MaxDistX), 0, "Distance")

    Form1.Picture7.DrawWidth = 3

    For x = 1 To NumberOfSeqs
        Form1.Picture7.ForeColor = FFillCol(RevSeq(x))
        Dummy = MoveToEx(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

        For Y = 1 To Counter - 1
            'Picture7.ForeColor = green
            Dummy = LineTo(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, Y) / MaxDistX)) * (PicHeight - 35)))
        Next 'Y

    Next 'X

    Form1.Picture7.DrawWidth = 1

    For x = 1 To NumberOfSeqs
        Form1.Picture7.ForeColor = SeqCol(RevSeq(x))
        Dummy = MoveToEx(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, 0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

        For Y = 1 To Counter - 1
            'Picture7.ForeColor = green
            Dummy = LineTo(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(x, Y) / MaxDistX)) * (PicHeight - 35)))
        Next 'Y

    Next 'X

    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Call UpdateF2Prog
    Form1.Picture21.Width = Form1.Picture7.Width + 100
Form1.Picture21.Height = Form1.Picture7.Height + 100
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub
Public Sub DXoverC()

ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1

    Dim YScaleFactor As Double
    Dim PosCount As Long, x As Long, Counter As Long, Y As Long
    Dim Header As String, T As String

    Form1.ProgressBar1 = 10
    Call UpdateF2Prog
    If Seq1 = Seq2 And Seq1 = Seq3 Then Exit Sub

    If Seq1 = NextNo + 1 Or Seq2 = NextNo + 1 Or Seq3 = NextNo + 1 Then Exit Sub
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
   
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the distance scan"
    Form1.SSPanel1.Caption = "Executing DNADist (Phylip)"
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next

    oDir$ = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    Dim SeqLen As Long

    PosCount = 0

    Dim TempSeq() As String
    Dim Boots() As String
    Dim BootName() As String
    Dim PntAPI As POINTAPI

    SeqLen = Len(StrainSeq(0))
    Form1.Picture7.Enabled = True
    SeqLen = Len(StrainSeq(0))
    ReDim Boots(NextNo + 1)
    ReDim TempSeq(2)
    ReDim BootName(NextNo + 1)
    BootName(0) = "A0        "
    BootName(1) = "A1        "
    'BootName(2) = "A2        "

    If Seq1 <> Seq2 Then
        TempSeq(0) = StrainSeq(Seq1)
        TempSeq(1) = StrainSeq(Seq2)
    Else
        TempSeq(0) = StrainSeq(Seq1)
        TempSeq(1) = StrainSeq(Seq3)
    End If

    '   TempSeq(2) = StrainSeq(Seq3)
    'replace . with -

    For x = 0 To 1
        Pos = 0

        Do
            Pos = InStr(Pos + 1, TempSeq(x), ".", vbBinaryCompare)

            If Pos > 0 Then
                Mid$(TempSeq(x), Pos, 1) = "-"
            Else
                Exit Do
            End If

        Loop

    Next 'X

    For x = 0 To 1
        Pos = 0

        Do
            Pos = InStr(Pos + 1, TempSeq(x), "*", vbBinaryCompare)

            If Pos > 0 Then
                Mid$(TempSeq(x), Pos, 1) = "-"
            Else
                Exit Do
            End If

        Loop

    Next 'X

    TempSeq(0) = TempSeq(0) + TempSeq(0)
    TempSeq(1) = TempSeq(1) + TempSeq(1)
    'TempSeq(2) = TempSeq(2) + TempSeq(2)
    Counter = 0
    NumPerms = ((NextNo * (NextNo - 1) * (NextNo - 2)) / 2)

    Dim tBSResults() As Double

    ReDim tBSResults(2)

    Dim xtBSResults() As Long

    ReDim xtBSResults(2)

    Dim xxtBSResults() As Long

    ReDim xxtBSResults(2)
    'Dim DPStep As Integer

    If BSCCenterFlag = 1 And x = 12345 Then

        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            Y = XoverList(RelX, RelY).Beginning + Int((XoverList(RelX, RelY).Ending - XoverList(RelX, RelY).Beginning) / 2)
            Y = Y + Int(DPWindow / 2)

            If Y > DPWindow Then

                Do
                    x = Y - DPWindow

                    If x < 1 Then
                        Exit Do
                    Else
                        Y = x
                    End If

                Loop

                Y = Y + DPWindow
                StartWin = Y
            Else
                Y = DPWindow
            End If

        Else
            Y = DPWindow
        End If

    Else
        Y = DPWindow
    End If

    Dim NoInfoFlag() As Integer

    ReDim MCPrintPos(Len(StrainSeq(0)))
    ReDim MCPrintData(Len(StrainSeq(0)))
    
    If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfile"
    Print #1, "rename outfile outfilex"
    Close #1
    KillFile "outfile"
    KillFile "outfilex"
    KillFile "infile"
    On Error GoTo 0
    
    
    Header$ = "   " + CStr(2) + "  " + CStr(DPWindow)
    'Close #1
    Open "infile" For Output As #1
    ReDim NoInfoFlag(3)
    Counter = 0

    Do While Y < SeqLen + Int(DPWindow / 2)
        Counter = Counter + 1
        Print #1, Header$

        For x = 0 To 1
            T$ = Mid$(TempSeq(x), Y - (DPWindow - 1), DPWindow)
            Boots(x) = BootName(x) + T$
            Print #1, Boots(x)
        Next 'X

        Y = Y + DPStep
        PosCount = PosCount + 1
    Loop

    Close #1
    Open "optfile" For Output As #1

    If DPModelFlag = 0 Then
        Print #1, "d"
        Print #1, "d"
        Print #1, "d"
    ElseIf DPModelFlag = 1 Then
    ElseIf DPModelFlag = 2 Then
        Print #1, "d"
    ElseIf DPModelFlag = 3 Then
        Print #1, "d"
        Print #1, "d"
    End If

    If DPModelFlag <> 0 Then
        Print #1, "t"
        Print #1, Trim$(CStr(DPTVRatio))
    Else
        Print #1, "t"
        Print #1, "0.5"
    End If

    If DPBFreqFlag <> 0 And DPModelFlag = 3 Then
        Print #1, "f"
        Print #1, Trim$(CStr(DPBFreqA)) & " " & Trim$(CStr(DPBFreqC)) & " " & Trim$(CStr(DPBFreqG)) & " " & Trim$(CStr(DPBFreqT))
    End If

    Print #1, "l"
    Print #1, "m"
    Print #1, Trim$(CStr(Counter))
    Print #1, "2"
    Print #1, "y"

    If DPModelFlag = 2 Then Print #1, DPCoeffVar
    Close #1
    ShellAndClose "dnadist.bat", 0
    Form1.ProgressBar1 = 60
    Call UpdateF2Prog
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        Close #1
        Exit Sub
    End If

    'Exit Sub

    Dim GetInteger As Integer
    Dim Getstring As String

    Getstring = String$(10, " ")
    CurPos = 1

    For x = 0 To Counter - 1
        Input #1, GetInteger
        Input #1, Getstring
        Input #1, Getstring
        MCPrintPos(x) = x * DPStep + DPWindow / 2
        MCPrintData(x) = (CDbl(Right$(Getstring, 6)))
    Next 'X

    Close #1
    Form1.ProgressBar1 = 80
    Call UpdateF2Prog
    MinDistX = 10
    MaxDistX = 0

    For Y = 0 To Counter - 1

        If MCPrintData(Y) > MaxDistX Then

            If MCPrintData(Y) > 2 Then
                MCPrintData(Y) = 2
                MaxDistX = MCPrintData(Y)
            Else
                MaxDistX = MCPrintData(Y)
            End If

        End If

    Next 'Y

    Form1.Picture7.ScaleMode = 3

    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 0, CSng(MaxDistX), 0, "Distance")

    Form1.Picture7.DrawWidth = 3
    Form1.Picture7.ForeColor = RGB(168, 168, 168)
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To Counter - 1
        'Picture7.ForeColor = green
        Dummy = LineTo(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    Form1.Picture7.DrawWidth = 1
    'For x = 0 To 1
    ' If x = 0 Then
    Form1.Picture7.ForeColor = RGB(0, 0, 0)
    ' ElseIf x = 1 Then
    '     Form1.Picture7.ForeColor = RGB(128, 0, 128)
    'Else
    '    Form1.Picture7.ForeColor = RGB(0, 128, 128)
    'End If
    Dummy = MoveToEx(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(0)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(0) / MaxDistX)) * (PicHeight - 35)), PntAPI)

    For Y = 1 To Counter - 1
        'Picture7.ForeColor = green
        Dummy = LineTo(Form1.Picture7.hdc, 30 + Decompress(MCPrintPos(Y)) * XFactor, PicHeight - (15 + (1 - (MCPrintData(Y) / MaxDistX)) * (PicHeight - 35)))
    Next 'Y

    'Next 'x

    Call Highlight(0)

    Form1.Picture7.Refresh
    Form1.ProgressBar1 = 100
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
End Sub

Public Sub DoCols()
    ReDim SeqCol(NextNo + 1)
    ReDim FFillCol(NextNo + 1)
    

Exit Sub
    Dim OddF As Long
    Dim HowClose As Integer, BColor As Integer, RColor As Integer, GColor As Integer

    HowClose = 4

    Dim x As Integer
    Dim TX As Integer

    If NextNo / 2 = Int(NextNo / 2) Then
        OddF = 0
    Else
        OddF = 1
    End If

    For x = 0 To NextNo + 1
        TX = x

        If TX / 3 = Int(TX / 3) Then
            RColor = Int(((TX + 1) / ((NextNo + 1) / 2) - Int((TX + 1) / ((NextNo + 1) / 2))) * 255)
            GColor = Int(((TX + 1) / 3.46 - Int((TX + 1) / 3.46)) * 255)

            If TX <= NextNo / 2 Then
                BColor = Int((128 / (NextNo + 1)) * (TX + 1))
            Else
                BColor = Int(128 + ((128 / (NextNo + 1)) * (TX + 1)))
            End If

        ElseIf TX / 2 = Int(TX / 2) Then

            If TX <= NextNo / 2 Then
                RColor = Int((128 / (NextNo + 1)) * (TX + 1))
            Else
                RColor = Int(128 + ((128 / (NextNo + 1)) * (TX + 1)))
            End If

            GColor = Int(((TX + 1) / ((NextNo + 1) / 2) - Int((TX + 1) / ((NextNo + 1) / 2))) * 255)
            BColor = Int(((TX + 1) / 3.46 - Int((TX + 1) / 3.46)) * 255)
        Else

            If TX <= NextNo / 2 Then
                GColor = Int((128 / (NextNo + 1)) * (TX + 1))
            Else
                GColor = Int(128 + ((128 / (NextNo + 1)) * (TX + 1)))
            End If

            BColor = Int(((TX + 1) / ((NextNo + 1) / 2) - Int((TX + 1) / ((NextNo + 1) / 2))) * 255)
            RColor = Int(((TX + 1) / 3.46 - Int((TX + 1) / 3.46)) * 255)
            'BColor = Int(((Nextno - TX) / ((Nextno + 1) / 2) - Int((Nextno - TX) / ((Nextno + 1) / 2))) * 255)
            'RColor = Int(((Nextno - TX) / 3.46 - Int((Nextno - TX) / 3.46)) * 255)
        End If

        If ((Abs(RColor - 196) + Abs(GColor - 196) + Abs(BColor - 196)) / HowClose) < 30 Then

            If RColor < 196 Then
                RColor = RColor - 120

                If RColor < 0 Then RColor = 255 + RColor
            Else
                RColor = RColor + 120

                If RColor > 255 Then RColor = RColor - 255
            End If

            If GColor < 196 Then
                GColor = GColor - 120

                If GColor < 0 Then GColor = 255 + GColor
            Else
                GColor = GColor + 120

                If GColor > 255 Then GColor = GColor - 255
            End If

            If BColor < 196 Then
                BColor = BColor - 120

                If BColor < 0 Then BColor = 255 + BColor
            Else
                BColor = BColor + 120

                If BColor > 255 Then BColor = BColor - 255
            End If

        End If

        SeqCol(x) = RGB(RColor, GColor, BColor) '11,73,2

        If RColor > 196 Then
            RColor = CInt(((RColor - 196) / HowClose) + 196)
        Else
            RColor = 196 - CInt(((196 - RColor) / HowClose))
        End If

        If GColor > 196 Then
            GColor = CInt(((GColor - 196) / HowClose) + 196)
        Else
            GColor = 196 - CInt(((196 - GColor) / HowClose))
        End If

        If BColor > 196 Then
            BColor = CInt(((BColor - 196) / HowClose) + 196)
        Else
            BColor = 196 - CInt(((196 - BColor) / HowClose))
        End If

        RColor = RColor + (BkR - RColor) / 2
        GColor = GColor + (BkG - GColor) / 2
        BColor = BColor + (BkB - BColor) / 2
        FFillCol(x) = RGB(RColor, GColor, BColor)
    Next 'X

End Sub
Public Sub DoAxes2(UValA As Single, LValA As Single, UValB As Single, LValB As Single, UValC As Long, LValC As Long, DDFlag As Byte, XLegendA As String, XLegendB As String, XLegendC As String)

    Dim CCX As Long, MFactor As Double
    Dim PartNumber As Integer
    Dim Outnum As Double, SOutNum As String, TH As Long
    Dim StartY As Integer
    Dim YE As Long, YS As Long, OPicheight As Long
    
    On Error GoTo DontBother
    If UBound(PDistPlt, 1) < UPArrayDim1 + 10 Then
        ReDim PDistPlt(UPArrayDim1 + 10, AddNum)
        ReDim ProbPlt(UPArrayDim1 + 10, AddNum)
        ReDim HitPlt(UPArrayDim1 + 10, AddNum)
        ReDim Hitnumber(Len(StrainSeq(0)) + 10)
    Else
        UB = UBound(PDistPlt, 1)
        ReDim PDistPlt(UB, AddNum)
        ReDim ProbPlt(UB, AddNum)
        ReDim HitPlt(UB, AddNum)
        ReDim Hitnumber(UB)
    End If
    On Error GoTo 0
    'XX = Form1.Picture7.Height
    Form1.Picture7.AutoRedraw = True
    Form1.Picture10.AutoRedraw = True
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.BackColor = BackColours
    Form1.Picture10.ScaleMode = 3
    Form1.Picture7.ScaleMode = 3
    Form1.Picture7.Picture = LoadPicture()
    Form1.Picture7.ForeColor = QBColor(0)

    If ORFFlag = 0 Then
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = 0
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
        Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
    End If

    Dim YScaleFactor As Double

    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    OPicheight = PicHeight
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    TH = Form1.Picture7.TextHeight("0")
    'Form1.Frame17.Visible = False
    PartNumber = (PicHeight / 3 - 35) / (TH * 3)

    If PartNumber < 3 Then PartNumber = 3

    Dim P1 As Long, P2 As Long, P3 As Long, P4 As Long

    StartY = 15
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10

    If DDFlag = 1 Then
        'shade detected region

        Call Highlight(0)

    End If

    Form1.Picture7.Line (25, P1)-(25, P4), QBColor(0)
    Form1.Picture7.Line (25, P2)-(Form1.Picture7.ScaleWidth - 5, P2), QBColor(0)
    Form1.Picture7.Line (25, P3)-(Form1.Picture7.ScaleWidth - 5, P3), QBColor(0)
    Form1.Picture7.Line (25, P4)-(Form1.Picture7.ScaleWidth - 5, P4), QBColor(0)
    'Y axis tick marks

    Dim YIncriment As Double

    'YIncriment = ((PicHeight - StartY - 10 - 25) / 3) / (PartNumber - 1)
    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (PartNumber - 1))

    Dim Z As Integer
    Dim Y As Long

    
    For Z = 0 To 2
        YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
        YS = CLng(YE + YIncriment * (PartNumber - 1))
        If YIncriment <> 0 Then
            For Y = YE To YS Step YIncriment
                Form1.Picture7.Line (25, Y)-(28, Y), QBColor(0)
            Next 'Y
        End If

    Next 'Z

    'X-Axis tick marks

    For Z = 0 To 2
        Y = StartY + ((PicHeight - 10 - StartY) / 3) + ((PicHeight - 10 - StartY) / 3) * Z
        Form1.Picture7.Line (30, Y)-(30, Y - 3), QBColor(0)
        Form1.Picture7.Line (Form1.Picture7.ScaleWidth - 10, Y)-(Form1.Picture7.ScaleWidth - 10, Y - 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, Y)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, Y - 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, Y)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, Y - 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, Y)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, Y - 3), QBColor(0)
    Next 'Z

    Dim XVal As String

    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentY = 14
    Form1.Picture7.CurrentX = 7
    MFactor = 1

    Dim x As Integer
    Dim UVal As Double, LVal As Double

    x = 0

    For Z = 0 To 2
        x = 0

        If Z = 0 Then
            UVal = UValA
            LVal = LValA
        ElseIf Z = 1 Then
            UVal = UValB
            LVal = LValB
        Else
            UVal = UValC
            LVal = LValC
        End If

        MFactor = 1
        YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
        YS = CLng(YE + YIncriment * (PartNumber - 1))

        For Y = YS To YE Step -(YIncriment)
            Outnum = (LVal + (UVal - LVal) * (x / (PartNumber - 1))) * MFactor

            If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then

                If LVal * 1000 > UVal Then
                    MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                    XLegendA = XLegendA + " (x " & Trim$(CStr(MFactor)) & ")"
                    Outnum = Outnum * MFactor
                Else
                    Outnum = 0
                End If

            End If

            SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
            'Exit Sub
            Outnum = (CLng(Outnum * 100)) / 100
            'If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = "0" & SOutNum

            If Outnum = Int(Outnum) Then SOutNum = SOutNum + ".0"

            If Outnum >= 100 And Outnum < 1000 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                SOutNum = " " & Trim$(CStr(Int(CDbl(SOutNum))))
                SOutNum = " " & Trim$(CStr(Int(val(SOutNum))))
                On Error GoTo 0
            End If

            If Len(SOutNum) < 4 Then
                SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 4 Then
                SOutNum = Left$(SOutNum, 4)
            End If

            Form1.Picture7.CurrentY = CLng(Y - TH / 2)
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            x = x + 1
            If x > 32000 Then Exit Sub
        Next 'Y

    Next 'Z
    If CurrentlyRunningFlag = 0 Then
        Form1.Picture10.Enabled = True
    End If
    Form1.Picture10.Picture = LoadPicture()
    Form1.Picture10.CurrentX = 5
    Form1.Picture10.FontSize = 6

    Dim TW As Integer

    Form1.Picture10.CurrentX = 2
    TW = Form1.Picture7.TextWidth(XLegendA)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + P1 + TW + (P2 - P1 - TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegendA, 90)

    Form1.Picture10.CurrentX = 2
    TW = Form1.Picture7.TextWidth(XLegendB)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + P2 + TW + (P3 - P2 - TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegendB, 90)

    Form1.Picture10.CurrentX = 2
    TW = Form1.Picture7.TextWidth(XLegendC)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + P3 + TW + (P4 - P3 - TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegendC, 90)

    'YScaleFactor = 0.85
    '
    'Form1.Picture7.CurrentX = 30
    'Form1.Picture7.CurrentY = Form1.Picture7.Height * (YScaleFactor + 0.08)
    Form1.Picture7.CurrentY = PicHeight - 9
    Form1.Picture7.CurrentX = 29
    Form1.Picture7.Print "1"
    
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = CLng(Decompress(Len(StrainSeq(0))) / 2)
    Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2 - (((Len(XVal) + 1) / 2) * 5.5)
    CCX = Form1.Picture7.CurrentX + Form1.Picture7.TextWidth(Trim(Str(CLng(Decompress(Len(StrainSeq(0))) / 2))))
    Form1.Picture7.Print (Trim(Str(CLng(Decompress(Len(StrainSeq(0))) / 2))))
    
    Form1.Picture7.CurrentY = PicHeight - 9
    XVal = CLng(Decompress(Len(StrainSeq(0))))
    Form1.Picture7.CurrentX = Form1.Picture7.ScaleWidth - 10 - (Len(XVal) - 1) * 5.5
    CCX = Form1.Picture7.CurrentX - CCX
    Form1.Picture7.Print Decompress(Len(StrainSeq(0)))
    
    If CCX > Form1.Picture7.TextWidth(Trim(Str(CLng(Len(StrainSeq(0)) / 1.33333)))) Then
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = CLng(Decompress(Len(StrainSeq(0))) / 1.333)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333 - (((Len(XVal) + 1) / 2) * 5.5)
        Form1.Picture7.Print CLng(Decompress(Len(StrainSeq(0))) / 1.3333)
        Form1.Picture7.CurrentY = PicHeight - 9
        
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = CLng(Decompress(Len(StrainSeq(0))) / 4)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4 - ((Len(XVal) + 1) / 2) * 5.5
        Form1.Picture7.Print CLng(Decompress(Len(StrainSeq(0))) / 4)
    End If
    '25, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 5
    Form1.Picture7.CurrentY = PicHeight
    Form1.Picture7.CurrentX = 25 + (Form1.Picture7.ScaleWidth - 30 - Form1.Picture7.TextWidth("Position in alignment")) / 2
    Form1.Picture7.Print "Position in alignment"
    'If TManFlag > -1 Then
    '    If XOverList(RelX, RelY).SBPFlag < 3 And XOverList(RelX, RelY).ProgramFlag <> 1 And XOverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
    '        Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    '    End If
    'End If
    Form1.Picture7.Enabled = True

    If ORFFlag = 0 Then
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = 0
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
        Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
        Form1.Picture20.Visible = True
    End If
    
Exit Sub
DontBother:
ShowPlotFlag = 0

End Sub
Public Sub DoAxes(CAFlag, APF, LSx, AN, UVal As Single, LVal As Single, DDFlag As Byte, XLegend As String)
    'Draws axes for many of the graphs that appear in the plot display.

    Dim OSM As Long, YX As Long, StepX As Long, SP As Long, EP As Long, Z As Long, Dummy As Long, Height As Long, UB As Long, Outnum As Variant, MFactor As Double, YIncriment As Double
    Dim YS As Long, YE As Long, TH As Long, Pict As Long
    Dim PartNumber As Integer, Y As Long, x As Integer, TW As Integer
    Dim SOutNum As String, XVal As String, DLSx
    GYAxHi(1) = LSx
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(CurveArray, 1)
    If UB < LSx Then
        Call MakeCurveArray(0)
        
    End If
    
'    UB = -1
'    UB = UBound(XDiffPos, 1)
'    If UB = -1 Then
'        ReDim XDiffPos(LSx + 1000)
'        UB = LSx + 1000
'        For X = 0 To UB
'            XDiffPos(X) = X * CurveArray(X)
'        Next X
'    ElseIf UB < LSx + 1000 Then
'        For X = 0 To UB
'            XDiffPos(X) = Decompress(XDiffPos(X)) * CurveArray(X)
'        Next X
'    End If
    On Error GoTo 0
    
    'Prepare the pictureboxes in the plot display
    DLSx = LSx 'Decompress(LSx)
    With Form1.Picture10
        .AutoRedraw = True
        .BackColor = BackColours
        .ScaleMode = 3
        .Picture = LoadPicture()
        .ForeColor = QBColor(0)
    End With

    With Form1.Picture7
        .AutoRedraw = True
        .BackColor = BackColours
        .ScaleMode = 3
        .Picture = LoadPicture()
        .ForeColor = QBColor(0)

        If ORFFlag = 0 Then
            Height = Form1.Picture10.ScaleHeight
            .Top = 0
        Else
            '@
            .Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
            .Top = Form1.Picture20.ScaleHeight - 5
        End If

    End With

    Dim YScaleFactor As Double

    'Set up some scaling variables
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / LSx)
    '@
    TH = Form1.Picture7.TextHeight("0")
    'If necessary draw an indicator of the variable sites used to make the plots
    
    If DDFlag = 1 Then
        'Form1.Picture7.DrawMode = 7
        'Form1.Picture7.ForeColor = BackColours
        'Pict = Form1.Picture7.hdc
        'Dummy = DrawDiffs(Pict, LenXoverSeq, XFactor, XDiffPos(0))
        'Form1.Picture7.DrawMode = 15
        'Form1.Picture7.ForeColor = RGB(128, 128, 128)
        'Pict = Form1.Picture7.hdc
        'Dummy = DrawDiffs(Pict, LenXoverSeq, XFactor, XDiffPos(0))
        'Form1.Picture7.DrawMode = 5
        'Form1.Picture7.ForeColor = RGB(128, 128, 128)
        Pict = Form1.Picture7.hdc
       ' XFactor = XFactor * 2
        'XDiffPos(10) = XDiffPos(13)
        'XDiffPos(11) = XDiffPos(14)
        'XDiffPos(21) = 3000 'XDiffpos(15)
        'XX = XDiffPos(21)
        'LenXOverSeq = 29
        'XFactor = XFactor * 2
        
        
        If CAFlag = 1 Then
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                Dummy = DrawDiffs(Pict, LenXoverSeq, XFactor, XDiffPosCA(0))
            Else
                Call DrawDiffsVB(Pict, LenXoverSeq, XFactor, XDiffPosCA())
            End If
        Else
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                Dummy = DrawDiffs(Pict, LenXoverSeq, XFactor, XDiffPos(0))
            Else
                Call DrawDiffsVB(Pict, LenXoverSeq, XFactor, XDiffPos())
            End If
        End If
        'Form1.Picture7.Cls
        x = x
        
        'Form1.Picture7.DrawMode = 13
        'Form1.Picture7.ForeColor = 0
    ElseIf DDFlag = 2 Then
        Dim PntAPI As POINTAPI
        Dim red As Long, Green As Long, blue As Long
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))

        For Z = 0 To 2
                
            
            If Z = 0 Then
                Form1.Picture7.ForeColor = Green
                SP = 10
                EP = 13
            ElseIf Z = 1 Then
                Form1.Picture7.ForeColor = blue
                SP = SP + 3
                EP = EP + 3
            Else
                SP = SP + 3
                EP = EP + 3
                Form1.Picture7.ForeColor = red
            End If
            Pict = Form1.Picture7.hdc
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB = UBound(CurveArray, 1)
            
            On Error GoTo 0
            If UB < LSx Then Call MakeCurveArray(0)
            
            For x = 1 To xLenXoverSeq(Z)
                MoveToEx Pict, (30 + Decompress(XDiffPosC(x, Z)) * XFactor * CurveArray(Decompress(XDiffPosC(x, Z)))), SP, PntAPI
                LineTo Pict, (30 + Decompress(XDiffPosC(x, Z)) * XFactor * CurveArray(Decompress(XDiffPosC(x, Z)))), EP
            Next x
        Next Z
        Form1.Picture7.ForeColor = 0
    End If
 
    'Work out how many tick marks to display on the Y-axis
    PartNumber = (PicHeight - 35) / (TH * 4)

    If PartNumber < 3 Then PartNumber = 3
    YIncriment = (PicHeight - 35) / (PartNumber - 1)
    'Draw X and Y axes
    Form1.Picture7.Line (25, 15)-(25, PicHeight - 10), QBColor(0)
    Form1.Picture7.Line (25, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 5, PicHeight - 10), QBColor(0)
    YE = CLng(PicHeight - (YIncriment))
    'Draw tick marks on the Y-Axis
    StepX = CLng(YIncriment * 100)
    For Y = 2000 To (YE * 100) Step StepX
        Form1.Picture7.Line (25, Y / 100)-(28, Y / 100), QBColor(0)
        x = x
    Next 'Y
   Form1.Picture7.Line (25, PicHeight - 15)-(28, PicHeight - 15), QBColor(0)
   
   ' For Y = 0 To Partnumber
   '     Form1.Picture7.Line (25, yin)-(28, Y), QBColor(0)
   ' Next Y
    
    
    Dim P1 As Long, P2 As Long, P3 As Long
    P1 = CLng(LSx / 4)
    P2 = CLng(LSx / 2)
    P3 = P2 + P1
    If P7XP > 0 Then
        P1 = P1 * XFactor * CurveArray(P1) '284908'286
        P2 = P2 * XFactor * CurveArray(P2) '569816'571
        P3 = P3 * XFactor * CurveArray(P3) '854724'855
    Else
        P1 = (P1 * XFactor)
        P2 = (P2 * XFactor)
        P3 = (P3 * XFactor)
    End If
    'Draw X-Axis tick marks
    Form1.Picture7.Line (30, PicHeight - 10)-(30, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (Form1.Picture7.ScaleWidth - 10, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 10, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (30 + P1, PicHeight - 10)-(30 + P1, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (30 + P2, PicHeight - 10)-(30 + P2, PicHeight - 13), QBColor(0)
    Form1.Picture7.Line (30 + P3, PicHeight - 10)-(30 + P3, PicHeight - 13), QBColor(0)
    Form1.Picture7.CurrentY = 14
    Form1.Picture7.CurrentX = 7
    YS = PicHeight - 15
    YE = 20 - (YIncriment - 1)
    
    
   
    'Print Y-Axis tick lables
    MFactor = 1
    x = 0

    For YX = YS * 100 To YE * 100 Step -YIncriment * 100
        Y = CLng(YX / 100)
        Outnum = (LVal + (UVal - LVal) * (x / (PartNumber - 1))) * MFactor
        If Outnum > 0 Then
            Outnum = Outnum + 0.000000001
        ElseIf Outnum < -10 Then
            Outnum = CLng(Outnum)
        
        ElseIf Outnum <= -1 Then
        
        
        ElseIf Outnum < 0 Then
            Outnum = Outnum - 0.000000001
        End If
        If Outnum > -0.1 And Outnum < 0.01 And Outnum <> 0 And MFactor = 1 And UVal > LVal Then

            If Abs(LVal * 1000) > UVal Then
                MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                
                Pos = InStr(1, XLegend, " (x " & Trim$(CStr(MFactor)) & ")", vbBinaryCompare)
                If Pos > 1 Then
                    XLegend = Left(XLegend, Pos - 1)
                End If
                XLegend = XLegend + " (x " & Trim$(CStr(MFactor)) & ")"
                Outnum = Outnum * MFactor
            ElseIf Abs(Outnum * 100) < UVal And UVal <= 1 Then
                
                Outnum = 0.00000001
                'Outnum = 0
            End If
        
            
            
        End If

        If Outnum < 10 ^ 8 And Outnum > -10 ^ 8 Then
            Outnum = Outnum * 1000
            Outnum = CLng(Outnum)
            Outnum = Outnum / 1000
        End If
        SOutNum = Trim$(CStr(Outnum))
        If UVal >= 0.02 Then
            If Outnum = Int(Outnum) And Outnum < 100 And Outnum > -10 Then SOutNum = SOutNum + ".0"
    
            If Abs(Outnum) >= 100 And Abs(Outnum) < 1000 Then
                SOutNum = " " & Trim$(CStr(Int(val(SOutNum))))
            ElseIf Abs(Outnum) < 1 Then
                Outnum = CLng(Outnum * 100)
                SOutNum = CStr(Outnum)
                If Len(SOutNum) < 2 Then
                    SOutNum = String(2 - Len(SOutNum), "0") + SOutNum
                ElseIf Outnum < 0 And Len(SOutNum) < 3 Then
                    SOutNum = String(3 - Len(SOutNum), "0") & Mid$(SOutNum, 2, 3)
                End If
                If val(SOutNum) >= 0 Then
                    If val(SOutNum) < 100 Then
                        SOutNum = "0." & SOutNum
                    Else
                        SOutNum = "1.00"
                    End If
                ElseIf Outnum < 0 Then
                    If Outnum > -100 Then
                        SOutNum = "-0." & Mid$(SOutNum, 2, Len(SOutNum) - 1)
                    Else
                        SOutNum = "-1.00"
                    End If
                End If
            End If
            
            If Len(SOutNum) < 4 And (InStr(1, SOutNum, ".", vbBinaryCompare) > 0 Or InStr(1, SOutNum, ".", vbBinaryCompare) > 0) Then
                SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 4 And (Outnum > -100 And Outnum < 1000) Then
                SOutNum = Left$(SOutNum, 4)
            End If
                
                
            If Right(SOutNum, 1) = "." Then
                SOutNum = Left(SOutNum, Len(SOutNum) - 1)
            End If
            Form1.Picture7.CurrentY = Y - TH / 2 '- 2
            Form1.Picture7.CurrentX = 0
            '@
            Form1.Picture7.Print SOutNum
            x = x + 1
        Else
            If val(Outnum) < 1 And val(Outnum) > -1 Then
                Outnum = CLng(Outnum * 1000)
                'Exit Sub
                SOutNum = CStr(Outnum)
                If Len(SOutNum) <= 3 And Outnum >= 0 Then
                    SOutNum = String(3 - Len(SOutNum), "0") + SOutNum
                    SOutNum = "0." & SOutNum
                Else
                    x = x
                    SOutNum = "-2"
                    SOutNum = Right$(SOutNum, Len(SOutNum) - 1)
                    SOutNum = String(3 - Len(SOutNum), "0") + SOutNum
                    SOutNum = "-0." & SOutNum
                    x = x
                End If
                
                    
               
                
                If Len(SOutNum) < 5 Then
                    SOutNum = SOutNum + String$(5 - Len(SOutNum), "0")
                ElseIf Len(SOutNum) > 5 Then
                    SOutNum = Left$(SOutNum, 5)
                End If
        
                If Right(SOutNum, 1) = "." Then
                    SOutNum = Left(SOutNum, Len(SOutNum) - 1)
                End If
            Else
                If Outnum > 0 Then
                    SOutNum = CStr(Outnum + 0.00000001)
                Else
                    SOutNum = CStr(Outnum - 0.00000001)
                End If
                SOutNum = Left(SOutNum, 5)
                If Right(SOutNum, 1) = "." Then
                    SOutNum = Left(SOutNum, Len(SOutNum) - 1)
                End If
            End If
            Form1.Picture7.CurrentY = Y - TH / 2 '- 2
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            x = x + 1
        End If
    Next YX

    'Print X-Axis tick labels
    Form1.Picture7.CurrentY = PicHeight - 9
    Form1.Picture7.CurrentX = 29
    Form1.Picture7.Print "1"
    Form1.Picture7.CurrentY = PicHeight - 9
    
    
 
    
    
    Dim CCX As Long
    
    If APF = 0 Then
        
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = Int(DLSx / 2)
        
        Form1.Picture7.CurrentX = 30 + P2 - (((Len(XVal) + 1) / 2) * 5.5)
        CCX = Form1.Picture7.CurrentX + Form1.Picture7.TextWidth(Trim(Str(CLng(LSx / 2))))
        Form1.Picture7.Print (CLng(LSx / 2))
        
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = Int(DLSx)
        Form1.Picture7.CurrentX = Form1.Picture7.ScaleWidth - 10 - (Len(XVal) - 1) * 5.5
        CCX = Form1.Picture7.CurrentX - CCX
        Form1.Picture7.Print DLSx
        
        If CCX > Form1.Picture7.TextWidth(Trim(Str(CLng(LSx / 1.33333)))) Then
            Form1.Picture7.CurrentY = PicHeight - 9
            XVal = Trim(Str(CLng(DLSx / 1.333)))
            
            Form1.Picture7.CurrentX = 30 + P3 - (Form1.Picture7.TextWidth(XVal) / 2) * CurveArray(CLng(val(XVal)))
            Form1.Picture7.Print (CLng(LSx / 1.33333))
            
            XVal = Int(DLSx / 4)
            Form1.Picture7.CurrentY = PicHeight - 9
            Form1.Picture7.CurrentX = 30 + P1 - ((Len(XVal) + 1) / 2) * 5.5
            'Form1.Picture7.Print Decompress(CLng(LSx / 4))
            Form1.Picture7.Print (CLng(LSx / 4))
        End If
        
        
    Else
        XVal = Trim(Str((CLng(LSx / 4))))
        Form1.Picture7.CurrentX = 30 + ((Form1.Picture7.ScaleWidth - 10 - 30) / 4 - (Form1.Picture7.TextWidth(XVal) / 2)) * CurveArray(CLng(val(XVal)))
        Form1.Picture7.Print (CLng(LSx / 4))
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = Trim(Str(CLng(DLSx / 2)))
        Form1.Picture7.CurrentX = 30 + ((Form1.Picture7.ScaleWidth - 10 - 30) / 2 - (Form1.Picture7.TextWidth(XVal) / 2)) * CurveArray(CLng(val(XVal)))
        Form1.Picture7.Print XVal
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = Trim(Str(CLng(DLSx / 1.333)))
        Form1.Picture7.CurrentX = 30 + ((Form1.Picture7.ScaleWidth - 10 - 30) / 1.333 - (Form1.Picture7.TextWidth(XVal) / 2)) * CurveArray(CLng(val(XVal)))
        Form1.Picture7.Print XVal
        Form1.Picture7.CurrentY = PicHeight - 9
        XVal = Trim(Str(CLng(DLSx)))
        Form1.Picture7.CurrentX = (Form1.Picture7.ScaleWidth - 10 - (Form1.Picture7.TextWidth(XVal) / 2)) * CurveArray(CLng(val(XVal)))
        Form1.Picture7.Print XVal
    End If
    'Print X axis label
    Dim OSt As String
    Form1.Picture7.CurrentY = PicHeight
    If APF = 0 Then
        OSt = "Position in alignment"
        
    Else
        If TypeSeqNumber < 0 Then TypeSeqNumber = 0
        If TypeSeqNumber > NextNo Then TypeSeqNumber = NextNo
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            OSt = "Nucleotide position in relation to " + Trim(OriginalName(TypeSeqNumber))
        Else
            OSt = "Position in alignment"
        End If
    End If
    Form1.Picture7.CurrentX = 25 + (Form1.Picture7.ScaleWidth - 30 - Form1.Picture7.TextWidth(OSt)) / 2
    Form1.Picture7.Print OSt
    'Print Y axis label
    Form1.Picture10.Enabled = True
    Form1.Picture10.Picture = LoadPicture()
    Form1.Picture10.CurrentX = 5
    Form1.Picture10.FontSize = 6
    TW = Form1.Picture7.TextWidth(XLegend)
    Form1.Picture10.CurrentY = Form1.Picture7.Top + 15 + ((PicHeight - 10 - 15) + TW) / 2

    Call DoText(Form1.Picture10, Form1.Picture10.Font, XLegend, 90)

    YScaleFactor = 0.85
    Form1.Picture7.CurrentX = 30
    Form1.Picture7.CurrentY = Form1.Picture7.Height * (YScaleFactor + 0.08)
    Form1.Picture7.Enabled = True
    'Sizes pictures according to whether an ORF map is being displayed or not
    OSM = Form1.Picture10.ScaleMode
    Form1.Picture10.ScaleMode = 1

    If ORFFlag = 0 Then
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = 0
    Else
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5 'p10=6120
        Form1.Picture7.Top = (Form1.Picture20.Height - 5 * Screen.TwipsPerPixelY)
    End If

    Form1.Picture10.ScaleMode = OSM
x = x
End Sub
Public Sub GCCheck(SPF)

If NextNo = -1 Then Exit Sub

    Dim PT As Variant, EN As Long, Z As Long, Y As Long, x As Long, Count As Long, Addfrag As Long, Dummy As Long, xMinP As Single, xGCSeq1 As Long, xGCSeq2 As Long, xGCSeq3 As Long
Dim COff As Double
    'ReDim xMinP(Nextno, Nextno)
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    
    Dim BT1 As Long, BT2 As Long, ET1 As Long, ET2 As Long
    Dim MinPA As Double
    Dim Prob As Double
    Dim Beginning As Long
    Dim Ending As Long
    Dim retVal As Long

    'Dim hProcess As Long

    Dim YScaleFactor As Double

    Call FindSubSeqGC2
    MinPx = -Log10(LowestProb / MCCorrection)
    
    MinPA = 1
    If SPF = 0 Then
        Form1.SSPanel1.Caption = "Executing GENECONV"
    End If
    Const STILL_ACTIVE = &H103

    Do
        GetExitCodeProcess cProcess, retVal
    Loop While retVal = STILL_ACTIVE

    Dummy = CloseHandle(cProcess)
    cProcess = 0
    ReDim MCPrintData(2, Len(StrainSeq(0)))
    ReDim MCPrintPos(2, Len(StrainSeq(0)), 1)
    Open GCCFile For Binary Access Read As #1

    Dim Results As String

    Results = String$(30000, " ")

    Dim FLen As Long

    FLen = LOF(1)
    Results = String$(FLen, " ")

    Dim CurrentStart As Long

    CurrentStart = 1
    Get #1, CurrentStart, Results

    Dim NPos As Long, GiPos As Long

    NPos = InStr(1, Results, "GI ", vbBinaryCompare)
    GiPos = NPos + 10

    Dim Temp As String

    If NPos > 0 Then
        Close #1
        Open GCCFile For Binary Access Read As #1
        Temp$ = " "
        Get #1, NPos, Temp$
        If EOF(1) Then
            Close #1
            Exit Sub
        End If
        Input #1, Temp$
        NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
        
        NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        If NPos > 0 Then
            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
        End If
        NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        MinPx = val(Trim$(Left$(Temp$, NPos))) / 3
        If MinPx = 0 Then MinPx = 10 ^ -300
        MinPx = -Log10(MinPx)
        'X = X
    End If

    Dim NPos2 As Long

    NPos2 = InStr(1, Results, "GO ", vbBinaryCompare)

    If NPos2 > 0 Then
        Close #1
        Open GCCFile For Binary Access Read As #1
        Temp$ = String(70, " ")
        Get #1, NPos2, Temp$
        'Input #1, Temp$

        If Len(Temp$) = 0 Then

            Do While Len(Temp$) = 0
                Input #1, Temp$
            Loop

        End If

        NPos2 = InStr(1, Temp$, " ", vbBinaryCompare)
        If NPos2 > 0 Then
            
            Temp$ = Trim$(Mid$(Temp$, NPos2, Len(Temp$) - NPos + 1))
        End If
        NPos2 = InStr(1, Temp$, " ", vbBinaryCompare)
        If NPos2 > 0 Then
            Temp$ = Trim$(Mid$(Temp$, NPos2, Len(Temp$) - NPos + 1))
        End If
        NPos2 = InStr(1, Temp$, " ", vbBinaryCompare)
        Dim tPV As Double
        tPV = val(Trim$(Left$(Temp$, NPos2))) / 3
        If tPV = 0 Then tPV = 10 ^ -300
        tPV = -Log10(tPV)
        If tPV > MinPx Then
            MinPx = tPV
           
        End If

    End If

    'Exit Sub
XDiffPos(0) = XDiffPos(1)
    If MinPx < -Log10(LowestProb / MCCorrection) Then
        MinPx = -Log10(LowestProb / MCCorrection)
    End If
    MinPx = MinPx + 0.5
    If SPF = 0 Then
    '    Form1.Picture7.Picture = LoadPicture()
        Form1.Picture1.Enabled = True
        Form1.Picture7.Enabled = True
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, MinPx, 0, 1, "-Log(KA P-Val)")
    End If
   ' XX = PermNextno
    'ReDim Preserve xMinP(Nextno, Nextno)
    xMinP = MinPx
    
    'Dim CurrentStart As Long
    CurrentStart = 1

    Dim TargetString As String
    Dim CurPPos As Long
    
    CurPPos = 0
    'Do 1 - 2
    Get #1, CurrentStart, Results
   ' XX = UBound(StraiName, 1)
   ' XX = UBound(OriginalName, 1)
   ' Exit Sub
    xGCSeq1 = TreeTrace(GCSeq1)
    xGCSeq2 = TreeTrace(GCSeq2)
    xGCSeq3 = TreeTrace(GCSeq3)
    Dim Seq1Str As String, Seq2Str As String, Seq3Str As String
    Pos = InStr(1, StraiName(xGCSeq1), " ")
    If Pos > 0 Then
        Seq1Str = Left(StraiName(xGCSeq1), Pos - 1)
    Else
        Seq1Str = StraiName(xGCSeq1)
    End If
    
    Pos = InStr(1, StraiName(xGCSeq2), " ")
    If Pos > 0 Then
        Seq2Str = Left(StraiName(xGCSeq2), Pos - 1)
    Else
        Seq2Str = StraiName(xGCSeq2)
    End If
    Pos = InStr(1, StraiName(xGCSeq3), " ")
    If Pos > 0 Then
        Seq3Str = Left(StraiName(xGCSeq3), Pos - 1)
    Else
        Seq3Str = StraiName(xGCSeq3)
    End If
    
    TargetString = Seq1Str + ";" + Seq2Str
    NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

    If NPos = 0 Then
        TargetString = Seq2Str + ";" + Seq1Str
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
    End If
    
    
    
    TargetString = Trim$(TargetString)
    Close #1
    
'    If SPF = 0 Then
'
'        YScaleFactor = 0.85
'        PicHeight = Form1.Picture7.Height * YScaleFactor
'        xFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
'        Form1.Picture7.AutoRedraw = True
'        'Show RDP plot
'
'        Call Highlight(0)
'
'        Form1.Picture2.ForeColor = QBColor(0)
'        COff = -Log10((LowestProb / (MCCorrection)))
'        Y1 = PicHeight - (15 + (COff / xMinP) * (PicHeight - 35))
'        Form1.Picture7.FillStyle = 1
'        Form1.Picture7.FillColor = 0
'        Form1.Picture7.DrawStyle = 2
'        Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
'        Y1 = PicHeight - (15 + (-Log10(LowestProb) / xMinP) * (PicHeight - 35))
'        Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
'        Form1.Picture7.DrawStyle = 0
'    End If
    Dim g As Byte
    Dim TargetCompare As String, TempEnd As String

    
        Open GCCFile For Binary Access Read As #1

For g = 0 To 1
        If NPos > 0 Then
            Temp$ = " "
            Get #1, NPos - 10, Temp$

            Do While Not EOF(1)
                If EOF(1) Then
                    Close #1
                    Exit Sub
                End If
                Input #1, Temp$

                If Left$(Temp$, 2) = "PI" Or Mid$(Temp$, 2, 2) = "PI" Or Left$(Temp$, 2) = "PO" Or Mid$(Temp$, 2, 2) = "PO" Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    If NPos > 0 Then
                        TargetCompare$ = Mid$(Temp$, 1, NPos - 1)
                    Else
                        TargetCompare$ = Temp$
                    End If

                    If TargetCompare$ <> TargetString Then
                        If EOF(1) Then
                            Close #1
                            Exit Sub
                        End If
                        Temp$ = ""
                        If EOF(1) Then
                            Close #1
                            Exit Sub
                        End If
                        'On Error Resume Next
                        Input #1, Temp$
                        On Error GoTo 0
                        If Left$(Temp$, 2) = "PI" Or Mid$(Temp$, 2, 2) = "PI" Or Left$(Temp$, 2) = "PO" Or Mid$(Temp$, 2, 2) = "PO" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        
                            If NPos > 0 Then
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If
        
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                            If NPos > 0 Then
                                TargetCompare$ = Mid$(Temp$, 1, NPos - 1)
                            Else
                                TargetCompare$ = Temp$
                            End If
                            If TargetCompare$ <> TargetString Then Exit Do
                        Else
                            Exit Do
                        End If
                    
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))

                        If Prob = 1 Then Exit Do
                        If Prob = 0 Then Prob = 10 ^ -300
                        If xMinP = -1 Then xMinP = -Log10(Prob)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = val(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = val(TempEnd$)
                        End If

                    End If

                    If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        
                        Prob = -Log10(Prob)
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = Beginning
                        MCPrintPos(0, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.AutoRedraw = True
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
'                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If

                        Prob = -Log10(Prob)
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = Beginning
                        MCPrintPos(0, CurPPos, 1) = Len(StrainSeq(0))
                        CurPPos = CurPPos + 1
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = 1
                        MCPrintPos(0, CurPPos, 1) = Ending
'                        If SPF = 0 Then
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
'                            X1 = 30 + 0 * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
'                        End If
                        CurPPos = CurPPos + 1
                    End If

                ElseIf Left$(Temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))
                        'If Prob = 0 Then

                        If xMinP = -1 Then xMinP = -Log10(Prob)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = val(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = val(TempEnd$)
                        End If

                    End If

                    If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = Beginning
                        MCPrintPos(0, CurPPos, 1) = Ending
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
'                        End If
                        CurPPos = CurPPos + 1
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(0, CurPPos) = Prob
                        MCPrintPos(0, CurPPos, 0) = Beginning
                        MCPrintPos(0, CurPPos, 1) = Len(StrainSeq(0))
                        CurPPos = CurPPos + 1
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = 1
                        MCPrintPos(1, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Len(StrainSeq(0))) * xFactor + xFactor
'
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
'                            X1 = 30 + 0 * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), Yellow, B
'                        End If
                    End If

                ElseIf Left$(Temp$, 8) = "#   Name" Then
                Else

                    If Left$(Temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop
        End If
        TargetString = "PO  " & Trim$(Seq3Str)
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

        If NPos = 0 Then Exit For
        Temp$ = " "
        Get #1, NPos - 10, Temp$
        TargetString = Trim$(Seq3Str)
        'Form1.Picture7.DrawStyle = 2
    Next 'G
    
    
    

    'Form1.Picture7.DrawStyle = 0
    Close #1
    CurPPos = 0
    'do 1-3
    TargetString = Seq1Str + ";" + Seq3Str
    NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

    If NPos = 0 Then
        TargetString = Seq3Str + ";" + Seq1Str
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
    End If

    TargetString = Trim$(TargetString)

   
    Open GCCFile For Binary Access Read As #1

    For g = 0 To 1
        If NPos > 0 Then
            Temp$ = " "
            Get #1, NPos - 10, Temp$
    
            Do While Not EOF(1)
                Input #1, Temp$

                If Left$(Temp$, 2) = "PI" Or Mid$(Temp$, 2, 2) = "PI" Or Left$(Temp$, 2) = "PO" Or Mid$(Temp$, 2, 2) = "PO" Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    If NPos > 0 Then
                        TargetCompare$ = Mid$(Temp$, 1, NPos - 1)
                    Else
                        TargetCompare$ = Temp$
                    End If
                    If TargetCompare$ <> TargetString Then
                        If EOF(1) Then
                            Close #1
                            Exit Sub
                        End If
                        Input #1, Temp$

                        If Left$(Temp$, 2) = "PI" Or Mid$(Temp$, 2, 2) = "PI" Or Left$(Temp$, 2) = "PO" Or Mid$(Temp$, 2, 2) = "PO" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        
                            If NPos > 0 Then
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If
        
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                            If NPos > 0 Then
                                TargetCompare$ = Mid$(Temp$, 1, NPos - 1)
                            Else
                                TargetCompare$ = Temp$
                            End If
                            If TargetCompare$ <> TargetString Then Exit Do
                        Else
                            Exit Do
                        End If
                    
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))

                        If Prob = 1 Then Exit Do
                        If Prob = 0 Then Prob = 10 ^ -300
                        If xMinP = -1 Then xMinP = -Log10(Prob)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = val(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = val(TempEnd$)
                        End If

                    End If

                    If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If (ET2 - BT1) > (ET1 - BT2) Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = Beginning
                        MCPrintPos(1, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.AutoRedraw = True
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), green, B
'                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = Beginning
                        MCPrintPos(1, CurPPos, 1) = Len(StrainSeq(0))
                        CurPPos = CurPPos + 1
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = 1
                        MCPrintPos(1, CurPPos, 1) = Decompress(Ending)
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Len(StrainSeq(0))) * xFactor + xFactor
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), green, B
'
'                            X1 = 30 + 0 * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'                            'Prob = -log10(Prob)
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                            Form1.Picture7.Line (X1, Y1)-(X2, Y2), green, B
'                        End If
                    End If

                ElseIf Left$(Temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))
                        'If Prob = 0 Then

                        If xMinP = -1 Then xMinP = -Log10(Prob)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = val(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = val(TempEnd$)
                        End If

                    End If

                    If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = Beginning
                        MCPrintPos(1, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), green, B
'                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = Beginning
                        MCPrintPos(1, CurPPos, 1) = Len(StrainSeq(0))
                        CurPPos = CurPPos + 1
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = 1
                        MCPrintPos(1, CurPPos, 1) = Decompress(Ending)
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Len(StrainSeq(0))) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), green, B
'                            X1 = 30 + 0 * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'                            'Prob = -Log(Prob)
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), green, B
'                        End If
                    End If

                ElseIf Left$(Temp$, 8) = "#   Name" Then
                Else

                    If Left$(Temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop
        End If
        TargetString = "PO  " & Trim$(Seq2Str)
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

        If NPos = 0 Then Exit For
        TargetString = Trim$(Seq2Str)
        'Form1.Picture7.DrawStyle = 2
    Next 'G



    'Form1.Picture7.DrawStyle = 0
    Close #1
    CurPPos = 0
    'do 2-3
    CurrentStart = 1
    TargetString = Seq2Str + ";" + Seq3Str
    NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

    If NPos = 0 Then
        TargetString = Seq3Str + ";" + Seq2Str
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
    End If

    TargetString = Trim$(TargetString)

    
        Open GCCFile For Binary Access Read As #1

    For g = 0 To 1
        If NPos > 0 Then
            Temp$ = " "
            Get #1, NPos - 10, Temp$

            Do While Not EOF(1)
                Input #1, Temp$

                If Left$(Temp$, 2) = "PI" Or Mid$(Temp$, 2, 2) = "PI" Or Left$(Temp$, 2) = "PO" Or Mid$(Temp$, 2, 2) = "PO" Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    If NPos > 0 Then
                        TargetCompare$ = Mid$(Temp$, 1, NPos - 1)
                    Else
                        TargetCompare$ = Temp$
                    End If
                    If TargetCompare$ <> TargetString Then
                        If EOF(1) Then
                            Close #1
                            Exit Sub
                        End If
                        Input #1, Temp$

                        If Left$(Temp$, 2) = "PI" Or Mid$(Temp$, 2, 2) = "PI" Or Left$(Temp$, 2) = "PO" Or Mid$(Temp$, 2, 2) = "PO" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        
                            If NPos > 0 Then
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If
        
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                            If NPos > 0 Then
                                TargetCompare$ = Mid$(Temp$, 1, NPos - 1)
                            Else
                                TargetCompare$ = Temp$
                            End If
        
                            If TargetCompare$ <> TargetString Then Exit Do
                        Else
                            Exit Do
                        End If
                    
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))

                        If Prob = 1 Then Exit Do
                        If Prob = 0 Then Prob = 10 ^ -300
                        If xMinP = -1 Then xMinP = -Log10(Prob)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = val(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = val(TempEnd$)
                        End If

                    End If

                    If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(2, CurPPos) = Prob
                        MCPrintPos(2, CurPPos, 0) = Beginning
                        MCPrintPos(2, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
'                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(2, CurPPos) = Prob
                        MCPrintPos(2, CurPPos, 0) = Beginning
                        MCPrintPos(2, CurPPos, 1) = Len(StrainSeq(0))
                        CurPPos = CurPPos + 1
                        MCPrintData(2, CurPPos) = Prob
                        MCPrintPos(2, CurPPos, 0) = 1
                        MCPrintPos(2, CurPPos, 1) = Decompress(Ending)
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Len(StrainSeq(0))) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
'                            X1 = 30 + 0 * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'                            'Prob = -log10(Prob)
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
'                        End If
                    End If

                ElseIf Left$(Temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))
                        'If Prob = 0 Then

                        If xMinP = -1 Then xMinP = -Log10(Prob)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = val(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                            Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = val(TempEnd$)
                        End If

                    End If

                    If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning

                    If Beginning < Ending Then
                        If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                            BT1 = Beginning + Len(StrainSeq(0))
                            ET1 = Ending + Len(StrainSeq(0))
                        Else
                            BT1 = Beginning
                            ET1 = Ending
                        End If
                        
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(2, CurPPos) = Prob
                        MCPrintPos(2, CurPPos, 0) = Beginning
                        MCPrintPos(2, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
'                        End If
                    Else
                        BT1 = Beginning
                        ET1 = Ending + Len(StrainSeq(0))
                        If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                            BT2 = BT2 + Len(StrainSeq(0))
                            ET2 = ET2 + Len(StrainSeq(0))
                        End If
                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If ET2 - BT1 > ET1 - BT2 Then

                                If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                            Else

                                If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                            End If

                            If MinPA > Prob Then MinPA = Prob
                        End If
                        Prob = -Log10(Prob)
                        MCPrintData(2, CurPPos) = Prob
                        MCPrintPos(2, CurPPos, 0) = Decompress(Beginning)
                        MCPrintPos(2, CurPPos, 1) = Decompress(Len(StrainSeq(0)))
                        CurPPos = CurPPos + 1
                        MCPrintData(2, CurPPos) = Prob
                        MCPrintPos(2, CurPPos, 0) = 1
                        MCPrintPos(2, CurPPos, 1) = Decompress(Ending)
                        CurPPos = CurPPos + 1
'                        If SPF = 0 Then
'                            X1 = 30 + Decompress(Beginning) * xFactor + xFactor
'                            X2 = 30 + Decompress(Len(StrainSeq(0))) * xFactor + xFactor
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
'                            X1 = 30 + 0 * xFactor + xFactor
'                            X2 = 30 + Decompress(Ending) * xFactor + xFactor
'                            'Prob = -log10(Prob)
'
'                            Y1 = PicHeight - (15 + (Prob / xMinP) * (PicHeight - 35))
'                            Y2 = PicHeight - 15
'                           Form1.Picture7.Line (X1, Y1)-(X2, Y2), Purple, B
'                        End If
                    End If

                ElseIf Left$(Temp$, 8) = "#   Name" Then
                Else

                    If Left$(Temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop
        End If
        TargetString = "PO  " & Trim$(Seq1Str)
        NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)

        If NPos = 0 Then Exit For
        TargetString = Trim$(Seq1Str)
        'Form1.Picture7.DrawStyle = 2
    Next 'G

    
MinPVal = xMinP
    Close #1
    
    
    If pMCFlag = 0 Then
        MinPA = MinPA * MCCorrection
    ElseIf pMCFlag = 2 Then
        MinPA = StepDown2(1, MinPA)
    End If
    
    If BestRescanFlag = 1 And BestRescanP > MinPA And MinPA < LowestProb And MinPA > 0 Then
        BestRescanP = MinPA
    End If
    If (UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
    End If
    If (BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
        ReDim GPVTFont(5, 100), GPVText(100)
        GPVTNum = -1
    
        'Form1.Picture7.DrawStyle = 0
        'Add data to standard drawing and copying arrays etc
        Count = Len(StrainSeq(0))
        GPrintNum = 2 'three line types
        ReDim GPrint(GPrintNum, Count), GPrintCol(GPrintNum), GPrintPos(GPrintNum, 1, Count)
        GPrintLen = Count - 1 'how many points to plot
        GPrintCol(0) = Yellow 'line is yellow
        GPrintCol(1) = Green 'line is green
        GPrintCol(2) = Purple 'line is purple
        ReDim GCritval(10)
        GCritval(0) = -Log10((LowestProb / MCCorrection))
        GLegend = "-Log[KA P-Val]"
        GPrintType = 1 'a region plot
        GPrintMin(0) = 0
        GPrintMin(1) = MinPx
        'GBlockNum = -1
        ReDim GVarPos(0, LenXoverSeq)
        For x = 1 To LenXoverSeq
            GVarPos(0, x) = XDiffPos(x)
        Next x
        
        For Y = 0 To GPrintNum
            Z = -1
            For x = 0 To Len(StrainSeq(0))
                
                If MCPrintData(Y, x) > 0 Then
                    Z = Z + 1
                    GPrint(Y, Z) = MCPrintData(Y, x)
                    
                    
                    If MCPrintPos(Y, x, 0) < MCPrintPos(Y, x, 1) Then
                        
                        GPrintPos(Y, 0, Z) = MCPrintPos(Y, x, 0)
                        GPrintPos(Y, 1, Z) = MCPrintPos(Y, x, 1)
                    Else
                        GPrintPos(Y, 0, Z) = MCPrintPos(Y, x, 0)
                        GPrintPos(Y, 1, Z) = Len(StrainSeq(0))
                        Z = Z + 1
                        GPrint(Y, Z) = MCPrintData(Y, x)
                        GPrintPos(Y, 0, Z) = 1
                        GPrintPos(Y, 1, Z) = MCPrintPos(Y, x, 1)
                   End If
                End If
                
            Next x
        Next Y
        GPrintLen = Len(StrainSeq(0))
        
        If SPF = 0 And DontRedrawPlotsFlag = 0 Then
            WN1 = GCSeq1: WN2 = GCSeq2: WN3 = GCSeq3
            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
            'Call WriteNames(GCSeq1, GCSeq2, GCSeq3, Yellow, Green, Purple)
        End If
        
    
        Form1.Picture2.ForeColor = QBColor(0)
        'COff = -Log10((LowestProb / (MCCorrection)))
        'Y1 = PicHeight - (15 + (COff / xMinP(1,2)) * (PicHeight - 35))
        'Form1.Picture7.DrawStyle = 2
        'Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
        'Y1 = PicHeight - (15 + (-Log10(LowestProb) / xMinP(1,2)) * (PicHeight - 35))
        'Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
        
        Form1.Picture7.DrawStyle = 0
         
        If ORFFlag = 1 Then
            'Form1.Picture20.Picture = Form1.Picture19.Image
            Call DrawORFsP20
            Form1.Picture20.Visible = True
        End If
         
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
        End If
        
        If SPF = 0 Then
            MaxVGC = 4
            Call RedrawPlotAA(1)
        End If
        
        
        'See whether a results here should be added to the confirmation table or not.
        If LongWindedFlag = 0 Then
            EN = XoverList(RelX, RelY).Eventnumber
        Else
            EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
        End If
        If Confirm(EN, 1) > 0 Then
            If Abs(ConfirmP(EN, 1)) < 300 Then
                PT = 10 ^ (-ConfirmP(EN, 1))
            Else
                PT = 10 ^ 300
            End If
        Else
            PT = 1
        End If
        If (Confirm(EN, 1) = 0 Or (Confirm(EN, 1) = 1 And MinPA < PT)) And MinPA < 1 Then
            Confirm(EN, 1) = 1
            ConfirmP(EN, 1) = -Log10(MinPA)
            
    
            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        
        ProbTest = MinPA
        ProbY = 1
    
        If XoverList(RelX, RelY).Ending > XoverList(RelX, RelY).Beginning Then
            ProbX = Decompress(XoverList(RelX, RelY).Beginning) + (Decompress(XoverList(RelX, RelY).Ending) - Decompress(XoverList(RelX, RelY).Beginning)) / 2
    
            If MinPA < 1 Then
                If SPF = 0 Then
                    If DontRedrawPlotsFlag = 0 Then
                        Call PrintProbability
                    End If
                    If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                        XoverList(RelX, RelY).Probability = MinPA
                    End If
                End If
                If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                    BestParent = CheckParent: WinMethod = 1
                    BestParentP = MinPA
                End If
                
            End If
    
        Else
    
            If Len(StrainSeq(0)) - XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                ProbX = Decompress(XoverList(RelX, RelY).Beginning) + (Decompress(Len(StrainSeq(0))) - Decompress(XoverList(RelX, RelY).Beginning)) / 2
    
                If MinPA < 1 Then
                    If SPF = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call PrintProbability
                        End If
                        If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                            XoverList(RelX, RelY).Probability = MinPA
                        End If
                    End If
                    If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                        BestParent = CheckParent: WinMethod = 1
                        BestParentP = MinPA
                    End If
                
                End If
            Else
                ProbX = Decompress(XoverList(RelX, RelY).Ending) / 2
    
                If MinPA < 1 Then
                    If SPF = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call PrintProbability
                        End If
                        If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                            XoverList(RelX, RelY).Probability = MinPA
                        End If
                    End If
                End If
                If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                    BestParent = CheckParent: WinMethod = 1
                    BestParentP = MinPA
                End If
                
    
            End If
    
        End If
    End If
    If SPF = 0 Then
        If UpdateProgressBar = 0 Then
            Form1.SSPanel1.Caption = ""
        End If
        If Screen.MousePointer <> oPointer Then
            Screen.MousePointer = oPointer
        End If
    End If
   
   
   MinPAGlobal = MinPA

x = x
End Sub
Static Function Log10(x)

    If x > 0 Then
        Log10 = Log(x) / Log(10#)
    Else
        Log10 = Log(10) / Log(10#)
    End If

End Function
Static Function StepUp(x, Y)
Dim MC As Variant, Z As Long
CurrentCorrect = x
If CurrentCorrect >= AddNum Then CurrentCorrect = CurrentCorrect - AddNum
Dim LPV As Double
If CurrentCorrect = 0 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 1 Then
    If GCtripletflag = 1 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 2 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 3 Then
    If MCTripletFlag = 0 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 4 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 5 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 6 Then
    MC = NumberOfSeqs + 1
Else

End If

Dim RPV As Double
If MCFlag = 2 Then
    For Z = 0 To 100
        
        If PValCat(CurrentCorrect, Z) > 0 Then
            RPV = Y / PValCat(CurrentCorrect, Z)
            LPV = CInt(-Log10(CDbl(RPV)) * 2)
            If LPV > 100 Then LPV = 100
            If Y > (RPV * PValCat(CurrentCorrect, LPV) * 0.99999) And Y < RPV * PValCat(CurrentCorrect, LPV) / 0.99999 Then
              Exit For
            End If
        End If
    Next Z
    
End If
StepUp = RPV



End Function
Static Function StepDown2(x, Y)
Dim MC As Variant, LPV As Variant, PVal As Variant
CurrentCorrect = x
Dim LPV2 As Double
LPV2 = Y
If CurrentCorrect = 0 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 1 Then
    If GCtripletflag = 1 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 2 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 3 Then
    If MCTripletFlag = 0 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 4 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 5 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 6 Then
    MC = NumberOfSeqs + 1
Else

End If

LPV = CInt(-Log10(CDbl(LPV2)) * 2)
If LPV > 0 Then
    If LPV < 100 Then
        If PValCat(CurrentCorrect, LPV + 1) > 0 Then
            If (Y * PValCat(CurrentCorrect, LPV)) > (MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)) Then
                PVal = Y * PValCat(CurrentCorrect, LPV)
            Else
                PVal = MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)
            End If
        Else
            PVal = Y * MC
        End If
    Else
        PVal = Y * MC
    End If
End If

StepDown2 = PVal
End Function
Static Function Exp10(x As Double)
    
    'If X > 0 Then
        Exp10 = Exp(x * Log(10#))
    'Else
    '    Exp10 = 1
    'End If

End Function
Public Function ProcessTerminate(Optional lProcessID As Long, Optional lHwndWindow As Long) As Boolean
   Dim lhwndProcess As Long
   Dim lExitCode As Long
   Dim lRetVal As Long
   Dim lhThisProc As Long
   Dim lhTokenHandle As Long
   Dim tLuid As LUID
   Dim tTokenPriv As TOKEN_PRIVILEGES, tTokenPrivNew As TOKEN_PRIVILEGES
   Dim lBufferNeeded As Long
   
   Const PROCESS_ALL_ACCESS = &H1F0FFF, PROCESS_TERMINATE = &H1
   Const ANYSIZE_ARRAY = 1, TOKEN_ADJUST_PRIVILEGES = &H20
   Const TOKEN_QUERY = &H8, SE_DEBUG_NAME As String = "SeDebugPrivilege"
   Const SE_PRIVILEGE_ENABLED = &H2

   If DebuggingFlag < 2 Then On Error Resume Next
   If lHwndWindow Then
       'Get the process ID from the window handle
       lRetVal = GetWindowThreadProcessId(lHwndWindow, lProcessID)
   End If
   
   If lProcessID Then
       'Give Kill permissions to this process
       lhThisProc = GetCurrentProcess
       
       OpenProcessToken lhThisProc, TOKEN_ADJUST_PRIVILEGES Or TOKEN_QUERY, lhTokenHandle
       LookupPrivilegeValue "", SE_DEBUG_NAME, tLuid
       'Set the number of privileges to be change
       tTokenPriv.PrivilegeCount = 1
       tTokenPriv.TheLuid = tLuid
       tTokenPriv.Attributes = SE_PRIVILEGE_ENABLED
       'Enable the kill privilege in the access token of this process
       AdjustTokenPrivileges lhTokenHandle, False, tTokenPriv, Len(tTokenPrivNew), tTokenPrivNew, lBufferNeeded

       'Open the process to kill
       lhwndProcess = OpenProcess(PROCESS_TERMINATE, 0, lProcessID)
   
       If lhwndProcess Then
           'Obtained process handle, kill the process
           ProcessTerminate = CBool(TerminateProcess(lhwndProcess, lExitCode))
           Call CloseHandle(lhwndProcess)
       End If
   End If
   On Error GoTo 0
End Function

Public Sub GCCompare()

    Dim LS As Long, Dummy As Long, x As Long, NewName As String, xGCSeq1 As Long, xGCSeq2 As Long, xGCSeq3 As Long
    Dim oDir As String
    If DebuggingFlag < 2 Then On Error Resume Next
    If OverrideGCCompare = 1 Then Exit Sub
    xGCSeq1 = TreeTrace(GCSeq1)
    xGCSeq2 = TreeTrace(GCSeq2)
    xGCSeq3 = TreeTrace(GCSeq3)
    
    
    
    
    Dim tExitCode As Long, lProcessID As Long

    Const STILL_ACTIVE = &H103

    If cProcess > 0 And x = 12345 Then 'this is disabled because hard stops don't seem to work under xp
        If x = x Then
            ProcessTerminate (cProcess)
        Else
            GetWindowThreadProcessId cProcess, lProcessID
            GetExitCodeProcess cProcess, tExitCode
            
            If tExitCode = STILL_ACTIVE Then
                Dummy = TerminateProcess(cProcess, tExitCode)
                
            'Else
            '    Exit Do
            End If
        'Loop
        
            Dummy = CloseHandle(cProcess)
        
            cProcess = 0
            
        End If
    End If
    
    
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    NewName = "comptf"
    If DebuggingFlag < 2 Then On Error Resume Next
    Close #1
    
    
    Dim Seq1Str As String, Seq2Str As String, Seq3Str As String
    Pos = InStr(1, StraiName(xGCSeq1), " ")
    If Pos > 0 Then
        Seq1Str = Left(StraiName(xGCSeq1), Pos - 1)
    Else
        Seq1Str = StraiName(xGCSeq1)
    End If
    
    Pos = InStr(1, StraiName(xGCSeq2), " ")
    If Pos > 0 Then
        Seq2Str = Left(StraiName(xGCSeq2), Pos - 1)
    Else
        Seq2Str = StraiName(xGCSeq2)
    End If
    Pos = InStr(1, StraiName(xGCSeq3), " ")
    If Pos > 0 Then
        Seq3Str = Left(StraiName(xGCSeq3), Pos - 1)
    Else
        Seq3Str = StraiName(xGCSeq3)
    End If
    
    
    Open NewName For Output As #1
    'Exit Sub
    'NewName = comptf
    'output in FASTA format
    If LongWindedFlag = 1 Then
        Dim TempSeq(2) As String
        LS = Len(StrainSeq(0))
        TempSeq(0) = ""
        TempSeq(1) = ""
        TempSeq(2) = ""
        TempSeq(0) = String(Len(StrainSeq(0)), " ")
        TempSeq(1) = String(Len(StrainSeq(0)), " ")
        TempSeq(2) = String(Len(StrainSeq(0)), " ")
        If GCSeq1 <= UBound(SeqNum, 2) Then
            For x = 1 To Len(StrainSeq(0))
                Mid$(TempSeq(0), x, 1) = Chr(SeqNum(x, GCSeq1) - 1)
            Next x
       Else
            If xGCSeq1 <= UBound(SeqNum, 2) Then
                For x = 1 To Len(StrainSeq(0))
                    Mid$(TempSeq(0), x, 1) = Chr(SeqNum(x, xGCSeq1) - 1)
                Next x
            Else
                TempSeq(0) = StrainSeq(GCSeq1)
            End If
        End If
        If GCSeq2 <= UBound(SeqNum, 2) Then
            For x = 1 To Len(StrainSeq(0))
                Mid$(TempSeq(1), x, 1) = Chr(SeqNum(x, GCSeq2) - 1)
            Next x
        Else
        
            If xGCSeq2 <= UBound(SeqNum, 2) Then
                For x = 1 To Len(StrainSeq(0))
                    Mid$(TempSeq(1), x, 1) = Chr(SeqNum(x, xGCSeq2) - 1)
                Next x
            Else
                TempSeq(1) = StrainSeq(GCSeq2)
            End If
        End If
        
        If GCSeq3 <= UBound(SeqNum, 2) Then
            For x = 1 To Len(StrainSeq(0))
                Mid$(TempSeq(2), x, 1) = Chr(SeqNum(x, GCSeq3) - 1)
            Next x
        Else
            If xGCSeq3 <= UBound(SeqNum, 2) Then
                For x = 1 To Len(StrainSeq(0))
                    Mid$(TempSeq(2), x, 1) = Chr(SeqNum(x, xGCSeq3) - 1)
                Next x
            Else
                TempSeq(2) = StrainSeq(GCSeq3)
            End If
        End If
            
            
        
        
    End If
    
    Print #1, ">" & Seq1Str
    Print #1, TempSeq(0)
    Print #1, ">" & Seq2Str
    Print #1, TempSeq(1)
    Print #1, ">" & Seq3Str
    Print #1, TempSeq(2)
    Close #1
    GCCFile = CurDir & "\comp.frags"
    GCCompCfg = CurDir & "\comp.cfg"
    Open "comp.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=comptf"
    Print #1, "-Outfile=comp"
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    ' Print #1, "/mkz"

    If GCSeqTypeFlag = 0 Then
        'Label29.Caption = "Automatic detection of sequence type"
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        'Label29.Caption = "Sequences are DNA"
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        'Label29.Caption = "Sequences are DNA coding region"
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        'Label29.Caption = "Sequences are protein"
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        'Label31.Caption = "Ignor indels"
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        'Label31.Caption = "Treat indel blocs as one polymorphism"
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        'Label31.Caption = "Treat each indel site as a polymorphism"
        Print #1, "-Use_individual_indels"
    End If

    

    If GCMonoSiteFlag = 0 Then
        'Label39.Caption = "Do not use monomorphic sites"
    Else
        'Label39.Caption = "Use monomorphic sites"
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)
    Print #1, "-SortName"
    'Print #1, "-SortGfragsBySeq"
    'Print #1, "-SortGfragsBoth"
    '  If GCEndLen > 0 Then
    '      Print #1, "-Dumpjseq -Jseqlen=" & GCEndLen
    '
    '  End If
    ' If GCOffsetAddjust > 0 Then
    '     Print #1, "-AddOffset=" & GCOffsetAddjust
    ' End If
    Print #1, "-Nolog"

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If

    Print #1, "-ListGlobal=1"
    Print #1, "-ListPerPair=50"
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore

    If GCMaxOverlapFrags < 10 Then
        Print #1, "/v1000" '& GCMaxOverlapFrags
    Else
        Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    End If

    Print #1, "-Numsim=0"
    'Print #1, "-Maxsimglobalpval=" & GCMaxPermPVal
    Print #1, "-Maxkapairwisepval=0.99999"
    'Print #1, "/mz"
    'Print #1, "-Listonly=" & strainame(GCSeq1) & "," & strainame(GCSeq2) & ";" & strainame(GCSeq1) & "," & strainame(GCSeq3) & ";" & strainame(GCSeq2) & "," & strainame(GCSeq3)
    Close #1
    'LowestProb = cdbl(Form1.Text1.Text)
    'Print #1, "/x"
    
    
    Dim CommandString As String
    CommandString = "geneconv comp.cfg"
    'XX = CurDir
    cProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell(CommandString, 0))
    'cProcess = 0
    'ShellAndClose CommandString, 0
    'Sleep 10
    On Error GoTo 0
    If DebuggingFlag < 2 Then On Error Resume Next
    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub

Public Sub DoText(AngPict As Object, AngFont As StdFont, AngText As String, Angle As Single)     ' Parameters:
    'angpict: picture box, etc to draw text in
    'angfont: Font object with info about font to use
    'angtext: text to print
    'angle : angle, measured anti-clockwise from horizontal: ----->

    Dim newfont As Long
    Dim OldFont As Long
    Dim angweight As Long

    If AngFont.Bold = True Then
        angweight = FW_BOLD
    Else
        angweight = FW_NORMAL
    End If

    newfont = CreateFont(AngFont.Size * 2, 0, Angle * 10, 0, angweight, AngFont.Italic, AngFont.Underline, AngFont.Strikethrough, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH Or FF_DONTCARE, AngFont.Name)
    '@'@
    OldFont = SelectObject(AngPict.hdc, newfont)
    '@
    AngPict.Print AngText
    newfont = SelectObject(AngPict.hdc, OldFont)

    If DeleteObject(newfont) = 0 Then
        'could not remove font from GDI heap
    End If

End Sub

Public Sub GCXOverB()
    
    LowestProb = pLowestProb
    Dim tExitCode As Long

    Const STILL_ACTIVE = &H103

    If hProcess > 0 Then
        GetExitCodeProcess hProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess hProcess, tExitCode
        End If

        CloseHandle hProcess
        hProcess = 0
    End If

    Dim x As Long, Y As Long
    Dim NewName As String, oDir As String, LList As String
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    NewName = "tf"
    GCFragSeq = CurDir & "tf"
    GCFragCfg = CurDir & "config.cfg"
    Open NewName For Output As #1
    'output in FASTA format

    For x = 0 To NextNo

        If MaskSeq(x) <= 1 Then

            If MaskSeq(x) = 1 Then MaskFlag = 1
            Print #1, ">" & StraiName(x)
            Print #1, StrainSeq(x)
        End If

    Next 'X

    Close #1
    'Dim DOSCommand As String
    'DOSCommand = "dir  > tempout.dat"
    'Open "dbat.bat" For Output As #1
    'Print #1, DOSCommand
    'Close #1
    Open "config.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=tf"
    Print #1, "-Outfile=" & GCOutfileName
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If
    Dim ProbString As String
    
    If MCFlag = 0 Then
        ProbString = LowestProb
    Else
        ProbString = (LowestProb * MCCorrect)
    End If
    Pos = InStr(1, ProbString, ",", vbBinaryCompare)
    If Pos > 0 Then Mid(ProbString, Pos, 1) = "."
    If ShortOutFlag = 3 And GCNumPerms > 0 Then
    
    Else
        Print #1, "-Maxkaglobalpval=" & ProbString
    End If
    
    If GCSeqTypeFlag = 0 Then
        'Label29.Caption = "Automatic detection of sequence type"
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        'Label29.Caption = "Sequences are DNA"
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        'Label29.Caption = "Sequences are DNA coding region"
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        'Label29.Caption = "Sequences are protein"
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        'Label31.Caption = "Ignor indels"
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        'Label31.Caption = "Treat indel blocs as one polymorphism"
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        'Label31.Caption = "Treat each indel site as a polymorphism"
        Print #1, "-Use_individual_indels"
    End If

    
    If GCMonoSiteFlag = 0 Then
        'Label39.Caption = "Do not use monomorphic sites"
    Else
        'Label39.Caption = "Use monomorphic sites"
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)

    If GCOutFlag = 0 Then
        'Label27.Caption = "Space separated output"
        Print #1, "-Dumpfrag"
    ElseIf GCOutFlag = 1 Then
        'Label27.Caption = "Tab separated output"
        Print #1, "-Dumptab"
    ElseIf GCOutFlag = 2 Then
        'Label27.Caption = "DIF-format spreadsheet output"
        Print #1, "-Dumpdif"
    ElseIf GCOutFlag = 3 Then
        'Label27.Caption = "Output in all formats"
        Print #1, "-Dumpall"
    End If

    If GCOutFlagII = 0 Then
        'Label33.Caption = "Simple output"
        'Command29.Enabled = False
    Else
        'Label33.Caption = "Maximum output"
        Print #1, "/sb /sp  /sd -Show_maxmeansims -ShowUnal"
    End If

    If GCSortFlag = 0 Then
        'Label34.Caption = "Sort fragment lists by P-Value"
    ElseIf GCSortFlag = 1 Then
        'Label34.Caption = "Sort fragment lists alphabetically by name"
        Print #1, "-SortGfragsBySeq"
    ElseIf GCSortFlag = 2 Then
        'Label34.Caption = "Sort fragment lists by P-Value then name"
        Print #1, "-SortGfragsBoth"
    End If

    If GCEndLen > 0 Then
        Print #1, "-Dumpjseq -Jseqlen=" & GCEndLen
    End If

    If GCOffsetAddjust > 0 Then
        Print #1, "-AddOffset=" & GCOffsetAddjust
    End If

    If GCLogFlag = 0 Then
        'Label28.Caption = "Write log file"
    ElseIf GCLogFlag = 1 Then
        'Label28.Caption = "Append existing log file"
        Print #1, "-Logappend"
    ElseIf GCLogFlag = 2 Then
        'Label28.Caption = "Do not write log file"
        Print #1, "-Nolog"
    End If

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If
    Dim NFr As Double
    If GCMaxGlobFrags > GCMaxPairFrags Then
        NFr = GCMaxGlobFrags
    Else
        NFr = GCMaxPairFrags
    End If
    
    If MCFlag = 0 Then
        Print #1, "-ListGlobal=" & NFr
        Print #1, "-ListPerPair=0"
    Else
        Print #1, "-ListGlobal=0"
        Print #1, "-ListPerPair=" & NFr
        
    End If
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore
    Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    Print #1, "-Numsim=" & GCNumPerms

    If GCNumPerms > 0 Then
        Print #1, "-Maxsimglobalpval=" & GCMaxPermPVal

        If GCPermPolyFlag = 0 Then
            Print #1, "-Simp_poly_only"
        Else
            Print #1, "-Mult_poly_only"
        End If

    End If

    If MaskFlag = 1 Then
        'Listonly List
        LList$ = ""

        For x = 0 To NextNo

            If MaskSeq(x) = 0 Then

                For Y = x + 1 To NextNo

                    If MaskSeq(Y) = 0 Then
                        LList$ = LList$ + StraiName(x) + "," + StraiName(Y) + " "
                    End If

                Next 'Y

            End If

        Next 'X

        Print #1, "-Listonly=" + LList$
    End If

    'Print #1, "-Mult_poly_only"
    'Print #1, "/x"
    'GCGroupFlag = 1
    
    
    
    Close #1
    
    
    'RetVal = Shell(App.Path & "\geneconv tempfile", 1)   ' Run geneconv
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell("dbat.bat", 1))
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell(App.Path & "\geneconv tempfile  /n0 /mkg " & LowestProb & " /v9 -ExpFormat", 0))
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell("geneconv config.cfg", 0))
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub
Public Sub GCXoverC(SPF)
    Dim TStr As String
   
    If ShortOutFlag = 0 Then
        LowestProb = pLowestProb
    End If
    
    Dim tExitCode As Long

    Const STILL_ACTIVE = &H103

    If hProcess > 0 Then
        GetExitCodeProcess hProcess, tExitCode

        If tExitCode = STILL_ACTIVE Then
            TerminateProcess hProcess, tExitCode
        End If

        CloseHandle hProcess
        hProcess = 0
    End If

    Dim x As Long, Y As Long
    Dim NewName As String, oDir As String, LList As String
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    NewName = "tf"
    GCFragSeq = CurDir & "tf"
    GCFragCfg = CurDir & "config.cfg"
    Open NewName For Output As #1
    'output in FASTA format

    For x = 0 To NextNo

        If MaskSeq(x) <= 1 Then

            If MaskSeq(x) = 1 Then MaskFlag = 1
            Print #1, ">" & StraiName(x)
            Print #1, StrainSeq(x)
        End If

    Next 'X

    Close #1
    'Dim DOSCommand As String
    'DOSCommand = "dir  > tempout.dat"
    'Open "dbat.bat" For Output As #1
    'Print #1, DOSCommand
    'Close #1
    Open "config.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=tf"
    Print #1, "-Outfile=" & GCOutfileName
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    If MCFlag = 0 Then
        TStr = Str(LowestProb)
        Pos = InStr(1, TStr, ",", vbBinaryCompare)
        If Pos > 0 Then Mid(TStr, Pos, 1) = "."
        Print #1, "-Maxkaglobalpval=" & TStr
    Else
        TStr = Str(LowestProb / MCCorrect)
        Pos = InStr(1, TStr, ",", vbBinaryCompare)
        If Pos > 0 Then Mid(TStr, Pos, 1) = "."
        Print #1, "-Maxkaglobalpval=" & TStr
    End If

    If GCSeqTypeFlag = 0 Then
        'Label29.Caption = "Automatic detection of sequence type"
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        'Label29.Caption = "Sequences are DNA"
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        'Label29.Caption = "Sequences are DNA coding region"
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        'Label29.Caption = "Sequences are protein"
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        'Label31.Caption = "Ignor indels"
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        'Label31.Caption = "Treat indel blocs as one polymorphism"
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        'Label31.Caption = "Treat each indel site as a polymorphism"
        Print #1, "-Use_individual_indels"
    End If

    

    If GCMonoSiteFlag = 0 Then
        'Label39.Caption = "Do not use monomorphic sites"
    Else
        'Label39.Caption = "Use monomorphic sites"
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)

    If GCOutFlag = 0 Then
        'Label27.Caption = "Space separated output"
        Print #1, "-Dumpfrag"
    ElseIf GCOutFlag = 1 Then
        'Label27.Caption = "Tab separated output"
        Print #1, "-Dumptab"
    ElseIf GCOutFlag = 2 Then
        'Label27.Caption = "DIF-format spreadsheet output"
        Print #1, "-Dumpdif"
    ElseIf GCOutFlag = 3 Then
        'Label27.Caption = "Output in all formats"
        Print #1, "-Dumpall"
    End If

    If GCOutFlagII = 0 Then
        'Label33.Caption = "Simple output"
        'Command29.Enabled = False
    Else
        'Label33.Caption = "Maximum output"
        Print #1, "/sb /sp  /sd -Show_maxmeansims -ShowUnal"
    End If

    If GCSortFlag = 0 Then
        'Label34.Caption = "Sort fragment lists by P-Value"
    ElseIf GCSortFlag = 1 Then
        'Label34.Caption = "Sort fragment lists alphabetically by name"
        Print #1, "-SortGfragsBySeq"
    ElseIf GCSortFlag = 2 Then
        'Label34.Caption = "Sort fragment lists by P-Value then name"
        Print #1, "-SortGfragsBoth"
    End If

    If GCEndLen > 0 Then
        Print #1, "-Dumpjseq -Jseqlen=" & GCEndLen
    End If

    If GCOffsetAddjust > 0 Then
        Print #1, "-AddOffset=" & GCOffsetAddjust
    End If

    If GCLogFlag = 0 Then
        'Label28.Caption = "Write log file"
    ElseIf GCLogFlag = 1 Then
        'Label28.Caption = "Append existing log file"
        Print #1, "-Logappend"
    ElseIf GCLogFlag = 2 Then
        'Label28.Caption = "Do not write log file"
        Print #1, "-Nolog"
    End If

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If

    Print #1, "-ListGlobal=" & GCMaxGlobFrags
    Print #1, "-ListPerPair=" & GCMaxPairFrags
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore
    Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    Print #1, "-Numsim=" & GCNumPerms

    If GCNumPerms > 0 Then
        Print #1, "-Maxsimglobalpval=" & GCMaxPermPVal

        If GCPermPolyFlag = 0 Then
            Print #1, "-Simp_poly_only"
        Else
            Print #1, "-Mult_poly_only"
        End If

    End If

    If MaskFlag = 1 Then
        'Listonly List
        LList$ = ""

        For x = 0 To NextNo

            If MaskSeq(x) = 0 Then

                For Y = x + 1 To NextNo

                    If MaskSeq(Y) = 0 Then
                        LList$ = LList$ + StraiName(x) + "," + StraiName(Y) + " "
                    End If

                Next 'Y

            End If

        Next 'X

        Print #1, "-Listonly=" + LList$
    End If

    'Print #1, "-Mult_poly_only"
    'Print #1, "/x"
    'GCGroupFlag = 1
    
    
    
    Close #1
    
    
    'RetVal = Shell(App.Path & "\geneconv tempfile", 1)   ' Run geneconv
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell("dbat.bat", 1))
    'hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, Shell(App.Path & "\geneconv tempfile  /n0 /mkg " & LowestProb & " /v9 -ExpFormat", 0))
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell("geneconv config.cfg", 0))
    
    
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub
Public Sub GCXoverE()
'this is the triplet scanning version of geneconv
Dim LSeq As Long, Y As Long, x As Long, SX As Long, NDiff() As Long, MissPen() As Double

LSeq = Len(StrainSeq(0))
'find relevant sites
ReDim XDiffPos(LSeq + 200)
ReDim XPosDiff(LSeq + 200)
Dim SubSeq() As Byte

ReDim SubSeq(LSeq, 6)
ReDim NDiff(5)
ReDim MissPen(5)
Y = 0
If GCMonoSiteFlag = 0 Then
    For x = 1 To LSeq
        XPosDiff(x) = Y
        If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
            If SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                SubSeq(Y, 0) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(x, Seq2) = SeqNum(x, Seq3)) / 255
            ElseIf GCIndelFlag = 1 Then
                SX = x
                x = x + 1
                Do While (SeqNum(x, Seq1) = 46 Or SeqNum(x, Seq2) = 46 Or SeqNum(x, Seq3) = 46) And x < LSeq
                    x = x + 1
                Loop
                x = x - 1
                Y = Y + 1
                XPosDiff(CLng(SX + (x - SX) / 2)) = Y
                XDiffPos(Y) = CLng(SX + (x - SX) / 2)
                SubSeq(Y, 0) = CByte(Mid$(StrainSeq(Seq1), SX, x - SX + 1) = Mid$(StrainSeq(Seq2), SX, x - SX + 1)) / 255
                SubSeq(Y, 1) = CByte(Mid$(StrainSeq(Seq1), SX, x - SX + 1) = Mid$(StrainSeq(Seq3), SX, x - SX + 1)) / 255
                SubSeq(Y, 2) = CByte(Mid$(StrainSeq(Seq2), SX, x - SX + 1) = Mid$(StrainSeq(Seq3), SX, x - SX + 1)) / 255
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                SubSeq(Y, 0) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(x, Seq2) = SeqNum(x, Seq3)) / 255
            End If
            SubSeq(Y, 6) = CByte((SubSeq(Y, 0) = 0 And SubSeq(Y, 1) = 0 And SubSeq(Y, 2) = 0)) / 255
        End If
        
    Next x
Else
    For x = 1 To LSeq
        XPosDiff(x) = Y
        'If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
            If SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                SubSeq(Y, 0) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(x, Seq2) = SeqNum(x, Seq3)) / 255
            ElseIf GCIndelFlag = 1 Then
                SX = x
                x = x + 1
                Do While (SeqNum(x, Seq1) = 46 Or SeqNum(x, Seq2) = 46 Or SeqNum(x, Seq3) = 46) And x < LSeq
                    x = x + 1
                Loop
                x = x - 1
                Y = Y + 1
                XPosDiff(CLng(SX + (x - SX) / 2)) = Y
                XDiffPos(Y) = CLng(SX + (x - SX) / 2)
                SubSeq(Y, 0) = CByte(Mid$(StrainSeq(Seq1), SX, x - SX) = Mid$(StrainSeq(Seq2), SX, x - SX)) / 255
                SubSeq(Y, 1) = CByte(Mid$(StrainSeq(Seq1), SX, x - SX) = Mid$(StrainSeq(Seq3), SX, x - SX)) / 255
                SubSeq(Y, 2) = CByte(Mid$(StrainSeq(Seq2), SX, x - SX) = Mid$(StrainSeq(Seq3), SX, x - SX)) / 255
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                SubSeq(Y, 0) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq2)) / 255
                SubSeq(Y, 1) = CByte(SeqNum(x, Seq1) = SeqNum(x, Seq3)) / 255
                SubSeq(Y, 2) = CByte(SeqNum(x, Seq2) = SeqNum(x, Seq3)) / 255
            End If
        'End If
        SubSeq(Y, 6) = CByte((SubSeq(Y, 0) = 0 And SubSeq(Y, 1) = 0 And SubSeq(Y, 2) = 0)) / 255
    Next x
End If

LenXoverSeq = Y
XDiffPos(Y + 1) = LSeq
For x = 1 To LenXoverSeq
    NDiff(0) = NDiff(0) + SubSeq(x, 0)
    NDiff(1) = NDiff(1) + SubSeq(x, 1)
    NDiff(2) = NDiff(2) + SubSeq(x, 2)
Next x

If NDiff(0) = LenXoverSeq Or NDiff(1) = LenXoverSeq Or NDiff(2) = LenXoverSeq Then Exit Sub

'for outer frags (ie matches instead of differences)
NDiff(3) = NDiff(0) + NDiff(1) 'seq1
NDiff(4) = NDiff(0) + NDiff(2)  'seq2
NDiff(5) = NDiff(1) + NDiff(2)  'seq3

'for inner fargs (ie genuine differences)
NDiff(0) = LenXoverSeq - NDiff(0)
NDiff(1) = LenXoverSeq - NDiff(1)
NDiff(2) = LenXoverSeq - NDiff(2)

MissPen(0) = Int(LenXoverSeq * GCMissmatchPen / NDiff(0)) + 1
MissPen(1) = Int(LenXoverSeq * GCMissmatchPen / NDiff(1)) + 1
MissPen(2) = Int(LenXoverSeq * GCMissmatchPen / NDiff(2)) + 1

MissPen(3) = Int(LenXoverSeq * GCMissmatchPen / NDiff(3)) + 1
MissPen(4) = Int(LenXoverSeq * GCMissmatchPen / NDiff(4)) + 1
MissPen(5) = Int(LenXoverSeq * GCMissmatchPen / NDiff(5)) + 1


'Calc LL and KMax
Dim LL() As Double, KMax() As Double, Q As Double, P As Double
ReDim LL(5)
ReDim KMax(5)

For x = 0 To 5
    LL(x) = 0
    
    If NDiff(x) > 0 And NDiff(x) < LenXoverSeq Then 'And MissPen(X) >= 1 And (MissPen(X) + 1) * ndiff(x) > lenxoverseq Then
    
        P = NDiff(x) / LenXoverSeq
        Q = 1 - P
        mP = MissPen(x) * P
        '/* If the mismatch penalty is infinite: */
        If GCMissmatchPen = 0 Then
            LL(x) = -Log(Q)
            KMax(x) = P
        Else
   
            '/* ll and kmax depend only on MissPen(X), ndiff(x), and lenxoverseq: */
            '/*   Have we seen these values before? */
            'Maybe I should work out a way to fill an array with these values and
            'look them up - array dims would be MissPen(X),lenxoverseq,ndiff(x)f
            '/* Use the Newton-Raphson method to compute ll by solving   */
            '/*                                                   */
            '/*    phi(ll) = q*exp(ll)+p*exp(-MissPen(X)*ll) = 1,  ll>0   */
            '/*                                                   */
            '/* Note  phi(0)=1 and phi'(0) = 1-(MissPen(X)+1)*p < 0,      */
            '/*    which should guarantees a solution  ll>0       */
            '/*                                                   */
            '/* The global minimum of phi(ll) is at ll0=log(mp/q)/(MissPen(X)+1)   */
    
            k = 0
            LL0 = Log(mP / Q) / (MissPen(x) + 1)
            Z = Exp(2 * LL0)
            Do
                
                ZM = Z ^ (-MissPen(x))
                Yy = Q * Z + P * ZM - 1
                ZDel = Yy / (Q - mP * ZM / Z)
                Z = Z - ZDel
                
            Loop While (Abs(ZDel) > 0.000001 Or Abs(Yy) > 0.000001)
    
            LL(x) = Log(Z)
            KMax(x) = (Exp(LL(x)) - 1) * (Q - mP * Exp(-(MissPen(x) + 1) * LL(x)))
       End If
    End If
Next x

'Find fragment lists
Dim FragSep() As Long, FragCount() As Long, FragSt() As Long, FragEn() As Long, FragScore() As Long

ReDim FragSt(LenXoverSeq, 6)
ReDim FragEn(LenXoverSeq, 6)
ReDim FragScore(LenXoverSeq, 6)
ReDim MFragSt(LenXoverSeq, 6)
ReDim MFragEn(LenXoverSeq, 6)
ReDim MFragScore(LenXoverSeq, 6)

ReDim FragCount(6)
ReDim MFragCount(6)
'Find Fragments
For x = 1 To LenXoverSeq
    
    For Y = 0 To 2
        If SubSeq(x, Y) = 1 Then Exit For
    Next Y
    If Y = 3 Then
        Y = 6
    End If
    FragSt(FragCount(Y), Y) = x
    x = x + 1
    Do While SubSeq(x, Y) = 1 And x <= LenXoverSeq
        x = x + 1
    Loop
    x = x - 1
    If x > LenXoverSeq Then
        'sort out frags that overlap the ends
    End If
    FragEn(FragCount(Y), Y) = x
    FragScore(FragCount(Y), Y) = FragEn(FragCount(Y), Y) - FragSt(FragCount(Y), Y) + 1
        'If Y <= 2 Then
             For Z = 0 To 2
                 If Y <> Z Then
                     FragSt(FragCount(Z), Z) = FragSt(FragCount(Y), Y)
                     FragEn(FragCount(Z), Z) = FragEn(FragCount(Y), Y)
                     FragScore(FragCount(Z), Z) = -FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                     FragCount(Z) = FragCount(Z) + 1
                 End If
             Next Z
        ' End If
        If Y = 0 Then
            Z = 5
        ElseIf Y = 1 Then
            Z = 4
        ElseIf Y = 2 Then
            Z = 3
        ElseIf Y = 6 Then
            Z = 6
        End If
        If Z < 6 Then
            
            If FragCount(Z) > 0 Then
                If FragScore(FragCount(Z) - 1, Z) > 0 Then
                    
                    FragEn(FragCount(Z) - 1, Z) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(Z) - 1, Z) = FragScore(FragCount(Z) - 1, Z) + FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    
                Else
                    FragSt(FragCount(Z), Z) = FragSt(FragCount(Y), Y)
                    FragEn(FragCount(Z), Z) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(Z), Z) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    FragCount(Z) = FragCount(Z) + 1
                End If
            Else
                FragSt(FragCount(Z), Z) = FragSt(FragCount(Y), Y)
                FragEn(FragCount(Z), Z) = FragEn(FragCount(Y), Y)
                FragScore(FragCount(Z), Z) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                FragCount(Z) = FragCount(Z) + 1
            End If
            
            For A = 3 To 5
                If A <> Z Then
                    FragSt(FragCount(A), A) = FragSt(FragCount(Y), Y)
                    FragEn(FragCount(A), A) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(A), A) = -FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    FragCount(A) = FragCount(A) + 1
                End If
            Next A
        Else
            If FragCount(3) > 0 Then
                For A = 3 To 5
                    If FragScore(FragCount(A) - 1, A) > 0 Then
                            
                        FragEn(FragCount(A) - 1, A) = FragEn(FragCount(Y), Y)
                        FragScore(FragCount(A) - 1, A) = FragScore(FragCount(A) - 1, A) + FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                            
                    Else
                        FragSt(FragCount(A), A) = FragSt(FragCount(Y), Y)
                        FragEn(FragCount(A), A) = FragEn(FragCount(Y), Y)
                        FragScore(FragCount(A), A) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                        FragCount(A) = FragCount(A) + 1
                    End If
                Next A
            Else
                For A = 3 To 5
                    FragSt(FragCount(A), A) = FragSt(FragCount(Y), Y)
                    FragEn(FragCount(A), A) = FragEn(FragCount(Y), Y)
                    FragScore(FragCount(A), A) = FragScore(FragCount(Y), Y) '* (MissPen(Z) + 1)
                    FragCount(A) = FragCount(A) + 1
                Next A
            End If
        End If
            
        If Y <= 2 Then
            FragCount(Y) = FragCount(Y) + 1
        End If
        FragCount(6) = FragCount(6) + 1
    
    
Next x

For x = 0 To 6
    FragSt(FragCount(x), x) = LenXoverSeq
    FragEn(FragCount(x), x) = LenXoverSeq
Next x

Dim FragMaxScore() As Long, MaxScorePos() As Long, TempScore As Long
ReDim FragMaxScore(LenXoverSeq, 5), MaxScorePos(LenXoverSeq, 5)
If GCMissmatchPen > 0 And x = x Then

    'Find the max score per frag by joing up frags, basically start at leftmost frag and
    'expand right, finding the max score including that frag -these are inner frags
    Dim Polys As Long, Diffs As Long
    
    If CircularFlag = 0 Then
        For x = 0 To 5
            For Y = 0 To FragCount(x)
                If FragScore(Y, x) > 0 Then
                 
                  TempScore = FragScore(Y, x)
                  Polys = TempScore
                  Diffs = 0
                  FragMaxScore(Y, x) = TempScore
                  MaxScorePos(Y, x) = Y
                  For Z = Y + 1 To FragCount(x)
                    Polys = Polys + Abs(FragScore(Z, x))
                    If FragScore(Z, x) <= 0 Then
                        Diffs = Diffs + Abs(FragScore(Z, x))
                    End If
                    
                    TempScore = Polys - Diffs + Diffs * (-MissPen(x))
                    
                    If TempScore >= FragMaxScore(Y, x) Then
                        FragMaxScore(Y, x) = TempScore
                        MaxScorePos(Y, x) = Z
                    ElseIf TempScore < -15 Then
                        Exit For
                    End If
                  Next Z
                End If
            Next Y
        Next x
    Else
        For x = 0 To 5
            For Y = 0 To FragCount(x)
                If FragScore(Y, x) > 0 Then
                  TempScore = FragScore(Y, x)
                  Polys = TempScore
                  Diffs = 0
                  FragMaxScore(Y, x) = TempScore
                  
                  For Z = Y + 1 To FragCount(x)
                    Polys = Polys + Abs(FragScore(Z, x))
                    If FragScore(Z, x) < 0 Then
                        Diffs = Diffs + Abs(FragScore(Z, x))
                    End If
                    
                    TempScore = Polys - Diffs + Diffs * (-MissPen(x))
                    
                    If TempScore >= FragMaxScore(Y, x) Then
                        FragMaxScore(Y, x) = TempScore
                        MaxScorePos(Y, x) = Z
                    ElseIf TempScore < -10 Then
                        Exit For
                    End If
                  Next Z
                    If TempScore > -10 Then
                        For Z = 0 To Y - 1
                          Polys = Polys + Abs(FragScore(Z, x))
                          If FragScore(Z, x) < 0 Then
                              Diffs = Diffs + Abs(FragScore(Z, x))
                          End If
                          
                          TempScore = Polys - Diffs + Diffs * (-MissPen(x))
                          
                          If TempScore >= FragMaxScore(Y, x) Then
                              FragMaxScore(Y, x) = TempScore
                              MaxScorePos(Y, x) = Z
                          ElseIf TempScore < -10 Then
                              Exit For
                          End If
                        Next Z
                    End If
                End If
            Next Y
        Next x
    End If
Else
    For x = 0 To 5
        For Y = 0 To FragCount(x)
            FragMaxScore(Y, x) = FragScore(Y, x)
            MaxScorePos(Y, x) = Y
        Next Y
    Next x
End If


Dim PVals() As Double, KAScore As Double, PVal As Double, MaxScore As Double, MaxY As Long, LKLen As Double
ReDim PVals(LenXoverSeq, 5)
Addon = 0
For x = 0 To 5
    MaxScore = 0
    
    'LKLen = Log(KMax(X) * NDiff(X))
    LKLen = Log(KMax(x) * LenXoverSeq)
    
    For Y = 0 To FragCount(x)
     
        
        
        KAScore = LL(x) * FragMaxScore(Y, x) - LKLen
        PVals(Y, x) = 1 - Exp(-Exp(-KAScore))
        'PVals(Y, X) = 1 - Exp(-KMax(X) * NDiff(X) * Exp(-(LL(X) * FragMaxScore(Y, X))))
        If FragMaxScore(Y, x) > MaxScore Then MaxScore = FragMaxScore(Y, x)
        
    Next Y
Next x
MaxScore = 10000
For x = 0 To 5
    For Y = 0 To FragCount(x)
        If MaxScore > PVals(Y, x) Then
            MaxScore = PVals(Y, x)
        End If
    Next Y
Next x
If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection

MaxScore = -Log10(CDbl(MaxScore))
If MaxScore <= 0 Then MaxScore = 5
DoAxes 0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MaxScore), 0, 1, "-Log(KA P-Val)"
Call Highlight(0)
For x = 0 To 5
    
    If x = 0 Then
        Form1.Picture7.ForeColor = Yellow
    ElseIf x = 1 Then
        Form1.Picture7.ForeColor = Green
    ElseIf x = 2 Then
        Form1.Picture7.ForeColor = Purple
    ElseIf x = 3 Then
        Form1.Picture7.ForeColor = Purple
    ElseIf x = 4 Then
        Form1.Picture7.ForeColor = Green
    ElseIf x = 5 Then
        Form1.Picture7.ForeColor = Yellow
    End If
    For Y = 0 To FragCount(x)
        If FragSt(Y, x) > 0 Then
            
            
            'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
            If PVals(Y, x) < 0.9995 Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                Prob = -Log10(CDbl(PVals(Y, x)))
                Beginning = XDiffPos(FragSt(Y, x) - 1) + 1
                Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x) + 1) - 1
                
                X1 = 30 + Decompress(Beginning) * XFactor + XFactor
                X2 = 30 + Decompress(Ending) * XFactor + XFactor
                
                
                'MCPrintData(0, CurPPos) = Prob
                'MCPrintPos(0, CurPPos, 0) = Beginning
                'MCPrintPos(0, CurPPos, 1) = Ending
                'CurPPos = CurPPos + 1
                Y1 = PicHeight - (15 + (Prob / MaxScore) * (PicHeight - 35))
                Y2 = PicHeight - 15
                Form1.Picture7.AutoRedraw = True
                Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
            End If
        Else
            Exit For
        End If
    Next Y
Next x

End Sub
Public Sub FindSubSeqGC2()

Dim Z As Long, SX As Long, Y As Long, x As Long
ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
ReDim GCXOverSeq(2)
Y = 0

Dim tGCXoverseq0 As String, tGCXoverseq1 As String, tGCXoverseq2 As String

tGCXoverseq0 = String(Len(StrainSeq(0)), " ")
tGCXoverseq1 = String(Len(StrainSeq(0)), " ")
tGCXoverseq2 = String(Len(StrainSeq(0)), " ")

UB = UBound(StrainSeq, 1)

If Seq1 > UBound(SeqNum, 2) Or Seq2 > UBound(SeqNum, 2) Or Seq3 > UBound(SeqNum, 2) Then
    Exit Sub
End If
If GCMonoSiteFlag = 0 Then
    For x = 1 To Len(StrainSeq(0))
        
        XPosDiff(x) = Y
        If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
            If SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46 Then
                Y = Y + 1
                XPosDiff(x) = Y '3152-36
                XDiffPos(Y) = x
                If UB > 0 Then
'                    If TreeTrace(Seq1) > UBound(StrainSeq, 1) Or TreeTrace(Seq2) > UBound(StrainSeq, 1) Or TreeTrace(Seq3) > UBound(StrainSeq, 1) Then
'                        ScDME = XOverList(RelX, RelY).Ending: ScDMB = XOverList(RelX, RelY).Beginning
'                    '652
'
'                        Call ModSeqNum(CLng(ScDMB), CLng(ScDME), 0)
'                    End If
                    Mid(tGCXoverseq0, Y, 1) = Chr(SeqNum(Y, TreeTrace(Seq1)) - 1)
                    Mid(tGCXoverseq1, Y, 1) = Chr(SeqNum(Y, TreeTrace(Seq2)) - 1)
                    Mid(tGCXoverseq2, Y, 1) = Chr(SeqNum(Y, TreeTrace(Seq3)) - 1)
                    x = x
                End If
            ElseIf GCIndelFlag = 1 Then
                SX = x
                x = x + 1
                
                If x < Len(StrainSeq(0)) Then
                    Do While x <= Len(StrainSeq(0))
                        If (SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46) Then
                            Exit Do
                        End If
                        x = x + 1
                    Loop
                End If
                x = x - 1
                Y = Y + 1
                
                If SX <> x Then
                    'XX = UBound(StrainSeq, 1)
                    For Z = SX To x
                            If SeqNum(Z, Seq1) <> 46 Or SeqNum(Z, Seq2) <> 46 Or SeqNum(Z, Seq3) <> 46 Then
                                XDiffPos(Y) = Z
                                XPosDiff(Z) = Y
                                If UB > 0 Then
                                    Mid(tGCXoverseq0, Y, 1) = Mid(StrainSeq(TreeTrace(Seq1)), Z, 1)
                                    Mid(tGCXoverseq1, Y, 1) = Mid(StrainSeq(TreeTrace(Seq2)), Z, 1)
                                    Mid(tGCXoverseq2, Y, 1) = Mid(StrainSeq(TreeTrace(Seq3)), Z, 1)
                                End If
                                Exit For
                            End If
                    Next Z
                    
                Else
                    XPosDiff(x) = Y
                    XDiffPos(Y) = x
                    If UB > 0 Then
                        Mid(tGCXoverseq0, Y, 1) = Mid(StrainSeq(TreeTrace(Seq1)), x, 1)
                        Mid(tGCXoverseq1, Y, 1) = Mid(StrainSeq(TreeTrace(Seq2)), x, 1)
                        Mid(tGCXoverseq2, Y, 1) = Mid(StrainSeq(TreeTrace(Seq3)), x, 1)
                    End If
                End If
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                If UB > 0 Then
                    Mid(tGCXoverseq0, Y, 1) = Mid(StrainSeq(TreeTrace(Seq1)), x, 1)
                    Mid(tGCXoverseq1, Y, 1) = Mid(StrainSeq(TreeTrace(Seq2)), x, 1)
                    Mid(tGCXoverseq2, Y, 1) = Mid(StrainSeq(TreeTrace(Seq3)), x, 1)
                End If
            End If
        End If
        
    Next x
    GCXOverSeq(0) = Trim(tGCXoverseq0)
    GCXOverSeq(1) = Trim(tGCXoverseq1)
    GCXOverSeq(2) = Trim(tGCXoverseq2)
Else
    GCXOverSeq(0) = StrainSeq(TreeTrace(Seq1))
    GCXOverSeq(1) = StrainSeq(TreeTrace(Seq2))
    GCXOverSeq(2) = StrainSeq(TreeTrace(Seq3))
    For x = 1 To Len(StrainSeq(0))
        XPosDiff(x) = Y
        'If SeqNum(X, Seq1) <> SeqNum(X, Seq2) Or SeqNum(X, Seq1) <> SeqNum(X, Seq3) Then
            If SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
                
            ElseIf GCIndelFlag = 1 Then
                SX = x
                x = x + 1
                Do While (SeqNum(x, Seq1) = 46 Or SeqNum(x, Seq2) = 46 Or SeqNum(x, Seq3) = 46) And x < Len(StrainSeq(0))
                    x = x + 1
                Loop
                x = x - 1
                Y = Y + 1
                XPosDiff(CLng(SX + (x - SX) / 2)) = Y
                XDiffPos(Y) = CLng(SX + (x - SX) / 2)
            ElseIf GCIndelFlag = 2 Then
                Y = Y + 1
                XPosDiff(x) = Y
                XDiffPos(Y) = x
            End If
        'End If
    Next x
End If

LenXoverSeq = Y
XDiffPos(Y + 1) = Len(StrainSeq(0))
End Sub
Public Sub GCXoverD(FindallFlag)

Dim NumInList As Long, lP As Single, Dummy As Variant, Y1 As Long, Y2 As Long, X1 As Long, X2 As Long, Prob As Variant, COff As Variant, Ac As Long, tMi As Long, tMa As Long
Dim SIP As Long, GG As Long, b As Long, ETarget As Long, BTarget As Long, A As Long, Z As Long, BEE As Long, ENN As Long, EWarn As Byte, BWarn As Byte, LastMPV As Double, GoOn As Byte, ZZZXZ As Long, SplitX As Long
Dim PBinFlag As Long
Dim Y As Long, x As Long
' For x = 0 To UBound(SubSeq, 1)
'    For Y = 0 To 6
'        If SubSeq(x, Y) <> 0 Then
'            x = x
'        End If
'    Next Y
' Next x
'ReDim SubSeq(Len(StrainSeq(0)), 6)

PBinFlag = -1

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If
If (PermDIffs(Seq1, Seq2) < 3 Or PermDIffs(Seq1, Seq3)) < 3 Or PermDIffs(Seq2, Seq3) < 3 Then
    If CLine = "" Or CLine = " " Then
        Exit Sub
    End If
End If
'this is the auto triplet scanning version of geneconv
Dim Beginning As Long, Ending As Long, DoneRedo As Byte, LTG As Single, Critval(5) As Double, PVM1 As Double, KMTL As Double
Dim LSeq As Long, SX As Long, NDiff() As Long, MissPen() As Double, MissPenB() As Single
Dim MaxX As Long, MaxY As Long, MPV As Double
Dim TempScore As Long
Dim ProbabilityXOver As Double
Dim KAScore As Variant, PVal As Double, MaxScore As Double, LKLen As Double
Dim Polys As Long, Diffs As Long
Dim FragSep() As Long, FragCount(6) As Long
Dim MaxDiff As Long
Dim MinDiff As Long
Dim FragMinScore As Long, tPX As Double
Dim LL(5) As Double, KMax(5) As Double, Q As Double, P As Double, mX As Long
Dim DoneThis As Byte, b1 As Long, E1 As Long
Dim PCO As Double
'
LSeq = Len(StrainSeq(0))


'XX = FragScore(121, 0)
'XX = FragScore(121, 1)
'XX = FragScore(121, 2)
'XX = FragScore(0, 3)
'XX = FragScore(106, 4)
'XX = FragScore(106, 5)
' 1.000 5k perms
'2.766 5k perms


ReDim NDiff(5)
'find relevant sites


'@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$
If UseCompress = 1 And GCIndelFlag = 0 Then
'    Dim XPosDiff2() As Long, XDiffPos2() As Long
'    ReDim XPosDiff2(UBound(XPosDiff)), XDiffPos2(UBound(XDiffPos))
'    ReDim XPosDiff(UBound(XPosDiff)), XDiffPos(UBound(XDiffPos))
'
    LenXoverSeq = FindSubSeqGCAP7(UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSGC, 2), FSSGC(0, 0, 0, 0), GCIndelFlag, LSeq, Seq1, Seq2, Seq3, SubSeq(0, 0), NDiff(0), XDiffPos(0), XPosDiff(0))

Else
    LenXoverSeq = FindSubSeqGCAP(GCIndelFlag, LSeq, Seq1, Seq2, Seq3, SeqNum(0, 0), SubSeq(0, 0), XPosDiff(0), XDiffPos(0), NDiff(0))
End If

'For x = 0 To LSeq
'    If XPosDiff(x) <> XPosDiff2(x) Then
'        x = x
'    End If
'    If XDiffPos(x) <> XDiffPos2(x) Then
'        x = x
'    End If
'Next x


If NDiff(0) = LenXoverSeq Or NDiff(1) = LenXoverSeq Or NDiff(2) = LenXoverSeq Then
    'If UseCompress = 1 And GCIndelFlag = 0 Then
    Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
    'End If
    Exit Sub
End If

'2.223
'1.883
'lxo = 349,n0=250,1=39,2=49,3=289,4=299,5=88

'XDiffPos(LenXOverSeq + 1) = LSeq
'
'Y = XDiffPos(LenXOverSeq) + 1
'
'For X = Y To LSeq
'    XPosDiff(X) = LenXOverSeq
'Next

SubSeq(LenXoverSeq + 1, 0) = 0
SubSeq(LenXoverSeq + 1, 1) = 0
SubSeq(LenXoverSeq + 1, 2) = 0
SubSeq(LenXoverSeq + 1, 6) = 0

HiFragScore(0) = 0
HiFragScore(1) = 0
HiFragScore(2) = 0
HiFragScore(3) = 0
HiFragScore(4) = 0
'
HiFragScore(5) = 0

'for outer frags (ie matches instead of differences)
NDiff(3) = NDiff(0) + NDiff(1) 'seq1
NDiff(4) = NDiff(0) + NDiff(2)  'seq2
NDiff(5) = NDiff(1) + NDiff(2)  'seq3

'@
'for inner fargs (ie genuine differences)
NDiff(0) = LenXoverSeq - NDiff(0)
NDiff(1) = LenXoverSeq - NDiff(1)
NDiff(2) = LenXoverSeq - NDiff(2)

LTG = LenXoverSeq * GCMissmatchPen


ReDim MissPen(5)
'ltg=349

MissPen(0) = Int(LTG / NDiff(0)) + 1
MissPen(1) = Int(LTG / NDiff(1)) + 1
MissPen(2) = Int(LTG / NDiff(2)) + 1
'mpen = 4,2,2
MaxDiff = 0
MinDiff = LSeq
'
For x = 0 To 5
    If MinDiff > NDiff(x) Then MinDiff = NDiff(x)
    If MaxDiff < NDiff(x) Then MaxDiff = NDiff(x)
    
Next x

If MinDiff < 3 And MaxDiff > MinDiff * 10 Then
    'If UseCompress = 1 And GCIndelFlag = 0 Then
        Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
    'End If
    Exit Sub
End If

If NDiff(3) = 0 Then NDiff(3) = 1
If NDiff(4) = 0 Then NDiff(4) = 1
If NDiff(5) = 0 Then NDiff(5) = 1

MissPen(3) = Int(LTG / NDiff(3)) + 1

MissPen(4) = Int(LTG / NDiff(4)) + 1
MissPen(5) = Int(LTG / NDiff(5)) + 1

'ReDim MissPenB(5)
'MissPenB(0) = MissPen(0)
'MissPenB(1) = MissPen(1)
'MissPenB(2) = MissPen(2)
'MissPenB(3) = MissPen(3)
'MissPenB(4) = MissPen(4)
'MissPenB(5) = MissPen(5)
'ReDim FragMaxScore(gcdimsize, 5)
'                ReDim MaxScorePos(gcdimsize, 5)
'                ReDim PVals(gcdimsize, 5)
'                ReDim FragSt(gcdimsize, 6)
'                ReDim FragEn(gcdimsize, 6)
'                ReDim FragScore(gcdimsize, 6)

'1.962
'1.563 desktop

'Find Fragments

'GoOn = GetFrags(CircularFlag, LenXOverSeq, Len(StrainSeq(0)), GCDimSize, SubSeq(0, 0), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))
''''''''''
'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'$
'SS = abs(gettickcount)
'For x = 0 To 500000
'    For Y = 0 To 6
'        FragCount(Y) = 0
'    Next Y
'$'$'$'$'$'$'$'$'$'$'$'$
GoOn = GetFragsP(CircularFlag, LenXoverSeq, LSeq, GCDimSize, SubSeq(0, 0), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))
'Next x
'EE = abs(gettickcount)
'TT = EE - SS


If GoOn = 0 And ShortOutFlag <> 3 Then
    'If UseCompress = 1 And GCIndelFlag = 0 Then
    Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
    'End If
    Exit Sub
End If

'For X = 0 To 6
'    FragSt(FragCount(X), X) = LenXOverSeq
'    FragEn(FragCount(X), X) = LenXOverSeq
'Next X

If x = x Then
    
    
    'GetMaxFragScoreB LenXOverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPenB(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    'getmaxfragscore LenXOverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    '''''''
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'$'$'$'$'$'$'$'$'$
    GetMaxFragScoreP LenXoverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    '
    x = x
    
Else
        GetMaxFragScoreB LenXoverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)

'    For X = 0 To 5
'
'        'need to change this to just sum fragments from one end of the genome component to the other
'
'        'HiScore(X) = 0
'        'os3 = X*os2;
'        MPen = MissPen(X)
'        For Y = 0 To FragCount(X)
'            FragMaxScore(Y, X) = 0
'            If FragScore(Y, X) > 0 Then
'
'                TempScore = FragScore(Y, X)
'                TS = TempScore
'                Polys = TS
'                Diffs = 0
'                FragMaxScore(Y, X) = TS
'
'                MaxScorePos(Y, X) = Y
'
'                For Z = Y + 1 To FragCount(X)
'                    FS = Abs(FragScore(Z, X))
'                    Polys = Polys + FS
'
'                    If FragScore(Z, X) <= 0 Then
'                        Diffs = Diffs + FS
'                    End If
'
'                    TempScore = (Polys - Diffs) - (Diffs * MPen)
'                    TS = CInt(TempScore)
'
'                    If TS >= FragMaxScore(Y, X) Then
'                        FragMaxScore(Y, X) = TS
'                        MaxScorePos(Y, X) = Z
'
'                    ElseIf TS < 0 Then
'                        Exit For
'                    End If
'
'                Next Z
'            '    If FragMaxScore(Y, X) > HiScore(X) Then
'            '        HiScore(X) = FragMaxScore(Y, X)
'            '    End If
'            End If
'        Next Y
'    Next X
    
End If
''Exit Sub

'11.877,11.827
'11.1126 - using offsets
'11.026,11.036 - using offsets in maxfragscore rather than a holder.

'5.671, 5.656 -desktop

'This could be encorporated into getmaxfragscore - highfragscore could be set to zero if below the cutoff an passed to calkmax - there is also another higenough test later in the code that could be avoided
'highenough used in gccalpval and gcgethipval
For x = 0 To 5
    If HiFragScore(x) > 3 Then
        HighEnough(x) = 1
    Else
        HighEnough(x) = 0
    End If
Next x


'Calc LL and KMax

'GoOn = CalcKMaxP(GCMissmatchPen, LenXOverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), CritVal(0), MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))

'5.688,5.687


'//(log(kmax*lenxoverseq)-log(-log(1-pval)))/ll(x) = score
'calculate critical fragment length



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Maybe port this bit to c++

'Exit Sub
''$
'If X = 12345 Then ' this bit has to be uncommented if i need to go back to using calkkmax
    GoOn = CalcKMaxP(GCMissmatchPen, LenXoverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), Critval(0), MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))
'Else
'    GoOn = CalcKMax(GCMissmatchPen, LenXOverSeq, MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))
'    If MCFlag = 0 Then
'        PCO = LowestProb / MCCorrection
'    Else
'        PCO = LowestProb
'    End If
'
'    If PCO > 1 Then
'        Exit Sub
'    End If
'
'
'
'    For X = 0 To 5
'        If KMax(X) > 0 Then
'            KMTL = KMax(X) * LenXOverSeq
'
'            KMTL = Log(KMTL)
'
'            PVM1 = (1 - PCO)
'
'            If PVM1 > 0 Then
'                PVM1 = -Log(PVM1)
'
'                If PVM1 > 0 Then
'                    PVM1 = -Log(PVM1)
'                    CritVal(X) = (KMTL + PVM1) / LL(X)
'                    If CritVal(X) < 4 Then CritVal(X) = 4
'                Else
'                    CritVal(X) = 4
'                End If
'            Else
'                CritVal(X) = 4
'            End If
'        End If
'    Next X
'
'    GoOn = 0
'    For X = 0 To 5
'        HighEnough(X) = 0
'        If HiFragScore(X) > 3 And HiFragScore(X) > CritVal(X) Then
'            HighEnough(X) = 1
'            GoOn = 1
'        End If
'    Next X
'End If
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

If GoOn = 0 Then
    'If UseCompress = 1 And GCIndelFlag = 0 Then
    Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
    'End If
    Exit Sub
End If


'5.813,5.828

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''GCCalcPValP gives a different result to this version - it may be correct but I've gone with the older one
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'@'$
MaxScore = GCCalcPValP(GCDimSize, LenXoverSeq, FragMaxScore(0, 0), PVals(0, 0), FragCount(0), KMax(0), LL(0), HighEnough(0), Critval(0))

'5.906,5.844

If ShortOutFlag = 3 Then
    If MaxScore * MCCorrection <= mtP(1) Then
        mtP(1) = MaxScore * MCCorrection
        
    End If
End If


If MaxScore > PCO Then
    'If UseCompress = 1 And GCIndelFlag = 0 Then
    Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
    'End If
    Exit Sub
End If

If MCFlag = 0 Then
    Dim MSS As Double
    MSS = MaxScore * MCCorrection
    If MSS >= StoreLPV(1, Seq1) And MSS >= StoreLPV(1, Seq2) And MSS >= StoreLPV(1, Seq3) Then
       'XX = CurrentXOver(0)
       Call AddToRedoList(1, Seq1, Seq2, Seq3)
       Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
       Exit Sub
    End If
End If



Dummy = ClearDeleteArray(LenXoverSeq + 1, DeleteArray(0))

DoneThis = 0
ZZZXZ = 0
'Exit Sub


Do
    '@
    LastMPV = MPV
    'XX = CSng(MPV)
    'MPV = 0
'    If UBound(PVals, 1) <> GCDimSize Then
'    X = X
'    End If
'    For X = 0 To 6
'        If FragCount(X) > GCDimSize Then
'            X = X
'        End If
'    Next X
'If LenXoverSeq = 1683 Then
'    X = X
'End If
'@'@'@'$
    MPV = GCGetHiPValP(GCDimSize, LenXoverSeq, FragCount(0), PVals(0, 0), MaxY, MaxX, HighEnough(0))
    
'     If Seq1 = 36 And Seq2 = 52 And Seq3 = 85 And SEventNumber = 17 Then
'        X = X
'    End If




    
    ZZZXZ = ZZZXZ + 1
    
    'The limit was 100 and not 10 - 100 would possibly be better in some cases'but 10 will always be ~30% faster
    If MPV = LastMPV And ZZZXZ > 10 Then
        'If UseCompress = 1 And GCIndelFlag = 0 Then
        Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
        'End If
        Exit Sub
    End If
    
    '10.425,10.735
    '9.974
   ' If zzzxz = 1 And Seq1 = 16 And Seq3 = 38 And Seq2 = 24 And SEventNumber = 2 Then
   '     X = X
   ' End If
    
    If MPV > PCO Or MPV = 1 Then
        'If UseCompress = 1 And GCIndelFlag = 0 Then
        Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
        'End If
        Exit Sub
    End If
    x = MaxX
    Y = MaxY
    
    '$'$
    GoOn = DelPValsP(GCMaxOverlapFrags, Y, x, GCDimSize, PVals(0, 0), FragCount(0), FragSt(0, 0), FragEn(0, 0), MaxScorePos(0, 0), DeleteArray(0))
    
    If GoOn = 1 Then
        
        
        
        'For Y = 0 To FragCount(X)
            'If FragSt(Y, X) > 0 Then
                
                
                'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
                If PVals(Y, x) < PCO Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                    
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 Then
                                
                                    Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 2
                                
                                End If
                                
                            End If
                        End If
                    End If
                    
                    If FragSt(Y, x) > 0 Then
                        If LongWindedFlag = 0 Then
                            Beginning = XDiffPos(FragSt(Y, x) - 1) + 1
                        Else
                             
                            Beginning = XDiffPos(FragSt(Y, x))
                        End If
                    Else
                        Beginning = 1
                    End If
                    If LongWindedFlag = 0 Then
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x) + 1) - 1
                    Else
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x))
                    End If
                    
                    'DontWorryAboutSplitsFlag = 1
                    If LongWindedFlag = 1 Then
                        If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                           
                        ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                            
                        ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                           
                            
                        ElseIf StoreLPV(1, Seq1) >= StoreLPV(1, Seq2) And StoreLPV(1, Seq1) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq2) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq2) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq3) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq3) >= StoreLPV(1, Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                        If MCFlag = 0 Then
                            ProbabilityXOver = PVals(Y, x) * MCCorrection
                        Else
                            ProbabilityXOver = PVals(Y, x)
                        End If
                        If ProbabilityXOver > StoreLPV(1, ActiveSeq) Then
                            Call AddToRedoList(1, Seq1, Seq2, Seq3)
                            Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
                            Exit Sub
                         End If
                        
                        'check to see if an event has been extended accross a tract of
                        'missing data
                         SplitX = 0
                         EWarn = 0
                         BWarn = 0
                        If XPosDiff(Beginning) > 0 Then
                            BEE = XDiffPos(XPosDiff(Beginning) - 1)
                        Else
                            BEE = Beginning
                        End If
                        If XDiffPos(Ending) < LSeq Then
                            ENN = XDiffPos(XPosDiff(Ending) + 1)
                        Else
                            ENN = Ending
                        End If
                        If BEE < 1 Then BEE = LSeq
                        If ENN > LSeq Then ENN = 1
                        '$
                        If DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                            Z = CheckSplitP(10, LSeq, BEE, ENN, Seq1, Seq2, Seq3, SplitX, MissingData(0, 0))
                        Else
                            Z = Len(StrainSeq(0))
                        End If
                    Else
                        SplitX = 0
                        If x = 0 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 1 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq2
                        ElseIf x = 2 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq1
                        ElseIf x = 3 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 4 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf x = 5 Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq1
                        End If
                    End If
                    'SplitX = 0
                    'If X >= 3 Then SplitX = 0
                    
                    If SplitX = 1 And x < 3 Then
                        For A = 0 To 1
                            If A = 0 Then
                                BTarget = XPosDiff(Beginning)
                                
                                ETarget = XPosDiff(Z) - 1
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                            Else
                                '$
                                b = FindMissingP(LSeq, Seq1, Seq2, Seq3, Z, Ending, MissingData(0, 0))
                                If XPosDiff(b) <> 0 Then
                                    BTarget = XPosDiff(b) + 1
                                Else
                                    GG = b
                                    
                                    Do While XPosDiff(GG) = 0
                                        GG = GG + 1
                                        
                                        If GG > LSeq Then
                                            GG = 0
                                            
                                        End If
                                    Loop
                                    BTarget = XPosDiff(GG)
                                End If
                                ETarget = XPosDiff(Ending)
                                
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                            End If
                            
                            ProbabilityXOver = MakeSubProbP(x, LSeq, LenXoverSeq, BTarget, ETarget, SubSeq(0, 0), LL(0), KMax(0), MissPen(0), Critval(0))
                            If ProbabilityXOver < PCO Then
                            '3.8621
                                If MCFlag = 0 Then
                                    ProbabilityXOver = ProbabilityXOver * MCCorrection
                                End If
                                If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                
                                
                                    
                                
                                    'Keep track of signal numbers
                                    oRecombNo(100) = oRecombNo(100) + 1
                                    oRecombNo(1) = oRecombNo(1) + 1
                                    If APermFlag = 0 Then
                                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                                    Else
                                        SIP = 1
                                    End If
                                        
                                    If MCFlag = 2 Then
                                        lP = -Log10(CDbl(ProbabilityXOver)) * 2
                                        If lP > 0 And lP < 100 Then
                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                        ElseIf CInt(lP) >= 100 Then
                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                        End If
                                    End If
                                    'if p high eough then add it to list, if not discard then repeat from Z to en.
                                    ActualFound = 1
                                    NewOneFound = 1
                                    If SIP > 0 Then
                                        Beginning = XDiffPos(BTarget)
                                        Ending = XDiffPos(ETarget)
                                        If ActiveSeq > UBound(XoverList, 1) Then
                                            'If UseCompress = 1 And GCIndelFlag = 0 Then
                                            Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
                                            'End If
                                            Exit Sub
                                        
                                        End If
                                        XoverList(ActiveSeq, SIP).Beginning = Beginning
                                        XoverList(ActiveSeq, SIP).Ending = Ending
                                        XoverList(ActiveSeq, SIP).DHolder = 0
                                        
                                        
                                        'Make a reminder that one of the berakpoints went undetected
                                        If A = 0 Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                            EWarn = 1
                                        Else
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                            BWarn = 1
                                        End If
                                        
                                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                                        XoverList(ActiveSeq, SIP).ProgramFlag = 1
                                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 1 Then BWarn = 1
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 2 Then EWarn = 1
                                        'If SEventNumber > 0 Or X = X Then
                                            If EWarn = 0 Then Call CheckEndsVB(0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB(0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                        'End If
                                        Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                                        Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                                        If FindallFlag = 1 And X = 12345 Then
'                                            If APermFlag = 0 Then
'                                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                            Else
'                                                SIP = 1
'                                            End If
'                                            If SIP > 0 Then
'                                                XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                                XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                                XOverlist(ActiveSeq, SIP).Beginning = Ending
'
'                                            End If
'                                        End If
'                                        If X = 12345 Then
'                                            If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            Else
'                                                For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            End If
'                                            'XX = ZZZXZ
'                                        End If
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(1) = 1
                                            AbortFlag = 1
                                            'If UseCompress = 1 And GCIndelFlag = 0 Then
                                            Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
                                            'End If
                                            Exit Sub
                                        End If
                                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(1) = 1
                                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                                        End If
                                    ElseIf DoneRedo = 0 Then
                                        DoneRedo = 1
                                        Call AddToRedoList(1, Seq1, Seq2, Seq3)
                                        'Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
                                        'Exit Sub
                                    End If
                                        
                                End If
                                
                            End If
                            
                        Next A
                    ElseIf SplitX = 0 Then
                        
                        
                        If MCFlag = 2 Then
                            lP = -Log10(CDbl(ProbabilityXOver)) * 2
                            If lP > 0 And lP < 100 Then
                                PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) + 1
                            ElseIf CInt(lP) >= 100 Then
                                PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                            End If
                        End If
                        
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(1) = oRecombNo(1) + 1
                        '$
                        If APermFlag = 0 Then
                            Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                        Else
                            SIP = 1
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(1) = 1
                            AbortFlag = 1
                            'If UseCompress = 1 And GCIndelFlag = 0 Then
                            Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
                            'End If
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                        ActualFound = 1
                        NewOneFound = 1
'                        XX = StoreLPV(1, Seq3)
'                        XX = StoreLPV(1, Seq1)
'                        XX = StoreLPV(1, Seq2)
                        If SIP > 0 Then
'                            If ProbabilityXOver > 0 Then
'                                x = x
'                            Else
'                                x = x
'                            End If
                            XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                            XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                            XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                            XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                            XoverList(ActiveSeq, SIP).Beginning = Beginning
                            XoverList(ActiveSeq, SIP).Ending = Ending
                            XoverList(ActiveSeq, SIP).ProgramFlag = 1
                            XoverList(ActiveSeq, SIP).DHolder = 0
                            
                            ''If SEventNumber > 0 Or X = X Then
                                If EWarn = 0 Then Call CheckEndsVB(0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB(0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                            
                           '' End If
                            Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                            If FindallFlag = 1 And X = 12345 Then
'                                If APermFlag = 0 Then
'                                    Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                Else
'                                    SIP = 1
'                                End If
'                                If SIP > 0 Then
'                                    XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                    XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                    XOverlist(ActiveSeq, SIP).Beginning = Ending
'                                End If
'                            End If
                            
                            'If Seq1 = 57 Or Seq2 = 57 Or Seq3 = 57 And XOverList(ActiveSeq, SIP).Beginning = 2301 And XOverList(ActiveSeq, SIP).Ending = 53 Then
                            '                XxX = SEventNumber
                            '            End If
                                        
'                                    If X = 12345 Then
'                                        If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        Else
'                                            For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        End If
'                                       'XX = ZZZXZ
'                                    End If
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                
                                StartPlt(1) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                            End If
                            
                        ElseIf DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(1, Seq1, Seq2, Seq3)
                            Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
                            Exit Sub
                        End If
                   Else
                        FragMaxScore(MaxY, MaxX) = 0
                   End If
                   tMa = ActiveMajorP
                   tMi = ActiveMinorP
                   Ac = ActiveSeq
                        
                                      
                    ActiveMajorP = tMa
                    ActiveMinorP = tMi
                    ActiveSeq = Ac
                    
                    If ShowPlotFlag = 1 And DoneThis = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call DoAxes(0, 0, Decompress(LSeq), -1, CSng(-Log10(CDbl(MaxScore))), 0, 1, "-Log(KA P-Val)")
                            
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
                            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
                        End If
                        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                        If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection
                        Form1.Picture2.ForeColor = QBColor(0)
                        COff = -Log10(CDbl(LowestProb / (MCCorrection)))
                        Y1 = PicHeight - (15 + (COff / -Log10(CDbl(MaxScore))) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 2
                        Y1 = PicHeight - (15 + (-Log10(CDbl(LowestProb)) / -Log10(CDbl(MaxScore))) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 0
                        'Form1.Picture7.AutoRedraw = True
                        DoneThis = 1
                        
                        For A = 5 To 0 Step -1
                            
    
                            If A = 0 Then
                                Form1.Picture7.ForeColor = Yellow
                            ElseIf A = 1 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 2 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 3 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 4 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 5 Then
                                Form1.Picture7.ForeColor = Yellow
                            End If
                            
                            
                                For b = 0 To FragCount(A)
                                    If PVals(b, A) < 0.9999 And PVals(b, A) > 0 Then
                                    
                                        Prob = -Log10(CDbl(PVals(b, A)))
                                        
                                        If FragSt(b, A) > 0 Then
                                            b1 = XDiffPos(FragSt(b, A) - 1) + 1
                                        Else
                                            b1 = 1
                                        End If
                                        E1 = XDiffPos(FragEn(MaxScorePos(b, A), A) + 1) - 1
                                        X1 = 30 + Decompress(b1) * XFactor + XFactor
                                        X2 = 30 + Decompress(E1) * XFactor + XFactor
                                        
                                        
                                        Y1 = PicHeight - (15 + (Prob / -Log10(CDbl(MaxScore))) * (PicHeight - 35))
                                        Y2 = PicHeight - 15
                                        Form1.Picture7.AutoRedraw = True
                                        'Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
                                    End If
                                Next b
                           
                        Next A
                        Form1.Picture7.Refresh
                        Form1.Frame17.Visible = False
                        'X = X
                        'XX = FragMaxScore(MaxY, MaxX)
                        'XX = FragSt(MaxY, MaxX)
                        'XX = FragEn(MaxY, MaxX)
                        'XX = FragCount(MaxX)
                        'XX = LenXOverSeq
                        'XX = KMax(MaxX)
                        'XX = LL(MaxX)
                        'XX = Log(KMax(MaxX) * LenXOverSeq)
                        'XX = (LL(MaxX) * FragMaxScore(MaxY, MaxX))
                    End If
                    
                    If SplitX = 1 And MaxX > 3 Then
                        PVals(MaxY, MaxX) = 100
                    Else
                        
                        '$
                            Dummy = MakeDeleteArrayP(FragSt(Y, x), FragEn(MaxScorePos(Y, x), x), FragCount(x), DeleteArray(0))
                       
                    End If
                    
                End If
            'Else
            '    Exit For
            'End If
        End If
        
Loop
'If UseCompress = 1 And GCIndelFlag = 0 Then
Dummy = cleanss(LenXoverSeq, UBound(SubSeq, 1), SubSeq(0, 0))
'End If
'124
End Sub



Public Sub GCManXOver()

    Dim LSeq As Long, x As Long, NPos2 As Long, g As Long
    Dim TempEnd As String, NewName As String, oDir As String, LList As String, TargetCompare As String
    Dim COff As Double
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    LSeq = Len(StrainSeq(0))
    Form1.Picture7.BackColor = BackColours
    Form1.Picture10.BackColor = BackColours
    Screen.MousePointer = 11
    Form1.SSPanel1.Caption = "Executing GENECONV"
    'Set up copies of sequences that can be edited and rearranged etc
    ReDim TempSeq(NextNo)
    ReDim RevSeq(NextNo)
    TempSeq(0) = StrainSeq(Form5.Combo1.ListIndex - 1)
    RevSeq(0) = Form5.Combo1.ListIndex - 1
    NumberOfSeqs = 1

    For x = 0 To NextNo

        If Selected(x) = 1 Then
            TempSeq(NumberOfSeqs) = StrainSeq(x)
            RevSeq(NumberOfSeqs) = x
            NumberOfSeqs = NumberOfSeqs + 1
        End If

    Next 'X

    NumberOfSeqs = NumberOfSeqs - 1
    NewName = "manseqs"
    'Make GENECONV input file in FASTA format
    Open NewName For Output As #1

    For x = 0 To NumberOfSeqs
        Print #1, ">S" & Trim$(CStr(x))
        Print #1, TempSeq(x)
    Next 'X

    Close #1
    'Make GENECONV configuration file
    Open "mancfg.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=manseqs"
    Print #1, "-Outfile=manfrag"
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    If GCSeqTypeFlag = 0 Then
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        Print #1, "-Use_individual_indels"
    End If

    

    If GCMonoSiteFlag = 0 Then
    Else
        Print #1, "-Include_monosites"
    End If

    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)
    Print #1, "-SortName"
    'If GCOffsetAddjust > 0 Then
    '    Print #1, "-AddOffset=" & GCOffsetAddjust
    'End If
    Print #1, "-Nolog"

    If GCMissmatchPen > 0 Then
        Print #1, "-Gscale=" & GCMissmatchPen
    End If

    Print #1, "-ListGlobal=1"
    Print #1, "-ListPerPair=50"
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore

    If GCMaxOverlapFrags < 10 Then
        Print #1, "/v10"
    Else
        Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    End If

    Print #1, "-Numsim=0"
    Print #1, "-Maxkapairwisepval=0.99999"
    LList$ = "S0 "

    For x = 1 To NumberOfSeqs
        LList$ = LList$ + "S0,S" + Trim$(CStr(x)) + " "
    Next 'X

    Print #1, "-Listonly=" + LList$
    'Print #1, "/x"
    Close #1
    If ShortOutFlag = 0 Then
        LowestProb = pLowestProb
    End If
    
    Form1.ProgressBar1 = 5
    Call UpdateF2Prog
    Dim mgcProcess As Long

    mgcProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell("geneconv mancfg.cfg", 0))

    Dim xMinP As Single

    xMinP = 0
    Form1.Picture7.Picture = LoadPicture()
    Form1.Picture1.Enabled = True
    Form1.Picture7.Enabled = True

    Dim Beginning As Long, Ending As Long, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim YScaleFactor As Double, Prob As Double
    Dim retVal As Long, CurrentStart As Long

    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(LSeq))
    Const STILL_ACTIVE = &H103

    Do
        GetExitCodeProcess mgcProcess, retVal
    Loop While retVal = STILL_ACTIVE

    Dummy = CloseHandle(mgcProcess)
    mgcProcess = 0
    Form1.ProgressBar1 = 50
    Call UpdateF2Prog
    ReDim MCPrintData(NumberOfSeqs, LSeq)
    ReDim MCPrintPos(NumberOfSeqs, LSeq, 1)

    Dim Results As String
    Dim FLen As Long
    Dim TargetString As String, Temp As String
    Dim CurPPos As Long, NPos As Long, GiPos As Long
    MinPx = 0
    Open "manfrag.frags" For Binary Access Read As #1
    Results = String$(30000, " ")
    FLen = LOF(1)
    Results = String$(FLen, " ")
    CurrentStart = 1
    Get #1, CurrentStart, Results
    'First look for inner fragments
    NPos = InStr(1, Results, "GI ", vbBinaryCompare)
    GiPos = NPos + 10

    If NPos > 0 Then
        Close #1
        Open "manfrag.frags" For Binary Access Read As #1
        Get #1, NPos, Temp$
        Input #1, Temp$
        NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
        NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
        NPos = InStr(1, Temp$, " ", vbBinaryCompare)
        MinPx = CDbl(Trim$(Left$(Temp$, NPos))) / 3
        MinPx = -Log10(CDbl(MinPx))
    End If

    NPos2 = InStr(1, Results, "GO ", vbBinaryCompare)

    If NPos2 > 0 Then
        Close #1
        Open "manfrag.frags" For Binary Access Read As #1
        
        Get #1, NPos2, Temp$
        Input #1, Temp$
        If Temp$ <> "" Then
            NPos2 = InStr(1, Temp$, " ", vbBinaryCompare)
        
        
            Temp$ = Trim$(Mid$(Temp$, NPos2, Len(Temp$) - NPos + 1))
        End If
        If Temp$ <> "" Then
            NPos2 = InStr(1, Temp$, " ", vbBinaryCompare)
            Temp$ = Trim$(Mid$(Temp$, NPos2, Len(Temp$) - NPos + 1))
        End If
        If Temp$ <> "" Then
            NPos2 = InStr(1, Temp$, " ", vbBinaryCompare)
        End If
        

        If -Log10(CDbl(Trim$(Left$(Temp$, NPos2))) / 3) > MinPx Then
            MinPx = CDbl(Trim$(Left$(Temp$, NPos2))) / 3
            MinPx = -Log10(CDbl(MinPx))
        End If

    End If

    'Exit Sub

    If MinPx < -Log10(CDbl(LowestProb / NumberOfSeqs)) Then
        MinPx = -Log10(CDbl(LowestProb / NumberOfSeqs))
    End If

    

    'For X = 0 To NumberOfSeqs
        xMinP = MinPx
        
    'Next 'X

    Get #1, CurrentStart, Results
    Close #1

    For g = 0 To NumberOfSeqs
        CurrentStart = 1
        CurPPos = 0
        'Do 1 - 2

        If g = 0 Then
            TargetString = "PO  S0"
            NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
            TargetString = "PI  S0"
            NPos2 = InStr(GiPos, Results, TargetString, vbBinaryCompare)
            If NPos2 < NPos Then NPos = NPos2
            TargetString = "S0"
        Else
            TargetString = "S0;S" + Trim$(CStr(g))
            NPos = InStr(GiPos, Results, TargetString, vbBinaryCompare)
        End If

        Form1.Picture7.AutoRedraw = True

        If NPos > 0 Then
            Open "manfrag.frags" For Binary Access Read As #1
            Get #1, NPos - 50, Temp$

            Do While Not EOF(1)
                Input #1, Temp$

                If Left$(Temp$, 2) = "PI" Or Left$(Temp$, 2) = "PO" Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    TargetCompare$ = Mid$(Temp$, 1, NPos - 1)

                    If TargetCompare$ <> TargetString Then Exit Do
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        'Prob = CDbl(Mid$(temp$, 1, NPos - 1))
                        If DebuggingFlag < 2 Then On Error Resume Next
                            Prob = val(Mid$(Temp$, 1, NPos - 1))
                            Prob = CDbl(Mid$(Temp$, 1, NPos - 1))
                           
                        On Error GoTo 0
                        If Prob = 1 Then Exit Do

                        If xMinP < -Log10(CDbl(Prob)) Then xMinP = -Log10(CDbl(Prob))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    If xMinP < -Log10(CDbl(Prob)) Then xMinP = -Log10(CDbl(Prob))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = CDbl(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = CDbl(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            Ending = CDbl(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = CDbl(TempEnd$)
                        End If

                    End If

                    If Beginning < Ending Then
                        Prob = -Log10(CDbl(Prob))
                        MCPrintData(g, CurPPos) = Prob
                        MCPrintPos(g, CurPPos, 0) = Beginning
                        MCPrintPos(g, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    Else
                        Prob = -Log10(CDbl(Prob))
                        MCPrintData(g, CurPPos) = Prob
                        MCPrintPos(g, CurPPos, 0) = Beginning
                        MCPrintPos(g, CurPPos, 1) = LSeq
                        CurPPos = CurPPos + 1
                        MCPrintData(g, CurPPos) = Prob
                        MCPrintPos(g, CurPPos, 0) = 1
                        MCPrintPos(g, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    End If

                ElseIf Left$(Temp$, Len(TargetString)) = TargetString Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = CDbl(Mid$(Temp$, 1, NPos - 1))

                        If xMinP = -1 Then xMinP = -Log10(CDbl(Prob))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Beginning = CDbl(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                        If TempEnd$ = "CA" Then
                            NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                            If NPos > 0 Then
                                Ending = CDbl(Mid$(Temp$, 1, NPos - 1))
                                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                            End If

                        ElseIf Left$(TempEnd$, 2) = "CA" Then
                            Ending = CDbl(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                        Else
                            Ending = CDbl(TempEnd$)
                        End If

                    End If

                    If Beginning < Ending Then
                        Prob = -Log10(CDbl(Prob))
                        MCPrintData(g, CurPPos) = Prob
                        MCPrintPos(g, CurPPos, 0) = Beginning
                        MCPrintPos(g, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    Else
                        Prob = -Log10(CDbl(Prob))
                        MCPrintData(g, CurPPos) = Prob
                        MCPrintPos(g, CurPPos, 0) = Beginning
                        MCPrintPos(g, CurPPos, 1) = LSeq
                        CurPPos = CurPPos + 1
                        MCPrintData(1, CurPPos) = Prob
                        MCPrintPos(1, CurPPos, 0) = 1
                        MCPrintPos(1, CurPPos, 1) = Ending
                        CurPPos = CurPPos + 1
                    End If

                ElseIf Left$(Temp$, 9) = "#   Names" Then
                Else

                    If Left$(Temp$, 1) = "#" Then
                        Exit Do
                    End If

                End If

            Loop

        End If

        Form1.ProgressBar1 = 50 + ((g - 1) / (NumberOfSeqs)) * 50
        Call UpdateF2Prog
        Close #1
    Next 'G

    'Form1.Picture7.Line (25, 30)-(25, PicHeight), QBColor(0)
    'Form1.Picture7.Line (25, PicHeight)-(Form1.Picture7.ScaleWidth - 5, PicHeight), QBColor(0)
    MinGCP = 0

    For x = 0 To NumberOfSeqs

        If MinGCP < xMinP Then
            MinGCP = xMinP
        End If

    Next 'X
    
    'If MinGCP > LowestProb Then X = X 'MinGCP = LowestProb
    If MinPx < -Log10(CDbl(MinGCP)) Then MinPx = -Log10(CDbl(MinGCP))

    Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(MinGCP), 0, 0, "-Log(KA P-Val)")

    Form1.Picture7.AutoRedraw = True

    For g = 0 To NumberOfSeqs

        For CurPPos = 0 To LSeq
            Beginning = MCPrintPos(g, CurPPos, 0)
            Ending = MCPrintPos(g, CurPPos, 1)

            If Beginning = Ending Then Exit For
'            X1 = 30 + Decompress(Beginning) * XFactor + XFactor
'            X2 = 30 + Decompress(Ending) * XFactor + XFactor
'            Prob = MCPrintData(g, CurPPos)
'
'
'            Y1 = PicHeight - (15 + (Prob / MinGCP) * (PicHeight - 35))
'            Y2 = PicHeight - 15
'            Form1.Picture7.Line (X1, Y1)-(X2, Y2), SeqCol(RevSeq(g)), B
        Next 'CurPPos

    Next 'G


    COff = -Log10(CDbl(LowestProb / NumberOfSeqs))
    Y1 = PicHeight - (15 + (COff / MinGCP) * (PicHeight - 35))
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
    Y1 = PicHeight - (15 + (-Log10(CDbl(LowestProb) / MinGCP)) * (PicHeight - 35))
    Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
    Form1.Picture7.DrawStyle = 0
    Form1.Picture2.ForeColor = QBColor(0)
    Form1.Picture21.Width = Form1.Picture7.Width + 100
Form1.Picture21.Height = Form1.Picture7.Height + 100
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
    
        'Add data to standard drawing and copying arrays etc
    Count = Len(StrainSeq(0))
    GPrintNum = NumberOfSeqs 'three line types
    ReDim GPrint(GPrintNum, Count), GPrintCol(GPrintNum), GPrintPos(GPrintNum, 1, Count)
    GPrintLen = Count - 1 'how many points to plot
    ReDim GCritval(10)
        
        
    MCMaxP = LowestProb / NumberOfSeqs
    GCritval(0) = -Log10(CDbl(MCMaxP))
    GCritval(1) = -Log10(CDbl(LowestProb))
    
    GLegend = "-Log[KA P-Val]"
    GPrintType = 1 'a region plot
    GPrintMin(0) = 0
    GPrintMin(1) = MinGCP
    'GBlockNum = -1
    ReDim GVarPos(0, 0)
    'For X = 1 To LenXOverSeq
    '    GVarPos(0, X) = XDiffpos(X)
    'Next X
    
    For Y = 0 To GPrintNum
        Z = -1
        For x = 0 To Len(StrainSeq(0))
            
            If MCPrintData(Y, x) > 0 Then
                Z = Z + 1
                GPrint(Y, Z) = MCPrintData(Y, x)
                
                
                If MCPrintPos(Y, x, 0) < MCPrintPos(Y, x, 1) Then
                    
                    GPrintPos(Y, 0, Z) = MCPrintPos(Y, x, 0)
                    GPrintPos(Y, 1, Z) = MCPrintPos(Y, x, 1)
                Else
                    GPrintPos(Y, 0, Z) = MCPrintPos(Y, x, 0)
                    GPrintPos(Y, 1, Z) = Len(StrainSeq(0))
                    Z = Z + 1
                    GPrint(Y, Z) = MCPrintData(Y, x)
                    GPrintPos(Y, 0, Z) = 1
                    GPrintPos(Y, 1, Z) = MCPrintPos(Y, x, 1)
               End If
            End If
            
        Next x
    Next Y
    GPrintLen = Len(StrainSeq(0))
    GBlockNum = 0
    ReDim GBlock(4, 0)
    GBlock(1, 0) = 3 'this is not actually a block - it is the legend saying which sequence is the query sequence
    XX = UBound(GPrintCol, 1)
    For x = 0 To NumberOfSeqs '- 1
        GPrintCol(x) = SeqCol(RevSeq(x))
    Next x
    
    GExtraTNum = NumberOfSeqs
    ReDim GExtraText(GExtraTNum)
        
    For x = 0 To NumberOfSeqs - 1
        GExtraText(x) = StraiName(RevSeq(x + 1))
    Next x
    GExtraText(x) = "Outer fragments (potentially unknown parents)"
    If ORFFlag = 1 Then
        'Form1.Picture20.Picture = Form1.Picture19.Image
        Call DrawORFsP20
        Form1.Picture20.Visible = True
    End If
    Call RedrawPlotAA(1)
    Form1.Picture7.Refresh
    
    Form1.SSPanel1.Caption = ""
    Screen.MousePointer = 0
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    'Kill GCCFile
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub

Public Sub GCXOver()
    Seq1 = 0
    Seq2 = 0
    oRecombNo(1) = 0
    Dim DA As Long, Mi As Long, T As Long, retVal As Long, x As Long, CPos As Long, NPos As Long
    Dim Results As String, ActualDir As String, oDir As String, Temp As String, MaP As String, MiP As String, TempEnd As String
    
    If UBound(XoverList, 2) < XOverListSize Then
       ReDim Preserve XoverList(NextNo, XOverListSize)
    End If
    
    
    'Make sure we're working in RDP's install directory
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    'Start the timer
    GCST = Abs(GetTickCount)
    Form1.SSPanel1.Caption = "Executing GENECONV"
    
   
    MinP = 0
    Form1.ProgressBar1.Value = 25
    Call UpdateF2Prog
    'Find the informative sites that GC looks at
    SS = Abs(GetTickCount)
    Call GCFindSites
    GCFoundSitesFlag = 1
    EE = Abs(GetTickCount)
    TT = EE - SS
    'Wait for GC execution to finish (it was started in the subroutine GCXoverB)
    Const STILL_ACTIVE = &H103

    Do
        'Check on how things are going every half second.
        Sleep (500)
        GetExitCodeProcess hProcess, retVal
        DoEvents 'covered by currentlyrunning
        
        If AbortFlag = 1 Then
            AbortFlag = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Call UpdateF2Prog
            ABFl(1) = 1
            Exit Sub
        End If

        ET = Abs(GetTickCount)
        Form1.Label50(2).Caption = DoTimeII(ET - GCST)
        Form1.Label50(12).Caption = DoTimeII(ET - ST)
    Loop While retVal = STILL_ACTIVE

    'Release the handle
    CloseHandle hProcess
    hProcess = 0
    'Update progress indicators
    UpdateRecNums (SEventNumber)
    Form1.ProgressBar1.Value = 50
    Call UpdateF2Prog
    'Bit for mtDNA Project
    If ShortOutFlag = 3 And GCNumPerms > 0 Then
        Open GCOutfileName + ".sum" For Binary Access Read As #1
        Results = String$(LOF(1), " ")
        Get #1, 1, Results
        Close #1
        Pos = InStr(1, Results, "SCORE", vbBinaryCompare)
        
        If Pos > 0 Then
            mtP(1) = val(Trim(Mid(Results, Pos + 18, 13)))
            NPos = InStr(Pos, Results, "Not found", vbBinaryCompare)
            If NPos = 0 Then
                Pos = InStr(Pos, Results, "frags", vbBinaryCompare)
                TVal = val(Trim(Mid(Results, Pos + 18, 13)))
                If TVal < mtP(1) Then
                    mtP(1) = TVal
                End If
            End If
        End If
        x = x
        If DebuggingFlag < 2 Then On Error Resume Next

        ChDrive oDir
        ChDir oDir
        On Error GoTo 0
        Exit Sub
    End If
    'Reexecutes GC in the background to get information on marginally significant fragments
    If ShortOutFlag <> 3 Then
        Call GCDrawC
    End If
    'Look for signiifcant fragments within the GC outfile - Note this is some seriously crap
    'code and must be rewritten - I have no idea why I first load the entire file, close it and
    'then reopen it to read the data - it is slow and messy.
    'Read the outfile into the string "Results"
    Open GCOutfileName + ".frags" For Binary Access Read As #1
    Results = String$(LOF(1), " ")
    Get #1, 1, Results
    Close #1
    'Determine  where within the string "Results" the data on Global Inner fragments begins
    CPos = 1
    NPos = InStr(1, Results, "GI ", vbBinaryCompare)

    If NPos > 0 Then
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, Temp$

        Do
            ET = Abs(GetTickCount)
            Form1.Label50(2).Caption = DoTimeII(ET - GCST)
            Form1.Label50(12).Caption = DoTimeII(ET - ST)
            Input #1, Temp$

            If Left$(Temp$, 2) = "GI" Then
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                CPos = InStr(1, Temp$, ";", vbBinaryCompare)
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If CPos > 0 Then
                    MaP$ = Mid$(Temp$, 1, CPos - 1)
                    MiP$ = Mid$(Temp$, CPos + 1, NPos - CPos - 1)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    For x = 0 To NextNo

                        If StraiName(x) = MaP$ Then Seq1 = x

                        If StraiName(x) = MiP$ Then Seq2 = x
                    Next 'X

                    ActiveSeq = Seq1
                    Call UpdateXOList(ActiveSeq, CurrentXOver(), XoverList())
                    
                    XoverList(Seq1, CurrentXOver(Seq1)).Daughter = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MajorP = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MinorP = Seq2
                    
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        If val(Mid$(Temp$, 1, NPos - 1)) >= 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).PermPVal = val(Mid$(Temp$, 1, NPos - 1))
                        End If
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).Probability = val(Mid$(Temp$, 1, NPos - 1))
                    If MCFlag = 2 Then
        
                        Dim ProbabilityXOver As Double
                        ProbabilityXOver = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                        
                        If -Log10(CDbl(ProbabilityXOver)) * 2 > 0 And -Log10(CDbl(ProbabilityXOver)) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) + 1
                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XoverList(Seq1, CurrentXOver(Seq1)).Probability <= mtP(1) And XoverList(Seq1, CurrentXOver(Seq1)).Probability <> 0 Then
                        mtP(1) = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).Beginning = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = (Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                        End If

                    ElseIf Left$(TempEnd$, 2) = "CA" Then
                        Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).LHolder = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
    'XXXZZZ                  XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
'XXXZZZ                      XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If ShortOutFlag = 50 Then ShortOutput(1) = 1
                If Temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XoverList(Seq1, CurrentXOver(Seq1)).ProgramFlag = 1
                XoverList(Seq1, CurrentXOver(Seq1)).MissIdentifyFlag = 1

                If XoverList(Seq1, CurrentXOver(Seq1)).Beginning < XoverList(Seq1, CurrentXOver(Seq1)).Ending Then

                    If XoverList(Seq1, CurrentXOver(Seq1)).Ending - XoverList(Seq1, CurrentXOver(Seq1)).Beginning > Len(StrainSeq(0)) / 2 Then

                        If CircularFlag = 1 Then
                            T = XoverList(Seq1, CurrentXOver(Seq1)).Ending
                            XoverList(Seq1, CurrentXOver(Seq1)).Ending = XoverList(Seq1, CurrentXOver(Seq1)).Beginning
                            XoverList(Seq1, CurrentXOver(Seq1)).Beginning = T
                            XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                            XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                        Else

                            If XoverList(Seq1, CurrentXOver(Seq1)).Beginning > Len(StrainSeq(0)) - XoverList(Seq1, CurrentXOver(Seq1)).Ending Then
                                XoverList(Seq1, CurrentXOver(Seq1)).Ending = XoverList(Seq1, CurrentXOver(Seq1)).Beginning
                                XoverList(Seq1, CurrentXOver(Seq1)).Beginning = 0
                                XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                                XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                            Else
                                XoverList(Seq1, CurrentXOver(Seq1)).Beginning = XoverList(Seq1, CurrentXOver(Seq1)).Ending
                                XoverList(Seq1, CurrentXOver(Seq1)).Ending = Len(StrainSeq(0))
                                XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                                XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                            End If

                        End If

                    End If

                Else

                    If XoverList(Seq1, CurrentXOver(Seq1)).Beginning - XoverList(Seq1, CurrentXOver(Seq1)).Ending < Len(StrainSeq(0)) / 2 Then
                        T = XoverList(Seq1, CurrentXOver(Seq1)).Ending
                        XoverList(Seq1, CurrentXOver(Seq1)).Ending = XoverList(Seq1, CurrentXOver(Seq1)).Beginning
                        XoverList(Seq1, CurrentXOver(Seq1)).Beginning = T
                        XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                        XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                    End If

                End If

                If XoverList(Seq1, CurrentXOver(Seq1)).Beginning = Len(StrainSeq(0)) Then XoverList(Seq1, CurrentXOver(Seq1)).Beginning = 1
                If XoverList(Seq1, CurrentXOver(Seq1)).Ending < 2 Then XoverList(Seq1, CurrentXOver(Seq1)).Ending = Len(StrainSeq(0))

                If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    DA = XoverList(Seq1, CurrentXOver(Seq1)).Daughter
                    Mi = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                    StartPlt(1) = 1
                    Call UpdatePlotB(DA, DA, Mi, CurrentXOver(Seq1))

                End If
                Call UpdateXOList(Seq2, CurrentXOver(), XoverList())
                XoverList(Seq2, CurrentXOver(Seq2)) = XoverList(Seq1, CurrentXOver(Seq1))
                XoverList(Seq2, CurrentXOver(Seq2)).Daughter = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                XoverList(Seq2, CurrentXOver(Seq2)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                XoverList(Seq2, CurrentXOver(Seq2)).MinorP = XoverList(Seq1, CurrentXOver(Seq1)).Daughter
                
                XoverList(Seq2, CurrentXOver(Seq2)).ProgramFlag = 1
                
            Else

                If Left$(Temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

    End If

    Form1.ProgressBar1.Value = 75
    Call UpdateF2Prog
    'Determine  where within the string "Results" the data on Pairwise Inner fragments begins
    NPos = InStr(1, Results, "PI ", vbBinaryCompare)

    If NPos > 0 Then
        
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, Temp$
        Do
            ET = Abs(GetTickCount)
            Form1.Label50(2).Caption = DoTimeII(ET - GCST)
            Form1.Label50(12).Caption = DoTimeII(ET - ST)
            Input #1, Temp$

            If Left$(Temp$, 2) = "PI" Then
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                CPos = InStr(1, Temp$, ";", vbBinaryCompare)
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If CPos > 0 Then
                    MaP$ = Mid$(Temp$, 1, CPos - 1)
                    MiP$ = Mid$(Temp$, CPos + 1, NPos - CPos - 1)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    For x = 0 To NextNo

                        If StraiName(x) = MaP$ Then Seq1 = x

                        If StraiName(x) = MiP$ Then Seq2 = x
                    Next 'X

                    ActiveSeq = Seq1
                    Call UpdateXOList(ActiveSeq, CurrentXOver(), XoverList())

                    XoverList(Seq1, CurrentXOver(Seq1)).Daughter = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MajorP = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MinorP = Seq2
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        If val(Mid$(Temp$, 1, NPos - 1)) >= 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).PermPVal = val(Mid$(Temp$, 1, NPos - 1))
                        End If
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    If MCFlag = 0 Then
                        XoverList(Seq1, CurrentXOver(Seq1)).Probability = (val(Mid$(Temp$, 1, NPos - 1))) * MCCorrect '(((Nextno + 1) * (Nextno + 1)) / 2)
                    Else
                        XoverList(Seq1, CurrentXOver(Seq1)).Probability = (val(Mid$(Temp$, 1, NPos - 1)))
                    End If
                    If MCFlag = 2 Then
        
                        
                        ProbabilityXOver = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                        
                        If -Log10(CDbl(ProbabilityXOver)) * 2 > 0 And -Log10(CDbl(ProbabilityXOver)) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) + 1
                        ElseIf CInt(-Log10(CDbl(ProbabilityXOver)) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XoverList(Seq1, CurrentXOver(Seq1)).Probability <= mtP(1) And XoverList(Seq1, CurrentXOver(Seq1)).Probability <> 0 Then
                        mtP(1) = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).Beginning = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                        End If

                    ElseIf Left$(TempEnd$, 2) = "CA" Then
                        Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).LHolder = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
             'XXXZZZ       XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
     'XXXZZZ               XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If ShortOutFlag = 50 Then ShortOutput(1) = 1
                If Temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XoverList(Seq1, CurrentXOver(Seq1)).ProgramFlag = 1
                XoverList(Seq1, CurrentXOver(Seq1)).MissIdentifyFlag = 1

                If XoverList(Seq1, CurrentXOver(Seq1)).Beginning < XoverList(Seq1, CurrentXOver(Seq1)).Ending Then

                    If XoverList(Seq1, CurrentXOver(Seq1)).Ending - XoverList(Seq1, CurrentXOver(Seq1)).Beginning > Len(StrainSeq(0)) / 2 Then

                        If CircularFlag = 1 Then
                            T = XoverList(Seq1, CurrentXOver(Seq1)).Ending
                            XoverList(Seq1, CurrentXOver(Seq1)).Ending = XoverList(Seq1, CurrentXOver(Seq1)).Beginning
                            XoverList(Seq1, CurrentXOver(Seq1)).Beginning = T
                            XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                            XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                        Else

                            If XoverList(Seq1, CurrentXOver(Seq1)).Beginning > Len(StrainSeq(0)) - XoverList(Seq1, CurrentXOver(Seq1)).Ending Then
                                XoverList(Seq1, CurrentXOver(Seq1)).Ending = XoverList(Seq1, CurrentXOver(Seq1)).Beginning
                                XoverList(Seq1, CurrentXOver(Seq1)).Beginning = 0
                                XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                                XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                            Else
                                XoverList(Seq1, CurrentXOver(Seq1)).Beginning = XoverList(Seq1, CurrentXOver(Seq1)).Ending
                                XoverList(Seq1, CurrentXOver(Seq1)).Ending = Len(StrainSeq(0))
                                XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                                XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                            End If

                        End If

                    End If

                Else

                    If XoverList(Seq1, CurrentXOver(Seq1)).Beginning - XoverList(Seq1, CurrentXOver(Seq1)).Ending < Len(StrainSeq(0)) / 2 Then
                        T = XoverList(Seq1, CurrentXOver(Seq1)).Ending
                        XoverList(Seq1, CurrentXOver(Seq1)).Ending = XoverList(Seq1, CurrentXOver(Seq1)).Beginning
                        XoverList(Seq1, CurrentXOver(Seq1)).Beginning = T
                        XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 2
                        XoverList(Seq1, CurrentXOver(Seq1)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                    End If

                End If

                If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    DA = XoverList(Seq1, CurrentXOver(Seq1)).Daughter
                    Mi = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                    StartPlt(1) = 1
                    Call UpdatePlotB(DA, DA, Mi, CurrentXOver(Seq1))

                End If
                
                Call UpdateXOList(Seq2, CurrentXOver(), XoverList())
                
                XoverList(Seq2, CurrentXOver(Seq2)) = XoverList(Seq1, CurrentXOver(Seq1))
                XoverList(Seq2, CurrentXOver(Seq2)).Daughter = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                XoverList(Seq2, CurrentXOver(Seq2)).MajorP = XoverList(Seq1, CurrentXOver(Seq1)).MinorP
                XoverList(Seq2, CurrentXOver(Seq2)).MinorP = XoverList(Seq1, CurrentXOver(Seq1)).Daughter
                
                XoverList(Seq2, CurrentXOver(Seq2)).ProgramFlag = 1
            Else

                If Left$(Temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

    End If

    'I don't know why I close this here only to reopen it in the next few lines
    'It may have something to do with the "Do Events" further on)
    Close #1
    ET = Abs(GetTickCount)
    Form1.Label50(2).Caption = DoTimeII(ET - GCST) 'Str$((Int((ET - GCST) / 100)) / 10)
    Form1.Label50(12).Caption = DoTimeII(ET - ST) 'Str$((Int((ET - ST) / 100)) / 10)
    Form1.Label50(2).Refresh
    Form1.Label50(3).Refresh
    Form1.Label50(12).Refresh
    Form1.Label50(13).Refresh
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    'Determine  where within the string "Results" the data on Global Outer fragments begins
    NPos = InStr(1, Results, "GO ", vbBinaryCompare)

    If NPos > 0 Then
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, Temp$

        Do
            ET = Abs(GetTickCount)
            Form1.Label50(2).Caption = DoTimeII(ET - GCST) 'Str$((Int((ET - GCST) / 100)) / 10)
            Form1.Label50(12).Caption = DoTimeII(ET - ST) 'Str$((Int((ET - ST) / 100)) / 10)
            Input #1, Temp$

            If Left$(Temp$, 2) = "GO" Then
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    MaP$ = Mid$(Temp$, 1, NPos - 1)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    For x = 0 To NextNo

                        If StraiName(x) = MaP$ Then Seq1 = x
                    Next 'X

                    ActiveSeq = Seq1
                    
                    Call UpdateXOList(ActiveSeq, CurrentXOver(), XoverList())
                    
                    XoverList(Seq1, CurrentXOver(Seq1)).Daughter = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MajorP = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MinorP = NextNo + 1
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        If val(Mid$(Temp$, 1, NPos - 1)) >= 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).PermPVal = val(Mid$(Temp$, 1, NPos - 1))
                        End If
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).Probability = val(Mid$(Temp$, 1, NPos - 1))
                    If MCFlag = 2 Then
        
                       
                        ProbabilityXOver = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                        
                        If -Log10(CDbl(ProbabilityXOver)) * 2 > 0 And -Log10(CDbl(ProbabilityXOver)) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(CDbl(ProbabilityXOver)) * 2)) + 1
                        ElseIf CInt(-Log10(CDbl(ProbabilityXOver)) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XoverList(Seq1, CurrentXOver(Seq1)).Probability <= mtP(1) And XoverList(Seq1, CurrentXOver(Seq1)).Probability <> 0 Then
                        mtP(1) = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).Beginning = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = (Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                        End If

                    ElseIf Left$(TempEnd$, 2) = "CA" Then
                        Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).LHolder = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
             'XXXZZZ       XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
            'XXXZZZ        XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If ShortOutFlag = 50 Then ShortOutput(1) = 1
                If Temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XoverList(Seq1, CurrentXOver(Seq1)).ProgramFlag = 1
                XoverList(Seq1, CurrentXOver(Seq1)).MissIdentifyFlag = 1
                XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 1
            Else

                If Left$(Temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

    End If

    Close #1
    Form1.ProgressBar1.Value = 75
    Call UpdateF2Prog
    'Determine  where within the string "Results" the data on Pairwise Outer fragments begins
    NPos = InStr(1, Results, "PO ", vbBinaryCompare)

    If NPos > 0 Then
        
        Open GCOutfileName + ".frags" For Binary Access Read As #1
        Get #1, NPos - 10, Temp$

        Do
            ET = Abs(GetTickCount)
            Form1.Label50(2).Caption = DoTimeII(ET - GCST) 'Str$((Int((ET - GCST) / 100)) / 10)
            Form1.Label50(12).Caption = DoTimeII(ET - ST) 'Str$((Int((ET - ST) / 100)) / 10)
            Input #1, Temp$

            If Left$(Temp$, 2) = "PO" Then
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    MaP$ = Mid$(Temp$, 1, NPos - 1)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    For x = 0 To NextNo

                        If StraiName(x) = MaP$ Then Seq1 = x
                    Next 'X

                    ActiveSeq = Seq1
                    Call UpdateXOList(ActiveSeq, CurrentXOver(), XoverList())

                    XoverList(Seq1, CurrentXOver(Seq1)).Daughter = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MajorP = Seq1
                    XoverList(Seq1, CurrentXOver(Seq1)).MinorP = NextNo + 1
                    'Keep track of signal numbers
                    oRecombNo(100) = oRecombNo(100) + 1
                    oRecombNo(1) = oRecombNo(1) + 1
                    
                    UpdateRecNums (SEventNumber)
                End If

                If GCNumPerms > 0 Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        If val(Mid$(Temp$, 1, NPos - 1)) >= 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).PermPVal = val(Mid$(Temp$, 1, NPos - 1))
                        End If
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    If MCFlag = 0 Then
                        XoverList(Seq1, CurrentXOver(Seq1)).Probability = (val(Mid$(Temp$, 1, NPos - 1))) * MCCorrect ' (((Nextno + 1) * (Nextno + 1)) / 2)
                    Else
                        XoverList(Seq1, CurrentXOver(Seq1)).Probability = (val(Mid$(Temp$, 1, NPos - 1)))
                    End If
                    If MCFlag = 2 Then
        
                        
                        ProbabilityXOver = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                        
                        If -Log10(CDbl(ProbabilityXOver)) * 2 > 0 And -Log10(CDbl(ProbabilityXOver)) * 2 < 100 Then
                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                        End If
                    End If
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 3 Then
    
                    If XoverList(Seq1, CurrentXOver(Seq1)).Probability <= mtP(1) And XoverList(Seq1, CurrentXOver(Seq1)).Probability <> 0 Then
                        mtP(1) = XoverList(Seq1, CurrentXOver(Seq1)).Probability
                    End If
                End If
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).Beginning = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(Mid$(Temp$, 1, NPos - 1)) - GCOffsetAddjust
                            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                        End If

                    ElseIf Left$(TempEnd$, 2) = "CA" Then
                        Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2)) - GCOffsetAddjust
                    Else
                        XoverList(Seq1, CurrentXOver(Seq1)).Ending = val(TempEnd$) - GCOffsetAddjust
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    XoverList(Seq1, CurrentXOver(Seq1)).LHolder = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
           'XXXZZZ         XOverlist(Seq1, CurrentXOver(Seq1)).NumDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
           'XXXZZZ         XOverlist(Seq1, CurrentXOver(Seq1)).TotDiffs = Val(Mid$(temp$, 1, NPos - 1))
                    tdiff = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If
                If ShortOutFlag = 1 And tdiff > 2 Then
                        ShortOutput(1) = 1
                        AbortFlag = 1
                        Exit Sub
                End If
                If ShortOutFlag = 50 Then ShortOutput(1) = 1
                If Temp$ <> "None" Then
'XXXZZZ                     XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = Val(temp$)
                Else
 'XXXZZZ                    XOverlist(Seq1, CurrentXOver(Seq1)).MisPen = 0
                End If

                XoverList(Seq1, CurrentXOver(Seq1)).ProgramFlag = 1
                XoverList(Seq1, CurrentXOver(Seq1)).MissIdentifyFlag = 1
                XoverList(Seq1, CurrentXOver(Seq1)).OutsideFlag = 1
            Else

                If Left$(Temp$, 1) = "#" Then Exit Do
            End If

        Loop

    End If

    Close #1
    'Wait for the "Checking" GC execution to finsish
    If ShortOutFlag = 3 Then
        If DebuggingFlag < 2 Then On Error Resume Next

        ChDrive oDir
        ChDir oDir
        On Error GoTo 0
        Exit Sub
    End If
    
    Do
        GetExitCodeProcess gcProcess, retVal
        Sleep (500)
        ET = Abs(GetTickCount)
        Form1.Label50(2).Caption = DoTimeII(ET - GCST)
        Form1.Label50(12).Caption = DoTimeII(ET - ST)

        If AbortFlag = 1 Then
            AbortFlag = 0
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Call UpdateF2Prog
            If DoScans(0, 3) = 1 And MCTripletFlag = 1 Then
                NoMCFlag = 0
            Else
                NoMCFlag = 1
            End If

            'I've temporarily removed this to see if it makes the program more stable
            'GetExitCodeProcess gcProcess, tExitCode
            'TerminateProcess gcProcess, tExitCode
            'Dummy = CloseHandle(gcProcess)
            'gcProcess=0
            ABFl(1) = 1
            Exit Sub
        End If

        DoEvents 'covered by currentlyrunning

    Loop While retVal = STILL_ACTIVE

    CloseHandle gcProcess
    gcProcess = 0
    'Executes MaxChi for a later check of GC results

    
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDrive oDir
    ChDir oDir
    On Error GoTo 0
    ET = Abs(GetTickCount)
    Form1.Label50(2).Caption = DoTimeII(ET - GCST)
    Form1.Label50(12).Caption = DoTimeII(ET - ST)
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End Sub
Public Sub Reactivate()
    '2,8,5,p8
    Form1.SSPanel2.Enabled = OSS2
    Form1.SSPanel8.Enabled = OSS8
    Form1.SSPanel5.Enabled = OSS5
    Form1.Picture3.Enabled = OP3
    Form1.Picture5.Enabled = OP5
    Form1.Picture16.Enabled = OP16
    Form1.Command28.Visible = False
End Sub
Public Sub Deactivate()
    'Temporarily disables various controlls on the main form
    OSS2 = Form1.SSPanel2.Enabled
    OSS8 = Form1.SSPanel8.Enabled
    OSS5 = Form1.SSPanel5.Enabled
    OP3 = Form1.Picture3.Enabled
    OP5 = Form1.Picture5.Enabled
    OP16 = Form1.Picture16.Enabled
    Form1.SSPanel2.Enabled = False
    Form1.SSPanel8.Enabled = False
    Form1.SSPanel5.Enabled = False
    Form1.Picture3.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Picture16.Enabled = False
End Sub

Public Sub MakeAncestral()

SS = Abs(GetTickCount)

Call MakeAncTree(1)

Form1.SSPanel1.Caption = "Constructing Ancestral Sequences"
Form1.ProgressBar1 = 5
Call UpdateF2Prog
Form1.Refresh

ReDim AncSeq(Len(StrainSeq(0)), NextNo)
Dim Path() As Long, DonePath() As Long
Dim StartP As Long
Dim CurPos As Long, CurPosB As Long
ReDim Path(NextNo)
ReDim DonePath(NextNo * 2)

'Work out the order of the read.
CurPos = 0
Dim TopNode() As Integer
ReDim TopNode(NextNo * 2)
'Initialise array
For x = 0 To NextNo
    TopNode(x) = -1
    For Y = 0 To NextNo - 1
        Path(x) = -1
    Next Y
Next x

Dim backup() As Long

ReDim backup(NextNo)
CurPos = 0

'Find MRCAs and the order in which to look at nodes
ReDim MRCAMat(NextNo * 2, NextNo * 2)


If x = 12345 Then
    For x = NextNo To NextNo * 2
        
        'BranchMap(X, 0) = BranchMap(X, 0)
        If DonePath(x) = 0 And BranchMap(x, 1) > -1 And BranchMap(x, 2) > -1 Then
            If TopNode(BranchMap(x, 1)) = -1 And TopNode(BranchMap(x, 2)) = -1 Then
                MRCAMat(BranchMap(x, 1), BranchMap(x, 2)) = x
                MRCAMat(BranchMap(x, 2), BranchMap(x, 1)) = x
                Path(CurPos) = x
                CurPos = CurPos + 1
                TopNode(x) = -1
                DonePath(x) = -1
                x = NextNo
            End If
         End If
    Next x
    
    
    Form1.ProgressBar1 = 10
    Call UpdateF2Prog
    For x = NextNo + 1 To NextNo * 2
        For Y = 0 To NextNo * 2
            If MRCAMat(x, Y) > 0 Then
                MRCAMat(BranchMap(x, 1), Y) = MRCAMat(x, Y)
                MRCAMat(Y, BranchMap(x, 1)) = MRCAMat(x, Y)
                MRCAMat(BranchMap(x, 2), Y) = MRCAMat(x, Y)
                MRCAMat(Y, BranchMap(x, 2)) = MRCAMat(x, Y)
                MRCAMat(x, Y) = 0
                MRCAMat(Y, x) = 0
            End If
                
        Next Y
    Next x
End If
Dim DoneMat() As Byte
ReDim DoneMat(NextNo * 2, NextNo * 2)
For x = NextNo + 1 To NextNo * 2
    MRCAMat(BranchMap(x, 1), BranchMap(x, 2)) = x
    MRCAMat(BranchMap(x, 2), BranchMap(x, 1)) = x
Next x
'Do While GoOn = 1
'    GoOn = 1
    For x = 0 To NextNo
        CPos = x
        Do
            For Y = 0 To NextNo * 2
                If MRCAMat(CPos, Y) > 0 Then
                    MRCAMat(x, Y) = MRCAMat(CPos, Y)
                    MRCAMat(Y, x) = MRCAMat(CPos, Y)
                    'GoOn = 1
                End If
            Next Y
            If CPos = NextNo * 2 Then Exit Do
            CPos = BranchMap(CPos, 0)
        Loop
    Next x
'Loop
Do
    GoOn = 0
    For x = 0 To NextNo * 2
        For Y = 0 To NextNo * 2
            If MRCAMat(x, Y) > 0 And DoneMat(x, Y) = 0 Then
                Epos = MRCAMat(x, Y)
                Xpos = x
                YPos = Y
                DoneMat(x, Y) = 1
                                
                Do
                    Do
                        If MRCAMat(Xpos, YPos) = 0 Then
                            MRCAMat(Xpos, YPos) = Epos
                            MRCAMat(YPos, Xpos) = Epos
                            GoOn = 1
                        End If
                        If YPos = Epos Then Exit Do
                        YPos = BranchMap(YPos, 0)
                    Loop
                    If Xpos = Epos Then Exit Do
                    Xpos = BranchMap(Xpos, 0)
                    
                Loop
                'Exit For
            End If
        Next Y
    Next x
    
    If GoOn = 0 Then Exit Do
    'For X = 0 To Nextno * 2
    '    CPos = X
    '    Do
    '        For Y = 0 To Nextno * 2
    '            If MRCAMat(CPos, Y) > 0 Then
    '                MRCAMat(X, Y) = MRCAMat(CPos, Y)
    '                MRCAMat(Y, X) = MRCAMat(CPos, Y)
    '
    '            End If
    '        Next Y
    '        If CPos = Nextno * 2 Then Exit Do
    '        CPos = BranchMap(CPos, 0)
    '    Loop
    'Next X
Loop


'            If BranchMap(X, 2) < BranchMap(X, 1) And BranchMap(X, 2) > Nextno Then
'                If BranchMap(X, 2) < X Then
'                    X = BranchMap(X, 2) - 1
'                Else
'                    X = X - 1
'                End If
 '           ElseIf BranchMap(X, 1) > Nextno Then
'                If BranchMap(X, 1) < X Then
'                    X = BranchMap(X, 1) - 1
'                Else
'                    X = X - 1
 '               End If
'            Else
'                If BranchMap(X, 2) <= Nextno Or BranchMap(X, 1) <= Nextno Then
'                    'X = Nextno
'                    X = X - 1
'                Else
'                    X = X - 1
'                End If
'            End If
'            'X = Nextno
'            Exit For
'            'mrcamat(branchmap(mrcamat(x,1)),y)=
'        End If
'    Next Y
'    X = X
'Next X

'MRCAMat(12, 18) = MRCAMat(12, 18)
'MRCAMat(13, 6) = MRCAMat(13, 6)
'For X = 0 To Nextno
'    If X <> Outie Then
'        MRCAMat(Outie, X) = Nextno + 1
'        MRCAMat(X, Outie) = Nextno + 1
'    End If
'Next X

'For X = 0 To Nextno
'    For Y = X + 1 To Nextno
'        MRCAMat(X, Y) = MRCAMat(X, Y)
'    Next Y
'Next X



'For X = 0 To Nextno * 2 - 1
'    MRCAMat(X, X) = X
'    CPos = BranchMap(X, 0)
 '   Do
'        'If MRCAMat(X, CPos) <> 0 Then
'        '    X = X
'        'End If
'        MRCAMat(X, CPos) = CPos
'        MRCAMat(CPos, X) = CPos
'        If CPos = Nextno * 2 Then Exit Do
'        CPos = BranchMap(CPos, 0)
'
'    Loop
'Next X
For x = 0 To NextNo * 2
    MRCAMat(x, x) = x
Next x

'For X = 0 To Nextno * 2
'    For Y = X + 1 To Nextno * 2
'        MRCAMat(X, Y) = MRCAMat(X, Y)
'        'If MRCAMat(X, Y) = 0 Then
'        '    X = X
'        'End If
'    Next Y
'Next X

CurPos = CurPos - 1

'12 = a/-
'13 = c/-
'14 = g/-
'15 = t/-

Dim TbT() As Byte, Conv() As Byte, BtB() As Byte

'ReDim BtB(255, 4)

'BtB(0, 1) = 66
'BtB(0, 2) = 66
'BtB(0, 3) = 66
'BtB(0, 11) = 66

'BtB(1, 1) = 68
'BtB(1, 4) = 68
'BtB(1, 5) = 68
'BtB(1, 12) = 68

'BtB(2, 2) = 72
'BtB(2, 4) = 72
'BtB(2, 6) = 72
'BtB(2, 13) = 72

'BtB(3, 3) = 85
'BtB(3, 5) = 85
'BtB(3, 6) = 85
'BtB(3, 14) = 85

'BtB(4, 11) = 46
'BtB(4, 12) = 46
'BtB(4, 13) = 46
'BtB(4, 14) = 46

ReDim Conv(255)

Conv(46) = 4
Conv(66) = 0
Conv(68) = 1
Conv(72) = 2
Conv(85) = 3

'ReDim TbT(4, 4)

'TbT(0, 0) = 66
'TbT(0, 1) = 1
'TbT(0, 2) = 2
'TbT(0, 3) = 3
'TbT(0, 4) = 11

'TbT(1, 1) = 68
'TbT(1, 2) = 4
'TbT(1, 3) = 5
'TbT(1, 4) = 12

'TbT(2, 2) = 72
'TbT(2, 3) = 6
'TbT(2, 4) = 13

'TbT(3, 3) = 85
'TbT(3, 4) = 14

'TbT(4, 4) = 46 '

'For X = 0 To 3
'    For Y = X + 1 To 4
'        TbT(Y, X) = TbT(X, Y)
'    Next Y
'Next X
EE = Abs(GetTickCount)
TT = EE - SS
Dim NS As Double, S1 As Integer, S3 As Integer, s2 As Integer, n1 As Byte, n2 As Byte, P As Long, MaxT As Double
Dim THold() As Double, Maxhold() As Double
ReDim Maxhold(NextNo * 2)
ReDim THold(NextNo * 2, 4)
Form1.ProgressBar1 = 15
Call UpdateF2Prog
If x = x Then
    Dummy = MakeAnc(NextNo, Len(StrainSeq(0)), CurPos, BranchMapX(0, 0), THold(0, 0), Path(0), Identical(0), Conv(0), AncSeq(0, 0), SeqNum(0, 0))
    
Else
    For x = 1 To Len(StrainSeq(0))
        If Identical(x) = 1 Then
            For Y = 0 To NextNo
                AncSeq(x, Y) = SeqNum(x, 0)
            Next Y
        Else
            ReDim THold(NextNo * 2, 4)
            'Find known nt states at tips
            For A = 0 To NextNo
                THold(A, Conv(SeqNum(x, A))) = 1
            Next A
            'First Pass (down)
            For Z = 0 To CurPos
                
                'ns = 0
                P = Path(Z)
                S1 = BranchMap(P, 1)
                s2 = BranchMap(P, 2)
                MaxT = 0
                For A = 0 To 4
                    THold(P, A) = THold(S1, A) + THold(s2, A)
                    If THold(P, A) > MaxT Then MaxT = THold(P, A)
                Next A
                            
                'Only Keep winners
                For A = 0 To 4
                    If THold(P, A) < MaxT Then
                        THold(P, A) = 0
                    Else
                        'ns = ns + 1
                        THold(P, A) = 1
                    End If
                    
                    'If THold(P, A) > 0 Then
                    '    THold(P, A) = 1
                    'End If
                Next A
                Maxhold(P) = 1 'MaxT ' / NS
            Next Z
            
            'Second Pass (up)
            For Z = CurPos To 0 Step -1
                    
                    P = Path(Z)
                    S1 = BranchMap(P, 0)
                    s2 = BranchMap(P, 1)
                    S3 = BranchMap(P, 2)
                    MaxT = 0
                    For A = 0 To 4
                        'THold(P, A) = THold(P, A) * Maxhold(P) + THold(S1, A) + THold(S2, A) + THold(S3, A)
                        THold(P, A) = THold(S1, A) + THold(s2, A) + THold(S3, A)
                        If THold(P, A) > MaxT Then MaxT = THold(P, A)
                    Next A
                        
                    'Only Keep winners
                    For A = 0 To 4
                        If THold(P, A) < MaxT Then
                            THold(P, A) = 0
                        Else
                            
                            THold(P, A) = 1
                        End If
                    Next A
                    x = x
            Next Z
            For Z = NextNo + 1 To NextNo * 2 - 1
            '1=a/c
            '2=a/g
            '3=a/t
            '4=c/g
            '5=c/t
            '6=g/t
            '7=a/c/g
            '8=a/c/t
            '9=a/g/t
            '10=c/g/t
            '11=a/c/g/t
                If THold(Z, 4) > 0 Then
                    AncSeq(x, Z - NextNo) = 46
                ElseIf THold(Z, 0) > 0 Then
                    If THold(Z, 1) > 0 Then
                        If THold(Z, 2) > 0 Then
                            If THold(Z, 3) > 0 Then 'acgt
                                AncSeq(x, Z - NextNo) = 11
                            Else 'acg
                                AncSeq(x, Z - NextNo) = 7
                            End If
                        ElseIf THold(Z, 3) > 0 Then 'act
                            AncSeq(x, Z - NextNo) = 8
                        Else 'ac
                            AncSeq(x, Z - NextNo) = 1
                        End If
                    ElseIf THold(Z, 2) > 0 Then
                        If THold(Z, 3) > 0 Then 'agt
                            AncSeq(x, Z - NextNo) = 9
                        Else 'ag
                            AncSeq(x, Z - NextNo) = 2
                        End If
                    ElseIf THold(Z, 3) > 0 Then 'at
                        AncSeq(x, Z - NextNo) = 3
                    Else 'a
                        AncSeq(x, Z - NextNo) = 66
                    End If
                ElseIf THold(Z, 1) > 0 Then 'c
                    If THold(Z, 2) > 0 Then
                        If THold(Z, 3) > 0 Then 'cgt
                            AncSeq(x, Z - NextNo) = 10
                        Else 'cg
                            AncSeq(x, Z - NextNo) = 4
                        End If
                    ElseIf THold(Z, 3) > 0 Then 'ct
                        AncSeq(x, Z - NextNo) = 5
                    Else 'c
                        AncSeq(x, Z - NextNo) = 68
                    End If
                ElseIf THold(Z, 2) > 0 Then
                    If THold(Z, 3) > 0 Then 'gt
                        AncSeq(x, Z - NextNo) = 6
                    Else 'g
                        AncSeq(x, Z - NextNo) = 72
                    End If
                ElseIf THold(Z, 3) > 0 Then 't
                    AncSeq(x, Z - NextNo) = 85
                Else
                    
                End If
                If AncSeq(x, Z - NextNo) < 46 Then
                    x = x
                End If
                If x = 2516 Then
                    x = x
                End If
            Next Z
        End If
        x = x
    Next x
End If
'3.145s
'Make a conversion matrix
ReDim ConDeg(85, 85)
'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t
For x = 1 To 85
    UnionC(x, x) = x
Next x

For x = 1 To 11
    UnionC(11, x) = x
    UnionC(46, x) = x
    UnionC(x, 46) = x
    UnionC(x, 11) = x
Next x
UnionC(85, 68) = 5
UnionC(85, 66) = 3
UnionC(85, 72) = 6
UnionC(66, 68) = 1
UnionC(68, 72) = 4
UnionC(66, 72) = 2

UnionC(85, 1) = 1
UnionC(85, 2) = 2
UnionC(85, 3) = 85
UnionC(85, 4) = 4
UnionC(85, 5) = 85
UnionC(85, 6) = 85
UnionC(85, 7) = 7
UnionC(85, 8) = 85
UnionC(85, 9) = 85
UnionC(85, 10) = 85
UnionC(85, 11) = 85


UnionC(72, 1) = 1
UnionC(72, 2) = 72
UnionC(72, 3) = 3
UnionC(72, 4) = 72
UnionC(72, 5) = 5
UnionC(72, 6) = 72
UnionC(72, 7) = 72
UnionC(72, 8) = 8
UnionC(72, 9) = 72
UnionC(72, 10) = 72
UnionC(72, 11) = 72

UnionC(68, 1) = 68
UnionC(68, 2) = 2
UnionC(68, 3) = 3
UnionC(68, 4) = 68
UnionC(68, 5) = 68
UnionC(68, 6) = 6
UnionC(68, 7) = 68
UnionC(68, 8) = 68
UnionC(68, 9) = 9
UnionC(68, 10) = 68
UnionC(68, 11) = 68

UnionC(66, 1) = 66
UnionC(66, 2) = 66
UnionC(66, 3) = 66
UnionC(66, 4) = 4
UnionC(66, 5) = 5
UnionC(66, 6) = 6
UnionC(66, 7) = 66
UnionC(66, 8) = 66
UnionC(66, 9) = 66
UnionC(66, 10) = 10
UnionC(66, 11) = 66


UnionC(10, 1) = 68
UnionC(10, 2) = 72
UnionC(10, 3) = 85
UnionC(10, 4) = 4
UnionC(10, 5) = 5
UnionC(10, 6) = 6
UnionC(10, 7) = 4
UnionC(10, 8) = 5
UnionC(10, 9) = 6
UnionC(10, 11) = 10


UnionC(9, 1) = 66
UnionC(9, 2) = 2
UnionC(9, 3) = 3
UnionC(9, 4) = 72
UnionC(9, 5) = 85
UnionC(9, 6) = 6
UnionC(9, 7) = 2
UnionC(9, 8) = 3
UnionC(9, 10) = 6
UnionC(9, 11) = 9


UnionC(8, 1) = 1
UnionC(8, 2) = 66
UnionC(8, 3) = 3
UnionC(8, 4) = 68
UnionC(8, 5) = 5
UnionC(8, 6) = 85
UnionC(8, 7) = 1
UnionC(8, 9) = 3
UnionC(8, 10) = 5
UnionC(8, 11) = 8

UnionC(7, 1) = 1
UnionC(7, 2) = 2
UnionC(7, 3) = 66
UnionC(7, 4) = 4
UnionC(7, 5) = 68
UnionC(7, 6) = 72
UnionC(7, 8) = 1
UnionC(7, 9) = 2
UnionC(7, 10) = 4
UnionC(7, 11) = 7

UnionC(6, 1) = 11
UnionC(6, 2) = 72
UnionC(6, 3) = 85
UnionC(6, 4) = 72
UnionC(6, 5) = 85
UnionC(6, 7) = 72
UnionC(6, 8) = 85
UnionC(6, 9) = 6
UnionC(6, 10) = 6
UnionC(6, 11) = 6

UnionC(5, 1) = 68
UnionC(5, 2) = 11
UnionC(5, 3) = 85
UnionC(5, 4) = 68
UnionC(5, 6) = 85
UnionC(5, 7) = 68
UnionC(5, 8) = 5
UnionC(5, 9) = 85
UnionC(5, 10) = 5
UnionC(5, 11) = 5

UnionC(4, 1) = 68
UnionC(4, 2) = 72
UnionC(4, 3) = 11 '3
UnionC(4, 5) = 68
UnionC(4, 6) = 72
UnionC(4, 7) = 4
UnionC(4, 8) = 68
UnionC(4, 9) = 72
UnionC(4, 10) = 4
UnionC(4, 11) = 4

UnionC(3, 1) = 66
UnionC(3, 2) = 66
UnionC(3, 4) = 11 '4
UnionC(3, 5) = 85
UnionC(3, 6) = 85
UnionC(3, 7) = 66
UnionC(3, 8) = 3
UnionC(3, 9) = 3
UnionC(3, 10) = 85
UnionC(3, 11) = 3

UnionC(2, 1) = 66
UnionC(2, 3) = 66
UnionC(2, 4) = 72
UnionC(2, 5) = 11
UnionC(2, 6) = 72
UnionC(2, 7) = 2
UnionC(2, 8) = 66
UnionC(2, 9) = 2
UnionC(2, 10) = 72
UnionC(2, 11) = 2

UnionC(1, 2) = 66
UnionC(1, 3) = 66
UnionC(1, 4) = 68
UnionC(1, 5) = 68
UnionC(1, 6) = 11
UnionC(1, 7) = 1
UnionC(1, 8) = 1
UnionC(1, 9) = 66
UnionC(1, 10) = 68
UnionC(1, 11) = 1


For x = 0 To 85
    For Y = x + 1 To 85
        'If (UnionC(X, Y) > 0 Or UnionC(Y, X) > 0) And (UnionC(X, Y) <> UnionC(Y, X)) Then
        '        X = X
        '    End If
        If UnionC(x, Y) = 0 Then
            UnionC(x, Y) = UnionC(Y, x)
        Else
            
            UnionC(Y, x) = UnionC(x, Y)
        End If
        ConDeg(x, Y) = 1
    Next Y
Next x
'ConDeg(66, 68) = 1
'ConDeg(66, 72) = 1
'ConDeg(66, 85) = 1
'ConDeg(68, 72) = 1
'ConDeg(68, 85) = 1
'ConDeg(72, 85) = 1



ConDeg(1, 66) = 0.5
ConDeg(2, 66) = 0.5
ConDeg(3, 66) = 0.5
ConDeg(7, 66) = 0.6666
ConDeg(8, 66) = 0.6666
ConDeg(9, 66) = 0.6666
ConDeg(11, 66) = 0.75

'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t

ConDeg(1, 68) = 0.5
ConDeg(4, 68) = 0.5
ConDeg(5, 68) = 0.5
ConDeg(7, 68) = 0.6666
ConDeg(8, 68) = 0.6666
ConDeg(10, 68) = 0.6666
ConDeg(11, 68) = 0.75

'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t

ConDeg(2, 72) = 0.5
ConDeg(4, 72) = 0.5
ConDeg(6, 72) = 0.5
ConDeg(7, 72) = 0.6666
ConDeg(9, 72) = 0.6666
ConDeg(10, 72) = 0.6666
ConDeg(11, 72) = 0.75

'1=a/c
'2=a/g
'3=a/t
'4=c/g
'5=c/t
'6=g/t
'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t

ConDeg(3, 85) = 0.5
ConDeg(5, 85) = 0.5
ConDeg(6, 85) = 0.5
ConDeg(8, 85) = 0.6666
ConDeg(9, 85) = 0.6666
ConDeg(10, 85) = 0.6666
ConDeg(11, 85) = 0.75

'1=a/c

'2=a/g

'3=a/t

'4=c/g

'5=c/t

'6=g/t

'7=a/c/g
'8=a/c/t
'9=a/g/t
'10=c/g/t
'11=a/c/g/t


ConDeg(10, 11) = 0.75

ConDeg(9, 10) = 0.7777
ConDeg(9, 11) = 0.75

ConDeg(8, 9) = 0.7777
ConDeg(8, 10) = 0.7777
ConDeg(8, 11) = 0.75

ConDeg(7, 8) = 0.7777
ConDeg(7, 9) = 0.7777
ConDeg(7, 10) = 0.7777
ConDeg(7, 11) = 0.75

ConDeg(6, 7) = 0.8333
ConDeg(6, 8) = 0.8333
ConDeg(6, 9) = 0.6666
ConDeg(6, 10) = 0.6666
ConDeg(6, 11) = 0.75

ConDeg(5, 6) = 0.75
ConDeg(5, 7) = 0.8333
ConDeg(5, 8) = 0.6666
ConDeg(5, 9) = 0.8333
ConDeg(5, 10) = 0.6666
ConDeg(5, 11) = 0.75


ConDeg(4, 5) = 0.75
ConDeg(4, 6) = 0.75
ConDeg(4, 7) = 0.6666
ConDeg(4, 8) = 0.8333
ConDeg(4, 9) = 0.8333
ConDeg(4, 10) = 0.6666
ConDeg(4, 11) = 0.75


ConDeg(3, 4) = 1
ConDeg(3, 5) = 0.75
ConDeg(3, 6) = 0.75
ConDeg(3, 7) = 0.8333
ConDeg(3, 8) = 0.6666
ConDeg(3, 9) = 0.6666
ConDeg(3, 10) = 0.8333
ConDeg(3, 11) = 0.75

ConDeg(2, 3) = 0.75
ConDeg(2, 4) = 0.75
ConDeg(2, 5) = 1
ConDeg(2, 6) = 0.75
ConDeg(2, 7) = 0.6666
ConDeg(2, 8) = 0.8333
ConDeg(2, 9) = 0.6666
ConDeg(2, 10) = 0.8333
ConDeg(2, 11) = 0.75

ConDeg(1, 2) = 0.75
ConDeg(1, 3) = 0.75
ConDeg(1, 4) = 0.75
ConDeg(1, 5) = 0.75
ConDeg(1, 6) = 1
ConDeg(1, 7) = 0.6666
ConDeg(1, 8) = 0.6666
ConDeg(1, 9) = 0.8333
ConDeg(1, 10) = 0.8333
ConDeg(1, 11) = 0.75

ConDeg(1, 1) = 0.5
ConDeg(2, 2) = 0.5
ConDeg(3, 3) = 0.5
ConDeg(4, 4) = 0.5
ConDeg(5, 5) = 0.5
ConDeg(6, 6) = 0.5
ConDeg(7, 7) = 0.6666
ConDeg(8, 8) = 0.6666
ConDeg(9, 9) = 0.6666
ConDeg(10, 10) = 0.6666
ConDeg(11, 11) = 0.75

For x = 0 To 85
    For Y = x + 1 To 85
        ConDeg(Y, x) = ConDeg(x, Y)
    Next Y
Next x

Form1.ProgressBar1 = 55
Call UpdateF2Prog
ReDim AncDstMat(NextNo * 2, NextNo * 2)
Dim Valid As Long

'Make Ancestral sequence at root node

S1 = BranchMap(NextNo * 2, 1)
s2 = BranchMap(NextNo * 2, 2)
Dim S1V As Long, S2V As Long
For x = 0 To Len(StrainSeq(0))
    If S1 > NextNo Then
        S1V = AncSeq(x, S1 - NextNo)
    Else
        S1V = SeqNum(x, S1)
    End If
    If s2 > NextNo Then
        S2V = AncSeq(x, s2 - NextNo)
    Else
        S2V = SeqNum(x, s2)
    End If
    AncSeq(x, NextNo) = UnionC(S1V, S2V)
    x = x
Next x

If x = x Then
    Dummy = GetAncDst(NextNo, Len(StrainSeq(0)), AncSeq(0, 0), SeqNum(0, 0), AncDstMat(0, 0), ConDeg(0, 0))
Else
    For x = 0 To NextNo * 2 - 1
        For Y = NextNo + 1 To NextNo * 2 - 1
            'If BranchMap(X, 0) = Y Then
            If x <> Y Then
                If x > NextNo Then
                    Valid = 0
                    For Z = 1 To Len(StrainSeq(0))
                        If AncSeq(Z, x - NextNo) <> 46 Then
                            If AncSeq(Z, Y - NextNo) <> 46 Then
                                Valid = Valid + 1
                                AncDstMat(x, Y) = AncDstMat(x, Y) + ConDeg(AncSeq(Z, x - NextNo), AncSeq(Z, Y - NextNo))
                            End If
                        End If
                    Next Z
                Else
                    Valid = 0
                    For Z = 1 To Len(StrainSeq(0))
                        If SeqNum(Z, x) <> 46 Then
                            If AncSeq(Z, Y - NextNo) <> 46 Then
                                Valid = Valid + 1
                                AncDstMat(x, Y) = AncDstMat(x, Y) + ConDeg(SeqNum(Z, x), AncSeq(Z, Y - NextNo))
                            End If
                        End If
                    Next Z
                End If
                AncDstMat(x, Y) = AncDstMat(x, Y) / Valid
                AncDstMat(Y, x) = AncDstMat(x, Y)
            End If
        
        Next Y
        
    Next x
End If

If x = x Then
    ReDim AncSeqS(NextNo)
    For x = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            If AncSeq(Y, x) < 46 Then
                AncSeqS(x) = AncSeqS(x) + Trim(Str(AncSeq(Y, x)))
            Else
                AncSeqS(x) = AncSeqS(x) + Chr(AncSeq(Y, x) - 1)
            End If
        Next Y
    Next x
End If
Form1.ProgressBar1 = 100
Call UpdateF2Prog
EE = Abs(GetTickCount)
TT = EE - SS
x = x
End Sub


Public Sub FindSeqColours()
Dim NodeCol() As Byte, DoneNode() As Byte, NodeIncriment As Long
ReDim NodeCol(NextNo * 2, 2), DoneNode(NextNo * 2)


'Start position for colours is the root node

End Sub

Public Sub MakeAncTree(NJF As Integer)
Dim th1 As Double, th2 As Double, th3 As Double

    SS = Abs(GetTickCount)
    TSeqLen = Len(StrainSeq(0))
    ReDim BranchMap(NextNo * 2, 2)
    'If 1 < 1 Then 1 = 1
    Dim DstMat() As Single, Done() As Integer, NodeDepth() As Integer, NameWidth() As Integer, CxAdd() As Integer, NodePath() As Integer, Outside() As Integer, BootDepth() As Integer
    Dim NHFlag As Integer, NumberOfSeqs As Long, ScaleSize As Integer, NotFound As Integer, SCount As Integer, DCount As Integer, CCount As Integer, OutFlag As Integer, CSeq As Integer
    Dim PNodeStr() As Long
    Dim LSeq As Long, A As Long, b As Long, LPos As Long, x As Long, Y As Long, PosP As Long, TPos As Long, Z As Long
    Dim Boots() As String, MatchNode() As String
    Dim Getstring As String, BootName As String, Header As String, oDir As String, TString As String
    Dim Treebyte() As Byte
    Dim DLen() As Single, NodeXPos() As Single, SeqYPos() As Double, tSeqYPos() As Double, NodeYPos() As Double, LLen() As Single, SeqXPos() As Single, NewFontSize As Double
    Dim MPosO As Double, Lowest As Double, OldFontSize As Double, OutsideAdjust As Double, MPosI As Double, DrawXAdjust As Double, DrawYAdjust As Double, MaxXPos As Double, TotalAdjust As Double
    Dim MatrixByte() As Byte
    Dim MatrixLen As Long
    Dim ScaleVal As String
    Dim ScaleValD As Double
    
    Dim oRec As Long, LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim tMat() As Single, TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqnum() As Integer
    
    Dim OrderArray() As Byte
    Dim t0() As Integer, T1() As Integer, T2() As Integer
    Dim SZE As Long
    Dim TotalCycles As Long
    Dim Cnt As Long
    'Dim GoOnA() As Byte
    Dim FCount As Long
    Dim COffCount As Long
    Dim HiS As Long, LoS1 As Long, LoS2 As Long
    Dim Scratch() As Integer
    Dim bttSeqNum() As Integer
    Dim SP As Long
    Dim L1 As Long, L2 As Long
    Dim BSFileBuffer() As Integer
    Dim FCNT As Long, FCNT2 As Long
    Dim BufferSize As Long
    Dim LastT As Long

    ReDim PNodeStr(NextNo * 2)
    ReDim DLen(NextNo)
    LSeq = TSeqLen


    NumberOfSeqs = NextNo
    Form1.Picture16.FontSize = 8.25

    If 1 = 0 And (NJF = 1 Or NJF = 2) Then
    
        Form1.ProgressBar1.Value = 10
    Else
        Form1.ProgressBar1.Value = 5
    End If
    Call UpdateF2Prog
    Form2.Command2.Enabled = True
    'Sort out directory locations
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
   
    'Clean up files
    
    KillFile "outfile"
    KillFile "outfilex"
    KillFile "infile"
    On Error GoTo 0
    ReDim Boots(NextNo + 2)
    'Set up copies of sequences that can be edited and rearranged etc
    'Set up batch files

    
    If NJF = 3 Then 'ML trees
        If DebuggingFlag < 2 Then On Error Resume Next
        Open "dnadist.bat" For Output As #1
        Print #1, "fastdnaml <infile"
        'Print #1, "fastdnaml <optfile"
        'Print #1, "dnaml <optfile"
        Print #1, "del treefile"
        Print #1, "rename treefile.0 treefile "
        Close #1
        On Error GoTo 0
    End If
    
    If NJF = 3 Then
        'Do FastDNAML options file
        If Len(TempSeq(0)) > 32000 Then

            For x = 0 To NextNo
                TempSeq(x) = Left$(TempSeq(x), 32000)
            Next 'X

        End If

        Open "infile" For Output As #1
        Header = " " + Trim$(CStr((NumberOfSeqs + 1))) + "   " + Trim$(CStr(Len(TempSeq(0))))
        Header = Header + " T O"

        If TBaseFreqFlag = 1 Then
            Header = Header + " F"
        End If

        If TGRFlag = 1 Then
            Header = Header + " G"
        End If

        If TRndIOrderFlag = 1 Then
            Header = Header + " J"
        End If

        If 1 > 1 Then
            Header = Header + " B"
        End If

        If TBaseFreqFlag = 1 Then
            Header = Header + " F"
        End If

        Header = Header + " Q 4 Y"
        Print #1, Header
        Print #1, "O " & CStr(Outie + 1)

        If TBaseFreqFlag = 1 Then
            Print #1, "F " & TAfreq & " " & TCFreq & " " & TGFreq & " " & TTFreq
        End If

        If TRndIOrderFlag = 1 Then
            Print #1, "J " + Trim$(CStr(-BSRndNumSeed))
        End If

        If 1 > 1 Then
            Print #1, "B " + Trim$(CStr(-BSRndNumSeed))
        End If

        Print #1, "T " + Trim$(CStr(TTVRat))

        For x = 0 To NumberOfSeqs
            BootName = "S" & x
            BootName = BootName + String$(10 - (Len(BootName)), " ")
            TString = TempSeq(x)
            Boots(x) = BootName + TString
            Print #1, Boots(x)
        Next 'X

        'Set up the initial infile
        Close #1
        BatIndex = 4
        PBStart = Form1.ProgressBar1.Value
        PBTarget = 95
        Form1.SSPanel1.Caption = "Making ML Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    End If
Dim LS As Long
LS = TSeqLen
    'Calculate distance matrices
    If NJF = 1 Or NJF = 2 Then
        
        
        ReDim XX1(3)
        ReDim XX2(3)
        ReDim Prod1(LS)
        ReDim Prod2(LS)
        ReDim Prod3(LS)
        ReDim Alias(LS)
        ReDim Ally(LS)
        ReDim Location(LS)
        ReDim Px(NextNo, LS)
        ReDim ttSeqNum(LS, NextNo)
        ReDim DstMat(NextNo, NextNo)
        ReDim DistVal(1 + 1)
        ReDim Num1(1 + 1)
        ReDim Num2(1 + 1)
        ReDim DEN(1 + 1)
        ReDim num(1 + 1)
        ReDim WeightMod(1, LS - 1)
        ReDim tMat(NextNo, NextNo)
        ReDim SHolder((NextNo + 1) * 40 * 2)
        ReDim Scratch(LS)
        ReDim Weight(1, LS)
            For x = 0 To LS - 1
                WeightMod(0, x) = 1
            Next x
        Dim SeqScores() As Double
        ReDim SeqScores(NextNo)
        Dim MaxDScore As Double
        MaxDScore = 0
        If TModel <> 3 Then
            Form1.SSPanel1.Caption = "Calculating distances"
            Form1.ProgressBar1 = 20
            Call UpdateF2Prog
            'Dim Tmat3() As Double
            'ReDim Tmat3(1, Nextno, Nextno)
            'BootDist 1, TCoeffVar, TTVRat, TModel, Nextno + 1, LS, SeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), xx1(0), xx2(0), Prod1(0), Prod2(0), Prod3(0), Tmat3(0, 0, 0), DistVal(0), Num1(0), Num2(0), Den(0), Num(0), WeightMod(0, 0)
            
            For x = 0 To NextNo
                DstMat(x, x) = 0
                For Y = x + 1 To NextNo
                    
                    If PermValid(x, Y) > 0 Then
                        th2 = PermValid(x, Y) - PermDIffs(x, Y)
                        th1 = th2 / PermValid(x, Y)
                        
                        If th1 > 0.25 Then
                            th2 = (4# * th1 - 1#) / 3#
                            th3 = Log(th2)
                            DstMat(x, Y) = -0.75 * th3
                        Else
                            DstMat(x, Y) = 10#
                        End If
                    
                    Else
                        DstMat(x, Y) = 10#
                        
                    End If
                    DstMat(Y, x) = DstMat(x, Y)
                    
                Next Y
            Next x
            
            'For X = 0 To Nextno
            '    For Y = 0 To Nextno
            '        If CLng(DstMat(X, Y) * 1000000) <> CLng(Tmat3(0, X, Y) * 1000000) Then
            '            X = X
            '        End If
            '    Next Y
            'Next X
            Form1.SSPanel1.Caption = "Making trees"
            Form1.ProgressBar1 = 60
            Call UpdateF2Prog
            For x = 0 To NextNo
                For Y = 0 To NextNo
                    SeqScores(x) = SeqScores(x) + DstMat(x, Y)
                Next Y
            Next x
            
            For x = 0 To NextNo
                If SeqScores(x) > MaxDScore Then
                    Outie = x
                    MaxDScore = SeqScores(x)
                End If
            Next x
            
        Else
            
                ReDim Weight(BSBootReps, BSStepWin)
                Dummy = DNADIST(TCoeffVar, TTVRat, TBaseFreqFlag, TModel, TAfreq, TCFreq, TGFreq, TTFreq, NextNo + 1, TSeqLen, SeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), DstMat(0, 0))
                
                

            
            For x = 0 To NextNo
                For Y = 0 To NextNo
                    SeqScores(x) = SeqScores(x) + DstMat(x, Y)
                Next Y
            Next x
            
            For x = 0 To NextNo
                If SeqScores(x) > MaxDScore Then
                    MaxDScore = SeqScores(x)
                    Outie = x
                End If
            Next x
        End If
        
        If NJF = 1 Then
            Dim Treestring As String
            ReDim PermDist(NextNo, NextNo)
            ReDim SHolder((NextNo + 1) * 40 * 2)
            
            
                For Y = 0 To NextNo
                    For Z = 0 To NextNo
                        PermDist(Y, Z) = DstMat(Y, Z)
                        PermDist(Z, Y) = PermDist(Y, Z)
                    Next 'Z
                    
                Next 'Y
                ReDim ColTotals(NextNo)
                Dim Treearray() As Single
                ReDim Treearray(NextNo, NextNo)
                LTree = NEIGHBOUR(1, 0, -BSRndNumSeed, Outie + 1, NextNo + 1, PermDist(0, 0), SHolder(0), ColTotals(NextNo), Treearray(0, 0))
                'byte array to string
                
                Treestring = ""
                For Y = 1 To LTree
                    Treestring = Treestring + Chr$(SHolder(Y))
                Next Y
                If x = x Then
                    Getstring = Treestring
                    NHString(NHFlag) = Getstring
                    ReDim Treebyte(LTree)
                    For Y = 1 To LTree
                        Treebyte(Y - 1) = SHolder(Y)
                    Next Y
                End If
            
            If 1 > 1 Then
                Close #1
            End If
            'Exit Sub
        Else
            Open "outfilex2" For Output As #1
            Open "outfilex3" For Output As #2
            For Z = 0 To 1
                If Z = 0 Then
                        Print #2, "  " & CStr(NumberOfSeqs + 1)
                End If
                Print #1, "  " & CStr(NumberOfSeqs + 1)
    
                For x = 0 To NumberOfSeqs
                    OutString = "S" & Trim$(CStr(x)) & String$(9 - Len(Trim$(CStr(x))), " ")
                    
                    For Y = 0 To NumberOfSeqs
            
                        If DstMat(Z, x, Y) = 0 Then
                            OutString = OutString & "  0.0000"
                        ElseIf DstMat(Z, x, Y) = 1 Then
                            OutString = OutString & "  1.0000"
                        ElseIf DstMat(Z, x, Y) > 1 Then
                            OutString = OutString & "  " & Int(DstMat(Z, x, Y) * 10000) / 10000 '& String$((6 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        Else
                            OutString = OutString & "  " & Int(DstMat(Z, x, Y) * 10000) / 10000 '& String$((5 - Len(Trim$(CStr(Int(DstMat(Z, X, Y) * 10000) / 10000)))), "0")
                        End If
            
                    Next 'Y
                    If Z = 0 Then
                        Print #2, OutString
                    End If
                    Print #1, OutString
                Next 'X
            Next 'Z
            Close #2
            Close #1
        End If
        
    Else
        ShellAndClose "dnadist.bat", 0
    End If
    
    If AbortFlag = 1 Then
        If DebuggingFlag < 2 Then On Error Resume Next

        ChDir oDir
        ChDrive oDir
        On Error GoTo 0
        Exit Sub
    End If

    If 1 < 2 And (NJF = 1 Or NJF = 2) Then
        Form1.ProgressBar1.Value = 60
    ElseIf NJF = 1 Or NJF = 2 Then
        Form1.ProgressBar1.Value = 10
    End If
    Call UpdateF2Prog
    If NJF = 2 Then
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "infilex"
        On Error GoTo 0
        'AbortFlag = 1
        'Exit Sub

        
            Name "outfilex3" As "infile"
        

        'Make the NEIGHBOR optfile
        Open "optfilen" For Output As #1

        
            'If TSubRepsFlag = 1 Then
            '    Print #1, "s"
            'End If

            If TRndIOrderFlag = 1 Then
                Print #1, "j"
                Print #1, -BSRndNumSeed
            End If

            If TGRFlag = 1 Then
                Print #1, "g"
            End If

            If TNegBLFlag = 1 Then
                Print #1, "-"
            End If

            Print #1, "p"
            Print #1, Trim$(CStr(TPower))
            Print #1, "o"
            Print #1, Outie + 1
            Print #1, "2"
            'Print #1, "3"
            Print #1, "y"
        

        Close #1
        Form1.SSPanel1.Caption = "Drawing Tree"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        If DebuggingFlag < 2 Then On Error Resume Next
        Open "neighbor.bat" For Output As #1
        Print #1, "fitch <optfilen"
        Print #1, "rename outfile outfilex"
        Close #1
        On Error GoTo 0
        
        ShellAndClose "neighbor.bat", 0
        'AbortFlag = 1

        If AbortFlag = 1 Then
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            Exit Sub
        End If

    End If
    If NJF = 2 Or NJF = 3 Then
    'Open treefile and read in the tree.
        Open "treefile" For Binary Access Read As #1
    
        'Open space for the entire treefile (Both a string and a byte array)
        Getstring = String$(LOF(1), " ")
        ReDim Treebyte(LOF(1))
        Get #1, 1, Getstring
        Get #1, 1, Treebyte()
        Close #1
        NHString(NHFlag) = Getstring
    End If
    LPos = 0
    LPos = 0
    ReDim NodeDepth(NumberOfSeqs + 1, NumberOfSeqs + 1)

    For x = 0 To NumberOfSeqs + 1

        For Y = 0 To NumberOfSeqs + 1
            NodeDepth(x, Y) = -1
        Next 'Y

    Next 'X

    ReDim LLen(NumberOfSeqs + 1)
    ReDim SeqXPos(NumberOfSeqs + 1)
    ReDim Done(NumberOfSeqs + 1)
    'sort out sequence order
    DCount = 0
    LPos = 1
    CCount = -1
    Dim XNo As Long, YNo As Long, ZNo As Long, lZNo As Long, mZNo As Long
    'dim NodeNo
    ZNo = NextNo + 1
    
    For x = 0 To NextNo * 2
        BranchMap(x, 0) = -1
        BranchMap(x, 1) = -1
        BranchMap(x, 2) = -1
    Next x
    BranchMap(NextNo + 2, 0) = NextNo + 1
    Do While LPos < Len(Getstring)
        mZNo = 0
        lZNo = 0
        ZNo = NextNo + 1
        If Treebyte(LPos - 1) = 40 Then '(
            'find the matching )
            
            If CCount > -1 Then
                lZNo = ZNo
                If ZNo + 1 <= mZNo Then
                    ZNo = mZNo + 1
                Else
                    ZNo = ZNo + 1
                End If
                mZNo = ZNo
                If BranchMap(ZNo, 0) = -1 Then
                    BranchMap(ZNo, 0) = lZNo
                End If
            End If
            
            CCount = CCount + 1
            
            DCount = 1
            SCount = 0
            TPos = LPos + 1

            Do

                If Treebyte(TPos - 1) = 40 Then '(
                    DCount = DCount + 1
                    lZNo = ZNo
                    If ZNo + 1 <= mZNo Then
                        ZNo = mZNo + 1
                    Else
                        ZNo = ZNo + 1
                    End If
                    
                    mZNo = ZNo
                    If BranchMap(ZNo, 0) = -1 Then
                        BranchMap(ZNo, 0) = lZNo
                    End If
                    If lZNo > -1 Then
                        If BranchMap(lZNo, 1) = -1 And BranchMap(lZNo, 2) <> ZNo Then
                            BranchMap(lZNo, 1) = ZNo
                        ElseIf BranchMap(lZNo, 2) = -1 And BranchMap(lZNo, 1) <> ZNo Then
                            BranchMap(lZNo, 2) = ZNo
                        End If
                    End If
                ElseIf Treebyte(TPos - 1) = 41 Then ')
                    
                    
                    If ZNo > -1 Then
                        If BranchMap(ZNo, 2) = -1 Then
                            BranchMap(ZNo, 2) = lZNo
                        'ElseIf BranchMap(ZNo, 1) = -1 Then
                        '    BranchMap(ZNo, 1) = lZNo
                        End If
                        lZNo = ZNo
                        ZNo = BranchMap(ZNo, 0)
                        
                   
                    End If
                    DCount = DCount - 1

                    If DCount = 0 Then

                        If Treebyte(TPos) = 58 Then ':

                            If Treebyte(TPos + 1) = 45 Then '-

                                If NJF = 3 Then
                                    LLen(CCount) = val(Mid$(Getstring, TPos + 2, 10))
                                Else
                                    LLen(CCount) = val(Mid$(Getstring, TPos + 2, 8))
                                End If

                                PNodeStr(CCount) = TPos
                            Else

                                If NJF = 3 Then
                                    LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 9))
                                Else
                                    LLen(CCount) = 0 'Val(Mid$(GetString, TPos + 2, 7))
                                End If

                                PNodeStr(CCount) = TPos
                            End If

                        Else
                            LLen(CCount) = 0
                            PNodeStr(CCount) = TPos
                        End If

                        Exit Do
                    End If

                ElseIf Treebyte(TPos - 1) = 83 And DCount > 0 Then  'If character is "S" - indicates a sequence name
                    
                    PosP = InStr(TPos, Getstring, ":", vbBinaryCompare)
                    CSeq = val(Mid$(Getstring, TPos + 1, PosP - TPos - 1))
                    If ZNo > -1 Then
                        If BranchMap(CSeq, 0) = -1 Then
                            BranchMap(CSeq, 0) = ZNo
                        End If
                    
                        If BranchMap(ZNo, 1) = -1 And BranchMap(ZNo, 2) <> CSeq Then
                            BranchMap(ZNo, 1) = CSeq
                        ElseIf BranchMap(ZNo, 2) = -1 And BranchMap(ZNo, 1) <> CSeq Then
                            BranchMap(ZNo, 2) = CSeq
                        End If
                    Else
                        
                    End If
                    NodeDepth(CCount, SCount) = CSeq
                    SCount = SCount + 1

                    If Done(CSeq) = 0 Then
                        Done(CSeq) = 1

                        If Treebyte(PosP) = 45 Then  '-

                            If NJF = 3 Then
                                SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 10))
                            Else
                                SeqXPos(CSeq) = 0 'Val(Mid$(GetString, PosP + 1, 8))
                            End If

                        Else

                            If NJF = 3 Then
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 9))
                            Else
                                SeqXPos(CSeq) = val(Mid$(Getstring, PosP + 1, 7))
                            End If

                        End If

                    End If

                End If

                TPos = TPos + 1
            Loop

        End If

        LPos = LPos + 1
        
    Loop
    
    BranchMap(NextNo + 1, 0) = Outie 'This is a big problem
    
    'Find midpoint between the two largest distances in the tree
    
    Dim NLen() As Double, DoneSeq() As Long, TallyDist As Double
    ReDim NLen(NextNo * 2 + 1)
    
    For x = 0 To NextNo
        NLen(x) = SeqXPos(x)
        NLen(x + NextNo + 1) = LLen(x)
    Next x
    
    ReDim TMat2(NextNo * 2, NextNo * 2)
    ReDim DoneSeq(NextNo * 2)
    
    
    'Store Unrooted Branchmap in BranchmapX - Branchmap is used to store the rooted Branchmap
    ReDim BranchMapX(NextNo * 2, 2)
    For x = 0 To NextNo * 2
        For Y = 0 To 2
            BranchMapX(x, Y) = BranchMap(x, Y)
        Next Y
    Next x
    
    
    'Make an MRCA list - it must be remade later to take account of the reorganisd
    'branchmap
    Dim Path() As Long, DonePath() As Long
    Dim StartP As Long
    Dim CurPos As Long, CurPosB As Long
    ReDim Path(NextNo)
    ReDim DonePath(NextNo * 2)
    Outie = Outie
    'Work out the order of the read.
    CurPos = 0
    Dim TopNode() As Integer
    ReDim TopNode(NextNo * 2)
    'Initialise array
    For x = 0 To NextNo
        TopNode(x) = -1
        For Y = 0 To NextNo - 1
            Path(x) = -1
        Next Y
    Next x
    
    Dim backup() As Long
    
    ReDim backup(NextNo)
    CurPos = 0
    Dim MRCAMat() As Long
    ReDim MRCAMat(NextNo * 2, NextNo * 2)

    For x = NextNo To NextNo * 2
        
        'BranchMap(X, 0) = BranchMap(X, 0)
        If DonePath(x) = 0 And BranchMap(x, 1) > -1 And BranchMap(x, 2) > -1 Then
            If TopNode(BranchMap(x, 1)) = -1 And TopNode(BranchMap(x, 2)) = -1 Then
                MRCAMat(BranchMap(x, 1), BranchMap(x, 2)) = x
                MRCAMat(BranchMap(x, 2), BranchMap(x, 1)) = x
                Path(CurPos) = x
                CurPos = CurPos + 1
                TopNode(x) = -1
                DonePath(x) = -1
                x = NextNo
            End If
         End If
    Next x
    
    For x = NextNo + 1 To NextNo * 2
        For Y = 0 To NextNo * 2
            If MRCAMat(x, Y) > 0 Then
                MRCAMat(BranchMap(x, 1), Y) = MRCAMat(x, Y)
                MRCAMat(Y, BranchMap(x, 1)) = MRCAMat(x, Y)
                MRCAMat(BranchMap(x, 2), Y) = MRCAMat(x, Y)
                MRCAMat(Y, BranchMap(x, 2)) = MRCAMat(x, Y)
                MRCAMat(x, Y) = 0
                MRCAMat(Y, x) = 0
                'BranchMap(X, 0) = BranchMap(X, 0)
                'X = Nextno
                If BranchMap(x, 2) < BranchMap(x, 1) And BranchMap(x, 2) > NextNo Then
                    If BranchMap(x, 2) < x Then
                        x = BranchMap(x, 2) - 1
                    Else
                        x = x - 1
                    End If
                ElseIf BranchMap(x, 1) > NextNo Then
                    If BranchMap(x, 1) < x Then
                        x = BranchMap(x, 1) - 1
                    Else
                        x = x - 1
                    End If
                Else
                    If BranchMap(x, 2) <= NextNo Or BranchMap(x, 1) <= NextNo Then
                        'X = Nextno
                        x = x - 1
                    Else
                        x = x - 1
                    End If
                End If
                'X = Nextno
                Exit For
                'mrcamat(branchmap(mrcamat(x,1)),y)=
            End If
        Next Y
        x = x
    Next x
    For x = 0 To NextNo
        If x <> Outie Then
            MRCAMat(Outie, x) = NextNo + 1
            MRCAMat(x, Outie) = NextNo + 1
        End If
    Next x
    'For X = 0 To Nextno * 2
    '    For Y = X + 1 To Nextno * 2
    '        MRCAMat(X, Y) = MRCAMat(X, Y)
    '    Next Y
    'Next X
    'find midpoint of the tree
    
    'Work out distances between seqs and nodes on the way to the provisional root (outie)
    For x = 0 To NextNo
        CPos = x
        TallyDist = 0
        Do
            TallyDist = TallyDist + NLen(CPos)
            TMat2(x, BranchMap(CPos, 0)) = TallyDist
            
            CPos = BranchMap(CPos, 0)
            If CPos <= NextNo Then Exit Do
        Loop
    Next x
    'calculate distances and find the max
    Dim HiDist As Double, WinPair(1) As Long, MiDDist As Double
    HiDist = 0
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            MRCA = MRCAMat(x, Y)
            TMat2(x, Y) = TMat2(x, MRCA) + TMat2(Y, MRCA)
            If TMat2(x, Y) > HiDist Then
                WinPair(0) = x
                WinPair(1) = Y
                HiDist = TMat2(x, Y)
            End If
            x = x
        Next Y
    Next x
    
    'find branch midway between the two most distant sequences
    MiDDist = HiDist / 2
    
    
    Dim WinBranch(1)
    
    GoOn = 1
    For x = 0 To 1
        
        CPos = BranchMap(WinPair(x), 0)
        LPos = WinPair(x)
        TallyDist = 0
        TallyDist = TallyDist + NLen(LPos)
        If GoOn = 1 Then
            Do
                If TallyDist > MiDDist Then
                    WinBranch(0) = LPos
                    WinBranch(1) = CPos
                    GoOn = 0
                    Exit Do
                End If
                If CPos = NextNo + 1 Then
                    GoOn = 1
                    Exit Do
                End If
                LPos = CPos
                CPos = BranchMap(CPos, 0)
                TallyDist = TallyDist + NLen(LPos)
            Loop
        End If
    Next x
    'WinBranch(1) = 13
    'WinBranch(0) = 14
    
    'reorder branchmap around the winbranch (ie midbranch)
    BranchMap(WinBranch(0), 0) = NextNo * 2
    
    For x = 0 To 2
        If BranchMap(WinBranch(1), x) = WinBranch(0) Then Exit For
    Next x
    
    ' BranchMap(WinBranch(1), 0)
    LPos = BranchMap(WinBranch(1), 0)
    BranchMap(WinBranch(1), 0) = NextNo * 2
    
    If x > 0 Then
        BranchMap(WinBranch(1), x) = LPos
    End If
    BranchMap(NextNo * 2, 1) = WinBranch(0)
    BranchMap(NextNo * 2, 2) = WinBranch(1)
    NPos = WinBranch(1)
    CPos = LPos
    Do While CPos > NextNo + 1
        For x = 1 To 2
            If BranchMap(CPos, x) = NPos Then Exit For
        Next x
        
        LPos = BranchMap(CPos, 0)
        BranchMap(CPos, 0) = NPos
        BranchMap(CPos, x) = LPos
        NPos = CPos
        CPos = LPos
    Loop
    
    'Change old root to just another node
    LPos = BranchMap(NextNo + 1, 0)
    
    For x = 1 To 2
        If BranchMap(CPos, x) = NPos Then Exit For
    Next x
    x = x
    If x < 3 Then
        BranchMap(NextNo + 1, 0) = NPos
        BranchMap(NextNo + 1, x) = LPos
    End If
    
    
    For x = 0 To NextNo * 2
        For Y = 0 To 2
            BranchMap(x, Y) = BranchMap(x, Y)
        Next Y
    Next x
    
    
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1 = 0
    Call UpdateF2Prog
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
    Form1.SSPanel6(1).Enabled = True
    Form1.Picture16.Enabled = True
    
    Form2.Command2.Enabled = False
End Sub
Public Sub StartTree()
    Form1.SSPanel1.Caption = "Drawing tree"
    Screen.MousePointer = 11
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    TreeTypeFlag = 0
    Form1.Picture16.Picture = LoadPicture()
   Form1.Label14 = "UPGMA ignoring recombination"
    
    
    
    If NJFlag = 0 Or x = x Then

        Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
        
        NJFlag = 1
    End If

    Form1.ProgressBar1.Value = 90
    
    Call UpdateF2Prog
    Call DrawTree
    
  
    
    If RelX > 0 Or RelY > 0 Then
        Call DoTreeColour(Form1.Picture16, 0, 0)
        For TNum = 0 To 2
            For TType = 0 To 5
                Call DoTreeLegend(TNum, TType, TreeBlocksL(), TBLLen, Form1.Picture16, 0, 14)
            Next TType
        Next TNum
        Call DoTreeLegend(3, 0, TreeBlocksL(), TBLLen, Form1.Picture16, 0, 14)
    End If
    
    Form1.ProgressBar1.Value = 100
    Form1.SSPanel6(1).Visible = True
    Form1.SSPanel6(0).Visible = False
    Form1.SSPanel6(2).Visible = False
    Screen.MousePointer = 0
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
    NJDrawFlag = 1
End Sub
Public Sub GCDrawC()
    'This subroutine writes the GC option file used for displaying fragments for the GC check.
    'It also begins background GC execution for this check.

    Dim x As Long, Y As Long
    Dim oDir As String, LList As String

    'Make sure we're working in the RDP root Dir
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    If DoScans(0, 1) = 0 Then
        Open "tf" For Output As #1
        'output in FASTA format
    
        For x = 0 To NextNo
    
            If MaskSeq(x) <= 1 Then
    
                If MaskSeq(x) = 1 Then MaskFlag = 1
                Print #1, ">" & StraiName(x)
                Print #1, StrainSeq(x)
            End If
    
        Next 'X
    
        Close #1
    End If
    GCOFile = App.Path & "\pout.frags"
    GCPOutCfg = App.Path & "\pout.cfg"
    Open "pout.cfg" For Output As #1
    Print #1, "#GCONV_CONFIG"
    Print #1, "-Seqfile=tf"
    Print #1, "-Outfile=pout"
    Print #1, "-ExpFormat"

    If CircularFlag = 0 Then
        Print #1, "-Linear"
    Else
        Print #1, "-Circular"
    End If

    If GCSeqTypeFlag = 0 Then
        Print #1, "-Seqtype=AUTO"
    ElseIf GCSeqTypeFlag = 1 Then
        Print #1, "-Seqtype=NUCL"
    ElseIf GCSeqTypeFlag = 2 Then
        Print #1, "-Seqtype=SIL"
    ElseIf GCSeqTypeFlag = 3 Then
        Print #1, "-Seqtype=PROT"
    End If

    If GCIndelFlag = 0 Then
        Print #1, "-Skip_indels"
    ElseIf GCIndelFlag = 1 Then
        Print #1, "-Indel_blocs"
    ElseIf GCIndelFlag = 2 Then
        Print #1, "-Use_individual_indels"
    End If

    

    If GCMonoSiteFlag <> 0 Then Print #1, "-Include_monosites"
    Print #1, "-Base_range=" & GCSeqRange(0) & "-" & GCSeqRange(1)
    Print #1, "-SortName"
    'Print #1, "-Nolog"

    If GCMissmatchPen > 0 Then Print #1, "-Gscale=" & GCMissmatchPen
    Print #1, "-ListGlobal=0"
    Print #1, "-ListPerPair=50"
    Print #1, "-Minlength=" & GCMinFragLen
    Print #1, "-Minnpoly=" & GCMinPolyInFrag
    Print #1, "-Minscore=" & GCMinPairScore

    If GCMaxOverlapFrags < 10 Then
        Print #1, "/v10"
    Else
        Print #1, "-Maxoverlap=" & GCMaxOverlapFrags
    End If

    If GCNumPerms > 0 Then
        Print #1, "-Numsim=1000"
        Print #1, "-Nomaxsimpval"

        If GCPermPolyFlag = 0 Then
            Print #1, "-Simp_poly_only"
        Else
            Print #1, "-Mult_poly_only"
        End If

    Else
        Print #1, "-Numsim=0"
    End If

    Print #1, "-Maxkapairwisepval=0.99999"

    If MaskFlag = 1 Then
        LList$ = ""

        For x = 0 To NextNo

            If MaskSeq(x) = 0 Then

                For Y = x + 1 To NextNo

                    If MaskSeq(Y) = 0 Then
                        LList$ = LList$ + StraiName(x) + "," + StraiName(Y) + " "
                    End If

                Next 'Y

            End If

        Next 'X

        Print #1, "-Listonly=" + LList$
    End If

    Close #1
    'Execute GC
    gcProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, Shell("geneconv pout.cfg", 0))
    'Exit Sub
    If GCFoundSitesFlag = 0 Then
        Call GCFindSites
    End If
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End Sub

Public Sub GCDraw()

    
    
    Form1.Picture7.ForeColor = 0
    ReDim MCPrintData(Len(StrainSeq(0)))
    ReDim MCPrintPos(Len(StrainSeq(0)), 1)

    Dim TW As Integer
    Dim Pict As Long, CurPPos As Long, x As Long, Tmp As Long, NPos As Long
    Dim Zero As String, Temp As String, TargetCompare As String, TempEnd As String
    Dim COff As Double, MinPA As Double
    MinPA = 1

    If Seq1 = Seq2 Then Seq1 = Seq3
    CurPPos = 0
    Form1.Picture7.Picture = LoadPicture()
    Form1.Picture7.Height = Form1.Picture10.ScaleHeight
    Form1.Picture1.Enabled = True
    Form1.Picture7.Enabled = True
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
   
    Dim GlobalAddj As Long
    Dim Unmasked As Long

    For x = 0 To NextNo

        If MaskSeq(x) < 2 Then
            Unmasked = Unmasked + 1
        End If

    Next 'X

    GlobalAddj = (Unmasked * (Unmasked - 1) / 2)

    Dim X1 As Integer
    Dim X2 As Integer
    Dim Y1 As Integer
    Dim Y2 As Integer
    Dim Prob As Double
    Dim Beginning As Long
    Dim Ending As Long
    Dim retVal As Long

    'Dim hProcess As Long

    Dim YScaleFactor As Double

    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    NextGCImage = NextGCImage + 1

    If NextGCImage = 11 Then NextGCImage = 1

    If Seq1 > Seq2 Then
        Tmp = Seq1
        Seq1 = Seq2
        Seq2 = Tmp
    End If

    If Seq1 = NextNo + 1 Then Seq1 = Seq2

    If Seq2 = NextNo + 1 Then Seq2 = Seq1
    Seq1S$ = StraiName(Seq1)
    

   
        
        


    Form1.SSPanel1.Caption = "Executing GENECONV"

    If gcProcess > 0 Then
        Const STILL_ACTIVE = &H103

        Do
            Sleep (100)
            GetExitCodeProcess gcProcess, retVal
        Loop While retVal = STILL_ACTIVE

        Dummy = CloseHandle(gcProcess)
        gcProcess = 0
    End If

    MinP = -1
    Open GCOFile For Binary Access Read As #1
    'Close #1
    'Open GCOFile For Binary Access Read As #1

    Dim Results As String

    Results = String$(10000, " ")

    Dim FLen As Long

    FLen = LOF(1)

    If FLen < 10000 Then Results = String$(FLen, " ")

    Dim CurrentStart As Long

    CurrentStart = 1

    Dim TargetString As String

    Do

        If CurrentStart < 1 Then CurrentStart = 1
        Get #1, CurrentStart, Results

        If XoverList(RelX, RelY).OutsideFlag <> 1 Or (Seq1 <> Seq2 And Seq1 <> NextNo + 1 And Seq2 <> NextNo + 1) Or (Seq1 <> Seq3 And Seq3 <> NextNo + 1 And Seq1 <> NextNo + 1) Or XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Then
            TargetString = StraiName(Seq1) + ";" + StraiName(Seq2)
            NPos = InStr(1, Results, TargetString, vbBinaryCompare)

            If NPos = 0 Then
                TargetString = StraiName(Seq2) + ";" + StraiName(Seq1)
                NPos = InStr(1, Results, TargetString, vbBinaryCompare)
            End If

        Else
            TargetString = "  " + StraiName(Seq1) + "  "
            NPos = InStr(1, Results, TargetString, vbBinaryCompare)

            If FLen > 10000 And CurrentStart = 1 Then
                NPos = InStr(NPos + 1, Results, TargetString, vbBinaryCompare)
            End If

        End If

        If NPos > 0 Then Exit Do

        If NPos = 0 And CurrentStart = FLen - 10000 Then
            Close #1
            Exit Sub
        End If

        CurrentStart = CurrentStart + 10000

        If CurrentStart + 10000 > FLen And FLen > 0 And CurrentStart - 10000 > 0 Then CurrentStart = FLen - 10000

        If FLen = 0 Then
            Close #1
            Exit Sub
        End If

    Loop

    TargetString = Trim$(TargetString)

    If NPos = 0 Then Exit Sub

    If CurrentStart <> FLen - 10000 Then
        NPos = NPos + CurrentStart - 1
    Else
        NPos = FLen - 10000 + NPos
    End If

    Close #1

    If NPos > 0 Then
        Form1.Picture7.Picture = LoadPicture()
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        Form1.Picture7.Top = -1
        Open GCOFile For Binary Access Read As #1
        Get #1, NPos - 10, Temp$

        Do
            Input #1, Temp$

            If Left$(Temp$, 2) = "PI" Or Left$(Temp$, 2) = "PO" Then
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                TargetCompare$ = Mid$(Temp$, 1, NPos - 1)

                If TargetCompare$ <> TargetString Then Exit Do
                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                If GCNumPerms > 0 Then
                    NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                    If NPos > 0 Then
                        Prob = val(Mid$(Temp$, 1, NPos - 1))
                        Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                    End If

                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Prob = val(Mid$(Temp$, 1, NPos - 1))

                    If Prob = 1 Then Exit Do

                    If MinP = -1 Then MinP = -Log10(Prob)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Beginning = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            Ending = val(Mid$(Temp$, 1, NPos - 1))
                            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                        End If

                    ElseIf Left$(TempEnd$, 2) = "CA" Then
                        'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                        Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                    Else
                        Ending = val(TempEnd$)
                    End If

                End If
                If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                        ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                    Else
                        ET2 = XoverList(RelX, RelY).Ending
                    End If

                    BT2 = XoverList(RelX, RelY).Beginning
                If Beginning < Ending Then
                    If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                        BT1 = Beginning + Len(StrainSeq(0))
                        ET1 = Ending + Len(StrainSeq(0))
                    Else
                        BT1 = Beginning
                        ET1 = Ending
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then
                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Decompress(Beginning) * XFactor + XFactor
                    X2 = 30 + Decompress(Ending) * XFactor + XFactor
                    Prob = -Log10(Prob)
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                Else
                    BT1 = Beginning
                    ET1 = Ending + Len(StrainSeq(0))
                    If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                        BT2 = BT2 + Len(StrainSeq(0))
                        ET2 = ET2 + Len(StrainSeq(0))
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then

                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Decompress(Beginning) * XFactor + XFactor
                    X2 = 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor
                    Prob = -Log10(Prob)
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Len(StrainSeq(0))
                    CurPPos = CurPPos + 1
                    Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = 1
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    X1 = 30 + 0 * XFactor + XFactor
                    X2 = 30 + Decompress(Ending) * XFactor + XFactor
                    'Prob = -log10(Prob)
                    Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                End If
                
            ElseIf Left$(Temp$, Len(TargetString)) = TargetString Then
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)
                Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Prob = val(Mid$(Temp$, 1, NPos - 1))
                    'If Prob = 0 Then

                    If MinP = -1 Then MinP = -Log10(Prob)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    Beginning = val(Mid$(Temp$, 1, NPos - 1))
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                End If

                NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                If NPos > 0 Then
                    TempEnd$ = Mid$(Temp$, 1, NPos - 1)
                    Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))

                    If TempEnd$ = "CA" Then
                        NPos = InStr(1, Temp$, " ", vbBinaryCompare)

                        If NPos > 0 Then
                            Ending = val(Mid$(Temp$, 1, NPos - 1))
                            Temp$ = Trim$(Mid$(Temp$, NPos, Len(Temp$) - NPos + 1))
                        End If

                    ElseIf Left$(TempEnd$, 2) = "CA" Then
                        'npos = InStr$(1, Temp$, " ", vbBinaryCompare)
                        Ending = val(Mid$(TempEnd, 3, Len(TempEnd) - 2))
                    Else
                        Ending = val(TempEnd$)
                    End If

                End If
                If XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
                    ET2 = XoverList(RelX, RelY).Ending + Len(StrainSeq(0))
                Else
                    ET2 = XoverList(RelX, RelY).Ending
                End If

                BT2 = XoverList(RelX, RelY).Beginning
                If Beginning < Ending Then
                    If Ending < BT2 And ET2 > Len(StrainSeq(0)) Then
                        BT1 = Beginning + Len(StrainSeq(0))
                        ET1 = Ending + Len(StrainSeq(0))
                    Else
                        BT1 = Beginning
                        ET1 = Ending
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then
                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Decompress(Beginning) * XFactor + XFactor
                    X2 = 30 + Decompress(Ending) * XFactor + XFactor
                    Prob = -Log10(Prob)
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                Else
                    BT1 = Beginning
                    ET1 = Ending + Len(StrainSeq(0))
                    If ET2 < BT1 And ET1 > Len(StrainSeq(0)) Then
                        BT2 = BT2 + Len(StrainSeq(0))
                        ET2 = ET2 + Len(StrainSeq(0))
                    End If
                    If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                        If ET2 - BT1 > ET1 - BT2 Then

                            If (ET1 - BT2) / (ET2 - BT1) > 1 / 3 Then Addfrag = 1
                        Else

                            If (ET2 - BT1) / (ET1 - BT2) > 1 / 3 Then Addfrag = 1
                        End If

                        If MinPA > Prob Then MinPA = Prob
                    End If
                    X1 = 30 + Decompress(Beginning) * XFactor + XFactor
                    X2 = 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor
                    Prob = -Log10(Prob)
                    Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = Beginning
                    MCPrintPos(CurPPos, 1) = Len(StrainSeq(0))
                    CurPPos = CurPPos + 1
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                    MCPrintData(CurPPos) = Prob
                    MCPrintPos(CurPPos, 0) = 1
                    MCPrintPos(CurPPos, 1) = Ending
                    CurPPos = CurPPos + 1
                    X1 = 30 + 0 * XFactor + XFactor
                    X2 = 30 + Decompress(Ending) * XFactor + XFactor
                    'Prob = -log10(Prob)
                    Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
                    Y2 = PicHeight - 0
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 0, 0), B
                End If

            Else

                If Left$(Temp$, 1) = "#" Then
                    Exit Do
                End If

            End If

        Loop

        Close #1
        
        ReDim GPVTFont(5, 100), GPVText(100)
        GPVTNum = -1
        
        Form1.Picture7.Line (25, 30)-(25, PicHeight), QBColor(0)
        Form1.Picture7.Line (25, PicHeight)-(Form1.Picture7.ScaleWidth - 5, PicHeight), QBColor(0)
        Pict = Form1.Picture7.hdc
        
        Dummy = DrawDiffs(Pict, Len(GCXOverSeq(0)), XFactor, GCXDiffPos(0))
        
        'Y-Axis tick marks
        Form1.Picture7.Line (25, 35)-(28, 35), QBColor(0)
        Form1.Picture7.Line (25, PicHeight)-(28, PicHeight), QBColor(0)
        Form1.Picture7.Line (25, 35 + (PicHeight - 35) / 2)-(28, 35 + (PicHeight - 35) / 2), QBColor(0)
        'X-Axis tick marks
        Form1.Picture7.Line (30, PicHeight)-(30, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (Form1.Picture7.ScaleWidth - 10, PicHeight)-(Form1.Picture7.ScaleWidth - 10, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, PicHeight + 3), QBColor(0)
        Form1.Picture7.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, PicHeight + 3), QBColor(0)
        'Form1.Picture7.Line (5, 20)-(Form1.Picture7.ScaleWidth - 10, 20), QBColor(0)

        Dim XVal As String

        'Form1.Picture7.FontSize = 7
        Form1.Picture7.ForeColor = 0
        Form1.Picture7.CurrentY = 29
        Form1.Picture7.CurrentX = 5

        Dim Outnum As Double
        Dim DecPlace As Double

        If MinP < 10 Then
            DecPlace = (Int(MinP * 10)) / 10
            Zero$ = " 0.0"
        ElseIf MinP < 100 Then
            DecPlace = Int(MinP)
            Zero$ = " 0"
        Else
            DecPlace = Int(MinP)
            Form1.Picture7.CurrentX = 0
            Zero$ = "  0"
        End If

        MinPVal = MinP
        Outnum = DecPlace
        'OutNum = (Int(MCMinChiP * 10)) / 10

        If Outnum >= 1 Then

            If Int(Outnum) <> Outnum Then
                Form1.Picture7.Print Trim$(CStr(Outnum))
            Else
                Form1.Picture7.Print Trim$(CStr(Outnum)) & ".0"
            End If

        Else
            Form1.Picture7.Print Trim$(CStr(Outnum))
        End If

        'ctmp$ = cstr(decplace)
        'Form1.Picture7.Print ctmp$
        Form1.Picture7.CurrentY = (29 + (PicHeight - 6 - 29) / 2)
        Form1.Picture7.CurrentX = 5

        If MinP < 20 Then
            DecPlace = (Int((MinP / 2) * 10)) / 10
        ElseIf MinP < 200 Then
            DecPlace = Int(MinP / 2)
        Else
            DecPlace = Int(MinP / 2)
            Form1.Picture7.CurrentX = 0
        End If

        Outnum = DecPlace
        'OutNum = (Int(MCMinChiP * 10)) / 10

        If Outnum >= 1 Then

            If Int(Outnum) <> Outnum Then
                Form1.Picture7.Print Trim$(CStr(Outnum))
            Else
                Form1.Picture7.Print Trim$(CStr(Outnum)) & ".0"
            End If

        Else
            Form1.Picture7.Print Trim$(CStr(Outnum))
        End If

        'ctmp$ = cstr(OutNum)
        'Form1.Picture7.Print ctmp$
        Form1.Picture7.CurrentY = PicHeight - 6
        Form1.Picture7.CurrentX = 5
        Form1.Picture7.Print Zero$
        Form1.Picture7.CurrentY = PicHeight + 6
        Form1.Picture7.CurrentX = 29
        Form1.Picture7.Print "1"
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)) / 4)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4 - ((Len(XVal) + 1) / 2) * 5.5
        Form1.Picture7.Print Int(Len(StrainSeq(0)) / 4)
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)) / 2)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 2 - (((Len(XVal) + 1) / 2) * 5.5)
        Form1.Picture7.Print Int(Len(StrainSeq(0)) / 2)
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)) / 1.333)
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333 - (((Len(XVal) + 1) / 2) * 5.5)
        Form1.Picture7.Print Int(Len(StrainSeq(0)) / 1.3333)
        Form1.Picture7.CurrentY = PicHeight + 6
        XVal = Int(Len(StrainSeq(0)))
        Form1.Picture7.CurrentX = Form1.Picture7.ScaleWidth - 10 - (Len(XVal) - 1) * 5.5
        Form1.Picture7.Print Len(StrainSeq(0))
        Form1.Picture7.CurrentY = PicHeight + 15
        Form1.Picture7.CurrentX = 30 + (Form1.Picture7.ScaleWidth - 10 - 10) / 2 - (21 / 2) * 5
        Form1.Picture7.Print "Position in alignment"
        'Y-axis text
        'Form1.Picture10.Enabled = True
        Form1.Picture10.Picture = LoadPicture()
        Form1.Picture10.CurrentX = 5
        Form1.Picture10.FontSize = 6
        TW = Form1.Picture7.TextWidth("Pairwise identity")
        Form1.Picture10.CurrentY = 30 + ((PicHeight - 30) + TW) / 2

        Call DoText(Form1.Picture10, Form1.Picture10.Font, "-Log(KA P-Value)", 90)

        ' cutt-off line

        If ExeCheckFlag = 0 Then

            If MCFlag = 0 Then
                COff = -Log10(LowestProb / GlobalAddj)
            Else
                COff = -Log10(LowestProb)
            End If

            Y1 = PicHeight - (0 + (COff / MinP) * (PicHeight - 35))
            Form1.Picture7.DrawStyle = 2
            Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
            Form1.Picture7.DrawStyle = 0
            
        Else
            Form1.Picture7.DrawStyle = 2
            COff = -Log10(LowestProb / GlobalAddj)
            Y1 = PicHeight - (0 + (COff / MinP) * (PicHeight - 35))
            Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
            COff = -Log10(LowestProb)
            Y1 = PicHeight - (0 + (COff / MinP) * (PicHeight - 35))
            Form1.Picture7.Line (25, Y1)-(Form1.Picture7.ScaleWidth - 5, Y1), QBColor(0)
            Form1.Picture7.DrawStyle = 0
        End If

        If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
            X1 = 30 + Decompress(XoverList(RelX, RelY).Beginning) * XFactor + XFactor
            X2 = 30 + Decompress(XoverList(RelX, RelY).Ending) * XFactor + XFactor
            Prob = XoverList(RelX, RelY).Probability / GlobalAddj
            Prob = -Log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
        Else
            X1 = 30 + Decompress(XoverList(RelX, RelY).Beginning) * XFactor + XFactor
            X2 = 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor
            Prob = XoverList(RelX, RelY).Probability / GlobalAddj
            Prob = -Log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.DrawMode = 12
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            X1 = 30 + 0 * XFactor + XFactor
            X2 = 30 + Decompress(XoverList(RelX, RelY).Ending) * XFactor + XFactor
            'Prob = XOverList(RelX, RelY).Probability / globaladdj
            'Prob = -log10(Prob)
            Y1 = PicHeight - (0 + (Prob / MinP) * (PicHeight - 35))
            Y2 = PicHeight - 0
            Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(0, 255, 255), BF
            Form1.Picture7.DrawMode = 13
        End If

        If ORFFlag = 1 Then
            'Form1.Picture20.Picture = Form1.Picture19.Image
            Call DrawORFsP20
            Form1.Picture20.Visible = True
        End If

    End If
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    If Confirm(EN, 1) > 0 Then
        If Abs(ConfirmP(EN, 1)) < 300 Then
            PT = 10 ^ (-ConfirmP(EN, 1))
        Else
            PT = 10 ^ 300
        End If
    Else
        PT = 1
    End If
    
    If (Confirm(EN, 1) = 0 Or (Confirm(EN, 1) = 1 And MinPA < PT)) And MinPA < 1 And XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
        Confirm(EN, 1) = 1
        ConfirmP(EN, 1) = -Log10(MinPA)
        

        If Form1.HScroll3.Value = 0 Then
            Form1.HScroll3.Value = 1
        Else
            Form1.HScroll3.Value = 0
        End If
        Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

    End If
    If MCFlag = 0 Then

        MinPA = MinPA * MCCorrect
    End If
    ProbTest = MinPA
    ProbY = 1

    If XoverList(RelX, RelY).Ending > XoverList(RelX, RelY).Beginning Then
        ProbX = Decompress(XoverList(RelX, RelY).Beginning) + (Decompress(XoverList(RelX, RelY).Ending) - Decompress(XoverList(RelX, RelY).Beginning)) / 2

        If SPF = 0 Then
            If DontRedrawPlotsFlag = 0 Then
                Call PrintProbability
            End If
            If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                XoverList(RelX, RelY).Probability = MinPA
            End If
        End If
        If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
            BestParent = CheckParent: WinMethod = 1
            BestParentP = MinPA
        End If
        
    Else

        If Len(StrainSeq(0)) - XoverList(RelX, RelY).Beginning > XoverList(RelX, RelY).Ending Then
            ProbX = Decompress(XoverList(RelX, RelY).Beginning) + (Decompress(Len(StrainSeq(0))) - Decompress(XoverList(RelX, RelY).Beginning)) / 2

            If SPF = 0 Then
                If DontRedrawPlotsFlag = 0 Then
                    Call PrintProbability
                
                End If
                If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                    XoverList(RelX, RelY).Probability = MinPA
                End If
            End If
            If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                BestParent = CheckParent: WinMethod = 1
                BestParentP = MinPA
            End If
            
        Else
            ProbX = Decompress(XoverList(RelX, RelY).Ending) / 2

            If SPF = 0 Then
                If DontRedrawPlotsFlag = 0 Then
                    Call PrintProbability
                End If
                If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                    XoverList(RelX, RelY).Probability = MinPA
                End If
            End If
            If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                BestParent = CheckParent: WinMethod = 1
                BestParentP = MinPA
            End If
            
        End If

    End If
    
    Form1.Picture7.Top = -1
End Sub

Public Sub LoadDNAMAN1()

    Dim CurrentShortest As Integer, LenSeg As Integer, NF As Integer
    Dim LPos As Long, PosN1 As Long, PosN2 As Long, x As Long, LastPos As Long, OriginPos As Long, MaxNameLenPos As Long
    Dim EndLine As Byte
    Dim MString As String, TempSeq As String

    DistanceFlag = 0
    NJFlag = 0
    Form1.SSPanel1.Caption = "Loading DNAMan 1.0 File"
    NF = FreeFile
    LastPos = 1
    NextNo = 0
    Finnish = 0
    Open FName$ For Binary Access Read As #NF
    VarString = String$(LOF(NF), " ")
    Get #NF, 1, VarString$
    OriginPos = InStr(LastPos, VarString, "ORIGIN", vbBinaryCompare)
    MaxNameLenPos = InStr(LastPos, VarString, "MAXNAMELEN:", vbBinaryCompare)

    If MaxNameLenPos = 0 Then MaxNameLenPos = 50000
    Pos = InStr(LastPos, VarString, "NUMBER:", vbBinaryCompare)

    If Pos > 0 Then
        NextNo = Int(CDbl(Mid$(VarString, Pos + 7, 3)))

        Call SeqArrays

        'Read the names of the sequences in the alignment
        Pos = InStr(LastPos, VarString, "NAMES: ", vbBinaryCompare)

        For x = 0 To NextNo - 1
            PosN1 = InStr(Pos, VarString, " ", vbBinaryCompare)
            PosN2 = InStr(PosN1 + 1, VarString, " ", vbBinaryCompare)

            If PosN2 > OriginPos Or PosN2 > MaxNameLenPos Then
                PosN2 = InStr(PosN1 + 1, VarString, Chr$(10), vbBinaryCompare) - 1
            End If

            If x < NextNo - 1 Then
                OriginalName(x) = Mid$(VarString, PosN1 + 1, (PosN2 - PosN1) - 1)
            Else
                OriginalName(x) = Mid$(VarString, PosN1 + 1, (PosN2 - PosN1))
            End If

            EndLine = Asc(Right$(OriginalName(x), 1))
            Pos = PosN2 - 1

            If EndLine <= 33 Then
                OriginalName(x) = Left$(OriginalName(x), Len(OriginalName(x)))
                Pos = Pos + 7
            End If

            Form1.ProgressBar1.Value = 1 + (x / (NextNo + 2) * 100) * 0.08
            Call UpdateF2Prog
        Next 'X

        For x = 0 To NextNo - 1

            Do

                If Asc(Right$(OriginalName(x), 1)) < 33 Then
                    OriginalName(x) = Mid$(OriginalName(x), 1, Len(OriginalName(x)) - 1)
                Else
                    Exit Do
                End If

            Loop

        Next 'X

        Form1.ProgressBar1.Value = 1
        Call UpdateF2Prog
        'Find distance from start of line to start of sequences.
        LastPos = InStr(OriginPos + 6, VarString, OriginalName(0), vbBinaryCompare)
        CurrentShortest = 50
        Pos = InStr(LastPos, VarString, " A", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " a", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " C", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " c", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " G", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " g", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " T", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " t", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        Pos = InStr(LastPos, VarString, " .", vbBinaryCompare)

        If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
        CurrentShortest = CurrentShortest + 1
        Pos = InStr(LastPos + CurrentShortest + 6, VarString, "  ", vbBinaryCompare)
        LenSeg = Pos - (LastPos + CurrentShortest)

        For x = 0 To NextNo - 1
            LastPos = OriginPos

            Do
                MString = OriginalName(x) + " "
                Pos = InStr(LastPos, VarString, MString, vbBinaryCompare)

                If Pos > 0 Then
                    StrainSeq(x) = StrainSeq(x) + Mid$(VarString, Pos + CurrentShortest, LenSeg)
                    LastPos = Pos + 1
                Else
                    StrainSeq(x) = UCase$(StrainSeq(x))
                    Exit Do
                End If

            Loop

        Next 'X

        For x = 0 To NextNo

            Do
                Test$ = Right$(StrainSeq(x), 20)

                If Right$(StrainSeq(x), 1) = Chr$(32) Then
                    StrainSeq(x) = Left$(StrainSeq(x), Len(StrainSeq(x)) - 1)
                Else
                    Exit Do
                End If

            Loop

        Next 'X

        NextNo = NextNo - 1
    End If

    For x = 1 To NextNo
        TempSeq = StrainSeq(0)
        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(x), "A", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = Left$(TempSeq, Pos - 1) + "A" + Right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "A" + Right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = Left$(TempSeq, Pos - 1) + "A"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(x), "C", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = Left$(TempSeq, Pos - 1) + "C" + Right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "C" + Right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = Left$(TempSeq, Pos - 1) + "C"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(x), "G", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = Left$(TempSeq, Pos - 1) + "G" + Right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "G" + Right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = Left$(TempSeq, Pos - 1) + "G"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(x), "T", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = Left$(TempSeq, Pos - 1) + "T" + Right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "T" + Right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = Left$(TempSeq, Pos - 1) + "T"
            End If

        Loop

        LPos = 1

        Do
            Pos = InStr(LPos, StrainSeq(x), ".", vbBinaryCompare)
            LPos = Pos + 1

            If Pos = 0 Then Exit Do

            If Pos < Len(TempSeq) And Pos > 1 Then
                TempSeq = Left$(TempSeq, Pos - 1) + "." + Right$(TempSeq, Len(TempSeq) - Pos)
            ElseIf Pos = 1 Then
                TempSeq = "." + Right$(TempSeq, Len(TempSeq) - Pos)
            Else
                TempSeq = Left$(TempSeq, Pos - 1) + "."
            End If

        Loop

        StrainSeq(x) = TempSeq
        Form1.ProgressBar1.Value = 1 + ((x / NextNo) * 100) * 0.3
        Call UpdateF2Prog
    Next 'X

    'Form1.ProgressBar1.Value = 0
    Close #NF
End Sub


Public Sub LoadALI()

    Dim x As Long, NF As Integer
    Dim PosN1 As Long, PosN2 As Long, Start As Long, Finnish As Long, Pos As Long, LastPos As Long

    DistanceFlag = 0
    NJFlag = 0
    Form1.SSPanel1.Caption = "Loading ALI File"
    NF = FreeFile
    Open FName$ For Binary Access Read As #NF
    VarString = String$(LOF(NF), " ")
    Get #NF, 1, VarString$
    Close #NF
    Form1.Picture3.AutoRedraw = True
    LastPos = 1
    NextNo = 0
    ReDim StrainSeq(200)
    ReDim OriginalName(200)
    Finnish = 0

    Do
        Pos = InStr(LastPos, VarString, "************", vbBinaryCompare)

        If Pos > 0 Then
            PosN1 = InStr(LastPos, VarString, "nnn ", vbBinaryCompare)
            PosN2 = InStr(LastPos, VarString, " nnn", vbBinaryCompare)
            OriginalName(NextNo) = Mid$(VarString, PosN1 + 4, PosN2 - PosN1 - 4)
            PosV1 = InStr(LastPos, VarString, "vvv ", vbBinaryCompare)
            Start = Pos
            LastPos = Pos + 6
            Pos = InStr(LastPos, VarString, "************", vbBinaryCompare)

            If Pos > 0 Then
                Finnish = Pos + 12
                StrainSeq(NextNo) = Mid$(VarString, Start, Finnish - Start)
                Finnish = Finnish + 2
                NextNo = NextNo + 1

                Call SeqArrays

                LastPos = Pos + 6
            End If

        Else
            NextNo = NextNo - 1
            Exit Do
        End If

    Loop

    For x = 0 To NextNo
        StrainSeq(x) = Mid$(StrainSeq(x), 13, Len(StrainSeq(x)) - 24)
    Next

    For x = 0 To NextNo

        Do

            If Right$(StrainSeq(x), 1) = Chr$(32) Then
                StrainSeq(x) = Left$(StrainSeq(x), Len(StrainSeq(x)) - 1)
            Else
                Exit Do
            End If

        Loop

    Next 'X

End Sub



Public Sub NJEMF(NHFlag As Integer)
    'Declare variables.
    'Set variables
    Dim LargestXPos As Double
    scaleaddjust = 3
    Form1.Picture16.Refresh
    Dim Xpos() As Double
    Dim YPos() As Double
    Dim SNodepath() As Integer, Pen2 As Long, oldpen As Long, PEN As Long
    Dim LPn As LOGPEN
    Dim PA As POINTAPI
    ReDim Xpos(NextNo)
    ReDim YPos(NextNo)
    PA.x = 0.75
    PA.Y = 0.75
    Dim OldFont As Long

    'NodeAdjust = HorAddjust * (0.65 / NodeLength(Nextno - 1))

    Dim rct As RECT
    TNum = F2TreeIndex
    TType = CurTree(F2TreeIndex)
    tTYF = 0.8
    
    
    Dim TXMod As Single
    'TW = Form2.Picture2(0).ScaleWidth
    TXMod = 412 / Form2.Picture2(0).ScaleWidth
    
    OS = TreeDraw(TNum, TType, 1, 3, TDLen(TNum, TType, 1)) * tTYF + 50
    
    
    If PRat = 0 Then PRat = 1
        
    'find maximum x and y coordiantes so that the drawing area can be defined in rect
    Dim MaxXCO As Long, MaxYCO As Long
    MaxXCO = 0: MaxYCO = 0
    
    For x = 0 To TDLen(TNum, TType, 1)
    'For X = 0 To TBLen(TNum, TType)
        
        If TreeDraw(TNum, TType, 1, 0, x) / PRat > MaxXCO Then MaxXCO = TreeDraw(TNum, TType, 1, 0, x) / PRat
        If (TreeDraw(TNum, TType, 1, 1, x)) > MaxYCO Then
            MaxYCO = (TreeDraw(TNum, TType, 1, 1, x))
            'TreeBlocks(TNum, TType, 1, X)
            x = x
        End If
         
    Next x
    OFS = Form1.Picture16.FontSize
    Form1.Picture16.FontSize = 10
    maxname = 0
    For x = 0 To PermNextno
        If Form1.Picture16.TextWidth(OriginalName(x)) > maxname Then maxname = Form1.Picture16.TextWidth(OriginalName(x))
    Next x
    Form1.Picture16.FontSize = OFS
    
    
    'MaxYCO = MaxYCO + Form1.Picture16.TextHeight("W")
    
    Dim SXF As Single, SYF As Single
    SXF = Screen.Width '28800
    SYF = Screen.Height '16200
    SXF = SXF / 28800
    SYF = SYF / 16200
    
    For x = 0 To UBound(TreeBlocks, 4)
        If TreeDraw(TNum, TType, 0, 0, x) / PRat * TXMod > MaxXCO Then
            MaxXCO = TreeDraw(TNum, TType, 0, 0, x) / PRat * TXMod
        End If
        If (IStart + TreeDraw(TNum, TType, 0, 1, x) + 1) > MaxYCO Then MaxYCO = TreeDraw(TNum, TType, 0, 1, x) + 1
    Next x
    
'    For X = 0 To TBLen(TNum, TType)
'        If MaxXCO < (TreeBlocks(TNum, TType, 2, X) / PRat * SXF * TXMod) Then
'            MaxXCO = TreeBlocks(TNum, TType, 2, X) / PRat * SXF * TXMod
'        End If
'    Next X
    Dim tLenName As Single
    For x = TDLen(TNum, TType, 0) To 0 Step -1
        If TreeDraw(TNum, TType, 0, 2, x) > -1 Then
            If TreeDraw(TNum, TType, 0, 2, x) <= UBound(OriginalName, 1) Or (TNum = 3 And TType = 2) Or (TNum = 3 And TType = 1) Then
                If TNum <> 0 Then
                    If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then  'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                        tLenName = Len(BigTreeName(TreeDraw(TNum, TType, 0, 2, x)))
                    ElseIf TNum = 3 And (TType = 1 Or TType = 0) Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                        tLenName = Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                    Else
                        
                        If TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x))) <= UBound(OriginalName, 1) Then
                            tLenName = Len(OriginalName(TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x)))))
                        End If
                        
                    End If
                
                Else
                    tLenName = Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                End If
            End If
        Else
            tLenName = 0
        End If
        tLenName = tLenName * 5 '* (SXF * TXMod)
        'tLenName = 0'170/240
        If MaxXCO < (TreeDraw(TNum, TType, 0, 0, x) + 1) / PRat * TXMod + tLenName Then
            MaxXCO = (TreeDraw(TNum, TType, 0, 0, x) + 1) / PRat * TXMod + tLenName
        End If
    Next x
    'MaxXCO = 685
    '558'685
    PointX = GetDeviceCaps(Form1.Picture16.hdc, 88) '88 = logpixelsx'96 at 1920 x 1080, 1680 x 1050
    PointY = GetDeviceCaps(Form1.Picture16.hdc, 90) '90 = logpixelsy'96 at 1920 x 1080, 1680 x 1050
    
    PointX = ((MaxXCO + Form2.Picture3(0).ScaleWidth + 10) * PointX / 72) * Screen.TwipsPerPixelX '743x204 - 15x15
    PointY = (MaxYCO + (20 * 13) * PointY / 72) * Screen.TwipsPerPixelY
    
    PointX = PointX * 1.2 'give a little extra space
    '17160
    
'    If TType = 0 And FastNJFlag = 0 And TNum <> 3 Then
'        LargestXPos = 650 * SXF
'    Else
'        LargestXPos = 580 * SXF
'    End If
    
    LargestXPos = (MaxXCO * SXF)
    
    'PointY = PointY * 2 'give a little extra space
    'PointX = PointX * SXF
    'PointY = PointY * SYF
    
    rct.Bottom = PointY 'MaxYCO * 36 + 1000 '686'there are 20 twips per point 'Screen.TwipsPerPixelY 'OS * 28 '((Nextno + 3) * 250)
    rct.Left = 0
    rct.Top = 0
    rct.Right = PointX '31000 'MaxXCO * 36 + 5000 '524'13000
    
    'X = Form1.Picture16.ScaleWidth
    'osm = Form1.Picture16.ScaleMode
    'Form1.Picture16.ScaleMode = vbMillimeters
    'Y = Form1.Picture16.ScaleWidth
    'Form1.Picture16.ScaleMode = osm
    'scaleadj = ((Y / X) * 100)
    
   
    
    HFactor = 200
    Form1.Picture1.AutoRedraw = False
    MhDC = CreateEnhMetaFile(Form1.Picture16.hdc, EMFFName, rct, "")
    Form1.Picture1.AutoRedraw = True
    'nHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
    
    Dim fHeight As Double, fWidth As Double, OFSx As Single, OFNx As String
'    fHeight = (8 * GetDeviceCaps(MhDC, 88)) / 72 / 1.1 '9.696'this doesnt seem to be effected by screen resolution
'    fWidth = (8 * GetDeviceCaps(MhDC, 90)) / 72 / 1.1 '9.696
'    OFSx = Form1.Picture16.FontSize
'    OFNx = Form1.Picture16.FontName
'    Form1.Picture16.FontSize = 6
'    Form1.Picture16.FontName = "Arial"
    fHeight = 9.49 'Form1.Picture16.TextHeight("A") * 0.7
    fWidth = 5 'Form1.Picture16.TextWidth("ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890") / 36 * 0.6
    
    '8.4848
    
   ' LoFnt = CreateFont(fHeight, 0, 0, 0, 400, 0, 0, 0, 0, 7, 0, PROOF_QUALITY, 0, "Arial") 'value 5 = weight, 9=charset, 10=precision OUT_TT_ONLY_PRECIS=7)
    LoFnt = CreateFont(fHeight * SYF, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 48, "Arial") 'value 5 = weight, 9=charset, 10=precision OUT_TT_ONLY_PRECIS=7)

    OldFont = SelectObject(MhDC, LoFnt)
    
    PEN = CreatePenIndirect(LPn)
    oldpen = SelectObject(MhDC, PEN)
    
    LPn.lopnColor = 0
    LPn.lopnWidth = PA
    LPn.lopnStyle = 0
    
    PEN = CreatePenIndirect(LPn)
    Pen2 = SelectObject(MhDC, PEN)
    'PEN = CreatePenIndirect(LPn)
    'OldPen = SelectObject(MhDC, PEN)
   '
   ' LPn.lopnColor = GPrintCol(Y)
   ' LPn.lopnStyle = 0
   '
   ' PEN = CreatePenIndirect(LPn)
   ' Pen2 = SelectObject(MhDC, PEN)
    'GetTextExtentPoint32
    
    Dim PntAPI As POINTAPI
    Dim XOffset As Long
    Dim YOffset As Long

    XOffset = 80
    YOffset = 20

    Dim XAdd As Long
    Dim YAdd As Integer
    
    
    Dim Brush2 As Long, Brush As Long, OldBrush As Long, LBrush As LOGBRUSH
    
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    
    
    If x = x Then
        
        
        
        
        TNum = F2TreeIndex
        TType = CurTree(F2TreeIndex)
        
        If TDLen(TNum, TType, 1) = 0 Then
            TNum = 0
            TNF = 0
        
        Else
            TNF = 1
        End If
        
        Pict = MhDC
        
        
        
        
        ' For X = 0 To TBLen(TNum, TType)
       '
       '
       '         PB.DrawMode = 9
       '         If PRat > 1 Then
       '             xPRat = PRat / (PRat ^ 0.1)
       '         Else
       '             xPRat = PRat
       '         End If
       '         PB.Line (TreeBlocks(TNum, TType, 0, X) / PRat, IStart + TreeBlocks(TNum, TType, 1, X) * tTYF)-(((TreeBlocks(TNum, TType, 0, X) + (TreeBlocks(TNum, TType, 2, X) - TreeBlocks(TNum, TType, 0, X) + 5) * tTYF) / xPRat) - XXMod, IStart + TreeBlocks(TNum, TType, 3, X) * tTYF), TreeBlocks(TNum, TType, 4, X), BF
       '
       ' Next X
       If TBLen(TNum, TType) > 0 And x = 1234567890 Then '0.8
           For x = 0 To TBLen(TNum, TType)
       
            'draw coloured taxon label blocks
                If x <= UBound(TreeBlocks, 4) Then
                        
                        'PB.DrawMode = 9
                        If PRat > 1 Then
                            xPRat = PRat / (PRat ^ 0.1)
                        Else
                            xPRat = PRat
                        End If
                        'PB.Line (TreeBlocks(TNum, TType, 0, X) / PRat, IStart + TreeBlocks(TNum, TType, 1, X) * tTYF)-(((TreeBlocks(TNum, TType, 0, X) + (TreeBlocks(TNum, TType, 2, X) - TreeBlocks(TNum, TType, 0, X) + 5) * tTYF) / xPRat) - XXMod, IStart + TreeBlocks(TNum, TType, 3, X) * tTYF), TreeBlocks(TNum, TType, 4, X), BF
                        
                        LPn.lopnColor = TreeBlocks(TNum, TType, 4, x)
                        PEN = CreatePenIndirect(LPn)
                        Pen2 = SelectObject(Pict, PEN)
                        
                        LBrush.lbColor = TreeBlocks(TNum, TType, 4, x)
                        LBrush.lbStyle = 0
                        Brush = CreateBrushIndirect(LBrush)
                        Brush2 = SelectObject(Pict, Brush)
                        'these are the coloured sequence name blocks
                        'Dummy = Rectangle(Pict, TreeBlocks(TNum, TType, 0, X) / PRat * SXF * TXMod, IStart + TreeBlocks(TNum, TType, 1, X) * tTYF * SYF, ((TreeBlocks(TNum, TType, 0, X) / xPRat * SXF * TXMod + (TreeBlocks(TNum, TType, 2, X) * 0.9 / xPRat * SXF * TXMod - TreeBlocks(TNum, TType, 0, X) / xPRat * SXF * TXMod))) - XXMod, IStart + TreeBlocks(TNum, TType, 3, X) * tTYF * SYF)
                        Dim LenBlock As Long
                        LenBlock = (TreeBlocks(TNum, TType, 0, x) + (TreeBlocks(TNum, TType, 2, x) - TreeBlocks(TNum, TType, 0, x)) / 1.1) * (TXMod)
                        'LenBlock = LenBlock * 1.6 * SXF * TXMod
                        If LenBlock > LargestXPos Then
                            LenBlock = LargestXPos
                        End If
                        
                        Dummy = Rectangle(Pict, TreeBlocks(TNum, TType, 0, x) / PRat * SXF * TXMod, IStart + TreeBlocks(TNum, TType, 1, x) * tTYF * SYF, LenBlock, IStart + TreeBlocks(TNum, TType, 3, x) * tTYF * SYF)
                 
                        DeleteObject (Pen2)
                        DeleteObject (Brush2)
                        
                        
                        LPn.lopnColor = 0
                        PEN = CreatePenIndirect(LPn)
                        Pen2 = SelectObject(Pict, PEN)
                        
                      '  LBrush.lbColor = 0
                      '  LBrush.lbStyle = 1
                      '  Brush = CreateBrushIndirect(LBrush)
                       ' Brush2 = SelectObject(Pict, Brush)
                        
                        
                      '  Dim LenTXT As Long
                      '  LenTXT = (TreeBlocks(TNum, TType, 2, X) - TreeBlocks(TNum, TType, 0, X))
                      '  LenTXT = LenTXT / 10
                      '
                      '  LenTXT = LenTXT + 1
                      '  Dummy = SetBkMode(Pict, 2)
                      '  Dummy = SetTextColor(Pict, TreeBlocks(TNum, TType, 4, X))
                      '  Dummy = SetTextColor(Pict, TreeBlocks(TNum, TType, 4, X))
                      '  Dummy = SetBkColor(Pict, TreeBlocks(TNum, TType, 4, X))
                      '  Dummy = TextOut(Pict, TreeBlocks(TNum, TType, 0, X) / PRat, IStart + TreeBlocks(TNum, TType, 1, X) * tTYF + 1, String(LenTXT, Chr(143)), LenTXT)
                    'El
                    End If
                
            Next x
        End If
        Dummy = SetBkMode(Pict, 1)
        Dim TargetSeq As Long, TBBack As Long, ACol As Long
        ACol = RGB(128, 0, 0) 'this is the colour of the "accepted" square
        
        
        
        For x = TDLen(TNum, TType, 0) To 0 Step -1
        
            
            If TreeDraw(TNum, TType, 0, 2, x) > -1 And (TreeDraw(TNum, TType, 0, 2, x) <= UBound(OriginalName) Or (TNum = 3 And TType = 2) Or (TNum = 3 And TType = 1)) Then
                
                         
                
                If TNF = 0 Then
                    If SelGrpFlag = 0 Then
                        If TreeDraw(TNum, TType, 0, 2, x) <= UBound(MaskSeq, 1) Then
                            If MaskSeq(TreeDraw(TNum, TType, 0, 2, x)) = 0 Then
                                Dummy = SetTextColor(Pict, 0)
                            ElseIf MaskSeq(TreeDraw(TNum, TType, 0, 2, x)) = 1 Then
                                 Dummy = SetTextColor(Pict, QBColor(8))
                                
                            Else
                                Dummy = SetTextColor(Pict, ThreeQuaterColour)
                                
                            End If
                        End If
                    Else
                        If TreeDraw(TNum, TType, 0, 2, x) <= UBound(GrpMaskSeq, 1) Then
                            If GrpMaskSeq(TreeDraw(TNum, TType, 0, 2, x)) = 0 Then
                                Dummy = SetTextColor(Pict, 0)
                                
                            Else
                                Dummy = SetTextColor(Pict, RGB(0, 0, 255))
                               
                            End If
                        End If
                    End If
                Else
                    If LongWindedFlag = 1 Then
                        If TNum <> 0 Then
                              'Exit Sub
                             'XX = PermNextNo
                            If TNum = 3 And (TType = 1 Or TType = 0) Then
                                Dummy = SetTextColor(Pict, MultColour((TreeDraw(TNum, TType, 0, 2, x))))
                                
                            ElseIf TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
                                Dummy = SetTextColor(Pict, MultColour(BigTreeTrace(TreeDraw(TNum, TType, 0, 2, x))))
                                
                            Else
                                If TreeDraw(TNum, TType, 0, 2, x) <= UBound(TreeTraceSeqs, 2) Then
                                    If TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x)) <= UBound(TreeTrace, 1) Then
                                        If TreeTrace(TreeTraceSeqs(1, TreeTrace(TreeDraw(TNum, TType, 0, 2, x)))) <= UBound(MultColour, 1) Then
                                            
                                            Dummy = SetTextColor(Pict, MultColour(TreeTrace(TreeTraceSeqs(1, TreeTrace(TreeDraw(TNum, TType, 0, 2, x))))))
                                        End If
                                    End If
                                End If
                            End If
                        Else
                            If DebuggingFlag < 2 Then On Error Resume Next
                            UBX = -1
                            UBX = UBound(TreeTrace, 1)
                            
                            On Error GoTo 0
                            If UBX <> -1 Then
                                If TreeDraw(TNum, TType, 0, 2, x) <= UBound(TreeTrace, 1) Then
                                    If TreeTrace(TreeDraw(TNum, TType, 0, 2, x)) <= UBound(MultColour, 1) Then
                                         Dummy = SetTextColor(Pict, MultColour(TreeTrace((TreeDraw(TNum, TType, 0, 2, x)))))
                                        
                                    End If
                                End If
                            End If
                        End If
                    Else
                        Dummy = SetTextColor(Pict, MultColour(TreeDraw(TNum, TType, 0, 2, x)))
                        
                    End If
                End If
                If TreeDraw(TNum, TType, 0, 2, x) <= UBound(OriginalName, 1) Or (TNum = 3 And TType = 2) Or (TNum = 3 And TType = 1) Then
                    TBBack = -1
                    If TBLen(TNum, TType) > 0 Then '0.8
                       For Y = 0 To TBLen(TNum, TType)
                        'Get  taxon label blocks colour
                            If Y <= UBound(TreeBlocks, 4) Then
                               If TreeBlocks(TNum, TType, 5, Y) = TreeDraw(TNum, TType, 0, 2, x) Then
                                   If TreeBlocks(TNum, TType, 4, Y) <> ACol Then
                                        TBBack = TreeBlocks(TNum, TType, 4, Y)
                                        Exit For
                                    End If
                               End If
                               
                            End If
                       Next Y
                       If Y > TBLen(TNum, TType) Then
                            TBBack = -1
                       End If
                    End If
'                    SetBkColor Pict, RGB(255, 0, 0)
'                    SetBkMode Pict, 1
                    
                    If TBBack > -1 Then
                        If TBBack <> ACol Then
'                            LBrush.lbColor = TBBack
'                            LBrush.lbStyle = 0
'                            Brush = CreateBrushIndirect(LBrush)
'                            Brush2 = SelectObject(Pict, Brush)
                            SetBkMode Pict, 2 'opaque
                            SetBkColor Pict, TBBack
                        Else
                            SetBkMode Pict, 0
                        End If
                    Else
                        SetBkMode Pict, 0 'transparent
                    End If
                    If TNum <> 0 Then
                        If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then  'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                            
                            
                            TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF * SYF + 1) - 1, BigTreeName(TreeDraw(TNum, TType, 0, 2, x)), Len(BigTreeName(TreeDraw(TNum, TType, 0, 2, x)))
                        ElseIf TNum = 3 And (TType = 1 Or TType = 0) Then 'this is the special expanded tree - it uses names from bigtreenames rather than originalname
                            TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF * SYF + 1) - 1, OriginalName(TreeDraw(TNum, TType, 0, 2, x)), Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                        
                        Else
                            
                            If TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x))) <= UBound(OriginalName, 1) Then
                                TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF * SYF + 1) - 1, OriginalName(TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x)))), Len(OriginalName(TreeTrace(TreeTraceSeqs(1, TreeDraw(TNum, TType, 0, 2, x)))))
                            End If
                            
                        End If
                    
                    Else
                        
                        TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF * SYF + 1) - 1, OriginalName(TreeDraw(TNum, TType, 0, 2, x)), Len(OriginalName(TreeDraw(TNum, TType, 0, 2, x)))
                    End If
                    x = x
                End If
            ElseIf TreeDraw(TNum, TType, 0, 3, x) > 0 Then
              
                Dummy = SetTextColor(Pict, RGB(0, 100, 0))
                'fHeight = (7 * GetDeviceCaps(Pict, 88)) / 72 / 3
                ' LoFnt = CreateFont(fHeight, 0, 0, 0, 400, 0, 0, 0, 0, 7, 0, PROOF_QUALITY, 0, "Arial") 'value 5 = weight, 9=charset, 10=precision OUT_TT_ONLY_PRECIS=7)
                 LoFnt = CreateFont(fHeight / 1.2, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, "Arial") 'value 5 = weight, 9=charset, 10=precision OUT_TT_ONLY_PRECIS=7)
                Dummy = SelectObject(Pict, LoFnt)
                ScaleX = Trim(Str(TreeDraw(TNum, TType, 0, 3, x)))
                TextOut Pict, (TreeDraw(TNum, TType, 0, 0, x) + 1) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF * SYF - 1), ScaleX, Len(ScaleX)
            
                ' fHeight = (7 * GetDeviceCaps(Pict, 88)) / 72 / 1.1
                ' LoFnt = CreateFont(fHeight, 0, 0, 0, 400, 0, 0, 0, 0, 7, 0, PROOF_QUALITY, 0, "Arial") 'value 5 = weight, 9=charset, 10=precision OUT_TT_ONLY_PRECIS=7)
                 LoFnt = CreateFont(fHeight, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")  'value 5 = weight, 9=charset, 10=precision OUT_TT_ONLY_PRECIS=7)
                Dummy = SelectObject(Pict, LoFnt)
            Else
               
                Dummy = SetTextColor(Pict, 0)
                ScaleL = -TreeDraw(TNum, TType, 0, 3, x) / 10000
                ScaleX = Trim(Str(ScaleL))
                If Left(ScaleX, 1) = "." Then ScaleX = "0" + ScaleX
                'prints the scale
                TextOut Pict, TreeDraw(TNum, TType, 0, 0, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 0, 1, x) * tTYF * SYF + 1), ScaleX, Len(ScaleX)
            End If
            
        Next x
        
        
        
        For x = 0 To TDLen(TNum, TType, 1)
            
            LPn.lopnColor = TreeDraw(TNum, TType, 1, 4, x)
            PEN = CreatePenIndirect(LPn)
            Pen2 = SelectObject(Pict, PEN)
            'LPn.lopnColor = TreeDraw(TNum, TType, 1, 4, X)
            'PEN = CreatePenIndirect(LPn)
            
            
            
            
            
            Dummy = MoveToEx(Pict, TreeDraw(TNum, TType, 1, 0, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 1, 1, x) * tTYF * SYF), PntAPI) '280,280,279
            Dummy = LineTo(Pict, TreeDraw(TNum, TType, 1, 2, x) / PRat * SXF * TXMod, (IStart + TreeDraw(TNum, TType, 1, 3, x) * tTYF * SYF))
            
            DeleteObject (Pen2)
             
        Next x
        
        
        
        
        
        
        OS = TreeDraw(TNum, TType, 1, 3, TDLen(TNum, TType, 1)) * tTYF * SYF + 50
        For x = 0 To TBLLen
            If TreeBlocksL(TNum, TType, 3, x) > 0 Then
                
                'PB.Line (treeblocksl(Tnum,ttype,0, X), OS + treeblocksl(Tnum,ttype,1, X))-(treeblocksl(Tnum,ttype,2, X), OS + treeblocksl(Tnum,ttype,3, X)), -treeblocksl(Tnum,ttype,4, X), BF
                
                'Dummy = MoveToEx(Pict, treeblocksl(Tnum,ttype,0, X), OS + treeblocksl(Tnum,ttype,1, X), PntAPI) '280,280,279
                'Dummy = LineTo(Pict, treeblocksl(Tnum,ttype,2, X), OS + treeblocksl(Tnum,ttype,3, X))
                'Dummy = SetTextColor(Pict, -TreeBlocksL(TNum, TType, 4, X))
                'Dummy = SetBkColor(Pict, -TreeBlocksL(TNum, TType, 4, X))
                
                    LPn.lopnColor = -TreeBlocksL(TNum, TType, 4, x)
                    PEN = CreatePenIndirect(LPn)
                    Pen2 = SelectObject(Pict, PEN)
                    
                    LBrush.lbColor = -TreeBlocksL(TNum, TType, 4, x)
                    LBrush.lbStyle = 0
                    Brush = CreateBrushIndirect(LBrush)
                    Brush2 = SelectObject(Pict, Brush)
                    
                
               ' dummy = SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
                
            Else
                If TreeBlocksL(TNum, TType, 2, x) > 0 Or TreeBlocksL(TNum, TType, 1, x) > 0 Or TreeBlocksL(TNum, TType, 0, x) > 0 Then
                    
                    
                    'this is the legend block rectangle
                    
                    Dummy = Rectangle(Pict, TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x) * tTYF + 1, TreeBlocksL(TNum, TType, 0, x) + 10, OS + TreeBlocksL(TNum, TType, 1, x) * tTYF + 9)
                    
                    DeleteObject (Pen2)
                    DeleteObject (Brush2)
                    
                    
                    LPn.lopnColor = 0
                    PEN = CreatePenIndirect(LPn)
                    Pen2 = SelectObject(Pict, PEN)
                    
                    
                    'XX = TBS(TreeBlocksL(TNum, TType, 2, X))
                   ' Dummy = SetBkMode(Pict, 2)
                   ' Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X) * tTYF, "Oo", 2)
                    
                    'this is the legend block text
                    Dummy = SetBkMode(Pict, 1)
                    Dummy = SetTextColor(Pict, 0)
                    Dummy = SetBkColor(Pict, RGB(255, 255, 255))
                    Dummy = TextOut(Pict, 25 + TreeBlocksL(TNum, TType, 0, x), OS + TreeBlocksL(TNum, TType, 1, x) * tTYF, TBS(TreeBlocksL(TNum, TType, 2, x)), Len(TBS(TreeBlocksL(TNum, TType, 2, x))))
                'Else
                   ' If RelX > 0 Or RelY > 0 Then
                   '     Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X) * tTYF, TBS(TreeBlocksL(TNum, TType, 2, X)), Len(TBS(TreeBlocksL(TNum, TType, 2, X))))
                   ' End If
                End If
            End If
        Next x
        
       
    Else
'        ReDim SNodepath(PermNextno + 1, PermNextno + 1)
'        Call MakeSNodePath(SNodepath(), NHFlag)
'        For X = 0 To Nextno
'
'            If SSeqXPos(NHFlag, X) > LargestXPos Then LargestXPos = SSeqXPos(NHFlag, X)
'        Next 'X
'
'        XAdd = 400 / LargestXPos
'
'        YAdd = 30
'
'
'        For X = 0 To Nextno
'
'            For Y = 0 To Nextno
'
'                If SNodepath(X, Y + 1) > -1 Then
'                    MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodepath(X, Y)) * YAdd, PntAPI
'                    LineTo MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodepath(X, Y + 1)) * YAdd
'                    MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodepath(X, Y + 1)) * YAdd, PntAPI
'                    LineTo MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y + 1))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodepath(X, Y + 1)) * YAdd
'                Else
'                    MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y))) * XAdd, YOffset + SNodeYPos(NHFlag, SNodepath(X, Y)) * YAdd, PntAPI
'                    LineTo MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y))) * XAdd, YOffset + SSeqYPos(NHFlag, X) * YAdd
'                    MoveToEx MhDC, XOffset + (SNodeXPos(NHFlag, SNodepath(X, Y))) * XAdd, YOffset + SSeqYPos(NHFlag, X) * YAdd, PntAPI
'                    LineTo MhDC, XOffset + (SSeqXPos(NHFlag, X)) * XAdd, YOffset + SSeqYPos(NHFlag, X) * YAdd
'
'                    If X = Seq3 And Seq3 <> Seq1 Then
'                        SetTextColor MhDC, RGB(255, 0, 0)
'                    ElseIf X = Seq1 And Seq1 <> Seq2 Then
'
'                        If OutsideFlagX = 1 Then
'                            SetTextColor MhDC, RGB(0, 128, 0)
'                        Else
'                            SetTextColor MhDC, RGB(0, 255, 0)
'                        End If
'
'                    ElseIf X = Seq2 And Seq1 <> Seq2 Then
'
'                        If OutsideFlagX = 2 Then
'                            SetTextColor MhDC, RGB(0, 0, 128)
'                        Else
'                            SetTextColor MhDC, RGB(0, 0, 255)
'                        End If
'
'                    Else
'                        SetTextColor MhDC, RGB(0, 0, 0)
'                    End If
'
'                    TextOut MhDC, XOffset + 10 + SSeqXPos(NHFlag, X) * XAdd, YOffset - 10 + SSeqYPos(NHFlag, X) * YAdd, OriginalName(X), Len(OriginalName(X))
'                    Exit For
'                End If
'
'            Next 'Y
'
'        Next 'X
'
'        SetTextColor MhDC, RGB(0, 64, 0)
'
'        For X = 0 To Nextno - 1
'
'            If SDLen(NHFlag, X) > 0 Then
'                TextOut MhDC, XOffset + 5 + SNodeXPos(NHFlag, X) * XAdd, YOffset - 10 + SNodeYPos(NHFlag, X) * YAdd, Trim$(CStr(SDLen(NHFlag, X))), Len(Trim$(CStr(SDLen(NHFlag, X))))
'            End If
'
'        Next 'X
'
'        MoveToEx MhDC, XOffset, YOffset + (Nextno + 2) * YAdd, PntAPI
'        LineTo MhDC, XOffset + (0.1) * XAdd, YOffset + (Nextno + 2) * YAdd
'        SetTextColor MhDC, RGB(0, 0, 0)
'        TextOut MhDC, XOffset + (0.1 / 2.1) * XAdd, YOffset + (Nextno + 2.5) * YAdd, "0.1", 3
    
    End If
    
    
    'do the sequence maps
    If NoP3Flag = 0 Then
'        If TType = 0 And FastNJFlag = 0 And TNum <> 3 Then
'            LargestXPos = 650 * SXF
'        Else
'            LargestXPos = 580 * SXF
'        End If
        Dim XSize As Single
        XSize = 200
        For x = 1 To MapBlockNum(TType, TNum)
            'If TreeBlocksL(TNum, TType, 3, X) > 0 Then
            If x <= UBound(MapBlocks, 4) Then
                'PB.Line (treeblocksl(Tnum,ttype,0, X), OS + treeblocksl(Tnum,ttype,1, X))-(treeblocksl(Tnum,ttype,2, X), OS + treeblocksl(Tnum,ttype,3, X)), -treeblocksl(Tnum,ttype,4, X), BF
                
                'Dummy = MoveToEx(Pict, treeblocksl(Tnum,ttype,0, X), OS + treeblocksl(Tnum,ttype,1, X), PntAPI) '280,280,279
                'Dummy = LineTo(Pict, treeblocksl(Tnum,ttype,2, X), OS + treeblocksl(Tnum,ttype,3, X))
                'Dummy = SetTextColor(Pict, -TreeBlocksL(TNum, TType, 4, X))
                'Dummy = SetBkColor(Pict, -TreeBlocksL(TNum, TType, 4, X))
                
                    LPn.lopnColor = MapBlocks(TType, TNum, 3, x)
                    PEN = CreatePenIndirect(LPn)
                    Pen2 = SelectObject(Pict, PEN)
                    
                    LBrush.lbColor = MapBlocks(TType, TNum, 3, x)
                    LBrush.lbStyle = 0
                    Brush = CreateBrushIndirect(LBrush)
                    Brush2 = SelectObject(Pict, Brush)
                    
                
               ' dummy = SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
                
            'Else
                'If TreeBlocksL(TNum, TType, 2, X) > 0 Or TreeBlocksL(TNum, TType, 1, X) > 0 Or TreeBlocksL(TNum, TType, 0, X) > 0 Then
                    
                    
                    '650 + 5.7x10-6*xsize=200
                    'these are the sequence rectangles
                    Dummy = Rectangle(Pict, LargestXPos + 10 + MapBlocks(TType, TNum, 0, x) * XSize * SXF, (MapBlocks(TType, TNum, 2, x)) * tTYF * SYF, LargestXPos + 10 + MapBlocks(TType, TNum, 1, x) * XSize * SXF, (MapBlocks(TType, TNum, 2, x) + 9) * tTYF * SYF)
                    
                    DeleteObject (Pen2)
                    DeleteObject (Brush2)
                    
                    
'                    LPn.lopnColor = 0
'                    PEN = CreatePenIndirect(LPn)
'                    Pen2 = SelectObject(Pict, PEN)
'
'
'                    'XX = TBS(TreeBlocksL(TNum, TType, 2, X))
'                   ' Dummy = SetBkMode(Pict, 2)
'                   ' Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X) * tTYF, "Oo", 2)
'
'
'                    Dummy = SetBkMode(Pict, 1)
'                    Dummy = SetTextColor(Pict, 0)
'                    Dummy = SetBkColor(Pict, RGB(255, 255, 255))
'                    Dummy = TextOut(Pict, 25 + TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X) * tTYF, TBS(TreeBlocksL(TNum, TType, 2, X)), Len(TBS(TreeBlocksL(TNum, TType, 2, X))))
                'Else
                   ' If RelX > 0 Or RelY > 0 Then
                   '     Dummy = TextOut(Pict, TreeBlocksL(TNum, TType, 0, X), OS + TreeBlocksL(TNum, TType, 1, X) * tTYF, TBS(TreeBlocksL(TNum, TType, 2, X)), Len(TBS(TreeBlocksL(TNum, TType, 2, X))))
                   ' End If
                'End If
            End If
        Next x
        
        If TNum = 1 Or TNum = 2 Then
            BPos = XoverList(RelX, RelY).Beginning
            Epos = XoverList(RelX, RelY).Ending
            X1 = -1
            X2 = -1
            X3 = -1
            X4 = -1
            
            
            If TNum = 1 Then
                If BPos < Epos Then
                'LargestXPos + 10 +
                    X1 = LargestXPos + (10 + (BPos / Len(StrainSeq(0))) * XSize) * SXF
                    X2 = LargestXPos + (10 + (Epos / Len(StrainSeq(0))) * XSize) * SXF
                '    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize, 0)-(5 + (EPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                Else
                    X1 = LargestXPos + (10 + (BPos / Len(StrainSeq(0))) * XSize) * SXF
                    X2 = LargestXPos + (10 + 1 * XSize) * SXF
                    X3 = LargestXPos + (10 + (1 / Len(StrainSeq(0))) * XSize) * SXF
                    X4 = LargestXPos + (10 + (Epos / Len(StrainSeq(0))) * XSize) * SXF
                '    Form2.Picture3(1).Line (5 + (1 / Len(StrainSeq(0))) * XSize, 0)-(5 + (EPos / Len(StrainSeq(0))) * XSize - 1, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                '    Form2.Picture3(1).Line (5 + (BPos / Len(StrainSeq(0))) * XSize + 1, 0)-(5 + 1 * XSize, Form2.Picture3(1).Height), Form2.Picture3(1).BackColor, BF
                End If
            ElseIf TNum = 2 Then
                If BPos < Epos Then
                    X1 = LargestXPos + (10 + (Epos / Len(StrainSeq(0))) * XSize) * SXF
                    X2 = LargestXPos + (10 + 1 * XSize) * SXF
                    X3 = LargestXPos + (10 + (1 / Len(StrainSeq(0))) * XSize) * SXF
                    X4 = LargestXPos + (10 + (BPos / Len(StrainSeq(0))) * XSize) * SXF
                Else
                     X1 = LargestXPos + (10 + (Epos / Len(StrainSeq(0))) * XSize) * SXF
                     X2 = LargestXPos + (10 + (BPos / Len(StrainSeq(0))) * XSize) * SXF
                End If
            End If
            Call ModNextno
            For Y = 0 To NextNo
                'If TreeBlocksL(TNum, TType, 3, X) > 0 Then
                
                        LPn.lopnColor = RGB(255, 255, 255) 'MapBlocks(TType, TNum, 3, X)
                        PEN = CreatePenIndirect(LPn)
                        Pen2 = SelectObject(Pict, PEN)
                        
                        LBrush.lbColor = RGB(255, 255, 255)
                        LBrush.lbStyle = 0
                        Brush = CreateBrushIndirect(LBrush)
                        Brush2 = SelectObject(Pict, Brush)
                        'these are the missing sequence rectangles
                        If X3 = -1 Then
                            Dummy = Rectangle(Pict, X1, CLng(((Y * 14) + 2) * tTYF * SYF), X2, ((Y * 14) + 12) * tTYF * SYF)
                        Else
                            Dummy = Rectangle(Pict, X1, CLng(((Y * 14) + 2) * tTYF * SYF), X2, ((Y * 14) + 12) * tTYF * SYF)
                            Dummy = Rectangle(Pict, X3, CLng(((Y * 14) + 2) * tTYF * SYF), X4, ((Y * 14) + 12) * tTYF * SYF)
                        End If
                        DeleteObject (Pen2)
                        DeleteObject (Brush2)
                        
                'End If
            Next Y
            Call UnModNextno
        End If
    End If
    
    'Clean up and close
     'Clear up and close  emf
     
    DeleteObject (Pen2)
    DeleteObject (Brush2)
    Brush = SelectObject(Pict, OldBrush)
    DeleteObject (Brush)
    Pen2 = SelectObject(MhDC, oldpen)
    DeleteObject (Pen2)
    LoFnt = SelectObject(MhDC, OldFont)
    DeleteObject LoFnt
    EMFCls = CloseEnhMetaFile(MhDC)
    Dummy = DeleteEnhMetaFile(EMFCls)
    Exit Sub
errorhandler:
End Sub









Public Sub LoadPIR()

    Dim NF As Integer
    Dim TempString As String

    NextNo = -1
    Form1.SSPanel1.Caption = "Loading PIR File"
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
    NF = FreeFile
    Open FName$ For Input Access Read As #NF

    Do While Not EOF(NF)
        Input #NF, TempString
        If Len(TempString) > LOF(NF) * 0.5 Then
            Call ReformatFile(NF, TempString, SaveFlag)
        End If
        If Mid$(TempString, 1, 4) = ">DL;" Then
            NextNo = NextNo + 1

            Call SeqArrays

            Form1.ProgressBar1.Value = 1 + ((Len(StrainSeq(0)) * NextNo) / LOF(NF)) * 30
            Call UpdateF2Prog
            OriginalName(NextNo) = Mid$(TempString, 5, Len(TempString) - 1)
            Line Input #NF, TempString

            If TempString = "" Then Line Input #NF, TempString
        Else
            StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
        End If

        If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
    Loop

    Close #NF
End Sub
Public Sub LoadFASTA()

    Dim LastPut As Long, A As Long, PosLF As Long, PosS As Long, FF As Long, oDirX As String, Temp As String, Y As Long, x As Long, TT As Long, LenS As Long, EE As Long, SS As Long, Xpos As Long, ltPX As Long, tPX As Long, CPXX As Long, FastLoadFlag As Byte, Offset As Long, NF As Integer, TempString As String, PosCR As Long, FN As Long, OldSeqFile As String ', SeqFile As String
    Dim crPos As Long, lfPos As Long, NPos As Long, Pos As Long, LastPos As Long
    Dim FFlag As Byte
    Dim TempMultName() As String, TempMult() As String, CPInSeqnum As Long
    Dim Target As String, incR As Long
    ReDim TempMultName(0), TempMult(0), MultCoords(MultFNum, 0)
    FFlag = 0
    If MultFNum = 0 Then
        Form1.SSPanel1.Caption = "Loading FASTA File"
    End If
    'check to see if file needs to be reformatted
   
    PosCR = InStr(1, SeqFile, Chr(13), vbBinaryCompare)
    Dim SizeF As Long, NF2 As Long
    Dim ReadBlock As Long
    ReadBlock = 20000000
    If PosCR = 0 Then
        NF = FreeFile
        Open FName$ For Binary Access Read As NF
        'XX = LOF(NF)
        SizeF = LOF(NF)
        If SizeF > ReadBlock Then
            If WholeFileFlag = 0 Then
                SeqFile = ""
            End If
            'split the file into chunks and reformat each chunk separately from the others
            TempString = String(ReadBlock, " ")
            NF2 = FreeFile
            Dim TargetS As Long
            TargetS = CLng((SizeF / ReadBlock) + 0.49999999)
            
            For x = 1 To TargetS
                TempString = String(ReadBlock, " ")
                Get #NF, , TempString
                TempString = Trim(TempString)
                Call ReformatFile(NF2, TempString, SaveFlag)
                
                Close #NF2
                On Error Resume Next
                Kill "TFX" + Str(x)
                On Error GoTo 0
                Name "tempfile" As "TFX" + Str(x)
                Form1.ProgressBar1.Value = (x / TargetS) * 100
            Next x
            Close #NF
            
            Open "tempfile" For Binary As NF
            For x = 1 To CLng((SizeF / ReadBlock) + 0.49999999)
                NF2 = FreeFile
                Open "TFX" + Str(x) For Binary As #NF2
                TempString = String(LOF(NF2), " ")
                Get #NF2, , TempString
                Pos = 1
                
                'XX = InStr(1, TempString, Chr(10), vbBinaryCompare)
                'need to remove a line feed and a CR at the end of tempstring
                TempString = Left(TempString, Len(TempString) - 2)
                Close #NF2
                Put #NF, , TempString
                If x = 1 Then
                    crPos = InStr(1, TempString, Chr$(13), vbBinaryCompare)
                    lfPos = InStr(1, TempString, Chr$(10), vbBinaryCompare)
                    
                    If crPos > 0 And lfPos > 0 Then
                        If crPos < lfPos Then
                            Target = Chr$(13)
                        Else
                            Target = Chr$(10)
                        End If
                        incR = 2
                    ElseIf crPos > 0 Then
                        Target = Chr$(13)
                        incR = 1
                    ElseIf lfPos > 0 Then
                        Target = Chr$(10)
                        incR = 1
                    End If
                
                End If
            Next x
            Close #NF
            TempString = ""
            For x = 1 To CLng((SizeF / ReadBlock) + 0.49999999)
                On Error Resume Next
                Kill "TFX" + Str(x)
                On Error GoTo 0
            Next x
            x = x
            FName$ = "tempfile"
            'now merge the files into a file called "tempfile"
        Else
            TempString = String(SizeF, " ")
            Get #NF, 1, TempString
            Call ReformatFile(NF, TempString, SaveFlag)
            FName$ = "tempfile"
            
            
            
            Close #NF
        End If
        
    End If
    oCRF = CurrentlyRunningFlag
    CurrentlyRunningFlag = 1
    CNX = 0
    For FN = 0 To MultFNum
        If MultFNum > 0 Then
            
            Form1.SSPanel1.Caption = "Loading" + Str(FN + 1) + " of" + Str(MultFNum + 1) + " FASTA Files"
            DoEvents
            'WholeFileFlag = 0
            FName$ = MultFN(FN)
            NextNo = -1
            
            If FN > 0 Then
                FFlag = 0
                NF = FreeFile
                'On Error GoTo FileNotFound
                Open FName$ For Binary Access Read As #NF
                'On Error GoTo 0
                RLFlag = 0
                OldSeqFile = SeqFile
                WholeFileFlag = 1
                SeqFile = String$(LOF(NF), " ")
                Get #NF, 1, SeqFile
                Close #NF
            End If
        End If
        Dim tTempString As String
        Dim AlreadyInX As Long
        If WholeFileFlag = 0 Then
            NF = FreeFile
            Open FName$ For Input Access Read As #NF
            
            'XX = Len(StrainSeq(0))
            
            If LOF(NF) > 10000000 Or x = x Then
                Close #NF
                Open FName$ For Binary As #NF
                BigFileFlag = 1
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "SequencesForSaving" + UFTag For Binary As #FF
            Else
                BigFileFlag = 0
            End If
            
            Form1.ProgressBar1.Value = 1
            Call UpdateF2Prog
            Offset = 0
            Dim NoLFFlag As Long, FirstRead As Long
            NoLFFlag = -1
            
            
            
            
            
            FirstRead = 0
            Do
                If FastLoadFlag = 0 Then
                    If EOF(NF) Then Exit Do
                    
                    If BigFileFlag = 1 Then
                        Dim PosN As Long
                        
                        Dim PosLB As Long
                        Dim TempString2 As String
                        LastPos = 1
                        Do While Not EOF(NF)
                            
                            TempString = String(ReadBlock, " ")
                            '@
                            Get #NF, , TempString
                            TempString = UCase(Trim(TempString))
                            posxx = 0
                            posxx = InStr(1, TempString, "A", vbTextCompare)
                            If posxx = 0 Then posxx = InStr(1, TempString, "C", vbTextCompare)
                            If posxx = 0 Then posxx = InStr(1, TempString, "G", vbTextCompare)
                            If posxx = 0 Then posxx = InStr(1, TempString, "T", vbTextCompare)
                            If posxx = 0 Then Exit Do
                            If FirstRead = 0 Then
                                FirstRead = 1
                                crPos = InStr(LastPos, TempString, Chr$(13), vbBinaryCompare)
                                lfPos = InStr(LastPos, TempString, Chr$(10), vbBinaryCompare)
                                
                                If crPos > 0 And lfPos > 0 Then
                                    If crPos < lfPos Then
                                        Target = Chr$(13)
                                    Else
                                        Target = Chr$(10)
                                    End If
                                    incR = 2
                                ElseIf crPos > 0 Then
                                    Target = Chr$(13)
                                    incR = 1
                                ElseIf lfPos > 0 Then
                                    Target = Chr$(10)
                                    incR = 1
                                End If
                            End If
                            PosS = InStr(1, TempString, "Recombination Data", vbBinaryCompare)
                            LastPos = 1
                            
                            
                            Dim MaybeName As Long
                            If MaybeName <> 2 Then
                                MaybeName = 1
                                If NextNo > 0 Then
                                    If Len(StrainSeq(0)) > Len(StrainSeq(NextNo)) Then
                                        MaybeName = 0
                                    End If
                                End If
                            End If
                            PosN = InStr(LastPos, TempString, ">", vbBinaryCompare)
                            Do
                                If LastPos >= PosN And PosN <> 0 Then
                                    PosN = InStr(LastPos, TempString, ">", vbBinaryCompare)
                                End If
                                '@
                                'PosLF = InStr(LastPos, TempString, Target, vbBinaryCompare)
                                PosCR = InStr(LastPos, TempString, Target, vbBinaryCompare)
                                
                                'Nextno = -1
                                If PosS <> 0 Then
                                    If PosS < PosN Or (PosS < PosCR And PosCR > 0) Then Exit Do
                                End If
                                'XX = Len(StrainSeq(Nextno))
                                
                                'XX = Len(TempString)
                                If PosN = 0 And PosCR = 0 Then  'in the middle of a long sequence
                                    'XX = Right(TempString, Len(TempString) - (LastPos - 1))
                                    ''XX = Right(TempString, Len(TempString) - (LastPos - 1))
                                    '@
                                    StrainSeq(NextNo) = Right(TempString, Len(TempString) - (LastPos - 1))
                                    LastPos = 1
                                    Exit Do
                                    
                                    
                                ElseIf (LastPos = 1 And PosN > Len(StrainSeq(0)) And MaybeName = 2) And (PosCR < PosN) Then 'in the middle of a name
                                    'XX = Mid$(TempString, 1, PosCR - 2)
                                        
                                        OriginalName(NextNo) = OriginalName(NextNo) + Mid$(TempString, 1, PosCR - 1)
                                        LastPos = PosCR + incR
                                        MaybeName = 0
                                        
                                ElseIf (PosN <> 0 And PosN < PosCR) Or (PosCR = 0 And PosN > 0) Then 'read a name
                                    If NextNo > -1 Then
                                        StrainSeq(NextNo) = Trim(StrainSeq(NextNo))
                                        'XX = Len(StrainSeq(0))
                                        'XX = Len(StrainSeq(Nextno - 1))
                                    End If
'                                    If NextNo > 1500 Then
'                                        Close #FF
'                                        ChDrive oDirX
'                                        ChDir oDirX
'
'                                        Close #NF
'                                        'XX = Mid$(StrainSeq(0), 90, 20)
'                                        CurrentlyRunningFlag = oCRF
'                                        XX = CNX
'                                        Exit Sub
'                                    End If
'                                    If NextNo > -1 Then
'                                        Dim SLC As Long
'                                        SLC = 0
'                                        For x = 1 To Len(StrainSeq(NextNo))
'                                            If Mid(StrainSeq(NextNo), x, 1) <> "-" Then
'                                                SLC = SLC + 1
'                                            End If
'                                        Next x
'                                    Else
'                                        SLC = 1000
'                                    End If
'                                    CNX = CNX + 1
'                                    If SLC > 200 Then
'                                        If NextNo > 0 Then
'                                            If StrainSeq(NextNo) <> StrainSeq(NextNo - 1) Then
'                                                DCount = 0
'                                                For x = 1 To Len(StrainSeq(NextNo))
'                                                    If Mid(StrainSeq(NextNo), x, 1) <> Mid(StrainSeq(NextNo - 1), x, 1) Then
'                                                        DCount = DCount + 1
'                                                        If DCount > 3 Then
'                                                            Exit For
'                                                        End If
'                                                    End If
'
'                                                Next x
'                                                If DCount > 3 Then
'                                                    NextNo = NextNo + 1
'                                                    Call SeqArrays
'                                                End If
'                                            End If
'                                        Else
'                                            NextNo = NextNo + 1
'                                            Call SeqArrays
'                                        End If
'
'                                     End If
'                                    If Nextno = 65 Then
'                                        x = x
'                                    End If
                                    
                                    'MaybeName = 1
                                        
                                    NextNo = NextNo + 1
'                                    If NextNo = 667 Or NextNo = 668 Or NextNo = 4630 Then
'                                        x = x
'                                    End If
                                    If NextNo > 0 Then
                                        'XX = Len(StrainSeq(1))
                                        If UBound(StrainSeq) < NextNo Then
                                            ReDim Preserve StrainSeq(NextNo + 50)
                                            ReDim Preserve OriginalName(NextNo + 50)
                                        End If
                                        StrainSeq(NextNo) = String(Len(StrainSeq(0)), " ")
                                    Else
                                        StrainSeq(NextNo) = String(ReadBlock / 10, " ")
                                    End If
                                    CPInSeqnum = 1
                                    If NextNo > 1 Then
                                        
                                        StrainSeq(NextNo - 1) = Left(StrainSeq(NextNo - 1), Len(StrainSeq(0)))
                                        'XX = Len(StrainSeq(NextNo))
                                        If Len(StrainSeq(NextNo - 1)) < Len(StrainSeq(0)) Then
                                            StrainSeq(NextNo - 1) = StrainSeq(NextNo - 1) + String(Len(StrainSeq(0)) - Len(StrainSeq(NextNo - 1)), "-")
                                        End If
                                        StrainSeq(NextNo - 1) = UCase(StrainSeq(NextNo - 1))
                                        'XX = Len(StrainSeq(NextNo - 1))
                                        'Mid$(StrainSeq(Nextno - 1), 1, 1) = Left(Trim(Str(Nextno - 1)), 1)
                                        
                                        Put #FF, , StrainSeq(NextNo - 1)
                                        If NextNo > 2 Then
                                            StrainSeq(NextNo - 2) = ""
                                        End If
                                        LastPut = NextNo - 1
                                    End If
                                    
                                    If PosCR = 0 Then
                                        OriginalName(NextNo) = Mid$(TempString, PosN + 1, Len(TempString) - PosN)
                                        MaybeName = 2
                                        Exit Do
                                    Else
                                        OriginalName(NextNo) = Mid$(TempString, PosN + 1, PosCR - (PosN + 1))
                                    End If
                                    LastPos = PosCR + incR
                                   
                                ElseIf (PosCR < PosN And PosCR > 0) Or (PosN = 0 And PosCR > 0) Then
                                    If PosCR > 0 Then
                                        Dim TSX As String
                                        TSX = Mid(TempString, LastPos, (PosCR - LastPos))
                                    
                                        Pos = InStr(LastPos, TSX, Target, vbBinaryCompare) + 1
                                        
                                        If Pos = 1 Then
                                            Pos = LastPos
                                        ElseIf Pos >= PosCR Then
                                            Pos = LastPos
                                        Else
                                        x = x
                                        End If
                                    End If
                                    'XX = Right(Mid(TempString, Pos, PosCR - Pos), 10)
                                    'StrainSeq(Nextno) = StrainSeq(Nextno) + Mid(TempString, Pos, PosCR - Pos)
'                                    If NextNo = 4630 Then
'                                        x = x
'                                    End If
                                    XX = Len(StrainSeq(0))
                                    If Len(StrainSeq(NextNo)) < Len(StrainSeq(0)) Then
                                        AlreadyInX = Len(StrainSeq(NextNo))
                                    Else
                                        AlreadyInX = 0
                                    End If
                                    
                                    If Len(StrainSeq(NextNo)) < CPInSeqnum + (PosCR - Pos) Then
                                        StrainSeq(NextNo) = StrainSeq(NextNo) + String(ReadBlock / 10, " ")
                                    End If
                                    'XX = Mid(TempString, Pos, PosCR - Pos)
                                    If Len(StrainSeq(NextNo)) <= AlreadyInX + (PosCR - Pos) Then
                                        StrainSeq(NextNo) = StrainSeq(NextNo) + String(PosCR - Pos, " ")
                                    End If
                                    Mid(StrainSeq(NextNo), CPInSeqnum + AlreadyInX, (PosCR - Pos)) = Mid(TempString, Pos, (PosCR - Pos))
                                    'Posxxxx = InStr(1, StrainSeq(NextNo), "A", vbTextCompare)
                                    CPInSeqnum = CPInSeqnum + PosCR - Pos
                                    'XX = Len(StrainSeq(0))
                                    LastPos = PosCR + incR
'                                    If CPInSeqnum > 3000000 Then
'                                        x = x
'                                    End If
                                    If LastPos > Len(TempString) Then Exit Do
                                    Pos = InStr(LastPos, TempString, Target, vbBinaryCompare)
'                                    If PosN = 0 Then
'                                        x = x
'                                    End If
                                    If PosN = 0 And Pos = 0 Then
                                        'StrainSeq(Nextno) = StrainSeq(Nextno) + Mid(TempString, LastPos, (Len(TempString) + 1 - LastPos))
'                                        If Len(StrainSeq(NextNo)) < Len(StrainSeq(0)) Then
'                                            x = x
'                                        End If
'                                        XX = Mid$(StrainSeq(NextNo), 500, 30)
                                        Mid(StrainSeq(NextNo), CPInSeqnum, (Len(TempString) + 1 - LastPos)) = Mid(TempString, LastPos, (Len(TempString) + 1 - LastPos))
                                        'XX = Mid$(StrainSeq(NextNo), 500, 30)
                                        CPInSeqnum = CPInSeqnum + (Len(TempString) + 1 - LastPos)
                                        'XX = Len(StrainSeq(Nextno))
                                        Exit Do
                                    End If
                                ElseIf PosCR = 0 And PosN > 0 Then 'in the middle of a name
                                    
                                    'StrainSeq(Nextno) = StrainSeq(Nextno) + Mid(TempString, LastPos, Len(TempString) - LastPos)
                                    'Exit Do
                                    'TempString2 = Len(StrainSeq(Nextno)) + 1
                                    'XX = Right(TempString, Len(TempString) - LastPos)
                                    'XX = Left(XX, 10)
                                    
'                                    Nextno = Nextno + 1
'                                    Call SeqArrays
'                                    If Nextno > 1 Then
'                                        StrainSeq(Nextno - 1) = Left(StrainSeq(Nextno - 1), Len(StrainSeq(0)))
'                                        If Len(StrainSeq(Nextno - 1)) < Len(StrainSeq(0)) Then
'                                            StrainSeq(A) = StrainSeq(Nextno - 1) + String(Len(StrainSeq(0)) - Len(StrainSeq(Nextno - 1)), "-")
'                                        End If
'                                        Put #FF, , StrainSeq(Nextno - 1)
'                                        StrainSeq(Nextno - 1) = ""
'                                        LastPut = Nextno - 1
'                                    End If
'                                    OriginalName(Nextno) = Mid$(TempString, PosN + 1, PosCR - (PosN + 1))
'                                    LastPos = PosCR + incR
                                    
                                End If
                                
                            Loop
                            EE = Abs(GetTickCount)
                            If (EE - SS) > 500 Then
                                SS = EE
                                Form1.SSPanel1.Caption = Trim(Str(NextNo + 1)) + " sequences loaded"
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                'XX = StrainSeq(0)
                                DoEvents
                            End If
                            
                            x = x
                        Loop
                        For A = LastPut + 1 To NextNo
                            
                            StrainSeq(A) = Left(StrainSeq(A), Len(StrainSeq(0)))
                            If Len(StrainSeq(A)) < Len(StrainSeq(0)) Then
                                StrainSeq(A) = StrainSeq(A) + String(Len(StrainSeq(0)) - Len(StrainSeq(A)), "-")
                            End If
                            StrainSeq(A) = UCase(StrainSeq(A))
                            
                            'XX = Right(StrainSeq(A), 50)
                            Put #FF, , StrainSeq(A)
                            StrainSeq(A) = ""
                            
                            x = x
                        Next A
                        
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                        
                        Close #NF
                        'XX = Mid$(StrainSeq(0), 90, 20)
                        CurrentlyRunningFlag = oCRF
                        XX = CNX
                        Exit Sub
                        
                    Else
                        TempString = String(Len(StrainSeq(0)), " ")
                        Input #NF, TempString
                    End If
                    
                    
                Else
                    'XX = Len(TempString)
                    If Left(TempString, 1) <> ">" Then
                        Offset = Offset + Len(StrainSeq(NextNo)) + Len(OriginalName(NextNo))
                        
                        tTempString = String(Len(StrainSeq(0)) + Len(StrainSeq(0)) / 2, " ")
                        Get #NF, Offset, tTempString
                        Pos = InStr(1, tTempString, Chr(13), vbBinaryCompare)
                        NPos = InStr(Pos + 1, tTempString, Chr(13), vbBinaryCompare)
                        
                        If NPos = 0 Then Exit Do
                        TempString = Mid(tTempString, Pos + 2, NPos - Pos - 2)
                        'XX = Left(TempString, 10)
                        'yy = Right(TempString, 10)
                        Pos = NPos
                        
                    Else
                        NPos = InStr(Pos + 1, tTempString, Chr(13), vbBinaryCompare)
                        TempString = Mid(tTempString, Pos + 2, NPos - Pos - 2)
                        'XX = Left(TempString, 10)
                        'yy = Right(TempString, 10)
                        'X = X
                    End If
                
                End If
                If Left$(TempString, 1) = ">" Then
                    NextNo = NextNo + 1
'                    If NextNo = 65 Then
'                                        x = x
'                                    End If
                    If BigFileFlag = 1 Then
                        If NextNo > 2 Then
                            StrainSeq(NextNo - 2) = UCase(StrainSeq(NextNo - 2))
                            Put #FF, , StrainSeq(NextNo - 2)
                            StrainSeq(NextNo - 2) = ""
                            LastPut = NextNo - 2
                        End If
                    End If
                    Call SeqArrays
                    If NextNo > 0 Then
                        StrainSeq(NextNo) = String(Len(StrainSeq(0)), " ")
                        CPXX = 1
                    End If
                    Form1.ProgressBar1.Value = 1 + ((Len(StrainSeq(0)) * NextNo) / LOF(NF)) * 30
                    Call UpdateF2Prog
                    OriginalName(NextNo) = Mid$(TempString, 2, Len(TempString) - 1)
                    
                Else
                    If NextNo = 0 Then
                        StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                    Else
                        If Len(TempString) > 0 And TempString <> "GB Data" Then
                            Mid(StrainSeq(NextNo), CPXX, Len(TempString)) = Mid(TempString, 1, Len(TempString))
                            CPXX = CPXX + Len(TempString)
                        End If
                    End If
                   ' XX = Mid(StrainSeq(1), 50, 40)
                    
                    If Len(StrainSeq(0)) > 100000 Then
                        tPX = Abs(GetTickCount)
                        If Abs(tPX - ltPX) > 500 Then
                            ltPX = tPX
                            If NextNo > 1 Then
                                Form1.SSPanel1.Caption = Trim(Str(NextNo)) + " sequences loaded"
                            ElseIf NextNo = 1 Then
                                Form1.SSPanel1.Caption = "1 sequence loaded"
                                
                            Else
                                Form1.SSPanel1.Caption = Trim(Str(Len(StrainSeq(0)))) + " nucleotides of the first sequence loaded"
                            End If
                            Form1.Refresh
                        End If
                        If Right(FName$, 3) = "rdp" Or Right(FName$, 3) = "RDP" Then
                        
                            FastLoadFlag = 1
                            Close #NF
                            Open FName$ For Binary As #NF
                        Else
                            'X = X
                        End If
                    Else
                        FastLoadFlag = 0
                    End If
                    
                End If
                
                
                
    'xxx = Len(StrainSeq(2))
                If Left(TempString, 18) = "Recombination Data" Or Left(TempString, 7) = "GB Data" Then Exit Do
                
            Loop
            
             
            
            If BigFileFlag = 1 Then
                If LastPut = NextNo - 1 Then
                    For A = LastPut + 1 To NextNo
                        StrainSeq(A) = UCase(StrainSeq(A))
                        Put #FF, , StrainSeq(A)
                        StrainSeq(A) = ""
                    Next A
                End If
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            End If
            Close #NF
        Else
            LastPos = InStr(1, SeqFile, ">", vbBinaryCompare)
            NextNo = NextNo + 1
            
            crPos = InStr(LastPos, SeqFile, Chr$(13), vbBinaryCompare)
            lfPos = InStr(LastPos, SeqFile, Chr$(10), vbBinaryCompare)
            
            If crPos > 0 And lfPos > 0 Then
                If crPos < lfPos Then
                    Target = Chr$(13)
                Else
                    Target = Chr$(10)
                End If
                incR = 2
            ElseIf crPos > 0 Then
                Target = Chr$(13)
                incR = 1
            ElseIf lfPos > 0 Then
                Target = Chr$(10)
                incR = 1
            End If
            SeqFile = SeqFile + Target
            'XX = Right$(SeqFile, 40)
            LastPos = 0
            Pos = InStr(LastPos + 1, SeqFile, ">", vbBinaryCompare)
    
            Do
                
                If Pos = 0 Then Exit Do 'Pos = Len(SeqFile) - 1
                NPos = InStr(LastPos + 1, SeqFile, Target, vbBinaryCompare)
                
                'If NPos = 0 Then
                '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
                '    If NPos = 0 Then
                '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
                '    End If
                'End If
                If NPos = 0 Then
                    CurrentlyRunningFlag = oCRF
                    XX = CNX
                    Exit Sub
                End If
                If NPos <= Pos Then
                    NPos = InStr(Pos + 1, SeqFile, Target, vbBinaryCompare)
                End If
                If NextNo > UBound(OriginalName, 1) Then
                    ReDim Preserve OriginalName(NextNo + 100)
                End If
                OriginalName(NextNo) = Trim(Mid$(SeqFile, Pos + 1, NPos - Pos - 1))
                XX = XX
                'XX = Mid$(SeqFile, NPos + 2, 1)
                'If Mid$(SeqFile, NPos + 2, 1) <> "A" And Mid$(SeqFile, NPos + 2, 1) <> "C" And Mid$(SeqFile, NPos + 2, 1) <> "G" And Mid$(SeqFile, NPos + 2, 1) <> "T" And Mid$(SeqFile, NPos + 2, 1) <> "-" And Mid$(SeqFile, NPos + 2, 1) <> "~" Then
                '    LastPos = NPos + 2
                'Else
                '    LastPos = NPos + 1
                'End If
                LastPos = NPos + incR
                NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
                Pos = InStr(LastPos + 1, SeqFile, ">", vbBinaryCompare)
                
                If Pos = 0 Then
                    If InStr(1, SeqFile, "Recombination Data", vbBinaryCompare) = 0 Then
                        Pos = Len(SeqFile)
                    Else
                        NPos = InStr(1, SeqFile, "GB Data", vbBinaryCompare) - 2
                        Xpos = InStr(1, SeqFile, "Recombination Data", vbBinaryCompare) - 2
                        
                        If Xpos < NPos Or NPos = 0 Then
                            Pos = Xpos
                        Else
                            Pos = NPos
                        End If
                    End If
                    FFlag = 1
                
                End If
                If NPos = 0 Then NPos = Len(SeqFile)
                
                Dim TempS As String, TempSS As String
                TempSS = ""
                If NextNo = 0 Then
                    TempS = ""
                    
                    SS = Abs(GetTickCount)
                    
                    Do While LastPos + 2 < Pos And NPos > 0
                        
                        'XX = Len(StrainSeq(Nextno))
                        'xxx = Mid$(SeqFile, LastPos, NPos - LastPos)
                        
                        TempS = TempS + Mid$(SeqFile, LastPos, NPos - LastPos)
                        'XX = Mid$(SeqFile, LastPos, NPos - LastPos)
                        'xxx = right(XX, 10)
                        
                        If Len(TempS) > 100000 Then
                            TempSS = TempSS + TempS
                            TempS = ""
                        End If
                        'xxx = Asc(left(TempS, 1))
                        LastPos = NPos + incR
                        'xx = Len(StrainSeq(10))
                        NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
                        'If NPos = 0 Then
                        '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
                        '    If NPos = 0 Then
                        '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
                        '    End If
                        'End If
                        'If NPos = 0 Then Exit Sub
                        EE = Abs(GetTickCount)
                        If Abs(EE - SS) > 500 Then
                            SS = EE
                            Form1.SSPanel1.Caption = "Loaded" + Str(Len(TempS) + Len(TempSS)) + " nucleotides"
                            Form1.Refresh
                        End If
                    Loop
                Else
                    TempS = String(Len(StrainSeq(0)), " ")
                    
                    Dim PosX As Long
                    PosX = 1
                    SS = Abs(GetTickCount)
                    Do While LastPos + 2 < Pos And NPos > 0 And NPos <> LastPos
                        
                        'XX = Len(StrainSeq(Nextno))
                        'XX = Mid$(SeqFile, LastPos, NPos - LastPos)
                        LenS = Len(TempS)
                        If PosX > LenS Then
                            MsgBox "It seems as though you are trying to load either an unaligned set of sequences, or an alignment where some rows are longer than others. What you should do is run the file you are attempting to analyse through an alignment program such as MUSCLE (an easy to use version of which can be found in the computer program MEGA5).  Try to open the alignment file that you get from this program in RDP4."
                            NextNo = -1
                            CurrentlyRunningFlag = oCRF
                            XX = CNX
                            Exit Sub
                        End If
                        Mid(TempS, PosX, NPos - LastPos) = Mid$(SeqFile, LastPos, NPos - LastPos)
                        PosX = PosX + (NPos - LastPos)
                        LastPos = NPos + incR
                        'xx = Len(StrainSeq(10))
                        NPos = InStr(LastPos, SeqFile, Target, vbBinaryCompare)
                        'If NPos = 0 Then
                        '    NPos = InStr(LastPos + 1, SeqFile, Chr$(13), vbBinaryCompare)
                        '    If NPos = 0 Then
                        '        NPos = InStr(LastPos + 1, SeqFile, Chr$(10), vbBinaryCompare)
                        '    End If
                        'End If
                        'If NPos = 0 Then Exit Sub
                        
                    Loop
                    EE = Abs(GetTickCount)
                    TT = EE - SS
                    'X = X
                End If
                If NextNo > UBound(StrainSeq, 1) Then
                    ReDim Preserve StrainSeq(NextNo + 100)
                End If
                StrainSeq(NextNo) = TempSS + TempS
                'XX = Len(StrainSeq(0))
                If FFlag = 1 Then Exit Do
                If Pos >= Len(SeqFile) - 2 Then Exit Do
                NextNo = NextNo + 1
                
                Call SeqArrays
    
                'Form1.SSPanel1.Caption = trim$(cstr(Nextno)) & " Sequences Loaded"
    
                If NextNo / 10 = Int(NextNo / 10) Then
                    Form1.ProgressBar1.Value = 1 + (LastPos / Len(SeqFile)) * 30
                    Call UpdateF2Prog
                End If
    
            Loop
    
        End If
        
        If MultFNum > 0 Then
            If NextNo > UBound(TempMult, 1) Then
                ReDim TempMult(NextNo)
                ReDim TempMultName(NextNo)
                ReDim MultCoords(MultFNum, NextNo)
                For x = 0 To NextNo
                    Pos = InStr(1, OriginalName(x), "_", vbBinaryCompare)
                    If Pos > 0 Then
                        TempMultName(x) = Left(OriginalName(x), Pos - 1)
                        If DebuggingFlag < 2 Then On Error Resume Next
                        MultCoords(FN, x) = Right(OriginalName(x), (Len(OriginalName(x)) - Pos))
                        On Error GoTo 0
                    Else
                        TempMultName(x) = OriginalName(x)
                    End If
                    
                    TempMult(x) = StrainSeq(x)
                    StrainSeq(x) = ""
                Next x
            ElseIf NextNo = UBound(TempMult, 1) Then
                If FN = 3 Then
                    x = x
                End If
                If UBound(TempMult, 1) <= NextNo Then
                    
                    For x = 0 To NextNo
                        Pos = InStr(1, OriginalName(x), "_", vbBinaryCompare)
                        If Pos > 0 Then
                            Temp = Left(OriginalName(x), Pos - 1)
                        Else
                            Temp = OriginalName(x)
                        End If
                        For Y = 0 To UBound(TempMult, 1)
                            If TempMultName(Y) = Temp Then
                                TempMult(Y) = TempMult(Y) + StrainSeq(x)
                                Exit For
                            End If
                        Next Y
                        x = x
                        If Y = UBound(TempMult, 1) + 1 Then 'there is a new sequence
                            For Y = 0 To NextNo
                                If TempMult(Y) = "" Then
                                    TempMultName(Y) = Temp
                                    If x > 0 Then
                                        TempMult(Y) = String(Len(TempMult(0)) - Len(TempMult(Y)), "-") + TempMult(Y)
                                    End If
                                End If
                            Next Y
                        End If
                        'xxx = Right(OriginalName(X), Len(OriginalName(X)) - Pos)
                        If Pos > 0 Then
                            If DebuggingFlag < 2 Then On Error Resume Next
                            MultCoords(FN, x) = Right(OriginalName(x), Len(OriginalName(x)) - Pos)
                            On Error GoTo 0
                        End If
                        'TempMult(X) = StrainSeq(X)
                        StrainSeq(x) = ""
                    Next x
                    x = x
                Else
                x = x
                End If
            
            Else
                ReDim StrainSeq(UBound(TempMult, 1))
            End If
            
            If FN < MultFNum And StrainSeq(0) <> "" Then
                For x = 0 To NextNo
                    TempMult(x) = TempMult(x) + "~"
                Next x
            ElseIf FN = MultFNum Then
                NextNo = UBound(TempMult, 1)
                For x = 0 To NextNo
                    OriginalName(x) = TempMultName(x)
                    StrainSeq(x) = TempMult(x)
                Next x
                'XX = Len(StrainSeq(X))
                'XX = FN
            End If
        End If
        
    Next FN
    
    StrainSeq(NextNo) = Trim(StrainSeq(NextNo))
    'need to get rid of characters at end of last seq
   
    'XX = right$(StrainSeq(10), 20)
    'XX = Len(StrainSeq(10))
    If Right(StrainSeq(NextNo), 7) = "GB Data" Then
        StrainSeq(NextNo) = Left(StrainSeq(NextNo), Len(StrainSeq(NextNo)) - 7)
        'XX = right$(StrainSeq(10), 20)
        'StrainSeq(Nextno) = left(StrainSeq(Nextno), Len(StrainSeq(Nextno)) - 1)
        
    End If
    'XX = Nextno
   CurrentlyRunningFlag = oCRF
    XX = CNX
End Sub
Public Sub LoadNEXUS()

    Dim NF As Integer
    Dim lTempString As String, TempString As String, Trimmed As String
    Dim x As Long, LastPos As Long, PosN1 As Long, StartFrom As Long, NumSpace As Long

    NF = FreeFile
    Form1.SSPanel1.Caption = "Loading NEXUS File"
    Open FName$ For Input Access Read As #NF
    Input #NF, TempString

    If Len(TempString) > LOF(NF) * 0.5 Then 'ie the whole file is read because there are no carriage returns
        Call ReformatFile(NF, TempString, SaveFlag)
        Input #NF, TempString
        Input #NF, TempString
        Input #NF, TempString
        'Line Input #NF, TempString
    Else
        Input #NF, TempString
        Input #NF, TempString
    End If

    NextNo = -1

    Do While Not EOF(NF)
        Input #NF, TempString
        Pos = InStr(1, TempString, "[", vbBinaryCompare)
            'If Left(TempString, 4) = "END;" Then
            
           
            
        If Pos > 0 And Left(TempString, 4) <> "END;" Then
            NextNo = NextNo + 1
            PosN1 = InStr(Pos + 1, TempString, " ", vbBinaryCompare)
            OriginalName(NextNo) = Mid$(TempString, Pos + 1, PosN1 - (Pos + 1))
        End If

        If TempString = "matrix" Or TempString = "MATRIX" Or TempString = "Matrix" Then Exit Do
    Loop

    Do
        Input #NF, TempString

        If TempString <> Empty Then Exit Do
    Loop

    If Left$(TempString, 1) = "[" Then 'ie file is interleaved
        Pos = InStr(1, TempString, "10", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(1, TempString, "1", vbBinaryCompare)
        StartFrom = Pos - CDbl(Mid$(TempString, Pos, 3))
        x = 0
        Do
            If InStr(1, TempString, "]", vbBinaryCompare) > 0 Then
                Exit Do
            End If
            Input #NF, TempString
        Loop
        Do While Not EOF(NF)
            Input #NF, TempString
            
            If TempString = ";" Then
                If x > 0 Then
                    NextNo = x - 1
                End If
                Exit Do
            End If
            If Mid$(TempString, 1, 1) = "[" Then
                x = 0
                Do
                    If InStr(1, TempString, "]", vbBinaryCompare) > 0 Then
                        Input #NF, TempString
                        Exit Do
                    End If
                    Input #NF, TempString
                Loop
            End If
            If TempString = "" Then
                lTempString = TempString
                
            End If
            If Mid$(TempString, 1, 1) <> "[" And TempString <> Empty Then
                If lTempString = "" Then
                    x = 0
                    lTempString = "xx"
                    'xxx = 'Len(StrainSeq(3))
                    If Len(StrainSeq(0)) > 3100 Then
                        x = x
                    End If
                End If
                If InStr(1, Trim(TempString), " ", vbBinaryCompare) = 0 Then ' ie very long lines involved
                    x = x - 1
                    Trimmed = Trim(TempString)
                Else
                    Trimmed = Trim$(Mid$(TempString, StartFrom, Len(TempString) - StartFrom + 1))
                End If
                Pos = InStr(1, Trimmed, " ", vbBinaryCompare)
                'zz = Len(Trimmed)
                UB = UBound(StrainSeq, 1)
                If x > UB Then
                    ReDim Preserve StrainSeq(x + 100)
                End If
                If Pos = 0 Then
                    StrainSeq(x) = StrainSeq(x) + Trimmed
                Else
                    StrainSeq(x) = StrainSeq(x) + Trim$(Left$(Trimmed, Pos))
                End If

                If OriginalName(x) = "" Then OriginalName(x) = Trim$(Left$(TempString, StartFrom - 1))
                x = x + 1
                UB = UBound(OriginalName, 1)
                If x > UB Then
                    ReDim Preserve OriginalName(x + 100)
                End If
                Call SeqArrays
            ElseIf Mid$(TempString, 1, 1) = "[" Then
                x = 0
            End If

            Form1.ProgressBar1.Value = 1 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.3
            Call UpdateF2Prog
        Loop

        If NextNo > -1 Then

            If x > 0 And OriginalName(NextNo) <> "" Then

                If OriginalName(x - 1) <> "" Then NextNo = x - 1
            End If

        End If

    ElseIf Left$(TempString, 1) = "'" Then 'ie file is interleaved
        If StrainSeq(0) = "" Then
            NextNo = -1
        End If
        Do While Not EOF(NF)

            If TempString <> Empty And TempString <> ";" Then
                NextNo = NextNo + 1

                Call SeqArrays

                Pos = InStr(3, TempString, "'", vbBinaryCompare)

                If Pos > 0 Then
                    OriginalName(NextNo) = Trim$(Mid$(TempString, 2, Pos - 2))
                    
                    For ZZ = 0 To NextNo
                        If OriginalName(NextNo) = OriginalName(ZZ) Then
                            NextNo = ZZ
                            Exit For
                        End If
                    Next ZZ
                    'find out if there are gaps or tabs between the end of the name
                    'and the start of the sequence
                    post = InStr(Pos, TempString, Chr(9), vbBinaryCompare)
                    'If post = 0 Then
                    '    post = InStr(Pos, TempString, Chr(10), vbBinaryCompare)
                    'End If
                    If post > 0 Then
                        Do
                            post = post + 1
                            If Mid$(TempString, post, 1) <> Chr(9) Then Exit Do
                        Loop
                        StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(Mid$(TempString, post, Len(TempString) - (post - 1)))
                        x = x
                    Else
                        StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(Mid$(TempString, Pos + 1, Len(TempString) - Pos))
                    End If
                Else
                    OriginalName(NextNo) = Trim$(Mid$(TempString, 2, 15))
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(Mid$(TempString, 15, Len(TempString) - 15))
                End If
                x = x
            Else
                Exit Do
            End If

            Form1.ProgressBar1.Value = 1 + (Loc(NF) / (LOF(NF) / 127)) * 30
            Call UpdateF2Prog
            Line Input #NF, TempString
        Loop
        If NextNo = 0 Then
            'OK a cockup ahs been made mayeb goto the non-interlieved load
            GoTo Stepinhere
        End If
        x = x
    ElseIf TempString <> Empty Then 'ie file is non interleaved
Stepinhere:
        Do While Not EOF(NF)

            If TempString <> Empty And TempString <> ";" Then
                NextNo = NextNo + 1

                Call SeqArrays

                PosN1 = InStr(1, TempString, " ", vbBinaryCompare)

                If PosN1 = 0 Then
                    PosN1 = InStr(1, TempString, Chr(9), vbBinaryCompare)
                    If PosN1 = 0 Then
                        OriginalName(NextNo) = Trim$(TempString)
                        Input #NF, TempString
                        PosN1 = InStr(1, TempString, " ", vbBinaryCompare)
                    Else
                        OriginalName(NextNo) = Mid$(TempString, 1, PosN1 - 1)
                        x = x
                    End If
                Else
                    OriginalName(NextNo) = Mid$(TempString, 1, PosN1 - 1)
                End If

                x = PosN1

                Do
                    x = x + 1

                    If Mid$(TempString, x, 1) <> " " And Mid$(TempString, x, 1) <> Chr(9) And Mid$(TempString, x, 1) <> "'" Then
                        NumSpace = x - 1
                        Exit Do
                    End If

                Loop

                StrainSeq(NextNo) = Trim(Right$(TempString, Len(TempString) - NumSpace))

                Do While Not EOF(NF)
                    Input #NF, TempString
                    Pos = InStr(1, TempString, " ", vbBinaryCompare)
                    
                    If Pos = 0 Then
                        Pos = InStr(1, TempString, Chr(9), vbBinaryCompare)
                    End If
                    
                    If Pos > 0 Then Exit Do

                    If TempString = Empty Then Exit Do

                    If TempString = ";" Then Exit Do

                    If Len(TempString) < Len(StrainSeq(0)) Then
                        NextNo = NextNo + 1
                        OriginalName(NextNo) = Trim$(TempString)
                        Input #NF, TempString
                        StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                    Else
                        StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                    End If

                Loop

                If Left$(TempString, 1) = ";" Then Exit Do
            Else

                If TempString = ";" Then Exit Do
                Input #NF, TempString
            End If

            Form1.ProgressBar1.Value = 1 + (Loc(NF) / (LOF(NF) / 127)) * 30
            Call UpdateF2Prog
        Loop

    End If
XX = NextNo
    Close #1
End Sub
Public Sub DoInterface()

    Dim ZZ As Long, Y As Long, OP10SM As Long, OVx As Single, OM As Long, VSMax As Long, Index As Long, OV As Long, OSM As Long, OTVal As Long, x As Long, Tempsize As Long, Pict As Long, Bak As Long, TYFM As Integer, tTYF As Double
    Dim otTYF As Double
    'If F1MDF = 1 Then Exit Sub
    Dim TestMax As Long
    'SS = Abs(GetTickCount)
   
    If F1MDF = 0 And F1RF = 0 Then
        Form3.Combo2.Clear
        '@
        For x = 0 To PermNextno
            Form3.Combo2.AddItem OriginalName(x)
        Next x
        Form3.Combo2.ListIndex = 0
        
        Form3.Combo4.Clear
        '@
        For x = 0 To PermNextno
            Form3.Combo4.AddItem OriginalName(x)
        Next x
        Form3.Combo4.ListIndex = 0
        
        Form3.Combo5.Clear
        'Form3.Combo5.ListIndex = 0
        Form3.Combo5.AddItem "Use original RDP5/4/3 decision tree"
        Form3.Combo5.AddItem "Use trained logistic regression derived decision weights"
        'Form3.Combo5.AddItem "Use a trained neural network"
        If ConsensusStrat = 0 Then
            Form3.Combo5.ListIndex = 0
        ElseIf ConsensusStrat = 1 Then
            Form3.Combo5.ListIndex = 1
        End If
    End If
    
    Pict = Form1.hdc
    Bak = GetBkColor(Pict)
    OTVal = Form1.Timer1.Enabled
    
    Form1.Timer1.Enabled = False

    With Form1.Picture9
        .ScaleMode = 3
        If F1MDF = 0 And F1RF = 0 Then
            .BackColor = BackColours
        End If
    End With
'   XX = Screen.TwipsPerPixelX
'   XX = Form1.Picture9.Width
'   XX = Form1.Width
'    XX = Form1.Picture1.Width
    With Form1.Picture1 'Sequence display
        .ScaleMode = 3
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        P1OH = (((NextNo + 2) * 13) - TYFM) * tTYF ' '2959
      'teststr = .Font
        .Font.Name = "Courier New"
        If TYF <= 0 Then TYF = 1
        If P1FontSize > 0 Then
            .FontSize = P1FontSize * TYF
        End If
        .ForeColor = 0
        If F1MDF = 0 And F1RF = 0 And DontPrintNames = 0 Then
            .Picture = LoadPicture()
            .BackColor = BackColours
        End If
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        .Enabled = True
    End With
    
    With Form1.Picture2 'Recombination Info window
        .ScaleMode = 3
        If F1MDF = 0 And F1RF = 0 Then
            .Picture = LoadPicture()
            .BackColor = Bak
            .Refresh
        End If
        .ForeColor = 0
        
    End With

    

    With Form1.Picture8
        .ScaleMode = 3
        If F1MDF = 0 And F1RF = 0 Then
            .BackColor = BackColours
        End If
    End With

    With Form1.Picture3 'Sequence names
        
        .ScaleMode = 3
        
        .Height = Form1.Picture8.Height
        .MousePointer = 0
        .CurrentX = 0
        .CurrentY = 0
        If F1MDF = 0 And F1RF = 0 And DontPrintNames = 0 Then
            .Picture = LoadPicture()
            .BackColor = BackColours
        End If
        .ForeColor = 0
        .AutoRedraw = True
        .Enabled = True
        .FontSize = 7 * TYF
    End With
    If F1MDF = 0 And F1RF = 0 Then
        Form1.Label21.Caption = "Show All Sequences"
        ReDim Preserve MaskSeq(NextNo)
    End If
    Form1.Picture3.ScaleMode = 3
    
   
    tTYF = Form1.Picture3.FontSize / 6.75
    

        
      '  If Form1.Picture3.FontSize = 9.75 Then
      '      tTYF = tTYF * 1 '0.999
      '      TYFM = 2
      '  ElseIf Form1.Picture3.FontSize = 9# Then
      '      tTYF = tTYF * 0.947
      '      TYFM = 2
      '  ElseIf Form1.Picture3.FontSize = 8.25 Then
      '      tTYF = tTYF * 1.033
      '      TYFM = 2
      '  ElseIf Form1.Picture3.FontSize = 7.5 Then
      '      tTYF = tTYF * 0.975
      '      TYFM = 1
      '  ElseIf Form1.Picture3.FontSize = 6.75 Then
      '      tTYF = tTYF * 0.903
      '      TYFM = 3
      '  ElseIf Form1.Picture3.FontSize = 6# Then
      '      tTYF = tTYF * 1.014
      '      TYFM = -1
      '  ElseIf Form1.Picture3.FontSize = 5.25 Then
      '      tTYF = tTYF * 0.928
      '      TYFM = 1
       ' ElseIf Form1.Picture3.FontSize = 4.5 Then
       '     tTYF = tTYF * 1.081
      '      TYFM = -1
      '  ElseIf Form1.Picture3.FontSize = 3.75 Then
      '      tTYF = tTYF * 0.974
      '      TYFM = 0
      '  End If
     
    If DontPrintNames = 0 Then
        If ShowSeqFlag = 0 Then
            Call PrintNames
        Else
            Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
        End If
    End If
    '0.016
    'Form1.Refresh

    
    If F1MDF = 0 And F1RF = 0 Then
        With Form1.Picture4 'Homology display
            .Picture = LoadPicture()
            .Refresh
        End With
    End If
    Form1.Picture5.ScaleMode = 3
    If F1MDF = 0 And F1RF = 0 Then
        Form1.Picture5.BackColor = Bak
    End If
    With Form1.Picture6 'Unique sequence schematic sequence display
        .ScaleMode = 3
        .ScaleHeight = Form1.Picture5.Height
        If F1MDF = 0 And F1RF = 0 Then
            .Picture = LoadPicture()
            .BackColor = Bak
        End If
    End With
     
    
    With Form1.Picture7 'Plot display (inner)
        OSM = Form1.Picture10.ScaleMode
        Form1.Picture10.ScaleMode = 1
        If ORFFlag = 0 Then
            .Height = Form1.Picture10.ScaleHeight
            .Top = -1
        Else
            .Height = Form1.Picture10.ScaleHeight - Form1.Picture20.Height + 5
            .Top = Form1.Picture20.Height - 5 * Screen.TwipsPerPixelY
                
        End If
        Form1.Picture10.ScaleMode = OSM
        
        
        If F1MDF = 0 And F1RF = 0 Then
            .Enabled = False
            .Picture = LoadPicture()
            .BackColor = Bak
        End If
    End With
    
    If F1MDF = 0 And F1RF = 0 Then
        Form1.Picture9.BackColor = BackColours
    End If
    Form1.Picture10.ForeColor = 0

    With Form1.Picture10 'Plot display (outer)
        
        If F1MDF = 0 And F1RF = 0 Then
            .Picture = LoadPicture()
            .BackColor = Bak
        End If
    End With

    

    With Form1.Picture11 'Homology display
        
        If F1MDF = 0 And F1RF = 0 Then
            .Picture = LoadPicture()
            .BackColor = Rejected
        End If
        
    End With
    If F1MDF = 0 And F1RF = 0 Then
        Form1.Picture12.BackColor = BackColours
        'Form1.Picture13.BackColor = BackColours
        Form1.Picture13.ForeColor = 0
    End If

    With Form1.Picture14
        .ScaleMode = 3
        If F1MDF = 0 And F1RF = 0 Then
            .BackColor = BackColours
        End If
    End With

    Form1.Picture16.ScaleMode = 3

    With Form1.Picture16 'Tree display
        If F1MDF = 0 And F1RF = 0 Then
            .Picture = LoadPicture()
            .BackColor = Bak
        End If
        .ScaleMode = 3
        'Tempsize = (Nextno + 12) * 14

        'If Tempsize < 32767 Then
        '    .Height = (Nextno + 12) * 14
        'Else
        '    .Height = 32767
        'End If

        'TRegion = 0.8 * .Width
    End With
    
    If -Form1.Picture16.ScaleHeight + (NextNo + 10) * 14 * TYF2 > 16000 Then
        ScrollSF = 16000 / (-Form1.Picture16.ScaleHeight + (NextNo + 10) * 14 * TYF2)
    Else
        ScrollSF = 1
    End If
    
   
   
    '''''''''''''''''''''''''''''0.0000
    'XX = Form1.VScroll1.Value
    If Form1.Picture16.ScaleHeight < ((NextNo + 6) * 15 * TYF2) Then
        OV = VSC1NC
        VSC1NC = 1
        Form1.VScroll1.Max = (-Form1.Picture16.ScaleHeight + (NextNo + 10) * 14 * TYF2) * ScrollSF
        'VSMax = -Form1.Picture16.ScaleHeight + ((TreeDraw(TreeTypeFlag, CTF, 1, 1, TDLen(TreeTypeFlag, CTF, 1)) + 1) * otTYF) + 200
        If Form1.VScroll1.Value < Form1.VScroll1.Max Then
            Form1.VScroll1.Value = Form1.VScroll1.Value + 1
            VSC1NC = OV
            Form1.VScroll1.Value = Form1.VScroll1.Value - 1
        Else
            Form1.VScroll1.Value = Form1.VScroll1.Value - 1
            VSC1NC = OV
            Form1.VScroll1.Value = Form1.VScroll1.Value + 1
        End If
        Form1.VScroll1.SmallChange = 5
        Form1.VScroll1.LargeChange = Form1.Picture16.ScaleHeight
        Form1.VScroll1.Enabled = True
    Else
        If Form1.VScroll1.Value <> 0 Then
            Form1.VScroll1.Value = 0
        End If
        Form1.VScroll1.Enabled = False
    End If

    '''''''''''''''''''''''''''''''''''0.047,0.063
     'XX = OriginalName(1)
    For Index = 0 To 3

        With Form2.VScroll1(Index)
            VSMax = .Max
            If VSMax <= 0 Then .Value = 0
            OV = .Value
            OM = VSMax
            OVx = OV / OM
            
            Call ModOffsets(8.25, Form1.Picture16, otTYF, TYFM)
            If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBound(TreeDraw, 5) Then
                VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200
            ElseIf TDLen(0, 1, 1) <= UBound(TreeDraw, 5) Then
                VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
            End If
            If OM = 0 Then OM = 1
            If VSMax > 32000 Then
                F2VSScaleFactor(Index) = VSMax / 32000
                VSMax = 32000
            Else
                F2VSScaleFactor(Index) = 1
            End If
            
            
            If VSMax > 0 Then
                .Max = VSMax
                If (.Value / (OM / VSMax)) < VSMax Then
                    .Value = OVx * VSMax
                ElseIf VSMax > 0 Then
                    .Value = VSMax
                End If
                If .Value > VSMax Then
                 .Value = VSMax
                End If
                If VSMax <= 0 Then
                    .Enabled = False
                Else
                    .LargeChange = Form2.Picture2(Index).ScaleHeight
                    .Enabled = True
                End If
            End If
            '.Max = VSMax
        End With

    Next 'X

 'XX = OriginalName(1)

''''''''''''''''''''''''''''''''''0.062,0.062
    If F1MDF = 0 And F1RF = 0 Then
        Form1.Picture19.Picture = LoadPicture() 'Hidden ORF picture
        Form1.Picture19.BackColor = BackColours
    End If
    With Form1.Picture20 'ORF picture
        If F1MDF = 0 And F1RF = 0 Then
            .Picture = LoadPicture()
            .Visible = False
            .BackColor = BackColours
        End If
    End With

    With Form1.Picture21 'Background plot picture
        .AutoRedraw = True
        .ScaleMode = 1
        .AutoSize = False
        
        OP10SM = Form1.Picture10.ScaleMode
        Form1.Picture10.ScaleMode = 1
        .ScaleWidth = Form1.Picture10.ScaleWidth
        .ScaleHeight = Form1.Picture10.ScaleHeight + 25
        .Visible = False
        If F1MDF = 0 And F1RF = 0 Then
            .BackColor = BackColours
        End If
        Form1.Picture10.ScaleMode = OP10SM
        .ScaleMode = 3
    End With

    
    If RETFlag < 3 Then
        If F1MDF = 0 And F1RF = 0 Then
            Form1.Picture26.Picture = LoadPicture() 'Small compatibility matrix window
        End If
    End If

    For x = 0 To 3
        Form2.Picture2(x).ScaleMode = 3
    Next 'X
    'StartX = X
    'NumSeqLines = X
    Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
    Call CalcttyfAdjust(TYFM, tTYF, 0, 0)
    P1OH = (((NextNo + 2) * 13) - TYFM) * tTYF * ttyfAdjust
    
    P3OH = P1OH
    
    'If F1MDF = 0 Then
    
    With Form1.VScroll3 'Sequence display scrollbar
        'Form1.VScroll3.Visible = False
        
        TestMax = -Form1.Picture9.ScaleHeight + P1OH
        'If F1MDF = 0 Then
           ' .Max = -Form1.Picture9.ScaleHeight + Form1.Picture1.Height
        'End If
        'Form1.VScroll3.Visible = True
        If TestMax <= 0 Then
            .Enabled = False
        Else
            If TestMax < 32000 Then
            
            
                .Max = TestMax
                ScrollSF = 1
            Else
                .Max = 32000
                ScrollSF = 32000 / TestMax
            End If
            If Form1.Picture9.ScaleHeight > 0 Then
                .LargeChange = Form1.Picture9.ScaleHeight
            End If
            'If F1MDF = 0 Then
                .Enabled = True
            'End If
        End If

    End With
   ' End If
   
   
   '''''''''''''''''''''''''''''''0.062,0.062
    With Form1.SSPanel16
        
        If F1MDF = 0 And F1RF = 0 Then
            .Caption = ""
            .BackColor = HalfColour
        End If
    End With
    If F1MDF = 0 And F1RF = 0 Then
        With Form1.Combo1
            .Clear
            
            .BackColor = Bak
            .ForeColor = 0
            .Enabled = False
        End With
    End If
    If F1MDF = 0 And F1RF = 0 Then
        ShowSeqFlag = 0
        If CLng(Len(StrainSeq(0)) / 100) < 32000 Then
            FullWindowSize = CLng(Len(StrainSeq(0)) / 100)
        Else
            FullWindowSize = 32000
        End If
        
    End If
    'Enable Command Buttons

    If F1MDF = 0 And F1RF = 0 Then
        With Form1.Command22
            .Enabled = True            'Enable "X-Over" button
            .Left = 175 * Screen.TwipsPerPixelX
            .Width = 70 * Screen.TwipsPerPixelX
        End With
        
        With Form1.Command33(0)
            .Enabled = True            'Enable "-" button
        End With
        With Form1.Command33(1)
            .Enabled = True            'Enable "+" button
        End With
       
        
        Form1.Command33(2).Enabled = True
        Form1.Command33(3).Enabled = True
        Form1.Command2(2).Visible = True
    
        With Form1.Command7
            .Enabled = True              'Enable "Draw Tree" button
            .Width = 70 * Screen.TwipsPerPixelX
        End With
        With Form1.Command38
            .Enabled = True              'Enable "Draw Tree" button
            .Width = 70 * Screen.TwipsPerPixelX
        End With
        
        If F1MDF = 0 And F1RF = 0 Then
            Form1.Command2(3).Visible = True
            Form1.Command2(4).Visible = True
            For ZZ = 0 To 2
                 'Enable "Show UPGMA Tree " buttons
                Form1.Command13(ZZ).Enabled = True
                'Enable "Show Recombination Info" buttons
                Form1.Command8(ZZ).Enabled = True
                'Enable "Show  Matrix" buttons
                Form1.Command4(ZZ).Enabled = True
            Next ZZ
            'DIsable command buttons
            Form1.Command6(3).Enabled = False
            Form1.Command17.Enabled = False
            
          
            If SEventNumber = 0 Then
                Form1.Command6(2).Enabled = False
                Form1.Command5.Enabled = False
                Form1.Command9.Enabled = False
            End If
            Form1.Command10.Enabled = False
            Form1.Command6(0).Enabled = False
            Form1.Frame17.Visible = False
        
            With Form1.Command18
                .Enabled = False             'Disable "save" button
                .Width = 85 * Screen.TwipsPerPixelX
            End With
        
            Form1.Command2(1).Visible = False
            'Close forms
            Form2.Visible = False
            'Enable/disable Panels
            Form1.SSPanel4.Enabled = True
            Form1.SSPanel5.Enabled = False
            Form1.SSPanel3.Enabled = True
            Form1.SSPanel4.Enabled = True
            Form1.SSPanel5.Enabled = True
        
            Form1.SSPanel6(0).Enabled = True
            Form1.SSPanel6(0).Visible = True
            Form1.SSPanel6(1).Visible = False
            Form1.SSPanel6(2).Visible = False
        End If
        Form1.SSPanel8.Enabled = True
    
        If RunFlag = 0 Then
            If SEventNumber = 0 Then
                Form1.Label58.Caption = ""
            End If
             Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
            Form1.Frame7.Enabled = False
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel5.Enabled = False
            Form1.HScroll2.Enabled = False
            Form1.VScroll2.Enabled = False
        End If
    End If
    If F1MDF = 0 And F1RF = 0 Then
        Form1.VScroll2.SmallChange = 13
    End If
    If PFName <> "LastSave.rdp5" Then
        Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor)) + ":  " + PFName
   
    Else
        Form1.Caption = "Recombination Detection Program v." & Trim(CStr(App.Major)) & "." & Trim(CStr(App.Minor))
    End If
    
    If DatasetName <> "" Then
        Form1.Caption = Form1.Caption + DatasetName
    End If

    If F1MDF = 0 And F1RF = 0 Then
        ReDim SYPos(NextNo)
        ReDim UYPos(NextNo)
        ReDim Selected(NextNo)
        With Form5.Combo1
            .AddItem "None", 0
    
            For x = 0 To PermNextno
                .AddItem OriginalName(x), x + 1
                
            Next 'X
    
        End With
    End If
    
    
    
'''''''''''''''''''''''''0.047, 0.046
    
    If F1MDF = 0 And F1RF = 0 Then
        For x = 0 To 3
            Form2.Picture2(x).BackColor = BackColours
        Next 'X
        For x = 0 To 3
            For Y = 0 To 3
                DoneTree(x, Y) = 0
            Next Y
        Next 'X
    End If
    
    If F1MDF = 0 And F1RF = 0 Then
        Form5.Combo1.ListIndex = 0
        Form5.Picture1.Height = NextNo * 13 * Screen.TwipsPerPixelY
        Form5.Picture2.Height = NextNo * 13 * Screen.TwipsPerPixelY
    End If
    
    
 '''''''''''''''''''''''''''0.062, 0.062
    
    Form1.Timer1.Enabled = OTVal
    'Form1.Refresh
    
    'XX = tTYF
End Sub
Public Sub LoadAlignX()

    Dim TempString As String
    Dim LastPos As Long, PosN As Long, Pos2 As Long, Pos3 As Long

    Form1.SSPanel1.Caption = "Loading AligntX File"
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, TempString

    If Len(TempString) > LOF(NF) * 0.5 Then
        Close #NF
        LastPos = 1

        Do
            Pos = InStr(LastPos, TempString, "obj|I", vbBinaryCompare)

            If Pos > 0 Then
                Mid$(TempString, Pos, 1) = Chr$(13)
                LastPos = Pos + 2
            Else
                Exit Do
            End If

        Loop

        Open "tempfile" For Output As #NF
        SaveFlag = 1
        Print #NF, TempString
        Close #NF
        Open "tempfile" For Input Access Read As #NF
    Else
        Close #NF
        Open FName$ For Input Access Read As #NF
    End If

    NextNo = -1
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog

    Do While Not EOF(NF)
        Line Input #NF, TempString
        PosN = InStr(1, TempString, "IxAlignment", vbBinaryCompare)

        If PosN > 0 Then
            NextNo = NextNo + 1

            Call SeqArrays

            Pos2 = InStr(PosN + 11, TempString, ":", vbBinaryCompare)
            Pos3 = InStr(Pos2, TempString, "|", vbBinaryCompare)
            StrainSeq(NextNo) = Mid$(TempString, Pos2 + 1, Pos3 - 1 - Pos2)
            OriginalName(NextNo) = Mid$(TempString, Pos3 + 1, Len(TempString) - Pos3)
        End If

    Loop

    Close #NF
End Sub
Public Sub LoadFormatX()

    Dim TempString As String

    Open FName$ For Input Access Read As #1
    Form1.SSPanel1.Caption = "Loading Mega File"
    NextNo = -1
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog

    Do While Not EOF(1)
        Input #1, TempString

        If Mid$(TempString, 1, 4) = "name" Then
            NextNo = NextNo + 1

            Call SeqArrays

            Form1.ProgressBar1.Value = 1 + ((Len(StrainSeq(0)) * NextNo) / LOF(1)) * 100 * 0.3
            Call UpdateF2Prog
            OriginalName(NextNo) = Mid$(TempString, 7, Len(TempString) - 7)
        ElseIf Mid$(TempString, 1, 8) = "sequence" And Mid$(TempString, 1, 9) <> "sequence-" Then

            Do
                Input #1, TempString

                If Mid$(TempString, 1, 1) = "}" Then Exit Do
                StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
            Loop

            StrainSeq(NextNo) = Mid$(StrainSeq(NextNo), 1, Len(StrainSeq(NextNo)) - 1)
            posseqa = InStr(1, StrainSeq(NextNo), "a", vbBinaryCompare)
            posseqb = InStr(1, StrainSeq(NextNo), "A", vbBinaryCompare)

            If posseqa = 0 And posseqb = 0 Then
                StrainSeq(NextNo) = ""
                NextNo = NextNo - 1
            End If

        End If

        If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
    Loop

    Close #1
End Sub
Public Sub LoadMugsy()

    Dim TempString As String, TempString2 As String, FileLength As Long, LastPos As Long, Pos2 As Long, LNextno As Long

    Form1.SSPanel1.Caption = "Loading Mugsy File"
    
    NextNo = -1
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
    Open FName$ For Input Access Read As #1
    FileLength = LOF(1)
    If FileLength > 100000000 Then
        BigFileFlag = 1
    Else
        BigFileFlag = 0
    End If
    Close #1
    
    
    If BigFileFlag = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        Open "SequencesForSaving" + UFTag For Binary As #2
        'ODirX = CurDir
        ChDrive oDirX
        ChDir oDirX
    End If
    If FileLength < 10000000 And x = 12345 Then
        Open FName$ For Input Access Read As #1
        Do While Not EOF(1)
        
            Input #1, TempString
    
            If Len(TempString) > LOF(1) * 0.5 Then
               
                Call ReformatFile(1, TempString, SaveFlag)
                Form1.SSPanel1.Caption = "Loading GDE File"
                'GoTo Specialcase  'ie if no carriage returns are used you're screwed buddy
            End If
    
            If Mid$(TempString, 1, 1) = "#" Then
                NextNo = NextNo + 1
    
                Call SeqArrays
    
                Form1.ProgressBar1.Value = 1 + ((Len(StrainSeq(0)) * NextNo) / FileLength) * 100 * 0.3
                Call UpdateF2Prog
                OriginalName(NextNo) = Mid$(TempString, 2, Len(TempString) - 1)
            Else
                StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                'B = Len(StrainSeq(10))
            End If
    
            If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
        Loop
    Else
        'open up 10Megs at a time
        Open FName$ For Binary Access Read As #1
        Do
            TempString = String(10000000, " ")
            
            Get #1, , TempString
'            Close #1
'            Open "testout" For Binary Access Write As #1
'            Put #1, , TempString
'            Close #1
            LastPos = 0
            Do
                Pos = InStr(LastPos + 1, TempString, "s ", vbBinaryCompare)
                If Pos > 0 And (Pos - LastPos) < 200 Then
                    LastPos = Pos
                    NextNo = NextNo + 1
                    Call SeqArrays
                    Pos = InStr(LastPos + 3, TempString, " ", vbBinaryCompare)
                    If Pos > 0 Then
                        TempString2 = Mid$(TempString, LastPos + 2, Pos - LastPos - 2)
                        OriginalName(NextNo) = TempString2
                        LastPos = Pos + 2
                    Else
                        OriginalName(NextNo) = Mid$(TempString, LastPos + 2, Len(TempString) - LastPos + 2)
                        Exit Do
                    End If
                    Pos = Pos + 1
                    x = x
                    'scan till there are no close spaces
                    TempString2 = Mid$(TempString, LastPos, 100)
                    
                    LastPos = 0
                    Do
                        Pos2 = InStr(LastPos + 1, TempString2, " ", vbBinaryCompare)
                        If Pos2 = 0 Then Exit Do
                        LastPos = Pos2
                    Loop
                    LastPos = LastPos + Pos
                   
                    Pos = InStr(LastPos + 2, TempString, " ", vbBinaryCompare)
                    If Pos > 0 Then
                        
                        StrainSeq(NextNo) = Mid$(TempString, LastPos + 1, Pos - LastPos - 2)
                        LastPos = Pos + 1
                        'XX = Right(StrainSeq(Nextno), 10)
                        x = x
                    Else
                        TempString2 = String(Len(StrainSeq(NextNo)) + Len(TempString) - LastPos, " ")
                        
                        Mid(TempString2, 1, Len(StrainSeq(NextNo))) = StrainSeq(NextNo)
                        'XX = Mid$(TempString2, Len(StrainSeq(Nextno)) - 5, 10)
                        Mid(TempString2, Len(StrainSeq(NextNo)) + 1, Len(TempString) - LastPos) = Mid(TempString, LastPos + 1, Len(TempString) - LastPos)
                        StrainSeq(NextNo) = Trim(TempString2)
                        Pos2 = InStr(1, StrainSeq(NextNo), " ", vbBinaryCompare)
                        If Pos2 > 0 Then
                            StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                        End If
                        Pos2 = InStr(1, StrainSeq(NextNo), Chr(0), vbBinaryCompare)
                        If Pos2 > 0 Then
                            StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                        End If
                        XX = Right(StrainSeq(NextNo), 10)
                        XX = Len(StrainSeq(NextNo))
                        'X = X
                        Exit Do
                    End If
                Else
                    
                    Pos = InStr(LastPos + 1, TempString, " ", vbBinaryCompare)
                    If Pos > 0 And Pos - LastPos < 200 Then
                        TempString2 = Mid$(TempString, LastPos + 2, Pos - LastPos - 2)
                        OriginalName(NextNo) = OriginalName(NextNo) + Mid$(TempString, LastPos + 2, Pos - LastPos)
                        TempString2 = Mid$(TempString, LastPos, 100)
                    
                         LastPos = 0
                         Do
                             Pos2 = InStr(LastPos + 1, TempString2, " ", vbBinaryCompare)
                             If Pos2 = 0 Then Exit Do
                             LastPos = Pos2
                         Loop
                         LastPos = LastPos + Pos
                        
                         Pos = InStr(LastPos + 2, TempString, " ", vbBinaryCompare)
                         If Pos > 0 Then
                            StrainSeq(NextNo) = Mid$(TempString, LastPos + 1, Pos - LastPos - 2)
                            LastPos = Pos + 1
                         Else
                             TempString2 = String(Len(StrainSeq(NextNo)) + Len(TempString) - LastPos, " ")
                            Mid(TempString2, 1, Len(StrainSeq(NextNo))) = StrainSeq(NextNo)
                            Mid(TempString2, Len(StrainSeq(NextNo)) + 1, Len(TempString) - LastPos) = Mid(TempString, LastPos + 1, Len(TempString) - LastPos)
                            StrainSeq(NextNo) = Trim(TempString2)
                            Pos2 = InStr(1, StrainSeq(NextNo), " ", vbBinaryCompare)
                            If Pos2 > 0 Then
                                StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                            End If
                            Pos2 = InStr(1, StrainSeq(NextNo), Chr(0), vbBinaryCompare)
                            If Pos2 > 0 Then
                                StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                            End If
                            Exit Do
                         End If
                    ElseIf Pos = 0 Then
                        'if eo
                        If LastPos = 0 Then Exit Do
                        OriginalName(NextNo) = Mid$(TempString, LastPos + 2, Len(TempString) - LastPos + 2)
                       
                    ElseIf Pos - LastPos > 200 Then
                        TempString2 = String(Len(StrainSeq(NextNo)) + Pos - 2, " ")
                        XX = Len(TempString2)
                        XX = Len(StrainSeq(0))
                        Mid(TempString2, 1, Len(StrainSeq(NextNo))) = StrainSeq(NextNo)
                        Mid(TempString2, Len(StrainSeq(NextNo)) + 1, Pos - 2) = Mid(TempString, LastPos + 1, Pos - 2)
                        StrainSeq(NextNo) = TempString2
                        Pos2 = InStr(1, StrainSeq(NextNo), " ", vbBinaryCompare)
                        If Pos2 > 0 Then
                            StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                        End If
                        Pos2 = InStr(1, StrainSeq(NextNo), Chr(0), vbBinaryCompare)
                        If Pos2 > 0 Then
                            StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                        End If
                        LastPos = Pos + 1
                        'Exit Do
                    Else
                        TempString2 = String(Len(StrainSeq(NextNo)) + Len(TempString) - LastPos, " ")
                        Mid(TempString2, 1, Len(StrainSeq(NextNo))) = StrainSeq(NextNo)
                        Mid(TempString2, Len(StrainSeq(NextNo)) + 1, Len(TempString) - LastPos) = Mid(TempString, LastPos + 1, Len(TempString) - LastPos)
                        StrainSeq(NextNo) = Trim(TempString2)
                        Pos2 = InStr(1, StrainSeq(NextNo), " ", vbBinaryCompare)
                        If Pos2 > 0 Then
                            StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                        End If
                        Pos2 = InStr(1, StrainSeq(NextNo), Chr(0), vbBinaryCompare)
                        If Pos2 > 0 Then
                            StrainSeq(NextNo) = Left(StrainSeq(NextNo), Pos2 - 1)
                        End If

                        Exit Do
                    End If
                    
                   
                End If
                
            Loop
            If EOF(1) Then Exit Do
            'reformat if necessary
            Form1.SSPanel1.Caption = Str(NextNo + 1) + " sequences loaded"
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            If BigFileFlag = 1 Then
                'dump sequences to the disk
                If NextNo - LastNextNo > 1 Then
                    For x = LastNextNo To NextNo - 1
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        Put #2, , StrainSeq(x)
                        
                        ChDrive oDirX
                        ChDir oDirX
                        If x > 0 Then
                            StrainSeq(x) = ""
                        End If
                    Next x
                    LastNextNo = NextNo
                End If
                
            End If
        Loop
        Close #1
        If BigFileFlag = 1 Then
            For x = LastNextNo To NextNo
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Put #2, , StrainSeq(x)
                
                ChDrive oDirX
                ChDir oDirX
                If x > 0 Then
                    StrainSeq(x) = ""
                End If
            Next x
            Close #2
        End If
    End If
    x = x
End Sub
Public Sub LoadGDE()

    Dim TempString As String, TempString2 As String, FileLength As Long, LastPos As Long

    Form1.SSPanel1.Caption = "Loading GDE File"
    
    NextNo = -1
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
    FF = FreeFile
    Open FName$ For Input As #FF
    FileLength = LOF(FF)
    Close #FF
    If FileLength < 10000000 Then
        Open FName$ For Input Access Read As #1
        Do While Not EOF(1)
        
            Input #1, TempString
    
            If Len(TempString) > LOF(1) * 0.5 Then
               
                Call ReformatFile(1, TempString, SaveFlag)
                Form1.SSPanel1.Caption = "Loading GDE File"
                'GoTo Specialcase  'ie if no carriage returns are used you're screwed buddy
            End If
    
            If Mid$(TempString, 1, 1) = "#" Then
                NextNo = NextNo + 1
    
                Call SeqArrays
    
                Form1.ProgressBar1.Value = 1 + ((Len(StrainSeq(0)) * NextNo) / FileLength) * 100 * 0.3
                Call UpdateF2Prog
                OriginalName(NextNo) = Mid$(TempString, 2, Len(TempString) - 1)
            Else
                StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                'B = Len(StrainSeq(10))
            End If
    
            If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
        Loop
    Else
        'open up 10Megs at a time
        Open FName$ For Binary Access Read As #1
        Do
            TempString = String(10000000, " ")
            
            Get #1, , TempString
            LastPos = 0
            Do
                Pos = InStr(LastPos + 1, TempString, "#", vbBinaryCompare)
                If Pos > 0 Then
                    LastPos = Pos
                    NextNo = NextNo + 1
                    Call SeqArrays
                Else
                    TempString2 = String(Len(StrainSeq(NextNo)) + Len(TempString) - LastPos, " ")
                    Mid(TempString2, 1, Len(StrainSeq(NextNo))) = StrainSeq(NextNo)
                    Mid(TempString2, Len(StrainSeq(NextNo)) + 1, Len(TempString) - LastPos) = Mid(TempString, LastPos + 1, Len(TempString) - LastPos)
                    StrainSeq(NextNo) = TempString2
                End If
                
                
            Loop
            'reformat if necessary
        
        Loop
        Close #1
    End If
    
End Sub
Public Sub LoadMeg()

    Dim TempString As String, FileLength As Long, LastPos As Long

    
    
    'check to see if reformatting is necessary
    Dim Fname2 As String
    Fname2 = "tempfile"
    Call Checkformat(FName$, Fname2)
    
    Open Fname2 For Input Access Read As #1
    Form1.SSPanel1.Caption = "Loading GDE File"
    
    
    NextNo = -1
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
    FileLength = LOF(1)

ilflag = 0
    SS = Abs(GetTickCount)
    Do While Not EOF(1)
        
        
        
        Line Input #1, TempString

        If Len(TempString) > LOF(1) * 0.5 Then
            
            Call ReformatFile(1, TempString, SaveFlag)
    
            'GoTo Specialcase  'ie if no carriage returns are used you're screwed buddy
        End If
        
        If TempString <> "#mega" And TempString <> "#MEGA" Then
            If Mid$(TempString, 1, 1) = "#" Then
                oNextno = NextNo
                NextNo = NextNo + 1
                Call SeqArrays
                If Len(TempString) <= 14 Then
                    If OriginalName(NextNo) = "" Then
                        EE = Abs(GetTickCount)
                        If Abs(EE - SS) > 500 Then
                            
                            Form1.ProgressBar1.Value = (1 + ((Len(StrainSeq(0)) * NextNo) / FileLength) * 100 * 0.9)
                            Call UpdateF2Prog
                            Form1.Refresh
                        End If
                        OriginalName(NextNo) = Mid$(TempString, 2, Len(TempString) - 1)
                        
                    End If
                Else
                    If OriginalName(NextNo) = "" Then
                        OriginalName(NextNo) = Trim$(Mid$(TempString, 2, 14))
                    End If
                    If Len(TempString) > 15 Then
                        GoOn = 0
                        Z = 0
                        For x = 15 To Len(TempString)
                            Z = Z + 1
                            If Z > 4 Then Exit For
                            If Mid$(TempString, x, 1) <> "-" And Mid$(TempString, x, 1) <> "A" And Mid$(TempString, x, 1) <> "C" And Mid$(TempString, x, 1) <> "G" And Mid$(TempString, x, 1) <> "T" Then
                                GoOn = GoOn + 1
                            End If
                        Next x
                        
                        If GoOn = 0 Then
                            StrainSeq(NextNo) = StrainSeq(NextNo) + Trim$(Mid$(TempString, 15, Len(TempString) - 15))
                        End If
                    End If
                End If
            ElseIf NextNo > -1 And TempString = "" And ilflag = 1 Then
                oNextno = NextNo
                NextNo = -1
            ElseIf NextNo > -1 Then
                StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                XX = Len(StrainSeq(NextNo))
                'B = Len(StrainSeq(10))
            End If
        
        End If
        If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
    Loop
    Form1.ProgressBar1.Value = 100 '(1 + ((Len(StrainSeq(0)) * Nextno) / FileLength) * 100 * 0.3)
    Form1.Refresh
    Call UpdateF2Prog
    XX = UBound(StrainSeq)
    If ilflag = 1 Then NextNo = oNextno
    Close #1
End Sub
Public Sub LoadPhylip()

    Dim NF As Integer, NoSpaceInFileFlag As Integer, NoSpaceBetweenGroupsFlag As Integer, SequentialFlag As Integer, SpaceInFileFlag As Integer, IsSeq As Integer
    Dim LastPos As Long, PosN1 As Long, x As Long, Y As Long
    Dim TempString As String, NameCheck As String
    Dim OTS As String
    'On Error GoTo UnknownFormat
    Form1.SSPanel1.Caption = "Loading Phylip File"
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    OTS = ""
    LF = LOF(NF)
    GoOn = 0
    If LF < 100000 Then
        If DebuggingFlag < 2 Then On Error Resume Next
        Line Input #NF, TempString
        On Error GoTo 0
    
    ElseIf LF < 500000000 Then
        'if the file is very big automatically just reformat it
        Close #NF
        
        Open FName$ For Binary As #NF
        TempString = String(LOF(NF), " ")
        XX = LOF(NF)
        
        Get #NF, , TempString
        'OTS = String(100000000, " ")
        XX = LOF(NF)
        OTS = String(LF, " ")
        
        If DebuggingFlag < 2 Then On Error Resume Next
        OTS = TempString
        On Error GoTo 0
        If Len(OTS) < Len(TempString) Then
            x = x
        End If
    Else
        GoOn = 1
        
    End If
    
    
    If Len(TempString) > LOF(NF) * 0.5 Or GoOn = 1 Then
        Call ReformatFile(NF, TempString, SaveFlag)
        NoSpaceBetweenGroupsFlag = 1
    Else
        Close #NF
        Open FName$ For Input Access Read As #NF
        On Error GoTo UnknownFormat
        Line Input #NF, TempString
        On Error GoTo 0
    End If
    
    NextNo = -1
    SequentialFlag = 0
    SpaceInFileFlag = 0
    
    
    Dim tNextno As Long
    
    Dim Z As Long
    
    Z = 1
    Do While Z < Len(TempString)
        If Mid(TempString, Z, 1) <> " " Then
            Exit Do
        End If
        Z = Z + 1
    Loop
    Pos = InStr(Z, TempString, " ", vbBinaryCompare)
    If Pos = 0 Then
        Pos = InStr(Z, TempString, Chr(9), vbBinaryCompare)
        x = x
    End If
    If Pos = 0 Then Exit Sub
    On Error Resume Next
    tNextno = CLng(Trim(Left$(TempString, Pos)))
    If tNextno = 0 Then
        'there is likely no sequence number and length information in the file
        'Nextno = -1
        Do While Not EOF(NF)
            NextNo = NextNo + 1
            Call SeqArrays
            OriginalName(NextNo) = Trim(Left$(TempString, Pos))
            StrainSeq(NextNo) = Trim(Right$(TempString, Len(TempString) - Pos))
            Line Input #NF, TempString
            Pos = InStr(1, TempString, " ", vbBinaryCompare)
        Loop
        Close NF
        Exit Sub
    End If
    Dim ExpectLen As Long
    ExpectLen = Right(TempString, Len(TempString) - Pos)
    x = x
    On Error GoTo 0
    
    
    'find the biggest line length
    Dim LOTS As Long
    LastPos = 0
    If Len(OTS) > 0 Then 'this only happens if the file is very big
        Do
            Pos = InStr(LastPos + 1, OTS, Chr(10), vbBinaryCompare)
            If Pos > 0 Then
                If Pos - LastPos > LOTS Then
                    LOTS = Pos - LastPos
                End If
                LastPos = Pos
            Else
                Exit Do
            End If
        Loop
        
        If LOTS > 100000 Then '(i.e. it is likely that sequence lines are >100K nts long then
        
        Else
            LOTS = 0 'the sequences are short can just be read normally
            OTS = ""
        End If
        'OTS = ""
     Else
        LOTS = 0
    End If
    
    Dim LastPosX As LogEventTypeConstants, PosX As Long
    LastPosX = 1: PosX = 0
    Do While Not EOF(NF)
        
        Form1.SSPanel1 = Trim(Str(NextNo + 1)) + " of " + Trim(Str(tNextno)) + " sequences loaded"
        If LOTS > 0 Then
            TempString = String(LOTS, " ")
            If PosX = 0 Then LastPosX = InStr(1, OTS, Chr(10), vbBinaryCompare) + 1
            PosX = InStr(LastPosX + 1, OTS, Chr(10), vbBinaryCompare)
            If PosX > 0 Then
                TempString = Mid$(OTS, LastPosX, PosX - LastPosX)
                XX = Left(TempString, 10)
                AA = Right(TempString, 10)
                
                LastPosX = PosX + 1
                x = x
            Else
                TempString = ""
            End If
            
        Else
            Line Input #NF, TempString
            Yy = Left(TempString, 10)
            BB = Right(TempString, 10)
            x = x
        End If
        If TempString = "Recombination Data" Or TempString = "GB Data" Then
            Exit Do
        End If

        If TempString <> Empty Then
            NextNo = NextNo + 1
            'If Nextno = 17 Then
            '    X = X
            'End If
            Call SeqArrays

            PosN1 = InStr(8, TempString, " ", vbBinaryCompare)
            'XX = Left(TempString, 10)
            If Left$(TempString, 10) = String(10, " ") Then
                NextNo = NextNo - 1

                If NoSpaceBetweenGroupsFlag = 1 Then Exit Do
            ElseIf PosN1 > 1 Then
                OriginalName(NextNo) = Trim$(Mid$(TempString, 1, PosN1 - 1))
                'X = X
            ElseIf Left$(TempString, 10) <> String(10, " ") Then
                NameCheck = Left$(TempString, 10)
                IsSeq = 0

                For x = 1 To 10

                    If Mid$(NameCheck, x, 1) = " " Or Mid$(NameCheck, x, 1) = "A" Or Mid$(NameCheck, x, 1) = "C" Or Mid$(NameCheck, x, 1) = "G" Or Mid$(NameCheck, x, 1) = "T" Or Mid$(NameCheck, x, 1) = "-" Or Mid$(NameCheck, x, 1) = "." Then
                        IsSeq = IsSeq + 1
                    End If

                Next 'X

                If IsSeq < 10 Then ' its a name!!!
                    OriginalName(NextNo) = Trim$(NameCheck)
                    SequentialFlag = 1
                Else
                    NextNo = NextNo - 1
                    StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                    Exit Do
                End If

            
            Else
                NoSpaceInFileFlag = 1
                NextNo = NextNo - 1
                Exit Do
            End If

            If TempString <> "" And Len(TempString) < 15 Then
                SequentialFlag = 1
                OriginalName(NextNo) = Trim$(TempString)
            ElseIf Mid$(TempString, 11 + 11, 1) = " " And SequentialFlag = 0 Then

                For Y = 0 To 4
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(TempString, 12 + Y * 10 + Y, 10)
                Next 'Y

                SpaceInFileFlag = 1
            Else
                TempString = Right$(TempString, Len(TempString) - Len(OriginalName(NextNo)))
                TempString = Trim$(TempString)
                StrainSeq(NextNo) = StrainSeq(NextNo) + TempString
                OriginalName(NextNo) = Trim$(OriginalName(NextNo))
            End If

        ElseIf NextNo = tNextno - 1 Then
            Exit Do
        End If

    Loop

    Dim NewNameFlag As Integer

    NewNameFlag = 0
    
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
    
    Dim GG As Long, HH As Long
    
    If Len(StrainSeq(0)) < ExpectLen Then
        '**************************************************
        'This bit is needed to speed up reading of large interleaved files
        
        
        Dim TempSX As String, WritePos() As Long
    
        ReDim WritePos(NextNo)
        For x = 0 To NextNo
            TempSX = StrainSeq(x)
            StrainSeq(x) = String(ExpectLen + ExpectLen * 0.2, " ")
            Mid(StrainSeq(x), 1, Len(TempSX)) = TempSX
            WritePos(x) = Len(TempSX) + 1
        Next x
        x = -1
        
        GG = 0
        '**************************************************
        Do While Not EOF(NF)
    
            If NoSpaceInFileFlag = 0 And NoSpaceBetweenGroupsFlag = 0 Then
                Input #NF, TempString
                'GG = GG + Len(TempString)
                'If HH > Loc(NF) Then
                'X = X
                'End If
                'HH = Loc(NF)
                'X = X
            Else
                NoSpaceInFileFlag = 0
                NoSpaceBetweenGroupsFlag = 0
            End If
    
            Pos = InStr(1, TempString, " ", vbBinaryCompare)
    
            If SequentialFlag = 1 Or (Len(TempString) < 11 And NextNo < 1) Then
                Pos = InStr(1, TempString, " ", vbBinaryCompare)
    
                If SequentialFlag = 0 Then
                    SequentialFlag = 1
                    NextNo = NextNo + 1
                    OriginalName(NextNo) = Trim$(TempString)
                ElseIf Pos > 0 Then
    
                    If NewNameFlag = 1 Then
    
                        If NextNo > 0 Then
                            Mid(StrainSeq(NextNo - 1), WritePos(NextNo - 1), Len(OriginalName(NextNo))) = OriginalName(NextNo)
                            WritePos(NextNo - 1) = WritePos(NextNo - 1) + Len(OriginalName(NextNo))
                        End If
    
                        OriginalName(NextNo) = Trim$(Right$(TempString, Len(TempString) - Pos))
                    Else
                        Mid(StrainSeq(NextNo), WritePos(NextNo), Len(Trim$(Left$(TempString, Pos)))) = Trim$(Left$(TempString, Pos))
                        WritePos(NextNo) = WritePos(NextNo) + Len(Trim$(Left$(TempString, Pos)))
                        NextNo = NextNo + 1
                        OriginalName(NextNo) = Trim$(Right$(TempString, Len(TempString) - Pos))
                        NewNameFlag = 1
                    End If
    
                ElseIf Len(TempString) < 11 And TempString > "" Then
    
                    If NewNameFlag = 1 Then
    
                        If NextNo > 0 Then
                            Mid(StrainSeq(NextNo - 1), WritePos(NextNo - 1), Len(OriginalName(NextNo))) = OriginalName(NextNo)
                            WritePos(NextNo - 1) = WritePos(NextNo - 1) + Len(OriginalName(NextNo))
                        End If
    
                        OriginalName(NextNo) = Trim$(Right$(TempString, Len(TempString) - Pos))
                    Else
                        'StrainSeq(Nextno) = StrainSeq(Nextno) + Trim$(Left$(TempString, Pos))
                        Mid(StrainSeq(NextNo), WritePos(NextNo), Len(Trim$(Left$(TempString, Pos)))) = Trim$(Left$(TempString, Pos))
                        WritePos(NextNo) = WritePos(NextNo) + Len(Trim$(Left$(TempString, Pos)))
                        NextNo = NextNo + 1
                        OriginalName(NextNo) = Trim$(Right$(TempString, Len(TempString) - Pos))
                        NewNameFlag = 1
                    End If
    
                Else
                    NewNameFlag = 0
                    If DebuggingFlag < 2 Then On Error Resume Next
                    UB = -1
                    UB = UBound(WritePos)
                    On Error GoTo 0
                    If UB = -1 Then Exit Sub
                    If UB < NextNo Then
                        ReDim Preserve WritePos(NextNo)
                    End If
                    If StrainSeq(NextNo) = "" Then
                        StrainSeq(NextNo) = String(ExpectLen + ExpectLen * 0.2, " ")
                    End If
                    If WritePos(NextNo) = 0 Then WritePos(NextNo) = 1
                    Mid(StrainSeq(NextNo), WritePos(NextNo), Len(Trim(TempString))) = Trim$(TempString)
                    WritePos(NextNo) = WritePos(NextNo) + Len(Trim(TempString))
                End If
    
            Else
                
    
                If TempString <> Empty Then
                    x = x + 1
                    If SpaceInFileFlag = 1 Then
                        TempString = Trim$(TempString)
    
                        For Y = 0 To 4
                            Mid(StrainSeq(x), WritePos(x), 10) = StrainSeq(x) + Mid$(TempString, 1 + Y * 10 + Y, 10)
                            WritePos(x) = WritePos(x) + 10
                        Next 'Y
    
                        If x = NextNo Then x = -1
                    Else
                        TempString = Trim$(TempString)
                        'StrainSeq(X) = StrainSeq(X) + TempString
                        If x > NextNo Then 'X = 0
                          ' XX = WritePos(1)
                          'XX = Loc(NF)
                          XX = WritePos(0)
                          x = x
                        Else
                            If WritePos(x) + Len(TempString) <= Len(StrainSeq(0)) Then
                                Mid(StrainSeq(x), WritePos(x), Len(TempString)) = TempString
                                WritePos(x) = WritePos(x) + Len(TempString)
                            End If
                        End If
                        If x = NextNo Then x = -1
                        SS = Abs(GetTickCount)
                        If Abs(SS - EE) > 2000 Then
                            EE = SS
                            Form1.SSPanel1.Caption = "Approximately " + Trim(Str(Loc(NF))) + " of " + Trim(Str(LOF(NF))) + " nucleotides loaded"
                        End If
                    End If
    
                Else
                    
                    SS = Abs(GetTickCount)
                        If Abs(SS - EE) > 2000 Then
                            EE = SS
                            Form1.SSPanel1.Caption = "Approximately " + Trim(Str(Loc(NF))) + " of " + Trim(Str(LOF(NF))) + " nucleotides loaded"
                            Form1.ProgressBar1.Value = 1 + (Loc(NF) / (LOF(NF) / 127)) * 30
                            Call UpdateF2Prog
                        End If
                    If x = NextNo Then
                        x = -1
                    End If
                End If
    
            End If
    
            If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
        Loop
    End If

    If StrainSeq(NextNo) = "" Then
        NextNo = NextNo - 1
        StrainSeq(NextNo) = StrainSeq(NextNo) + OriginalName(NextNo + 1)
    End If

    Close #NF
    For x = 0 To NextNo
        StrainSeq(x) = Trim(StrainSeq(x))
    Next x
    On Error GoTo 0
    'check to see if spaces have been included
    SLen = Len(StrainSeq(0))
    If Mid$(StrainSeq(0), 11, 1) = " " Then
        For Y = 0 To NextNo
            TempString = String(SLen, " ")
            CPos = 0
            For x = 2 To SLen
                Pos = InStr(x, StrainSeq(Y), " ", vbBinaryCompare)
                If Pos = 0 Then Exit For
                CPos = InStr(CPos + 1, TempString, " ")
                Mid(TempString, CPos, Pos - x + 1) = Mid$(StrainSeq(Y), x - 1, Pos - x + 1)
                x = Pos + 1
                LastPos = Pos
            Next 'X
            CPos = InStr(CPos + 1, TempString, " ")
            Mid(TempString, CPos, SLen - LastPos) = Trim$(Right$(StrainSeq(Y), SLen - LastPos))
            'TempString = TempString + Trim$(Right$(StrainSeq(Y), SLen - LastPos))
            StrainSeq(Y) = Trim(TempString)
        Next 'Y
    End If
    Exit Sub
UnknownFormat:
    '    MsgBox ("I could not recognise this DNA alignment file format" + chr$(13) + "Send it as an attatchment to darren@molbiol.uct.ac.za")
    ErrorFlag = 1
    Screen.MousePointer = 0
    'Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Close #NF
End Sub
Public Sub LoadMSF()

    Dim NF As Integer, SeqStart As Integer, CLen As Integer
    Dim LastStartPos As Long, StartPos As Long, LastPos As Long, CHK As Long, x As Long
    Dim TempString As String, CK As String

    NextNo = -1
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, TempString

    If Len(TempString) > LOF(NF) * 0.5 Then
        Call ReformatFile(NF, TempString, SaveFlag)
    End If

    Form1.SSPanel1.Caption = "Loading MSF File"

    Do Until TempString = "//"
        Input #NF, TempString
    Loop

    Do Until val(TempString) > 0 Or Len(TempString) > 20
        Input #NF, TempString
        'Pos
        'X = X
    Loop

    CLen = 4

    
    Do
        If val(TempString) > 0 And Len(TempString) > 20 Then
            Pos = InStr(1, TempString, " ", vbBinaryCompare)
            
            Pos = Pos + 1
            If Pos <= Len(TempString) Then
                If Left(TempString, Pos) <> "A" And Left(TempString, Pos) <> "a" Then
                If Left(TempString, Pos) <> "C" And Left(TempString, Pos) <> "c" Then
                If Left(TempString, Pos) <> "G" And Left(TempString, Pos) <> "g" Then
                If Left(TempString, Pos) <> "T" And Left(TempString, Pos) <> "t" Then
                If Left(TempString, Pos) <> "-" And Left(TempString, Pos) <> "." Then
                    Input #NF, TempString
                End If
                End If
                End If
                End If
                End If
                
                
            End If
            
        ElseIf NextNo >= 0 Then
            Input #NF, TempString
        End If
        Pos = 0
        'XX = val(TempString)
        If (val(TempString) = 0 Or Len(TempString) > 6) And TempString <> "" Then
            NextNo = NextNo + 1

            LastStartPos = Pos + 1
            StartPos = 0

            Do Until StartPos > 0
                StartPos = InStr(LastStartPos, TempString, "  ", vbBinaryCompare)
                LastStartPos = LastStartPos + 1
            Loop
            
            Call SeqArrays

            OriginalName(NextNo) = Trim(Mid$(TempString, 1, StartPos - 1))
            TempString = Trim(Right$(TempString, Len(TempString) - (StartPos)))
            Xpos = 1
                    Do
                        Xpos = InStr(1, TempString, " ", vbBinaryCompare)
                        If Xpos > 0 Then
                            TempString = Left(TempString, Xpos - 1) + Right(TempString, Len(TempString) - Xpos)
                        Else
                        
                            Exit Do
                        End If
                    Loop
            StrainSeq(NextNo) = TempString
            XX = x
        Else
            Exit Do
        End If

        
    Loop

    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog

    Do While Not EOF(NF)
        Input #NF, TempString

        If TempString <> Empty And (val(TempString) = 0 Or Len(TempString) > 6) Then
            x = -1

            Do
                Pos = InStr(1, TempString, "  ", vbBinaryCompare)

                If (val(Left(TempString, 2)) = 0 Or Len(TempString) > 6) And TempString <> Empty Then
                    x = x + 1
                    Xpos = 1
                    TempString = Trim(Right$(TempString, Len(TempString) - (Pos)))
                    Do
                        Xpos = InStr(1, TempString, " ", vbBinaryCompare)
                        If Xpos > 0 Then
                            TempString = Left(TempString, Xpos - 1) + Right(TempString, Len(TempString) - Xpos)
                        Else
                        
                            Exit Do
                        End If
                    Loop
                    StrainSeq(x) = StrainSeq(x) + TempString
                Else
                    If val(Left(TempString, 2)) = 0 Then
                        Exit Do
                    End If
                End If
                

                Input #NF, TempString
                x = x
            Loop

        End If

        XXX = Loc(NF)
        
        Form1.ProgressBar1.Value = 1 + (XXX / LOF(NF)) * 30
        Call UpdateF2Prog

        If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
    Loop

    If NextNo > -1 Then

        If OriginalName(NextNo) = "" Then NextNo = NextNo - 1
    End If

    Close #NF
End Sub

Public Sub LoadRDP(Response As Long, SNNextNo As Long, AdjustAlign() As Long)
    Dim A As Long, oDirX As String, IncrementX As Single, StartVal As Long, WeightedFlag As Long, OC As Double, AA As Long, CC As Long, SS As Long, TT As Long, EE As Long, Eventholder As Long, UB As Long, Z As Long, Enu As Long, XX As Variant, XXX As Variant, Dummy As Variant, tFName As String, TLen As Long, StartProgressVal As Double, TargetVal As Double
    
    
    If Form1.ProgressBar1.Value < 75 Then
        TargetVal = Form1.ProgressBar1 + 20
    Else
        TargetVal = Form1.ProgressBar1.Value + (100 - Form1.ProgressBar1.Value) / 1.2
    End If
    Form1.SSPanel1.Caption = "Loading recombination data"
    StartProgressVal = Form1.ProgressBar1
    Dim TS As String, TA As String, TB As String, TC As String, AddNumX As Long, oSEventNumber As Long, oEventNumber As Long, xFName As String, FF As Long, Hold As Byte, MaxList As Long, x As Long, Y As Long, PosGB As Long, DistLeft As Long, PosStart As Long
    Dim oDir As String, recomb As String, TString As String, Crap As String, PO As String, GO As String, MO As String
    If SNNextNo = -1 Then SNNextNo = 0
    SaveFlag = 1
    
    'XX = SEventNumber
    AddNumX = AddNum
    
    'XX = XoverList(0, 1).Probability '(4*10-30)
    'XX = XoverList(0, 4).Probability '(4*10-30)
    
    If Response <> 6 Then
        ReDim Preserve CurrentXOver(NextNo + 1)
        ReDim Preserve XOverSeq(NextNo + 2)
    Else
        ReDim CurrentXOver(NextNo + 1)
        ReDim XOverSeq(NextNo + 2)
    End If
    
    
    'FF = FreeFile
    FF = 144
    'XX = Len(StrainSeq(0))
    'Close #FF
    Open FName$ For Binary Access Read As #FF
    If Response <> 6 Then
        Get #FF, 1, Hold 'Len(StrainSeq(NextNo)) * (NextNo - SNNextNo), Hold
    Else
        Get #FF, Decompress(Len(StrainSeq(0))) * (NextNo + 1), Hold
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    
    
    
    '748060
    Do While Not EOF(FF)
        
        Line Input #FF, recomb$
        'XX = Len(recomb$)
        If recomb$ = "GB Data" Or Right(recomb$, 7) = "GB Data" Then
            
            SeqFile = ""
            xFName$ = "tGBFile"
            Open xFName$ For Output As #2
            TLen = 0
            Do While Not EOF(FF)
                Line Input #FF, recomb$
        
                If recomb$ = "Recombination Data" Or Mid(recomb$, 2, 18) = "Recombination Data" Or recomb$ = "//" Then
                    If Response <> 6 Then
                        Get #FF, 1, Hold
                    Else
                        Get #FF, Len(StrainSeq(0)) * (NextNo), Hold
                    End If
                    Exit Do
                End If
                Print #2, recomb$
                TLen = TLen + Len(recomb$)
            Loop
            Close #2
            
            
            If TLen > 200 Then
                Open xFName$ For Binary Access Read As #2
                SeqFile = String$(LOF(2), " ")
                Get #2, 1, SeqFile
                Close #2
                tFName = FName
                FName = xFName
                RDPLGBFlag = 1
                'Resetload = 0
                Call LoadGenBank(SeqFile)
                RDPLGBFlag = 0
                FName = tFName
                GBFile = SeqFile
                If GeneNumber > 0 Then
                    For x = 1 To GeneNumber
                        If GeneList(x).Orientation = 1 Then
                            If GeneList(x).EndInAlign > Len(StrainSeq(0)) Then
                                GeneList(x).EndInAlign = GeneList(x).EndInAlign - Len(StrainSeq(0))
                            End If
                        ElseIf GeneList(x).Orientation = 2 Then
                            If GeneList(x).StartInAlign > Len(StrainSeq(0)) Then
                                GeneList(x).StartInAlign = GeneList(x).StartInAlign - Len(StrainSeq(0))
                            End If
                        End If
                    Next x
                    
                    
                    Call FillGeneSEPos
                    Form5.Timer3.Enabled = True
                    F5T3Executing = 0
                    Form5.Timer4.Enabled = True
                    F5T1Executing = 0
                    
                End If
                Close #FF
                Open FName$ For Binary Access Read As #FF
            End If
            Kill xFName$
            
            If recomb$ = "Recombination Data" Or Mid(recomb$, 2, 18) = "Recombination Data" Or recomb$ = "//" Then
                If Response <> 6 Then
                    Get #FF, 1, Hold
                Else
                    Get #FF, Len(StrainSeq(0)) * (NextNo), Hold
                End If
                x = x
                Exit Do
            End If
        ElseIf EOF(FF) = True Then
            If Response <> 6 Then
                Get #FF, 1, Hold
            Else
                Get #FF, Len(StrainSeq(0)) * (NextNo), Hold
            End If
            Exit Do
        End If
        x = x
    Loop
     
    '748020
     Form1.ProgressBar1 = (StartProgressVal + (TargetVal - StartProgressVal) * 0.1)
     Call UpdateF2Prog
    'If InStr(1, recomb$, "Recombination Data", vbTextCompare) = 0 Then
        Close #FF
        Open FName$ For Binary Access Read As #FF
        'XX = oNextno
        Dim StartByte As Long, Junk As String
        Junk = String(18, " ")
        If NextnoSubtract = 0 Then
            StartByte = (((NextNo - (NextnoSubtract))) * Decompress(Len(StrainSeq(NextNo))))
        Else
            StartByte = (((NextNo - (NextnoSubtract))) * Decompress(Len(StrainSeq(NextNo)))) / 1.5
        End If
        'StartByte = StartByte - 3000
        If StartByte < 1 Then StartByte = 1
        Get #FF, StartByte, Junk
    'End If
     
    Dim NumCycles As Long
    Do While Not EOF(FF) 'While recomb$ <> "Recombination Data" And Mid(recomb$, 2, 18) <> "Recombination Data"
'        If InStr(1, recomb$, "Recombination Data", vbTextCompare) = 0 Then
            Input #FF, recomb$
'        Else
'            Exit Do
'        End If
        '''''
        If recomb$ = "Recombination Data" Then Exit Do
        x = x
        NumCycles = NumCycles + 1
        XX = LOF(FF)
        If NumCycles > LOF(FF) Then
            Close #FF
            Open FName$ For Input As #FF
            Do While Not EOF(FF) 'While recomb$ <> "Recombination Data" And Mid(recomb$, 2, 18) <> "Recombination Data"
            Input #FF, recomb$
            '''''
            If recomb$ = "Recombination Data" Then Exit Do
            
            NumCycles = NumCycles + 1
            If NumCycles > LOF(FF) Then
                Close #FF
                Open FName$ For Input As #FF
                Do While Not EOF(FF) 'While recomb$ <> "Recombination Data" And Mid(recomb$, 2, 18) <> "Recombination Data"
                    Input #FF, recomb$
                    '''''
                    If Left$(recomb$, 18) = "Recombination Data" Then Exit Do
                    x = x
                    NumCycles = NumCycles + 1
                    If NumCycles > LOF(FF) Then
                        MsgBox ("I can't seem to access the recombination data in this file. Try opening it in an older version of RDP")
                        Close #FF
                        Exit Sub
                    End If
                Loop
                Exit Do
            End If
        Loop
        End If
    Loop
    'Input #ff, Junk
    If EOF(FF) Then
        Close #FF
        Exit Sub
    End If
On Error GoTo 0
    Input #FF, TString
    If TString = "r13" Or TString = "r8" Or TString = "r9" Or TString = "r10" Or TString = "r11" Or TString = "r12" Then
        AddNumX = 7
    ElseIf TString = "r14" Then
        
        AddNumX = 8
    ElseIf TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Or TString = "r16" Or TString = "r15" Then
        
        AddNumX = 9
    End If
    If TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Or TString = "r16" Or TString = "r15" Or TString = "r14" Or TString = "r13" Or TString = "r8" Or TString = "r9" Or TString = "r10" Or TString = "r11" Or TString = "r12" Then    ' is  revision 8 or 9 or 10
        Form1.SSPanel1.Caption = "Loading recombination data"
        Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.15)
        Call UpdateF2Prog
        
        
        
        MinP = 0
        Dim F1(4) As String
        'Load settings
        Input #FF, SpacerFlag, CircularFlag, ShowPlotFlag, GPerms, PermTypeFlag, XOverWindowX, LowestProb, MCFlag
        Input #FF, SHWinLen, GCIndelFlag, SHStep, GCtripletflag
        Input #FF, GCOutfileName
        Input #FF, BSTreeStrat, BSupTest, GCSortFlag, GCTractLen, GCLogFlag
        Input #FF, GCMissmatchPen, SCHEMADistCO, SCHEMAPermNo, GCMinFragLen, GCMinPolyInFrag
        Input #FF, GCMinPairScore, GCMaxOverlapFrags, ConservativeGroup, MaxTemperature, ntType
        Input #FF, BSStepWin, BSStepSize, BSCutOff, BSBootReps, BSRndNumSeed, BSSubModelFlag
        Input #FF, BSTTRatio, MCMCUpdates, BlockPen, StartRho, MatPermNo
        Input #FF, DoScans(1, 2), DoScans(1, 5), FreqCo, MatWinSize, FreqCoMD
        Input #FF, AllowConflict, MCPermMaxP, MCSteplen, MCWinSize
        Input #FF, DoScans(0, 0), DoScans(0, 1), DoScans(0, 2), DoScans(0, 3), DoScans(0, 4), DoScans(0, 5)
        Input #FF, F1(1), F1(2), F1(3), F1(4)
        Input #FF, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
        Input #FF, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
        Input #FF, MCWinFract, MCProportionFlag, MCTripletFlag, MCStripGapsFlag, MCFullOR, MCFullOL
        Input #FF, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
        Input #FF, VisRDWin, ModelTestFlag
        Input #FF, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
        Input #FF, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
        Input #FF, TOTreeType, TOFreqFlag, TOModel
        Input #FF, BSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
        Input #FF, GCFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
        Input #FF, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
        Input #FF, TAfreq, TCFreq, TGFreq, TTFreq, TPower
        If ntType > 1 Or ntType < 0 Then
            ntType = 0
        End If
        If MaxTemperature < 0 Or (MaxTemperature > 0 And MaxTemperature < 1) Or MaxTemperature > 1000 Then
            MaxTemperature = 37
        End If
        If TString = "r9" Then
            Input #FF, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag
        Else
            Input #FF, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, BSPValFlag, SSFastFlag, SSGapFlag, SSVarPFlag, SSOutlyerFlag, SSRndSeed, SSWinLen, SSStep, SSNumPerms, SSNumPerms2
            Input #FF, ForcePhylE, PolishBPFlag, RealignFlag, ConsensusProg, CWinFract, CProportionFlag, CWinSize, Dummy, CPermMaxP
            If TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Or TString = "r16" Or TString = "r15" Or TString = "r14" Or TString = "r10" Or TString = "r11" Or TString = "r12" Or TString = "r13" Then
                Input #FF, PPWinLen, pPPStripGaps, IncSelf, PPSeed, PPPerms, DoScans(0, 8)
                If TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Or TString = "r16" Then
                    Input #FF, TPTVRat, TPGamma, TPAlpha, TPInvSites, TPModel, TPBPFEstimate
                    Input #FF, TBModel, TBGamma, TBGammaCats, TBNGens, TBNChains, TBSampFreq, TBTemp, TBSwapFreq, TBSwapNum
                End If
                
            End If
            
        End If
        GCSeqTypeFlag = 0
        If SCHEMAPermNo < 50 Or SCHEMADistCO > 80 Or SCHEMADistCO < 1 Then
            SCHEMAPermNo = 100000
            SCHEMADistCO = 4.5
        End If
        
        
        
        'LDHAT Variables
        If MCMCUpdates < 100000 Then
            BlockPen = 10
            StartRho = 30
            MCMCUpdates = 1000000
            FreqCo = 0.05
            FreqCoMD = 0.1
            GCFlag = 1
            GCTractLen = 1000
        End If
        If MatPermNo = 0 Then
            MatPermNo = 100
            MatWinSize = 200
        End If
    
        DoScans(0, 2) = 0
        Dim NP As Long
        NP = 0
        For x = 0 To AddNum - 1
            NP = NP + DoScans(0, x)
        Next x
        
        If NP = 0 Then
            DoScans(0, 0) = 1
            DoScans(0, 1) = 1
            DoScans(0, 3) = 1
            
        End If
        For x = 0 To AddNum - 1
            pDoScans(0, x) = DoScans(0, x)
        Next x
        
        
        
        pBSPValFlag = BSPValFlag
        
        
        
        ReDim Preserve ProgF(100)

        For x = 0 To AddNumX + AddNumX
            ProgF(x) = 1
        Next 'X

        Form1.Text5 = XOverWindowX
        Form1.Text1 = LowestProb
        Dim PVHold As Double
        
        Input #FF, MCCorrection
        If Response <> 6 Then
            Dim PValCon As Double
            If MCCorrection < oMCCorrection Then
                PValCon = oMCCorrection / MCCorrection
                MCCorrection = oMCCorrection
            Else 'convert current p-vals
                PValCon = MCCorrection / oMCCorrection
                For x = 0 To SNNextNo - 1
                    
                    For Y = 1 To CurrentXOver(x)
                        XoverList(x, Y).Probability = XoverList(x, Y).Probability * PValCon
                    Next Y
                    For Y = 1 To BCurrentXoverMi(x)
                        BestXOListMi(x, Y).Probability = BestXOListMi(x, Y).Probability * PValCon
                    Next Y
                    
                    For Y = 1 To BCurrentXoverMa(x)
                        BestXOListMa(x, Y).Probability = BestXOListMa(x, Y).Probability * PValCon
                    Next Y
                    
                Next x
                For x = 1 To SEventNumber
                    For Y = 0 To AddNumX - 1
                        If Confirm(x, Y) <> 0 Then
                            
                            PVHold = ConfirmP(x, Y) / Confirm(x, Y)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmP(x, Y) = -Log10(PVHold) * Confirm(x, Y)
                        End If
                        If ConfirmMi(x, Y) <> 0 Then
                            
                            PVHold = ConfirmPMi(x, Y) / ConfirmMi(x, Y)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMi(x, Y) = -Log10(PVHold) * ConfirmMi(x, Y)
                        End If
                        
                        If ConfirmMa(x, Y) <> 0 Then
                            
                            PVHold = ConfirmPMa(x, Y) / ConfirmMa(x, Y)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMa(x, Y) = -Log10(PVHold) * ConfirmMa(x, Y)
                        End If
                    Next Y
                Next x
                'BestXOListMi(X, Y).Probability = BestXOListMi(X, Y).Probability * PValCon
                PValCon = 1
            End If
        Else
            PValCon = 1
        End If
        NumberOfSeqs = -1
        Form1.SSPanel1.Caption = "Loading recombination data"
        Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.2)
        Call UpdateF2Prog
        Form1.Refresh
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        For x = SNNextNo To NextNo
            Input #FF, MaskSeq(x)
            If MaskSeq(x) = 0 Then
                NumberOfSeqs = NumberOfSeqs + 1
            End If
        Next 'X

        If DoScans(0, 1) = 1 And GCtripletflag = 0 Then

            Call GCFindSites

        End If
        If Response = 6 Then
            oMCCorrection = MCCorrection
            Call MakeMCCorrection(NextNo, MaskSeq(), MCCorrection, MCCorrect, GCMCCorrection, NumberOfSeqs, IndividualA, IndividualB)
            MCCorrection = oMCCorrection
        End If
        ReDim pMaskSeq(NextNo)

        For x = 0 To NextNo
            pMaskSeq(x) = MaskSeq(x)
        Next 'X
        Form1.SSPanel1.Caption = "Loading recombination data"
        
         Form1.ProgressBar1 = (StartProgressVal + (TargetVal - StartProgressVal) * 0.3)
         Call UpdateF2Prog
         Form1.Refresh
         If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        'store variable states at start of analysis
        MCFullFile = App.Path & "\maxchiout" + UFTag
        pMCTripletFlag = MCTripletFlag
        pMCProportionFlag = MCProportionFlag
        
        
        pMCStart = MCStart
        pMCEnd = MCEnd
        pMCMaxP = MCMaxP
        pMCSteplen = MCSteplen
        pMCWinSize = MCWinSize
        pMCWinFract = MCWinFract
        pMCStripGapsFlag = MCStripGapsFlag
        pMCFlag = MCFlag
        pXOverWindowX = XOverWindowX
        pCircularFlag = CircularFlag
        pSpacerFlag = SpacerFlag
        If LowestProb = 0 Then LowestProb = 0.05
        pLowestProb = LowestProb
        pBSTypeFlag = BSTypeFlag
        pBSStepSize = BSStepSize
        pBSStepWin = BSStepWin
        pBSBootReps = BSBootReps
        pBSCutoff = BSCutOff
        pSSGapFlag = SSGapFlag
        pSSVarPFlag = SSVarPFlag
        pSSOutlyerFlag = SSOutlyerFlag
        pSSRndSeed = SSRndSeed
        pSSWinLen = SSWinLen
        pSSStep = SSStep
        pSSNumPerms = SSNumPerms
        pSSNumPerms2 = SSNumPerms2
        pGCTripletflag = GCtripletflag
        pGCMissmatchPen = GCMissmatchPen
        pGCIndelFlag = GCIndelFlag
        pGCMinFragLen = GCMinFragLen
        pGCMinPolyInFrag = GCMinPolyInFrag
        pGCMinPairScore = GCMinPairScore
        pGCMaxOverlapFrags = GCMaxOverlapFrags
        pCWinFract = CWinFract
        pCProportionFlag = CProportionFlag
        pCWinSize = CWinSize
        
        pSSFastFlag = SSFastFlag
        pPPStripGaps = PPStripGaps
        ReDim ShowAllHits(NextNo)
        ReDim SubSetF(NextNo)
        ReDim SubSetR(NextNo + 1)
        ReDim SubMaskSeq(NextNo + 1)
        IncludeSeq = 0

        For x = 0 To NextNo

            If MaskSeq(x) < 2 Then
                SubSetF(x) = IncludeSeq
                SubSetR(IncludeSeq) = x
                SubMaskSeq(IncludeSeq) = x
                IncludeSeq = IncludeSeq + 1
            End If

        Next 'X

        Input #FF, Crap
        

        For x = SNNextNo To NextNo
            Input #FF, CurrentXOver(x)
            
            x = x
        Next 'X
        MaxList = 0
        For x = 0 To NextNo
            If CurrentXOver(x) > MaxList Then MaxList = CurrentXOver(x)
        Next x
        GlobalMemoryStatus MemSit
        
        
        APhys = Abs(MemSit.dwTotalPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        
        MaxXOListSize = APhys / 20
        MaxXOListSize = CLng(MaxXOListSize / NextNo / 100 / 2)
        If MaxList + 10 > MaxXOListSize Then MaxXOListSize = MaxList + 10
        XOverListSize = MaxList + 10
       ' XX = XoverList(0, 4).Probability '(4*10-30)
        If Response <> 6 Then
            Dim tXOL() As XOverDefine, MSize As Long
            MSize = 0
            For x = 0 To NextNo
                If CurrentXOver(x) > MSize Then
                    MSize = CurrentXOver(x)
                End If
            Next x
            ReDim tXOL(NextNo, MSize)
            
            For x = 0 To SNNextNo - 1
                For Y = 1 To CurrentXOver(x)
                    tXOL(x, Y) = XoverList(x, Y)
                    'XX = XOverList(X, Y).Probability
                Next Y
            Next x
            ReDim XoverList(NextNo, XOverListSize)
            For x = 0 To SNNextNo - 1
                For Y = 1 To CurrentXOver(x)
                    XoverList(x, Y) = tXOL(x, Y)
                    'XX = XOverList(X, Y).Probability
                Next Y
            Next x
        Else
            ReDim XoverList(NextNo, XOverListSize)
        End If
         Form1.ProgressBar1 = (StartProgressVal + (TargetVal - StartProgressVal) * 0.4)
         
         'XX = XoverList(0, 4).Probability '(4*10-30)
         
         
         Call UpdateF2Prog
        Input #FF, Crap

        If TString = "r8" Then

            For x = SNNextNo To NextNo

                For Y = 1 To CurrentXOver(x)
                    Input #FF, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, XoverList(x, Y).Beginning, XoverList(x, Y).Ending
                    Input #FF, XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag
                    Input #FF, XX, XoverList(x, Y).PermPVal, XoverList(x, Y).ProgramFlag
                    Input #FF, XXX, XX, XoverList(x, Y).LHolder, XoverList(x, Y).LHolder
                    Input #FF, XoverList(x, Y).BeginP, XoverList(x, Y).EndP, XX, XXX
                    Input #FF, XoverList(x, Y).SBPFlag
                    If XoverList(x, Y).ProgramFlag >= AddNumX Then
                        XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y

            Next 'X

        ElseIf TString = "r9" Or TString = "r10" Or TString = "r11" Or TString = "r12" Then
            ReDim oRecombNo(100)
            Enu = 0
            For x = 0 To NextNo
                oRecombNo(100) = oRecombNo(100) + CurrentXOver(x)
                For Y = 1 To CurrentXOver(x)
                    Input #FF, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, XoverList(x, Y).Beginning, XoverList(x, Y).Ending
                    Input #FF, XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag
                    Input #FF, XX, XoverList(x, Y).PermPVal, XoverList(x, Y).ProgramFlag
                    Input #FF, XXX, XX, XoverList(x, Y).LHolder, XoverList(x, Y).LHolder
                    Input #FF, XoverList(x, Y).BeginP, XoverList(x, Y).EndP, XX, XXX
                    XoverList(x, Y).DHolder = NextNo * 2
                    'If DebuggingFlag < 2 Then On Error Resume Next
                    Input #FF, XoverList(x, Y).SBPFlag, XoverList(x, Y).Accept
                    'On Error GoTo 0
                    
                    If TString = "r12" Or TString = "r10" Or TString = "r11" Then
                        
                        If TString = "r10" Then
                            Enu = Enu + 1
                            XoverList(x, Y).Eventnumber = Enu
                            For Z = 0 To 16
                                Input #FF, XX
                                Z = Z
                            Next Z
                        Else
                            Input #FF, XoverList(x, Y).Eventnumber
                        End If
                    End If
                    If XoverList(x, Y).ProgramFlag >= AddNumX Then XoverList(x, Y).Accept = 2
                    If XoverList(x, Y).ProgramFlag >= AddNumX Then
                        XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag - AddNumX + AddNum
                    End If
                Next 'Y
                
                Form1.ProgressBar1.Value = StartProgressVal + (TargetVal - StartProgressVal) * (x / NextNo)
                Call UpdateF2Prog
                
            Next 'X
            If TString = "r10" Then
                
                ReDim TreeSMat(0, 0)
                
                ReDim SuperEventList(Enu), BestEvent(Enu, 1), Confirm(Enu, AddNum - 1), ConfirmP(Enu, AddNum - 1), DScores(25, 2, Enu)
                SEventNumber = Enu
                For x = 0 To Enu
                    SuperEventList(x) = x
                Next x
                For x = 0 To NextNo
                    For Y = 1 To CurrentXOver(x)
                        BestEvent(XoverList(x, Y).Eventnumber, 0) = x
                        BestEvent(XoverList(x, Y).Eventnumber, 1) = Y
                    Next Y
                Next x
            End If
        ElseIf TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Or TString = "r16" Or TString = "r15" Or TString = "r14" Or TString = "r13" Then
            ST = Abs(GetTickCount)
            '807292
            ReDim oRecombNo(100)
            StartProgressVal = Form1.ProgressBar1.Value
            For x = SNNextNo To NextNo
                oRecombNo(100) = oRecombNo(100) + CurrentXOver(x) '6,1,2,2,0,0,5
                If TString = "r21" Or TString = "r20" Or TString = "r19" Then
                    For Y = 1 To CurrentXOver(x)
                        Call GetFromFile(PValCon, AddNumX, SNNextNo, FF, x, Y, XoverList())
                    Next 'Y
                Else
                
                    For Y = 1 To CurrentXOver(x)
                        
                        
                        
                        Call GetFromFile(PValCon, AddNumX, SNNextNo, FF, x, Y, XoverList())
                        'XOverList(X, Y).Beginning = XOverList(X, Y).Beginning - 500
                        'XOverList(X, Y).Ending = XOverList(X, Y).Ending - 500
                        'If XOverList(X, Y).Ending > Len(StrainSeq(0)) Then XOverList(X, Y).Ending = XOverList(X, Y).Ending - Len(StrainSeq(0))
                        'If XOverList(X, Y).Beginning > Len(StrainSeq(0)) Then XOverList(X, Y).Beginning = XOverList(X, Y).Beginning - Len(StrainSeq(0))
                        'If XOverList(X, Y).Ending < 1 Then XOverList(X, Y).Ending = XOverList(X, Y).Ending + Len(StrainSeq(0))
                        'If XOverList(X, Y).Beginning < 1 Then XOverList(X, Y).Beginning = XOverList(X, Y).Beginning + Len(StrainSeq(0))
                    Next 'Y
                End If
                ET = Abs(GetTickCount)
                If (ET - ST) > 500 Then
                    ST = ET
                    Form1.SSPanel1.Caption = "Recombination data loaded for " + Trim(Str(CLng(x / 3) + 1)) + " of " + Trim(Str(NextNo + 1)) + " sequences"
                    Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * x / NextNo * 0.28)
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            Dim MaxNum As Long
            MaxNum = 0
            For x = 0 To NextNo
                If MaxNum < CurrentXOver(x) Then
                    MaxNum = CurrentXOver(x)
                End If
            Next x
            UB = UBound(XoverList, 1)
            ReDim Preserve XoverList(UB, MaxNum)
            '805192
            StartProgressVal = Form1.ProgressBar1.Value
            Input #FF, Crap
            
            ReDim Preserve BCurrentXoverMi(NextNo)
            
            For x = SNNextNo To NextNo
                Input #FF, BCurrentXoverMi(x)
    
                
            Next 'X
            MaxList = 0
            For x = 0 To NextNo
                If BCurrentXoverMi(x) > MaxList Then MaxList = BCurrentXoverMi(x)
            Next 'X
            If Response <> 6 Then
                ReDim tXOL(NextNo, MaxList)
                
                For x = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMi(x)
                        tXOL(x, Y) = BestXOListMi(x, Y)
                    Next Y
                Next x
                ReDim BestXOListMi(NextNo, MaxList)
                For x = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMi(x)
                        BestXOListMi(x, Y) = tXOL(x, Y)
                    Next Y
                Next x
                
            Else
                ReDim BestXOListMi(NextNo, MaxList)
            End If
            Input #FF, Crap
            
            For x = SNNextNo To NextNo
                If TString = "r21" Or TString = "r20" Or TString = "r19" Then
                    For Y = 1 To BCurrentXoverMi(x)
                        Call GetFromFile(PValCon, AddNumX, SNNextNo, FF, x, Y, BestXOListMi())
                    Next 'Y
                Else
                    For Y = 1 To BCurrentXoverMi(x)
                        Call GetFromFile(PValCon, AddNumX, SNNextNo, FF, x, Y, BestXOListMi())
                    Next 'Y
                End If
                '857152
                ET = Abs(GetTickCount)
                If ET - ST > 500 Then
                    ST = ET
                    Form1.SSPanel1.Caption = "Recombination data loaded for " + Trim(Str(CLng(NextNo / 3) + CLng(x / 3) + 1)) + " of " + Trim(Str(NextNo + 1)) + " sequences"
                    Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * x / NextNo)
                    Call UpdateF2Prog
                End If
                ET = Abs(GetTickCount)
                
            Next 'X
'826
            Input #FF, Crap
            ReDim Preserve BCurrentXoverMa(NextNo)
            For x = SNNextNo To NextNo
                Input #FF, BCurrentXoverMa(x)
                 '= XX
                If BCurrentXoverMa(x) > MaxList Then MaxList = BCurrentXoverMa(x)
            Next 'X
            MaxList = 0
            For x = 0 To NextNo

                If BCurrentXoverMa(x) > MaxList Then MaxList = BCurrentXoverMa(x)
            Next 'X
            If Response <> 6 Then
                ReDim tXOL(NextNo, MaxList)
                
                For x = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMa(x)
                        tXOL(x, Y) = BestXOListMa(x, Y)
                    Next Y
                Next x
                ReDim BestXOListMa(NextNo, MaxList)
                For x = 0 To SNNextNo - 1
                    For Y = 1 To BCurrentXoverMa(x)
                        BestXOListMa(x, Y) = tXOL(x, Y)
                    Next Y
                Next x
                
            Else
                ReDim BestXOListMa(NextNo, MaxList)
            End If
            Input #FF, Crap
           
            For x = SNNextNo To NextNo
                If TString = "r21" Or TString = "r20" Or TString = "r19" Then
                    For Y = 1 To BCurrentXoverMa(x)
                        Call GetFromFile(PValCon, AddNumX, SNNextNo, FF, x, Y, BestXOListMa())
                    Next 'Y
                Else
                    For Y = 1 To BCurrentXoverMa(x)
                        Call GetFromFile(PValCon, AddNumX, SNNextNo, FF, x, Y, BestXOListMa())
                    Next 'Y
                End If
                ET = Abs(GetTickCount)
                If ET - ST > 500 Then
                    ST = ET
                    Form1.SSPanel1.Caption = "Recombination data loaded for " + Trim(Str(CLng(NextNo * 2 / 3) + CLng(x / 3) + 1)) + " of " + Trim(Str(NextNo + 1)) + " sequences"
                    'Form1.ProgressBar1.Value = 66 + ((X / 3) / Nextno) * 100
                End If
            Next 'X
            Form1.SSPanel1.Caption = "Recombination data loaded for " + Trim(Str(NextNo + 1)) + " of " + Trim(Str(NextNo + 1)) + " sequences"
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            '850
            
            
ForgetIt:
           
           
           
        End If
        
        'Form1.ProgressBar1 = 100
        'XX = XOverList(243, 3).DHolder
        If TString = "r11" Then
            Input #FF, Eventnumber
            ReDim BestEvent(Eventnumber, 1)
            For x = 1 To Eventnumber
                Input #FF, BestEvent(x, 0), BestEvent(x, 1)
                
            Next x
        ElseIf TString = "r12" Then
            Input #FF, Eventnumber
            'Eventnumber = 42
            ReDim BestEvent(Eventnumber, 1)
            ReDim Confirm(Eventnumber, AddNum - 1), ConfirmP(Eventnumber, AddNum - 1)
            For x = 1 To Eventnumber
                Input #FF, BestEvent(x, 0), BestEvent(x, 1)
                For Z = 0 To AddNumX - 1
                    Input #FF, Confirm(x, Z), ConfirmP(x, Z)
                Next Z
            Next x
            
            
            ReDim Daught(Eventnumber, NextNo), MinorPar(Eventnumber, NextNo + 1), MajorPar(Eventnumber, NextNo + 1)

            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    Eventholder = XoverList(x, Y).Eventnumber
                    Daught(Eventholder, x) = 1
                    MinorPar(Eventholder, XoverList(x, Y).MinorP) = 1
                    MajorPar(Eventholder, XoverList(x, Y).MajorP) = 1
                Next Y
            Next x
            
            'Call LoadConfirms
        ElseIf TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Or TString = "r16" Or TString = "r15" Or TString = "r14" Or TString = "r13" Then
            'Input #ff, Crap
            Form1.SSPanel1.Caption = "Loading recombination data"
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            LongWindedFlag = 1
            'If Response <> 6 Then
            If Response <> 6 Then
                oSEventNumber = SEventNumber
                oEventNumber = Eventnumber
            Else
                oSEventNumber = 1
                oEventNumber = 1
            End If
            
            
            Input #FF, SEventNumber, Eventnumber
            
            If Response <> 6 Then
                SEventNumber = SEventNumber + oSEventNumber
                Eventnumber = Eventnumber + oEventNumber
                oSEventNumber = oSEventNumber + 1
                oEventNumber = oEventNumber + 1
                For x = SNNextNo To NextNo
                    For Y = 1 To CurrentXOver(x)
                        XoverList(x, Y).Eventnumber = XoverList(x, Y).Eventnumber + oEventNumber - 1
                        
                    Next Y
                    For Y = 1 To BCurrentXoverMi(x)
                        BestXOListMi(x, Y).Eventnumber = BestXOListMi(x, Y).Eventnumber + oEventNumber - 1
                        
                    Next Y
                    For Y = 1 To BCurrentXoverMa(x)
                        BestXOListMa(x, Y).Eventnumber = BestXOListMa(x, Y).Eventnumber + oEventNumber - 1
                        
                    Next Y
                Next x
            
            End If
            Form1.SSPanel1.Caption = "Loading event statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.4)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            ReDim Preserve NOPINI(2, SEventNumber)
            SS = Abs(GetTickCount)
            If Response = 6 Then
                For x = oSEventNumber - 1 To SEventNumber
                
                    For Y = 0 To 2
                         Call GetTS(FF, TS)
                         NOPINI(Y, x) = CInt(TS)
                        
                    Next Y
                Next x
            Else
                For Y = 0 To 2
                    Input #FF, Crap
                Next Y
                For x = oSEventNumber To SEventNumber
                    For Y = 0 To 2
                         Call GetTS(FF, TS)
                         NOPINI(Y, x) = CInt(TS)
                    Next Y
                Next x
            End If
            '0.062 for 600 events
            ReDim Preserve DScores(25, 2, SEventNumber)
            If DebuggingFlag < 2 Then On Error Resume Next
            Form1.SSPanel1.Caption = "Loading recombinant identification statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.5)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            If TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Then
                If Response = 6 Then
                    For x = 0 To 25
                        For Y = 0 To 2
                            For Z = oSEventNumber - 1 To SEventNumber
                                
                                Call GetTS(FF, TS)
                                'DScores(X, Y, Z) = val(TS)
                                DScores(x, Y, Z) = CDbl(val(TS))
                            Next Z
                        Next Y
                    Next x
                Else
                    For x = 0 To 25
                        For Y = 0 To 2
                            Input #FF, Crap
                            x = x
                            For Z = oSEventNumber To SEventNumber
                                Call GetTS(FF, TS)
                                'DScores(X, Y, Z) = val(TS)
                                DScores(x, Y, Z) = CDbl(val(TS))
                            Next Z
                        Next Y
                    Next x
                End If
            Else
            
                If Response = 6 Then
                    For x = 0 To 20
                        For Y = 0 To 2
                            For Z = oSEventNumber - 1 To SEventNumber
                                
                                Call GetTS(FF, TS)
                                'DScores(X, Y, Z) = val(TS)
                                DScores(x, Y, Z) = CDbl(val(TS))
                            Next Z
                        Next Y
                    Next x
                Else
                    For x = 0 To 20
                        For Y = 0 To 2
                            Input #FF, Crap
                            x = x
                            For Z = oSEventNumber To SEventNumber
                                Call GetTS(FF, TS)
                                'DScores(X, Y, Z) = val(TS)
                                DScores(x, Y, Z) = CDbl(val(TS))
                            Next Z
                        Next Y
                    Next x
                End If
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.577 for 600 events
            Form1.SSPanel1.Caption = "Loading recombination event statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.55)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            On Error GoTo 0
            ReDim Preserve SuperEventList(Eventnumber)
            SS = Abs(GetTickCount)
            If Response = 6 Then
                For x = oEventNumber - 1 To Eventnumber
                    
                    Call GetTS(FF, TS)
                    If TS <> "1" Then
                        x = x
                    End If
                    SuperEventList(x) = CLng(TS)
                    
                Next x
                x = x
            Else
                
                Input #FF, Crap
                For x = oEventNumber To Eventnumber
                    Call GetTS(FF, TS)
                    SuperEventList(x) = CLng(TS)
                    SuperEventList(x) = SuperEventList(x) + oSEventNumber - 1
                Next x
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.968 for 600 events
            Form1.SSPanel1.Caption = "Loading recombination event statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.6)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            
            If Response <> 6 Then
                'get backups of arrays that can't be redim preserved.
                Dim TD() As Long, tMi() As Long, tMa() As Long, CD() As Long, CP() As Double, CMi() As Long, CPMi() As Double, CMa() As Long, CPMa() As Double
                ReDim TD(SEventNumber, NextNo), tMi(SEventNumber, NextNo), tMa(SEventNumber, NextNo)
                ReDim CD(SEventNumber, AddNum - 1), CP(SEventNumber, AddNum - 1), CMi(SEventNumber, AddNum - 1), CPMi(SEventNumber, AddNum - 1), CMa(SEventNumber, AddNum - 1), CPMa(SEventNumber, AddNum - 1)
                For Y = 1 To oSEventNumber - 1
                    For x = 0 To SNNextNo - 1
                        TD(Y, x) = Daught(Y, x)
                        tMi(Y, x) = MinorPar(Y, x)
                        tMa(Y, x) = MajorPar(Y, x)
                    Next x
                    For x = 0 To AddNumX - 1
                        CD(Y, x) = Confirm(Y, x)
                        CMi(Y, x) = ConfirmMi(Y, x)
                        CMa(Y, x) = ConfirmMa(Y, x)
                        CP(Y, x) = ConfirmP(Y, x)
                        CPMi(Y, x) = ConfirmPMi(Y, x)
                        CPMa(Y, x) = ConfirmPMa(Y, x)
                    Next x
                Next Y
                
            End If
            ReDim BestEvent(SEventNumber, 1)
            ReDim Confirm(Eventnumber, AddNum - 1), ConfirmP(Eventnumber, AddNum - 1), ConfirmMi(Eventnumber, AddNum - 1), ConfirmPMi(Eventnumber, AddNum - 1), ConfirmMa(Eventnumber, AddNum - 1), ConfirmPMa(Eventnumber, AddNum - 1)
            ReDim Daught(SEventNumber, NextNo), MinorPar(SEventNumber, NextNo + 1), MajorPar(SEventNumber, NextNo + 1)
            
            If Response <> 6 Then
                'Put backups back into the arrays
                          
                For Y = 1 To oSEventNumber - 1
                    For x = 0 To SNNextNo
                        Daught(Y, x) = TD(Y, x)
                        MinorPar(Y, x) = tMi(Y, x)
                        MajorPar(Y, x) = tMa(Y, x)
                    Next x
                    For x = 0 To AddNumX - 1
                        Confirm(Y, x) = CD(Y, x)
                        ConfirmMi(Y, x) = CMi(Y, x)
                        ConfirmMa(Y, x) = CMa(Y, x)
                        ConfirmP(Y, x) = CP(Y, x)
                        ConfirmPMi(Y, x) = CPMi(Y, x)
                        ConfirmPMa(Y, x) = CPMa(Y, x)
                    Next x
                Next Y
                
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.031 for 600 events
            Form1.SSPanel1.Caption = "Loading recombinant/parental sequence groups"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.7)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            '*****************************************************************************
            'Super slow
            CC = 0
            If TString = "r21" Or TString = "r20" Or TString = "r19" Then
                Dim NumEntriesD As Long, NumEntriesMi As Long, NumEntriesMa As Long, TotNum As Long
                Call GetTS(FF, TA)
                Call GetTS(FF, TB)
                Call GetTS(FF, TC)
                NumEntriesD = CLng(TA)
                NumEntriesMi = CLng(TB)
                NumEntriesMa = CLng(TC)
                TotNum = NumEntriesD + NumEntriesMi + NumEntriesMa
                For Y = 1 To NumEntriesD
                    Call GetTS(FF, TA)
                    Call GetTS(FF, TB)
                    Call GetTS(FF, TC)
                    Daught(CLng(TA) + (oSEventNumber - 1), CLng(TB) + SNNextNo) = CLng(TC)
                    AA = Abs(GetTickCount)
                    If Abs(AA - CC) > 500 Then
                        CC = AA
                        Form1.SSPanel1.Caption = "Loaded " + Str(Y) + " out of " + Str(TotNum) + " sequence groups"
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                Next Y
                For Y = 1 To NumEntriesMi
                    Call GetTS(FF, TA)
                    Call GetTS(FF, TB)
                    Call GetTS(FF, TC)
                    MinorPar(CLng(TA) + (oSEventNumber - 1), CLng(TB) + SNNextNo) = CLng(TC)
                    AA = Abs(GetTickCount)
                    If Abs(AA - CC) > 500 Then
                        CC = AA
                        Form1.SSPanel1.Caption = "Loaded " + Str(Y + NumEntriesD) + " out of " + Str(TotNum) + " sequence groups"
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                Next Y
                For Y = 1 To NumEntriesMa
                    Call GetTS(FF, TA)
                    Call GetTS(FF, TB)
                    Call GetTS(FF, TC)
                    MajorPar(CLng(TA) + (oSEventNumber - 1), CLng(TB) + SNNextNo) = CLng(TC)
                    AA = Abs(GetTickCount)
                    If Abs(AA - CC) > 500 Then
                        CC = AA
                        Form1.SSPanel1.Caption = "Loaded " + Str(Y + NumEntriesD + NumEntriesMi) + " out of " + Str(TotNum) + " sequence groups"
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                Next Y
'                For Y = oSEventNumber To SEventNumber
'                    For X = SNNextNo To Nextno
'    '                    Input #ff, Daught(Y, X)
'    '                    Input #ff, MinorPar(Y, X)
'    '                    Input #ff, MajorPar(Y, X)
'                        Call GetTS(ff, TS)
'                        Daught(Y, X) = CLng(TS)
'                        Call GetTS(ff, TS)
'                        MinorPar(Y, X) = CLng(TS)
'                        Call GetTS(ff, TS)
'                        MajorPar(Y, X) = CLng(TS)
'                        'X = X
'                    Next X
'                    AA = Abs(GetTickCount)
'
'                    If Abs(AA - CC) > 500 Then
'                        CC = AA
'                        Form1.SSPanel1.Caption = "Loading sequence groups for " + Trim(Str(Y)) + " out of " + Trim(Str(SEventNumber)) + " recobination events"
'                        'Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.7)
'                        Form1.Refresh
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'                    End If
'                Next Y
            Else
                For Y = oSEventNumber To SEventNumber
                    For x = SNNextNo To NextNo
    '                    Input #ff, Daught(Y, X)
    '                    Input #ff, MinorPar(Y, X)
    '                    Input #ff, MajorPar(Y, X)
                        Call GetTS(FF, TS)
                        Daught(Y, x) = CLng(TS)
                        Call GetTS(FF, TS)
                        MinorPar(Y, x) = CLng(TS)
                        Call GetTS(FF, TS)
                        MajorPar(Y, x) = CLng(TS)
                        'X = X
                    Next x
                    AA = Abs(GetTickCount)
                    
                    If Abs(AA - CC) > 500 Then
                        CC = AA
                        Form1.SSPanel1.Caption = "Loading sequence groups for " + Trim(Str(Y)) + " out of " + Trim(Str(SEventNumber)) + " recobination events"
                        Call UpdateF2Prog
                        'Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.7)
                        Form1.Refresh
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                Next Y
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            Form1.SSPanel1.Caption = "Loaded sequence groups for " + Trim(Str(SEventNumber)) + " out of " + Trim(Str(SEventNumber)) + " recobination events"
            '31.3 seconds for 600 events and 1700 sequences
            '************************************************************************************
            Form1.SSPanel1.Caption = "Loading recombinant sequence statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.75)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            'TT = EE - SS
            For x = oSEventNumber To SEventNumber
                
                Call GetTS(FF, TS)
                BestEvent(x, 0) = CLng(TS)
                Call GetTS(FF, TS)
                BestEvent(x, 1) = CLng(TS)
                If BestEvent(x, 0) = 0 And BestEvent(x, 1) = 0 And x < 5 Then
                    
                    If TString <> "r13" Then
                        AddNumX = AddNumX + 1
                    End If
                    Call GetTS(FF, TS)
                    BestEvent(x, 0) = CLng(TS)
                    Call GetTS(FF, TS)
                    BestEvent(x, 1) = CLng(TS)
                End If
                If DebuggingFlag < 2 Then On Error Resume Next
                For Z = 0 To AddNumX - 1
                        Call GetTS(FF, TS)
                        Confirm(x, Z) = CLng(TS)
                        Call GetTS(FF, TS)
                        'ConfirmP(X, Z) = val(TS)
                        ConfirmP(x, Z) = CDbl(val(TS))
                        
                        If ConfirmP(x, Z) < 0.05 Then
                        OC = ConfirmP(x, Z)
                             If ConfirmP(x, Z) < 0 Then
                                ConfirmP(x, Z) = 10 ^ (ConfirmP(x, Z))
                                
                             ElseIf ConfirmP(x, Z) > 0 Then
                                ConfirmP(x, Z) = -Log10(ConfirmP(x, Z))
                                If ConfirmP(x, Z) < 0 Then
                                
                                End If
                             End If
                        End If
                       
                                
                        If Confirm(x, Z) <> 0 Then
                            
                            PVHold = ConfirmP(x, Z) / Confirm(x, Z)
                            PVHold = 10 ^ (-PVHold)
                            PVHold = PVHold * PValCon
                            ConfirmP(x, Z) = -Log10(PVHold) * Confirm(x, Z)
                            x = x
                        End If
                Next Z
                On Error GoTo 0
            Next x
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.203 for 1700 seqs and 600 events
            Form1.SSPanel1.Caption = "Loading parantal sequence statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.8)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            For x = oSEventNumber To SEventNumber
                If DebuggingFlag < 2 Then On Error Resume Next
                For Z = 0 To AddNumX - 1
                    Call GetTS(FF, TS)
                    ConfirmMi(x, Z) = CLng(TS)
                    Call GetTS(FF, TS)
                    'ConfirmPMi(X, Z) = val(TS)
                    ConfirmPMi(x, Z) = CDbl(val(TS))
                    
                        If ConfirmPMi(x, Z) < 0.05 Then
                        
                             If ConfirmPMi(x, Z) < 0 Then
                                
                                ConfirmPMi(x, Z) = 10 ^ (ConfirmPMi(x, Z))
                                
                             ElseIf ConfirmPMi(x, Z) > 0 Then
                                ConfirmPMi(x, Z) = -Log10(ConfirmPMi(x, Z))
                                
                             End If
                        End If
                        If ConfirmMi(x, Z) <> 0 Then
                            
                            PVHold = ConfirmPMi(x, Z) / ConfirmMi(x, Z)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMi(x, Z) = -Log10(PVHold) * ConfirmMi(x, Z)
                        End If
                
                Next Z
                On Error GoTo 0
            Next x
            Form1.SSPanel1.Caption = "Loading parental sequence statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.85)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            
            For x = oSEventNumber To SEventNumber
                If DebuggingFlag < 2 Then On Error Resume Next
                For Z = 0 To AddNumX - 1
                        Call GetTS(FF, TS)
                        If TS = "" Then Exit For
                        ConfirmMa(x, Z) = CLng(TS)
                        Call GetTS(FF, TS)
                        'ConfirmPMa(X, Z) = val(TS)
                        ConfirmPMa(x, Z) = CDbl(val(TS))
                        If ConfirmPMa(x, Z) < 0.05 Then
                        
                             If ConfirmPMa(x, Z) < 0 Then
                                
                                ConfirmPMa(x, Z) = 10 ^ (ConfirmPMa(x, Z))
                                
                             ElseIf ConfirmPMa(x, Z) > 0 Then
                                ConfirmPMa(x, Z) = -Log10(ConfirmPMa(x, Z))
                                
                             End If
                        End If
                        If ConfirmMa(x, Z) <> 0 Then
                            
                            PVHold = ConfirmPMa(x, Z) / ConfirmMa(x, Z)
                            PVHold = 10 ^ (-PVHold)
                            
                            PVHold = PVHold * PValCon
                            ConfirmPMa(x, Z) = -Log10(PVHold) * ConfirmMa(x, Z)
                        End If
                Next Z
                On Error GoTo 0
            Next x
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.187 for 1700 seqs and 600 events
            Form1.SSPanel1.Caption = "Loading parental sequence statistics"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.9)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Dim AProg() As Byte
            ReDim AProg(AddNum * 2)
            
            
           
            For x = 0 To AddNum - 1
                If DoScans(0, x) = 1 Then AProg(x) = 1: AProg(x + AddNum) = 1
            Next x
            
            
            ReDim BestEvent(Eventnumber, 1)
            Dim BestP() As Double, oStepNo As Long
            ReDim BestP(SEventNumber + 1)
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    If XoverList(x, Y).Eventnumber <= Eventnumber Then
                        If XoverList(x, Y).Probability > 0 And (XoverList(x, Y).Probability < BestP(SuperEventList(XoverList(x, Y).Eventnumber)) Or BestP(SuperEventList(XoverList(x, Y).Eventnumber)) = 0) Then
                            If AProg(XoverList(x, Y).ProgramFlag) = 1 Then
                                BestP(SuperEventList(XoverList(x, Y).Eventnumber)) = XoverList(x, Y).Probability
                                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 0) = x
                                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 1) = Y
                            End If
                        End If
                    End If
                Next Y
                x = x
            Next x
            
            
            If Response <> 6 Then
                oStepNo = StepNo + 1
                StepNo = StepNo + 1
               
            Else
                oStepNo = 0
            End If
            If DebuggingFlag < 2 Then On Error Resume Next
            Input #FF, StepNo
            On Error GoTo 0
            x = x
            XX = StepNo
            If Response <> 6 Then
                StepNo = StepNo + oStepNo
            End If
           XX = UBound(Steps, 1)
            ReDim Preserve Steps(4, StepNo)
            'For Y = 0 To 4
            '    Input #ff, Crap
            '    XX = Steps(0, X)
            'Next Y
            If StepNo > 0 Then
                For x = oStepNo To StepNo
                    For Y = 0 To 4
                    
                        
                       Call GetTS(FF, TS)
                       If TS <> "" Then
                            Steps(Y, x) = CDbl(TS)
                       End If
                    Next Y
                    
                Next x
            End If
            ReDim Preserve MultColour(NextNo), ColourSeq(NextNo)
            Form1.SSPanel1.Caption = "Loading graphical data"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 0.95)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            'TT = EE - SS
            For x = SNNextNo To NextNo
                Call GetTS(FF, TS)
                If TS = "" Then Exit For
                MultColour(x) = CLng(TS)
                Call GetTS(FF, TS)
                ColourSeq(x) = CLng(TS)
                
            Next x
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.047 for 600 events and 1700 seqs
            Form1.SSPanel1.Caption = "Loading sequence exchange data"
            Form1.ProgressBar1.Value = (StartProgressVal + (TargetVal - StartProgressVal) * 1#)
            Call UpdateF2Prog
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            SS = Abs(GetTickCount)
            
            If Response <> 6 Then
                Call DoAlnAddj(SNNextNo, AdjustAlign())
                For x = 0 To oStepNo - 1
                    If Steps(1, x) > SNNextNo - 1 Then
                        Steps(1, x) = NextNo + (Steps(1, x) - (SNNextNo - 1))
                    End If
                    
                    If Steps(0, x) = 1 Or Steps(0, x) = 2 Then
                        Steps(2, x) = AdjustAlign(Steps(2, x), 0)
                        Steps(3, x) = AdjustAlign(Steps(3, x), 0)
                    'ElseIf Steps(0, X) = 3 Or Steps(0, X) = 4 Then
                    '    Steps(1, X) = NextNo + (Steps(1, X) - SNNextNo - 1)
                    
                    End If
                Next x
                'work out how many sequences there actually are after the last sequence in the first dataset is considered
                Dim tNextno As Long
                tNextno = NextNo
                
                For x = 0 To oStepNo - 1
                    If Steps(0, x) = 1 Then
                    
                        tNextno = tNextno + 1
                    ElseIf Steps(0, x) = 3 Then
                    
                        tNextno = tNextno - 1
                    ElseIf Steps(0, x) = 4 Then
                    
                        tNextno = tNextno - 1
                    End If
                        
                Next x
                If tNextno < NextNo Then
                    tNextno = NextNo
                End If
                Dim Mint As Long
                Mint = NextNo - SNNextNo
                For x = oStepNo To StepNo
                    If Steps(1, x) <= Mint Then
                        Steps(1, x) = Steps(1, x) + SNNextNo
                    Else
                        Steps(1, x) = tNextno + (Steps(1, x) - Mint)
                    End If
                    If Steps(0, x) = 1 Or Steps(0, x) = 2 Then
                        
                        Steps(2, x) = AdjustAlign(Steps(2, x), 1)
                        Steps(3, x) = AdjustAlign(Steps(3, x), 1)
                        Steps(4, x) = Steps(4, x) + oSEventNumber - 1
                    'ElseIf Steps(0, X) = 3 Or Steps(0, X) = 4 Then
                    '    Steps(1, X) = tNextno + (Steps(1, X) - NextNo)
                    End If
                Next x
                ReDim MissingData(Len(StrainSeq(0)), NextNo)
                If ReassortmentFlag = 1 Then
                    Dim tBP As Long
                    If UBound(RBPPos, 1) < RBPNum Then
                        ReDim Preserve RBPPos(RBPNum)
                    End If
                    For x = 0 To RBPNum
                        tBP = RBPPos(x)
                        For Y = 0 To NextNo
                            MissingData(tBP, Y) = 1
                        Next Y
                    Next x
                End If
            End If
            
            On Error GoTo SkipThis
            On Error GoTo 0
            ReDim Preserve TreeTestStats(3, SEventNumber)
            For x = oSEventNumber To SEventNumber
                For Y = 0 To 3
                    TreeTestStats(Y, x) = -1
                Next Y
            Next x
            If TString = "r21" Or TString = "r20" Or TString = "r19" Or TString = "r18" Or TString = "r17" Then
                
                For x = oSEventNumber To SEventNumber
                    For Y = 0 To 3
                        Input #FF, TreeTestStats(Y, x)
                        
                    Next Y
                Next x
            End If
            
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.094 for 600 events and 1700 sequences
            
            Form1.SSPanel1.Caption = "Loading recombination data"
            SS = Abs(GetTickCount)
            
            Call GetTS(FF, TS)
            GPerms = CLng(TS)
            If GPerms > 0 Then
                
                For Z = 0 To GPerms
                    For x = 0 To NextNo
                        For Y = 0 To PermsCurrentXOver(Z, x)
                            Input #FF, PermsXOverList(Z, x, Y).Daughter, PermsXOverList(Z, x, Y).MajorP, PermsXOverList(Z, x, Y).MinorP, PermsXOverList(Z, x, Y).Beginning, PermsXOverList(Z, x, Y).Ending
                            Input #FF, PermsXOverList(Z, x, Y).Probability, PermsXOverList(Z, x, Y).OutsideFlag, PermsXOverList(Z, x, Y).MissIdentifyFlag
                            Input #FF, PermsXOverList(Z, x, Y).PermPVal, PermsXOverList(Z, x, Y).ProgramFlag
                            Input #FF, PermsXOverList(Z, x, Y).LHolder, PermsXOverList(Z, x, Y).DHolder
                            Input #FF, PermsXOverList(Z, x, Y).BeginP, PermsXOverList(Z, x, Y).EndP
                            Input #FF, PermsXOverList(Z, x, Y).SBPFlag, PermsXOverList(Z, x, Y).Accept, PermsXOverList(Z, x, Y).Eventnumber
                        Next Y
                    Next x
                Next Z
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            'get info on confidence intervals
            If UBound(BPCIs, 1) <> 9 Then
               ReDim BPCIs(9, SEventNumber)
            Else
                ReDim Preserve BPCIs(9, SEventNumber)
            End If
            SS = Abs(GetTickCount)
            'TT = EE - SS
            On Error Resume Next
            'If Response <> 6 Then
                For x = oSEventNumber To SEventNumber
                    For Y = 0 To 9
                        Input #FF, BPCIs(Y, x)
                        
                    Next Y
                Next x
            On Error GoTo 0
            'Else
            '    For x = 1 To SEventNumber
            '        For Y = 0 To 9
            '            Input #ff, BPCIs(Y, x)
            '            x = x
            '        Next Y
            '    Next x
            'End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0.041 for 600 events
            If DebuggingFlag < 2 Then On Error Resume Next
            SelGrpFlag = 0
            'TString = String(100, " ")
            On Error Resume Next
            Input #FF, SelGrpFlag
            ReDim Preserve GrpMaskSeq(NextNo)
            SS = Abs(GetTickCount)
            
            If SelGrpFlag > 0 Then
                For x = SNNextNo To NextNo
                    Input #FF, GrpMaskSeq(x)
                Next x
            End If
            EE = Abs(GetTickCount)
            TT = EE - SS
            '0for 1700 seqs
            On Error GoTo 0
            On Error Resume Next
            Input #FF, ReassortmentFlag
            If ReassortmentFlag = 1 Then
                
                Input #FF, RBPNum
                ReDim RBPPos(RBPNum + 10)
                For x = 0 To RBPNum
                    Input #FF, RBPPos(x)
                Next x
            End If
            
            For x = 0 To AddNum - 1
                Input #FF, MethodTime(x)
                
            Next x
            For x = 0 To AddNum - 1
                Input #FF, TimeFract(x)
                
            Next x
            
            
            Input #FF, RefNum
            If RefNum > 0 Then
                ReDim ReferenceList(PermNextno)
                For x = 0 To PermNextno
                   
                    Input #FF, ReferenceList(x)
                    
                
                Next x
                ReDim RefGroupName(RefNum)
                ReDim ReferenceCols(RefNum)
                For x = 0 To RefNum
                    Input #FF, RefGroupName(x)
                    Input #FF, ReferenceCols(x)
                Next x
            End If
            
            
            ReDim Preserve YannWarn(SEventNumber)
            On Error Resume Next
            For x = oSEventNumber To SEventNumber
                Input #FF, YannWarn(x)
                x = x
            Next x
            On Error GoTo 0
            Dim UBWWSg As Long, NumEntries As Long, PositionX As Long
            If Loc(FF) = LOF(FF) Then 'end of the file has been reached
            
            Else
'                XX = Loc(1)
'                XX = LOF(1)
                Dim oUBWWS As Long
                If SNNextNo > 0 Then
                    oUBWWS = UBound(Worthwhilescan)
                Else
                    oUBWWS = 0
                End If

                Input #FF, UBWWS
                
                Dim NN As Variant
                NN = (NextNo - SNNextNo) + 1
                NN = NN * (NextNo - SNNextNo)
                NN = NN * ((NextNo - SNNextNo) - 1)
                NN = NN / 6
                If UBWWS < MaxAnalNo And UBWWS < NN Then
                    If NN <= MaxAnalNo Then
                        UBWWS = NN
                    Else
                        UBWWS = MaxAnalNo
                    End If
                End If
                
                Input #FF, NumEntries
                'If UBound(Worthwhilescan, 1) < UBWWS Then
                If UBWWS > 0 Then
                    ReDim Preserve Worthwhilescan(UBWWS + oUBWWS + 1)
                End If
                'End If
                'XX = UBound(Worthwhilescan)
                UBWWSx = UBound(Worthwhilescan, 1)
                Dim VarX As Variant
                For x = 1 To NumEntries
                    
                    Input #FF, PositionX
                    If PositionX <= UBWWSx Then '10877551,10877555
                        Input #FF, VarX 'Worthwhilescan(PositionX)
                        If VarX >= 0 And VarX <= 255 Then
                            Worthwhilescan(PositionX + oUBWWS) = VarX
                        Else
                            x = x
                        End If
                    Else
                        Input #FF, VarX '53448
                        x = x
                    End If
                Next x
                
                
                On Error GoTo 0
            End If
            
            Dim TTr As Long
            TT = 0
            For x = 0 To UBound(Worthwhilescan)
                If Worthwhilescan(x) = 1 Then
                    TTr = TTr + Worthwhilescan(x)
                End If
            Next x

            If TTr < 10 Then
                For x = 0 To UBound(Worthwhilescan)
                    'If Worthwhilescan(X) = 1 Then
                    Worthwhilescan(x) = 1 + 2 + 4 + 8 + 16 + 32 + 64
                    'End If
                Next x

            End If
            
        End If
            
SkipThis:


        
            'Form1.ProgressBar1.Value = 100

            If PosGB > 0 Then

                If NextNo > 0 Then
                    'Form1.ProgressBar1.Value = 0
                    Form1.SSPanel1.Caption = "Loading ORF positions"
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    VarString = Right$(VarString, Len(VarString) - PosGB)
                    'Form1.ProgressBar1.Value = 10

                    Call LoadGenBankII(VarString)
    
                    'Form1.ProgressBar1.Value = 100
                Else
                    Response = MsgBox("You need to open an alignment file before opening a GenBank file.", 48)
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
    
            End If

            Form1.Command6(2).Enabled = True
            Form1.Command5.Enabled = True
            Form1.Command9.Enabled = True
            Form1.Label58.Caption = "Unique sequences"

            If TString = "r8" Then
    
                If DoScans(0, 1) = 1 Or (DoScans(0, 3) = 1 And MCTripletFlag = 1) Then
                    Form1.ProgressBar1.Value = StartProgressVal + (TargetVal - StartProgressVal) * 0.2
                    Form1.SSPanel1.Caption = "Loading GENECONV Data"
                    Call UpdateF2Prog
                    GCOFile = App.Path & "\pout.frags"
                    DistLeft = LOF(FF) - Loc(FF)
                    PosStart = Loc(FF)
                    PO$ = String$(DistLeft, " ")
                    Form1.ProgressBar1.Value = StartProgressVal + (TargetVal - StartProgressVal) * 0.5
                    
                    Get #FF, PosStart, PO$
                    Form1.SSPanel1.Caption = "Loading MaxChi Data"
                    Call UpdateF2Prog
                    Pos = InStr(1, PO$, "MCData", vbBinaryCompare)
    
                    If Pos > 0 Then
                        GO$ = Left$(PO$, Pos - 1)
                        MO$ = Right$(PO$, Len(PO$) - Pos - 6)
                    End If
    
                    Close #FF
                    Open GCOFile For Output As #FF
                    Print #FF, GO$
                    Close #FF
                    GO$ = ""
                    If DebuggingFlag < 2 Then On Error Resume Next

                    oDir$ = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    On Error GoTo 0
                    Open "RDP5maxchiout" + UFTag For Output As #FF
                    Print #FF, MO$
                    Close #FF
                    MO$ = ""
                    If DebuggingFlag < 2 Then On Error Resume Next

                    ChDir oDir$
                    ChDrive oDir$
                    On Error GoTo 0
                    Form1.ProgressBar1.Value = TargetVal
                    Call UpdateF2Prog
                Else
                    Close #FF
                End If
    
            ElseIf TString = "r9" Then
                If DebuggingFlag < 2 Then On Error Resume Next
    
                If DoScans(0, 1) = 1 Or (DoScans(0, 3) = 1 And MCTripletFlag = 1) Then
                    Kill App.Path & "\maxchiout" + UFTag
                    GCOFile = App.Path & "\pout.frags"
                    MCFullFile = App.Path & "\maxchiout" + UFTag
                    Kill GCOFile
                    Form1.SSPanel1.Caption = "Loading GENECONV Data"
                    FileCopy Left$(FNameII, Len(FNameII) - 4) + ".gc", GCOFile
                    Form1.SSPanel1.Caption = "Loading MaxChi Data"
                    FileCopy Left$(FNameII, Len(FNameII) - 4) + ".mc", MCFullFile
                End If
    
                If DoScans(0, 2) = 1 Then
                    If DebuggingFlag < 2 Then On Error Resume Next
                    Kill App.Path & "\BSScanData" + UFTag
                    On Error GoTo 0
                    Form1.SSPanel1.Caption = "Loading Bootscan Data"
                    BSFileName = Left$(FNameII, Len(FNameII) - 4) + ".bs"
                End If
    
                Form1.SSPanel1.Caption = ""
                On Error GoTo 0
                Close #FF
            End If

    ElseIf TString = "r7" Then
        Input #FF, SpacerFlag, CircularFlag, WeightedFlag, FullWindowSize, HomologyIndicator, XOverWindowX, LowestProb, MCFlag
        Form1.Text5 = XOverWindowX
        Form1.Text1 = LowestProb
        Input #FF, MCCorrection

        For x = 0 To NextNo
            Input #FF, MaskSeq(x)
        Next 'X

        For x = 0 To NextNo
            Input #FF, CurrentXOver(x)
        Next 'X

        For x = 0 To NextNo

            For Y = 0 To CurrentXOver(x)
                Input #FF, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, XoverList(x, Y).Beginning, XoverList(x, Y).Ending, XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag
            Next 'Y

        Next 'X

        If PosGB > 0 Then

            If NextNo > 0 Then
                RDPLGBFlag = 1
                Call LoadGenBank(SeqFile)
                
                For x = 1 To GeneNumber
                    If GeneList(x).Orientation = 1 Then
                        If GeneList(x).EndInAlign > Len(StrainSeq(0)) Then
                            GeneList(x).EndInAlign = GeneList(x).EndInAlign - Len(StrainSeq(0))
                        End If
                    ElseIf GeneList(x).Orientation = 2 Then
                        If GeneList(x).StartInAlign > Len(StrainSeq(0)) Then
                            GeneList(x).StartInAlign = GeneList(x).StartInAlign - Len(StrainSeq(0))
                        End If
                    End If
                Next x
                
                
                Call FillGeneSEPos
                Timer3.Enabled = False
                Timer3.Interval = 100
                Form5.Timer3.Enabled = True
                F5T3Executing = 0
                Timer4.Enabled = False
                Timer4.Interval = 100
                Form5.Timer4.Enabled = True
                F5T1Executing = 0
                
            Else
                Response = MsgBox("You need to open an alignment file before opening a GenBank file.", 48)
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If

        End If

        Close #FF
    Else ' versions befor revision7
        SpacerFlag = CDbl(TString)
        Input #FF, CircularFlag, WeightedFlag, FullWindowSize, HomologyIndicator, XOverWindowX, LowestProb, MCFlag
        Form1.Text5 = XOverWindowX
        Form1.Text1 = LowestProb
        Input #FF, MCCorrection

        For x = 0 To NextNo
            Input #FF, MaskSeq(x)
        Next 'X

        For x = 0 To NextNo
            Input #FF, CurrentXOver(x)
        Next 'X

        For x = 0 To NextNo

            For Y = 0 To CurrentXOver(x)
                Input #FF, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, XoverList(x, Y).Beginning, XoverList(x, Y).Ending, XoverList(x, Y).Probability
            Next 'Y

        Next 'X

        Close #FF
    End If
    Dim IncirimentX As Single
    StartVal = Form1.ProgressBar1.Value: IncrementX = (100 - StartVal) / 4
    SS = Abs(GetTickCount)
    MaRec = 1
    MiRec = 1
    If (PermNextno > MemPoc And x = 1234567 And SEventNumber > 300) Or XOMiMaInFileFlag = 1 Then
        'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        Form1.SSPanel1.Caption = "Writing minor parent lists to disk"
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        
        XOMiMaInFileFlag = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        UBXOMi = UBound(BestXOListMi, 2)
        UBXoMa = UBound(BestXOListMa, 2)
        
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Put #FF, , BestXOListMi()
        Close #FF
        MiRec = MiRec - 1
        Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + IncrementX
        Form1.SSPanel1.Caption = "Writing major parent lists to disk"
        Call UpdateF2Prog
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Put #FF, , BestXOListMa()
        Close #FF
        MaRec = MaRec - 1
        Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + IncrementX
        Call UpdateF2Prog
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Form1.Refresh
        ChDrive oDirX
        ChDir oDirX
        Erase BestXOListMi
        Erase BestXOListMa
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS '11.607
    x = x
    Form1.SSPanel1.Caption = "Updating recombination graphs"
    Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    'Form1.ProgressBar1 = 5
    
    'I NEED TO FIGURE OUT HOW TO HANDLE THE STEPDOWN CORRECTION FOLLOWING A SAVE
    If MCFlag = 2 And x = 1234567 Then
        ReDim PValCat(AddNum, 100)
        ReDim MaxPValCat(AddNum, 100)
        For Z = 0 To NextNo
            For A = 1 To CurrentXOver(x)
                CurrentCorrect = XoverList(Z, A).ProgramFlag
                If CurrentCorrect >= AddNumX Then CurrentCorrect = CurrentCorrect - AddNumX
                ProbabilityXOver = XoverList(Z, A).Probability
                If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                    PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                    PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                End If
            Next A
            
        Next Z
    ElseIf MCFlag = 2 Then
        MCFlag = 0
    End If
    If Response <> 6 Then
        If Len(StrainSeq(0)) > UBound(Decompress) Or Len(StrainSeq(0)) > UBound(Recompress) Then
            ReDim Decompress(Len(StrainSeq(0)))
            ReDim Recompress(Len(StrainSeq(0)))
            For x = 0 To Len(StrainSeq(0))
                Decompress(x) = x
                Recompress(x) = x
            Next x
            
        End If
    End If
    'rather than redoing this I should simply save the bestevent array and load it up again here
    Call FORDPLoad
    
    
'    If CombinedFileFlag = 1 Then
'
'        For x = 0 To UBound(tXoverlist, 1)
'            'tCurrentxover(x) = CurrentXOver(x)
'            For Y = 0 To tCurrentxover(x)
'                XoverList(x, Y) = tXOList(x, Y)
'            Next Y
'        Next x
'    End If
    
    ReDim Preserve YannWarn(SEventNumber + 100)
    Close #FF
    XX = CurrentXOver(NextNo)
    Form1.Command6(2).Enabled = True
    Form1.Command5.Enabled = True
    Form1.Command9.Enabled = True
    Form1.Label58.Caption = "Unique sequences"
    Form1.Command18.ToolTipText = "Save results in .csv or .rdp project file format"
End Sub

Public Sub FORDPLoad()
    'If SEventNumber > 0 Then
    '497.7
        Call IntegrateXOvers(1)
    'End If
    '506.8 Megs Urmilla
    Form1.SSPanel1.Caption = "Finishing load"
    'XX = Form1.Picture21.Height
    ReDim StartPlt(AddNum - 1)
    ReDim PDistPlt(0, 0)
    ReDim ProbPlt(0, 0)
    ReDim HitPlt(0, 0)
    ReDim Hitnumber(0)
    
    Form1.Picture6.Refresh
    
    Form1.Picture6.MousePointer = 0
    'Form1.ProgressBar1.Value = 100
    
    'ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    'ReDim XOverSeqNumW(Len(StrainSeq(0)) + XOverWindow * 2, 2)
    Form1.Command18.Enabled = True                'Enable "save" button
    
    'Form1.Command18.Width = 70 * Screen.TwipsPerPixelX
    'Form1.command2(1).Visible = True
    Form1.Picture7.ScaleMode = 3
    Form1.Picture21.Height = Form1.Picture7.Height + 50
    Form1.Picture21.Width = Form1.Picture7.Width + 50
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.Picture3.AutoRedraw = True

    Call PrintNames
 'XX = Form1.Picture21.Height
    Close #1
    'XX = Form1.Picture21.Height
    If SEventNumber > 0 Then
        RunFlag = 1
    End If
    Form1.Picture3.Refresh
    LastY3 = -1
    Form1.Picture3.MousePointer = 0
    Form1.Picture3.AutoRedraw = False
    Form1.Picture7.ScaleMode = 3
    Form1.Picture10.ScaleMode = 3
    Form1.UnmaskAllMnu.Visible = False
    Form1.DisableAllMnu.Visible = True
    Form1.MaskAllMnu.Visible = True
    'Form1.InvertMaskMnu.Visible = False
    pMCTripletFlag = MCTripletFlag
    pMCProportionFlag = MCProportionFlag
    
    pMCStart = MCStart
    pMCEnd = MCEnd
    pMCMaxP = MCMaxP
    pMCSteplen = MCSteplen
    pMCWinSize = MCWinSize
    pMCWinFract = MCWinFract
    pMCStripGapsFlag = MCStripGapsFlag
    pMCFlag = MCFlag
    pXOverWindowX = XOverWindowX
    pCircularFlag = CircularFlag
    If LowestProb = 0 Then LowestProb = 0.05
    
    pSpacerFlag = SpacerFlag
    pLowestProb = LowestProb
    pDoScans(0, 4) = DoScans(0, 4)
    pDoScans(0, 5) = DoScans(0, 5)
    pDoScans(0, 0) = DoScans(0, 0)
    pDoScans(0, 1) = DoScans(0, 1)
    pDoScans(0, 2) = DoScans(0, 2)
    pDoScans(0, 3) = DoScans(0, 3)
    PerMaxPval = 0
    PPMax = 0
    Form1.Picture5.Enabled = True
    Form1.Picture6.Enabled = True
    If Form1.Picture6.Enabled = True Then
        If CLine = "" Or CLine = " " Then
            Form1.Picture6.SetFocus
        End If
    End If
    Form1.SSPanel1.Caption = ""
    '506.8 Urmilla
    x = x
End Sub
Public Sub LoadCLUSTAL()

    Dim NF As Integer, SeqStart As Integer, CLen As Integer
    Dim LastStartPos As Long, StartPos As Long, LastPos As Long, CHK As Long, x As Long
    Dim TempString As String, CK As String

    NextNo = -1
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, TempString

    If Len(TempString) > LOF(NF) * 0.5 Then
        
        Call ReformatFile(NF, TempString, SaveFlag)
 
    End If

    Form1.SSPanel1.Caption = "Loading CLUSTAL File"

    Do Until TempString = Empty
        Input #NF, TempString
    Loop

    Do Until TempString <> Empty
        Input #NF, TempString
    Loop

    CLen = 4

    Do While CLen > 0
        CK$ = String$(CLen, " ")
        CHK = InStr(1, TempString, CK$, vbBinaryCompare)

        If CHK > 0 Then Exit Do
        CLen = CLen - 1
    Loop

    If CLen = 0 Then
        Close #NF
        Exit Sub
    End If

    Do Until Mid$(TempString, 1, CLen) = CK$
        Pos = InStr(1, TempString, CK$, vbBinaryCompare)

        If Pos > 1 And Right$(TempString, 1) <> "*" Then
            NextNo = NextNo + 1

            If SeqStart = 0 Then
                LastStartPos = Pos + 1
                StartPos = 1

                Do Until StartPos = 0
                    StartPos = InStr(LastStartPos, TempString, "  ", vbBinaryCompare)
                    LastStartPos = LastStartPos + 1
                Loop

                SeqStart = LastStartPos
            End If

            Call SeqArrays

            OriginalName(NextNo) = Mid$(TempString, 1, Pos - 1)
            spacepos = InStr(SeqStart, TempString, " ", vbBinaryCompare)
            If spacepos = 0 Then
                StrainSeq(NextNo) = Mid$(TempString, SeqStart, Len(TempString) - (SeqStart - 1))
            Else
                If spacepos - SeqStart = 10 Then
                    Pos = SeqStart
                    Do While spacepos > 0
                        StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(TempString, Pos, spacepos - (Pos))
                        Pos = spacepos + 1
                        spacepos = InStr(Pos, TempString, " ", vbBinaryCompare)
                    Loop
                    StrainSeq(NextNo) = StrainSeq(NextNo) + Mid$(TempString, Pos, Len(TempString) - (Pos) + 1)
                Else
                    StrainSeq(NextNo) = Mid$(TempString, SeqStart, spacepos - (SeqStart))
                End If
            End If
            
        Else
            Exit Do
        End If

        Input #NF, TempString
    Loop

    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
   ' Dim TSX() As String
  '  ReDim TSX(Nextno)
    Do While Not EOF(NF)
        Input #NF, TempString

        If TempString <> Empty Then
            x = -1
           ' TSX = ""
            Do
                Pos = InStr(1, TempString, "  ", vbBinaryCompare)

                If Mid$(TempString, 1, Len(OriginalName(x + 1))) = OriginalName(x + 1) And Mid$(TempString, 1, 1) <> "*" And TempString <> Empty Then
                    x = x + 1
                    spacepos = InStr(SeqStart, TempString, " ", vbBinaryCompare)
                    If spacepos = 0 Then
                        StrainSeq(x) = StrainSeq(x) + Mid$(TempString, SeqStart, Len(TempString) - (SeqStart - 1))
                    Else
                        If spacepos - SeqStart = 10 Then
                            Pos = SeqStart
                            Do While spacepos > 0
                                StrainSeq(x) = StrainSeq(x) + Mid$(TempString, Pos, spacepos - (Pos))
                                Pos = spacepos + 1
                                spacepos = InStr(Pos, TempString, " ", vbBinaryCompare)
                            Loop
                       
                            StrainSeq(x) = StrainSeq(x) + Mid$(TempString, Pos, Len(TempString) - (Pos) + 1)
                        
                        Else
                            StrainSeq(x) = StrainSeq(x) + Mid$(TempString, SeqStart, spacepos - (SeqStart))
                        End If
                    End If
                Else
                    Exit Do
                End If

                Input #NF, TempString
            Loop

        End If

        XXX = Loc(NF)
        XXX = Len(StrainSeq(0))
        Form1.ProgressBar1.Value = 1 + (XXX / LOF(NF)) * 30
        Call UpdateF2Prog
        If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
    Loop

    If NextNo > -1 Then

        If OriginalName(NextNo) = "" Then NextNo = NextNo - 1
    End If

    Close #NF
End Sub
Public Sub LoadGCG()

    Dim OddFormat As Integer, Y As Integer, NF As Integer
    Dim LastPos As Long, PosN1 As Long, x As Long, Displacement As Long
    Dim TempSeq As String, TempString As String

    NF = FreeFile
    OddFormat = 0
    Form1.SSPanel1.Caption = "Loading GCG File"
    Form1.ProgressBar1.Value = 1
    Call UpdateF2Prog
    NextNo = -1
    Open FName$ For Input Access Read As #NF

    Do While Not EOF(NF)
        Line Input #NF, TempString

        If Len(TempString) > LOF(NF) * 0.5 Then
            OddFormat = 1
            Close #NF
            LastPos = 1

            Do
                Pos = InStr(LastPos, TempString, Chr$(10), vbBinaryCompare)

                If Pos > 0 Then
                    Mid$(TempString, Pos, 1) = Chr$(13)
                    LastPos = Pos + 2
                    Variab = Asc(Mid$(TempString, 7, 1))
                Else
                    Exit Do
                End If

            Loop

            Open "tempfile" For Output As #NF
            SaveFlag = 1
            Print #NF, TempString
            Close #NF
            Open "tempfile" For Input Access Read As #NF
            Line Input #NF, TempString
        End If

        Pos = InStr(1, TempString, "Name:", vbBinaryCompare)

        If Pos > 0 Then
            NextNo = NextNo + 1

            Call SeqArrays

            PosN1 = InStr(Pos + 6, TempString, " ", vbBinaryCompare)
            OriginalName(NextNo) = Mid$(TempString, Pos + 6, PosN1 - (Pos + 6))
        End If

        If TempString = "//" Then Exit Do
    Loop

    OddFormat = 0
    x = 0

    If OddFormat = 0 Then

        Do While Not EOF(NF)
            Line Input #NF, TempString
            Pos = InStr(1, TempString, OriginalName(0), vbBinaryCompare)

            If Pos > 0 Then

                If Displacement = 0 Then

                    Do

                        If Mid$(TempString, Len(OriginalName(0)) + Pos + Displacement, 1) <> " " Then
                            Displacement = Displacement + Pos + Len(OriginalName(0))
                            Exit Do
                        Else
                            Displacement = Displacement + 1
                        End If

                    Loop

                End If

                For x = 0 To NextNo

                    For Y = 0 To 4
                        StrainSeq(x) = StrainSeq(x) + Mid$(TempString, Displacement + Y * 10 + Y, 10)
                    Next 'Y

                    If x < NextNo Then Line Input #NF, TempString
                Next 'X

                x = x + 1
            Else
                x = 0
            End If

            If TempString = "Recombination Data" Or TempString = "GB Data" Then Exit Do
            Form1.ProgressBar1.Value = 1 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.3
            Call UpdateF2Prog
        Loop

    Else

        Do While Not EOF(NF)
            Pos = InStr(1, TempString, OriginalName(0), vbBinaryCompare)

            If Pos > 0 Then
                Displacement = Pos + (Len(OriginalName(0))) + 2

                For x = 0 To NextNo

                    For Y = 1 To 4
                        TempSeq = Mid$(TempString, Displacement + Y * 10 + Y, 10)
                        StrainSeq(x) = StrainSeq(x) + TempSeq
                    Next 'Y

                Next 'X

            End If

            Form1.ProgressBar1.Value = 1 + (Loc(NF) / (LOF(NF) / 127)) * 100 * 0.3
            Call UpdateF2Prog
        Loop

    End If

    Close #NF
    Exit Sub
Specialcase:
    Close #NF
    'this is where the routine ends up if you've tried to load a file without any carriage returns.
End Sub
Public Sub SeqArrays()
    'If X = X Then
        
        If NextNo > UBound(StrainSeq, 1) Then
            ReDim Preserve StrainSeq(NextNo + 100)
            ReDim Preserve OriginalName(NextNo + 100)
        End If
        
       
'    Else
'        If Nextno = 200 Then
'            ReDim Preserve StrainSeq(300)
'            ReDim Preserve OriginalName(300)
'        ElseIf Nextno = 300 Then
'            ReDim Preserve StrainSeq(1000)
'            ReDim Preserve OriginalName(1000)
'        ElseIf Nextno = 1000 Then
'            ReDim Preserve StrainSeq(10000)
'            ReDim Preserve OriginalName(10000)
'        ElseIf Nextno = 10000 Then
'            ReDim Preserve StrainSeq(100000)
'            ReDim Preserve OriginalName(100000)
'        End If
'
'    End If
End Sub

Public Sub LoadMSA()


    Dim NF As Integer, NoSpaceInFileFlag As Integer, NoSpaceBetweenGroupsFlag As Integer, SequentialFlag As Integer, SpaceInFileFlag As Integer, IsSeq As Integer
    Dim LastPos As Long, PosN1 As Long, x As Long, Y As Long
    Dim TempString As String, NameCheck As String

    'On Error GoTo UnknownFormat
    Form1.SSPanel1.Caption = "Loading MSA File"
    NF = FreeFile
    Open FName$ For Input Access Read As #NF
    Line Input #NF, TempString
    SS = Abs(GetTickCount)
    If Len(TempString) > LOF(NF) * 0.5 Then
         Call ReformatFile(NF, TempString, SaveFlag)
        NoSpaceBetweenGroupsFlag = 1
    Else
        Close #NF
        Open FName$ For Input Access Read As #NF
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS
    NextNo = -1
    SequentialFlag = 0
    SpaceInFileFlag = 0
    
    
    Dim tNextno As Long, SCount As Long, TempNames() As String, TempSequences() As String, FullNames() As String, FullSequences() As String, DoneSeq() As Byte
    
    Dim Z As Long
    ReDim TempNames(10), TempSequences(10)
    Z = 1
    NextNo = -1
    Do While Not EOF(NF)
        Line Input #NF, TempString
        XX = Left$(TempString, 13)
        If Left$(TempString, 13) = "#=GF Accuracy" Then
            SCount = -1
            Do
                
                Line Input #NF, TempString
                If Left$(TempString, 13) = "#=GC Accuracy" Then
                    Exit Do
                ElseIf TempString <> "" Then
                    SCount = SCount + 1
                    Pos = InStr(1, TempString, " ", vbBinaryCompare)
                    If SCount > UBound(TempNames, 1) Then
                        ReDim Preserve TempNames(SCount + 10)
                        ReDim Preserve TempSequences(SCount + 10)
                    End If
                    TempNames(SCount) = Trim(Left$(TempString, Pos))
                    TempSequences(SCount) = Trim(Right$(TempString, Len(TempString) - Pos))
                    Pos = InStr(1, TempNames(SCount), "_", vbBinaryCompare)
                    If Pos > 0 Then
                        TempNames(SCount) = Left(TempNames(SCount), Pos - 1)
                        x = x
                    End If
                End If
                
            Loop
            'go through the loaded sequences and see if they should be kept
            If NextNo = -1 Then
                NextNo = SCount
                ReDim FullNames(NextNo)
                ReDim FullSequences(NextNo)
                For x = 0 To NextNo
                    FullNames(x) = TempNames(x)
                    FullSequences(x) = TempSequences(x)
                Next x
                'remove duplicates
                x = 0
                Do While x <= NextNo
                   For Y = x + 1 To NextNo
                        If FullNames(x) = FullNames(Y) Then
                            FullNames(Y) = FullNames(NextNo)
                            FullSequences(Y) = FullSequences(NextNo)
                            NextNo = NextNo - 1
                            x = x - 1
                            Exit Do
                        End If
                   Next Y
                   x = x + 1
                Loop
                x = x
            Else
                ReDim DoneSeq(SCount)
                For x = 0 To SCount
                    For Y = 0 To NextNo
                        If TempNames(x) = FullNames(Y) Then
                            DoneSeq(x) = 1
                            Exit For
                        End If
                    Next Y
                Next x
                GoOn = 1
                For x = 0 To SCount
                    If DoneSeq(x) = 0 Then
                        
                        'A new sequence name has been found so start again
                        If SCount <= NextNo Then
                            NextNo = -1
                            GoOn = 0
                            Exit For
                        Else
                            NextNo = SCount
                            ReDim FullNames(NextNo)
                            ReDim FullSequences(NextNo)
                            For Z = 0 To NextNo
                                FullNames(Z) = TempNames(Z)
                                FullSequences(Z) = TempSequences(Z)
                            Next Z
                            GoOn = 0
                            Exit For
                        End If
                    End If
                Next x
                If GoOn = 1 Then 'The new sequences should possibly be added to the old
                    'check whether all the sequences are represented in the new batch
                    ReDim DoneSeq(NextNo)
                    For x = 0 To NextNo
                        For Y = 0 To SCount
                            If TempNames(Y) = FullNames(x) Then
                                DoneSeq(x) = 1
                                Exit For
                            End If
                        Next Y
                    Next x
                    GoOn = 1
                    For x = 0 To NextNo
                        If DoneSeq(x) = 0 Then
                            GoOn = 0
                            Exit For
                        End If
                    Next x
                    If GoOn = 1 Then
                        For x = 0 To NextNo
                            For Y = 0 To SCount
                                If TempNames(Y) = FullNames(x) Then
                                    FullSequences(x) = FullSequences(x) + TempSequences(Y)
                                    Exit For
                                End If
                            Next Y
                        Next x
                        XX = Len(FullSequences(0))
                    End If
                End If
            End If
        
        End If
        x = x
    Loop
    Close #NF
    
    ReDim OriginalName(NextNo)
    ReDim StrainSeq(NextNo)
    For x = 0 To NextNo
        OriginalName(x) = FullNames(x)
        StrainSeq(x) = FullSequences(x)
    Next x
    XX = Len(StrainSeq(0))
    Exit Sub
UnknownFormat:
    '    MsgBox ("I could not recognise this DNA alignment file format" + chr$(13) + "Send it as an attatchment to darren@molbiol.uct.ac.za")
    ErrorFlag = 1
    Screen.MousePointer = 0
    'Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Close #NF

End Sub

Public Sub LoadMSD()

    Dim LenSeg As Integer, CurrentShortest As Integer, NF As Integer
    Dim x As Long, PosN1 As Long, PosN2 As Long, LastPos As Long, OriginPos As Long, MaxNameLenPos As Long
    Dim EndLine As Byte

    DistanceFlag = 0
    NJFlag = 0
    Form1.SSPanel1.Caption = "Loading DNAMan File"
    NF = FreeFile
    Open FName$ For Binary Access Read As #NF
    VarString = String$(LOF(NF), " ")
    Get #NF, 1, VarString$
    Close #NF
    LastPos = 1
    NextNo = 0
    'put number of sequences info into the file and read it in here dickhead
    Finnish = 0
    OriginPos = InStr(LastPos, VarString, "ORIGIN", vbBinaryCompare)
    MaxNameLenPos = InStr(LastPos, VarString, "MAXNAMELEN:", vbBinaryCompare)

    If MaxNameLenPos = 0 Then
        MaxNameLenPos = 50000
    End If

    Pos = InStr(LastPos, VarString, "NUMBER:", vbBinaryCompare)

    If Pos > 0 Then
        NextNo = Int(CDbl(Mid$(VarString, Pos + 7, 3)))

        Call SeqArrays

        'Read the names of the sequences in the alignment
        Pos = InStr(LastPos, VarString, "NAMES: ", vbBinaryCompare)
        Form1.ProgressBar1.Value = 1
        Call UpdateF2Prog

        For x = 0 To NextNo - 1
            PosN1 = InStr(Pos, VarString, " ", vbBinaryCompare)
            PosN2 = InStr(PosN1 + 1, VarString, " ", vbBinaryCompare)

            If PosN2 > OriginPos Or PosN2 > MaxNameLenPos Then
                PosN2 = InStr(PosN1 + 1, VarString, Chr$(10), vbBinaryCompare) - 1
            End If

            OriginalName(x) = Mid$(VarString, PosN1 + 1, (PosN2 - PosN1) - 1)
            EndLine = Asc(Right$(OriginalName(x), 1))
            Pos = PosN2 - 1

            If EndLine = 10 Then
                OriginalName(x) = Left$(OriginalName(x), Len(OriginalName(x)) - 2)
                Pos = Pos + 7
            End If

            Form1.ProgressBar1.Value = 1 + x / (NextNo + 2) * 100 * 0.15
            Call UpdateF2Prog
        Next 'X

        'Is maxnamelen given
        
        Pos = InStr(LastPos, VarString, "MAXNAMELEN:", vbBinaryCompare)
        If Pos = 0 Then Pos = InStr(LastPos, VarString, "maxnamelen:", vbBinaryCompare)
            ZZ = Mid(VarString, Pos + 11, 4)
            
            
            CurrentShortest = val(Mid(VarString, Pos + 11, 4)) + 1
            x = x
            LenSeg = 60
        If Pos > 0 Then
        
        
        Else
        
            
            
            
            'Find distance from start of line to start of sequences.
            LastPos = InStr(OriginPos + 6, VarString, OriginalName(0), vbBinaryCompare)
            CurrentShortest = 50
            Pos = InStr(LastPos, VarString, " A", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " a", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " C", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " c", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " G", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " g", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " T", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " t", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            Pos = InStr(LastPos, VarString, " .", vbBinaryCompare)
    
            If Pos - LastPos < CurrentShortest And Pos > 0 Then CurrentShortest = Pos - LastPos
            CurrentShortest = CurrentShortest + 1
            Pos = InStr(LastPos + CurrentShortest + 5, VarString, "   ", vbBinaryCompare)
            LenSeg = Pos - (LastPos + CurrentShortest)
        End If
        
        For x = 0 To NextNo - 1
            LastPos = OriginPos

            Do
                If OriginalName(x) = "TbLCZV" Then
                    x = x
                End If
                Pos = InStr(LastPos, VarString, OriginalName(x) + " ", vbBinaryCompare)

                If Pos > 0 Then
                    StrainSeq(x) = StrainSeq(x) + Mid$(VarString, Pos + CurrentShortest, LenSeg)
                    b = Len(StrainSeq(x))
                    LastPos = Pos + (CurrentShortest + LenSeg) * NextNo
                Else
                    StrainSeq(x) = UCase$(StrainSeq(x))
                    Exit Do
                End If

            Loop

            Form1.ProgressBar1.Value = 1 + (NextNo / (NextNo + 2) + (x / NextNo) * (2 / (NextNo + 2))) * 100 * 0.3
            Call UpdateF2Prog
        Next 'X

        For x = 0 To NextNo
            ZZ = Len(StrainSeq(x))
            
            
            Do

                If Right$(StrainSeq(x), 1) = Chr$(32) Then
                    StrainSeq(x) = Left$(StrainSeq(x), Len(StrainSeq(x)) - 1)
                Else
                    Exit Do
                End If

            Loop

        Next 'X

        NextNo = NextNo - 1
        'Form1.ProgressBar1.Value = 0
    End If

End Sub

Public Function DoTreeColour(PBox As PictureBox, TType, TNum)
Dim ExtraDZ As Long, TL As Long, UB As Long, C As Long, LSeq As Long, D As Long, YPos As Long, A As Long, UBY As Long, Y As Long, x As Long, AcceptedEvent() As Byte
Dim EN As Long
Dim TH As Double, HCg As Long, QCg As Long, ECg As Long, EEcg As Long
Dim HCb As Long, QCb As Long, ECb As Long, EECb As Long
Dim HCr As Long, QCr As Long, ECr As Long, EECr As Long, DoneR As Byte, DoneG As Byte, DoneB As Byte

Dim MapBlockNumX As Long, OldFS As Single
                

'Define Colours
HCg = BkG + (220 - BkG) / 2
QCg = BkG + (220 - BkG) / 4
ECg = (BkG - (BkG) / 4)
EEcg = (BkG - (BkG) / 8)

HCb = BkB + (220 - BkB) / 2
QCb = BkB + (220 - BkB) / 4
ECb = BkB - (BkB) / 4
EECb = (BkB - (BkB) / 8)

HCr = (BkR + (220 - BkR) / 2)
QCr = (BkR + (220 - BkR) / 4)
EECr = (BkR + (220 - BkR) / 8)
ECr = BkR - (BkR) / 4


'HCg = BkG + (255 - BkG) / 2
'QCg = BkG + (255 - BkG) / 4
'ECg = BkG - (BkG) / 4
'
'HCb = BkB + (255 - BkB) / 2
'QCb = BkB + (255 - BkB) / 4
'ECb = BkB - (BkB) / 4
'
'HCr = BkR + (255 - BkR) / 2
'QCr = BkR + (255 - BkR) / 4
'ECr = BkR - (BkR) / 4


If LongWindedFlag = 0 Then
    EN = XoverList(RelX, RelY).Eventnumber
Else
    EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    
End If
ReDim ExtraD(20)
PBox.ForeColor = 0

OldFS = PBox.FontSize
PBox.FontSize = 8.25

Dim BB As Long
BB = -1




ReDim AcceptedEvent(PermNextno)
If RelX > 0 Or RelY > 0 Then
    Seq1 = XoverList(RelX, RelY).MajorP
    Seq2 = XoverList(RelX, RelY).MinorP
    Seq3 = XoverList(RelX, RelY).Daughter
    
    For x = 0 To PermNextno
        
        
        For Y = 1 To CurrentXOver(x)
            
            If SuperEventList(XoverList(x, Y).Eventnumber) = EN Then
                If Daught(EN, XoverList(x, Y).Daughter) > 0 Then
                    If XoverList(x, Y).Accept = 1 Then
                        If XoverList(x, Y).Daughter > UBound(AcceptedEvent, 1) Then
                            ReDim Preserve AcceptedEvent(XoverList(x, Y).Daughter)
                        End If
                        AcceptedEvent(XoverList(x, Y).Daughter) = 1
                    End If
                    
                    Exit For
                    
                End If
            End If
        Next Y
        
    Next x
Else
    
    Seq1 = -1
    Seq2 = -1
    Seq3 = -1

End If


'starttime = Abs(GetTickCount)

If TNum = 0 Or (TNum = 3 And (TType = 0 Or TType = 1)) Then
    
    
    UBY = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    UBY = UBound(TreeTrace, 1)
    
    On Error GoTo 0
    If UBY > 0 Then
        
        
        If Seq1 <= UBound(TreeTrace, 1) And Seq2 <= UBound(TreeTrace, 1) And Seq3 <= UBound(TreeTrace, 1) Then
            
            MapBlockNumX = 0
            'XX = NextNo
            'Call ModNextno
            For x = 0 To PermNextno '- 1
            'XX = NextNo
               
                A = x
                YPos = YCord(TType, TNum, A) - 1
                If TNum = 0 Then
                    MapBlockNumX = MapBlockNumX + 1
                    If MapBlockNumX > UBound(MapBlocks, 4) Then
                        ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                    End If
                    
                    MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
                    MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                    MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                    MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
                    MapBlockNum(TType, TNum) = MapBlockNumX
                    
                
                ElseIf x = 12345 Then
                'X = TreeTraceSeqs(1, A) '0,1,2,3,4,5,6,7,8
                    
                    A = x
                    YPos = YCord(TType, TNum, A) - 1
                    MapBlockNumX = MapBlockNumX + 1
                    If MapBlockNumX > UBound(MapBlocks, 4) Then
                        ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                    End If
                    
                    MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
                    MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                    MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                    MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(220, 220, 220) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
                   ' If X = X Then
                        D = 1
                        LSeq = Len(StrainSeq(0))
                        Do
                            
'                            If X = X Then
                            If x <= UBound(MissingData, 2) Then
                                
                                D = StartBlock(D, x, UBound(MissingData, 1), LSeq, MissingData(0, 0))
                            Else
                                Do
                                    If MissingData(D, x) = 0 Then

                                        Exit Do
                                    End If
                                    D = D + 1
                                    If D >= LSeq Then Exit Do
                                Loop
                            End If
                            If D < LSeq Then
                                MapBlockNumX = MapBlockNumX + 1
                                If MapBlockNumX > UBound(MapBlocks, 4) Then
                                    ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                                End If
                                MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
                                MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                                MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
                                C = D + 1
                                If x <= UBound(MissingData, 2) Then
                                    D = EndBlock(C, x, UBound(MissingData, 1), LSeq, MissingData(0, 0))
                                Else
                                    Do 'C = D + 1 To Len(StrainSeq(0))
                                        If MissingData(C, x) = 1 Then
                                           D = C - 1
                                           Exit Do
                                        End If

                                        C = C + 1
                                        If C >= LSeq Then
                                            D = LSeq
                                            Exit Do
                                        End If
                                    Loop
                                End If
                                
                                If D = LSeq Then
                                    MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                                Else
                                    MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(D + 1) - 1) / Decompress(Len(StrainSeq(0)))
                                End If
                            End If
                            
                            
                            D = D + 1
                            If D >= LSeq Then Exit Do
                        Loop
        '            Else
        '                For D = 1 To Len(StrainSeq(0))
        '                    If MissingData(D, X) = 0 Then
        '                        MapBlockNumX = MapBlockNumX + 1
        '                        If MapBlockNumX > UBound(MapBlocks, 4) Then
        '                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
        '                        End If
        '
        '                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
        '                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
        '                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
        '                        For C = D + 1 To Len(StrainSeq(0))
        '                            If MissingData(C, X) = 1 Then
        '                               'A = C - 1
        '                               MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(C) - 1) / Decompress(Len(StrainSeq(0)))
        '                               Exit For
        '                            End If
        '
        '                        Next C
        '                        D = C - 1
        '                        If C = Len(StrainSeq(0)) + 1 Then
        '                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
        '                        End If
        '                    End If
        '
        '                Next D
        '            End If
                    
                End If
                
                
                If DebuggingFlag < 2 Then On Error Resume Next
                UB = 0
                UB = UBound(TreeTrace, 1)
                On Error GoTo 0
                If x > UB Then Exit For
                '
                If x > PermNextno Then
                    x = x
                End If
                If TreeTrace(x) <= UBound(PermOriginalName, 1) Then
                    TL = PBox.TextWidth(PermOriginalName(TreeTrace(x))) + 2
                Else
                    TL = 20
                End If
                
                If TreeTrace(x) = SelectedSeqNumber Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 6
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 2
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 2
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 2
                    TreeBlocks(TNum, TType, 4, BB) = RGB(255, 255, 255)
                    TreeBlocks(TNum, TType, 5, BB) = x
                End If
                If TreeTrace(x) <= UBound(AcceptedEvent, 1) Then
                    If AcceptedEvent(TreeTrace(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 5
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 1
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 1
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 1
                        TreeBlocks(TNum, TType, 4, BB) = RGB(128, 0, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                    
                    End If
                ElseIf Excludetrace(TreeTrace(x)) > 0 Then 'not sure this will work - in next line may need to use excludetraace(treetrace(x))
                    If AcceptedEvent(EventsInExcludeds(3, Excludetrace(TreeTrace(x)))) = 1 Then 'if it is an excluded event then give it the accept status of the non-excluded sequence that it is most similar to
                    'If AcceptedEvent(EventsInExcludeds(3, TreeTrace(x))) = 1 Then 'if it is an excluded event then give it the accept status of the non-excluded sequence that it is most similar to
                        
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 5
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 1
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 1
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 1
                        TreeBlocks(TNum, TType, 4, BB) = RGB(128, 0, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x

                    End If
                Else
                    x = x
                End If
                On Error Resume Next
                UB = -1
                UB = UBound(TreeTrace)
                If UB < 1 Then
                    ReDim TreeTrace(PermNextno)
                    For Y = 0 To PermNextno
                        TreeTrace(Y) = Y
                    Next Y
                End If
                If Seq1 < 0 Then Exit Function
                On Error GoTo 0
                If x = TreeTrace(Seq1) Then
                    If OutsideFlagX = 1 Then
                        'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(ECr, QCg, ECb), BF
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, QCg, ECb)
                        TreeBlocks(TNum, TType, 5, BB) = x
                    Else
                        'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(0, 255, 0), BF
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 4, BB) = RGB(0, 220, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                    End If
                ElseIf x = TreeTrace(Seq2) Then
                    If OutsideFlagX = 2 Then
                        'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(ECr, ECg, QCb), BF
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, ECg, QCb)
                        TreeBlocks(TNum, TType, 5, BB) = x
                    Else
                        'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(64, 64, 255), BF
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                        TreeBlocks(TNum, TType, 4, BB) = RGB(64, 64, 220)
                        TreeBlocks(TNum, TType, 5, BB) = x
                    End If
                ElseIf x = TreeTrace(Seq3) Then
                    'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 0, 0), BF
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 4, BB) = RGB(220, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    MiddlePos(TType, TNum) = YCord(TType, TNum, TreeTrace(x))
                    
                ElseIf Daught(EN, TreeTrace(x)) = 1 Then
                    'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(220, 128, 128), BF
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 4, BB) = RGB(220, 128, 128)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    ExtraD(0) = ExtraD(0) + 1
                ElseIf Daught(EN, TreeTrace(x)) > 1 And Daught(EN, x) < 5 Then
                    'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 128, 192), BF
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 4, BB) = RGB(255, 128, 192) 'RGB(220, 128, 128)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    ExtraD(1) = ExtraD(1) + 1
                ElseIf Daught(EN, TreeTrace(x)) = 5 Then
                    'PBox.Line (XCord(TType, TNum, TreeTrace(X)) - 2, YCord(TType, TNum, TreeTrace(X)))-(XCord(TType, TNum, TreeTrace(X)) + TL, 12 + YCord(TType, TNum, TreeTrace(X))), RGB(255, 192, 192), BF
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x))
                    TreeBlocks(TNum, TType, 4, BB) = RGB(220, 192, 192)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    ExtraD(2) = ExtraD(2) + 1
                End If
                
                'PBox.DrawMode = 13
                'PBox.CurrentX = XCord(TType, TNum, TreeTrace(X))
                'PBox.CurrentY = YCord(TType, TNum, TreeTrace(X))
                'PBox.ForeColor = MultColour(TreeTrace(X))
                'PBox.Print Permoriginalname(TreeTrace(X))
                
            Next 'X
            Call UnModNextno
        End If
    Else
        'If Seq1 <= UBound(TreeTrace, 1) And Seq2 <= UBound(TreeTrace, 1) And Seq3 <= UBound(TreeTrace, 1) Then
            
            MapBlockNumX = 0
            
            For x = 0 To PermNextno '- 1
                A = x
                YPos = YCord(TType, TNum, A) - 1
                
                
                
                
                If TreeY(x) <= UBound(PermOriginalName, 1) Then
                    TL = PBox.TextWidth(PermOriginalName(TreeY(x))) + 2
                Else
                    TL = 20
                End If
                
                If TreeY(x) = SelectedSeqNumber Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeY(x)) - 6
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeY(x)) - 2
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeY(x)) + TL + 2
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeY(x)) + 2
                    TreeBlocks(TNum, TType, 4, BB) = RGB(255, 255, 255)
                    TreeBlocks(TNum, TType, 5, BB) = x
                End If
                
                
                
                


                
                'PBox.DrawMode = 13
                'PBox.CurrentX = XCord(TType, TNum, TreeTrace(X))
                'PBox.CurrentY = YCord(TType, TNum, TreeTrace(X))
                'PBox.ForeColor = MultColour(TreeTrace(X))
                'PBox.Print Permoriginalname(TreeTrace(X))
                
            Next 'X
        
        'End If
    End If
Else
    If TNum = 3 And (TType = 2 Or TType = 3 Or TType = 4) Then
        If NextNo = -1 Then
            DoneTree(4, 3) = 0
            DoTreeColour = 0
            Exit Function
        End If
        'Call ModSeqNum(0, 0, 0)
        For A = 0 To UBound(BigTreeName, 1)
            x = A
            
            YPos = YCord(TType, TNum, A) - 1
            MapBlockNumX = MapBlockNumX + 1
            If MapBlockNumX > UBound(MapBlocks, 4) Then
                ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
            End If
            
            MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
            MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
            MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(220, 220, 220) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
            'If X = X Then
                D = 1
                LSeq = Len(StrainSeq(0))
               
                Do
                    
                    
                    If x = x Then
                        D = StartBlock(D, x, UBound(btMissingData, 1), LSeq, btMissingData(0, 0))
                    Else
                        Do
                            If btMissingData(D, x) = 0 Then

                                Exit Do
                            End If
                            D = D + 1
                            If D >= LSeq Then Exit Do
                        Loop
                    End If
                    If D < LSeq Then
                        MapBlockNumX = MapBlockNumX + 1
                        If MapBlockNumX > UBound(MapBlocks, 4) Then
                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                        End If
                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
                        C = D + 1
                        If x = x Then
                            D = EndBlock(C, x, UBound(btMissingData, 1), LSeq, btMissingData(0, 0))
                        Else
                            Do 'C = D + 1 To Len(StrainSeq(0))
                                If btMissingData(C, x) = 1 Then
                                   D = C - 1
                                   Exit Do
                                End If

                                C = C + 1
                                If C >= LSeq Then
                                    D = LSeq
                                    Exit Do
                                End If
                            Loop
                        End If

                        If D = LSeq Then
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                        Else
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(D + 1) - 1) / Decompress(Len(StrainSeq(0)))
                        End If
                    End If
                    
                    
                    D = D + 1
                    If D >= LSeq Then Exit Do
                Loop
'            Else
'                For D = 1 To Len(StrainSeq(0))
'                    If MissingData(D, X) = 0 Then
'                        MapBlockNumX = MapBlockNumX + 1
'                        If MapBlockNumX > UBound(MapBlocks, 4) Then
'                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
'                        End If
'
'                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
'                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
'                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
'                        For C = D + 1 To Len(StrainSeq(0))
'                            If MissingData(C, X) = 1 Then
'                               'A = C - 1
'                               MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(C) - 1) / Decompress(Len(StrainSeq(0)))
'                               Exit For
'                            End If
'
'                        Next C
'                        D = C - 1
'                        If C = Len(StrainSeq(0)) + 1 Then
'                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
'                        End If
'                    End If
'
'                Next D
'            End If
            MapBlockNum(TType, TNum) = MapBlockNumX
            TL = PBox.TextWidth(BigTreeName(x)) + 2
            TH = PBox.TextHeight(BigTreeName(x))
            
            'PBox.DrawMode = 13
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), BackColours, BF
            'PBox.DrawMode = 9
            If BigTreeTrace(x) = SelectedSeqNumber Then
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 6
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 2
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 2
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 2
                TreeBlocks(TNum, TType, 4, BB) = RGB(255, 255, 255)
                TreeBlocks(TNum, TType, 5, BB) = x
            End If
            If AcceptedEvent(BigTreeTrace(x)) = 1 Then
                If EN = BigTreeTraceEvent(x) Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2 - 1
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x) - 1
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL + 1
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x) + 1
                    TreeBlocks(TNum, TType, 4, BB) = RGB(128, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
                End If
            End If
            
            
            If x = BTSeq1 And (RelX > 0 Or RelY > 0) Then
                    
                    If OutsideFlagX = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, QCg, ECb)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, QCg, ECb), BF
                    Else
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(0, 220, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(0, 255, 0), BF
                    End If
                'X = X
            ElseIf x = BTSeq2 And (RelX > 0 Or RelY > 0) Then
                If OutsideFlagX = 2 Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, ECg, QCb)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, ECg, QCb), BF
                Else
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(64, 64, 220)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(64, 64, 255), BF
                End If
            ElseIf BigTreeTrace(x) = BigTreeTrace(BTSeq3) And (RelX > 0 Or RelY > 0) Then
                
                If x = BTSeq3 Then
                
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(196, 64, 0) 'RGB(255, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 0, 0), BF
                    MiddlePos(TType, TNum) = YCord(TType, TNum, x)
                    ExtraD(3) = ExtraD(3) + 1
                ElseIf EN = BigTreeTraceEvent(x) Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(220, 0, 128) 'RGB(255, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 0, 0), BF
                ElseIf x = 123345 Then
                    If Daught(EN, BigTreeTrace(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 150, 80) 'RGB(196, 64, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                        ExtraD(0) = ExtraD(0) + 1
                    ElseIf Daught(EN, BigTreeTrace(x)) > 1 And Daught(EN, BigTreeTrace(x)) < 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 128, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                        ExtraD(1) = ExtraD(1) + 1
                    ElseIf Daught(EN, BigTreeTrace(x)) = 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 196, 128)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                        ExtraD(2) = ExtraD(2) + 1
                    End If
                End If
            ElseIf Daught(EN, BigTreeTrace(x)) > 0 And (RelX > 0 Or RelY > 0) Then
                If EN = BigTreeTraceEvent(x) Then
                    If Daught(EN, BigTreeTrace(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 64, 128)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                        ExtraD(0) = ExtraD(0) + 1
                    ElseIf Daught(EN, BigTreeTrace(x)) > 1 And Daught(EN, BigTreeTrace(x)) < 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 64, 192)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                        ExtraD(1) = ExtraD(1) + 1
                    ElseIf Daught(EN, BigTreeTrace(x)) = 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 128, 192)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                        ExtraD(2) = ExtraD(2) + 1
                    
                    End If
                ElseIf x = 12345 Then
                    If Daught(EN, BigTreeTrace(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 150, 80) 'RGB(196, 64, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                        ExtraD(0) = ExtraD(0) + 1
                    ElseIf Daught(EN, BigTreeTrace(x)) > 1 And Daught(EN, BigTreeTrace(x)) < 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 128, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                        ExtraD(1) = ExtraD(1) + 1
                    ElseIf Daught(EN, BigTreeTrace(x)) = 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 196, 128)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                        ExtraD(2) = ExtraD(2) + 1
                    End If
                Else
                    
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(255, 220, 150)
                    TreeBlocks(TNum, TType, 5, BB) = x
                End If
            End If
            
            'PBox.DrawMode = 13
            'PBox.CurrentX = XCord(TType, TNum, X)
            'PBox.CurrentY = YCord(TType, TNum, X)
            'PBox.ForeColor = MultColour(TreeTrace(bigtreetrace( X)))
            'PBox.ForeColor = RGB(255, 0, 0)
            'If DebuggingFlag < 2 Then On Error Resume Next
            'PBox.print bigtreename(X)
            'On Error GoTo 0
             PBox.ForeColor = 0
            'If bigtreename(TreeTrace(bigtreetrace( X))) <> bigtreename(X) Then
            '    X = X
            'End If
        Next 'X
        TBLen(TNum, TType) = BB
       ' On Error GoTo 0
    ElseIf TNum = 3 And TType = 1 Then
        'If DebuggingFlag < 2 Then On Error Resume Next
        For A = 0 To UBound(BigTreeNameU, 1)
            x = A 'BigTreeTraceU(A)
            
            
            'X = TreeTraceSeqs(1, A) '0,1,2,3,4,5,6,7,8
            
            YPos = YCord(TType, TNum, A) - 1
            MapBlockNumX = MapBlockNumX + 1
            If MapBlockNumX > UBound(MapBlocks, 4) Then
                ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
            End If
            
            MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
            MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
            MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(220, 220, 220) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
            'If X = X Then
                D = 1
                LSeq = Len(StrainSeq(0))
                Do
                    
                    If x = x Then
                        D = StartBlock(D, x, UBound(btMissingData, 1), LSeq, btMissingData(0, 0))
                    Else
                        Do
                            If btMissingData(D, x) = 0 Then

                                Exit Do
                            End If
                            D = D + 1
                            If D >= LSeq Then Exit Do
                        Loop
                    End If
                    If D < LSeq Then
                        MapBlockNumX = MapBlockNumX + 1
                        If MapBlockNumX > UBound(MapBlocks, 4) Then
                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                        End If
                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
                        C = D + 1
                        If x <= UBound(MissingData, 1) Then

                            D = EndBlock(C, x, UBound(btMissingData, 1), LSeq, btMissingData(0, 0))
                        Else
                            Do 'C = D + 1 To Len(StrainSeq(0))
                                If btMissingData(C, x) = 1 Then
                                   D = C - 1
                                   Exit Do
                                End If

                                C = C + 1
                                If C >= LSeq Then
                                    D = LSeq
                                    Exit Do
                                End If
                            Loop
                        End If
                        
                        If D = LSeq Then
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                        Else
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(D + 1) - 1) / Decompress(Len(StrainSeq(0)))
                        End If
                    End If
                    
                    
                    D = D + 1
                    If D >= LSeq Then Exit Do
                Loop
'            Else
'                For D = 1 To Len(StrainSeq(0))
'                    If MissingData(D, X) = 0 Then
'                        MapBlockNumX = MapBlockNumX + 1
'                        If MapBlockNumX > UBound(MapBlocks, 4) Then
'                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
'                        End If
'
'                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
'                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
'                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
'                        For C = D + 1 To Len(StrainSeq(0))
'                            If MissingData(C, X) = 1 Then
'                               'A = C - 1
'                               MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(C) - 1) / Decompress(Len(StrainSeq(0)))
'                               Exit For
'                            End If
'
'                        Next C
'                        D = C - 1
'                        If C = Len(StrainSeq(0)) + 1 Then
'                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
'                        End If
'                    End If
'
'                Next D
'            End If
            MapBlockNum(TType, TNum) = MapBlockNumX
            
            x = A
            TL = PBox.TextWidth(BigTreeNameU(x)) + 2
            TH = PBox.TextHeight(BigTreeNameU(x))
            
            'PBox.DrawMode = 13
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), BackColours, BF
            'PBox.DrawMode = 9
            
            If BigTreeTraceU(x) = SelectedSeqNumber Then
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 6
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 2
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 2
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 2
                TreeBlocks(TNum, TType, 4, BB) = RGB(255, 255, 255)
                TreeBlocks(TNum, TType, 5, BB) = x
            End If
            
            If AcceptedEvent(BigTreeTraceU(x)) = 1 Then
                If EN = BigTreeTraceEventU(x) Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2 - 1
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x) - 1
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL + 1
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x) + 1
                    TreeBlocks(TNum, TType, 4, BB) = RGB(128, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
            
                End If
           
            End If
            
            If x = BTSeq1 Then
                    
                    If OutsideFlagX = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, QCg, ECb)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, QCg, ECb), BF
                    Else
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(0, 220, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(0, 255, 0), BF
                    End If
                'X = X
            ElseIf x = BTSeq2 Then
                If OutsideFlagX = 2 Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, ECg, QCb)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, ECg, QCb), BF
                Else
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(64, 64, 220)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(64, 64, 255), BF
                End If
            ElseIf BigTreeTraceU(x) = BigTreeTraceU(BTSeq3) Then
                
                If x = BTSeq3 Then
                
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(196, 64, 0) 'RGB(255, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 0, 0), BF
                    MiddlePos(TType, TNum) = YCord(TType, TNum, x)
                    ExtraD(3) = ExtraD(3) + 1
                ElseIf EN = BigTreeTraceEventU(x) Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(220, 0, 128) 'RGB(255, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 0, 0), BF
                
                
                ElseIf x = 123345 Then
                    If Daught(EN, BigTreeTraceU(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 150, 80) 'RGB(196, 64, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                        ExtraD(0) = ExtraD(0) + 1
                    ElseIf Daught(EN, BigTreeTraceU(x)) > 1 And Daught(EN, BigTreeTraceU(x)) < 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 128, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                        ExtraD(1) = ExtraD(1) + 1
                    ElseIf Daught(EN, BigTreeTraceU(x)) = 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 196, 128)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                        ExtraD(2) = ExtraD(2) + 1
                    End If
                End If
                'XX = PermNextno
            ElseIf Daught(EN, BigTreeTraceU(x)) > 0 Then
                'Exit Function
                If EN = BigTreeTraceEventU(x) Then
                    If Daught(EN, BigTreeTraceU(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        If x <= UBound(XCord, 3) Then
                            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                            TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                            TreeBlocks(TNum, TType, 4, BB) = RGB(196, 64, 128)
                            TreeBlocks(TNum, TType, 5, BB) = x
                        End If
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                        ExtraD(0) = ExtraD(0) + 1
                    ElseIf Daught(EN, BigTreeTraceU(x)) > 1 And Daught(EN, BigTreeTraceU(x)) < 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        If x <= UBound(XCord, 3) Then
                            TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                            TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                            TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                            TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                            TreeBlocks(TNum, TType, 4, BB) = RGB(196, 64, 192)
                            TreeBlocks(TNum, TType, 5, BB) = x
                        End If
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                        ExtraD(1) = ExtraD(1) + 1
                    ElseIf Daught(EN, BigTreeTraceU(x)) = 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 128, 192)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                        ExtraD(2) = ExtraD(2) + 1
                    End If
                ElseIf x = 12345 Then
                    If Daught(EN, BigTreeTraceU(x)) = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 150, 80) 'RGB(196, 64, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                        ExtraD(0) = ExtraD(0) + 1
                    ElseIf Daught(EN, BigTreeTraceU(x)) > 1 And Daught(EN, BigTreeTraceU(x)) < 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(196, 128, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                        ExtraD(1) = ExtraD(1) + 1
                    ElseIf Daught(EN, BigTreeTraceU(x)) = 5 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(255, 196, 128)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                        ExtraD(2) = ExtraD(2) + 1
                    End If
                Else
                    
                    
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(255, 220, 150)
                    TreeBlocks(TNum, TType, 5, BB) = x
                End If
            End If
            
            'PBox.DrawMode = 13
            'PBox.CurrentX = XCord(TType, TNum, X)
            'PBox.CurrentY = YCord(TType, TNum, X)
            'PBox.ForeColor = MultColour(TreeTrace(bigtreetrace( X)))
            'PBox.ForeColor = RGB(255, 0, 0)
            'If DebuggingFlag < 2 Then On Error Resume Next
            'PBox.print bigtreename(X)
            'On Error GoTo 0
             PBox.ForeColor = 0
            'If bigtreename(TreeTrace(bigtreetrace( X))) <> bigtreename(X) Then
            '    X = X
            'End If
        Next 'X
        TBLen(TNum, TType) = BB
    Else
    
        If DebuggingFlag < 2 Then On Error Resume Next
        On Error GoTo 0
        'XX = PermNextno
        'XX = Nextno
        
        
        MapBlockNumX = 0
        'XX = PermNextno ' MissingData(500, 8)
        
        'SS = Abs(GetTickCount)
        'ModNextno
        For A = 0 To NextNo '- 1
'        If A = 1017 Then
'            x = x
'        End If
        'XX = UBound(MissingData, 2)
            x = TreeTraceSeqs(1, A) '0,1,2,3,4,5,6,7,8
            
            YPos = YCord(TType, TNum, A) - 1
            MapBlockNumX = MapBlockNumX + 1
            If MapBlockNumX > UBound(MapBlocks, 4) Then
                ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
            End If
            
            MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
            MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
            MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(220, 220, 220) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
            If x = x Then
                D = 1
                LSeq = Len(StrainSeq(0))
                Do
                    
                    If x = x Then
                        D = StartBlock(D, x, UBound(MissingData, 1), LSeq, MissingData(0, 0))
                    Else
                        Do
                            If MissingData(D, x) = 0 Then
                                
                                Exit Do
                            End If
                            D = D + 1
                            If D >= LSeq Then Exit Do
                        Loop
                    End If
                    If D < LSeq Then
                        MapBlockNumX = MapBlockNumX + 1
                        If MapBlockNumX > UBound(MapBlocks, 4) Then
                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                        End If
                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
                        C = D + 1
                        If x = x Then
                            '
                            D = EndBlock(C, x, UBound(MissingData, 1), LSeq, MissingData(0, 0))
                            x = x
                            
                        Else
                            Do 'C = D + 1 To Len(StrainSeq(0))
                                If MissingData(C, x) = 1 Then
                                   D = C - 1
                                   Exit Do
                                End If
                                
                                C = C + 1
                                If C >= LSeq Then
                                    D = LSeq
                                    Exit Do
                                End If
                            Loop
                        End If
                        
                        If D = LSeq Then
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                        Else
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(D + 1) - 1) / Decompress(Len(StrainSeq(0)))
                        End If
                    End If
                    
                    
                    D = D + 1
                    If D >= LSeq Then Exit Do
                Loop
            Else
                For D = 1 To Len(StrainSeq(0))
                    If MissingData(D, x) = 0 Then
                        MapBlockNumX = MapBlockNumX + 1
                        If MapBlockNumX > UBound(MapBlocks, 4) Then
                            ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
                        End If
                        
                        MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
                        MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
                        MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
                        For C = D + 1 To Len(StrainSeq(0))
                            If MissingData(C, x) = 1 Then
                               'A = C - 1
                               MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(C) - 1) / Decompress(Len(StrainSeq(0)))
                               Exit For
                            End If
                            
                        Next C
                        D = C - 1
                        If C = Len(StrainSeq(0)) + 1 Then
                            MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
                        End If
                    End If
                    
                Next D
            End If
            MapBlockNum(TType, TNum) = MapBlockNumX
            x = A
            
'            If x = 500 Then
'            x = x
'            End If
            XX = NextNo
            If ExcludedEventNum = 0 Then
                If OriginalName((TreeTraceSeqs(1, x))) <> "Unknown" Then
                    TL = PBox.TextWidth(OriginalName((TreeTraceSeqs(1, x)))) + 2
                Else
                    If TreeTraceSeqs(1, x) <= UBound(StraiName) Then
                        TL = PBox.TextWidth(StraiName((TreeTraceSeqs(1, x)))) + 2
                    Else
                        If x <= UBound(StraiName) Then
                            TL = PBox.TextWidth(StraiName(x)) + 2
                        End If
                    End If
                End If
            Else
                If PermOriginalName((TreeTraceSeqs(1, x))) <> "Unknown" Then
                    TL = PBox.TextWidth(PermOriginalName((TreeTraceSeqs(1, x)))) + 2
                Else
                    If TreeTraceSeqs(1, x) <= UBound(StraiName) Then
                        TL = PBox.TextWidth(StraiName((TreeTraceSeqs(1, x)))) + 2
                    Else
                        If x <= UBound(StraiName) Then
                            TL = PBox.TextWidth(StraiName(x)) + 2
                        End If
                    End If
                End If
            
            End If
            TH = PBox.TextHeight(OriginalName(x))
            
            'PBox.DrawMode = 13
            'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), BackColours, BF
            'PBox.DrawMode = 9
            'XX = PermNextno
            If TreeTrace(TreeTraceSeqs(1, x)) = SelectedSeqNumber Then '526,642
                BB = BB + 1
                
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                If XCord(TType, TNum, TreeTrace(x)) > 0 Then
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 6
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 2
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 2
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 2
                    TreeBlocks(TNum, TType, 4, BB) = RGB(255, 255, 255)
                    TreeBlocks(TNum, TType, 5, BB) = x
                End If
            End If
           
            If UBound(AcceptedEvent, 1) >= TreeTrace(TreeTraceSeqs(1, x)) And Excludetrace(TreeTrace(TreeTraceSeqs(1, x))) = 0 Then
                If AcceptedEvent(TreeTrace(TreeTraceSeqs(1, x))) = 1 Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 5
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x) - 1
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL + 1
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x) + 1
                    TreeBlocks(TNum, TType, 4, BB) = RGB(128, 0, 0)
                    TreeBlocks(TNum, TType, 5, BB) = x
'                    For Z = 0 To NextNo
'                        If Excludetrace(TreeTrace(TreeTraceSeqs(1, Z))) > 0 Then
'                            X = X
'                            XX = EventsInExcludeds(3, Excludetrace(TreeTrace(TreeTraceSeqs(1, Z))))
'                        End If
'                    Next Z
'                    X = X
                End If
                
           ' Else
           '     X = X
            ElseIf Excludetrace(TreeTrace(TreeTraceSeqs(1, x))) > 0 Then
                    If AcceptedEvent(EventsInExcludeds(3, Excludetrace(TreeTrace(TreeTraceSeqs(1, x))))) = 1 Then 'if it is an excluded event then give it the accept status of the non-excluded sequence that it is most similar to
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, TreeTrace(x)) - 5
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, TreeTrace(x)) - 1
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, TreeTrace(x)) + TL + 1
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, TreeTrace(x)) + 1
                        TreeBlocks(TNum, TType, 4, BB) = RGB(128, 0, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                    
                    End If
                
            End If
            'If X = 14 Then
            '    X = X
            '    'XX = TreeTrace(28)
            'End If
            'XX = Seq3
            
            
            
            
            If TreeTrace(TreeTraceSeqs(1, x)) = Seq1 And DoneG = 0 Then
                    DoneG = 1
                    If OutsideFlagX = 1 Then
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, QCg, ECb)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, QCg, ECb), BF
                    Else
                        BB = BB + 1
                        If UBound(TreeBlocks, 4) < BB Then
                            ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                        End If
                        TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                        TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                        TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                        TreeBlocks(TNum, TType, 4, BB) = RGB(0, 220, 0)
                        TreeBlocks(TNum, TType, 5, BB) = x
                        'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(0, 255, 0), BF
                    End If
                'X = X
            ElseIf TreeTrace(TreeTraceSeqs(1, x)) = Seq2 And DoneB = 0 Then
                DoneB = 1
                If OutsideFlagX = 2 Then
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(ECr, ECg, QCb)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(ECr, ECg, QCb), BF
                Else
                    BB = BB + 1
                    If UBound(TreeBlocks, 4) < BB Then
                        ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                    End If
                    TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                    TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                    TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                    TreeBlocks(TNum, TType, 4, BB) = RGB(64, 64, 220)
                    TreeBlocks(TNum, TType, 5, BB) = x
                    'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(64, 64, 255), BF
                End If
            ElseIf TreeTrace(TreeTraceSeqs(1, x)) = Seq3 And DoneR = 0 Then
                DoneR = 1
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL '287,287\
                'XX = TreeBlocks(TNum, TType, 2, BB) - TreeBlocks(TNum, TType, 0, BB)
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 4, BB) = RGB(220, 0, 0)
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 0, 0), BF
                MiddlePos(TType, TNum) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 5, BB) = x
            ElseIf Daught(EN, TreeTrace(TreeTraceSeqs(1, x))) = 1 And TreeTrace(TreeTraceSeqs(1, x)) <> Seq3 Then
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                
                    TreeBlocks(TNum, TType, 4, BB) = RGB(220, 128, 128)
                
                TreeBlocks(TNum, TType, 5, BB) = x
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(220, 128, 128), BF
                ExtraD(0) = ExtraD(0) + 1
            ElseIf Daught(EN, TreeTrace(TreeTraceSeqs(1, x))) > 1 And Daught(EN, TreeTrace(TreeTraceSeqs(1, x))) < 5 Then
                BB = BB + 1
                
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 4, BB) = RGB(255, 128, 192)
                TreeBlocks(TNum, TType, 5, BB) = x
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 128, 192), BF
                ExtraD(1) = ExtraD(1) + 1
            ElseIf Daught(EN, TreeTrace(TreeTraceSeqs(1, x))) = 5 Then
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 4, BB) = RGB(220, 192, 192)
                TreeBlocks(TNum, TType, 5, BB) = x
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                ExtraD(2) = ExtraD(2) + 1
            ElseIf Daught(EN, TreeTrace(TreeTraceSeqs(1, x))) = 6 Then
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 4, BB) = RGB(220, 170, 230)
                TreeBlocks(TNum, TType, 5, BB) = x
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                ExtraD(20) = ExtraD(20) + 1
            ElseIf Daught(EN, TreeTrace(TreeTraceSeqs(1, x))) = 7 Then
                BB = BB + 1
                If UBound(TreeBlocks, 4) < BB Then
                    ReDim Preserve TreeBlocks(3, 4, 5, BB + 10)
                End If
                TreeBlocks(TNum, TType, 0, BB) = XCord(TType, TNum, x) - 2
                TreeBlocks(TNum, TType, 1, BB) = YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 2, BB) = XCord(TType, TNum, x) + TL
                TreeBlocks(TNum, TType, 3, BB) = 12 + YCord(TType, TNum, x)
                TreeBlocks(TNum, TType, 4, BB) = RGB(220, 170, 230) 'RGB(190, 190, 190)
                TreeBlocks(TNum, TType, 5, BB) = x
                'PBox.Line (XCord(TType, TNum, X) - 2, YCord(TType, TNum, X))-(XCord(TType, TNum, X) + TL, TH + YCord(TType, TNum, X)), RGB(255, 192, 192), BF
                ExtraD(20) = ExtraD(20) + 1
            End If
            
            'PBox.DrawMode = 13
            'PBox.CurrentX = XCord(TType, TNum, X)
            'PBox.CurrentY = YCord(TType, TNum, X)
            'PBox.ForeColor = MultColour(TreeTrace(TreeTraceSeqs(1, X)))
            'PBox.ForeColor = RGB(255, 0, 0)
            'If DebuggingFlag < 2 Then On Error Resume Next
            'PBox.print originalname(X)
            'On Error GoTo 0
             PBox.ForeColor = 0
            'If originalname(TreeTrace(TreeTraceSeqs(1, X))) <> originalname(X) Then
            '    X = X
            'End If
        Next 'X
        'UnModNextno
        MapBlockNum(TNum, TType) = MapBlockNumX
        TBLen(TNum, TType) = BB
        On Error GoTo 0
    
    
    End If

    
    
End If


'ubD = UBound(MapBlocks, 4)
'ubA = UBound(MapBlocks, 1)
'ubB = UBound(MapBlocks, 2)
'ubC = UBound(MapBlocks, 3)
'
'ReDim MapBlocksR(ubC, ubD, ubA, ubB)
'For A = 0 To ubA
'    For B = 0 To ubB
'        For C = 0 To ubC
'            For D = 0 To ubD
'                MapBlocksR(C, D, A, B) = MapBlocks(A, B, C, D)
'            Next D
'        Next C
'    Next B
'Next A



'EE = Abs(GetTickCount)
'TT = EE - starttime
TBLen(TNum, TType) = BB
PBox.ForeColor = QBColor(0)
PBox.FontSize = OldFS
ExtraDZ = ExtraD(0)
DoTreeColour = ExtraDZ
End Function

Public Sub RecUPGMAII()
'tree derived from minor parent
    Dim TType As Long, TNum As Long, CycleX As Long, Dummy As Long, UB1 As Long, UB2 As Long, FF As Long, oDirX As String, XInstance() As Integer, Check() As Long
    Dim AdjYD As Integer, SortedNo As Long, MultiInclude As Integer
    Dim cXi As Long, LSeq As Long, x As Long, Z As Long, Y As Long, NodeAdjust As Long
    Dim NodeLengthB() As Double, ValidSite() As Single, NJSubDistance() As Single, CurLen() As Double
    Dim OldFontSize As Double, FirstPos As Double, FormerXPos As Double, ShortestDistance As Single
    
    Dim TempName() As String

    If NextNo <= 0 Then Exit Sub
    
    ReDim NodeLengthB(NextNo + 1), Check(NextNo)
    ReDim NodeYPos(NextNo)
    
    
    If NextNo = -1 Then Exit Sub
    LSeq = Len(StrainSeq(0))
    
    

    Form1.Picture16.FontSize = 8.25
    'Make sub sequences
    'First make small recombinant section
    'PPAVal = 1
    
    ReDim NJSubDistance(NextNo, NextNo)
    
    If TreeMatrixInFileFLag = 1 Then
        ReDim NJSubDistance(UBTreeMatrix, UBTreeMatrix)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5TreeSMat" + UFTag For Binary As #FF
        Get #FF, , NJSubDistance()
        Close #FF
    Else
    
        If DebuggingFlag < 2 Then On Error Resume Next
        UB1 = -1
        UB1 = UBound(TreeSMat, 1): UB2 = UBound(TreeSMat, 2)
        If UB1 = -1 Then
            Exit Sub
        End If
        On Error GoTo 0
        
        If UB1 >= NextNo And UB1 >= NextNo Then
            'UB1 = UBound(TreeSMat, 1): UB2 = UBound(TreeSMat, 2)
        
            Dummy = CopySingleArray(NextNo, NextNo, UB1, UB2, NextNo, NextNo, TreeSMat(0, 0), NJSubDistance(0, 0))
        End If
    End If
    
    Call MakeSeqCoverage(0, SubValid())
    
    
    ReDim TreeRY(NextNo)
    ReDim XInstance(NextNo + 1)
    ReDim TempName(NextNo)
    ReDim CurLen(NextNo)
    
    'Initialise the tree array
    ReDim TreeRX(NextNo, NextNo) 'this is a funny size because it means that the edges of the array remain unfilled
    ''
    'SS = abs(gettickcount)
    For x = 0 To NextNo
        For Y = 0 To NextNo
            TreeRX(x, Y) = -1
        Next 'Y
    Next 'X
'    EE = abs(gettickcount)
'    TT = EE - SS
    'Fred event 2 32,47,46,32
    For x = 0 To NextNo
        TempName(x) = OriginalName(x)
    Next 'X

    'Draw the tree in memory
    'Dim OldX(0) As Long
    'scen through the distance matrix and build the first distmap - this speeds up shortestdistb
    Dim DistMap() As Single, WinningX() As Long
    ReDim DistMap(NextNo), WinningX(NextNo)
    Dummy = MakeDistMapX(NextNo, DistMap(0), NJSubDistance(0, 0), WinningX(0))
    
    'OldX(0) = 0
    'CycleX = 0
    
    'SS = abs(gettickcount)
    Do Until SortedNo = NextNo
        
        
        'ShortestDistance2 = ShortestDist(Nextno, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))
        If DebuggingFlag < 2 Then On Error Resume Next
        '
        ShortestDistance = ShortestDistB(NextNo, SortedNo, DistMap(0), WinningX(0), NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))
        On Error GoTo 0
        
        
        If ShortestDistance = 1 Then
            ShortestDistance = 100
            For x = 0 To NextNo
                For Y = x + 1 To NextNo
                    If NJSubDistance(x, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(x, Y)
                        TreeRX(SortedNo, 0) = x
                        TreeRY(SortedNo) = Y
                    End If
                Next 'Y
            Next 'X
        End If
        
        Dim TD As Double, TDS As String, TDS2 As String
        
        NodeLengthB(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        
        'build Newick string
         TD = NodeLengthB(SortedNo) - CurLen(TreeRX(SortedNo, 0))
        TD = CLng(TD * 10000) / 10000
        TDS = Trim$(CStr(TD))
        If TDS = "0" Then TDS = "0.0000"
        
        Pos = InStr(1, TDS, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TDS, Pos, 1) = "."
        End If
        
        TD = NodeLengthB(SortedNo) - CurLen(TreeRY(SortedNo))
        TD = CLng(TD * 10000) / 10000
        TDS2 = Trim$(CStr(TD))
        If TDS2 = "0" Then TDS2 = "0.0000"
        
        Pos = InStr(1, TDS2, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TDS2, Pos, 1) = "."
        End If
        TempName(TreeRX(SortedNo, 0)) = "(" + TempName(TreeRX(SortedNo, 0)) + ":" + TDS + "," + TempName(TreeRY(SortedNo)) + ":" + TDS2 + ")"
        CurLen(TreeRX(SortedNo, 0)) = NodeLengthB(SortedNo)
        
        'If X = X Then
        ''''
            Dummy = AddSeqToUPGMA2(NextNo, SortedNo, XInstance(0), NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0), Check(0), NodeYPos(0))
            x = x
'        Else
'
'            For X = 0 To Nextno
'
'                If X <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> X Then
'
'                    NJSubDistance(TreeRX(SortedNo, 0), X) = (NJSubDistance(TreeRX(SortedNo, 0), X) + NJSubDistance(TreeRY(SortedNo), X)) / 2
'
'                    NJSubDistance(X, TreeRX(SortedNo, 0)) = NJSubDistance(TreeRX(SortedNo, 0), X) '(NJSubDistance(X, TreeRX(SortedNo, 0)) + NJSubDistance(X, TreeRY(SortedNo))) / 2
'                ElseIf X = TreeRX(SortedNo, 0) Then
'
'                    If XInstance(TreeRX(SortedNo, 0)) > 0 Then
'                        'Find last instance including x
'
'                        For Z = SortedNo - 1 To 0 Step -1
'
'                            If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
'                                MultiInclude = Z
'                                Exit For
'                            End If
'
'                        Next 'Z
'
'                        cXi = XInstance(TreeRX(SortedNo, 0))
'
'                        For Z = 0 To cXi
'                            TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
'                        Next 'Z
'
'                    End If
'
'                    If XInstance(TreeRY(SortedNo)) > 0 Then ' If "sequence y" is actually a node
'                        'Finds last node including y
'
'                        For Z = SortedNo - 1 To 0 Step -1
'
'                            If TreeRX(Z, 0) = TreeRY(SortedNo) Then
'                                MultiInclude = Z
'                                Exit For
'                            End If
'
'                        Next 'Z
'
'                        cXi = XInstance(TreeRY(SortedNo))
'                        'Adds sequences in node y to node x
'
'                        For Z = 0 To cXi
'                            XInstance(X) = XInstance(X) + 1
'                            TreeRX(SortedNo, XInstance(X)) = TreeRX(MultiInclude, Z)
'                        Next 'Z
'
'                    Else
'                        XInstance(X) = XInstance(X) + 1
'                        TreeRX(SortedNo, XInstance(X)) = TreeRY(SortedNo)
'                    End If
'
'                End If
'
'            Next 'X
'
'            For X = 0 To Nextno
'
'                If X <> TreeRY(SortedNo) Then
'                    NJSubDistance(TreeRY(SortedNo), X) = 100
'                    NJSubDistance(X, TreeRY(SortedNo)) = 100
'                End If
'
'            Next 'X
'        End If
        
        'update distmap
        x = TreeRX(SortedNo, 0)
        Z = TreeRY(SortedNo)
        DistMap(x) = 100
        DistMap(TreeRY(SortedNo)) = 100
        
'        If X = X Then
        
            Dummy = UpdateDistMapX(x, Z, NextNo, DistMap(0), NJSubDistance(0, 0), WinningX(0))
'        Else
'
'            For Y = 0 To Nextno
'                If X <> Y And Z <> Y Then
'                    If DistMap(X) > NJSubDistance(X, Y) Then
'                        DistMap(X) = NJSubDistance(X, Y)
'                        WinningX(X) = Y
'                    End If
'                    'recalculate affected distmap entries
'                    If WinningX(Y) = X Or WinningX(Y) = Z Then
'                        If DistMap(Y) < 100 Then
'                            DistMap(Y) = 100
'                            For A = 0 To Nextno
'                                If A <> Y Then
'                                    If DistMap(Y) > NJSubDistance(A, Y) Then
'                                        DistMap(Y) = NJSubDistance(A, Y)
'                                        WinningX(Y) = A
'                                    End If
'                                End If
'                            Next A
'                        End If
'                        X = X
'                    End If
'
'                End If
'
'            Next Y
'        End If
        
        
        
        SortedNo = SortedNo + 1
        CycleX = CycleX + 1
    Loop
  '  For X = 0 To Nextno
  '      XX = TreeRY(X)
  '      For Y = 0 To Nextno
  '          XX = TreeRX(X, Y)
  '      Next Y
  '
  '  Next X
    NHString(TreeTypeFlag) = TempName(TreeRX(SortedNo - 1, 0)) + ";"
    NHComp(1) = NHString(TreeTypeFlag)
    Pos = InStr(1, NHString(TreeTypeFlag), "E-", vbBinaryCompare)
        
   'EE = abs(gettickcount)
   'TT = EE - SS
   '125 freds 3800 seq alignment
   x = x
        
        
        
    'Draw tree
    
    AdjYD = 14
    Form1.Picture16.FontSize = 8.25
    OldFontSize = Form1.Picture16.FontSize

    Call TreeFont(2)

    If NodeLengthB(NextNo - 1) > 0 Then
        NodeAdjust = (TRegion - 10) / NodeLengthB(NextNo - 1)
    Else
        NodeAdjust = (TRegion - 10) / 0.00001
    End If

    FirstPos = CInt(TRegion) - 5
    'Write sequence names
    Dim EN As Long
    Dim ExtraDX As Long
    
    ExtraDX = 0
    
    
    

    'Draw the tree to the screen
    Dim NodeFind() As Byte
    '@
    If PermNextno > NextNo Then
        ReDim NodeFind(PermNextno + 2, PermNextno + 2)
    Else
        ReDim NodeFind(NextNo + 2, NextNo + 2)
    End If
    If UBound(NodeFind, 1) < UBound(TreeTraceSeqs, 2) Then
        ReDim NodeFind(UBound(TreeTraceSeqs, 2), UBound(TreeTraceSeqs, 2))
    End If
    'XX = UBound(TreeTraceSeqs, 2)
    Call UPGMADraw(TreeTrace(), TreeTraceSeqs(), PermNextno, NodeFind(), NodeXY(), 0, 2, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    ExtraDX = DoTreeColour(Form1.Picture16, 0, 2)
    For TNum = 0 To 2
        For TType = 0 To 5
            DoTreeLegend TNum, TType, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
        Next TType
    Next TNum
    DoTreeLegend 3, 0, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
    
    'Erase TreeRX
    Erase TreeRY
    
End Sub
Public Sub RecUPGMAIV()
    'tree derived from the major parent
    Dim TType As Long, TNum As Long, TDS2 As String, Dummy As Long, UB2 As Long, UB1 As Long, FF As Long, oDirX As String, XInstance() As Integer, RecombTreeSeqs() As Integer, Check() As Long
    Dim AdjYD As Integer, SortedNo As Long, MultiInclude As Integer
    Dim cXi As Long, LSeq As Long, x As Long, Z As Long, Y As Long, NodeAdjust As Long
    Dim NodeLengthB() As Double, ValidSite() As Single, NJSubDistance() As Single, CurLen() As Double
    Dim OldFontSize As Double, FirstPos As Double, FormerXPos As Double, ShortestDistance As Single
    Dim TempName() As String, RecombTreeName() As String
    

'SS = Abs(GetTickCount)

'If MaxAnalNo < MCCorrection Then
'    Exit Sub
'End If
If NextNo = -1 Then Exit Sub
    LSeq = Len(StrainSeq(0))
    
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1), Check(NextNo)
    
    
    ReDim NodeYPos(NextNo)
    
    
    For x = 0 To NextNo
        RecombTreeName(x) = OriginalName(x)
    Next 'X

    Form1.Picture16.FontSize = 8.25
    
    If x = x Then
        
        
        If TreeMatrixInFileFLag = 1 Then
            ReDim NJSubDistance(UBTreeMatrix, UBTreeMatrix)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5TreeFMat" + UFTag For Binary As #FF
            Get #FF, , NJSubDistance()
            Close #FF
        Else
            ReDim NJSubDistance(NextNo, NextNo)
            If DebuggingFlag < 2 Then On Error Resume Next
            UB1 = -1
            UB1 = UBound(TreeFMat, 1): UB2 = UBound(TreeFMat, 2)
            If UB1 = -1 Then
                Exit Sub
            End If
            On Error GoTo 0
            
            
            'Dummy = CopySingleArray(Nextno, Nextno, UB1, UB2, UB3, UB4, FMat(0, 0), BFMat(0, 0))
            If UB1 <> NextNo Or UB2 <> NextNo Then
                x = x
            End If
            If TreeMatrixInFileFLag = 0 Then
                Dummy = CopySingleArray(NextNo, NextNo, UB1, UB2, NextNo, NextNo, TreeFMat(0, 0), NJSubDistance(0, 0))
            Else
            
            End If
        End If
        If FubValidInFile = 1 Then
            
            '****************************
            'Better to read just single value from the file
            '*******************************
            ReDim FubValid(FVL, FVL)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5FVFile" + UFTag For Binary As #FF
            '
            Get #FF, , FubValid
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        End If
       
        Call MakeSeqCoverage(0, FubValid())
        If FubValidInFile = 1 Then
            
            ReDim FubValid(0, 0)
        End If
       
    Else
        'Make sub sequences
        'First make small recombinant section
        
        ReDim RecombTreeSeqs(LSeq, NextNo + 1)
            
        If XoverList(PRecSeq, PPAVal).Ending < XoverList(PRecSeq, PPAVal).Beginning Then
            'Exit Sub
            'find beginning
            BeginMark = XoverList(PRecSeq, PPAVal).Ending + 1
    
            For x = 1 To BeginMark - 1
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(x, Z) = 60
                Next 'Z
    
            Next 'X
    
            Y = BeginMark
    
            Do Until Y = XoverList(PRecSeq, PPAVal).Beginning Or Y >= LSeq
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(Y, Z) = SeqNum(Y, Z)
                Next 'Z
    
                Y = Y + 1
            Loop
    
            EndMark = Y - 1
    
            'Call DrawBlueColumn
    
            If Y < LSeq Then
    
                For x = Y To LSeq
    
                    For Z = 0 To NextNo
                        RecombTreeSeqs(x, Z) = SeqNum(x, Z) = 60
                    Next 'Z
    
                Next 'X
    
            End If
    
        Else ' If recombination overlaps the end of the sequence
            BeginMark = XoverList(PRecSeq, PPAVal).Ending + 1
    
            For x = XoverList(PRecSeq, PPAVal).Beginning To BeginMark - 1
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(x, Z) = 60
                Next 'Z
    
            Next 'X
    
            Y = BeginMark
    
            For x = Y To LSeq
    
                For Z = 0 To NextNo
                    RecombTreeSeqs(x, Z) = SeqNum(x, Z)
                Next 'Z
    
            Next 'X
    
            Y = 1
            
            Do Until Y = XoverList(PRecSeq, PPAVal).Beginning Or Y > LSeq
                For x = 0 To NextNo
                    RecombTreeSeqs(Y, x) = SeqNum(Y, x)
                Next 'X
                Y = Y + 1
            Loop
    
            
    
            'Call DrawBlueColumn
    
            EndMark = Y - 1
        End If
    
        NextnoB = NextNo
        'Calculate distances in recombinant section of the alignment
        ReDim NJSubDistance(NextNo, NextNo)
        ReDim ValidSite(NextNo, NextNo)
            'this coluld be speeded up with better nesting of if then's
    
        DistanceCalcC NextNo, LSeq + 1, BeginMark, EndMark, RecombTreeSeqs(0, 0), NJSubDistance(0, 0), ValidSite(0, 0)
        
   'XX = NJSubDistance(41, 26)
    
        For x = 0 To NextNo
    
            For Y = x + 1 To NextNo
    
                If ValidSite(x, Y) > 0 Then
                    NJSubDistance(x, Y) = 1 - ((ValidSite(x, Y) - NJSubDistance(x, Y)) / ValidSite(x, Y))
                    NJSubDistance(Y, x) = NJSubDistance(x, Y)
    
                    
                End If
    
            Next 'Y
    
        Next 'X
    
    
    End If
    
'    EE = Abs(GetTickCount)
'    TT = EE - SS
'    X = X
    ReDim TreeRX(NextNo, NextNo)
    ReDim TreeRY(NextNo)
    ReDim XInstance(NextNo + 1)
    ReDim TempName(NextNo)
    ReDim CurLen(NextNo)
    'Initialise the tree array

    For x = 0 To NextNo

        For Y = 0 To NextNo
            TreeRX(x, Y) = -1
        Next 'Y

    Next 'X

    For x = 0 To NextNo
        TempName(x) = RecombTreeName(x)
    Next 'X
    
    Dim DistMap() As Single, WinningX() As Long
    ReDim DistMap(NextNo), WinningX(NextNo)
    Dummy = MakeDistMapX(NextNo, DistMap(0), NJSubDistance(0, 0), WinningX(0))
    'Draw the tree in memory

    Do Until SortedNo = NextNo
        'ShortestDistance = ShortestDist(Nextno, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))
        If DebuggingFlag < 2 Then On Error Resume Next
        ShortestDistance = ShortestDistB(NextNo, SortedNo, DistMap(0), WinningX(0), NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))
        On Error GoTo 0
        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For x = 0 To NextNo

                For Y = x + 1 To NextNo

                    If NJSubDistance(x, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(x, Y)
                        TreeRX(SortedNo, 0) = x
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If

        NodeLengthB(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        Dim TD As Double, TDS As String
        TD = NodeLengthB(SortedNo) - CurLen(TreeRX(SortedNo, 0))
        TD = CLng(TD * 10000) / 10000
        TDS = Trim$(CStr(TD))
        If TDS = "0" Then TDS = "0.0000"
        
        Pos = InStr(1, TDS, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TDS, Pos, 1) = "."
        End If
        
        
        TD = NodeLengthB(SortedNo) - CurLen(TreeRY(SortedNo))
        TD = CLng(TD * 10000) / 10000
        TDS2 = Trim$(CStr(TD))
        If TDS2 = "0" Then TDS2 = "0.0000"
        
        Pos = InStr(1, TDS2, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TDS2, Pos, 1) = "."
        End If
        
        TempName(TreeRX(SortedNo, 0)) = "(" + TempName(TreeRX(SortedNo, 0)) + ":" + TDS + "," + TempName(TreeRY(SortedNo)) + ":" + TDS2 + ")"
        CurLen(TreeRX(SortedNo, 0)) = NodeLengthB(SortedNo)
        
        
        
        
        
        
        If x = x Then
            '
            Dummy = AddSeqToUPGMA2(NextNo, SortedNo, XInstance(0), NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0), Check(0), NodeYPos(0))

        Else
            For x = 0 To NextNo
    
                If x <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> x Then
                    NJSubDistance(TreeRX(SortedNo, 0), x) = (NJSubDistance(TreeRX(SortedNo, 0), x) + NJSubDistance(TreeRY(SortedNo), x)) / 2
                    
                    NJSubDistance(x, TreeRX(SortedNo, 0)) = (NJSubDistance(x, TreeRX(SortedNo, 0)) + NJSubDistance(x, TreeRY(SortedNo))) / 2
                ElseIf x = TreeRX(SortedNo, 0) Then
    
                    If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                        'Find last instance including x
    
                        For Z = SortedNo - 1 To 0 Step -1
    
                            If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                                MultiInclude = Z
                                Exit For
                            End If
    
                        Next 'Z
    
                        cXi = XInstance(TreeRX(SortedNo, 0))
    
                        For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                            TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                        Next 'Z
    
                    End If
    
                    If XInstance(TreeRY(SortedNo)) > 0 Then ' If "sequence y" is actually a node
                        'Finds last node including y
    
                        For Z = SortedNo - 1 To 0 Step -1
    
                            If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                                MultiInclude = Z
                                Exit For
                            End If
    
                        Next 'Z
    
                        cXi = XInstance(TreeRY(SortedNo))
                        'Adds sequences in node y to node x
    
                        For Z = 0 To cXi
                            XInstance(x) = XInstance(x) + 1
                            TreeRX(SortedNo, XInstance(x)) = TreeRX(MultiInclude, Z)
                        Next 'Z
    
                    Else
                        XInstance(x) = XInstance(x) + 1
                        TreeRX(SortedNo, XInstance(x)) = TreeRY(SortedNo)
                    End If
    
                End If
    
            Next 'X
    
            For x = 0 To NextNo
    
                If x <> TreeRY(SortedNo) Then
                    NJSubDistance(TreeRY(SortedNo), x) = 100
                    NJSubDistance(x, TreeRY(SortedNo)) = 100
                End If
    
            Next 'X
        End If
        'update distmap
        x = TreeRX(SortedNo, 0)
        Z = TreeRY(SortedNo)
        DistMap(x) = 100
        DistMap(TreeRY(SortedNo)) = 100
        '@
        Dummy = UpdateDistMapX(x, Z, NextNo, DistMap(0), NJSubDistance(0, 0), WinningX(0))
        SortedNo = SortedNo + 1
    Loop
    If SortedNo = 0 Then Exit Sub
    NHString(TreeTypeFlag) = TempName(TreeRX(SortedNo - 1, 0)) + ";"
    NHComp(0) = NHString(TreeTypeFlag)
    Pos = InStr(1, NHString(TreeTypeFlag), "E-", vbBinaryCompare)
        
    
    
    Dim ExtraDX As Long
    
    ExtraDX = 0
    Dim NodeFind() As Byte
    
    If PermNextno > NextNo Then
        ReDim NodeFind(PermNextno + 2, PermNextno + 2)
    Else
        ReDim NodeFind(NextNo + 2, NextNo + 2)
    End If
    If UBound(NodeFind, 1) < UBound(TreeTraceSeqs, 2) Then
        ReDim NodeFind(UBound(TreeTraceSeqs, 2), UBound(TreeTraceSeqs, 2))
    End If
    If TreeTypeFlag = 1 Then
        Call UPGMADraw(TreeTrace(), TreeTraceSeqs(), PermNextno, NodeFind(), NodeXY(), 0, 1, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    ElseIf TreeTypeFlag = 3 Then
        Call UPGMADraw(TreeTrace(), TreeTraceSeqs(), PermNextno, NodeFind(), NodeXY(), 0, 3, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    End If
    
    ExtraDX = DoTreeColour(Form1.Picture16, 0, 1)
    For TNum = 0 To 2
        For TType = 0 To 5
            DoTreeLegend TNum, TType, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
        Next TType
    Next TNum
    DoTreeLegend 3, 0, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
   
        'Erase TreeRX
        
        
   
    
    
    'Form1.Picture16.Refresh
End Sub

Public Sub DrawBlueColumn()

    If BeginMark > EndMark Then

        Form1.Picture6.DrawMode = 12 '7 and 15 ok too
        Form1.Picture6.Line (5 + (BeginMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), 0)-(5 + (Form1.Picture5.ScaleWidth - 10), Form1.Picture6.ScaleHeight), Yellow, BF
        Form1.Picture6.Line (5, 0)-(5 + (EndMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), Form1.Picture6.ScaleHeight), Yellow, BF
        Form1.Picture6.DrawMode = 13

    Else

        Form1.Picture6.DrawMode = 12 '7 and 15 ok too
        Form1.Picture6.Line (5 + (BeginMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), 0)-(5 + (EndMark / Len(StrainSeq(0))) * (Form1.Picture5.ScaleWidth - 10), Form1.Picture6.ScaleHeight), Yellow, BF
        Form1.Picture6.DrawMode = 13

    End If

End Sub

Public Sub RecUPGMAIII()

    Dim XInstance() As Integer
    Dim YAdjD As Integer, MultiInclude As Integer, SortedNo As Long
    Dim LSeq As Long, cXi As Long, NodeAdjust As Long
    Dim CurLen() As Double, NJSubDistance() As Single, ValidSite() As Single, NodeLengthB() As Double
    Dim OldFontSize As Double, ShortestDistance As Single
    Dim RecombTreeName() As String, TempName() As String
    
    Dim x As Long, Y As Long, Z As Long
    If NextNo = -1 Then Exit Sub
    LSeq = Len(StrainSeq(0))
    
    ReDim RecombTreeName(NextNo + 1)
    ReDim NodeLengthB(NextNo + 1)
    ReDim NodeYPos(NextNo) ', TreeX(Nextno, Nextno), TreeY(Nextno)
    
    Form1.Picture16.FontSize = 8.25
    If TreeMatrixInFileFLag = 1 Then
        ReDim NJSubDistance(UBTreeMatrix, UBTreeMatrix)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5TreeMatrix" + UFTag For Binary As #FF
        Get #FF, , NJSubDistance()
        Close #FF
    Else

        ReDim NJSubDistance(NextNo, NextNo)
        For x = 0 To NextNo
            For Y = 0 To TreeNextno
                NJSubDistance(x, Y) = TreeMatrix(x, Y)
                
            Next Y
        Next x
    End If
    For x = 0 To NextNo
        RecombTreeName(x) = OriginalName(x)
    Next 'X

    
   'XX = NJSubDistance(41, 26)
    'Draw tree in memory
    ReDim TreeRX(NextNo + 1, NextNo + 1)
    ReDim TreeRY(NextNo)
    ReDim XInstance(NextNo + 1)
    ReDim TempName(NextNo)
    ReDim CurLen(NextNo)

    For x = 0 To NextNo

        For Y = 0 To NextNo
            TreeRX(x, Y) = -1
        Next 'Y

        TempName(x) = RecombTreeName(x)
    Next 'X

    Do Until SortedNo = NextNo
        ShortestDistance = ShortestDist(NextNo, SortedNo, NJSubDistance(0, 0), TreeRX(0, 0), TreeRY(0))

        If ShortestDistance = 1 Then
            ShortestDistance = 100

            For x = 0 To NextNo

                For Y = x + 1 To NextNo

                    If NJSubDistance(x, Y) < ShortestDistance Then
                        ShortestDistance = NJSubDistance(x, Y)
                        TreeRX(SortedNo, 0) = x
                        TreeRY(SortedNo) = Y
                    End If

                Next 'Y

            Next 'X

        End If
        
        Dim TD As Double, TDS As String, TDS2 As String
        NodeLengthB(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        TD = NodeLengthB(SortedNo) - CurLen(TreeRX(SortedNo, 0))
        TD = CLng(TD * 10000) / 10000
        TDS = Trim$(CStr(TD))
        If TDS = "0" Then TDS = "0.0000"
        Pos = InStr(1, TDS, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TDS, Pos, 1) = "."
        End If
        
        TD = NodeLengthB(SortedNo) - CurLen(TreeRY(SortedNo))
        TD = CLng(TD * 10000) / 10000
        TDS2 = Trim$(CStr(TD))
        If TDS2 = "0" Then TDS2 = "0.0000"
        Pos = InStr(1, TDS2, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(TDS2, Pos, 1) = "."
        End If
        
        TempName(TreeRX(SortedNo, 0)) = "(" + TempName(TreeRX(SortedNo, 0)) + ":" + TDS + "," + TempName(TreeRY(SortedNo)) + ":" + TDS2 + ")"
        CurLen(TreeRX(SortedNo, 0)) = NodeLengthB(SortedNo)
        Pos = InStr(1, TempName(TreeRX(SortedNo, 0)), "E-", vbBinaryCompare)
        'If Pos > 0 Then
        '    X = X
        '    XX = Mid$(NHString(TreeTypeFlag), Pos - 10, 20)
        '    X = X
        'End If
        For x = 0 To NextNo

            If x <> TreeRX(SortedNo, 0) And TreeRY(SortedNo) <> x Then
                NJSubDistance(TreeRX(SortedNo, 0), x) = (NJSubDistance(TreeRX(SortedNo, 0), x) + NJSubDistance(TreeRY(SortedNo), x)) / 2
                NJSubDistance(x, TreeRX(SortedNo, 0)) = (NJSubDistance(x, TreeRX(SortedNo, 0)) + NJSubDistance(x, TreeRY(SortedNo))) / 2
            ElseIf x = TreeRX(SortedNo, 0) Then

                If XInstance(TreeRX(SortedNo, 0)) > 0 Then
                    'Find last instance including x

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRX(SortedNo, 0) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRX(SortedNo, 0))

                    For Z = 0 To XInstance(TreeRX(SortedNo, 0))
                        TreeRX(SortedNo, Z) = TreeRX(MultiInclude, Z)
                    Next 'Z

                End If

                If XInstance(TreeRY(SortedNo)) > 0 Then ' If "sequence y" is actually a node
                    'Finds last node including y

                    For Z = SortedNo - 1 To 0 Step -1

                        If TreeRX(Z, 0) = TreeRY(SortedNo) Then
                            MultiInclude = Z
                            Exit For
                        End If

                    Next 'Z

                    cXi = XInstance(TreeRY(SortedNo))
                    'Adds sequences in node y to node x

                    For Z = 0 To cXi
                        XInstance(x) = XInstance(x) + 1
                        TreeRX(SortedNo, XInstance(x)) = TreeRX(MultiInclude, Z)
                    Next 'Z

                Else
                    XInstance(x) = XInstance(x) + 1
                    TreeRX(SortedNo, XInstance(x)) = TreeRY(SortedNo)
                End If

            End If

        Next 'X

        For x = 0 To NextNo

            If x <> TreeRY(SortedNo) Then
                NJSubDistance(TreeRY(SortedNo), x) = 100
                NJSubDistance(x, TreeRY(SortedNo)) = 100
            End If

        Next 'X

        SortedNo = SortedNo + 1
    Loop

    NHString(3) = TempName(TreeRX(SortedNo - 1, 0)) + ";"
    Pos = InStr(1, NHString(TreeTypeFlag), "E-", vbBinaryCompare)
        
    'Draw tree
    
    'Actually draw the tree
    Dim NodeFind() As Byte
    If PermNextno > NextNo Then
        ReDim NodeFind(PermNextno + 2, PermNextno + 2)
    Else
        ReDim NodeFind(NextNo + 2, NextNo + 2)
    End If
    If UBound(NodeFind, 1) < UBound(TreeTraceSeqs, 2) Then
        ReDim NodeFind(UBound(TreeTraceSeqs, 2), UBound(TreeTraceSeqs, 2))
    End If
    Call UPGMADraw(TreeTrace(), TreeTraceSeqs(), PermNextno, NodeFind(), NodeXY(), 0, 3, NextNo, NodeLengthB(), TreeRX(), TreeRY())
    ExtraDX = DoTreeColour(Form1.Picture16, 0, 3)
    For TNum = 0 To 2
        For TType = 0 To 5
            DoTreeLegend TNum, TType, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
        Next TType
    Next TNum
    DoTreeLegend 3, 0, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
    
    Erase TreeRX
    Erase TreeRY
        
    
   
End Sub


Public Sub FindSubSeqX()

    Dim Z As Long, x As Long, Y As Long, g As Long, A As Long, LSeq As Long

    If ExeCheckFlag = 0 Then
        ReDim XOverSeq(NextNo + 2)
    End If
    LSeq = Len(StrainSeq(0))

    If SpacerFlag > 0 And SpacerNo > 0 Then
        Y = 0

        For x = 1 To LSeq

            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Or SeqNum(x, Seq3) <> SeqNum(x, Seq2) Then

                If SeqNum(x, Seq1) <> SeqNum(x, Seq2) And SeqNum(x, Seq1) <> SeqNum(x, Seq3) And SeqNum(x, Seq3) <> SeqNum(x, Seq2) Then
                ElseIf SeqNum(x, Seq1) > 65 And SeqNum(x, Seq2) > 65 And SeqNum(x, Seq3) > 65 Then

                    If SeqNum(x, Seq1) <> SeqNum(x, Seq2) And SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
                        'If seq1 is odd one
                        Y = Y + 1

                        For Z = 1 To SpacerNo

                            If SeqNum(x, Seq1) = SeqNum(x, SpacerSeqs(Z)) Or (Outlyer = Seq1 And SpacerFlag = 1) Then
                                'If difference is legitimate
                                g = 1
                                If ExeCheckFlag = 0 Then
                                    XoverSeqNum(Y, 0) = SeqNum(x, Seq1)
                                    XoverSeqNum(Y, 1) = SeqNum(x, Seq2)
                                    XoverSeqNum(Y, 2) = SeqNum(x, Seq3) '
                                    
                                    XoverSeqNumW(Y + XoverWindow, 0) = SeqNum(x, Seq1)
                                    XoverSeqNumW(Y + XoverWindow, 1) = SeqNum(x, Seq2)
                                    XoverSeqNumW(Y + XoverWindow, 2) = SeqNum(x, Seq3)
                                    
                                    XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(x, Seq1) - 1)
                                    XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(x, Seq2) - 1)
                                    XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(x, Seq3) - 1)
                                
                                    For A = 1 To SpacerNo
                                        XOverSeq(2 + A) = XOverSeq(2 + A) + Chr$(SeqNum(x, SpacerSeqs(A)) - 1)
                                    Next 'A
                                
                                End If
                                
                                XDiffPos(Y) = x
                                XPosDiff(x) = Y
                                
                                Exit For
                            Else

                                If SeqNum(x, Seq2) = SeqNum(x, SpacerSeqs(Z)) Then
                                    
                                End If

                            End If

                        Next 'Z

                        If XPosDiff(x) = 0 Then
                            
                            Y = Y - 1
                        End If

                    ElseIf SeqNum(x, Seq2) <> SeqNum(x, Seq1) And SeqNum(x, Seq2) <> SeqNum(x, Seq3) Then
                        'If seq2 is odd one
                        Y = Y + 1

                        For Z = 1 To SpacerNo ''

                            If SeqNum(x, Seq2) = SeqNum(x, SpacerSeqs(Z)) Or (Outlyer = Seq2 And SpacerFlag = 1) Then
                                'If difference is legitimate
                                g = 2
                                If ExeCheckFlag = 0 Then
                                    XoverSeqNum(Y, 0) = SeqNum(x, Seq1)
                                    XoverSeqNum(Y, 1) = SeqNum(x, Seq2)
                                    XoverSeqNum(Y, 2) = SeqNum(x, Seq3)
                                    XoverSeqNumW(Y + XoverWindow, 0) = SeqNum(x, Seq1)
                                    XoverSeqNumW(Y + XoverWindow, 1) = SeqNum(x, Seq2)
                                    XoverSeqNumW(Y + XoverWindow, 2) = SeqNum(x, Seq3) '
                                    XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(x, Seq1) - 1)
                                    XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(x, Seq2) - 1)
                                    XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(x, Seq3) - 1)
    
                                    For A = 1 To SpacerNo
                                        XOverSeq(2 + A) = XOverSeq(2 + A) + Chr$(SeqNum(x, SpacerSeqs(A)) - 1)
                                    Next 'A
                                
                                End If
                                
                                XDiffPos(Y) = x
                                XPosDiff(x) = Y
                                
                                Exit For
                            Else

                                

                            End If

                        Next 'Z

                        If XPosDiff(x) = 0 Then
                           
                            Y = Y - 1
                        End If

                    ElseIf SeqNum(x, Seq3) <> SeqNum(x, Seq1) And SeqNum(x, Seq3) <> SeqNum(x, Seq2) Then
                        'If seq3 is odd one
                        Y = Y + 1

                        For Z = 1 To SpacerNo '

                            If SeqNum(x, Seq3) = SeqNum(x, SpacerSeqs(Z)) Or (Outlyer = Seq3 And SpacerFlag = 1) Then  '
                                'If difference is legitimate
                                g = 3
                                If ExeCheckFlag = 0 Then
                                    XoverSeqNum(Y, 0) = SeqNum(x, Seq1)
                                    XoverSeqNum(Y, 1) = SeqNum(x, Seq2)
                                    XoverSeqNum(Y, 2) = SeqNum(x, Seq3) '
                                    XoverSeqNumW(Y + XoverWindow, 0) = SeqNum(x, Seq1)
                                    XoverSeqNumW(Y + XoverWindow, 1) = SeqNum(x, Seq2)
                                    XoverSeqNumW(Y + XoverWindow, 2) = SeqNum(x, Seq3) '
                                    XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(x, Seq1) - 1)
                                    XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(x, Seq2) - 1)
                                    XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(x, Seq3) - 1)
    
                                    For A = 1 To SpacerNo
                                        XOverSeq(2 + A) = XOverSeq(2 + A) + Chr$(SeqNum(x, SpacerSeqs(A)) - 1)
                                    Next 'A
                                End If

                                XDiffPos(Y) = x
                                XPosDiff(x) = Y
                                
                                Exit For
                            Else

                               

                            End If

                        Next 'Z ''

                        If XPosDiff(x) = 0 Then
                            
                            Y = Y - 1
                        End If

                    End If ''

                End If

            End If

        Next 'X

        LenXoverSeq = Y
    Else

        For x = 1 To LSeq

            If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Or SeqNum(x, Seq3) <> SeqNum(x, Seq2) Then

                If SeqNum(x, Seq1) <> SeqNum(x, Seq2) And SeqNum(x, Seq1) <> SeqNum(x, Seq3) And SeqNum(x, Seq3) <> SeqNum(x, Seq2) Then
                    g = g + 1
                ElseIf SeqNum(x, Seq1) > 65 And SeqNum(x, Seq2) > 65 And SeqNum(x, Seq3) > 65 Then
                    Y = Y + 1
                    If ExeCheckFlag = 0 Then
                        XoverSeqNum(Y, 0) = SeqNum(x, Seq1)
                        XoverSeqNum(Y, 1) = SeqNum(x, Seq2)
                        XoverSeqNum(Y, 2) = SeqNum(x, Seq3)
                        XoverSeqNumW(Y + XoverWindow, 0) = SeqNum(x, Seq1)
                        XoverSeqNumW(Y + XoverWindow, 1) = SeqNum(x, Seq2)
                        XoverSeqNumW(Y + XoverWindow, 2) = SeqNum(x, Seq3)
                        XOverSeq(0) = XOverSeq(0) + Chr$(SeqNum(x, Seq1) - 1)
                        XOverSeq(1) = XOverSeq(1) + Chr$(SeqNum(x, Seq2) - 1)
                        XOverSeq(2) = XOverSeq(2) + Chr$(SeqNum(x, Seq3) - 1)
                    End If
                    
                    XDiffPos(Y) = x
                    XPosDiff(x) = Y
                End If

            End If

        Next 'X

        LenXoverSeq = Y
    End If

    If LenXoverSeq < XoverWindow * 2 Then
        Exit Sub
    End If
    
    If ExeCheckFlag = 0 Then
        For x = 1 To XoverWindow
            XoverSeqNumW(x, 0) = XoverSeqNum(LenXoverSeq - XoverWindow + x, 0)
            XoverSeqNumW(LenXoverSeq + XoverWindow + x, 0) = XoverSeqNum(x, 0)
            XoverSeqNumW(x, 1) = XoverSeqNum(LenXoverSeq - XoverWindow + x, 1)
            XoverSeqNumW(LenXoverSeq + XoverWindow + x, 1) = XoverSeqNum(x, 1)
            XoverSeqNumW(x, 2) = XoverSeqNum(LenXoverSeq - XoverWindow + x, 2)
            XoverSeqNumW(LenXoverSeq + XoverWindow + x, 2) = XoverSeqNum(x, 2)
        Next 'X
    End If

End Sub
Public Sub MakeXOverSeq()

    Dim x As Long, TSeq As String

    ReDim XOverSeq(2)
    TSeq = String(LenXoverSeq, " ")
    If Seq1 <= UBound(SeqNum, 2) Then
        For x = 1 To LenXoverSeq
            Mid$(TSeq, x, 1) = Chr(SeqNum(XDiffPos(x), Seq1) - 1)   'Mid$(StrainSeq(Seq1), XDiffPos(X), 1)
            
        Next 'X
    End If
    
    XOverSeq(0) = TSeq
    If Seq2 <= UBound(SeqNum, 2) Then
        For x = 1 To LenXoverSeq
            Mid$(TSeq, x, 1) = Chr(SeqNum(XDiffPos(x), Seq2) - 1) 'Mid$(StrainSeq(Seq1), XDiffPos(X), 1)
            
        Next 'X
    End If
    XOverSeq(1) = TSeq
    If Seq3 <= UBound(SeqNum, 2) Then
        For x = 1 To LenXoverSeq
             Mid$(TSeq, x, 1) = Chr(SeqNum(XDiffPos(x), Seq3) - 1) 'Mid$(StrainSeq(Seq1), XDiffPos(X), 1)
            
        Next 'X
    End If
    XOverSeq(2) = TSeq

End Sub
Public Sub FindsubseqChiII()
ReDim XDiffPos(Len(StrainSeq(0)) + 200, 2)
ReDim XPosDiff(Len(StrainSeq(0)) + 200, 2)

ReDim xLenXoverSeq(2)

tSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
        
For Z = 0 To 2
    If Z = 0 Then
        Seq1 = tSeq1
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Z = 1 Then
        Seq1 = tSeq3
        Seq2 = tSeq1
        Seq3 = tSeq2
    Else
        Seq1 = tSeq2
        Seq2 = tSeq3
        Seq3 = tSeq1
    End If
    'This could be speeded up with better nesting
    xLenXoverSeq(Z) = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0, Z), XPosDiff(0, Z))
    If xLenXoverSeq(Z) > LenXoverSeq Then LenXoverSeq = xLenXoverSeq(Z)
'End If
Next Z
Seq1 = tSeq1
Seq2 = tSeq2
Seq3 = tSeq3
End Sub
Public Sub FindSubSeqChi()
    
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    
    LenXoverSeq = 0
    'Seq1 = tseq1
    'Seq2 = tseq2
    'Seq3 = tseq3
    tSeq1 = Seq1
    tSeq2 = Seq2
    tSeq3 = Seq3
    If XoverList(RelX, RelY).DHolder <= PermNextno And XoverList(RelX, RelY).DHolder >= -PermNextno - 1 Then
        Seq1 = Abs(CLng(XoverList(RelX, RelY).DHolder))
        
        If Seq1 <> tSeq1 And Seq1 <> tSeq2 And Seq1 <> tSeq3 Then
            For x = 0 To NextNo
                If TreeTrace(x) = Seq1 And (x = tSeq1 Or x = tSeq2 Or x = tSeq3) Then
                    Seq1 = x: Exit For
                End If
            Next x
        End If
        x = x
    End If
    If Seq1 = tSeq1 Then
        Seq2 = tSeq2
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq2 Then
        Seq2 = tSeq1
        Seq3 = tSeq3
    ElseIf Seq1 = tSeq3 Then
        Seq2 = tSeq1
        Seq3 = tSeq2
    Else
    
    End If
    'This could be speeded up with better nesting
    LenXoverSeq = FindSubSeqD(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
    
    
    
    
    Seq1 = tSeq1
    Seq2 = tSeq2
    Seq3 = tSeq3
    
    ReDim CXoverSeq(2)
    UB = UBound(StrainSeq, 1)
    If UB > 0 Then
        For x = 1 To LenXoverSeq
            CXoverSeq(0) = CXoverSeq(0) + Mid(StrainSeq(TreeTrace(Seq1)), XDiffPos(x), 1)
            CXoverSeq(1) = CXoverSeq(1) + Mid(StrainSeq(TreeTrace(Seq2)), XDiffPos(x), 1)
            CXoverSeq(2) = CXoverSeq(2) + Mid(StrainSeq(TreeTrace(Seq3)), XDiffPos(x), 1)
        Next x
    End If
    
End Sub
Public Sub GetXOSMC()
ReDim XDiffPos(Len(StrainSeq(0)) + 200)
ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    
LenXoverSeq = 0
'This could be speeded up with better nesting
LenXoverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))

End Sub
    

    

Public Sub FindSubSeqMC()
    
    Call GetXOSMC
    If ExeCheckFlag = 1 And OptFlag <> 4 Then
        BE = XoverList(RelX, RelY).Beginning
        EN = XoverList(RelX, RelY).Ending
        If BE < EN Then
            MCWinSize = XPosDiff(EN) - XPosDiff(BE)
        Else
            MCWinSize = XPosDiff(EN) + (LenXoverSeq - XPosDiff(BE))
        End If
        
        MCWinSize = MCWinSize * 2
        MCWinFract = MCWinSize / LenXoverSeq
    End If
    
    If MCProportionFlag = 0 Then
        
        If MCWinSize < LenXoverSeq / 1.5 Then
            If ExeCheckFlag = 1 Then
                MCOverlapR = XDiffPos(MCWinSize)
            Else
                MCOverlapR = XDiffPos(MCWinSize / 2)
            End If
            MCOverlapL = MCOverlapR
        Else
            MCOverlapR = XDiffPos(Int(1 + LenXoverSeq / 1.5))
            MCOverlapL = MCOverlapR
        End If

    Else

        If MCWinFract * LenXoverSeq >= 20 And MCWinFract * LenXoverSeq < LenXoverSeq / 1.5 Then
            MCOverlapR = XDiffPos(Int(MCWinFract * LenXoverSeq / 2) + 1)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXoverSeq < 20 Then
            MCOverlapR = XDiffPos(10)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXoverSeq <= LenXoverSeq / 1.5 Then
            MCOverlapR = XDiffPos(Int(1 + LenXoverSeq / 1.5))
            MCOverlapL = MCOverlapR
        End If

    End If

End Sub

Public Sub FindSubSeqRDP()

    Dim CS As Long, Y As Long, x As Long, Dummy As Long, StringX As String, TString As String, XDP As Long, NTnum As Long
    'ReDim AvHomol(3)
    XoverWindow = Int(XOverWindowX / 2)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    Dim AH(2) As Long
    
    LenStrainSeq = Len(StrainSeq(0)) + 1
    If SpacerFlag > 0 And SpacerNo > 0 Then
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqX)
        'Call FindSubSeqX
        'This could be speeded up with better nesting
        LenXoverSeq = FindSubSeq(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
        
        LenXoverSeq = Abs(LenXoverSeq)
        
        If ExeCheckFlag = 0 Then
            ReDim XOverSeq(NextNo + 1)
            StringX = String$(LenXoverSeq, "1")
            
            'For X = 0 To 2
                'Dummy = CopyStringC(LenXOverSeq, XOverSeqNum(0, X), StringX)
                Dummy = CopyStringD(LenXoverSeq, SeqNum(0, Seq1), XDiffPos(0), StringX)
                If LenXoverSeq > 0 Then
                    XOverSeq(0) = Right$(StringX, LenXoverSeq - 1)
                    
                    Dummy = CopyStringD(LenXoverSeq, SeqNum(0, Seq2), XDiffPos(0), StringX)
                    XOverSeq(1) = Right$(StringX, LenXoverSeq - 1)
                    Dummy = CopyStringD(LenXoverSeq, SeqNum(0, Seq3), XDiffPos(0), StringX)
                    XOverSeq(2) = Right$(StringX, LenXoverSeq - 1)
                End If
            'Next 'X
    
            For x = 1 To SpacerNo
                Dummy = CopyStringD(LenXoverSeq, SeqNum(0, SpacerSeqs(x)), XDiffPos(0), StringX)
                If LenXoverSeq > 0 Then
                    XOverSeq(2 + x) = Right$(StringX, LenXoverSeq - 1)
                End If
            Next 'X
        End If
        
    Else
        SpacerFlag = 0
        ReDim ValidSpacer(0)
        ReDim SpacerSeqs(0)
        'This could be speeded up with better nesting
        LenXoverSeq = FindSubSeqP(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
        'LenXOverSeq = FindSubSeqP2(UBound(XoverSeqNumW, 1), 125, UBound(CompressedSeqs3, 1), XoverWindow, Len(StrainSeq(0)), Seq1, Seq2, Seq3, AH(0), CompressedSeqs3(0, 0), XoverSeqNumW(0, 0), XDiffPos(0), SkipTrip(0, 0, 0), FindSS0(0, 0, 0, 0))
        'LenXOverSeq = FindSubSeqPVB(XoverWindow, Seq1, Seq2, Seq3, XoverSeqNumW(), AH(), XDiffPos(), XPosDiff())
        
        
        
        
        If ExeCheckFlag = 0 Then
            ReDim XOverSeq(NextNo + 1)
            StringX = String$(LenXoverSeq, "1")
            'SS = Abs(GetTickCount)
            For x = 0 To 2
                If x = 0 Then
                    CS = Seq1
                ElseIf x = 1 Then
                    CS = Seq2
                Else
                    CS = Seq3
                End If
                XOverSeq(x) = ""
                TString = String(LenXoverSeq, " ")
                For Y = 1 To LenXoverSeq
                    XDP = XDiffPos(Y)
                    NTnum = SeqNum(XDP, CS) - 1
                    If NTnum > 0 Then
                        Mid(TString, Y, 1) = Chr(NTnum)
                    End If
                Next Y
                XOverSeq(x) = TString
            Next 'X
            'EE = Abs(GetTickCount)
            'TT = EE - SS
            x = x
        End If
        
        SpacerNo = 0
        AllowExtraSeqsFlag = 0
    End If
    If LenXoverSeq = 0 Then Exit Sub
    AvHomol(1) = (AH(0) / LenXoverSeq)
    AvHomol(2) = (AH(1) / LenXoverSeq)
    AvHomol(3) = (AH(2) / LenXoverSeq)
    LenXoverSeq = Abs(LenXoverSeq) - 1
    
End Sub
Public Sub FindSubSeqBS()

    Dim Y As Long, x As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    ReDim XDiffPos(LSeq + 200)
    ReDim XPosDiff(LSeq + 200)
    
    
    Y = 0
    If Seq1 > UBound(SeqNum, 2) Then Exit Sub
    
    
    For x = 1 To LSeq
        XPosDiff(x) = Y
       
        If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Then
             If SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46 Then
                Y = Y + 1
                XDiffPos(Y) = x
                XPosDiff(x) = Y
            
            End If
        End If

    Next 'X
    LenXoverSeq = Y
    'End If
End Sub
Public Sub FindSubSeqGC()

    Dim Y As Long, x As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    ReDim XDiffPos(LSeq + 200)
    ReDim XPosDiff(LSeq + 200)
    
    Y = 0
    
    For x = 1 To LSeq
        XPosDiff(x) = Y

        If SeqNum(x, Seq1) <> SeqNum(x, Seq2) Or SeqNum(x, Seq1) <> SeqNum(x, Seq3) Or SeqNum(x, Seq2) <> SeqNum(x, Seq3) Then
            If (SeqNum(x, Seq1) = 46 Or SeqNum(x, Seq2) = 46 Or SeqNum(x, Seq2) = 46) And (GCIndelFlag = 0 Or GCIndelFlag = 1) Then
            Else
                Y = Y + 1
                XDiffPos(Y) = x
                XPosDiff(x) = Y
            
            End If
        End If

    Next 'X
    LenXoverSeq = Y
    'End If
End Sub
Public Sub FindSubSeqBSII()

    Dim Y As Long, x As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    ReDim XDiffPos(LSeq + 200)
    ReDim XPosDiff(LSeq + 200)
    
    If Seq1 <> Seq2 Then
        S1 = Seq1
        s2 = Seq2
    Else
        S1 = Seq1
        s2 = Seq3
    End If
    Y = 0
    For x = 1 To LSeq
        XPosDiff(x) = Y
        If SeqNum(x, S1) <> SeqNum(x, s2) And SeqNum(x, S1) <> 46 And SeqNum(x, s2) <> 46 Then
            Y = Y + 1
            XDiffPos(Y) = x
            XPosDiff(x) = Y
        End If
    Next 'X
    LenXoverSeq = Y
End Sub
Public Sub FindSubSeqMCII()

    Dim Y As Long, x As Long, Z As Long, LSeq As Long

    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    LSeq = Len(StrainSeq(0))
    ReDim MCXDiffPos(Len(StrainSeq(0)))
    ReDim MCXPosDiff(LSeq)
    ReDim MCXoverSeq(NextNo)
    
    
    'Exit Sub
    If UBound(MCIdentical) = 0 Then
        ReDim MCIdentical(Len(StrainSeq(0)) + 200)
        'If NumEnabledSeqs < Nextno Then 'Or MCStripGapsFlag = 1 Then
        ReDim MCIDCount(Len(StrainSeq(0)), 4)
        
        
        For x = 1 To Len(StrainSeq(0))
    
            If Identical(x) = 0 Then
                If NumEnabledSeqs > 0 Then
                    For Y = 0 To NumEnabledSeqs
        
                        If SeqNum(x, GCEnabledNo(Y)) = 66 Then
                            MCIDCount(x, 0) = MCIDCount(x, 0) + 1
                        ElseIf SeqNum(x, GCEnabledNo(Y)) = 68 Then
                            MCIDCount(x, 1) = MCIDCount(x, 1) + 1
                        ElseIf SeqNum(x, GCEnabledNo(Y)) = 72 Then
                            MCIDCount(x, 2) = MCIDCount(x, 2) + 1
                        ElseIf SeqNum(x, GCEnabledNo(Y)) = 85 Then
                            MCIDCount(x, 3) = MCIDCount(x, 3) + 1
                        ElseIf SeqNum(x, GCEnabledNo(Y)) = 46 Or SeqNum(x, GCEnabledNo(Y)) = 47 Then
                            MCIDCount(x, 4) = MCIDCount(x, 4) + 1
                        End If
        
                    Next 'Y
                End If
    
                If MCIDCount(x, 0) = NumEnabledSeqs + 1 Or MCIDCount(x, 1) = NumEnabledSeqs + 1 Or MCIDCount(x, 2) = NumEnabledSeqs + 1 Or MCIDCount(x, 3) = NumEnabledSeqs + 1 Or MCIDCount(x, 4) = NumEnabledSeqs + 1 Then
                    MCIdentical(x) = 1
                ElseIf MCIDCount(x, 4) > 0 And MCStripGapsFlag = 1 Then
                    MCIdentical(x) = 1
                ElseIf MCIDCount(x, 0) + MCIDCount(x, 4) < NumEnabledSeqs + 1 And MCIDCount(x, 1) + MCIDCount(x, 4) < NumEnabledSeqs + 1 And MCIDCount(x, 2) + MCIDCount(x, 4) < NumEnabledSeqs + 1 And MCIDCount(x, 3) + MCIDCount(x, 4) < NumEnabledSeqs + 1 Then
                    MCIdentical(x) = 0
                Else
                    MCIdentical(x) = 2
                End If
    
            Else
                MCIdentical(x) = 1
            End If
    
        Next 'X
    End If
    
    If NumEnabledSeqs <> NextNo And NumEnabledSeqs > 0 Then
        Y = 0

        For x = 1 To LSeq
            XPosDiff(x) = Y
            MCXPosDiff(x) = Y

            If MCIdentical(x) = 0 Then
                Y = Y + 1
                XDiffPos(Y) = x
                MCXDiffPos(Y) = x
                XPosDiff(x) = Y

                For Z = 0 To NextNo

                    If MaskSeq(Z) < 2 Then
                        MCXoverSeq(Z) = MCXoverSeq(Z) + Mid$(StrainSeq(Z), x, 1)
                    End If

                Next 'Z

            End If

        Next 'X

    Else
        Y = 0

        For x = 1 To LSeq
            XPosDiff(x) = Y

            If MCIdentical(x) = 0 Then
                Y = Y + 1
                XDiffPos(Y) = x
                MCXDiffPos(Y) = x
                XPosDiff(x) = Y

                For Z = 0 To NextNo
                    If Z < UBound(StrainSeq, 1) Then
                        MCXoverSeq(Z) = MCXoverSeq(Z) + Mid$(StrainSeq(Z), x, 1)
                    End If
                Next 'Z

            End If

        Next 'X

    End If

    LenXoverSeq = Y

    If MCProportionFlag = 0 Then

        If MCWinSize < LenXoverSeq / 1.5 Then
            MCOverlapL = XDiffPos(Int(MCWinSize / 2) + 1)
            MCOverlapR = (LSeq - XDiffPos(LenXoverSeq - (Int(MCWinSize / 2) + 1)))
        Else
            MCOverlapR = XDiffPos(Int(1 + LenXoverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    Else

        If MCWinFract * LenXoverSeq >= 20 And MCWinFract * LenXoverSeq < LenXoverSeq / 1.5 Then
            MCOverlapL = XDiffPos(Int(MCWinFract * LenXoverSeq / 2) + 1)
            MCOverlapR = (LSeq - XDiffPos(LenXoverSeq - (Int(MCWinFract * LenXoverSeq / 2) + 1)))
        ElseIf MCWinFract * LenXoverSeq < 20 Then
            MCOverlapR = XDiffPos(10)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXoverSeq <= LenXoverSeq / 1.5 Then
            MCOverlapR = XDiffPos(Int(1 + LenXoverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    End If

End Sub
Public Sub FindSubSeqMCIII()

    Dim Y As Long, x As Long

    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim MCXDiffPos(Len(StrainSeq(0)))
    ReDim MCXPosDiff(Len(StrainSeq(0)))
    ReDim MCXoverSeq(NextNo)

    Dim Z As Long, ATot As Long, CTot As Long, GTot As Long, TTot As Long, LSeq As Long

    LSeq = Len(StrainSeq(0))
    Y = 0

    For x = 1 To LSeq
        XPosDiff(x) = Y

        If Identical(x) = 0 Then
            ATot = 0
            CTot = 0
            GTot = 0
            TTot = 0

            For Z = 0 To NumberOfSeqs

                If Mid$(TempSeq(Z), x, 1) = "A" Then
                    ATot = ATot + 1
                ElseIf Mid$(TempSeq(Z), x, 1) = "C" Then
                    CTot = CTot + 1
                ElseIf Mid$(TempSeq(Z), x, 1) = "G" Then
                    GTot = GTot + 1
                ElseIf Mid$(TempSeq(Z), x, 1) = "T" Then
                    TTot = TTot + 1
                End If

            Next 'Z

            If (ATot > 0 And CTot > 0) Or (ATot > 0 And GTot > 0) Or (ATot > 0 And TTot > 0) Or (CTot > 0 And GTot > 0) Or (CTot > 0 And TTot > 0) Or (GTot > 0 And TTot > 0) Then
                Y = Y + 1
                XDiffPos(Y) = x
                MCXDiffPos(Y) = x
                XPosDiff(x) = Y
            End If

        End If

    Next 'X

    LenXoverSeq = Y

    If MCProportionFlag = 0 Then

        If MCWinSize < LenXoverSeq / 1.5 Then
            MCOverlapL = XDiffPos(Int(MCWinSize / 2) + 1)
            MCOverlapR = (LSeq - XDiffPos(LenXoverSeq - (Int(MCWinSize / 2) + 1)))
        Else
            MCOverlapR = XDiffPos(Int(1 + LenXoverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    Else

        If MCWinFract * LenXoverSeq >= 20 And MCWinFract * LenXoverSeq < LenXoverSeq / 1.5 Then
            MCOverlapL = XDiffPos(Int(MCWinFract * LenXoverSeq / 2) + 1)
            MCOverlapR = (LSeq - XDiffPos(LenXoverSeq - (Int(MCWinFract * LenXoverSeq / 2) + 1)))
        ElseIf MCWinFract * LenXoverSeq < 20 Then
            MCOverlapR = XDiffPos(10)
            MCOverlapL = MCOverlapR
        ElseIf MCWinFract * LenXoverSeq <= LenXoverSeq / 1.5 Then
            MCOverlapR = XDiffPos(Int(1 + LenXoverSeq / 3))
            MCOverlapL = MCOverlapR
        End If

    End If

End Sub

Public Sub ProbCalcX()
    'ProbabilityXOver = 0.000000000001
    
    Dim Y As Long, Z As Long, NMFactorial As Double, AddjustFactor As Double, XOL As Long, NIC As Long

    On Error GoTo Rescue

   ' If XOverLength < 600 Then
   '     AddjustFactor = XOverLength / ((XOverLength / 171) + 1)
   ' ElseIf XOverLength < 1000 Then
   '     AddjustFactor = XOverLength / 3
   ' ElseIf XOverLength < 2000 Then
   '     AddjustFactor = XOverLength / 1.8
   ' Else
   '     AddjustFactor = 1
   ' End If
   
    AddjustFactor = (XOverLength / 170)
   
    XOL = 170
    NIC = CLng((ntInCommon / XOverLength) * 170)
    
    ProbabilityXOver = 0
    'NFactorial = 1
    'For Y = 1 To XOverLength
    '         NFactorial = NFactorial * (Y / AddjustFactor)
    ' Next 'Y
    'AddjustFactor = 135.5
    NFactorial = Fact(XOL)

    

    For Z = NIC To XOL
        MFactorial = Fact(Z)
        NMFactorial = Fact(XOL - Z)

        'For Y = 1 To Z
        '    MFactorial = MFactorial * (Y / AddjustFactor)
        'Next 'Y

        'For Y = 1 To XOverLength - Z
        '    NMFactorial = NMFactorial * (Y / AddjustFactor)
        'Next 'Y

        ProbabilityXOver = ProbabilityXOver + ((IndProb ^ Z) * ((1 - IndProb) ^ (XOverLength - Z)) * (NFactorial / (MFactorial * NMFactorial)))
        x = x
    Next 'Z
    
    Exit Sub
Rescue:
    ProbabilityXOver = -1
End Sub
Public Sub CorrectProb()
    'This is used during the RDP analysis to properly record very small P-values

    If 1 - ProbabilityXOver = 1 Then
        If ProbabilityXOver < 1 Then ProbabilityXOver = ProbabilityXOver * (LenXoverSeq / XOverLength)
    Else
        If ProbabilityXOver < 0 Then
            ProbabilityXOver = -1
        ElseIf ProbabilityXOver < 1 Then
            ProbabilityXOver = 1 - ((1 - ProbabilityXOver) ^ ((LenXoverSeq / XOverLength)))
        End If

    End If

End Sub
Public Sub UPGMA(StraiName() As String, TempNHF As String, SeqNum() As Integer, DistanceFlag As Long, NodeLength() As Double, TreeX() As Integer, TreeY() As Integer, AvDst As Double, Decompress() As Long, PermDIffs() As Single, PermValid() As Single, NextNo As Long, Distance() As Single, SPF, LF)
      
    Dim UB1 As Long, UB As Long, FF As Long, oDir As String, GoOn As Byte, A As Long, b As Long, Dummy As Variant, ValidSiteNo() As Single, OldCaption As String, Check() As Long, ShortestDistance As Single, x As Long, Y As Long, cXi As Long, SortedNo As Long, distancebak() As Single
    Dim CurLen() As Double, TempName() As String, FxName As String
    Dim CJNode As Integer, XInstance() As Integer, MultiInclude As Integer, Z As Long
    Dim TS As String, nt As Long, NS As Long
    
    ReDim Check(NextNo)
    ReDim NodeYPos(NextNo), TreeY(NextNo), distancebak(NextNo, NextNo)
    
    '1.495gigs
    
    Dim CS As Long, Gaps As Long
    
    
    
    
    
    If NextNo > UBound(StraiName, 1) Then ReDim Preserve StraiName(NextNo)
    
    If Form1.VScroll1.Max = 0 Then Form1.VScroll1.Max = 1
    ReDim TempName(NextNo), CurLen(NextNo)
   '504268
   If LF = 0 Then
        For x = 0 To NextNo
        
            If StraiName(x) = "" Then StraiName(x) = Str(SEventNumber) + Str(x)
            FxName = OriginalName(x)
            
            Call FixName(FxName)
            TempName(x) = FxName
        Next 'X
        OldCaption$ = Form1.SSPanel1.Caption
        If SPF = 0 Then Form1.SSPanel1.Caption = "Making UPGMA"
    ElseIf LF = 2 Then
        On Error GoTo 0
        If NextNo > UBound(StraiName, 1) Then ReDim Preserve StraiName(NextNo)
        For x = 0 To NextNo
        
            If StraiName(x) = "" Then StraiName(x) = Str(SEventNumber) + Str(x)
            FxName = OriginalName(x)
            Call FixName(FxName)
            TempName(x) = FxName
        Next 'X
        'OldCaption$ = Form1.SSPanel1.Caption
        'If SPF = 0 Then Form1.SSPanel1.Caption = "Drawing UPGMA"
    ElseIf LF = 3 Then
        For x = 0 To NextNo
        
            If StraiName(x) = "" Then StraiName(x) = Str(SEventNumber) + Str(x)
            FxName = OriginalName(x)
            
            Call FixName(FxName)
            TempName(x) = FxName
        Next 'X
    End If
    
    'Initialise the tree array
    ReDim TreeX(NextNo, NextNo)
    '533284
    'SS = Abs(GetTickCount)
    '&
    For x = 0 To NextNo

        For Y = 0 To NextNo
            TreeX(x, Y) = -1
        Next 'Y
        
    Next 'X
    'EE = Abs(GetTickCount)
    'TT = EE - SS '0.499 for 4715
    'X = X
'Exit Sub
'0.046



    If DistanceFlag = 0 Then
        Z = 0
       ' For X = 0 To Len(StrainSeq(0))
       '     If SeqNum(X, Nextno) > 46 Then
       '         Z = Z + 1
       '     End If
       ' Next X
        x = x
        Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), SPF, 0)
        
        x = x
    ElseIf DistanceFlag = 2 Or DistanceFlag = 3 Then
        Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), SPF, 1)
        If DistanceFlag = 3 Then 'this is used specifically for the PADREUPGMA - it helps to group recombinants with the same/simal mosaics in the network
            Dim BigDTracker() As Double, MultFact As Double
            ReDim BigDTracker(SEventNumber, 1) '0=inner,1 = outer
            For x = 1 To SEventNumber
                BigDTracker(x, 0) = 1
                
            Next x
            For x = 0 To NextNo
                For Y = x + 1 To NextNo
                
                    If PADRETraceEventU(x) = PADRETraceEventU(Y) Then
                        If PADRETraceEventU(x) > 0 Then
                            If Distance(x, Y) > 0 Then
                                If Distance(x, Y) <= BigDTracker(PADRETraceEventU(x), 0) Then
                                    BigDTracker(PADRETraceEventU(x), 0) = Distance(x, Y)
                                End If
                            Else
                                'work out distances between very small fragments
                                Dim VV As Double, HH As Double
                                VV = 0: HH = 0
                                For Z = 1 To Len(StrainSeq(0))
                                    If SeqNum(Z, x) > 48 Then
                                        If SeqNum(Z, Y) > 48 Then
                                            VV = VV + 1
                                            If SeqNum(Z, Y) = SeqNum(Z, x) Then
                                                HH = HH + 1
                                            End If
                                        End If
                                        
                                    End If
                                Next Z
                                If VV > 0 Then
                                    Distance(x, Y) = HH / VV
                                    Distance(Y, x) = Distance(x, Y)
                                    If Distance(x, Y) <= BigDTracker(PADRETraceEventU(x), 0) Then
                                        BigDTracker(PADRETraceEventU(x), 0) = Distance(x, Y)
                                    End If
                                End If
                            End If
                        End If
                    Else
                        If PADRETraceEventU(x) > 0 Then
                            If BigDTracker(PADRETraceEventU(x), 1) <= Distance(x, Y) Then
                                BigDTracker(PADRETraceEventU(x), 1) = Distance(x, Y)
                            End If
                        End If
                        If PADRETraceEventU(Y) > 0 Then
                            If BigDTracker(PADRETraceEventU(Y), 1) <= Distance(x, Y) Then
                                BigDTracker(PADRETraceEventU(Y), 1) = Distance(x, Y)
                            End If
                        End If
                    End If
                    
                Next Y
            Next x
            For Y = 0 To NextNo
                For x = Y + 1 To NextNo
                
                    If PADRETraceEventU(x) = PADRETraceEventU(Y) And PADRETraceEventU(x) > 0 Then
                        If BigDTracker(PADRETraceEventU(Y), 0) < BigDTracker(PADRETraceEventU(Y), 1) Then
                            If Distance(x, Y) < (BigDTracker(PADRETraceEventU(Y), 1)) Then
                                Distance(x, Y) = (BigDTracker(PADRETraceEventU(Y), 1)) + 0.00001
                                If Distance(x, Y) > 1 Then Distance(x, Y) = 1
                                Distance(Y, x) = Distance(x, Y)
                            End If
                        End If
                        
                        'If MultFact > 1 Then
                        'If Distance(X, Y) < BigDTracker(PADRETraceEventU(Y), 1) Then
                        '    Distance(X, Y) = BigDTracker(PADRETraceEventU(Y), 1) + 0.0001
                        'End If
                    
                    End If
                Next x
            Next Y
        Else
            
        End If
    End If



    
 
 
 '4.937
 '4.266 -better arguements in calcdist
'XX = Distance(0, 14) '0.26,0.311,0.129,0.131
'XX = PermValid(0, 17) '2467,3343,2065,1791
'XX = PermValid(0, 17) '2467,3343,2065,1791
'For X = 1 To Len(StrainSeq(0))
'    If SeqNum(X, 12) < 50 Then
'        X = X
'    End If
'Next X
'XX = PermNextno

   If DebuggingFlag < 2 Then On Error Resume Next
   UB = 0
   UB = UBound(PermValid, 1)
   UB1 = 0
   UB1 = UBound(Distance, 1)
   On Error GoTo 0
  
   If NextNo > UB Or NextNo > UB1 Then
        Call UnModNextno
        Call UnModSeqNum(0)
        
   End If '533284
    Call MakeSeqCoverage(1, PermValid())
    
     
    
    
    '533296
    If x = 123456 Then
        'MakeDistanceBak(ubound(distance,1), ubound(distancebak,1), nextno, distance(0,0),distancebak(0,0)
    Else
        
        
        'SS = Abs(GetTickCount)
        
        If x = x Then
        
            Dummy = MakeDistanceBakB(NextNo, UBound(distancebak, 1), UBound(Distance, 1), Distance(0, 0), distancebak(0, 0))
            
        Else
        
            For x = 0 To NextNo
        
                For Y = x + 1 To NextNo
                    
                    If Distance(x, Y) > 0 Then
                    
                        distancebak(x, Y) = (1 - Distance(x, Y))
                        distancebak(Y, x) = distancebak(x, Y)
                       
                    Else
                        distancebak(x, Y) = 0.999
                        distancebak(Y, x) = 0.999
                     
                    End If
                Next 'Y
        
            Next 'X
        End If
'        EE = Abs(GetTickCount)
'        TT = EE - SS '1.809 for nextno = 4715
'        '0.125 for freds 3800
       x = x
    End If
    
    ReDim XInstance(NextNo + 1), NodeLength(NextNo)
    
    '533248
    If TreeDistFlag = 0 Then
        ReDim TreeDistance(NextNo, NextNo)
    End If
    
   
    
    CJNode = 0
    '591048
    Dim DistMap() As Single, WinningX() As Long
    ReDim DistMap(NextNo), WinningX(NextNo)
    '
    'XX = UBound(TreeRX, 1)
    Dummy = MakeDistMapX(NextNo, DistMap(0), distancebak(0, 0), WinningX(0))
'5.078

    Do Until SortedNo = NextNo
        
        'ShortestDistance = ShortestDist(Nextno, SortedNo, distancebak(0, 0), treex(0, 0), treey(0))
        If DebuggingFlag < 2 Then On Error Resume Next
        ShortestDistance = ShortestDistB(NextNo, SortedNo, DistMap(0), WinningX(0), distancebak(0, 0), TreeX(0, 0), TreeY(0))
        On Error GoTo 0
        
        'XX = Distance(1, 10)
        If ShortestDistance = 1 Then
            For x = 0 To NextNo
                For Y = x + 1 To NextNo
                    If distancebak(x, Y) < ShortestDistance Then
                        ShortestDistance = distancebak(x, Y)
                        TreeX(SortedNo, 0) = x
                        TreeY(SortedNo) = Y
                    End If
                Next 'Y
            Next 'X
        End If
        
        'this is meant to fix the trees that are made from sequences with large amounts of missing data.
        If DistanceFlag = 2 Or DistanceFlag = 3 Then
             A = TreeX(SortedNo, 0)
             b = TreeY(SortedNo)
             
              
             For x = 0 To NextNo
                 
                 
                 If A <> x And b <> x Then
                     If PermValid(A, x) / 2 > PermValid(b, x) Then
                         distancebak(A, x) = distancebak(A, x) * PermValid(A, x) + distancebak(b, x) * PermValid(b, x)
                         distancebak(A, x) = distancebak(A, x) / (PermValid(A, x) + PermValid(b, x))
                         distancebak(b, x) = distancebak(A, x)
                         PermValid(b, x) = PermValid(A, x)
                         PermDIffs(b, x) = PermDIffs(A, x)
                         distancebak(x, b) = distancebak(A, x)
                         PermValid(x, b) = PermValid(A, x)
                         PermDIffs(x, b) = PermDIffs(A, x)
                     ElseIf PermValid(b, x) / 2 > PermValid(A, x) Then
                         distancebak(b, x) = distancebak(A, x) * PermValid(A, x) + distancebak(b, x) * PermValid(b, x)
                         distancebak(b, x) = distancebak(b, x) / (PermValid(A, x) + PermValid(b, x))
                         distancebak(A, x) = distancebak(b, x)
                         PermValid(A, x) = PermValid(b, x)
                         PermDIffs(A, x) = PermDIffs(b, x)
                         distancebak(x, A) = distancebak(b, x)
                         PermValid(x, A) = PermValid(b, x)
                         PermDIffs(x, A) = PermDIffs(b, x)
                         
                     End If
                 End If
            Next x
            
        End If
        
        
        If ShortestDistance = 1 Then
            'find the sequence missing from the tree
            
            For x = 0 To NextNo
                GoOn = 0
                For Y = 0 To NextNo
                    For Z = 0 To NextNo
                        If TreeX(Y, Z) = x Then
                            GoOn = 1
                            Exit For
                        ElseIf TreeX(Y, Z) = -1 Then
                            Exit For
                        End If
                    Next Z
                    If GoOn = 1 Then Exit For
                Next Y
                If GoOn = 0 Then
                    If x > 0 Then
                        TreeX(SortedNo, 0) = 0
                        TreeY(SortedNo) = x
                    Else
                        TreeX(SortedNo, 0) = 0
                        TreeY(SortedNo) = 1
                    End If
                    Exit For
                End If
            Next x
        
        End If
        
        NodeLength(SortedNo) = Int((ShortestDistance / 2) * 100000) / 100000
        
        'build Newick string
        
        Dim NodeLS1 As String, NodeLS2 As String
        NodeLS1 = Trim$(CStr(NodeLength(SortedNo) - CurLen(TreeX(SortedNo, 0))))
        NodeLS2 = Trim$(CStr(NodeLength(SortedNo) - CurLen(TreeY(SortedNo))))
        Pos = InStr(1, NodeLS1, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(NodeLS1, Pos, 1) = "."
        End If
        Pos = InStr(1, NodeLS2, ",", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(NodeLS2, Pos, 1) = "."
        End If
        
        If LF = 0 Or LF = 2 Then
            TempName(TreeX(SortedNo, 0)) = "(" + TempName(TreeX(SortedNo, 0)) + ":" + NodeLS1 + "," + TempName(TreeY(SortedNo)) + ":" + NodeLS2 + ")"
            CurLen(TreeX(SortedNo, 0)) = NodeLength(SortedNo)
        ElseIf LF = 3 Then
            TempName(TreeX(SortedNo, 0)) = "(" + TempName(TreeX(SortedNo, 0)) + ":" + NodeLS1 + "," + TempName(TreeY(SortedNo)) + ":" + NodeLS2 + ")"
            CurLen(TreeX(SortedNo, 0)) = NodeLength(SortedNo)
        End If
        
        If TreeDistFlag = 0 Then
            If ShortestDistance < 0.999999 Then
                TreeDistance(TreeX(SortedNo, 0), TreeY(SortedNo)) = 1 - (ShortestDistance / 2)
                TreeDistance(TreeY(SortedNo), TreeX(SortedNo, 0)) = 1 - (ShortestDistance / 2)
            End If
        End If
        '@'&
        Dummy = AddSeqToUPGMA(NextNo, SortedNo, XInstance(0), distancebak(0, 0), TreeX(0, 0), TreeY(0), Check(0), NodeYPos(0))
        
        
        x = TreeX(SortedNo, 0)
        Z = TreeY(SortedNo)
        
        DistMap(x) = 100
        DistMap(TreeY(SortedNo)) = 100
        
        '@'&
        Dummy = UpdateDistMapX(x, Z, NextNo, DistMap(0), distancebak(0, 0), WinningX(0))
        x = x
        SortedNo = SortedNo + 1
    Loop
    '601160
    
     
    
    
    If TreeDistFlag = 0 Then
        'XX = UBound(TreeDistance, 1)
        '&
        Dummy = TreeDist2(NextNo, TreeX(0, 0), TreeY(0), TreeDistance(0, 0))
        
        
       
        TreeDistFlag = 1
        For x = 0 To NextNo
            TreeDistance(x, x) = 1
        Next x
    End If
    '6.234 seconds
    
    
    
    
    'ee2 = Abs(GetTickCount)
    'tt2 = ee2 - SS2
    '7.4
    '4.765 using ints in for loops instead of short ints
    '5.609 using a,x,y offsets
    '4.765 using x,y offsets
    '4.562 using brackets in pointers
    '4.546 using breaks instead of x=nextno etc.
    '4.532 using elses
    '0.047 using new method in VB
    
    If LF = 0 Then
        
        
       
        '@
        nt = 0
        For x = 0 To NextNo
            TS = "-Group G" & Trim(nt)
            NS = 0
            For Y = 0 To NextNo
                If TreeX(x, Y) = -1 Then Exit For
                TS = TS & " " & OriginalName(TreeX(x, Y))
                
                NS = NS + 1
            Next Y
            If NS > 2 Then
                
                nt = nt + 1
            End If
        Next x
        Form1.SSPanel6(1).Enabled = True
        NHString(0) = TempName(TreeX(SortedNo - 1, 0)) + ";"
        'Open "test.txt" For Output As #10
        'Print #10, StraiName(44)
        'Print #10, OriginalName(44)
        
        
        'Print #10, NHString(0)
        'Close #10
        Form1.SSPanel1.Caption = OldCaption$
        
    ElseIf LF = 2 Then
        TempNHF = TempName(TreeX(SortedNo - 1, 0)) + ";"
    ElseIf LF = 3 Then
        TempNHF = TempName(TreeX(SortedNo - 1, 0)) + ";"
    End If
    
    
  
  'EE = Abs(GetTickCount)
  'TT = EE - SS
  '8.110 seconds
  '5.219 win nextno = short int
  '5.234 with ints instead of short ints in shortestdist
  '5.032 using xoff in shortestdist
  '5.000 using brackets in pointers in shortestdist
  'X = X
    
End Sub
Public Sub DrawTree()

    Dim FF As Long, oDir As String, NameWidth() As Integer, YAdjD As Integer
    Dim NodeAdjust As Long, x As Long
    Dim Xpos() As Double, YPos() As Double
    Dim FormerXPos As Double, ScaleSize As Double, FirstPos As Double, OldFontSize As Double

    ReDim Xpos(NextNo)
    ReDim YPos(NextNo)
   
    ReDim NameWidth(NextNo)
    Form1.Picture16.Picture = LoadPicture()
    
    Form1.Picture16.ScaleMode = 3
    Form1.Picture16.BackColor = BackColours
    Form1.Picture16.BackColor = BackColours
    Form1.Picture16.CurrentY = 0
    Form1.Picture16.ForeColor = QBColor(0)
    Form1.Picture16.FontSize = 8.25
    YAdjD = 14
    Form1.Picture16.FontSize = 8.25
    OldFontSize = Form1.Picture16.FontSize

    Call TreeFont(0)

    
    If NodeLength(NextNo - 1) > 0 Then
        NodeAdjust = (TRegion - 10) / NodeLength(NextNo - 1)
    Else
        NodeAdjust = 1000
    End If
    
    'Calculate tree distances
    
    
    FirstPos = CInt(TRegion) - 5
    
    

Dim Y As Long, Z As Long, ColPos() As Double, ExtraMod As Byte
ReDim ColPos(NextNo)
'go from last partition to first and average the colpos of each partition
'go from first partition to last and adjust colpos around average pos
    
Dim ColEvol() As Double, RC As Long, GC As Long, BC As Long, MinCol(2) As Double, MaxCol(2) As Double, ZOK(2, 1) As Byte, Round As Byte
ReDim ColEvol(NextNo, 2)


ZOK(0, 0) = 1
ZOK(0, 1) = 2
ZOK(1, 0) = 2
ZOK(1, 1) = 0
ZOK(2, 0) = 0
ZOK(2, 1) = 1


If DoneColFlag = 0 Then
        Rnd (-BSRndNumSeed)
        Z = -1
        MinCol(0) = 1000000
        MinCol(1) = 1000000
        MinCol(2) = 1000000
        For Y = NextNo - 1 To 0 Step -1
            Z = Z + 1
            If Z = 3 Then
                Z = 0
            End If
            ColEvol(TreeY(Y), Z) = ColEvol(TreeY(Y), Z) + NodeLength(Y)
            If ColEvol(TreeY(Y), Z) > MaxCol(Z) Then MaxCol(Z) = ColEvol(TreeY(Y), Z)
                    
            Z = Z + 1
            If Z = 3 Then
                Z = 0
            End If
            'x = UBound(TreeRX, 1)
            For x = 0 To NextNo
                If TreeX(Y, x) = TreeY(Y) Then
                    Exit For
                End If
                If TreeX(Y, x) <> -1 Then
                    ColEvol(TreeX(Y, x), Z) = ColEvol(TreeX(Y, x), Z) + NodeLength(Y)
                    
                    
                Else
                    Exit For
                End If
            Next x
        Next Y
        For x = 0 To NextNo
            For Z = 0 To 2
                If ColEvol(x, Z) > MaxCol(Z) Then MaxCol(Z) = ColEvol(x, Z)
                'If ColEvol(X, Z) < MinCol(Z) Then
                '    MinCol(Z) = ColEvol(X, Z)
                '    XX = ColEvol(X, 0)
                '    XX = ColEvol(X, 1)
                '    XX = ColEvol(X, 2)
                'End If
            Next Z
        Next x
        
        For x = 0 To NextNo
            
            If MaxCol(0) > 0 Then
                RC = (ColEvol(x, 0) / MaxCol(0)) * 230
            Else
                RC = 0
            End If
            If MaxCol(1) > 0 Then
                GC = (ColEvol(x, 1) / MaxCol(1)) * 200
            Else
                GC = 0
            End If
            'GC = (ColEvol(X, 1) / MaxCol(1)) * 200
            If MaxCol(2) > 0 Then
                BC = (ColEvol(x, 2) / MaxCol(2)) * 200
            End If
            If RC <= GC And RC <= BC Then
                RC = RC / 2
            ElseIf BC <= GC And BC <= RC Then
                BC = BC / 2
            ElseIf GC <= RC And GC <= BC Then
                GC = GC / 2
            End If
            SeqCol(x) = RGB(RC, GC, BC) '163,174,77
            
            FFillCol(x) = RGB(RC + (BkR - RC) / 1.25, GC + (BkG - GC) / 1.25, BC + (BkB - BC) / 1.25)
        Next x
        DoneColFlag = 1
        'XX = SeqCol(3) '3445930
    End If
    Dim NodeFind() As Byte
    If PermNextno > NextNo Then
        ReDim NodeFind(PermNextno + 2, PermNextno + 2)
    Else
        ReDim NodeFind(NextNo + 2, NextNo + 2)
    End If
    If TreeXInFileFlag = 1 Then
        If TreeXUB = NextNo Then
        ReDim TreeX(TreeXUB, TreeXUB) ' = UBound(TreeX, 1)
        
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Get #FF, , TreeX()
        Close #FF
        ChDir oDir
        ChDrive oDir
        Else
            TreeXInFileFlag = 0
        End If
        'Erase TreeX
    End If
    
     
    Call UPGMADraw(TreeTrace(), TreeTraceSeqs(), PermNextno, NodeFind(), NodeXY(), 0, 0, NextNo, NodeLength(), TreeX(), TreeY())
    
    Form1.Picture16.Refresh
End Sub

Public Sub SpacerFind()

    Dim InlyerA As Integer, InlyerB As Integer
    Dim x As Long
    
    If TreeDistance(Seq1, Seq2) < TreeDistance(Seq2, Seq3) And TreeDistance(Seq1, Seq3) < TreeDistance(Seq2, Seq3) Then
        InlyerA = Seq2
        InlyerB = Seq3
        Outlyer = Seq1
    ElseIf TreeDistance(Seq1, Seq2) < TreeDistance(Seq1, Seq3) And TreeDistance(Seq2, Seq3) < TreeDistance(Seq1, Seq3) Then
        InlyerA = Seq1
        InlyerB = Seq3
        Outlyer = Seq2
    Else
        InlyerA = Seq1
        InlyerB = Seq2
        Outlyer = Seq3
    End If
    
    InRangeFlag = 1
    
    
    
    
    If MiDistance > 0 Or MaDistance < 1 Then
        If (Distance(Outlyer, InlyerA) > MiDistance Or Distance(Outlyer, InlyerB) > MiDistance) And (Distance(Outlyer, InlyerA) < MaDistance Or Distance(Outlyer, InlyerB) < MaDistance) Then
            InRangeFlag = 1
        Else
            InRangeFlag = 0
            Exit Sub
        End If
    End If
    
    
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
    
    SpacerNo = 0
    
    If SpacerFlag = 1 Then

        For x = 0 To NextNo

            If MaskSeq(x) < 2 Then
                If x <> InlyerA And x <> InlyerB And x <> Outlyer Then
                    If TreeDistance(x, InlyerA) < TreeDistance(InlyerA, InlyerB) Then
    
                        If TreeDistance(x, InlyerA) > TreeDistance(InlyerA, Outlyer) Then
    
                                SpacerNo = SpacerNo + 1
                                SpacerSeqs(SpacerNo) = x
                                ValidSpacer(SpacerNo) = 1
    
                        ElseIf TreeDistance(x, InlyerA) = TreeDistance(InlyerA, Outlyer) And TreeDistance(x, Outlyer) < TreeDistance(InlyerA, InlyerB) Then
    
                                SpacerNo = SpacerNo + 1
                                SpacerSeqs(SpacerNo) = x
                        
                        End If
                    End If
                End If
            End If

        Next 'X
        'Exit Sub
    ElseIf SpacerFlag = 2 Then

        For x = 0 To NextNo

            If MaskSeq(x) < 2 Then

                If TreeDistance(x, InlyerA) < TreeDistance(InlyerA, InlyerB) Then

                    If x <> InlyerA And x <> InlyerB And x <> Outlyer Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = x
                    End If

                End If

            End If

        Next 'X

    ElseIf SpacerFlag = 3 Then

        For x = 0 To NextNo

            If MaskSeq(x) < 2 Then

                If TreeDistance(x, Outlyer) < TreeDistance(InlyerA, Outlyer) Then

                    If x <> InlyerA And x <> InlyerB And x <> Outlyer Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = x
                    End If

                End If

            End If

        Next 'X

    End If
    If PermNextno > MemPoc Then
        ReDim TreeDistance(0, 0)
    End If
End Sub

Public Sub DrawPlots(Seq1 As Long, Seq2 As Long, Seq3 As Long)

    Dim NumLines As Long, x As Long, Y As Long
    Dim YScaleFactor As Double

    Form1.Picture7.Picture = LoadPicture()
    
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    Form1.Picture7.Cls
    'Draw identity plot in picturebox 7

    Dim PntAPI As POINTAPI
    Dim Pict As Long

    Pict = Form1.Picture7.hdc
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))

    

    RDPUD = 0
    RDPLD = 1
    'XX = UBound(XOverHomologyNum, 1)
    For Y = 0 To 2

        For x = 1 To LenXoverSeq

            If XOverHomologyNum(x, Y) > RDPUD Then
                RDPUD = XOverHomologyNum(x, Y)
            ElseIf XOverHomologyNum(x, Y) < RDPLD Then
                RDPLD = XOverHomologyNum(x, Y)
            End If

        Next 'X

    Next 'Y
    
    
    'Get everything into the standard format for printing and saving
    NumLines = 6 'number of lines to print
    ReDim GPrint(NumLines - 1, LenXoverSeq + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, LenXoverSeq + 1)

    ReDim GVarPos(0, LenXoverSeq)
    For x = 1 To LenXoverSeq
        GVarPos(0, x) = XDiffPos(x)
    Next x
    If XDiffPos(0) = 0 Then XDiffPos(0) = XDiffPos(1)
    ReDim GCritval(10)
    GCritval(0) = 0
    GLegend = "Pairwise identity"
    GPrintLen = LenXoverSeq + 1 'how many points to plot
    GPrintCol(0) = Yellow 'line is yellow
    GPrintCol(1) = Green 'line is green
    GPrintCol(2) = Purple ''line is purple
    GPrintCol(3) = Yellow 'line is yellow
    GPrintCol(4) = Green 'line is green
    GPrintCol(5) = Purple ''line is purple
    GPrintNum = NumLines - 1 'six lines
    GPrintType = 0 'a normal line plot
    Dim Div As Double
    Div = (Int(XOverWindowX / 2) * 2 + 1)
    GPrintMin(0) = RDPLD / Div 'bottom val
    GPrintMin(1) = RDPUD / Div 'upper val
    
    For x = 0 To LenXoverSeq
        For Y = 0 To 2
            GPrint(Y, x) = XOverHomologyNum(x, Y) / Div
            GPrint(Y + 3, x) = XOverHomologyNum(x, Y) / Div
            GPrintPos(Y, x) = XDiffPos(x)
            GPrintPos(Y + 3, x) = XDiffPos(x)
        Next Y
    Next x
    
 '***************************************
'    For X = 0 To NumLines - 1
'        GPrintPos(X, GPrintLen) = Len(StrainSeq(0))
'        GPrint(X, GPrintLen) = (GPrint(X, GPrintLen - 1) + GPrint(X, 1)) / 2
'        GPrintPos(X, 0) = 1
'        GPrint(X, 0) = (GPrint(X, GPrintLen - 1) + GPrint(X, 1)) / 2
'    Next X
    
    
    
    
    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
    'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, RDPUD / (Int(XOverWindowX / 2) * 2 + 1), RDPLD / (Int(XOverWindowX / 2) * 2 + 1), 1, "Pairwise identity")

    Form1.Picture7.DrawWidth = 3
    Dim PHX As Long, RDPA As Single
    PHX = PicHeight - 35
    RDPA = (RDPUD - RDPLD)
    'SS = Abs(GetTickCount)
'    For Y = 0 To 2
'        Pict = Form1.Picture7.hDC
'
'        If Y = 0 Then
'            Form1.Picture7.ForeColor = mYellow
'        ElseIf Y = 1 Then
'            Form1.Picture7.ForeColor = LGreen
'        Else
'            Form1.Picture7.ForeColor = LPurple
'        End If
'
'        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
'            Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
'
'        Else
'            Dim YP As Long, XP As Long, OXP As Long
'            Dim MaY As Long, MiY As Long
'            MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * xFactor, PicHeight - (15 + (((XOverHomologyNum(LenXOverSeq, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35)), PntAPI
'            OXP = 0
'            For X = 1 To LenXOverSeq
'                YP = PicHeight - (15 + (((XOverHomologyNum(X, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35))
'                XP = 30 + Decompress(XDiffPos(X)) * xFactor + xFactor
'                If OXP <> XP Then
'                    MiY = 10000
'                    MaY = 0
'                End If
'                OXP = XP
'                If YP > MaY Or YP < MiY Then
'                    LineTo Pict, XP, YP
'                    If YP > MaY Then MaY = YP
'                    If YP < MiY Then MiY = YP
'                End If
'            Next 'X
'        End If
'    Next 'Y
'    EE = Abs(GetTickCount)
'    TT = EE - SS
    If RelX > 0 Or RelY > 0 Then
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
        End If
    End If

    'Form1.Picture7.Refresh
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = QBColor(0)
'    X = LenXOverSeq
'    'For Z = 0 To 1
'        Z = 1
'        For Y = 0 To 2
'            Pict = Form1.Picture7.hDC
'
'            If Z = 0 Then
'                Form1.Picture7.DrawWidth = 2
'                If Y = 0 Then
'                    Form1.Picture7.ForeColor = mYellow
'                ElseIf Y = 1 Then
'                    Form1.Picture7.ForeColor = mGreen
'                Else
'                    Form1.Picture7.ForeColor = mPurple
'                End If
'            Else
'                Form1.Picture7.DrawWidth = 1
'                If Y = 0 Then
'                    Form1.Picture7.ForeColor = Yellow
'                ElseIf Y = 1 Then
'                    Form1.Picture7.ForeColor = green
'                Else
'                    Form1.Picture7.ForeColor = Purple
'                End If
'
'            End If
'
'            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
'                Dummy = DrawRDPPlot(Y, LenXOverSeq, UBound(XOverHomologyNum, 1), RDPLD, RDPUD, PicHeight, Pict, xFactor, XDiffPos(0), XOverHomologyNum(0, 0))
'
'            Else
'                MoveToEx Pict, 30 + Decompress(XDiffPos(1)) * xFactor, PicHeight - (15 + (((XOverHomologyNum(LenXOverSeq, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35)), PntAPI
'
'                For X = 1 To LenXOverSeq
'                    LineTo Pict, 30 + Decompress(XDiffPos(X)) * xFactor + xFactor, PicHeight - (15 + (((XOverHomologyNum(X, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35))
'                Next 'X
'            End If
'        Next 'Y
'   ' Next Z

    'For some odd reason this C-routine is slower than its VB eqvalent
    '    For Y = 0 To 2
    '
    '        If Y = 0 Then
    '            Form1.Picture7.ForeColor = Yellow
    '        ElseIf Y = 1 Then
    '            Form1.Picture7.ForeColor = Green
    '        Else
    '            Form1.Picture7.ForeColor = Purple
    '        End If
    '        Pict = Form1.Picture7.hdc
    '        Dummy = PlotDraw(Pict, LenXoverSeq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, Y))
    '
    '    Next 'Y
    If DontRedrawPlotsFlag = 0 Then
        WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
        WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
        Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
    End If
    'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
    RDPUD = RDPUD / (Int(XOverWindowX / 2) * 2 + 1)
    RDPLD = RDPLD / (Int(XOverWindowX / 2) * 2 + 1)
    
    Call RedrawPlotAA(1)
    
End Sub

Public Sub PrintHomolPlots()
    On Error GoTo errorhandler
    'Print button click event.
    'The subroutine works but just barely.
    Printer.Font = "Ariel"
    'Declare variables.
    'Set variables
    scaleaddjust = 3
    PrinterDefault = True
    Printer.ScaleMode = 1
    Printer.FontTransparent = True
    Printer.Zoom = 50
    ' Exit Sub

    Dim FontSizeT As Double

    Printer.ScaleMode = 3
    FontSizeT = 16 - (NextNo / 10)

    If FontSizeT < 4 Then FontSizeT = 4
    Printer.FontSize = 10
    Printer.DrawMode = 13 'Set drawmode to "copy pen"
    Printer.DrawStyle = 0
    Printer.DrawWidth = 1
    Printer.ForeColor = 0
    Printer.Orientation = 1
    'offset = (((Printer.Width - Picture2.ScaleWidth) / 2) / Screen.TwipsPerPixelX) * 3
    'Picture2.ScaleMode = 3

    Dim XMove As Integer
    Dim YMove As Integer

    XMove = 600
    YMove = 400
    Printer.DrawMode = 13
    'call UPGMA
    XFactor = (Printer.ScaleWidth - 800) / Decompress(Len(StrainSeq(0)))
    PicHeight = Printer.ScaleHeight / 4
    Printer.Font = "Ariel"
    'Dim XFactor As Double

    Dim TotalLen As Integer
    Dim YAdd As Integer

    'Inform user of the sequences being compared

    If RunFlag = 0 Then
        Printer.ForeColor = QBColor(0)

        If SpacerFlag > 0 Then

            If SpacerNo > 0 Then
                Printer.CurrentX = 0
                Printer.CurrentY = 70
                Printer.Print "REFERENCE SEQUENCES:"

                For x = 1 To SpacerNo
                    Printer.CurrentX = 0
                    Printer.CurrentY = 80 + 10 * x
                    Printer.Print OriginalName(SpacerSeqs(x))
                Next 'X

            End If

        Else
            Printer.CurrentX = 0
            Printer.CurrentY = 70
            Printer.ForeColor = RGB(255, 0, 0)
            Printer.Print "NO REFERENCE SEQUENCES:"
            Printer.ForeColor = RGB(0, 0, 0)
        End If

        'Printer.Refresh
    Else
        Printer.CurrentX = 0
        Printer.ForeColor = QBColor(0)

        If SpacerFlag > 0 Then

            If SpacerNo > 0 Then
                Printer.CurrentX = XMove - 100
                Printer.CurrentY = YMove + 300 + PicHeight
                Printer.Print "REFERENCE SEQUENCES:"
                YAdd = 0
                TotalLen = 0

                For x = 1 To SpacerNo
                    Printer.CurrentX = XMove - 100 + TotalLen
                    Printer.CurrentY = YMove + 340 + PicHeight + YAdd '+ 10 * X
                    Printer.Print OriginalName(SpacerSeqs(x))
                    TotalLen = TotalLen + 400

                    If TotalLen > Printer.ScaleWidth - 50 Then TotalLen = 0: YAdd = YAdd + 40
                Next 'X

            End If

        Else
            Printer.CurrentX = XMove - 100
            Printer.CurrentY = YMove + 300 + PicHeight
            Printer.ForeColor = RGB(255, 0, 0)
            Printer.Print "NO REFERENCE SEQUENCES"
            Printer.ForeColor = RGB(0, 0, 0)
        End If

    End If

    'Draw homology plot in picturebox 7
    'Form1.Picture7.Picture = Printer.Picture
    'Form1.Picture7.Top = 0
    'Form1.Picture7.Left = 0
    'Pict = Form1.Picture7.hdc
    '    Form1.Picture7.ForeColor = QBColor(0)
    '    dummy = DrawDiffs(Pict, lenxoverseq, XFactor, XDiffPos(0))
    '
    '    Form1.Picture7.ForeColor = QBColor(8)
    '    dummy = PlotDraw(Pict, lenxoverseq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, 0))
    '
    '    Form1.Picture7.ForeColor = green
    '    dummy = PlotDraw(Pict, lenxoverseq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, 1))
    '
    '    Form1.Picture7.ForeColor = purple
    '    dummy = PlotDraw(Pict, lenxoverseq, PicHeight, XFactor, XDiffPos(0), XOverHomologyNum(0, 2))
    Printer.DrawWidth = 2

    For x = 1 To LenXoverSeq - 1
        'z = z + 1
        'Form1.Picture7.ForeColor = QBColor(0)
        'dummy = MoveToEx(pict, 10 + XDiffPos(X) * XFactor, 10, pntapi)
        'dummy = LineTo(pict, 10 + XDiffPos(X) * XFactor, 15)
        'Printer.ForeColor = QBColor(8)
        Printer.Line (XMove + XDiffPos(x + 1) * XFactor, YMove + PicHeight - (15 + XOverHomologyNum(x + 1, 0) * (PicHeight - 35)))-(XMove + XDiffPos(x) * XFactor + XFactor, YMove + PicHeight - (15 + XOverHomologyNum(x, 0) * (PicHeight - 35))), Yellow
        Printer.Line (XMove + XDiffPos(x + 1) * XFactor, YMove + PicHeight - (15 + XOverHomologyNum(x + 1, 1) * (PicHeight - 35)))-(XMove + XDiffPos(x) * XFactor + XFactor, YMove + PicHeight - (15 + XOverHomologyNum(x, 1) * (PicHeight - 35))), RGB(255, 0, 255)
        Printer.Line (XMove + XDiffPos(x + 1) * XFactor, YMove + PicHeight - (15 + XOverHomologyNum(x + 1, 2) * (PicHeight - 35)))-(XMove + XDiffPos(x) * XFactor + XFactor, YMove + PicHeight - (15 + XOverHomologyNum(x, 2) * (PicHeight - 35))), RGB(0, 255, 255)
        '               Form1.Picture7.Line (25, 15)-(25, PicHeight - 10), QBColor(0)
        '               Form1.Picture7.Line (25, PicHeight - 10)-(Form1.Picture7.ScaleWidth - 5, PicHeight - 10), QBColor(0)
        '
        '
        '        dummy = MoveToEx(10 + XDiffPos(X) * XFactor, PicHeight - (15 + XOverHomologyNum(X + 1, 0) * (PicHeight - 35)))
        '        dummy = LineTo(10 + Len(strainseq(0)) * XFactor + XFactor, PicHeight - (15 + XOverHomologyNum(1, 0) * (PicHeight - 35)))
        '   Printer.ForeColor = green
        '   dummy = MoveToEx(Pict, 10 + XDiffPos(X) * XFactor, PicHeight - (15 + XOverHomologyNum(X + 1, 1) * (PicHeight - 35)), pntapi)
        '   dummy = LineTo(Pict, 10 + Len(strainseq(0)) * XFactor + XFactor, PicHeight - (15 + XOverHomologyNum(1, 1) * (PicHeight - 35)))
        '  Printer.ForeColor = purple
        '  dummy = MoveToEx(Pict, 10 + XDiffPos(X) * XFactor, PicHeight - (15 + XOverHomologyNum(X + 1, 2) * (PicHeight - 35)), pntapi)
        '  dummy = LineTo(Pict, 10 + Len(strainseq(0)) * XFactor + XFactor, PicHeight - (15 + XOverHomologyNum(1, 2) * (PicHeight - 35)))
    Next 'X

    Printer.Line (XMove - 25, YMove)-(575, PicHeight + YMove + 25), QBColor(0)
    Printer.Line (XMove - 25, PicHeight + YMove + 25)-(25 + (XFactor * Len(StrainSeq(0)) + XMove), PicHeight + YMove + 25), QBColor(0)
    'Y-Axis tick marks
    Printer.Line (XMove - 25, YMove + 15)-(XMove - 10, YMove + 15), RGB(0, 0, 0)
    Printer.Line (XMove - 25, YMove - 15 + PicHeight)-(XMove - 10, YMove - 15 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove - 25, YMove - 15 + (PicHeight) / 2)-(XMove - 10, YMove - 15 + (PicHeight) / 2), RGB(0, 0, 0)
    '               'X-Axis tick marks
    Printer.Line (XMove, YMove + 25 + PicHeight)-(XMove, YMove + 5 + PicHeight), RGB(0, 0, 0)
    Printer.Line ((XFactor * Len(StrainSeq(0)) + XMove), YMove + 5 + PicHeight)-((XFactor * Len(StrainSeq(0)) + 600), YMove + 25 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove + ((XFactor * Len(StrainSeq(0)))) / 2, YMove + 5 + PicHeight)-(XMove + ((XFactor * Len(StrainSeq(0)))) / 2, YMove + 25 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove + ((XFactor * Len(StrainSeq(0)))) / 4, YMove + 5 + PicHeight)-(XMove + ((XFactor * Len(StrainSeq(0)))) / 4, YMove + 25 + PicHeight), RGB(0, 0, 0)
    Printer.Line (XMove + ((XFactor * Len(StrainSeq(0)))) / 1.333, YMove + 5 + PicHeight)-(XMove + ((XFactor * Len(StrainSeq(0)))) / 1.333, YMove + 25 + PicHeight), RGB(0, 0, 0)
    '               Printer.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, 425 + PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 4, 405 + PicHeight), RGB(255, 0, 0)
    '               Printer.Line (30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, 425 + PicHeight)-(30 + (Form1.Picture7.ScaleWidth - 10 - 30) / 1.333, 405 + PicHeight), RGB(255, 0, 0)
    Printer.ForeColor = RGB(0, 0, 0)

    For x = 1 To LenXoverSeq
        'XDiffPos(0) = X
        Printer.Line (XMove + XFactor * XDiffPos(x), YMove - 10)-(XMove + XFactor * XDiffPos(x), YMove - 30)
    Next 'X

    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove - 10
    Printer.Print "1.0"
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove - 40 + PicHeight / 2
    Printer.Print "0.5"
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove - 40 + PicHeight
    Printer.Print "0.0"
    Printer.CurrentX = XMove - 10
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print "1"

    Dim Addjust As Integer

    Addjust = 0

    If (Len(StrainSeq(0))) / 10 < 1 Then
        Addjust = 10
    ElseIf (Len(StrainSeq(0))) / 100 < 1 Then
        Addjust = 25
    ElseIf (Len(StrainSeq(0))) / 1000 < 1 Then
        Addjust = 40
    ElseIf (Len(StrainSeq(0))) / 10000 < 1 Then
        Addjust = 55
    ElseIf (Len(StrainSeq(0))) / 100000 < 1 Then
        Addjust = 70
    ElseIf (Len(StrainSeq(0))) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XFactor * Len(StrainSeq(0)) + XMove - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Len(StrainSeq(0))
    Addjust = 0

    If ((Len(StrainSeq(0))) / 2) / 10 < 1 Then
        Addjust = 10
    ElseIf ((Len(StrainSeq(0))) / 2) / 100 < 1 Then
        Addjust = 25
    ElseIf ((Len(StrainSeq(0))) / 2) / 1000 < 1 Then
        Addjust = 40
    ElseIf ((Len(StrainSeq(0))) / 2) / 10000 < 1 Then
        Addjust = 55
    ElseIf ((Len(StrainSeq(0))) / 2) / 100000 < 1 Then
        Addjust = 70
    ElseIf ((Len(StrainSeq(0))) / 2) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 2 - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Int(Len(StrainSeq(0)) / 2)
    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 2 - 200
    Printer.CurrentY = YMove + 100 + PicHeight
    Printer.Print "Position in alignment"
    Addjust = 0

    If ((Len(StrainSeq(0))) / 1.333) / 10 < 1 Then
        Addjust = 10
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 100 < 1 Then
        Addjust = 25
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 1000 < 1 Then
        Addjust = 40
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 10000 < 1 Then
        Addjust = 55
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 100000 < 1 Then
        Addjust = 70
    ElseIf ((Len(StrainSeq(0))) / 1.333) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 1.333 - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Int(Len(StrainSeq(0)) / 1.333)
    Addjust = 0

    If ((Len(StrainSeq(0))) / 4) / 10 < 1 Then
        Addjust = 10
    ElseIf ((Len(StrainSeq(0))) / 4) / 100 < 1 Then
        Addjust = 25
    ElseIf ((Len(StrainSeq(0))) / 4) / 1000 < 1 Then
        Addjust = 40
    ElseIf ((Len(StrainSeq(0))) / 4) / 10000 < 1 Then
        Addjust = 55
    ElseIf ((Len(StrainSeq(0))) / 4) / 100000 < 1 Then
        Addjust = 70
    ElseIf ((Len(StrainSeq(0))) / 4) / 1000000 < 1 Then
        Addjust = 85
    End If

    Printer.CurrentX = XMove + ((XFactor * Len(StrainSeq(0)))) / 4 - Addjust
    Printer.CurrentY = YMove + 50 + PicHeight
    Printer.Print Int(Len(StrainSeq(0)) / 4)
    Printer.ForeColor = Yellow
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove + 140 + PicHeight
    Printer.Print OriginalName(Seq1) & "-" & OriginalName(Seq2)
    Printer.ForeColor = RGB(255, 0, 255)
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove + 180 + PicHeight
    Printer.Print OriginalName(Seq1) & "-" & OriginalName(Seq3)
    Printer.ForeColor = RGB(0, 255, 255)
    Printer.Print ""
    Printer.CurrentX = XMove - 100
    Printer.CurrentY = YMove + 220 + PicHeight
    Printer.Print OriginalName(Seq2) & "-" & OriginalName(Seq3)
    'Printer.ForeColor = RGB(255, 0, 0)
    Printer.Line (XMove + RecStart * XFactor, YMove - 95)-(XMove + RecEnd * XFactor, YMove - 95)
    Printer.Line (XMove + RecStart * XFactor, YMove - 85)-(XMove + RecStart * XFactor, YMove - 105)
    Printer.Line (XMove + RecEnd * XFactor, YMove - 85)-(XMove + RecEnd * XFactor, YMove - 105)
    Printer.CurrentX = XMove - 20 + RecStart * XFactor
    Printer.CurrentY = YMove - 160
    Printer.Print RecStart
    Printer.CurrentX = XMove - 20 + RecEnd * XFactor
    Printer.CurrentY = YMove - 80
    Printer.Print RecEnd
    Printer.CurrentX = XMove + RecEnd * XFactor + 70
    Printer.CurrentY = YMove - 120
    Printer.Print RecProb
    Printer.CurrentX = XMove + RecEnd * XFactor + 40
    Printer.CurrentY = YMove - 120
    Printer.Font.Italic = True
    Printer.Print "P ="
    Printer.Font.Italic = False
    'Print probability
    '                        Form1.Picture7.CurrentX = 1 + ProbX '10 + XDiffPos(XOverList(CurrentXOver).Beginning) * XFactor
    '
    '                        Form1.Picture7.CurrentY = 1 + ProbY 'PicHeight - (15 + XHomology((XOverList(CurrentXOver).Beginning + ((XOverList(CurrentXOver).Ending - XOverList(CurrentXOver).Beginning) / 2)), Seq2, Seq3) * (PicHeight - 35))
    '
    '                        out$ = left$(ProbTest$, 4)
    '                        power$ = right$(ProbTest$, Len(ProbTest$) - (Pos + 1))
    '
    '                        Form1.Picture7.FontSize = 7
    '                        Form1.Picture7.ForeColor = QBColor(15)
    '                        Form1.Picture7.Print out$ + " X 10 "
    '                        Form1.Picture7.FontSize = 5
    Form1.Picture7.Enabled = True
    Form1.Picture7.Refresh
    Printer.EndDoc
    Exit Sub
errorhandler:
End Sub

Public Sub XOverIII(SPF)

    Dim PT As Variant, AFact As Double, NCommon As Long, Dummy As Long, oDir As String, EndFlag As Long, Temp As Integer
    Dim StartPosX As Long, NextPosX As Long, UB As Long, FF As Long, x As Long, ET1 As Long, ET2 As Long, BT1 As Long, BT2 As Long
    Dim StringX As String
    Dim MinPA As Double
    Dim ActiveSeq As Integer
    Dim ActiveMajorP As Integer
    Dim ActiveMinorP As Integer
    Dim SeqDaughter As Integer
    Dim SeqMinorP As Integer, OXOV As Double, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long
    
    
    
    If CurrentCheck = -1 Then
        OXOV = XoverList(RelX, RelY).Probability
    End If
    oSeq1 = Seq1
    oSeq2 = Seq2
    oSeq3 = Seq3
   'Seq1 = 3
   ' Seq2 = 19
   ' Seq3 = 0
    MinPA = 1
    FirstDrawFlag = 0
    'SpacerFlag = 4
'XX = originalname(Seq1)
'XX = originalname(Seq2)
'XX = originalname(Seq3)
    'Dim AvHomol() As Double
    If NextNo = -1 Then Exit Sub
   
    ReDim ValidSpacer(NextNo)
    'ReDim SpacerSeqs(Nextno)

    Dim HighHomol As Integer
    Dim MedHomol As Integer
    Dim LowHomol As Integer

    If DistanceFlag = 0 Then  'If distancematrix not yet calculated and if a "spacer" is required

        Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)

    End If

    'Find "spacer sequences"
    'NJFlag = 0

    If NJFlag = 0 Then
        
        
        
        Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
        
        If PermNextno > MemPoc And TreeXInFileFlag = 0 Then
            TreeXUB = UBound(TreeX, 1)
            TreeXInFileFlag = 1
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            FF = FreeFile
            Open "RDP5TreeX" + UFTag For Binary As #FF
            Put #FF, , TreeX()
            Close #FF
            ChDir oDir
            ChDrive oDir
            Erase TreeX
        End If
       
        NJFlag = 1
    End If
    
    If SpacerFlag < 4 And SpacerFlag > 0 Then
        ReDim ValidSpacer(NextNo)
        ReDim SpacerSeqs(NextNo)
        
        'If UBound(TreeDistance, 1) <> Nextno Then
        '
       '
        'End If
        If Seq1 <= NextNo And Seq2 <= NextNo And Seq3 <= NextNo Then
            InRangeFlag = SpacerFindB(NextNo, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNo, TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqs(0), ValidSpacer(0))
        End If
        'Call SpacerFind
        If PermNextno > MemPoc And x = 1234567 Then
            ReDim Distance(0, 0)
        End If
    Else
        ReDim ValidSpacer(NextNo)
        ReDim SpacerSeqs(NextNo)
        SpacerNo = 1
        SpacerSeqs(1) = Spacer4No
        'originalname(14) = x
    End If

    'If SpacerNo = 0 And SpacerFlag > 0 And ExeCheckFlag = 0 Then Exit Sub
    
    LenStrainSeq = Len(StrainSeq(0)) + 1
    
    If ExeCheckFlag = 0 Then
        XOverSeq(0) = ""
        XOverSeq(1) = ""
        XOverSeq(2) = ""
    End If
    
    'Find Information Rich Subsequences
    'SpacerFlag = 0
    ' If SpacerFlag > 0 And SpacerNo > 0 Then
    'C routine for finding information rich subsequences (it does the same thing as the
    'VB routine FindSubSeqX)
    'Call FindSubSeqX
    '      lenxoverseq = FindSubSeq(SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XOverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0))
    
    Call FindSubSeqRDP
    If LenXoverSeq = 0 Then Exit Sub
    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000
    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000
    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000
    
    'If ExeCheckFlag = 1 And OptFlag <> 0 Then
    '    Be = XOverList(RelX, RelY).Beginning
    '    En = XOverList(RelX, RelY).Ending
    '    If Be < En Then
    '        XOverWindow = Int(XPosDiff(En) - XPosDiff(Be)) / 2
    '   Else
    '        XOverWindow = Int((XPosDiff(En) + (LenXoverSeq - XPosDiff(Be))) / 2)
    '    End If
    'Else
    '    XOverWindow = Int(XOverWindowX / 2)
    'End If
    
    XoverWindow = Int(XOverWindowX / 2)
    
    
    'Work out homologies
    ReDim Preserve XDiffPos(LenXoverSeq)
    ReDim XOverHomologyNum(LenXoverSeq + XoverWindow * 2, 2)
    'C Routine to work out moving homology averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    Dummy = XOHomology(1, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
    'Find Xovers
    
        If DebuggingFlag < 2 Then On Error Resume Next
        UB = -1
        UB = UBound(TreeDistance, 1)
        On Error GoTo 0
        If UB > -1 Then
        'XX = PermNextno
            If TreeTrace(Seq1) <= UB And TreeTrace(Seq2) <= UB And TreeTrace(Seq3) <= UB Then
                If TreeDistance(TreeTrace(Seq1), TreeTrace(Seq2)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) And TreeDistance(TreeTrace(Seq1), TreeTrace(Seq2)) >= TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) Then
                    HighHomol = 1
            
                    If AvHomol(2) > AvHomol(3) Then
                        MedHomol = 2: LowHomol = 3
                        ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
                        SeqDaughter = 0: SeqMinorP = 2
                    Else
                        MedHomol = 3: LowHomol = 2
                        ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
                        SeqDaughter = 1: SeqMinorP = 2
                    End If
            
                ElseIf TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq2)) And TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) Then
                    HighHomol = 2
            
                    If AvHomol(1) > AvHomol(3) Then
                        MedHomol = 1: LowHomol = 3
                        ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
                        SeqDaughter = 0: SeqMinorP = 1
                    Else
                        MedHomol = 3: LowHomol = 1
                        ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
                        SeqDaughter = 2: SeqMinorP = 1
                    End If
            
                ElseIf TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) And TreeDistance(TreeTrace(Seq2), TreeTrace(Seq3)) >= TreeDistance(TreeTrace(Seq1), TreeTrace(Seq3)) Then
                    HighHomol = 3
            
                    If AvHomol(1) > AvHomol(2) Then
                        MedHomol = 1: LowHomol = 2
                        ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
                        SeqDaughter = 1: SeqMinorP = 0
                    Else
                        MedHomol = 2: LowHomol = 1
                        ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
                        SeqDaughter = 2: SeqMinorP = 0
                    End If
            
                End If
            Else
                HighHomol = 2
            
                    
                MedHomol = 3: LowHomol = 1
                ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
                SeqDaughter = 2: SeqMinorP = 1
            End If
        Else
            
            HighHomol = 2
        
                
            MedHomol = 3: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
           
        End If
    
    'Check for medium line being higher than higher line
    'Dim NumDifferent As Integer
    
    If PermNextno > MemPoc Then
        ReDim TreeDistance(0, 0)
    End If
    ReDim Preserve XDiffPos(Len(StrainSeq(0)))
    
    If DebuggingFlag < 2 Then On Error Resume Next
    LowestProb = pLowestProb
    On Error GoTo 0
    
    Dim FindCycle As Integer

    FindCycle = 0

    Dim Store As Integer, CycleX As Long
    Dim Storex As Integer
    Dim NumDifferent As Long
    Dim TempCurrent As Long, BE As Long, EN As Long, NC As Long

    ProbY = 1
    GPVTNum = -1
    XX = MinPA
    Do
        CycleX = 0
        Storex = 0
        NextPosX = StartPosX
        For x = 1 To LenXoverSeq

            If XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, LowHomol - 1) And XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, HighHomol - 1) Then

                If CircularFlag = 1 And XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, HighHomol - 1) And x = 1 Then

                    Do Until XOverHomologyNum(x, MedHomol - 1) <= XOverHomologyNum(x, HighHomol - 1)
                        x = x + 1
                    Loop

                    If XOverHomologyNum(LenXoverSeq, MedHomol - 1) <= XOverHomologyNum(LenXoverSeq, HighHomol - 1) Then
                        XOverHomologyNum(LenXoverSeq, MedHomol - 1) = XOverHomologyNum(1, MedHomol - 1)
                        XOverHomologyNum(LenXoverSeq, HighHomol - 1) = XOverHomologyNum(1, HighHomol - 1)
                    End If

                Else
                    If x = x Then
                        NCommon = 0
                        'LowHomol = 2
                        'HighHomol = 1
                        XOverLength = 0
                        Dummy = DefineEvent(ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, x, XoverWindow, Len(StrainSeq(0)), LenXoverSeq, SeqDaughter, SeqMinorP, EndFlag, BE, EN, NCommon, XOverLength, XoverSeqNumW(0, 0), XDiffPos(0), XOverHomologyNum(0, 0))
                        x = x
                        'If Be = 5629 Then
                        '    X = X
                        '    En = En
                        '    For Z = 0 To LenXoverSeq
                        '        If testpa(Z, MedHomol - 1) <> XOverSeqNum(Z, MedHomol - 1) Then
                        '            X = X
                        '        End If
                        '        If testpa(Z, HighHomol - 1) <> XOverSeqNum(Z, HighHomol - 1) Then
                        '            X = X
                        '        End If
                        '        If testpa(Z, LowHomol - 1) <> XOverSeqNum(Z, LowHomol - 1) Then
                        '            X = X
                        '        End If
                        '    Next Z
                        '    XX = SEventNumber
                        '    XX = Seq1
                        '    XX = Seq2
                        '    XX = Seq3
                        'End If
                        x = Dummy
                        '5.469 1K perms
                        If CircularFlag = 1 And x > LenXoverSeq Then
                            x = 1
                            CycleX = CycleX + 1
                            If CycleX = 2 Then
                                EndFlag = 1
                            End If
                        End If
                        IndProb = AvHomol(MedHomol)
                        NumDifferent = XOverLength - NCommon
                    Else
                        If x > 1 Then
    
                            Do Until x = 1
                                x = x - 1
    
                                If XoverSeqNum(x, SeqDaughter) <> XoverSeqNum(x, SeqMinorP) Then
                                    x = x + 1
                                    Exit Do
                                End If
    
                            Loop
    
                        End If
    
                        If XoverSeqNum(x, SeqDaughter) <> XoverSeqNum(x, SeqMinorP) Then
    
                            Do Until x = LenXoverSeq
                                x = x + 1
    
                                If XoverSeqNum(x, SeqDaughter) = XoverSeqNum(x, SeqMinorP) Then
                                    'X = X - 1
                                    Exit Do
                                End If
    
                            Loop
    
                        End If
    
                        
                        
                        If CircularFlag = 0 And x = 1 Then
                            BE = 1
                        Else
                            BE = XDiffPos(x)
                            'Exit Sub
                        End If
                        
                        XOverLength = 0
                        NC = 0
                        Do Until XOverHomologyNum(x, MedHomol - 1) < XOverHomologyNum(x, HighHomol - 1) And XoverSeqNum(x, SeqDaughter) <> XoverSeqNum(x, SeqMinorP)
    
                            If XoverSeqNum(x, SeqDaughter) = XoverSeqNum(x, SeqMinorP) Then
                                NC = NC + 1
                            End If
    
                            XOverLength = XOverLength + 1: If XOverLength >= LenXoverSeq Then Exit Do
                            x = x + 1
    
                            If x > LenXoverSeq Then
    
                                If CircularFlag = 1 Then
                                    x = 1
                                    EndFlag = 1
                                Else
                                    x = LenXoverSeq + 2 * XoverWindow + 1
                                    Exit Do
                                End If
    
                            End If
    
                        Loop
    
                        Storex = x
                        x = x - 1
                        Store = 0
    
                        Do
    
                            If XoverSeqNum(x, SeqDaughter) <> XoverSeqNum(x, SeqMinorP) And x < LenXoverSeq And x > 1 Then
                                x = x - 1
                                Store = Store + 1
                                XOverLength = XOverLength - 1
    
                                If XOverLength = 1 Then Exit Do
                            Else
                                Exit Do
                            End If
    
                        Loop
    
                        'X = X + 1
    
                        If x = LenXoverSeq + 2 * XoverWindow + 1 And CircularFlag = 0 Then
                            EN = Len(StrainSeq(0))
                        Else
    
                            If NC > 1 Then
                                EN = XDiffPos(x)
                            Else
                                EN = XDiffPos(x)
                            End If
    
                        End If
                        
                        'X = X + 1 + Store
                        x = Storex + 1
    
                        If EN = 0 Then EN = Len(StrainSeq(0)) - 1
                        IndProb = AvHomol(MedHomol)
                        NumDifferent = XOverLength - NC
                    End If
                    
                    If XOverLength > 2 Then
                                        If XOverLength >= 170 Then
                            AFact = XOverLength / 169
                            NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                            XOverLength = 169
                            
                        Else
                            AFact = 1
                        End If
                        'C routine that calculates the probability of the "recomination" having occured by chance.
                        ProbabilityXOver = ProbCalcP(Fact(0), XOverLength, (XOverLength - NumDifferent), IndProb, CLng(LenXoverSeq / AFact))
                        'xol =169;numdiff = 36; indprob=0.356; lenxo = 1780
                        'xol = 169, numdiff = 53, 0.4133; 1666
                        If ProbabilityXOver > 1 Then
                            ProbabilityXOver = 1
                        
                        End If
                        If AFact > 200 Then AFact = 200
                        ProbabilityXOver = ProbabilityXOver ^ AFact
                        If ProbabilityXOver < 10 ^ -300 Then
                            ProbabilityXOver = 10 ^ -300
                        End If
                        x = x
                        'Call CorrectProb

                        'xol = 63:numdiff = 0:lenxoverseq =824:indprob = 0.1176:be=2293:en=2470
                    End If

                    If MCFlag = 0 Then
                        ProbabilityXOver = ProbabilityXOver * MCCorrection
                    ElseIf MCFlag = 2 Then
                        ProbabilityXOver = StepDown2(0, ProbabilityXOver)
                    End If
                    If EN = BE Then
                       ProbabilityXOver = 1
                    ElseIf EN < BE And CircularFlag = 0 Then
                        ProbabilityXOver = 1
                    End If
                    BT2 = XoverList(RelX, RelY).Beginning
                    ET2 = XoverList(RelX, RelY).Ending
                    If ET2 < BT2 Then ET2 = ET2 + Len(StrainSeq(0))
                    
                    If ProbabilityXOver = 0 Then ProbabilityXOver = 1
                    
                    If BE <= EN Then
                        BT1 = BE
                        ET1 = EN
                        

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If MinPA > ProbabilityXOver Then MinPA = ProbabilityXOver
                        End If

                    Else
                        BT1 = BE
                        ET1 = EN + Len(StrainSeq(0))

                        If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap

                            If MinPA > ProbabilityXOver Then MinPA = ProbabilityXOver
                        End If
                        If MinPA = 1 Then
                            BT1 = BE - Len(StrainSeq(0))
                            ET1 = EN
    
                            If ET2 - BT1 > 0 And ET1 - BT2 > 0 Then      'ie there is overlap
    
                                If MinPA > ProbabilityXOver Then MinPA = ProbabilityXOver
                            End If
                            x = x
                        End If
                    End If
                    If MinPA <= LowestProb Then
                    
                        If BestRescanFlag = 1 And BestRescanP > MinPA And MinPA > 0 Then
                            BestRescanP = MinPA
                        End If
                    End If
                    If ProbabilityXOver > -1 And (ProbabilityXOver < 1 Or ExeCheckFlag = 1) Then
                        ' oRecombNo(100)  = oRecombNo(100) + 1
                        'ProbTest$ = XOverList(ActiveSeq, TempCurrent).Probability

                        If (FirstDrawFlag = 0 And SPF = 0 And DontRedrawPlotsFlag = 0 And BestRescanFlag = 0) Or (FirstDrawFlag = 0 And BestRescanFlag = 1 And BestRescanP = MinPA) Then
                            Form1.Picture7.ForeColor = QBColor(12)
                            Form1.Picture7.FontBold = True
                            ReDim GPVTFont(5, 100), GPVText(100)
                            GPVTNum = -1
                            Call DrawPlots(Seq1, Seq2, Seq3)
                            'XX = originalname(33)
                            'XX = TreeTrace(33)
                            FirstDrawFlag = 1
                        End If
                        If ProbabilityXOver < 0.1 Or CurrentCheck = 0 Then
                            If BT2 < ET2 Then
                                If ET2 <= Len(StrainSeq(0)) Then
                                    ProbX = Decompress(BT2) + (Decompress(ET2) - Decompress(BT2)) / 2
                                Else
                                    ProbX = Decompress(BT2) + Decompress(EN) / 2 '(Decompress(Len(StrainSeq(0))) - Decompress(BT2)) / 2
                                End If
                            Else
    
                                If ET2 > Len(StrainSeq(0)) - BT2 Then
                                    ProbX = Decompress(ET2) / 2
                                Else
                                    ProbX = Decompress(BT2) + (Decompress(Len(StrainSeq(0))) - Decompress(BT2)) / 2
                                End If
    
                            End If
                            If ProbX > Decompress(Len(StrainSeq(0))) Then
                                ProbX = ProbX - Decompress(Len(StrainSeq(0)))
                                
                            End If
                            ProbTest$ = ProbabilityXOver
                            Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)
    'if spf = 0 then call printprobability
    
                            'the second case had to be added because wraprounds didn't work well
                            
                            If (BT1 < ET2 And ET1 > BT2) Or (BT1 < (ET2 - Len(StrainSeq(0))) And ET1 > (BT2 - Len(StrainSeq(0)))) Then
                                If Pos > 0 And ProbabilityXOver < 1 Then
        
                                    If SPF = 0 Then
                                        If DontRedrawPlotsFlag = 0 Then
                                            Call PrintProbability
                                        End If
                                        If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                                            If XoverList(RelX, RelY).Probability > ProbabilityXOver Or XoverList(RelX, RelY).Probability = OXOV Then
                                                XoverList(RelX, RelY).Probability = ProbabilityXOver
                                            End If
                                        End If
                                    End If
                                    If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                                        BestParent = CheckParent: WinMethod = 0
                                        BestParentP = MinPA
                                    End If
                                ElseIf ProbabilityXOver > 0 And ProbabilityXOver < 1 Then
        
                                    If SPF = 0 Then
                                        If DontRedrawPlotsFlag = 0 Then
                                            Call PrintProbabilityII
                                        End If
                                        
                                        If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
                                            If XoverList(RelX, RelY).Probability > ProbabilityXOver Or XoverList(RelX, RelY).Probability = OXOV Then
                                                XoverList(RelX, RelY).Probability = ProbabilityXOver
                                            End If
                                        End If
                                    End If
                                    If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
                                        BestParent = CheckParent: WinMethod = 0
                                        BestParentP = MinPA
                                    End If
                                End If
                            End If
                        End If
                    ElseIf ProbabilityXOver >= LowestProb Then
                        ProbabilityXOver = 0
                    End If

                End If

            End If

            If EndFlag = 1 Then
                EndFlag = 0
                x = LenXoverSeq
            End If

        Next 'X

        If FindCycle = 0 Then
            Temp = MedHomol
            MedHomol = LowHomol
            LowHomol = Temp
        ElseIf FindCycle = 1 Then
            'Exit Do
            If AvHomol(HighHomol) < 1# Then
                Temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = Temp
            Else
                Exit Do
            End If
        Else
            Exit Do
        End If

        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1
            ActiveMajorP = Seq2
            ActiveMinorP = Seq3
            SeqDaughter = 0
            SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2
            ActiveMajorP = Seq1
            ActiveMinorP = Seq3
            SeqDaughter = 1
            SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1
            ActiveMajorP = Seq3
            ActiveMinorP = Seq2
            SeqDaughter = 0
            SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3
            ActiveMajorP = Seq1
            ActiveMinorP = Seq2
            SeqDaughter = 2
            SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2
            ActiveMajorP = Seq3
            ActiveMinorP = Seq1
            SeqDaughter = 1
            SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3
            ActiveMajorP = Seq2
            ActiveMinorP = Seq1
            SeqDaughter = 2
            SeqMinorP = 0
        End If


        FindCycle = FindCycle + 1
    Loop
    If BestRescanFlag = 0 Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
        If FirstDrawFlag = 0 And SPF = 0 And DontRedrawPlotsFlag = 0 Then
            Form1.Picture7.ForeColor = QBColor(12)
            Form1.Picture7.FontBold = True
            Call DrawPlots(Seq1, Seq2, Seq3)
        
        End If
    End If
    'Erase XOverHomologyNum
    Erase XoverSeqNum
    Erase XoverSeqNumW
    'Erase XDiffpos
    'Erase XPosDiff
    
    If LongWindedFlag = 0 Then
        EN = XoverList(RelX, RelY).Eventnumber
    Else
        EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    End If
    '
    If Confirm(EN, 0) > 0 Then
        If Abs(ConfirmP(EN, 0)) < 300 Then
            PT = 10 ^ (-ConfirmP(EN, 0))
        Else
            PT = 10 ^ 300
        End If
    Else
        PT = 1
    End If
    'Confirm(EN, 2) = 0
    If (Confirm(EN, 0) = 1 Or Confirm(EN, 0) = 0) Or (XoverList(RelX, RelY).ProgramFlag <> 0 And XoverList(RelX, RelY).ProgramFlag <> 0 + AddNum) Then

        If ((Confirm(EN, 0) = 0 Or (Confirm(EN, 0) = 1) And MinPA < PT)) And MinPA < 1 And MinPA > 0 Then
            Confirm(EN, 0) = 1
            ConfirmP(EN, 0) = -Log10(MinPA)
            

            If Form1.HScroll3.Value = 0 Then
                Form1.HScroll3.Value = 1
            Else
                Form1.HScroll3.Value = 0
            End If
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If

    End If
    
    MinPAGlobal = MinPA
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
End Sub
Public Sub UpdatePlot(DA As Long, Ma As Long, Mi As Long)

    Dim NJSubDistance() As Single, ValidSite() As Single, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    ReDim NJSubDistance(NextNo, NextNo)
    ReDim ValidSite(NextNo, NextNo)
    StartY = 15
    PVal = -Log10(XoverList(DA, CurrentXOver(DA)).Probability)
    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    LSeq = Len(StrainSeq(0))

    If PVal > PerMaxPval Then
        PVal = PerMaxPval
    End If

    'Form1.Picture7.ScaleMode = 3

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, x As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double

    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10
    'this coluld be speeded up with better nesting of if then's

    For Z = 0 To NextNo
        Dummy = DistanceCalcE(Z, NextNo, LSeq + 1, XoverList(DA, CurrentXOver(DA)).Beginning, XoverList(DA, CurrentXOver(DA)).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
    Next 'Z

    Dim TotCompare As Long

    TotCompare = 0

    For x = 0 To NextNo

        For Y = x + 1 To NextNo

            If NJSubDistance(x, Y) <> 0 Then
                AvSDst = AvSDst + (1 - NJSubDistance(x, Y))
                TotCompare = TotCompare + 1
            End If

        Next 'Y

    Next 'X

    If TotCompare > 0 Then
        AvSDst = AvSDst / TotCompare
    Else
        Exit Sub
    End If

    Dim MFactor As Integer, PartNumber As Integer
    Dim DistMod As Double

    DistMod = AvSDst / AvDst

    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String

    'If ValidSite(Da, Mi) = 0 Then ValidSite(Da, Mi) = 1
    'If ValidSite(Da, Ma) = 0 Then ValidSite(Da, Ma) = 1
    'subtract the shortest distance of mi -da in redcomb region or mada in rest of seq (obviously corrected).
    
    
    If DA <> Ma Then

        If ((1 - Distance(DA, Ma)) * DistMod) < 1 - NJSubDistance(DA, Mi) Then
            Dst = (1 - NJSubDistance(DA, Ma)) - ((1 - Distance(DA, Ma)) * DistMod)
        Else
            Dst = (1 - NJSubDistance(DA, Ma)) - (1 - NJSubDistance(DA, Mi))
        End If

    Else
        Dst = (1 - Distance(DA, Mi)) * DistMod
    End If

    If Dst < 0 Then Dst = (1 - Distance(DA, Ma)) * DistMod
    
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
    
    If oDMax < Dst Then oDMax = Dst

    If XoverList(DA, CurrentXOver(DA)).Beginning < XoverList(DA, CurrentXOver(DA)).Ending Then
        X1 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Beginning) * XFactor + XFactor
        X2 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Ending) * XFactor + XFactor
        Y1 = P2 - 5 - (Dst * (P2 - P1 - 10))
        Y2 = P2 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, CurrentXOver(DA)).ProgramFlag), BF
    Else
        X1 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Beginning) * XFactor + XFactor
        X2 = 30 + Decompress(LSeq) * XFactor + XFactor
        Y1 = P2 - 5 - (Dst * (P2 - P1 - 10))
        Y2 = P2 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, CurrentXOver(DA)).ProgramFlag), BF
        X1 = 30 + Decompress(1) * XFactor + XFactor
        X2 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Ending) * XFactor + XFactor
        Y1 = P2 - 5 - (Dst * (P2 - P1 - 10))
        Y2 = P2 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, CurrentXOver(DA)).ProgramFlag), BF
    End If

    If oPMax < PVal Then oPMax = PVal

    If XoverList(DA, CurrentXOver(DA)).Beginning < XoverList(DA, CurrentXOver(DA)).Ending Then
        X1 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Beginning) * XFactor + XFactor
        X2 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Ending) * XFactor + XFactor
        Y1 = P3 - 5 - (PVal / PerMaxPval) * (P3 - P2 - 10)
        Y2 = P3 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, CurrentXOver(DA)).ProgramFlag), BF
    Else
        X1 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Beginning) * XFactor + XFactor
        X2 = 30 + Decompress(LSeq) * XFactor + XFactor
        Y1 = P3 - 5 - (PVal / PerMaxPval) * (P3 - P2 - 10)
        Y2 = P3 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, CurrentXOver(DA)).ProgramFlag), BF
        X1 = 30 + Decompress(1) * XFactor + XFactor
        X2 = 30 + Decompress(XoverList(DA, CurrentXOver(DA)).Ending) * XFactor + XFactor
        Y1 = P3 - 5 - (PVal / PerMaxPval) * (P3 - P2 - 10)
        Y2 = P3 - 5
        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, CurrentXOver(DA)).ProgramFlag), BF
    End If

    Form1.Picture7.Line (30 + Decompress(1) * XFactor + XFactor, P4 - 5 - 1 * (P4 - P3 - 10))-(30 + Decompress(LSeq) * XFactor + XFactor, P4 - 5 - 0 * (P4 - P3 - 10)), BackColours, BF
    Pict = Form1.Picture7.hdc
    'Form1.Picture7.AutoRedraw = False

    If XoverList(DA, CurrentXOver(DA)).Beginning < XoverList(DA, CurrentXOver(DA)).Ending Then

        If XoverList(DA, CurrentXOver(DA)).Ending > LSeq Then
            XoverList(DA, CurrentXOver(DA)).Ending = LSeq
        End If

        If XoverList(DA, CurrentXOver(DA)).Beginning > LSeq - 10 Then
            XoverList(DA, CurrentXOver(DA)).Beginning = LSeq - 10
            XoverList(DA, CurrentXOver(DA)).Ending = LSeq
        End If

        For x = XoverList(DA, CurrentXOver(DA)).Beginning To XoverList(DA, CurrentXOver(DA)).Ending
            Hitnumber(x) = Hitnumber(x) + 1

            If Hitnumber(x) > MaxHits Then
                MaxHits = MaxHits + 10
                RedoLabelFlag = 1
            End If

        Next 'X

    Else

        For x = 1 To XoverList(DA, CurrentXOver(DA)).Ending
            Hitnumber(x) = Hitnumber(x) + 1

            If Hitnumber(x) > MaxHits Then
                MaxHits = MaxHits + 10
                RedoLabelFlag = 1
            End If

        Next 'X

        For x = XoverList(DA, CurrentXOver(DA)).Beginning To LSeq
            Hitnumber(x) = Hitnumber(x) + 1

            If Hitnumber(x) > MaxHits Then
                MaxHits = MaxHits + 10
                RedoLabelFlag = 1
            End If

        Next 'X

    End If

    If RedoLabelFlag = 1 Then
        RedoLabelFlag = 0
        LVal = 0
        UVal = MaxHits
        Z = 2
        MFactor = 1
        PartNumber = (PicHeight / 3 - 35) / (Form1.Picture7.TextHeight("0") * 3)

        If PartNumber < 3 Then PartNumber = 3
        YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (PartNumber - 1))
        x = 0
        EY = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
        SY = CLng(EY + YIncriment * (PartNumber - 1))

        For Y = SY To EY Step -(YIncriment)
            Outnum = (LVal + (UVal - LVal) * (x / (PartNumber - 1))) * MFactor

            If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then

                If LVal * 1000 > UVal Then
                    MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                    XLegendA = XLegendA + " (x " & Trim$(CStr(MFactor)) & ")"
                    Outnum = Outnum * MFactor
                Else
                    Outnum = 0
                End If

            End If

            SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
            'Exit Sub

            If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = "0" & SOutNum

            If CDbl(SOutNum) = Int(CDbl(SOutNum)) Then SOutNum = SOutNum + ".0"

            If CDbl(SOutNum) >= 100 And CDbl(SOutNum) < 1000 Then
                SOutNum = " " & Trim$(CStr(Int(CDbl(SOutNum))))
            End If

            If Len(SOutNum) < 4 Then
                SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
            ElseIf Len(SOutNum) > 4 Then
                SOutNum = Left$(SOutNum, 4)
            End If

            Form1.Picture7.Line (0, CLng(Y - Form1.Picture7.TextHeight("0") / 2))-(20, Y + Form1.Picture7.TextHeight("0") / 2), BackColours, BF
            Form1.Picture7.CurrentY = CLng(Y - Form1.Picture7.TextHeight("0") / 2)
            Form1.Picture7.CurrentX = 0
            Form1.Picture7.Print SOutNum
            x = x + 1
        Next 'Y

    End If

    MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5 - (Hitnumber(1) / MaxHits) * (P4 - P3 - 10), Pnt

    For x = 2 To LSeq
        LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P4 - 5 - (Hitnumber(x) / MaxHits) * (P4 - P3 - 10)
    Next 'X

    Form1.Picture7.Refresh
End Sub
Public Sub UpdatePlotE(BPos As Long, Epos As Long, PVal As Double, oPMax As Single, oPMin As Single, DistX As Double, Mi, MaxBP() As Double, BPlots() As Single)
    
    Dim YE As Long, MFactor As Single, TH As Long, ValidSite() As Single, YScaleFactor As Single
    Dim YS As Long, Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim PValx As Double, StartY As Integer
    If DistX > 0.5 Then DistX = 0.5
    PValx = -Log10(PVal)
    Form1.Picture7.ScaleMode = 3
    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    LSeq = Len(StrainSeq(0))
    Form1.Picture7.DrawWidth = 1
    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    TH = Form1.Picture7.TextHeight("0")

    Dim PartNumber As Single, P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, x As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    StartY = 15
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10


    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String
    
    PartNumber = (PicHeight / 3 - 35) / (TH * 3)

    If PartNumber < 3 Then PartNumber = 3

    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (PartNumber - 1))
    'If Form1.Picture7.BackColor <> Form1.Picture1.BackColor Then
    '    Form1.Picture7.BackColor = Form1.Picture1.BackColor
    'End If
    'Form1.Picture7.Line (30 + 1 * XFactor + XFactor, (P2 - 5 - (P2 - P1 - 10)))-(30 + lseq * XFactor + XFactor, (P2 - 5)), BackColours, BF
    Form1.Picture7.Line ((30 + Decompress(1) * XFactor + XFactor), (P3 - 5 - (P3 - P2 - 10)))-(30 + Decompress(LSeq) * XFactor + XFactor, P3 - 5), BackColours, BF
    Form1.Picture7.Line (30 + Decompress(1) * XFactor + XFactor, (P4 - 5 - (P4 - P3 - 10)))-(30 + Decompress(LSeq) * XFactor + XFactor, P4 - 5), BackColours, BF

    Form1.Picture7.ForeColor = 0
    x = 0
    
    For Z = 0 To 2
        
        If RedoPltL(Z) = 1 Then
            Pict = Form1.Picture7.hdc
            RedoPltL(Z) = 0
            x = 0
    
            If Z = 1 Then
                UVal = MaxBP(0)
                LVal = 0
            ElseIf Z = 0 Then
                UVal = oPMax
                LVal = 0
            Else
                UVal = MaxBP(1)
                LVal = 0
            End If
    
            MFactor = 1
            YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
            YS = CLng(YE + YIncriment * (PartNumber - 1))
    
            For Y = YS To YE Step -(YIncriment)
                Outnum = (LVal + (UVal - LVal) * (x / (PartNumber - 1))) * MFactor
    
                If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then
    
                    If LVal * 1000 > UVal Then
                        MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                        Outnum = Outnum * MFactor
                    Else
                        Outnum = 0
                    End If
    
                End If
    
                SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
                'Exit Sub
                Outnum = (CLng(Outnum * 100)) / 100
                If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = SOutNum
    
                If Outnum = Int(SOutNum) Then
                    
                    SOutNum = SOutNum + ".0"
                End If
                If Outnum >= 100 And Outnum < 1000 Then
                    SOutNum = " " & Trim$(CStr(Int(Outnum)))
                End If
    
                If Len(SOutNum) < 4 Then
                    SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
                ElseIf Len(SOutNum) > 4 Then
                    SOutNum = Left$(SOutNum, 4)
                End If
                Form1.Picture7.Line (0, CLng(Y - TH / 2))-(20, Y + TH / 2), BackColours, BF
                Form1.Picture7.CurrentY = CLng(Y - TH / 2)
                Form1.Picture7.CurrentX = 0
                'TextOut Pict, 0, CLng(Y - TH / 2), SOutNum, Len(SOutNum)
                Form1.Picture7.Print SOutNum
                x = x + 1
            
            Next 'Y
        Else
        
        End If

    Next 'Z
    
    
    
    Dim DistXX As Long
    'For Y = 0 To AddNum - 1
    '    If StartPlt(Y) = 1 Then
            If Mi = 0 Then
                DistXX = ((DistX - 0.5) / (-0.5) * 768)
                Call DistColour(DistXX)
            Else
                DistXX = RGB(128, 128, 128)
            End If
            Form1.Picture7.ForeColor = DistXX
            'Form1.Picture7.ForeColor = QBColor(3)
            'Form1.Picture7.DrawWidth = 4
            Pict = Form1.Picture7.hdc
            
            'top plot
            If PValx > oPMax Then PValx = oPMax
            
            
'            If BPos < EPos Then
'                MoveToEx Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
'                'LineList1(0, 1) = 30 + Decompress(BPos) * XFactor + XFactor
'                'LineList1(1, 1) = P2 - 5
'                'LineList1(0, 2) = 30 + Decompress(BPos) * XFactor + XFactor
'                'LineList1(1, 2) = P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                'LineList1(0, 3) = 30 + Decompress(EPos) * XFactor + XFactor
'                'LineList1(1, 3) = P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                'LineList1(0, 4) = 30 + Decompress(EPos) * XFactor + XFactor
'                'LineList1(1, 4) = P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                'LineList1(0, 5) = 30 + Decompress(BPos) * XFactor + XFactor
'                'LineList1(1, 5) = P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                'x = x
'                'Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList1(), Form1.Picture7.ForeColor, -1) ' Form1.Picture7.FillColor)
'            Else
'                MoveToEx Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
'                'LineList1(0, 1) = 30 + Decompress(BPos) * XFactor + XFactor
'                'LineList1(1, 1) = P2 - 5
'                'LineList1(0, 2) = 30 + Decompress(BPos) * XFactor + XFactor
'                'LineList1(1, 2) = P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                'LineList1(0, 3) = 30 + Decompress(LSeq) * XFactor + XFactor
'                'LineList1(1, 3) = P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                'LineList1(0, 4) = 30 + Decompress(LSeq) * XFactor + XFactor
'                'LineList1(1, 4) = P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                'LineList1(0, 5) = 30 + Decompress(BPos) * XFactor + XFactor
'                'LineList1(1, 5) = P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'
'
'                'Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList1(), Form1.Picture7.ForeColor, -1) 'Form1.Picture7.FillColor)
'
'
''               LineList4(0, 1) = 30 + Decompress(1) * XFactor + XFactor
''                LineList4(1, 1) = P2 - 5
''                LineList4(0, 2) = 30 + Decompress(1) * XFactor + XFactor
''                LineList4(1, 2) = P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
''                'LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
''                LineList4(0, 3) = 30 + Decompress(EPos) * XFactor + XFactor
''                LineList4(1, 3) = P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
''                'LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
''                LineList4(0, 4) = 30 + Decompress(EPos) * XFactor + XFactor
''                LineList4(1, 4) = P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
''                'LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
''                LineList4(0, 5) = 30 + Decompress(1) * XFactor + XFactor
''                LineList4(1, 5) = P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
''                'LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
''               ' LineList1(0, 4) = 30 + Decompress(EPos) * XFactor + XFactor
''               ' LineList1(1, 4) = P2 - 5
''               ' 'LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
''               ' LineList1(0, 5) = 30 + Decompress(1) * XFactor + XFactor
''               ' LineList1(1, 5) = P2 - 5
''
''                Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList4(), Form1.Picture7.ForeColor, -1) 'Form1.Picture7.FillColor)
''
'                MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
'                LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(EPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'                LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
'            End If
            If PValx > oPMax Then PValx = oPMax
            MoveToEx Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
            If BPos < Epos Then
                LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Decompress(Epos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Decompress(Epos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                x = x
            Else
                LineTo Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                MoveToEx Pict, 30 + Decompress(BPos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
                LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                
                MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10), Pnt
                LineTo Pict, 30 + Decompress(Epos) * XFactor + XFactor, P2 - 5 - (0 / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Decompress(Epos) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
                LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - (PValx / oPMax) * (P2 - P1 - 10)
            End If
            'Form1.Picture7.Refresh
           If x = x Then
            'If x = x Then
                Dim ImageData() As Byte, bm As BITMAP
                GetObject Form1.Picture7.Image, Len(bm), bm 'grabs image from picture7
                '@'@'@
                ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)
                '$
                GetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0) 'add the current  picture7 graphic to imagedata
                Dim LineList1() As Single, LineList2() As Single, LineList3() As Single, LineList4() As Single
                 ReDim LineList1(1, CLng(UPArrayDim1) + 20)
                 ReDim LineList2(1, CLng(UPArrayDim1) + 20)
                 ReDim LineList3(1, CLng(UPArrayDim1) + 20)
                  ReDim LineList4(1, CLng(UPArrayDim1) + 20)
            End If
            
            'Form1.Picture7.Refresh
            
            Form1.Picture7.ForeColor = 0
           
            'middle plot
            'Form1.Picture7.BackColor = RGB(196, 196, 196)
            
            
            
            
            Dim StepSS As Long
            'StepSS = CLng((LSeq / (Decompress(LSeq) * XFactor)) / 4)
            StepSS = CLng(UPArrayDim1 / CLng(((Decompress(LSeq) * XFactor))) / 2)
            XX = UBound(BPlots, 2)
            If StepSS < 1 Then StepSS = 1
            XX = Decompress(LSeq) * XFactor
            Pict = Form1.Picture7.hdc
            'XX = Form1.Picture7.ScaleMode
            
            If x = x Then
                
                P = 0
                
                For x = 1 To UPArrayDim1 ' Step StepSS
                    P = P + 1
                    If BPlots(0, x) > 0 Then
                        x = x
                    End If
                    LineList2(0, P) = 30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor
                    LineList2(1, P) = P3 - 5 - (BPlots(0, x) / MaxBP(0)) * (P3 - P2 - 10)
                    x = x
                    'LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P3 - 5 - (BPlots(0, x) / MaxBP(0)) * (P3 - P2 - 10)
                Next 'X
                Pict = Form1.Picture7.hdc
                'XX = Form1.Picture7.DrawStyle
                'Bottom plot
                '@'@'@'@'@'@'@'@'@
                'MoveToEx Pict, 30 + (Decompress(1) * XFactor) + XFactor, P4 - 5 - (BPlots(1, 1) / MaxBP(1)) * (P4 - P3 - 10), Pnt
                P = 0
                For x = 1 To UPArrayDim1 ' Step StepSS
                    P = P + 1
                    LineList3(0, P) = 30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor
                    LineList3(1, P) = P4 - 5 - (BPlots(1, x) / MaxBP(1)) * (P4 - P3 - 10)
                    'LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P4 - 5 - (BPlots(1, x) / MaxBP(1)) * (P4 - P3 - 10)
                Next 'X
            Else
            
            
                MoveToEx Pict, 30 + (Decompress(1) * XFactor) + XFactor, P3 - 5 - (BPlots(0, 1) / MaxBP(0)) * (P3 - P2 - 10), Pnt
                
                For x = 2 To LSeq Step StepSS
                    
                    LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P3 - 5 - (BPlots(0, x) / MaxBP(0)) * (P3 - P2 - 10)
                Next 'X
                Pict = Form1.Picture7.hdc
                'XX = Form1.Picture7.DrawStyle
                'Bottom plot
                '@'@'@'@'@'@'@'@'@
                MoveToEx Pict, 30 + (Decompress(1) * XFactor) + XFactor, P4 - 5 - (BPlots(1, 1) / MaxBP(1)) * (P4 - P3 - 10), Pnt
                For x = 2 To LSeq Step StepSS
                    
                    LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P4 - 5 - (BPlots(1, x) / MaxBP(1)) * (P4 - P3 - 10)
                Next 'X
            
            End If
            Form1.Picture7.ForeColor = 0
            'Call DoLineObject(ImageData(), Form1.Picture7, LineList2(), Form1.Picture7.ForeColor, 1, 1, 1)
            'Call DoLineObject(ImageData(), Form1.Picture7, LineList3(), Form1.Picture7.ForeColor, 1, 1, 1)
            
            Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList2(), Form1.Picture7.ForeColor, Form1.Picture7.FillColor)
            Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList3(), Form1.Picture7.ForeColor, Form1.Picture7.FillColor)
            'Form1.Picture7.Draw
            SetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
            
            'Form1.Picture1.Refresh
            x = x
            'Form1.Picture7.ForeColor = BackColours
            'MoveToEx Pict, 30 + 1 * XFactor + XFactor, P2 - 5, Pnt
            'LineTo Pict, 30 + LSeq * XFactor + XFactor, P2 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5, Pnt
            LineTo Pict, 30 + Decompress(LSeq) * XFactor + XFactor, P3 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5, Pnt
            LineTo Pict, 30 + Decompress(LSeq) * XFactor + XFactor, P4 - 5

     '   End If
    'Next 'Y
    Dim SP As Long
    'For Y = AddNum - 1 To 0 Step -1 'AddNum - 1
        'If StartPlt(Y) = 1 Then
        'Form1.Picture7.Refresh
        
        For Y = 0 To 1
            x = 1
            Do
                Form1.Picture7.ForeColor = 0
                If BPlots(Y, x) > 0 Then
                    SP = x
                    
                    x = x + 1
                    Do While x <= UPArrayDim1
                        If BPlots(Y, x) = 0 Then
                            x = x + 2
                            Exit Do
                        End If
                        x = x + 1
                    Loop
                    Pict = Form1.Picture7.hdc
                    If Y = 0 Then
                        MoveToEx Pict, 30 + Decompress(CLng(SP / UPArrayDimXFact)) * XFactor + XFactor, P3 - 5, Pnt
                        If x <= UPArrayDim1 Then
                            LineTo Pict, 30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor + 1, P3 - 5
                        Else
                            LineTo Pict, 30 + Decompress(CLng(UPArrayDim1 / UPArrayDimXFact)) * XFactor + XFactor + 1, P3 - 5
                        End If
                    Else
                        MoveToEx Pict, 30 + Decompress(CLng(SP / UPArrayDimXFact)) * XFactor + XFactor, P4 - 5, Pnt
                        If x <= UPArrayDim1 Then
                        
                       
                            LineTo Pict, 30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor + 1, P4 - 5
                        
                        Else
                            LineTo Pict, 30 + Decompress(CLng(UPArrayDim1 / UPArrayDimXFact)) * XFactor + XFactor + 1, P4 - 5
                        End If
                    End If
                    
                End If
                x = x + 1
            Loop While x <= UPArrayDim1
            
            If CircularFlag = 0 Then
                If BPlots(0, 1) > 0 Then
                    MoveToEx Pict, 30 + Decompress(CLng(1 / UPArrayDimXFact)) * XFactor + XFactor, P3 - 5 - (BPlots(0, 1) / MaxBP(0)) * (P3 - P2 - 10), Pnt
                    LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5
                End If
                If BPlots(1, 1) > 0 Then
                    MoveToEx Pict, 30 + Decompress(CLng(1 / UPArrayDimXFact)) * XFactor + XFactor, P4 - 5 - (BPlots(1, 1) / MaxBP(1)) * (P4 - P3 - 10), Pnt
                    LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5
                End If
           
            End If
            x = x
            
        Next Y
        'End If
    'Next 'Y
    
    Form1.Picture7.Refresh
End Sub
Public Sub UpdatePlotC()
Dim YE As Long, YS As Long, MFactor As Double, PartNumber As Double, YScaleFactor As Single, TH As Single
Dim LSeq As Long, Pict As Long, SY As Long, EY As Long, StepSize As Long
    
    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    
    
    LSeq = Len(StrainSeq(0))
    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    TH = Form1.Picture7.TextHeight("0")
    
    
    If UBound(PDistPlt, 1) < UPArrayDim1 + 10 Then
        ReDim PDistPlt(UPArrayDim1 + 10, AddNum)
        ReDim ProbPlt(UPArrayDim1 + 10, AddNum)
        ReDim HitPlt(UPArrayDim1 + 10, AddNum)
        ReDim Hitnumber(Len(StrainSeq(0)) + 10)
    End If
    
    AddTimes = AddTimes + 1
    Dim ValidSite() As Single, PVal As Double
    Dim Pnt As POINTAPI
    
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, x As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    StartY = 15
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10

    'StepSS = CLng(((LSeq * XFactor)) / 5)
    StepSize = CLng(UPArrayDim1 / CLng(((Decompress(LSeq) * XFactor))) / 2)
    If StepSize < 1 Then StepSize = 1
'    If LSeq > 20000 Then
'        'StepSize = CLng(LSeq / 20000)
'        StepSize = CLng(((LSeq * XFactor)) / 5)
'    Else
'        StepSize = 1
'    End If
    
    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String
    
    PartNumber = (PicHeight / 3 - 35) / (TH * 3)

    If PartNumber < 3 Then PartNumber = 3
    
    Dim ScaleFact As Double
    ScaleFact = Decompress(LSeq) * XFactor
    
    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (PartNumber - 1))

    Form1.Picture7.Line (30 + Decompress(1) * XFactor + XFactor, (P2 - 5 - (P2 - P1 - 10)))-(30 + ScaleFact + XFactor, (P2 - 5)), BackColours, BF
    Form1.Picture7.Line (30 + Decompress(1) * XFactor + XFactor, (P3 - 5 - (P3 - P2 - 10)))-(30 + ScaleFact + XFactor, P3 - 5), BackColours, BF
    Form1.Picture7.Line (30 + Decompress(1) * XFactor + XFactor, (P4 - 5 - (P4 - P3 - 10)))-(30 + ScaleFact + XFactor, P4 - 5), BackColours, BF

    Form1.Picture7.ForeColor = 0
    x = 0
    
    For Z = 0 To 2
        
        If RedoPltL(Z) = 1 Then
            Pict = Form1.Picture7.hdc
            RedoPltL(Z) = 0
            x = 0
    
            If Z = 0 Then
                UVal = oDMax
                LVal = 0
            ElseIf Z = 1 Then
                UVal = oPMax
                LVal = 0
            Else
                UVal = MaxHits
                LVal = 0
            End If
    
            MFactor = 1
            YE = CLng((StartY + 5 + ((PicHeight - 10 - StartY) / 3) * Z))
            YS = CLng(YE + YIncriment * (PartNumber - 1))
            If YIncriment > 0 Then
                For Y = YS To YE Step -(YIncriment)
                    Outnum = (LVal + (UVal - LVal) * (x / (PartNumber - 1))) * MFactor
        
                    If Outnum > 0 And Outnum < 0.01 And MFactor = 1 Then
        
                        If LVal * 1000 > UVal Then
                            MFactor = 10 ^ (Int(Log10(1 / Outnum)))
                            Outnum = Outnum * MFactor
                        Else
                            Outnum = 0
                        End If
        
                    End If
        
                    SOutNum = Trim$(CStr((CLng(Outnum * 100)) / 100))
                    'Exit Sub
                    Outnum = (CLng(Outnum * 100)) / 100
                    If CDbl(SOutNum) < 1 And CDbl(SOutNum) > 0 Then SOutNum = SOutNum
        
                    If Outnum = Int(SOutNum) Then
                        
                        SOutNum = SOutNum + ".0"
                    End If
                    If Outnum >= 100 And Outnum < 1000 Then
                        SOutNum = " " & Trim$(CStr(Int(Outnum)))
                    End If
        
                    If Len(SOutNum) < 4 Then
                        SOutNum = SOutNum + String$(4 - Len(SOutNum), "0")
                    ElseIf Len(SOutNum) > 4 Then
                        SOutNum = Left$(SOutNum, 4)
                    End If
                    Form1.Picture7.Line (0, CLng(Y - TH / 2))-(20, Y + TH / 2), BackColours, BF
                    Form1.Picture7.CurrentY = CLng(Y - TH / 2)
                    Form1.Picture7.CurrentX = 0
                    'TextOut Pict, 0, CLng(Y - TH / 2), SOutNum, Len(SOutNum)
                    Form1.Picture7.Print SOutNum
                    x = x + 1
                
                Next 'Y
            End If
        Else
        
        End If

    Next 'Z
    
    
    'Work out the order in which plots get displayed (from most eventsdetected to least)
    'oRecombNo (x)
'    Dim Order() As Byte, BestN As Long, Winner As Long, CC As Long, Done() As Byte
'    ReDim Order(AddNum - 1), Done(AddNum - 1)
'    For x = 0 To AddNum - 1
'        BestN = 0
'        For Y = 0 To AddNum - 1
'            If Done(Y) = 0 Then
'                If oRecombNo(Y) > BestN Then
'                    Winner = Y
'                    BestN = oRecombNo(Y)
'                End If
'            End If
'        Next Y
'        Done(Winner) = 1
'        Order(x) = Winner
'    Next x
    
    
    If x = x Then
        Dim ImageData() As Byte, bm As BITMAP
        GetObject Form1.Picture7.Image, Len(bm), bm 'grabs image from picture7
        '@'@'@
        ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)
        GetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0) 'add the current  picture7 graphic to imagedata
        Dim LineList1() As Single, LineList2() As Single, LineList3() As Single
         ReDim LineList1(1, CLng(UPArrayDim1) + 20)
         ReDim LineList2(1, CLng(UPArrayDim1) + 20)
         ReDim LineList3(1, CLng(UPArrayDim1) + 20)
    End If
    
    For ZZ = 0 To AddNum - 1
        Y = ZZ 'Order(ZZ)
        If StartPlt(Y) = 1 Then
            Form1.Picture7.ForeColor = ProgColour(Y)
            'Form1.Picture7.ForeColor = QBColor(3)
            'Form1.Picture7.DrawWidth = 4
            Pict = Form1.Picture7.hdc
            If x = x Then
                
                If x = 123456 Then
                    Dummy = UpdatePlotsCP(UPArrayDim1, UPArrayDimXFact, Pict, LSeq, P1, P2, P3, P4, StepSize, XFactor, oDMax, oPMax, MaxHits, Decompress(0), PDistPlt(0, Y), ProbPlt(0, Y), HitPlt(0, Y))
                Else
                    If x = x Then
                        Dummy = UpdatePlotsCP2(UPArrayDim1, UPArrayDimXFact, Pict, LSeq, P1, P2, P3, P4, StepSize, XFactor, oDMax, oPMax, MaxHits, Decompress(0), PDistPlt(0, Y), ProbPlt(0, Y), HitPlt(0, Y), LineList1(0, 0), LineList2(0, 0), LineList3(0, 0))
                        
                    Else
                        Dim P As Long
                        If oDMax > 0 Then
                            HMult1 = P2 - P1 - 10
                            HMult2 = P2 - 5
                            
                             x = LSeq
                             'MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, HMult2 - (PDistPlt(1, Y) / oDMax) * (HMult1), Pnt
                             P = 0
                             XX = (UPArrayDim1 / UPArrayDimXFact)
                             For x = 1 To UPArrayDim1
                                 P = P + 1
                                 LineList1(0, P) = (30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor)
                                 LineList1(1, P) = HMult2 - (PDistPlt(x, Y) / oDMax) * (HMult1)
                                 'LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, HMult2 - (PDistPlt(x, Y) / oDMax) * (HMult1)
                                 
                             Next 'X
                         End If
                        '@
                         If oPMax > 0 Then
                            HMult1 = P3 - P2 - 10
                            HMult2 = P3 - 5
                             P = 0
                             For x = 1 To UPArrayDim1
                                 P = P + 1
                                 If ProbPlt(x, Y) > oPMax Then
                                    x = x
                                 End If
                                 LineList2(0, P) = (30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor)
                                 LineList2(1, P) = (HMult2 - (ProbPlt(x, Y) / oPMax) * (HMult1))
                             Next 'X
                         End If
                         
                         If MaxHits > 0 Then
                            HMult1 = P4 - P3 - 10
                            HMult2 = P4 - 5
                             P = 0
                             For x = 1 To UPArrayDim1 'Step StepSize
                                 P = P + 1
                                 If HitPlt(x, Y) > MaxHits Then
                                    x = x
                                 End If
                                 LineList3(0, P) = (30 + Decompress(CLng(x / UPArrayDimXFact)) * XFactor + XFactor)
                                 LineList3(1, P) = HMult2 - (HitPlt(x, Y) / MaxHits) * (HMult1)
                             Next 'X
                         End If
                    End If
                     Dim TransparencyFlag As Byte
                    'TransparencyFlag = 0
                    'Call DoLineObject(ImageData(), Form1.Picture7, LineList1(), Form1.Picture7.ForeColor, 1, CByte(TransparencyFlag), 1)
                    'Call DoLineObject(ImageData(), Form1.Picture7, LineList2(), Form1.Picture7.ForeColor, 1, CByte(TransparencyFlag), 1)
                    'Call DoLineObject(ImageData(), Form1.Picture7, LineList3(), Form1.Picture7.ForeColor, 1, CByte(TransparencyFlag), 1)
                    Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList1(), Form1.Picture7.ForeColor, Form1.Picture7.FillColor)
                    Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList2(), Form1.Picture7.ForeColor, Form1.Picture7.FillColor)
                    Call DoPolyPointObject(ImageData(), Form1.Picture7, LineList3(), Form1.Picture7.ForeColor, Form1.Picture7.FillColor)
                End If
            
            Else
                 'Dim HMult1 As Long, HMult2 As Long
                 
                 If oDMax > 0 Then
                    HMult1 = P2 - P1 - 10
                    HMult2 = P2 - 5
                     MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, HMult2 - (PDistPlt(1, Y) / oDMax) * (HMult1), Pnt
                     For x = 2 To LSeq Step StepSize
                         LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, HMult2 - (PDistPlt(x, Y) / oDMax) * (HMult1)
                         
                     Next 'X
                 End If
                '@
                 If oPMax > 0 Then
                    HMult1 = P3 - P2 - 10
                    HMult2 = P3 - 5
                     MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, HMult2 - (ProbPlt(1, Y) / oPMax) * (HMult1), Pnt
                     For x = 2 To LSeq Step StepSize
                     
                         LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, HMult2 - (ProbPlt(x, Y) / oPMax) * (HMult1)
                     Next 'X
                 End If
                 
                 If MaxHits > 0 Then
                    HMult1 = P4 - P3 - 10
                    HMult2 = P4 - 5
                     MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, HMult2 - (HitPlt(1, Y) / MaxHits) * (HMult1), Pnt
                     For x = 2 To LSeq Step StepSize
                         
                         LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, HMult2 - (HitPlt(x, Y) / MaxHits) * (HMult1)
                     Next 'X
                 End If
            End If
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5, Pnt
            LineTo Pict, 30 + ScaleFact + XFactor + 1, P2 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5, Pnt
            LineTo Pict, 30 + ScaleFact + XFactor + 1, P3 - 5
            Form1.Picture7.ForeColor = BackColours
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5, Pnt
            LineTo Pict, 30 + ScaleFact + XFactor + 1, P4 - 5
            
            x = x
        End If
        x = x
    Next 'Y
    
   
    If x = x Then
        SetBitmapBits Form1.Picture7.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
    End If
    x = x
    Dim SP As Long
    
    For x = AddNum - 1 To 0 Step -1
        Y = x 'Order(x)
        If StartPlt(Y) = 1 Then
            
            If x = 1234567 Then
                x = 1
                Do
                    Form1.Picture7.ForeColor = ProgColour(Y)
                    If HitPlt(x, Y) > 0 Then
                        SP = x
                        
                        x = x + 1
                        Do While x <= LSeq
                            If HitPlt(x, Y) = 0 Then
                                x = x + 2
                                Exit Do
                            End If
                            x = x + StepSize
                        Loop
                        Pict = Form1.Picture7.hdc
                        If x <= UBound(Decompress) Then
                            MoveToEx Pict, 30 + Decompress(SP) * XFactor + XFactor, P2 - 5, Pnt
                            LineTo Pict, 30 + Decompress(x) * XFactor + XFactor + 1, P2 - 5
                        
                            MoveToEx Pict, 30 + Decompress(SP) * XFactor + XFactor, P3 - 5, Pnt
                            
                            LineTo Pict, 30 + Decompress(x) * XFactor + XFactor + 1, P3 - 5
                            MoveToEx Pict, 30 + Decompress(SP) * XFactor + XFactor, P4 - 5, Pnt
                            LineTo Pict, 30 + Decompress(x) * XFactor + XFactor + 1, P4 - 5
                        Else
                            MoveToEx Pict, 30 + Decompress(SP) * XFactor + XFactor, P2 - 5, Pnt
                            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor + 1, P2 - 5
                            
                            MoveToEx Pict, 30 + Decompress(SP) * XFactor + XFactor, P3 - 5, Pnt
                            
                            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor + 1, P3 - 5
                            MoveToEx Pict, 30 + Decompress(SP) * XFactor + XFactor, P4 - 5, Pnt
                            LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor + 1, P4 - 5
                        End If
                    End If
                    x = x + 1
                    'Form1.Picture7.Refresh
                    x = x
                Loop While x <= LSeq
            End If
            If CircularFlag = 0 Then
                'PDistPlt(1, Y) / oDMax
                If PDistPlt(1, Y) > 0 Then
                    MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - PDistPlt(1, Y) / oDMax * (P2 - P1 - 10), Pnt
                    LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5
                End If
                If HitPlt(1, Y) > 0 Then
                    MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5 - HitPlt(1, Y) / MaxHits * (P4 - P3 - 10), Pnt
                    LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5
                End If
                If ProbPlt(1, Y) > 0 Then
                    MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5 - ProbPlt(1, Y) / oPMax * (P3 - P2 - 10), Pnt
                    LineTo Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5
                End If
           
            End If
            x = x
        End If
    Next 'Y
    'ReDim StartPlt(AddNum)
    
    Form1.Picture7.Refresh
End Sub
Public Sub UpdatePlotD()

Dim NJSubDistance() As Single, ValidSite() As Single, PVal As Double
Dim Pnt As POINTAPI
Dim XOLen As Long, LSeq As Long, Pict As Long, SY As Long, EY As Long
Dim RedoLabelFlag As Integer
Dim StartY As Integer
Dim Dst As Double
Dst = 0
oDMax = 0
oPMax = 0
MaxHits = 0


ReDim PDistPlt(UPArrayDim1 + 10, AddNum)
ReDim ProbPlt(UPArrayDim1 + 10, AddNum)
ReDim HitPlt(UPArrayDim1 + 10, AddNum)
    
ReDim Hitnumber(Len(StrainSeq(0)) + 10)

Call DrawORFsP20
'PDistPlt(0, 0) = PDistPlt(0, 0)

Form1.SSPanel1.Caption = "Plotting " & OriginalName(0) & " regions"
Form1.Refresh

Dim STime As Long, CTime As Long
STime = Abs(GetTickCount)
For Z = 0 To NextNo
    For Y = 1 To CurrentXOver(Z)
        If XoverList(Z, Y).Accept <> 2 Then
            DA = Z
            Ma = XoverList(Z, Y).MajorP
            Mi = XoverList(Z, Y).MinorP
            ReDim NJSubDistance(NextNo, NextNo)
            ReDim ValidSite(NextNo, NextNo)
            StartY = 15
            PVal = -Log10(XoverList(Z, Y).Probability)
            Form1.Picture7.AutoRedraw = True
            XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
            
            
            LSeq = Len(StrainSeq(0))
        
            If PVal > PerMaxPval Then
                PerMaxPval = PVal
            End If
        
            'Form1.Picture7.ScaleMode = 3
        
            Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
            Dim YIncriment As Long
            Dim AvSDst As Double, LVal As Double, UVal As Double
        
            P1 = StartY
            P2 = StartY + (PicHeight - 10 - StartY) / 3
            P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
            P4 = PicHeight - 10
            AvSDst = 0
            'Calculate parental distances at approx time of recombination event
            If XoverList(DA, Y).Beginning < XoverList(DA, Y).Ending Then
                XOLen = XoverList(DA, Y).Ending - XoverList(DA, Y).Beginning
                For A = XoverList(DA, Y).Beginning To XoverList(DA, Y).Ending
                    AvSDst = AvSDst + BkgIdentity(A)
                Next A
            Else
                XOLen = XoverList(DA, Y).Ending + Len(StrainSeq(0)) - XoverList(DA, Y).Beginning
                For A = 1 To XoverList(DA, Y).Ending
                    AvSDst = AvSDst + BkgIdentity(A)
                Next A
                For A = XoverList(DA, Y).Beginning To Len(StrainSeq(0))
                    AvSDst = AvSDst + BkgIdentity(A)
                Next A
            End If
            
            AvSDst = 1 - AvSDst / XOLen
                'this coluld be speeded up with better nesting of if then's

            'For Z = 0 To Nextno
            Dummy = DistanceCalcE(DA, NextNo, LSeq + 1, XoverList(DA, Y).Beginning, XoverList(DA, Y).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(Ma, NextNo, LSeq + 1, XoverList(DA, Y).Beginning, XoverList(DA, Y).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            Dummy = DistanceCalcE(Mi, NextNo, LSeq + 1, XoverList(DA, Y).Beginning, XoverList(DA, Y).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
            'Next 'Z
        
            Dim TotCompare As Long
        
            TotCompare = 0
            
            Dim MFactor As Integer, PartNumber As Integer
            Dim DistMod As Double
            If AvDst > 0 Then
                DistMod = AvSDst / AvDst
            Else
                DistMod = 1
            End If
            Dim Outnum As Double
            Dim SOutNum As String
            Dim XLegendA As String
        
            'subtract the shortest distance of mi -da in redcomb region or mada in rest of seq (obviously corrected).
        
            If DA <> Ma Then
        
                If ((1 - Distance(DA, Ma)) * DistMod) < 1 - NJSubDistance(DA, Mi) Then
                    Dst = (1 - NJSubDistance(DA, Ma)) - ((1 - Distance(DA, Ma)) * DistMod)
                Else
                    Dst = (1 - NJSubDistance(DA, Ma)) - (1 - NJSubDistance(DA, Mi))
                End If
        
            Else
                Dst = (1 - Distance(DA, Mi)) * DistMod
            End If
        
            If Dst < 0 Then Dst = (1 - Distance(DA, Ma)) * DistMod
        'XXXZZZ    XOverlist(Da, Y).EndPermP = Dst
            
            If oDMax < Dst Then
                RedoPltL(0) = 1
                oDMax = Dst + 0.1
            End If
            
            If oPMax < PVal Then
                oPMax = PVal * 1.5
                RedoPltL(1) = 1
            End If
        
            If XoverList(DA, Y).Beginning < XoverList(DA, Y).Ending Then
        
                If XoverList(DA, Y).Ending > LSeq Then
                    XoverList(DA, Y).Ending = LSeq
                End If
        
                If XoverList(DA, Y).Beginning > LSeq - 10 Then
                    XoverList(DA, Y).Beginning = LSeq - 10
                    XoverList(DA, Y).Ending = LSeq
                End If
        
                For x = XoverList(DA, Y).Beginning * UPArrayDimXFact To XoverList(DA, Y).Ending * UPArrayDimXFact
                    
                    'x = CLng(A * UPArrayDimXFact)
                    HitPlt(x, XoverList(DA, Y).ProgramFlag) = HitPlt(x, XoverList(DA, Y).ProgramFlag) + 1
                    If PDistPlt(x, XoverList(DA, Y).ProgramFlag) < Dst Then
                        PDistPlt(x, XoverList(DA, Y).ProgramFlag) = Dst
                    End If
                    If ProbPlt(x, XoverList(DA, Y).ProgramFlag) < PVal Then
                        ProbPlt(x, XoverList(DA, Y).ProgramFlag) = PVal
                    End If
                    
                    If HitPlt(x, XoverList(DA, Y).ProgramFlag) > MaxHits Then
                        MaxHits = MaxHits + 10
                        RedoPltL(2) = 1
                    End If
                Next 'X
        
            Else
        
                For x = 1 * UPArrayDimXFact To XoverList(DA, Y).Ending * UPArrayDimXFact
                    Hitnumber(x) = Hitnumber(x) + 1
                    'x = CLng(A * UPArrayDimXFact)
                    
                    HitPlt(x, XoverList(DA, Y).ProgramFlag) = HitPlt(x, XoverList(DA, Y).ProgramFlag) + 1
                    If PDistPlt(x, XoverList(DA, Y).ProgramFlag) < Dst Then
                        PDistPlt(x, XoverList(DA, Y).ProgramFlag) = Dst
                    End If
                    If ProbPlt(x, XoverList(DA, Y).ProgramFlag) < PVal Then
                        ProbPlt(x, XoverList(DA, Y).ProgramFlag) = PVal
                    End If
                    
                    If HitPlt(x, XoverList(DA, Y).ProgramFlag) > MaxHits Then
                        MaxHits = MaxHits + 10
                        RedoPltL(2) = 1
                    End If
        
                Next 'X
                XX = UBound(HitPlt, 1)
                For x = XoverList(DA, Y).Beginning * UPArrayDimXFact To LSeq * UPArrayDimXFact
                    Hitnumber(x) = Hitnumber(x) + 1
                    'x = CLng(A * UPArrayDimXFact)
                    
                    HitPlt(x, XoverList(DA, Y).ProgramFlag) = HitPlt(x, XoverList(DA, Y).ProgramFlag) + 1
                    If PDistPlt(x, XoverList(DA, Y).ProgramFlag) < Dst Then
                        PDistPlt(x, XoverList(DA, Y).ProgramFlag) = Dst
                    End If
                    If ProbPlt(x, XoverList(DA, Y).ProgramFlag) < PVal Then
                        ProbPlt(x, XoverList(DA, Y).ProgramFlag) = PVal
                    End If
                    
                    If HitPlt(x, XoverList(DA, Y).ProgramFlag) > MaxHits Then
                        MaxHits = MaxHits + 10
                        RedoPltL(2) = 1
                    End If
                    
                Next 'X
        
            End If
        End If
    Next Y
'    CTime = Abs(GetTickCount)
'    If Abs(CTime - STime) > 200 Then
'        STime = CTime
'        Form1.ProgressBar1.Value = (Z / NextNo) * 100
'        If Z < NextNo Then
'            Form1.SSPanel1.Caption = "Plotting " & OriginalName(Z + 1) & " regions"
'            'If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'        End If
'        Call UpdateF2Prog
'    End If
    
    'Form1.Refresh
    
Next Z

If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If

For Z = 0 To 2
    
    RedoPltL(Z) = 1
    'Exit Sub
Next Z
ReDim StartPlt(AddNum - 1)
For Z = 0 To AddNum - 1
    
   StartPlt(Z) = 1
    'Exit Sub
Next Z
'oDMax = oPMax

Form1.ProgressBar1.Value = 0
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
End Sub

Public Sub UpdatePlotB(DA, Ma, Mi, SIP)
    If SIP = -1 Then Exit Sub
    Dim Dummy As Variant, Dst As Single, Pnt As POINTAPI
    Dim PVal As Variant, VDiffs(2) As Double, LenR As Double, Epos As Long, BPos As Long, XOLen As Long, LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer

    StartY = 15
    PVal = -Log10(XoverList(DA, CurrentXOver(DA)).Probability)
    Form1.Picture7.AutoRedraw = True
    
    LSeq = Len(StrainSeq(0))
    
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(LSeq))
    

    If PVal > PerMaxPval Then
        PerMaxPval = PVal
    End If

    'Form1.Picture7.ScaleMode = 3

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, x As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    BPos = XoverList(DA, SIP).Beginning
    Epos = XoverList(DA, SIP).Ending
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10
    'XX = UBound(VDiffs, 1)
        If x = x Then
            If DebuggingFlag < 2 Then On Error Resume Next
            '@'@
            Dst = MakeDst(Len(StrainSeq(0)), DA, Mi, Ma, BPos, Epos, VDiffs(0), SeqNum(0, 0))
            On Error GoTo 0
        Else
            
            LenR = 0: VDiffs(0) = 0: VDiffs(1) = 0: VDiffs(2) = 0
            If BPos < Epos Then
               For x = BPos To Epos
                    If SeqNum(x, DA) <> 46 Then
                        If SeqNum(x, Mi) <> 46 Then
                            If SeqNum(x, Ma) <> 46 Then
                                LenR = LenR + 1
                                If SeqNum(x, DA) <> SeqNum(x, Mi) Or SeqNum(x, DA) <> SeqNum(x, Ma) Then
                                    If SeqNum(x, DA) <> SeqNum(x, Mi) And SeqNum(x, DA) = SeqNum(x, Ma) Then
                                        VDiffs(0) = VDiffs(0) + 1
                                    ElseIf SeqNum(x, DA) <> SeqNum(x, Ma) And SeqNum(x, DA) = SeqNum(x, Mi) Then
                                        VDiffs(1) = VDiffs(1) + 1
                                    ElseIf SeqNum(x, DA) <> SeqNum(x, Ma) And SeqNum(x, Mi) = SeqNum(x, Ma) Then
                                        VDiffs(2) = VDiffs(2) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
               Next x
            Else
                For x = BPos To LSeq
                    If SeqNum(x, DA) <> 46 Then
                        If SeqNum(x, Mi) <> 46 Then
                            If SeqNum(x, Ma) <> 46 Then
                                LenR = LenR + 1
                                If SeqNum(x, DA) <> SeqNum(x, Mi) Or SeqNum(x, DA) <> SeqNum(x, Ma) Then
                                    If SeqNum(x, DA) <> SeqNum(x, Mi) And SeqNum(x, DA) = SeqNum(x, Ma) Then
                                        VDiffs(0) = VDiffs(0) + 1
                                    ElseIf SeqNum(x, DA) <> SeqNum(x, Ma) And SeqNum(x, DA) = SeqNum(x, Mi) Then
                                        VDiffs(1) = VDiffs(1) + 1
                                    ElseIf SeqNum(x, DA) <> SeqNum(x, Ma) And SeqNum(x, Mi) = SeqNum(x, Ma) Then
                                        VDiffs(2) = VDiffs(2) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
               Next x
               For x = 1 To Epos
                    If SeqNum(x, DA) <> 46 Then
                        If SeqNum(x, Mi) <> 46 Then
                            If SeqNum(x, Ma) <> 46 Then
                                LenR = LenR + 1
                                If SeqNum(x, DA) <> SeqNum(x, Mi) Or SeqNum(x, DA) <> SeqNum(x, Ma) Then
                                    If SeqNum(x, DA) <> SeqNum(x, Mi) And SeqNum(x, DA) = SeqNum(x, Ma) Then
                                        VDiffs(0) = VDiffs(0) + 1
                                    ElseIf SeqNum(x, DA) <> SeqNum(x, Ma) And SeqNum(x, DA) = SeqNum(x, Mi) Then
                                        VDiffs(1) = VDiffs(1) + 1
                                    ElseIf SeqNum(x, DA) <> SeqNum(x, Ma) And SeqNum(x, Mi) = SeqNum(x, Ma) Then
                                        VDiffs(2) = VDiffs(2) + 1
                                    End If
                                End If
                            End If
                        End If
                    End If
               Next x
                
            End If
            
            If VDiffs(0) >= VDiffs(1) And VDiffs(0) >= VDiffs(2) Then
                Dst = VDiffs(0) / LenR
            ElseIf VDiffs(1) >= VDiffs(0) And VDiffs(1) >= VDiffs(2) Then
                Dst = VDiffs(1) / LenR
            ElseIf VDiffs(2) >= VDiffs(1) And VDiffs(2) >= VDiffs(0) Then
                Dst = VDiffs(2) / LenR
            End If
        End If
    
'XXXZZZ    XOverlist(Da, CurrentXOver(Da)).EndPermP = Dst
    'Exit Sub
    If oDMax < Dst Then
        RedoPltL(0) = 1
        oDMax = Dst + 0.1
    End If
    If PPMax < PVal Then
        PPMax = PVal
    End If
    If oPMax < PVal Then
        oPMax = PVal * 1.5
        RedoPltL(1) = 1
    End If
    '@'@
    'BPos = 1000: Epos = 10000
    Dummy = UpdatePlotInfo2(UBound(PDistPlt, 1), UPArrayDimXFact, CSng(PVal), XoverList(DA, SIP).ProgramFlag, LSeq, BPos, Epos, CSng(Dst), MaxHits, PDistPlt(0, 0), ProbPlt(0, 0), HitPlt(0, 0), RedoPltL(0))
    If MaxHits > PHMax Then PHMax = MaxHits
End Sub
Public Sub RecOverview()

    Dim NJSubDistance() As Single, ValidSite() As Single, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, Y As Long, Z As Long, Mi As Long, Ma As Long, P1 As Long, P2 As Long, P3 As Long, P4 As Long, Pict As Long, DA As Long, g As Long, x As Long, StartY As Long
    Dim AvSDst As Double
    
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    
    ReDim NJSubDistance(NextNo, NextNo)
    ReDim ValidSite(NextNo, NextNo)
    LSeq = Len(StrainSeq(0))

    Dim tmpDMax As Double

    ReDim Hitnumber(LSeq + 10)
    oPMax = 0
    MaxHits = 10
    Dim PMa As Double
    PMa = oPMax
    For DA = 0 To NextNo

        For g = 1 To CurrentXOver(DA)

            If XoverList(DA, g).Accept < 2 Then

                If PMa < -Log10(XoverList(DA, g).Probability) Then
                    PMa = -Log10(XoverList(DA, g).Probability)
                End If

                If XoverList(DA, g).Beginning < XoverList(DA, g).Ending Then

                    For x = XoverList(DA, g).Beginning To XoverList(DA, g).Ending
                        Hitnumber(x) = Hitnumber(x) + 1

                        If Hitnumber(x) > MaxHits Then
                            MaxHits = MaxHits + 10
                        End If

                    Next 'X

                Else

                    For x = 1 To XoverList(DA, g).Ending
                        Hitnumber(x) = Hitnumber(x) + 1

                        If Hitnumber(x) > MaxHits Then
                            MaxHits = MaxHits + 10
                        End If

                    Next 'X

                    For x = XoverList(DA, g).Beginning To LSeq
                        Hitnumber(x) = Hitnumber(x) + 1

                        If Hitnumber(x) > MaxHits Then
                            MaxHits = MaxHits + 10
                            RedoLabelFlag = 1
                        End If

                    Next 'X

                End If

            End If

        Next 'G

    Next 'Da

    If oDMax = 0 Then oDMax = 1
    oPMax = Int(PMa) + 1

    Call DoAxes2(oDMax, 0, oPMax, 0, MaxHits, 0, 1, "PDist", "P-Val", "# Hits")

    StartY = 15
    Form1.Picture7.AutoRedraw = True
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10
    
    
    If AvDst = 0 Then Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)

    If PVal > PerMaxPval Then
        PerMaxPval = PVal
    End If

    Dim TotCompare As Long
    Dim Dst As Double
    Dim DistMod As Double

    tmpDMax = 0
    
    For DA = 0 To NextNo

        For g = 1 To CurrentXOver(DA)

            If XoverList(DA, g).Accept < 2 Then
                PVal = -Log10(XoverList(DA, g).Probability)
                Mi = XoverList(DA, g).MinorP
                Ma = XoverList(DA, g).MajorP

                If Mi <= NextNo Then
    'this coluld be speeded up with better nesting of if then's

                    For Z = 0 To NextNo
                        Dummy = DistanceCalcE(Z, NextNo, LSeq + 1, XoverList(DA, g).Beginning, XoverList(DA, g).Ending, SeqNum(0, 0), NJSubDistance(0, 0))
                    Next 'Z

                    AvSDist = 0
                    TotCompare = 0

                    For x = 0 To NextNo - 1

                        For Y = x + 1 To NextNo
                            AvSDst = AvSDst + (1 - NJSubDistance(x, Y))
                        Next 'Y

                    Next 'X

                    If ((NextNo * (NextNo + 1) / 2) - TotCompare) > 0 Then
                        AvSDst = AvSDst / ((NextNo * (NextNo + 1) / 2) - TotCompare)
                    Else
                        Exit Sub
                    End If

                    DistMod = AvSDst / AvDst

                    If ValidSite(DA, Mi) = 0 Then ValidSite(DA, Mi) = 1

                    If ValidSite(DA, Ma) = 0 Then ValidSite(DA, Ma) = 1
                    'subtract the shortest distance of mi -da in redcomb region or mada in rest of seq (obviously corrected).

                    If DA <> Ma Then

                        If ((1 - Distance(DA, Ma)) * DistMod) < (1 - (ValidSite(DA, Mi) - NJSubDistance(DA, Mi)) / ValidSite(DA, Mi)) Then
                            Dst = (1 - (ValidSite(DA, Ma) - NJSubDistance(DA, Ma)) / ValidSite(DA, Ma)) - ((1 - Distance(DA, Ma)) * DistMod)
                        Else
                            Dst = (1 - (ValidSite(DA, Ma) - NJSubDistance(DA, Ma)) / ValidSite(DA, Ma)) - (1 - (ValidSite(DA, Mi) - NJSubDistance(DA, Mi)) / ValidSite(DA, Mi))
                        End If

                    Else
                        Dst = (1 - Distance(DA, Mi)) * DistMod
                    End If

                    If Dst < 0 Then Dst = (1 - Distance(DA, Ma)) * DistMod

                    If Dst > tmpDMax Then tmpDMax = Dst

                    If XoverList(DA, g).Beginning < XoverList(DA, g).Ending Then
                        X1 = 30 + Decompress(XoverList(DA, g).Beginning) * XFactor + XFactor
                        X2 = 30 + Decompress(XoverList(DA, g).Ending) * XFactor + XFactor
                        Y1 = P2 - 5 - ((Dst / oDMax) * (P2 - P1 - 10))
                        Y2 = P2 - 5
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, g).ProgramFlag), BF
                    Else
                        X1 = 30 + Decompress(XoverList(DA, g).Beginning) * XFactor + XFactor
                        X2 = 30 + Decompress(LSeq) * XFactor + XFactor
                        Y1 = P2 - 5 - ((Dst / oDMax) * (P2 - P1 - 10))
                        Y2 = P2 - 5
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, g).ProgramFlag), BF
                        X1 = 30 + Decompress(1) * XFactor + XFactor
                        X2 = 30 + Decompress(XoverList(DA, g).Ending) * XFactor + XFactor
                        Y1 = P2 - 5 - ((Dst / oDMax) * (P2 - P1 - 10))
                        Y2 = P2 - 5
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, g).ProgramFlag), BF
                    End If

                End If

                If XoverList(DA, g).Beginning < XoverList(DA, g).Ending Then
                    X1 = 30 + Decompress(XoverList(DA, g).Beginning) * XFactor + XFactor
                    X2 = 30 + Decompress(XoverList(DA, g).Ending) * XFactor + XFactor
                    Y1 = P3 - 5 - (PVal / oPMax) * (P3 - P2 - 10)
                    Y2 = P3 - 5
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, g).ProgramFlag), BF
                Else
                    X1 = 30 + Decompress(XoverList(DA, g).Beginning) * XFactor + XFactor
                    X2 = 30 + Decompress(LSeq) * XFactor + XFactor
                    Y1 = P3 - 5 - (PVal / oPMax) * (P3 - P2 - 10)
                    Y2 = P3 - 5
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, g).ProgramFlag), BF
                    X1 = 30 + Decompress(1) * XFactor + XFactor
                    X2 = 30 + Decompress(XoverList(DA, g).Ending) * XFactor + XFactor
                    Y1 = P3 - 5 - (PVal / oPMax) * (P3 - P2 - 10)
                    Y2 = P3 - 5
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), ProgColour(XoverList(DA, g).ProgramFlag), BF
                End If

            End If

        Next 'G

    Next 'Da
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5 - (Hitnumber(1) / MaxHits) * (P4 - P3 - 10), Pnt

    For x = 2 To LSeq
        LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P4 - 5 - (Hitnumber(x) / MaxHits) * (P4 - P3 - 10)
    Next 'X

    oDMax = Int(tmpDMax * 10 + 1) / 10
    Form1.Picture7.Refresh
End Sub
Public Sub RecOverview2()

    
    Dim ValidSite() As Single, PVal As Double
    Dim Pnt As POINTAPI
    Dim LSeq As Long, Pict As Long, SY As Long, EY As Long
    Dim RedoLabelFlag As Integer
    Dim StartY As Integer
    
    
    If UBound(PDistPlt, 1) < UPArrayDim1 + 10 Then
        ReDim PDistPlt(UPArrayDim1 + 10, AddNum)
        ReDim ProbPlt(UPArrayDim1 + 10, AddNum)
        ReDim HitPlt(UPArrayDim1 + 10, AddNum)
        ReDim Hitnumber(Len(StrainSeq(0)) + 10)
    End If
    
    Form1.Picture7.AutoRedraw = True
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    
    LSeq = Len(StrainSeq(0))

    YScaleFactor = 0.901
    PicHeight = CInt(Form1.Picture7.Height * YScaleFactor)
    TH = Form1.Picture7.TextHeight("0")

    Dim P1 As Integer, P2 As Integer, P3 As Integer, P4 As Integer, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim Z As Long, x As Long, Y As Long, YIncriment As Long
    Dim AvSDst As Double, LVal As Double, UVal As Double
    
    StartY = 15
    
    P1 = StartY
    P2 = StartY + (PicHeight - 10 - StartY) / 3
    P3 = StartY + ((PicHeight - 10 - StartY) / 3) * 2
    P4 = PicHeight - 10


    Dim Dst As Double, Outnum As Double
    Dim SOutNum As String
    Dim XLegendA As String
    
    PartNumber = (PicHeight / 3 - 35) / (TH * 3)

    If PartNumber < 3 Then PartNumber = 3

    YIncriment = CLng((StartY + ((PicHeight - 10 - StartY) / 3) * 2 - (StartY + (PicHeight - 10 - StartY) / 3) - 10) / (PartNumber - 1))


    Call DoAxes2(oDMax, 0, oPMax, 0, MaxHits, 0, 0, "PDist", "P-Val", "# Hits")
    
    Form1.Picture7.ForeColor = 0
    Call UpdatePlotD
    Call UpdatePlotC
    
    Exit Sub
    x = 0
    
    Dim ProgcolourB() As Long
    ReDim ProgcolourB(AddNum - 1)
    
    ProgcolourB(0) = RGB(206, 165, 165)
    ProgcolourB(1) = RGB(179, 179, 206)
    ProgcolourB(2) = RGB(155, 184, 171)
    ProgcolourB(3) = RGB(206, 179, 155)
    
    Form1.Picture7.DrawWidth = 2
    For Y = 0 To AddNum - 1
        If StartPlt(Y) = 1 Then
            Form1.Picture7.ForeColor = ProgcolourB(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - (PDistPlt(1, Y) / oDMax) * (P2 - P1 - 10), Pnt
            For x = 2 To LSeq
                LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P2 - 5 - (PDistPlt(x, Y) / oDMax) * (P2 - P1 - 10)
            Next 'X
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5 - (ProbPlt(1, Y) / oPMax) * (P3 - P2 - 10), Pnt
            For x = 2 To LSeq
                LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P3 - 5 - (ProbPlt(x, Y) / oPMax) * (P3 - P2 - 10)
            Next 'X
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5 - (HitPlt(1, Y) / MaxHits) * (P4 - P3 - 10), Pnt
            For x = 2 To LSeq
                LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P4 - 5 - (HitPlt(x, Y) / MaxHits) * (P4 - P3 - 10)
            Next 'X
        End If
    Next 'Y
    
    Form1.Picture7.DrawWidth = 1
    
    Call Highlight(0)
    
    For Y = 0 To AddNum - 1
        If StartPlt(Y) = 1 Then
            Form1.Picture7.ForeColor = ProgColour(Y)
            Pict = Form1.Picture7.hdc
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P2 - 5 - (PDistPlt(1, Y) / oDMax) * (P2 - P1 - 10), Pnt
            For x = 2 To LSeq
                LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P2 - 5 - (PDistPlt(x, Y) / oDMax) * (P2 - P1 - 10)
            Next 'X
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P3 - 5 - (ProbPlt(1, Y) / oPMax) * (P3 - P2 - 10), Pnt
            For x = 2 To LSeq
                LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P3 - 5 - (ProbPlt(x, Y) / oPMax) * (P3 - P2 - 10)
            Next 'X
            MoveToEx Pict, 30 + Decompress(1) * XFactor + XFactor, P4 - 5 - (HitPlt(1, Y) / MaxHits) * (P4 - P3 - 10), Pnt
            For x = 2 To LSeq
                LineTo Pict, 30 + Decompress(x) * XFactor + XFactor, P4 - 5 - (HitPlt(x, Y) / MaxHits) * (P4 - P3 - 10)
            Next 'X
        End If
    Next 'Y
    
    Form1.Picture7.Refresh
End Sub
Public Sub StepDown()
Dim LPV As Integer, On1 As Byte
On1 = 0
'ReDim PValCat(AddNum, 100)
'ReDim MaxPValCat(AddNum, 100)
If CurrentCorrect = 0 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 1 Then
    If GCtripletflag = 1 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 2 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 3 Then
    If MCTripletFlag = 0 Then
        MC = MCCorrection
    Else
        MC = MCCorrect
    End If
ElseIf CurrentCorrect = 4 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 5 Then
    MC = MCCorrection
ElseIf CurrentCorrect = 6 Then
    MC = NumberOfSeqs + 1
Else

End If
For x = 99 To 0 Step -1
    PValCat(CurrentCorrect, x) = PValCat(CurrentCorrect, x) + PValCat(CurrentCorrect, x + 1)
Next x

For x = 0 To 99
    PValCat(CurrentCorrect, x) = MC - PValCat(CurrentCorrect, x)
    If PValCat(CurrentCorrect, x) < 0 Then
        PValCat(CurrentCorrect, x) = 0
    End If
Next x

For x = 0 To NextNo
    For Y = CurrentXOver(x) To 1 Step -1
        If XoverList(x, Y).ProgramFlag = CurrentCorrect Then
            LPV = CInt(-Log10(XoverList(x, Y).Probability) * 2)
            If LPV < 100 And LPV > 0 Then
                If XoverList(x, Y).Probability > MaxPValCat(CurrentCorrect, LPV) Then
                    MaxPValCat(CurrentCorrect, LPV) = XoverList(x, Y).Probability
                End If
            End If
        Else
            Exit For
        End If
    Next Y

Next x

For x = 99 To 0 Step -1
    If MaxPValCat(CurrentCorrect, x) = 0 Then
        MaxPValCat(CurrentCorrect, x) = MaxPValCat(CurrentCorrect, x + 1)
    Else
        x = x
    End If
Next x

For x = 0 To NextNo
    Y = CurrentXOver(x)
    Do While Y > 0
        If XoverList(x, Y).ProgramFlag = CurrentCorrect Then
            LPV = CInt(-Log10(XoverList(x, Y).Probability) * 2)
            If LPV > 0 Then
                
                If LPV < 100 Then
                    If PValCat(CurrentCorrect, LPV + 1) > 0 Then
                        If (XoverList(x, Y).Probability * PValCat(CurrentCorrect, LPV)) > (MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)) Then
                            XoverList(x, Y).Probability = XoverList(x, Y).Probability * PValCat(CurrentCorrect, LPV)
                        Else
                            XoverList(x, Y).Probability = MaxPValCat(CurrentCorrect, LPV + 1) * PValCat(CurrentCorrect, LPV + 1)
                        End If
                    Else
                        XoverList(x, Y).Probability = XoverList(x, Y).Probability * MC
                    End If
                Else
                   XoverList(x, Y).Probability = XoverList(x, Y).Probability * MC
                End If
            End If
            
            If XoverList(x, Y).Probability > LowestProb Then
                
                
                If Y = CurrentXOver(x) Then
                    CurrentXOver(x) = CurrentXOver(x) - 1
                Else
                    XoverList(x, Y) = XoverList(x, CurrentXOver(x))
                    CurrentXOver(x) = CurrentXOver(x) - 1
                    
                End If
                If CurrentCorrect <> 1 Or (CurrentCheck = 1 And GCtripletflag = 1) Then
                    oRecombNo(100) = oRecombNo(100) - 1
                End If
                If CurrentCorrect = 1 Then
                    If GCtripletflag = 0 Then
                        If XoverList(x, Y).OutsideFlag = 1 Then
                            'Keep track of signal numbers
                            oRecombNo(100) = oRecombNo(100) - 1
                            oRecombNo(1) = oRecombNo(1) - 1
                        Else
                            On1 = On1 + 1
                            If On1 > 1 Then
                                On1 = 0
                                'Keep track of signal numbers
                                oRecombNo(100) = oRecombNo(100) - 1
                                oRecombNo(1) = oRecombNo(1) - 1
                            End If
                        End If
                    Else
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) - 1
                        oRecombNo(1) = oRecombNo(1) - 1
                    End If
                Else
                 
                    oRecombNo(CurrentCorrect) = oRecombNo(CurrentCorrect) - 1
                
                End If
            End If
        Else
            Exit Do
        End If
        Y = Y - 1
    Loop
    
Next x

End Sub

Public Sub XOver(Distance() As Single, XPosDiff() As Long, XDiffPos() As Long, CurrentXOver() As Integer, XoverList() As XOverDefine, SeqNum() As Integer, Seq1 As Long, Seq2 As Long, Seq3 As Long, DoAllFlag)
Dim GoOn As Long, NumInList As Long, PBinFlag As Long, NumSame As Long, XPDDone As Long, LowThresh As Double
Dim SIP As Long, XOverLen As Long, A As Long, ENN As Long, BEE As Long, SPF As Byte, Dummy As Variant, MCC As Long, FF As Long, oDir As String, UB As Long, OldX As Long
'@'@

PBinFlag = -1
    If SelGrpFlag > 0 Then
        Dim GrpTest As Long
        GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
        If GrpTest < 2 Then
            Exit Sub
        End If
    End If
    '0.343 - 1K perms
    Dim AFact As Double, BWarn As Byte, EWarn As Byte, DoneRedo As Byte, b As Long, BTarget As Long, ETarget As Long, Split As Long, AD As Long, AMi As Long, AMa As Long, BE As Long, EN As Long, NCommon As Long, StartPosX As Long
    Dim NextPosX As Long
    Dim oProbXOver As Double, Inlyer As Integer
    Dim FindCycle As Integer, Store As Long, Storex As Long, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, SeqDaughter As Long, SeqMinorP As Long, Temp As Integer, EndFlag As Long, HighHomol As Long, MedHomol As Long, LowHomol As Long
    Dim DA As Long, Ma As Long, Mi  As Long, x As Long, NumDifferent As Long, NumDiff As Long, XOL As Long, Z As Long
    
    Dim SLen As Long, AmaTot As Double, AmiTot As Double, ATot As Double
    Dim AH(2) As Long
    DoneRedo = 0
    
    '@
    SLen = Len(StrainSeq(0))
    

    'Dim RDProportionflag As Byte
    'RDProportionflag = 1
    'If RDProportionflag = 1 Then
    '    If PermDiffs(Seq1, Seq2) > PermDiffs(Seq1, Seq3) And PermDiffs(Seq1, Seq2) > PermDiffs(Seq2, Seq3) Then
    '        XOverWindow = CLng(PermDiffs(Seq1, Seq2) * 0.66)
    '    ElseIf PermDiffs(Seq1, Seq3) > PermDiffs(Seq2, Seq3) Then
    '        XOverWindow = CLng(PermDiffs(Seq1, Seq3) * 0.66)
    '    Else
    '        XOverWindow = CLng(PermDiffs(Seq2, Seq3) * 0.66)
    '    End If
    'Else
    '    XOverWindow = Int(XOverWindowX / 2)
    'End If
    FirstDrawFlag = 0
    
    'Find reference sequences (takes 0.3/21)
    '@
    Dim NeedToClean As Byte
    Dim NewXPos As Long
    NewXPos = 0
    NeedToClean = 0
    If SpacerFlag > 0 Then
        If SpacerFlag < 4 Then
            UB = UBound(TreeDistance, 1)
            
            If SEventNumber > 0 Then
                
                If UBound(ValidSpacer, 1) < UB Then
                    ReDim Preserve ValidSpacer(UB)
                End If
                If UBound(SpacerSeqs, 1) < UB Then
                    ReDim Preserve SpacerSeqs(UB)
                End If
                If UBound(MaskSeq, 1) < UB Then
                    ReDim Preserve MaskSeq(UB)
                End If
            End If
'            If DebuggingFlag < 2 Then On Error Resume Next
'            UB = 0
'            UB = UBound(TreeDistance, 1)
'
'
'            On Error GoTo 0
'

            InRangeFlag = SpacerFindB(UB, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNo, TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqs(0), ValidSpacer(0))
            
'            If PermNextno > LowMemThreshold Then
'                Erase Distance
'            End If
            
            If InRangeFlag = 0 Then Exit Sub
        ElseIf SpacerFlag = 4 Then
            SpacerNo = 1
            SpacerSeqs(1) = Spacer4No
            
        End If
    
    
    
        'Find Information rich subsequences (takes 11/21)
    
        If SpacerNo = 0 Then
            Exit Sub
        End If
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqX)
        'This could be speeded up with better nesting
        
            LenXoverSeq = FindSubSeqP(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
        
    Else

            
            ''XX = UBound(XoverSeqNumW, 1)
            'XX = RedoListSize
            
            'nt
            '@'@
            If (UBound(CompressSeq, 2) = NextNo And SEventNumber = 0) Or UseCompress = 1 Then
                NeedToClean = 1
'                SSSS = abs(gettickcount)
'
'                For Z = 1 To 1000000
'
'                AH(0) = 0
'                AH(1) = 0
'                AH(2) = 0
                '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
                
                'If x = 123456 Then
                '$'$'$'$'&
                    LenXoverSeq = FindSubSeqPB3(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), FSSRDP(0, 0, 0, 0))
                    
                    x = x
                    'LenXoverSeq = FindSubSeqPB3(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), FSSRDP(0, 0, 0, 0))
                
                'Else
                '    NewXPos = 1
                '    LenXoverSeq = FindSubSeqPB5(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), Nextno, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), FSSRDP(0, 0, 0, 0))
                'End If
                'x = x
                'LenXoverSeq = FindSubSeqPB3(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), Nextno, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), XDiffPos(0), XPosDiff(0), FSSRDP(0, 0, 0, 0))


'                Next Z
'                eeee = abs(gettickcount)
'                TT = eeee - SSSS
                'no ah incriment'1953,1953, 1968
                'no xoverseqnum incriment, 1750, 1719
                'leaving off the window overlap 1969
                '2715 without the empty triplet check
                'all 2000
                'XX = RedoListSize
                x = x
            Else
                'SSSS = abs(gettickcount)
                'For Z = 1 To 100000
                '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
                LenXoverSeq = FindSubSeqP(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
                'Next Z
            End If
'            eeee = abs(gettickcount)
'            tttt = eeee - SSSS '1844
'            x = x
            'LenXoverSeq = FindSubSeqP(AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
            
            'x = x
            '0(174)=0,2;162(211) =0,9; 0(181) = 0,10; 209 = 0,17; 0(179)=0,19; 103(189) = 0,22:s1=79
            'Exit Sub
'            XX = AH(0)
'            XX = AH(1)
'            XX = AH(2)
'             XX = XPosDiff(2397) '1041
'            XX = XPosDiff(2398) '1042
'            XX = XDiffPos(1041) '2398
'            XX = XDiffPos(1042) '2404
'
'        Open "coords2.csv" For Output As #1
'            For X = 0 To Len(StrainSeq(0))
''                Out$ = Str(XPosDiff(X))
'
''                For Y = 0 To 2
''                Next Y
'                Print #1, XPosDiff(X)
'            Next X
            'Close #1
            XPDDone = 1
            'Exit Sub
'Exit Sub
'Exit Sub
'        For X = 0 To LenXOverSeq
'                If XDiffPos(X) <> XDiffPos2(X) Then
'                    X = X
'                End If
'                If XPosDiff(X) <> xposdiff2(X) Then
'                    X = X
'                End If
'                For Y = 0 To 2
'                    If Xoverseqnumw2(X, 0) <> XoverSeqNumW(X, 0) Then '(2,0)
'                        X = X
'                    End If
'                Next Y
'            Next X
        'End If
'            For X = 0 To LenXOverSeq
'                For Y = 0 To 2
'                    If Xoverseqnumw2(X, Y) <> XoverSeqNumW(X, Y) Then '(2,0)
'                        X = X
'                    End If
'                Next Y
'            Next X
        
'        End If
'            X = X
        
    End If
    
    'Exit Sub
    'XX = CircularFlag
    '2.625,2.610
    
    If LenXoverSeq < XoverWindow * 2 Then
        If NeedToClean = 1 Then
            Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        End If
        Exit Sub
    End If
    
    If AH(0) < XoverWindow / 3 Or AH(1) < XoverWindow / 3 Or AH(2) < XoverWindow / 3 Then
        If NeedToClean = 1 Then
            Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        End If
        Exit Sub
    End If
    If AH(0) = 0 Or AH(1) = 0 Or AH(2) = 0 Then
        If NeedToClean = 1 Then
            Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        End If
        Exit Sub
    End If
    '@'@'@'@'@
    AvHomol(1) = (AH(0) / LenXoverSeq)
    AvHomol(2) = (AH(1) / LenXoverSeq)
    AvHomol(3) = (AH(2) / LenXoverSeq)
    '@
'    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000 '0.3088
'    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000 '0.4847
'    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000 '0.2065
    
    If MCFlag = 0 Then
        MCC = MCCorrection
    Else
        MCC = 1
    End If
    
    
    
    
    
    
    '@
    LenXoverSeq = Abs(LenXoverSeq) - 1 '875
    

    
    'Work out identities (7.1/21)

    If DebuggingFlag < 3 Then On Error Resume Next
    '@'@
    If UBound(TreeDistance, 1) > 0 Then
        If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
            HighHomol = 1
        ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
            HighHomol = 2
        ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
            HighHomol = 3
        End If
    Else
       If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
            HighHomol = 1
        ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
            HighHomol = 2
        ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) Then
            HighHomol = 3
        End If
    End If
On Error GoTo 0
    
    
    
    'ReDim XOverHomologyNum(LenXOverSeq + XoverWindow * 2, 2)
    
    'C Routine to work out moving identity averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    
    '@'@'@'@'@'@'@'@'@'@'@'@
    'SS = abs(gettickcount)
'    If LenXoverSeq < 2000 Then
'        x = x
'    End If
   'For x = 0 To 400000
    '@'@
     If LenXoverSeq < 2500 Then 'not worth doing this in paralell for smaller lenxoverseqs
        StartPosX = XOHomologyP(HighHomol, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
     Else
        StartPosX = XOHomologyPB5(HighHomol, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
     End If
    'End If
   'Next x
    'EE = abs(gettickcount) '1297
    '3735,2531,2532,2594
    'TT = EE - SS
    '@
    If StartPosX = 0 And ShortOutFlag <> 3 Then
        If NeedToClean = 1 Then
            Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        End If
        Exit Sub
    End If
    'End If
    '1.883
    '@
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    UB = UBound(Distance, 1)
    If UB = -1 Or UB = 0 Then
        If DistanceInFileFlag = 1 Then
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            
            FF = FreeFile
            'UBDistance = UBound(Distance, 1)
            ReDim Distance(UBDistance, UBDistance)
            Open "RDP5Distance" + UFTag For Binary As #FF
            Get #FF, , Distance()
            Close #FF
            'DistanceInFileFlag = 0
            'Erase Distance
            ChDir oDir
            ChDrive oDir
        End If
    End If
    On Error GoTo 0
    '@'@'@'@
    If Seq1 <= UBound(Distance, 1) And Seq2 <= UBound(Distance, 1) And Seq3 <= UBound(Distance, 1) Then
        If AvHomol(1) = AvHomol(2) And AvHomol(1) = AvHomol(3) Then
            If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                    AvHomol(2) = AvHomol(2) - 0.00001
                    AvHomol(3) = AvHomol(3) - 0.00002
                Else
                    AvHomol(2) = AvHomol(2) - 0.00002
                    AvHomol(3) = AvHomol(3) - 0.00001
                End If
            ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                    AvHomol(1) = AvHomol(1) - 0.00001
                    AvHomol(3) = AvHomol(3) - 0.00002
                Else
                    AvHomol(1) = AvHomol(1) - 0.00002
                    AvHomol(3) = AvHomol(3) - 0.00001
                End If
            Else
                If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                    AvHomol(1) = AvHomol(1) - 0.00001
                    AvHomol(2) = AvHomol(2) - 0.00002
                Else
                    AvHomol(1) = AvHomol(1) - 0.00002
                    AvHomol(2) = AvHomol(2) - 0.00001
                End If
            End If
        ElseIf AvHomol(1) = AvHomol(2) Then
            If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                AvHomol(2) = AvHomol(2) - 0.00001
            Else
                AvHomol(1) = AvHomol(1) - 0.00001
            End If
        ElseIf AvHomol(1) = AvHomol(3) Then
            If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                AvHomol(3) = AvHomol(3) - 0.00001
            Else
                AvHomol(1) = AvHomol(1) - 0.00001
            End If
        ElseIf AvHomol(2) = AvHomol(3) Then
            If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                AvHomol(3) = AvHomol(3) - 0.00001
            Else
                AvHomol(2) = AvHomol(2) - 0.00001
            End If
        End If
    
    End If
    'If PermNextno > LowMemThreshold Then
    '    Erase Distance
    'End If
    
    
    '2.142
    
    
    '@'@
    If AvHomol(1) >= AvHomol(2) And AvHomol(1) >= AvHomol(3) Then
        HighHomol = 1

        If AvHomol(2) >= AvHomol(3) Then
            MedHomol = 2: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        
        Else 'If AvHomol(3) > AvHomol(2) Then
            MedHomol = 3: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(3) Then
        HighHomol = 2

        If AvHomol(1) >= AvHomol(3) Then
            MedHomol = 1: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        Else 'If AvHomol(3) > AvHomol(1) Then
            MedHomol = 3: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(3) >= AvHomol(1) And AvHomol(3) >= AvHomol(2) Then
        HighHomol = 3
        '@
        If AvHomol(1) >= AvHomol(2) Then
            MedHomol = 1: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        Else 'If AvHomol(2) > AvHomol(1) Then
            MedHomol = 2: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        'Else
        '    Exit Sub
        End If

    End If
 
 

   
   '1.823
   '@
    FindCycle = 0
    
    'XX = Seq1: XX = Seq2: XX = Seq3
    'Exit Sub
    '@
    OldX = -1
    
    Dim UBXOHN As Long
    '@
    UBXOHN = UBound(XOverHomologyNum, 1)
    
    
'    If FastestFlag = 1 Then
'        If FindallFlag = 0 Then
'            If MCFlag = 0 Then
'                LowThresh = (LowestProb / (MCCorrection / 1000))
'
'                If LowThresh > LowestProb Then LowThresh = LowestProb
'            Else
'                LowThresh = LowestProb
'            End If
'        Else
'            LowThresh = LowestProb
'        End If
'    Else
'    'Exit Sub
'        LowThresh = LowestProb
'    End If
    LowThresh = LowestProb
    Dim XDPAlreadyDone As Byte
    XDPAlreadyDone = 0
    
    Do
        '
        NextPosX = 1 'StartPosX
        Storex = 0
        
        Do
            
            
            'This could be speeded up a bit
            '@'@'$'$
            x = FindNextP(UBXOHN, NextPosX, HighHomol, MedHomol, LowHomol, LenXoverSeq, XoverWindow, XOverHomologyNum(0, 0))
                
              'XX = SeqNum(1800, 258)
            '@'@'$
            If x > -1 And x <> OldX Then
                OldX = x
                '5.078 - 1K perms
                '@
                If CircularFlag = 1 And XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, HighHomol - 1) And x = 1 Then 'And ReassortmentFlag = 0 Then
                    '@'@'@'@
                    x = FindFirstCOP(x, MedHomol, HighHomol, LenXoverSeq, UBXOHN, XOverHomologyNum(0, 0))
                    x = x
                Else
                    NCommon = 0
                    XOverLength = 0
                    '@'@'@'@'@'@'@'@'@'@'@'@'@
                    'XX = Len(StrainSeq(0))
                    x = DefineEventP2(UBXOHN, ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, x, XoverWindow, SLen, LenXoverSeq, SeqMinorP, SeqDaughter, EndFlag, BE, EN, NCommon, XOverLength, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
                    'mhl - 312,mp,d - 2,1; 93,55
                    '68,115
                    x = x
                    
                    'Uncommenting this code uses the bintable - it reduces the number of probxover tests BUT not enough to make a difference
                    
                    '2.183
                    'If Int(indprob * 100) + 1 <= 100 Then
                    '    ip = Int(indprob * 100) + 1
                    'Else
                    '    ip = 100
                    'End If
                    'Dim GoOnXX As Byte
                    'GoOnXX = 1
                    'If Int(XOverLength / 5) + 1 <= 34 And (Int(NCommon / 5) + 1) <= 34 Then
                    '    If BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) > 0.05 Then
                    '
                    '        GoOnXX = 0
                    '    End If
                    'End If
                    'GoOnXX = 1 ' 0.5 cutoff 40 seconds = 1 reassortment
                    '@'@'@'@
                    If XOverLength > 2 And EN <> BE And (EN > BE Or CircularFlag = 1) Then ' And GoOnXX = 1 Then ' And BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) < 0.5 Then
                        
                        NumDifferent = XOverLength - NCommon
                        
                        If NCommon > NumDifferent * 0.8 Then
                    
                            '@
                            If XOverLength >= 170 Then
                                AFact = XOverLength / 169
                                NumDiff = CLng(NumDifferent * 169 / XOverLength)
                                XOL = 169
                                NumSame = XOL - NumDiff
                            Else
                                '
                                XOL = XOverLength
                                NumDiff = NumDifferent
                                AFact = 1
                                NumSame = NCommon
                            End If
                        
                        
                             'if i put the worthwhile scan filter here it skips ~1900 trips and gets the right answer - not much of a time reduction though
                        
                             
                            
                                                

                            
                            'C routine that calculates the "probability" of the "recomination signal" having occured by chance mutation without recombination.
                            'ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)
                            '
                            '169,6,16
    '                       If Seq1 = 21 And Seq2 = 22 And Seq3 = 24 Then
    '                            X = X
    '                        End If
    'XX = AllowConflict
                            '@
                            IndProb = AvHomol(MedHomol)
                            GoOn = 0
                            '@'@
                            If ProbEstimateInFileFlag = 0 Then
                                '@'@'@
                                If ProbEstimate(XOL, NumSame, Int(IndProb * 50)) < LowThresh Then
                                    GoOn = 1
                                End If
                            Else
                                GoOn = 1
                            End If
                            
                            If GoOn = 1 Then '169,169-6,16, lenxoverseq =1644
                                '
                                'if i put the worthwhile scan filter here it skips ~2399 trips and gets the right answer - on;y ~5% time reduction though
                                '@'@'@'$
                                If XOverLength <= UBFact3x3 Then
                                    '@'@'@'@'@'@'@'@'@'@
                                    ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOL, NumSame, IndProb, LenXoverSeq)
                                Else
                                    '@'@'@'@'@'@'@'@'@'@
                                    ProbabilityXOver = ProbCalcP(Fact(0), XOL, NumSame, IndProb, LenXoverSeq)
                                End If
                                '20,14
                        
                            
                                
                                 
                                If ProbabilityXOver < 0.5 Then
                                    'if i put the worthwhile scan filter here it skips ~3000 trips and gets the right answer - only ~5% time reduction though
                                    
                                    
                                    
                                    If AFact <> 1 Then
                                        If ProbabilityXOver > 0 Then
                                            ProbabilityXOver = ProbabilityXOver ^ AFact
                                        Else
                                            ProbabilityXOver = 0.05
                                        End If
                                    End If
                                    
                                    If ProbabilityXOver < 10 ^ -300 Then
                                        ProbabilityXOver = 10 ^ -300
                                    End If
                                    
                                    If ProbabilityXOver < 0.05 Then
                                        NewOneFound = 1
                                    End If
                                    If APermFlag = 1 Then
                                        If ProbabilityXOver > 0 And (ProbabilityXOver < BestPermP(CPermNo, 0) Or BestPermP(CPermNo, 0) = 0) Then
                                            BestPermP(CPermNo, 0) = ProbabilityXOver
                                        End If
                                    Else
                                        oProbXOver = ProbabilityXOver
                                        If MCFlag = 0 Then
                                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                                        End If
                                        
                                        '
                                        If ShortOutFlag = 3 Then
                                            If ProbabilityXOver <= mtP(0) Then
                                                mtP(0) = ProbabilityXOver
                                            End If
                                        End If
                                        
                                        '2.323
                                        
                                        
                                        
                                        'If (ProbabilityXOver < LowestProb Or oProbXOver < CritPVals(0)) And ProbabilityXOver > 0 And ProbabilityXOver <> 1 Then
                                        
                                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                        'need to determin xdiffpos/xposdiff here
                                        'need to convert BE and EN to full sequence versions
                                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                            
                                            
                                          
                                        
                                            '2.033
                                            '
'                                            If SEventNumber = 0 And ProbabilityXOver < LowestProb * MCCorrection / 20 Then
'                                                    'if i put the worthwhile scan filter here mccorrection/20 cutoff it skips ~184000 trips and gets the wrong answer - 254 instead of 263 only a ~2% time reduction though for some reason
'                                                    'if i put the worthwhile scan filter here with mccorrection/10 cutoff it skips ~99499 trips and gets the wrongish answer - 262 instead of 263 only a ~6% time reduction though
'                                                    'if i put the worthwhile scan filter here mccorrection/5 cutoff it skips ~54000 trips and gets the wrongish answer - 262 instead of 263 only a ~5% time reduction though
'                                                    If FastestFlag = 1 Then
'                                                        If PBinFlag = -1 Then
'                                                            NuminList = GetNumInList(Seq1, Seq2, Seq3)
'                                                            PBinFlag = 1
'                                                            If ProgBinRead(0, Worthwhilescan(NumList)) = 0 Then
'                                                            If Worthwhilescan(NuminList) > 0 Then
'                                                                X = X
'                                                            End If
'                                                                Worthwhilescan(NuminList) = Worthwhilescan(NuminList) + 1
'                                                            End If
'
'                                                        End If
'                                                    End If
'                                                End If
'                                            If ProbabilityXOver < LowestProb * 1 And ProbabilityXOver > 0 Then
'                                                NewOneFound = 1
'                                            End If
'0.618, 43K,19k,0.023
'0.0169
'XX = CircularFlag
                                            If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                            
                                                'the is the late xdiffpos determination
                                                If SpacerFlag = 0 And (((UBound(CompressSeq, 2) = NextNo And SEventNumber = 0) Or UseCompress = 1) And XDPAlreadyDone = 0) Then
                                                    '@'@'@'$'@
                                                    Dummy = FindSubSeqPB4(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), XDiffPos(0), XPosDiff(0), FSSRDP(0, 0, 0, 0))
                                                    'XX = XPosDiff(LenXoverSeq)
                                                    'XX = XDiffPos(LenXoverSeq)
                                                    XDPAlreadyDone = 1
                                                End If
                                                 'if i put the worthwhile scan filter here it skips ~1.146M trips and gets the wrongish answer - 247 instead of 263 ~50% time reduction though
                                                
                                                If SEventNumber = 0 Then
                                                    If FastestFlag = 1 Then
                                                        If PBinFlag = -1 Then
                                                            If UseALFlag = 0 Then
                                                                NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                                            Else
                                                                NumInList = CurrentTripListNum
                                                            End If
                                                            PBinFlag = 1
                                                            If ProgBinRead(0, Worthwhilescan(NumInList)) = 0 Then
                                                            
                                                                Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 1
                                                            End If
                                                            
                                                        End If
                                                    End If
                                                End If
                                                Dim oEN As Long, OBE As Long
                                                oEN = EN
                                                OBE = BE
                                                
                                                If CircularFlag = 0 Then
                                                    If BE = 1 Then
                                                        If XDiffPos(BE) < TargetX Then
                                                            BE = 1
                                                            OBE = 1
                                                        Else
                                                            BE = XDiffPos(BE)
                                                        End If
                                                    
                                                    Else
                                                        BE = XDiffPos(BE)
                                                    End If
                                                
                                                Else
                                                    BE = XDiffPos(BE)
                                                End If
                                                
                                                
                                                If EN = LenXoverSeq And CircularFlag = 0 Then
                                                    If ShortOutFlag = 0 Or ShortOutFlag = 6 Or ShortOutFlag = 10 Then
                                                        EN = Len(StrainSeq(0))
                                                    Else
                                                        
                                                        EN = XDiffPos(LenXoverSeq)
                                                    End If
                                                    oEN = LenXoverSeq
                                        
                                                Else
                                                    If EN >= LenXoverSeq Then
                                                        If LongWindedFlag = 0 Then
                                                            XDiffPos(EN) = 0
                                                        Else
                                                            EN = LenXoverSeq + 1
                                                        End If
                                        
                                                    ElseIf EN < 1 Then
                                                        EN = LenXoverSeq + 1
                                                        
                                                    End If
                                                    oEN = EN
                                                    EN = XDiffPos(EN)
                                                End If
                                        
                                                
                                                If EN = 0 Then
                                        
                                                    If ShortOutFlag = 0 Or ShortOutFlag = 6 Or ShortOutFlag = 10 Then
                                                        EN = Len(StrainSeq(0))
                                                        
                                                    Else
                                                        EN = XDiffPos(LenXoverSeq)
                                                    End If
                                                    oEN = LenXoverSeq
                                                End If
                                            
                                                If ShowPlotFlag = 1 Then 'Draw plots if necessary
                                        
                            
                                                    If FirstDrawFlag = 0 Then
                                    
                                                        Call DrawPlots(Seq1, Seq2, Seq3)
                                    
                                                        FirstDrawFlag = 1
                                                    End If
                                    
                                                    If BE < EN Then
                                                        ProbX = 10 + Decompress(BE) * XFactor
                                                    Else
                                                        ProbX = 10
                                                    End If
                                                    'XPosDiff not calculated anymore
                                                    ProbY = PicHeight - (15 + XOverHomologyNum((OBE + ((oEN - OBE) / 2)), MedHomol - 1) * (PicHeight - 35))
                                                    ProbTest$ = ProbabilityXOver
                                                    Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)
                                    
                                                    If Pos > 0 Then
                                                        If SPF = 0 Then Call PrintProbability
                                                    Else
                                                        If SPF = 0 Then Call PrintProbabilityII
                                                    End If
                                                End If
                                                'beginning and ending breakpoint positions here
                                                
                                                EWarn = 0: BWarn = 0
                                                Split = 0
                                                If LongWindedFlag = 1 Then
                                                    
                                                    
                                                    
                                                    If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                                        AD = Seq1
                                                        AMa = Seq2
                                                        AMi = Seq3
                                                       
                                                    ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                                        AD = Seq2
                                                        AMa = Seq1
                                                        AMi = Seq3
                                                      
                                                        
                                                    ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                                        AD = Seq3
                                                        AMa = Seq1
                                                        AMi = Seq2
                                                       
                                                        
                                                    ElseIf StoreLPV(0, Seq1) >= StoreLPV(0, Seq2) And StoreLPV(0, Seq1) >= StoreLPV(0, Seq3) Then
                                                        AD = Seq1
                                                        AMa = Seq2
                                                        AMi = Seq3
                                                    ElseIf StoreLPV(0, Seq2) >= StoreLPV(0, Seq1) And StoreLPV(0, Seq2) >= StoreLPV(0, Seq3) Then
                                                        AD = Seq2
                                                        AMa = Seq1
                                                        AMi = Seq3
                                                    ElseIf StoreLPV(0, Seq3) >= StoreLPV(0, Seq1) And StoreLPV(0, Seq3) >= StoreLPV(0, Seq2) Then
                                                        AD = Seq3
                                                        AMa = Seq1
                                                        AMi = Seq2
                                                    End If
                                                    
                                                    'If ReassortmentFlag = 0 Then
                                                        'check to see if an event has been extended accross a tract of
                                                        'missing data
                                                        'xposdiff isnt calculated anymore
                                                        If XDiffPos(BE) > 0 Then
                                                            BEE = XDiffPos(OBE - 1)
                                                        Else
                                                            BEE = BE
                                                        End If
                    '
                                                        
                                                        If XDiffPos(EN) < SLen Then
                                                            ENN = XDiffPos(oEN + 1)
                                                        Else
                                                            ENN = EN
                                                        End If
                                                        If ENN < EN Then ENN = EN
                                                        If BEE < 1 Then BEE = SLen
                                                        If ENN > SLen Then ENN = 1
                                                        
                                                        If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                                            BWarn = 0: EWarn = 0
                                                            Split = 0
                                                            '
                                                            If BEE <> BE Then
                                                            Z = CheckSplit2(2, SLen, BEE, BE, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                                            End If
                                                            If Split = 1 Then BWarn = 1
                                                            Split = 0
                                                            '@
                                                            If EN <> ENN Then
                                                                Z = CheckSplit2(2, SLen, EN, ENN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                                            End If
                                                            If Split = 1 Then EWarn = 1
                                                            Split = 0
                                                            Z = CheckSplit2(10, SLen, BE, EN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                                           
                                                        End If
                    '                                Else
                    '                                    Split = 0
                    '                                End If
                                                End If
                                                
                                                
                                                If Split = 1 Then
                                                    If XPDDone = 0 Then
                                                        XPDDone = 1
                                                        Dummy = MakeXPD2(LenXoverSeq, XDiffPos(0), XPosDiff(0))
                                                       
                                                    End If
                                                    'go back and recalculate the p-value between be and Z
                                                    For A = 0 To 1
                                                        NCommon = 0
                                                        XOverLen = 0
                                                        If A = 0 Then
                                                            BTarget = BE
                                                            If BE = Z Then Z = Z + 1
                                                            'Find point in the variable site subsequence that is immediately before BE
                                                            If XPosDiff(Z) > 0 Then
                                                                ETarget = XDiffPos(XPosDiff(Z) - 1)
                                                            Else
                                                                ETarget = SLen
                                                            End If
                                                        Else
                                                            b = FindMissing(SLen, Seq1, Seq2, Seq3, Z, EN, MissingData(0, 0))
                                                            If EN = b Then
                                                                BTarget = EN - 1
                                                                ETarget = EN
                                                            Else
                                                        '        XX = LenXoverSeq
                                                                If XPosDiff(b) + 1 < LenXoverSeq And (XDiffPos(XPosDiff(b) + 1) > b Or XDiffPos(XPosDiff(b) + 1) < EN) Then
                                                                    BTarget = XDiffPos(XPosDiff(b) + 1)
                                                                Else
                                                                    
                                                                    Do
                                                                        If SeqNum(b, Seq1) <> 46 And SeqNum(b, Seq2) <> 46 And SeqNum(b, Seq3) <> 46 Then
                                                                            If SeqNum(b, Seq1) <> SeqNum(b, Seq2) Or SeqNum(b, Seq1) <> SeqNum(b, Seq3) Then
                                                                                Exit Do
                                                                            End If
                                                                        End If
                                                                        b = b + 1
                                                                        If b = EN Then b = b + 1: Exit Do
                                                                        If b > SLen Then b = 1
                                                                    Loop
                                                                    If b > SLen Then
                                                                        b = 1
                                                                    End If
                                                                    BTarget = b
                                                                End If
                                                                ETarget = EN
                                                            End If
                                                        End If
                                                        
                                                        NumDifferent = SplitEvent(XoverWindow, SLen, LenXoverSeq, SeqDaughter, SeqMinorP, BTarget, ETarget, XOverLength, NCommon, XPosDiff(0), XoverSeqNumW(0, 0))
                                                        
                                                        x = XPosDiff(ETarget) + 1
                                                        
                                                        If XOverLength > 2 Then
                                                            
                                                            If XOverLength >= 170 Then
                                                                AFact = XOverLength / 169
                                                                NumDiff = CLng(NumDifferent * 169 / XOverLength)
                                                                XOL = 169
                                                                NumSame = XOL - NumDiff
                                                            Else
                                                                '
                                                                XOL = XOverLength
                                                                NumDiff = NumDifferent
                                                                AFact = 1
                                                                NumSame = XOL - NumDiff
                                                            End If
                                                            'C routine that calculates the probability of the recomination signal having arisen through mutation.
                                                            '
                                                            If XOverLength <= UBFact3x3 Then
                                                                ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOL, NumSame, IndProb, LenXoverSeq)
                                                                
                                                            Else
                                                                ProbabilityXOver = ProbCalcP(Fact(0), XOL, NumSame, IndProb, LenXoverSeq)
                                                            End If
                                                            
                                                            If ProbabilityXOver > 1 Then
                                                                ProbabilityXOver = 1
                                                            End If
                                                    
                                                        Else
                                                            ProbabilityXOver = 1
                                                        End If
                                                        
                                                        If ProbabilityXOver < 10 ^ -300 Then
                                                            ProbabilityXOver = 10 ^ -300
                                                        End If
                                                        
                                                        If MCFlag = 0 Then
                                                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                                                        End If
                                                        
                                                        If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                                            
                                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            Call ProcessEvent(0, ProbabilityXOver, BTarget, ETarget, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            If ShortOutFlag = 1 Then
                                                                ShortOutput(0) = 1
                                                                AbortFlag = 1
                                                                If NeedToClean = 1 Then
                                                                    Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
                                                                End If
                                                                Exit Sub
                                                            End If
                                                            If ShortOutFlag = 50 Then ShortOutput(0) = 1
                                                        End If
                                                    Next A
                                                Else
                                                    'If BE = 8129 And EN = 8440 Then
                                                    '        XX = SEventNumber
                                                    '        XX = Seq1 '21,1,9
                                                    '        XX = Seq2
                                                    '        XX = Seq3
                                                    '        '0,19,23,25
                                                    '    End If
                                                    'If Seq2 = 3 And Seq3 = 6 Then
                                                    '    X = X
                                                    'End If
                                                
                                                    If APermFlag = 0 Then
                                                        Call UpdateXOList3(AD, CurrentXOver(), XoverList(), 0, ProbabilityXOver, SIP)
                                                    Else
                                                        SIP = 1
                                                    End If
                                                    
                                                    
                                                    If MCFlag = 2 Then
                                                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                                        End If
                                                    End If
                                                    
                                                    oRecombNo(100) = oRecombNo(100) + 1
                                                    oRecombNo(0) = oRecombNo(0) + 1
                                                    NewOneFound = 1
                                                    ActualFound = 1
                                                    If SIP > 0 Then
                                                        'XOverlist(AD, CurrentXOver(AD)).lholder = NCommon
                                                        
                                                        'If ReassortmentFlag = 0 Then
                                                        If XPDDone = 0 Then
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            Call CentreBP(OBE, oEN, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                        Else
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                        End If
                                                        'End If
                                                       
                                                        If AD > UBound(XoverList, 1) Then
                                                            If NeedToClean = 1 Then
                                                                Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
                                                            End If
                                                            Exit Sub
                                                        End If
                                                        
                                                        
                                                        '93,12:93,4:93,2:70,9:
                                                        XoverList(AD, SIP).Beginning = BE '2839-65 (111,1)
                                                        XoverList(AD, SIP).Ending = EN
                                                        XoverList(AD, SIP).MajorP = AMa
                                                        XoverList(AD, SIP).MinorP = AMi
                                                        XoverList(AD, SIP).Daughter = AD
                                                        XoverList(AD, SIP).ProgramFlag = 0
                                                        XoverList(AD, SIP).DHolder = 0
                                                        XoverList(AD, SIP).Probability = ProbabilityXOver
                                                       
                         
                                                        
                                    
                
                
                                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                                            StartPlt(0) = 1
                                                            Call UpdatePlotB(AD, AMa, AMi, SIP)
                                                                
                                                        End If
                                                        'If ReassortmentFlag = 0 Then
                                                            If SEventNumber > 0 Then
                                                                If XPDDone = 0 Then
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                    If EWarn = 0 Then Call CheckEndsVB(OBE, oEN, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                                    If BWarn = 0 Then Call CheckEndsVB(OBE, oEN, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                Else
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                    If EWarn = 0 Then Call CheckEndsVB(0, 0, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                                    If BWarn = 0 Then Call CheckEndsVB(0, 0, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                End If
                                                            End If
                                                            If BWarn = 1 And EWarn = 1 Then
                                                                XoverList(AD, SIP).SBPFlag = 3
                                                            ElseIf BWarn = 1 Then
                                                                XoverList(AD, SIP).SBPFlag = 1
                                                            ElseIf EWarn = 1 Then
                                                                XoverList(AD, SIP).SBPFlag = 2
                                                            End If
                                                        'End If
                                                        
                                                                
                                                        If ShortOutFlag = 1 Then
                                                            ShortOutput(0) = 1
                                                            AbortFlag = 1
                                                            If NeedToClean = 1 Then
                                                                Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
                                                            End If
                                                            Exit Sub
                                                        End If
                                                        If ShortOutFlag = 50 Then ShortOutput(0) = 1
                                                        'Do shortend distance calculation here?
                                                                
                                                        
                                                    ElseIf DoneRedo = 0 Then
                                                        DoneRedo = 1
                                                        Call AddToRedoList(0, Seq1, Seq2, Seq3)
                                                        
                                                        
                                                    End If
                                                End If
                                            
                                            End If
                                        
                                        'End If
                                    End If
                                ElseIf APermFlag = 1 Then
                                    If ProbabilityXOver > 0 And (ProbabilityXOver < BestPermP(CPermNo, 0) Or BestPermP(CPermNo, 0) = 0) Then
                                        BestPermP(CPermNo, 0) = ProbabilityXOver
                                    End If
                                End If
                            '''''''4
                            End If
                            
                            
                        End If
                        ''''''
                    
                    End If
                    ''''''''''
                End If
                
                '1.923
                '@
                If EndFlag = 1 Then
                    EndFlag = 0
                    x = LenXoverSeq
                End If
                '@'@'@'@'@
                If (x < LenXoverSeq + 1 And x > NextPosX) Then 'Or ReassortmentFlag = 1 Then
                    NextPosX = x + 1
                    
                Else
                    Exit Do
                End If
                
                '5.719 1K perms
                
            Else
                Exit Do
            End If
        Loop
        '3.895
        
        
        
        If FindCycle = 0 Then
            '@
            Temp = MedHomol
            MedHomol = LowHomol
            LowHomol = Temp
        ElseIf FindCycle = 1 Then
            'Exit Sub
            '5.027
            '@'@
            If AvHomol(HighHomol) < 0.7 Or DoAllFlag = 1 Then
                Temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = Temp
            Else
                Exit Do
            End If

        Else
            Exit Do
        End If
        '@'@
        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        End If
        
        FindCycle = FindCycle + 1
        
        'Exit Sub
    Loop
    'Exit Sub
        '10.359 1K perms
    If NeedToClean = 1 Then
        '@'@
         Dummy = CleanXOSNW(LenXoverSeq + XoverWindow * 2, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
     End If
End Sub
Public Sub XOverIV(SeqNum() As Integer, Seq1 As Long, Seq2 As Long, Seq3 As Long, DoAllFlag)

'If Seq1 = 0 And Seq2 = 1 Or Seq3 = 5 Then
'    XX = XX
'End If
Dim SIP As Long, XOverLen As Long, A As Long, ENN As Long, BEE As Long, SPF As Byte, Dummy As Variant, MCC As Long, FF As Long, oDir As String, UB As Long, OldX As Long
Dim XPDDone As Byte
    XPDDone = 0
    
    XX = UBound(Distance, 1)
    XX = UBound(TreeDistance, 1)
'


'If QvRFlag = 1 Then
'    If ReferenceList(Seq1) = 0 Then
'        If ReferenceList(Seq2) > 0 And ReferenceList(Seq3) > 0 Then
'            If ReferenceList(Seq2) = ReferenceList(Seq3) Then
'                Exit Sub
'            End If
'        Else
'            Exit Sub
'        End If
'    ElseIf ReferenceList(Seq2) = 0 Then
'        If ReferenceList(Seq1) > 0 And ReferenceList(Seq3) > 0 Then
'            If ReferenceList(Seq1) = ReferenceList(Seq3) Then
'                Exit Sub
'            End If
'        Else
'            Exit Sub
'        End If
'    ElseIf ReferenceList(Seq3) = 0 Then
'        If ReferenceList(Seq1) > 0 And ReferenceList(Seq2) > 0 Then
'            If ReferenceList(Seq1) = ReferenceList(Seq2) Then
'                Exit Sub
'            End If
'        Else
'            Exit Sub
'        End If
'    Else
'        Exit Sub
'    End If
'End If

If SelGrpFlag > 0 Then
    Dim GrpTest As Long
    GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
    If GrpTest < 2 Then
        Exit Sub
    End If
End If
    '0.343 - 1K perms
    Dim AFact As Double, BWarn As Byte, EWarn As Byte, DoneRedo As Byte, b As Long, BTarget As Long, ETarget As Long, Split As Long, AD As Long, AMi As Long, AMa As Long, BE As Long, EN As Long, NCommon As Long, StartPosX As Long
    Dim NextPosX As Long
    Dim oProbXOver As Double, Inlyer As Integer
    Dim FindCycle As Integer, Store As Long, Storex As Long, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, SeqDaughter As Long, SeqMinorP As Long, Temp As Integer, EndFlag As Long, HighHomol As Long, MedHomol As Long, LowHomol As Long
    Dim DA As Long, Ma As Long, Mi  As Long, x As Long, NumDifferent As Long, Z As Long
    
    Dim SLen As Long, AmaTot As Double, AmiTot As Double, ATot As Double
    Dim AH(2) As Long
    DoneRedo = 0
    
    
    SLen = Len(StrainSeq(0))
    

    Dim RDProportionflag As Byte
    'RDProportionflag = 1
    'If RDProportionflag = 1 Then
    '    If PermDiffs(Seq1, Seq2) > PermDiffs(Seq1, Seq3) And PermDiffs(Seq1, Seq2) > PermDiffs(Seq2, Seq3) Then
    '        XOverWindow = CLng(PermDiffs(Seq1, Seq2) * 0.66)
    '    ElseIf PermDiffs(Seq1, Seq3) > PermDiffs(Seq2, Seq3) Then
    '        XOverWindow = CLng(PermDiffs(Seq1, Seq3) * 0.66)
    '    Else
    '        XOverWindow = CLng(PermDiffs(Seq2, Seq3) * 0.66)
    '    End If
    'Else
    '    XOverWindow = Int(XOverWindowX / 2)
    'End If
    FirstDrawFlag = 0
    
    'Find reference sequences (takes 0.3/21)
    If SpacerFlag > 0 Then
        If SpacerFlag < 4 Then
            UB = UBound(TreeDistance, 1)
            
            If SEventNumber > 0 Then
                
                If UBound(ValidSpacer, 1) < UB Then
                    ReDim Preserve ValidSpacer(UB)
                End If
                If UBound(SpacerSeqs, 1) < UB Then
                    ReDim Preserve SpacerSeqs(UB)
                End If
                If UBound(MaskSeq, 1) < UB Then
                    ReDim Preserve MaskSeq(UB)
                End If
            End If
'            If DebuggingFlag < 2 Then On Error Resume Next
'            UB = 0
'            UB = UBound(TreeDistance, 1)
'
'
'            On Error GoTo 0
'

            InRangeFlag = SpacerFindB(UB, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNo, TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqs(0), ValidSpacer(0))
            
'            If PermNextno > LowMemThreshold Then
'                Erase Distance
'            End If
            
            If InRangeFlag = 0 Then Exit Sub
        ElseIf SpacerFlag = 4 Then
            SpacerNo = 1
            SpacerSeqs(1) = Spacer4No
        End If
    
    
    
        'Find Information rich subsequences (takes 11/21)
    
        If SpacerNo = 0 Then
            Exit Sub
        End If
        'C routine for finding information rich subsequences (it does the same thing as the
        'VB routine FindSubSeqX)
        'This could be speeded up with better nesting
        
            LenXoverSeq = FindSubSeqP4(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0), BinArray(0, 0))
            
            
            
            XPDDone = 1
            'LenXOverSeq = FindSubSeqP6(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), ValidSpacer(0), BinArray(0, 0))
            'LenXOverSeq = FindSubSeqP7(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), ValidSpacer(0), BinArray(0, 0))


    Else
        '
'        If SEventNumber = 0 And X = X Then
''           Dim Xoverseqnumw2() As Byte, XDiffPos2() As Long, xposdiff2() As Long
''            ReDim Xoverseqnumw2(Len(StrainSeq(0)) + XoverWindow * 2, 2)
''            ReDim XDiffPos2(Len(StrainSeq(0))), xposdiff2(Len(StrainSeq(0)))
''            If UBound(CompressedSeqs3, 2) <> Nextno Then
''            XX = UBound(CompressedSeqs3, 1)
''                Call MakeIntegerSeq3
''            End If
'            If X = 12345 Then
'                LenXOverSeq = FindSubSeqP2(UBound(XoverSeqNumW, 1), 125, UBound(CompressedSeqs3, 1), XoverWindow, Len(StrainSeq(0)), Seq1, Seq2, Seq3, AH(0), CompressedSeqs3(0, 0), XoverSeqNumW(0, 0), XDiffPos(0), XPosDiff(0), SkipTrip(0, 0, 0), FindSS0(0, 0, 0, 0))
'            Else
'                LenXOverSeq = FindSubSeqPVB(XoverWindow, Seq1, Seq2, Seq3, XoverSeqNumW(), AH(), XDiffPos(), XPosDiff())
'            End If
''            For X = 0 To LenXOverSeq
''                If XDiffPos(X) <> XDiffPos2(X) Then
''                    X = X
''                End If
''                If XPosDiff(X) <> xposdiff2(X) Then
''                    X = X
''                End If
''                For Y = 0 To 2
''                    If Xoverseqnumw2(X, 0) <> XoverSeqNumW(X, 0) Then '(2,0)
''                        X = X
''                    End If
''                Next Y
''            Next X
''            X = X
'            '1645
''            If Seq1 = 8 And Seq2 = 16 And Seq3 = 19 Then
''            X = X
''        End If
'            '3843,3849,3855,3809,3649,3649
'           ''
'        'find the variable site string
'        'If X = X Then
'        '    LenXOverSeq = FindSubSeqFaster(UBound(Iseq4, 1), AH(0), SpacerFlag, Outlyer, XOverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XOverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0), Iseq4(0, 0))
'       '
'        Else
            '
'             Dim Xoverseqnumw2() As Byte, XDiffPos2() As Long, xposdiff2() As Long
'            ReDim Xoverseqnumw2(Len(StrainSeq(0)) + XoverWindow * 2, 2)
'            ReDim XDiffPos2(Len(StrainSeq(0))), xposdiff2(Len(StrainSeq(0)))
            'LenXOverSeq = FindSubSeqP2(UBound(XoverSeqNumW, 1), 125, UBound(CompressedSeqs3, 1), XoverWindow, Len(StrainSeq(0)), Seq1, Seq2, Seq3, AH(0), CompressedSeqs3(0, 0), Xoverseqnumw2(0, 0), XDiffPos2(0), xposdiff2(0), SkipTrip(0, 0, 0), FindSS0(0, 0, 0, 0))
            'LenXOverSeq = FindSubSeqPVB(XoverWindow, Seq1, Seq2, Seq3, Xoverseqnumw2(), AH(), XDiffPos2(), xposdiff2())
            'LenXOverSeq = FindSubSeqP2(UBound(XoverSeqNumW, 1), 125, UBound(CompressedSeqs3, 1), XoverWindow, Len(StrainSeq(0)), Seq1, Seq2, Seq3, AH(0), CompressedSeqs3(0, 0), Xoverseqnumw2(0, 0), XDiffPos2(0), xposdiff2(0), SkipTrip(0, 0, 0), FindSS0(0, 0, 0, 0))
            
            'LenXOverSeq = FindSubSeqP9(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0), BinArray(0, 0), XPD2(0), XPD3(0), XPD4(0), XDP2(0), XDP3(0), XDP4(0), XSN2(0, 0), XSN3(0, 0), XSN4(0, 0), BinA2(0, 0), BinA3(0, 0), BinA4(0, 0))
            LenXoverSeq = FindSubSeqP4(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0), BinArray(0, 0))
            'LenXOverSeq = FindSubSeqP10(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0), BinArray(0, 0), BinArray2(0, 0))
            'Exit Sub
            '3843
'            X = X
'            XX = XDiffPos(2)
'
'            XX = AH(0) '1177,1199,1227
'            XX = AH(1) '1501,1530,1508
'            XX = AH(2) '1165,1120,1120
'            XX = (LenStrainSeq / 4)
'            XX = XPosDiff(2397) '1041
'            XX = XPosDiff(2398) '1042
'            XX = XDiffPos(1041) '2398
'            XX = XDiffPos(1042) '2404
'If Seq1 = 0 And Seq2 = 1 And Seq3 = 2 Then
'    X = X
'
'            Open "coords4.csv" For Append As #1
''''            For Y = 0 To 2
'            For X = 0 To Len(StrainSeq(0))
'''                Out$ = Str(XPosDiff(X))
''
''
''                    Print #1, XoverSeqNumW(X, 0)
'
'                'Print #1, XPosDiff(X)
'
'
'            Next X
'''            Next Y
''''
'             Print #1, LenXOverSeq
'                Print #1, AH(0)
'                Print #1, AH(1)
'                Print #1, AH(2)
'            Close #1
'''Exit Sub
''End If
'            XPDDOne = 1
            'LenXOverSeq = FindSubSeqP7(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), ValidSpacer(0), BinArray(0, 0))
            'LenXOverSeq = FindSubSeqP6(AH(0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, SpacerNo, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), ValidSpacer(0), BinArray(0, 0))

'        For X = 0 To LenXOverSeq
'                If XDiffPos(X) <> XDiffPos2(X) Then
'                    X = X
'                End If
'                If XPosDiff(X) <> xposdiff2(X) Then
'                    X = X
'                End If
'                For Y = 0 To 2
'                    If Xoverseqnumw2(X, 0) <> XoverSeqNumW(X, 0) Then '(2,0)
'                        X = X
'                    End If
'                Next Y
'            Next X
        'End If
'            For X = 0 To LenXOverSeq
'                For Y = 0 To 2
'                    If Xoverseqnumw2(X, Y) <> XoverSeqNumW(X, Y) Then '(2,0)
'                        X = X
'                    End If
'                Next Y
'            Next X
        
'        End If
'            X = X
        
    End If
    
    
    'XX = CircularFlag
    '2.625,2.610
    
    If LenXoverSeq < XoverWindow * 2 Then
        Exit Sub
    End If
    
    If AH(0) < XoverWindow / 3 Or AH(1) < XoverWindow / 3 Or AH(2) < XoverWindow / 3 Then
        Exit Sub
    End If
    If AH(0) = 0 Or AH(1) = 0 Or AH(2) = 0 Then
        Exit Sub
    End If
    AvHomol(1) = (AH(0) / LenXoverSeq)
    AvHomol(2) = (AH(1) / LenXoverSeq)
    AvHomol(3) = (AH(2) / LenXoverSeq)
    
    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000 '0.3088
    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000 '0.4847
    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000 '0.2065
    
    If MCFlag = 0 Then
        MCC = MCCorrection
    Else
        MCC = 1
    End If
    'For X = 1 To 34
    '    For Y = 0 To 34
    '        For Z = 0 To 10
    '            If BinTable(X, Y, Z) > 0 And BinTable(X, Y, Z) < 1 Then
    '                X = X
    '            End If
    '
    '        Next Z
    '    Next Y
    'Next X
    
    '1.542
    
    'If SEventNumber = 2 Then
    '    If Seq1 = 20 Or Seq1 = 9 Or Seq1 = 4 Then
    '    If Seq2 = 20 Or Seq2 = 9 Or Seq2 = 4 Then
    '    If Seq3 = 20 Or Seq3 = 9 Or Seq3 = 4 Then
    '        X = X '152,28,0.3088,1045
    '        '152,18,0.3088,1045
    '        '150,17,0.3088,1045
    '    End If
    '    End If
    '    End If
    'End If
    
    
    
    
    
    
    LenXoverSeq = Abs(LenXoverSeq) - 1 '875
    
'    If DebuggingFlag < 2 Then On Error Resume Next
'    UB = 0
'    UB = UBound(TreeDistance, 1)
'
'
'    On Error GoTo 0
'
'    If UB = 0 Then
'        'it'll probably be much quicker to just load the individual distances
'        odir = CurDir
'        ChDir App.Path
'        ChDrive App.Path
'
'        ReDim Distance(PermNextno, PermNextno), TreeDistance(PermNextno, PermNextno)
'        FF = FreeFile
'
'        Open "RDP5Distance" + UFTag For Binary As #FF
'        Get #FF, , Distance()
'        Close #FF
'        Open "RDP5TreeDistance" + UFTag For Binary As #FF
'        Get #FF, , TreeDistance()
'        Close #FF
'        ChDir odir
'        ChDrive odir
'    End If

    
    'Work out identities (7.1/21)
    '
    If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 1
    ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
        HighHomol = 2
    ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
        HighHomol = 3
    End If
    

    
    
    
    ' ReDim XOverHomologyNum(LenXOverSeq + XoverWindow * 2, 2)
    
    'C Routine to work out moving identity averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    
    '
    
    'Exit Sub
    StartPosX = XOHomologyP(HighHomol, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
    'Exit Sub
    'Exit Sub
    'If Seq1 = 1 And Seq2 = 2 And Seq3 = 3 Then
'        Open "xol4.csv" For Append As #1
'         Print #1, " "
'         Print #1, Seq1
'        Print #1, Seq2
'        Print #1, Seq3
'        For X = 0 To 20
'            For Y = 0 To 2
'                Print #1, XOverHomologyNum(X, Y)
'            Next Y
'        Next X
'        Close #1
'        X = X
    'End If
    If StartPosX = 0 And ShortOutFlag <> 3 Then Exit Sub
    'End If
    '1.883
    
'    If PermNextno > LowMemThreshold Then
'        ODir = CurDir
'        ChDir App.Path
'        ChDrive App.Path
'        ReDim Distance(PermNextno, PermNextno)
'        FF = FreeFile
'
'        Open "RDP5Distance" For Binary As #FF
'        Get #FF, , Distance()
'        Close #FF
'
'        ChDir ODir
'        ChDrive ODir
'    End If
    If Seq1 <= UBound(Distance, 1) And Seq2 <= UBound(Distance, 1) And Seq3 <= UBound(Distance, 1) Then
        If AvHomol(1) = AvHomol(2) And AvHomol(1) = AvHomol(3) Then
            If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                    AvHomol(2) = AvHomol(2) - 0.00001
                    AvHomol(3) = AvHomol(3) - 0.00002
                Else
                    AvHomol(2) = AvHomol(2) - 0.00002
                    AvHomol(3) = AvHomol(3) - 0.00001
                End If
            ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                    AvHomol(1) = AvHomol(1) - 0.00001
                    AvHomol(3) = AvHomol(3) - 0.00002
                Else
                    AvHomol(1) = AvHomol(1) - 0.00002
                    AvHomol(3) = AvHomol(3) - 0.00001
                End If
            Else
                If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                    AvHomol(1) = AvHomol(1) - 0.00001
                    AvHomol(2) = AvHomol(2) - 0.00002
                Else
                    AvHomol(1) = AvHomol(1) - 0.00002
                    AvHomol(2) = AvHomol(2) - 0.00001
                End If
            End If
        ElseIf AvHomol(1) = AvHomol(2) Then
            If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                AvHomol(2) = AvHomol(2) - 0.00001
            Else
                AvHomol(1) = AvHomol(1) - 0.00001
            End If
        ElseIf AvHomol(1) = AvHomol(3) Then
            If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                AvHomol(3) = AvHomol(3) - 0.00001
            Else
                AvHomol(1) = AvHomol(1) - 0.00001
            End If
        ElseIf AvHomol(2) = AvHomol(3) Then
            If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                AvHomol(3) = AvHomol(3) - 0.00001
            Else
                AvHomol(2) = AvHomol(2) - 0.00001
            End If
        End If
    
    End If
    'If PermNextno > LowMemThreshold Then
    '    Erase Distance
    'End If
    
    
    '2.142
    
    
    
    If AvHomol(1) >= AvHomol(2) And AvHomol(1) >= AvHomol(3) Then
        HighHomol = 1

        If AvHomol(2) >= AvHomol(3) Then
            MedHomol = 2: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        
        Else 'If AvHomol(3) > AvHomol(2) Then
            MedHomol = 3: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(3) Then
        HighHomol = 2

        If AvHomol(1) >= AvHomol(3) Then
            MedHomol = 1: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        Else 'If AvHomol(3) > AvHomol(1) Then
            MedHomol = 3: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(3) >= AvHomol(1) And AvHomol(3) >= AvHomol(2) Then
        HighHomol = 3

        If AvHomol(1) >= AvHomol(2) Then
            MedHomol = 1: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        Else 'If AvHomol(2) > AvHomol(1) Then
            MedHomol = 2: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        'Else
        '    Exit Sub
        End If

    End If
 
 

   
   '1.823
    FindCycle = 0
    
    'XX = Seq1: XX = Seq2: XX = Seq3
    'Exit Sub
    
    OldX = -1
    Dim AVal As Long, TC As Long
    AVal = 1
    Dim UBXOHN As Long, g As Long
    UBXOHN = UBound(XOverHomologyNum, 1)
    'Exit Sub
    Do
        '
        NextPosX = 1 'StartPosX
        Storex = 0
        
        Do
            
            
                'This could be speeded up a bit
                
                x = FindNextP(UBXOHN, NextPosX, HighHomol, MedHomol, LowHomol, LenXoverSeq, XoverWindow, XOverHomologyNum(0, 0))
              
                
            
            If x > -1 And x <> OldX Then
                OldX = x
                '5.078 - 1K perms
                '
                If CircularFlag = 1 And XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, HighHomol - 1) And x = 1 Then 'And ReassortmentFlag = 0 Then
                    'If X = X Then
                    
                        x = FindFirstCOP(x, MedHomol, HighHomol, LenXoverSeq, UBXOHN, XOverHomologyNum(0, 0))
                    'Else
                        
'                        Do Until XOverHomologyNum(X, MedHomol - 1) <= XOverHomologyNum(X, HighHomol - 1)
'                            X = X + 1
'                        Loop
'                        If XOverHomologyNum(LenXOverSeq, MedHomol - 1) <= XOverHomologyNum(LenXOverSeq, HighHomol - 1) Then
'                            XOverHomologyNum(LenXOverSeq, MedHomol - 1) = XOverHomologyNum(1, MedHomol - 1)
'                            XOverHomologyNum(LenXOverSeq, HighHomol - 1) = XOverHomologyNum(1, HighHomol - 1)
'                        End If
'                    End If
                Else
                    NCommon = 0
                    XOverLength = 0
                    'If ReassortmentFlag = 0 Then
                        '
                        x = DefineEventP2(UBXOHN, ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, x, XoverWindow, SLen, LenXoverSeq, SeqMinorP, SeqDaughter, EndFlag, BE, EN, NCommon, XOverLength, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
  
                      
                        
'                    Else
'                        'ncommon
'                        'endflag
'                        'xoverlength
'                        AVal = AVal + 1
'                        EN = RBPPos(AVal)
'                        X = XPosDiff(RBPPos(AVal))
'                        XOverLength = X - OldX + 1
'                        If (SeqDaughter = 0 And SeqMinorP = 1) Or (SeqDaughter = 1 And SeqMinorP = 0) Then
'                            TC = 0
'                        ElseIf (SeqDaughter = 0 And SeqMinorP = 2) Or (SeqDaughter = 2 And SeqMinorP = 0) Then
'                            TC = 1
'                        Else
'                            TC = 2
'                        End If
'
'
'                        'convert this code into c++
'                        NCommon = 0
'                        For Y = OldX To X
'                            If XOverSeqNumW(Y, TC) = 1 Then
'                                NCommon = NCommon + 1
'                            End If
'
'                        Next Y
'                        OldX = -1
'                    End If
                    
                    '
                    NumDifferent = XOverLength - NCommon
                    
                    IndProb = AvHomol(MedHomol)
                    
                    'Uncommenting this code uses the bintable - it reduces the number of probxover tests BUT not enough to make a difference
                    
                    '2.183
                    'If Int(indprob * 100) + 1 <= 100 Then
                    '    ip = Int(indprob * 100) + 1
                    'Else
                    '    ip = 100
                    'End If
                    'Dim GoOnXX As Byte
                    'GoOnXX = 1
                    'If Int(XOverLength / 5) + 1 <= 34 And (Int(NCommon / 5) + 1) <= 34 Then
                    '    If BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) > 0.05 Then
                    '
                    '        GoOnXX = 0
                    '    End If
                    'End If
                    'GoOnXX = 1 ' 0.5 cutoff 40 seconds = 1 reassortment
                    If XOverLength > 2 Then ' And GoOnXX = 1 Then ' And BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) < 0.5 Then
                        If XOverLength >= 170 Then
                            AFact = XOverLength / 169
                            NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                            XOverLength = 169
                        Else
                            AFact = 1
                        End If
                        'C routine that calculates the "probability" of the "recomination signal" having occured by chance mutation without recombination.
                        'ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)
                        '
                        '169,6,16
                        If ProbEstimate(XOverLength, XOverLength - NumDifferent, Int(IndProb * 50)) < LowestProb Then
                            '
                            If XOverLength <= UBFact3x3 Then
                                
                                ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)

                                
                            Else
                                ProbabilityXOver = ProbCalcP(Fact(0), XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                            End If
                        Else
                          ProbabilityXOver = 2
                        End If
                        '1.25 (10.21) 1.32 probcalc
                        '1.14 (10.02) 1.17 probcalcp
                       ' If Int(XOverLength / 5) + 1 And (Int(NCommon / 5) + 1) <= 34 Then
                       '     If ProbabilityXOver < 0.05 And BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) > 0.05 Then
                       '         X = X
                       '     End If
                       ' End If
                        
                        'XX = QvRFlag
                        If ProbabilityXOver > 1 Then
                            ProbabilityXOver = 1
                        End If
                                
                        'ProbabilityXOver = ProbCalc(Fact(0), 10, 10 - 1, 0.0001, LenXoverSeq)
                        If AFact <> 1 Then
                            If ProbabilityXOver > 0 Then
                                
                                
                                ProbabilityXOver = ProbabilityXOver ^ AFact
                                
                            'X = X
                            Else
                                ProbabilityXOver = 0.05
                            End If
                        End If
                        'End If
                        
                     
                    Else
                        ProbabilityXOver = 1
                    End If
                    
                    If APermFlag = 1 Then
                        If ProbabilityXOver > 0 And (ProbabilityXOver < BestPermP(CPermNo, 0) Or BestPermP(CPermNo, 0) = 0) Then
                            BestPermP(CPermNo, 0) = ProbabilityXOver
                        End If
                    Else
                        oProbXOver = ProbabilityXOver
                        If MCFlag = 0 Then
                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                        End If
                                              
                        
                        
                        If EN = BE Then
                            ProbabilityXOver = 1
                        ElseIf EN < BE And CircularFlag = 0 Then
                            ProbabilityXOver = 1
                        End If
                               
                        
                        '
                        If ShortOutFlag = 3 Then
                            If ProbabilityXOver <= mtP(0) Then
                                mtP(0) = ProbabilityXOver
                            End If
                        End If
                        
                        '2.323
                        
                        
                        
                        If (ProbabilityXOver < LowestProb Or oProbXOver < CritPVals(0)) And ProbabilityXOver > 0 And ProbabilityXOver <> 1 Then
                        
                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                        'need to determin xdiffpos/xposdiff here
                        'need to convert BE and EN to full sequence versions
                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                            Dim oEN As Long, OBE As Long
                            oEN = EN
                            OBE = BE
                            
                            If CircularFlag = 0 Then
                                If BE = 1 Then
                                    If XDiffPos(BE) < TargetX Then
                                        BE = 1
                                        OBE = 1
                                    Else
                                        BE = XDiffPos(BE)
                                    End If
                                
                                Else
                                    BE = XDiffPos(BE)
                                End If
                            
                            Else
                                BE = XDiffPos(BE)
                            End If
                            
                            
                            If EN = LenXoverSeq And CircularFlag = 0 Then
                                If ShortOutFlag = 0 Or ShortOutFlag = 6 Or ShortOutFlag = 10 Then
                                    EN = Len(StrainSeq(0))
                                Else
                                    
                                    EN = XDiffPos(LenXoverSeq)
                                End If
                                oEN = LenXoverSeq
                    
                            Else
                                If EN >= LenXoverSeq Then
                                    If LongWindedFlag = 0 Then
                                        XDiffPos(EN) = 0
                                    Else
                                        EN = LenXoverSeq + 1
                                    End If
                    
                                ElseIf EN < 1 Then
                                    EN = LenXoverSeq + 1
                                    
                                End If
                                oEN = EN
                                EN = XDiffPos(EN)
                            End If
                    
                            
                            If EN = 0 Then
                    
                                If ShortOutFlag = 0 Or ShortOutFlag = 6 Or ShortOutFlag = 10 Then
                                    EN = Len(StrainSeq(0))
                                    
                                Else
                                    EN = XDiffPos(LenXoverSeq)
                                End If
                                oEN = LenXoverSeq
                            End If
                            
                           If ShowPlotFlag = 1 Then 'Draw plots if necessary
                        
            
                                If FirstDrawFlag = 0 Then
                
                                    Call DrawPlots(Seq1, Seq2, Seq3)
                
                                    FirstDrawFlag = 1
                                End If
                
                                If BE < EN Then
                                    ProbX = 10 + Decompress(BE) * XFactor
                                Else
                                    ProbX = 10
                                End If
                                'XPosDiff not calculated anymore
                                ProbY = PicHeight - (15 + XOverHomologyNum((OBE + ((oEN - OBE) / 2)), MedHomol - 1) * (PicHeight - 35))
                                ProbTest$ = ProbabilityXOver
                                Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)
                
                                If Pos > 0 Then
                                    If SPF = 0 Then Call PrintProbability
                                Else
                                    If SPF = 0 Then Call PrintProbabilityII
                                End If
                            End If
                        
                            '2.033
                            '
                            If ProbabilityXOver < LowestProb Then
                                
                                'beginning and ending breakpoint positions here
                                
                                EWarn = 0: BWarn = 0
                                Split = 0
                                If LongWindedFlag = 1 Then
                                    
                                    
                                    
                                    If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                        AD = Seq1
                                        AMa = Seq2
                                        AMi = Seq3
                                       
                                    ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                        AD = Seq2
                                        AMa = Seq1
                                        AMi = Seq3
                                      
                                        
                                    ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                        AD = Seq3
                                        AMa = Seq1
                                        AMi = Seq2
                                       
                                        
                                    ElseIf StoreLPV(0, Seq1) >= StoreLPV(0, Seq2) And StoreLPV(0, Seq1) >= StoreLPV(0, Seq3) Then
                                        AD = Seq1
                                        AMa = Seq2
                                        AMi = Seq3
                                    ElseIf StoreLPV(0, Seq2) >= StoreLPV(0, Seq1) And StoreLPV(0, Seq2) >= StoreLPV(0, Seq3) Then
                                        AD = Seq2
                                        AMa = Seq1
                                        AMi = Seq3
                                    ElseIf StoreLPV(0, Seq3) >= StoreLPV(0, Seq1) And StoreLPV(0, Seq3) >= StoreLPV(0, Seq2) Then
                                        AD = Seq3
                                        AMa = Seq1
                                        AMi = Seq2
                                    End If
                                    
                                    'If ReassortmentFlag = 0 Then
                                        'check to see if an event has been extended accross a tract of
                                        'missing data
                                        'xposdiff isnt calculated anymore
    '                                    If XPosDiff(BE) > 0 Then
    '                                        BEE = XDiffPos(XPosDiff(BE) - 1)
    '                                    Else
    '                                        BEE = BE
    '                                    End If
    '
                                        If XDiffPos(BE) > 0 Then
                                            BEE = XDiffPos(OBE - 1)
                                        Else
                                            BEE = BE
                                        End If
                    '
                                        If XDiffPos(EN) < SLen Then
                                            ENN = XDiffPos(oEN + 1)
                                        Else
                                            ENN = EN
                                        End If
                                        If ENN < EN Then ENN = EN
                                        If BEE < 1 Then BEE = SLen
                                        If ENN > SLen Then ENN = 1
                                        
                                        If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                            BWarn = 0: EWarn = 0
                                            Split = 0
                                            If BEE <> BE Then
                                                Z = CheckSplit2(2, SLen, BEE, BE, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                            End If
                                            If Split = 1 Then BWarn = 1
                                            Split = 0
                                            If EN <> ENN Then
                                                Z = CheckSplit2(2, SLen, EN, ENN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                            End If
                                            If Split = 1 Then EWarn = 1
                                            Split = 0
                                            
                                            Z = CheckSplit2(10, SLen, BE, EN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                           
                                        End If
    '                                Else
    '                                    Split = 0
    '                                End If
                                End If
                                
                                
                                If Split = 1 Then
                                    If XPDDone = 0 Then
                                        XPDDone = 1
                                        Dummy = MakeXPD2(LenXoverSeq, XDiffPos(0), XPosDiff(0))
                                        
                                    End If
                                    'go back and recalculate the p-value between be and Z
                                    For A = 0 To 1
                                        NCommon = 0
                                        XOverLen = 0
                                        If A = 0 Then
                                            BTarget = BE
                                            If BE = Z Then Z = Z + 1
                                            'Find point in the variable site subsequence that is immediately before BE
                                            If XPosDiff(Z) > 0 Then
                                                ETarget = XDiffPos(XPosDiff(Z) - 1)
                                            Else
                                                ETarget = SLen
                                            End If
                                        Else
                                            b = FindMissing(SLen, Seq1, Seq2, Seq3, Z, EN, MissingData(0, 0))
                                            If EN = b Then
                                                BTarget = EN - 1
                                                ETarget = EN
                                            Else
                                        '        XX = LenXoverSeq
                                                If XPosDiff(b) + 1 < LenXoverSeq And (XDiffPos(XPosDiff(b) + 1) > b Or XDiffPos(XPosDiff(b) + 1) < EN) Then
                                                    BTarget = XDiffPos(XPosDiff(b) + 1)
                                                Else
                                                    
                                                    Do
                                                        If SeqNum(b, Seq1) <> 46 And SeqNum(b, Seq2) <> 46 And SeqNum(b, Seq3) <> 46 Then
                                                            If SeqNum(b, Seq1) <> SeqNum(b, Seq2) Or SeqNum(b, Seq1) <> SeqNum(b, Seq3) Then
                                                                Exit Do
                                                            End If
                                                        End If
                                                        b = b + 1
                                                        If b = EN Then b = b + 1: Exit Do
                                                        If b > SLen Then b = 1
                                                    Loop
                                                    If b > SLen Then
                                                        b = 1
                                                    End If
                                                    BTarget = b
                                                End If
                                                ETarget = EN
                                            End If
                                        End If
                                        
                                        NumDifferent = SplitEvent(XoverWindow, SLen, LenXoverSeq, SeqDaughter, SeqMinorP, BTarget, ETarget, XOverLength, NCommon, XPosDiff(0), XoverSeqNumW(0, 0))
                                        
                                        x = XPosDiff(ETarget) + 1
                                        
                                        If XOverLength > 2 Then
                                            If XOverLength >= 170 Then
                                                NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                                                XOverLength = 169
                                            End If
                                            'C routine that calculates the probability of the recomination signal having arisen through mutation.
                                            '
                                            If XOverLength <= UBFact3x3 Then
                                                ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                                                
                                            Else
                                                ProbabilityXOver = ProbCalcP(Fact(0), XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                                            End If
                                            
                                            If ProbabilityXOver > 1 Then
                                                ProbabilityXOver = 1
                                            End If
                                    
                                        Else
                                            ProbabilityXOver = 1
                                        End If
                                        If MCFlag = 0 Then
                                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                                        End If
                                        
                                        If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                            
                                            
                                            Call ProcessEvent(0, ProbabilityXOver, BTarget, ETarget, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                            If ShortOutFlag = 1 Then
                                                ShortOutput(0) = 1
                                                AbortFlag = 1
                                                Exit Sub
                                            End If
                                            If ShortOutFlag = 50 Then ShortOutput(0) = 1
                                        End If
                                    Next A
                                Else
                                    'If BE = 8129 And EN = 8440 Then
                                    '        XX = SEventNumber
                                    '        XX = Seq1 '21,1,9
                                    '        XX = Seq2
                                    '        XX = Seq3
                                    '        '0,19,23,25
                                    '    End If
                                    'If Seq2 = 3 And Seq3 = 6 Then
                                    '    X = X
                                    'End If
                                
                                    If APermFlag = 0 Then
                                        Call UpdateXOList3(AD, CurrentXOver(), XoverList(), 0, ProbabilityXOver, SIP)
                                    Else
                                        SIP = 1
                                    End If
                                    
                                    
                                    If MCFlag = 2 Then
                                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                        End If
                                    End If
                                    
                                    oRecombNo(100) = oRecombNo(100) + 1
                                    oRecombNo(0) = oRecombNo(0) + 1
                                    NewOneFound = 1
                                    ActualFound = 1
                                    If SIP > 0 Then
                                        'XOverlist(AD, CurrentXOver(AD)).lholder = NCommon
                                        
                                        'If ReassortmentFlag = 0 Then
                                        If XPDDone = 0 Then
                                            Call CentreBP(OBE, oEN, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                        Else
                                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                        End If
                                        'End If
                                        If AD > UBound(XoverList, 1) Then Exit Sub
                                        
                                        
                                        XoverList(AD, SIP).Beginning = BE
                                        XoverList(AD, SIP).Ending = EN
                                        XoverList(AD, SIP).MajorP = AMa
                                        XoverList(AD, SIP).MinorP = AMi
                                        XoverList(AD, SIP).Daughter = AD
                                        XoverList(AD, SIP).ProgramFlag = 0
                                        XoverList(AD, SIP).DHolder = 0
                                        XoverList(AD, SIP).Probability = ProbabilityXOver
                                        ExeCountD = ExeCountD + 1 '8,0,1; 8,0,1; 8, 0, 12; 8, 1, 2
                                        'If BE = 1 And EN > 2500 Then
                                        '    X = X
                                        'End If
                                        ExeCountD = ExeCountD + 1
                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(0) = 1
                                            Call UpdatePlotB(AD, AMa, AMi, SIP)
                                                
                                        End If
                                        'If ReassortmentFlag = 0 Then
                                            If SEventNumber > 0 Then
                                                If XPDDone = 0 Then
                                                    If EWarn = 0 Then Call CheckEndsVB(OBE, oEN, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                    If BWarn = 0 Then Call CheckEndsVB(OBE, oEN, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                Else
                                                    If EWarn = 0 Then Call CheckEndsVB(0, 0, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                    If BWarn = 0 Then Call CheckEndsVB(0, 0, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                End If
                                            End If
                                            If BWarn = 1 And EWarn = 1 Then
                                                XoverList(AD, SIP).SBPFlag = 3
                                            ElseIf BWarn = 1 Then
                                                XoverList(AD, SIP).SBPFlag = 1
                                            ElseIf EWarn = 1 Then
                                                XoverList(AD, SIP).SBPFlag = 2
                                            End If
                                        'End If
                                        
                                                
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(0) = 1
                                            AbortFlag = 1
                                            Exit Sub
                                        End If
                                        If ShortOutFlag = 50 Then ShortOutput(0) = 1
                                        'Do shortend distance calculation here?
                                                
                                        
                                    ElseIf DoneRedo = 0 Then
                                        DoneRedo = 1
                                        Call AddToRedoList(0, Seq1, Seq2, Seq3)
                                        
                                        
                                    End If
                                End If
                            End If
                        
                        End If
                        
                    End If
                End If
                
                '1.923
                '
                If EndFlag = 1 Then
                    EndFlag = 0
                    x = LenXoverSeq
                End If
                '
                If (x < LenXoverSeq + 1 And x > NextPosX) Then 'Or ReassortmentFlag = 1 Then
                    NextPosX = x + 1
                    
                Else
                    Exit Do
                End If
                
                '5.719 1K perms
                
            Else
                Exit Do
            End If
        Loop
        '3.895
        
        
        
        If FindCycle = 0 Then
            Temp = MedHomol
            MedHomol = LowHomol
            LowHomol = Temp
        ElseIf FindCycle = 1 Then
            'Exit Sub
            '5.027
            
            If AvHomol(HighHomol) < 0.7 Or DoAllFlag = 1 Then
                Temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = Temp
            Else
                Exit Do
            End If

        Else
            Exit Do
        End If

        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        End If
        
        FindCycle = FindCycle + 1
        
        'Exit Sub
    Loop
    'Exit Sub
        '10.359 1K perms
        x = x
End Sub



Public Sub GCFindSites()
    'This routine attempts to determine which sites are looked at during a GC scan

    Dim x As Long, b As Long, Y As Long, A As Long, LSeq As Long

    ReDim GCSeq(NextNo)
    ReDim GCEnabledNo(NextNo)
    LSeq = Len(StrainSeq(0))
    'Work out how many sequences are not disabled
    NumEnabledSeqs = 0

    For x = 0 To NextNo

        If MaskSeq(x) < 2 Then
            GCSeq(NumEnabledSeqs) = StrainSeq(x)
            GCEnabledNo(NumEnabledSeqs) = x
            NumEnabledSeqs = NumEnabledSeqs + 1
        End If

    Next 'X

    NumEnabledSeqs = NumEnabledSeqs - 1
    ReDim GCIdentical(LSeq + 200)
    ReDim GCXOverSeq(NextNo)
    ReDim GCXPosDiff(LSeq + 200)
    ReDim GCXDiffPos(LSeq + 200)
    b = 0

    If NumEnabledSeqs < NextNo Or GCIndelFlag = 0 Or GCIndelFlag = 1 Then
        ReDim GCIDCount(LSeq, 4)

        For x = 1 To LSeq
            If x = 1000 Then
                x = x
            End If
            LastX = x
            
            GCXPosDiff(x) = b

            For Y = 0 To NumEnabledSeqs

                If SeqNum(x, GCEnabledNo(Y)) = 66 Then
                    GCIDCount(x, 0) = GCIDCount(x, 0) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 68 Then
                    GCIDCount(x, 1) = GCIDCount(x, 1) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 72 Then
                    GCIDCount(x, 2) = GCIDCount(x, 2) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 85 Then
                    GCIDCount(x, 3) = GCIDCount(x, 3) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 46 Or SeqNum(x, GCEnabledNo(Y)) = 47 Then
                    GCIDCount(x, 4) = GCIDCount(x, 4) + 1
                End If

            Next 'Y

            If GCIDCount(x, 0) = NumEnabledSeqs + 1 Or GCIDCount(x, 1) = NumEnabledSeqs + 1 Or GCIDCount(x, 2) = NumEnabledSeqs + 1 Or GCIDCount(x, 3) = NumEnabledSeqs + 1 Or GCIDCount(x, 4) = NumEnabledSeqs + 1 Then
                GCIdentical(x) = 1

                If GCMonoSiteFlag = 1 And GCIDCount(x, 4) = 0 Then
                    b = b + 1
                    GCXPosDiff(x) = b
                    GCXDiffPos(b) = x

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                        End If

                    Next 'A

                End If

            ElseIf GCIDCount(x, 4) > 0 Then
                GCIdentical(x) = 2

                If GCIndelFlag > 0 Then
                    b = b + 1
                    GCXPosDiff(x) = b
                    GCXDiffPos(b) = x

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                        End If

                    Next 'A

                End If

            Else
                b = b + 1
                GCXPosDiff(x) = b
                GCXDiffPos(b) = x

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                    End If

                Next 'A

            End If
             'DoEvents
            If AbortFlag = 1 Then Exit Sub
        Next 'X

    Else

        For x = 1 To LSeq
            GCXPosDiff(x) = b
            GCIdentical(x) = Identical(x)

            If Identical(x) = 0 Then
                b = b + 1
                GCXPosDiff(x) = b
                GCXDiffPos(b) = x

                For A = 0 To NextNo
                    GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                Next 'A

            ElseIf GCMonoSiteFlag = 1 And Mid$(StrainSeq(A), x, 1) <> "-" Then
                b = b + 1
                GCXPosDiff(x) = b
                GCXDiffPos(b) = x

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                    End If

                Next 'A

            End If
            'DoEvents
            If AbortFlag = 1 Then Exit Sub
        Next 'X
        
    End If

End Sub
Public Sub GCFindSitesII()
    'This routine attempts to determine which sites are looked at during a GC scan

    Dim x As Long, b As Long, Y As Long, A As Long, LSeq As Long

    ReDim GCSeq(NextNo)
    ReDim GCEnabledNo(NextNo)
    LSeq = Len(StrainSeq(0))
    'Work out how many sequences are not disabled
    NumEnabledSeqs = 0

    For x = 0 To NextNo

        If MaskSeq(x) < 2 Then
            GCSeq(NumEnabledSeqs) = StrainSeq(x)
            GCEnabledNo(NumEnabledSeqs) = x
            NumEnabledSeqs = NumEnabledSeqs + 1
        End If

    Next 'X

    NumEnabledSeqs = 2
    ReDim GCIdentical(LSeq + 200)
    ReDim GCXOverSeq(NextNo)
    ReDim GCXPosDiff(LSeq + 200)
    ReDim GCXDiffPos(LSeq + 200)
    b = 0

    If NumEnabledSeqs < NextNo Or GCIndelFlag = 0 Or GCIndelFlag = 1 Then
        ReDim GCIDCount(LSeq, 4)

        For x = 1 To LSeq
            GCXPosDiff(x) = b

            For Y = 0 To NumEnabledSeqs

                If SeqNum(x, GCEnabledNo(Y)) = 66 Then
                    GCIDCount(x, 0) = GCIDCount(x, 0) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 68 Then
                    GCIDCount(x, 1) = GCIDCount(x, 1) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 72 Then
                    GCIDCount(x, 2) = GCIDCount(x, 2) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 85 Then
                    GCIDCount(x, 3) = GCIDCount(x, 3) + 1
                ElseIf SeqNum(x, GCEnabledNo(Y)) = 46 Or SeqNum(x, GCEnabledNo(Y)) = 47 Then
                    GCIDCount(x, 4) = GCIDCount(x, 4) + 1
                End If

            Next 'Y

            If GCIDCount(x, 0) = NumEnabledSeqs + 1 Or GCIDCount(x, 1) = NumEnabledSeqs + 1 Or GCIDCount(x, 2) = NumEnabledSeqs + 1 Or GCIDCount(x, 3) = NumEnabledSeqs + 1 Or GCIDCount(x, 4) = NumEnabledSeqs + 1 Then
                GCIdentical(x) = 1

                If GCMonoSiteFlag = 1 And GCIDCount(x, 4) = 0 Then
                    b = b + 1
                    GCXPosDiff(x) = b
                    GCXDiffPos(b) = x

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                        End If

                    Next 'A

                End If

            ElseIf GCIDCount(x, 4) > 0 Then
                GCIdentical(x) = 2

                If GCIndelFlag > 0 Then
                    b = b + 1
                    GCXPosDiff(x) = b
                    GCXDiffPos(b) = x

                    For A = 0 To NextNo

                        If MaskSeq(A) < 2 Then
                            GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                        End If

                    Next 'A

                End If

            Else
                b = b + 1
                GCXPosDiff(x) = b
                GCXDiffPos(b) = x

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                    End If

                Next 'A

            End If

        Next 'X

    Else

        For x = 1 To LSeq
            GCXPosDiff(x) = b
            GCIdentical(x) = Identical(x)

            If Identical(x) = 0 Then
                b = b + 1
                GCXPosDiff(x) = b
                GCXDiffPos(b) = x

                For A = 0 To NextNo
                    GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                Next 'A

            ElseIf GCMonoSiteFlag = 1 And Mid$(StrainSeq(A), x, 1) <> "-" Then
                b = b + 1
                GCXPosDiff(x) = b
                GCXDiffPos(b) = x

                For A = 0 To NextNo

                    If MaskSeq(A) < 2 Then
                        GCXOverSeq(A) = GCXOverSeq(A) + Mid$(StrainSeq(A), x, 1)
                    End If

                Next 'A

            End If

        Next 'X

    End If

End Sub


Public Sub CalcIdentity3(DF)




'This calculates the values displayed in the "Homology display"
    Dim StartPos As Long, Dummy As Variant, FF As Long, oDir As String, EE As Long, SS As Long, OFull As Long, Y As Long, x As Long, SX As Long, EX As Long, Z As Long
    Dim LSeq As Long, DivBy As Long, Pict As Long
    Dim StepSizeB As Double, Interval As Single, Temp As Single, DisplayID() As Single, MaxID As Single, MinID As Single
    Dim WindowSize As Integer, HWindowSize As Integer, ShortColourB As Integer, ShortColourG As Integer, ShortColourR As Integer, HeightOfWindow As Integer
    Dim Pnt As POINTAPI
    Form1.Picture4.ScaleMode = 3
    Form1.Picture11.ScaleMode = 3
    
    OFull = FullWindowSize
    'FullWindowSize = 20
    LSeq = Len(StrainSeq(0))
    If FullWindowSize > 2 Then
        WindowSize = Int(FullWindowSize / 2) * 2
    Else
        WindowSize = 2
        FullWindowSize = 2
    End If
    
    ReDim DisplayID(LSeq)
    If IDDisplayMode = 0 Then
        If DF = 1 And DoneBKgFlag = 0 Then 'recalculate identities
            
            
            If F1MDF = 0 Then
                Form1.SSPanel1.Caption = "Calculating identity"
            End If
            
            ReDim BkgIdentity(LSeq)
            'If distance matrix not calculated yet then calculate it
        SS = Abs(GetTickCount)
            If DistanceFlag = 0 Then
                
                Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
                
                'CalcDistances(AvDst, Decompress() As Long, PermDiffs() As Double, PermValid() As Double, Nextno As Long, Distance() As Double, SPF, DF)
                
               ' XX = UBound(NumSeq, 1)
                'EE = Abs(GetTickCount)
                'TT = EE - SS
                '3.151 for nextno = 4715
                If F1MDF = 0 Then
                    Form1.SSPanel1.Caption = "Making similarity plots"
                End If
                
        
            End If
        'EE = Abs(GetTickCount)
        'TT = EE - SS
        'X = X
            '"Evenise" windowsize
        
            
        
            HWindowSize = WindowSize / 2
            'Do first window
        
            
        
            Y = 1
            SX = Y - HWindowSize
            EX = Y + HWindowSize
        
            For x = SX To EX
        
                If x >= 0 And x <= LSeq Then
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(x)
                Else
                    If LSeq + x > 0 Then
                        If x < 1 Then
                            'XX = UBound(SiteIdentity)
                            BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(LSeq + x)
                        Else
                            BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(x - LSeq)
                        End If
                    End If
                End If
            Next 'X
        
            'Do the rest
            
            For Y = 2 To LSeq
        
                If Y - HWindowSize > 0 Then
                    BkgIdentity(Y) = BkgIdentity(Y - 1) - SiteIdentity(Y - HWindowSize)
                Else
                    BkgIdentity(Y) = BkgIdentity(Y - 1) - SiteIdentity(LSeq + (Y - HWindowSize))
                End If
        
                If Y + HWindowSize <= LSeq Then
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(Y + HWindowSize)
                Else
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity((Y + HWindowSize) - LSeq)
                End If
                
            Next 'Y
            'Erase SiteIdentity
            DoneBKgFlag = 1
            DivBy = NextNo * (NextNo + 1)
            MaxHomology = 0
            MinHomology = 1
            For x = 1 To LSeq
                BkgIdentity(x) = BkgIdentity(x) / (DivBy * WindowSize)
                AvBkgHomology = AvBkgHomology + BkgIdentity(x)
                If BkgIdentity(x) > MaxHomology Then
                    MaxHomology = BkgIdentity(x)
                ElseIf BkgIdentity(x) < MinHomology Then
                    MinHomology = BkgIdentity(x)
                End If
    
            Next 'X
            AvBkgHomology = AvBkgHomology / LSeq
            
            If F1MDF = 0 Then
                If Form1.ProgressBar1.Value < 80 Then
                    Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + 10
                Else
                    Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + (100 - Form1.ProgressBar1.Value) / 4
                End If
                Call UpdateF2Prog
            End If
        End If
        UBB = 0
        On Error Resume Next
        UBB = UBound(BkgIdentity, 1)
        On Error GoTo 0
        If UBB = 0 Then
        ReDim Preserve BkgIdentity(LSeq + 10)
        End If
        If LSeq > UBound(BkgIdentity, 1) Then Exit Sub
        For x = 0 To LSeq
            DisplayID(x) = BkgIdentity(x)
        Next x
        MaxID = MaxHomology
        MinID = MinHomology
    ElseIf IDDisplayMode = 1 Then
        If DF = 1 And DoneTajDflag = 0 Then
            Call TajimasD2(SeqNum(), TajD(), CLng(WindowSize))
            DoneTajDflag = 1
        End If
        For x = 0 To LSeq
            DisplayID(x) = TajD(x)
        Next x
        MinID = MinTajD
        MaxID = MaxTajD
    ElseIf IDDisplayMode = 2 Then 'GC content
        If DF = 1 And DonGCContentFlag = 0 Then
            Call FindGCContent(SeqNum(), GCContent(), CLng(WindowSize))
            DonGCContentFlag = 1
        End If
        For x = 0 To LSeq
            DisplayID(x) = GCContent(x)
        Next x
        MinID = MinGCContent
        MaxID = MaxGCContent
    End If
    'Make sure that the scalemode is in pixels
    
    Dim StepSizeC As Single, ModStep As Single
    StepSizeB = LSeq / Form1.Picture4.ScaleWidth
    StepSizeC = Decompress(LSeq) / Form1.Picture4.ScaleWidth
    If StepSizeC <> StepSizeB Then
        ModStep = 0.25
    Else
        ModStep = 1
    End If
    If StepSizeC < 1 Then

        If StepSizeC <> 0 Then
            Chunk = CLng(1 / StepSizeC) + 1
        Else
            Chunk = 1
        End If

        StepSizeB = 1
        'StepSizeC = 1
    Else
        Chunk = 1
    End If
    
    HeightOfWindow = Form1.Picture4.ScaleHeight
    Interval = MaxID - MinID
    'Enable "ID Window Toggle" Button
    Form1.Command6(1).Enabled = True
    'Clear and prepare windows for drawing
    
    Form1.Picture11.Picture = LoadPicture()
    
    If HomologyIndicator = 2 Then
        Form1.Picture11.Visible = True
    Else
        Form1.Picture11.Visible = False
    End If

    
    Form1.Picture4.Picture = LoadPicture()
    
    Dim SSB As Long, SSC As Long
    
    SSB = CLng(StepSizeB - 0.5) * ModStep
    If SSB < 1 Then SSB = 1
    
    
    
    Dim ImageData() As Byte, bm As BITMAP
     
    
    Dim EP As Long
    GetObject Form1.Picture4.Image, Len(bm), bm 'grabs image from picture7
    ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)
    GetBitmapBits Form1.Picture4.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0) 'add the picture7 graphic to imagedata
    
    
    
    If x = x Then
    
        Dummy = P4Draw(Chunk, LSeq, SSB, MinID, UBound(ImageData, 1), UBound(ImageData, 2), Interval, HeightOfWindow, StepSizeC, Decompress(0), DisplayID(0), ImageData(0, 0, 0))
    Else
        EP = UBound(ImageData, 3)
        For x = 1 To LSeq - 1 Step SSB
            If Interval > 0 Then
            
                Temp = (DisplayID(x) - MinID) / Interval
            Else
                Temp = 1
                Interval = 1
            End If
            Temp = Int(Temp * 765)
            ShortColourR = Temp
    
            If ShortColourR > 255 Then
                ShortColourR = 255
                ShortColourG = Temp - 255
                '@
                If ShortColourG > 255 Then
                    ShortColourB = Temp - 510
                    ShortColourG = 255
                Else
                    ShortColourB = 0
                End If
    
            Else
                ShortColourB = 0
                ShortColourG = 0
            End If
    
            
            If ShortColourR < 0 Then ShortColourR = 0
            StartPos = (Decompress(x) / StepSizeC)
            For Z = StartPos To StartPos + (Chunk - 1)
                For Y = 0 To EP
                    
                    ImageData(0, Z, Y) = ShortColourG
                    ImageData(1, Z, Y) = ShortColourB
                    
                    ImageData(2, Z, Y) = ShortColourR
                Next Y
            Next Z
        Next 'X
    End If
    
    
        'XX = Form1.Picture4.AutoRedraw
    SetBitmapBits Form1.Picture4.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
    
    
    '@
    GetObject Form1.Picture11.Image, Len(bm), bm 'grabs image from picture7
    ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)
    GetBitmapBits Form1.Picture11.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0) 'add the picture7 graphic to imagedata

    If x = x Then
    
       Dummy = P11Draw(Chunk, LSeq, SSB, MinID, UBound(ImageData, 1), UBound(ImageData, 2), Interval, HeightOfWindow, StepSizeC, Decompress(0), DisplayID(0), ImageData(0, 0, 0))
    Else
    
        For x = 1 To LSeq - 1 Step SSB
            StartPos = Int((Decompress(x) / StepSizeC))
            For Z = StartPos To StartPos + (Chunk - 1)
                For Y = (1 - ((DisplayID(x) - MinID) / Interval)) * HeightOfWindow To HeightOfWindow - 1
                    ImageData(0, Z, Y) = 0
                    ImageData(1, Z, Y) = 0
                    ImageData(2, Z, Y) = 0
                Next Y
            Next Z
        Next 'X
    End If
    
    SetBitmapBits Form1.Picture11.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
    
        'Calculate distmods
    Dim Max As Double, Min As Double, AV As Double
    
    If DF = 1 Then
        ReDim DistMod(Len(StrainSeq(0)))
        FullWindowSize = OFull
        Max = -10
        Min = 100
        AV = 0
        For x = 1 To Len(StrainSeq(0))
            AV = AV + DisplayID(x)
            If Max < DisplayID(x) Then
                Max = DisplayID(x)
            End If
            If Min > DisplayID(x) Then
                Min = DisplayID(x)
            End If
        Next x
        AV = AV / Len(StrainSeq(0))
        For x = 1 To Len(StrainSeq(0))
            If DisplayID(x) > 0 Then
                DistMod(x) = AV / DisplayID(x)
            Else
                '@
                DistMod(x) = AV / 0.0000001
            End If
        Next x
    End If
    
    If ORFFlag = 1 Then
        Call DrawORFs
        
    End If
    
    Pic4Flag = 1
    Pic11Flag = 1
    Form1.Picture4.Refresh
    PositionIndicaterOn = 0
    Form1.Picture4.DrawWidth = 1
    Form1.Picture4.Enabled = True
    Form1.Picture11.DrawWidth = 1
    Form1.Picture11.Refresh
    Form1.Picture11.Enabled = True
    '@
    Form1.SSPanel1.Caption = ""



End Sub


Public Sub CalcIdentity2(DF)
    
    'This calculates the values displayed in the "Homology display"
    Dim Dummy As Variant, FF As Long, oDir As String, EE As Long, SS As Long, OFull As Long, Y As Long, x As Long, SX As Long, EX As Long
    Dim LSeq As Long, DivBy As Long, Pict As Long
    Dim StepSizeB As Double, Interval As Double, Temp As Double, DisplayID() As Single, MaxID As Single, MinID As Single
    Dim WindowSize As Integer, HWindowSize As Integer, ShortColourB As Integer, ShortColourG As Integer, ShortColourR As Integer, HeightOfWindow As Integer
    Dim Pnt As POINTAPI
    
    
    OFull = FullWindowSize
    'FullWindowSize = 20
    LSeq = Len(StrainSeq(0))
    If FullWindowSize > 2 Then
        WindowSize = Int(FullWindowSize / 2) * 2
    Else
        WindowSize = 2
        FullWindowSize = 2
    End If
    
    ReDim DisplayID(LSeq)
    If IDDisplayMode = 0 Then
        If DF = 1 And DoneBKgFlag = 0 Then 'recalculate identities
            
            
            If F1MDF = 0 Then
                Form1.SSPanel1.Caption = "Calculating identity"
            End If
            
            ReDim BkgIdentity(LSeq)
            'If distance matrix not calculated yet then calculate it
        SS = Abs(GetTickCount)
            If DistanceFlag = 0 Then
                
                Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
                
                'CalcDistances(AvDst, Decompress() As Long, PermDiffs() As Double, PermValid() As Double, Nextno As Long, Distance() As Double, SPF, DF)
                
               ' XX = UBound(NumSeq, 1)
                'EE = Abs(GetTickCount)
                'TT = EE - SS
                '3.151 for nextno = 4715
                If F1MDF = 0 Then
                    Form1.SSPanel1.Caption = "Making similarity plots"
                End If
                
        
            End If
        'EE = Abs(GetTickCount)
        'TT = EE - SS
        'X = X
            '"Evenise" windowsize
        
            
        
            HWindowSize = WindowSize / 2
            'Do first window
        
            
        
            Y = 1
            SX = Y - HWindowSize
            EX = Y + HWindowSize
        
            For x = SX To EX
        
                If x >= 0 And x <= LSeq Then
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(x)
                ElseIf x < 1 Then
                    'XX = UBound(SiteIdentity)
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(LSeq + x)
                Else
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(x - LSeq)
                End If
        
            Next 'X
        
            'Do the rest
            
            For Y = 2 To LSeq
        
                If Y - HWindowSize > 0 Then
                    BkgIdentity(Y) = BkgIdentity(Y - 1) - SiteIdentity(Y - HWindowSize)
                Else
                    BkgIdentity(Y) = BkgIdentity(Y - 1) - SiteIdentity(LSeq + (Y - HWindowSize))
                End If
        
                If Y + HWindowSize <= LSeq Then
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity(Y + HWindowSize)
                Else
                    BkgIdentity(Y) = BkgIdentity(Y) + SiteIdentity((Y + HWindowSize) - LSeq)
                End If
                
            Next 'Y
            'Erase SiteIdentity
            DoneBKgFlag = 1
            DivBy = NextNo * (NextNo + 1)
            MaxHomology = 0
            MinHomology = 1
            For x = 1 To LSeq
                BkgIdentity(x) = BkgIdentity(x) / (DivBy * WindowSize)
                AvBkgHomology = AvBkgHomology + BkgIdentity(x)
                If BkgIdentity(x) > MaxHomology Then
                    MaxHomology = BkgIdentity(x)
                ElseIf BkgIdentity(x) < MinHomology Then
                    MinHomology = BkgIdentity(x)
                End If
    
            Next 'X
            AvBkgHomology = AvBkgHomology / LSeq
            
            If F1MDF = 0 Then
                If Form1.ProgressBar1.Value < 80 Then
                    Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + 10
                Else
                    Form1.ProgressBar1.Value = Form1.ProgressBar1.Value + (100 - Form1.ProgressBar1.Value) / 4
                End If
                Call UpdateF2Prog
            End If
        End If
        For x = 0 To LSeq
            DisplayID(x) = BkgIdentity(x)
        Next x
        MaxID = MaxHomology
        MinID = MinHomology
    ElseIf IDDisplayMode = 1 Then 'Tajima D
        If DF = 1 And DoneTajDflag = 0 Then
            Call TajimasD2(SeqNum(), TajD(), CLng(WindowSize))
            DoneTajDflag = 1
        End If
        For x = 0 To LSeq
            DisplayID(x) = TajD(x)
        Next x
        MinID = MinTajD
        MaxID = MaxTajD
    ElseIf IDDisplayMode = 2 Then 'GC content
        If DF = 1 And DonGCContentFlag = 0 Then
            Call FindGCContent(SeqNum(), GCContent(), CLng(WindowSize))
            DonGCContentFlag = 1
        End If
        For x = 0 To LSeq
            DisplayID(x) = GCContent(x)
        Next x
        MinID = MinGCContent
        MaxID = MaxGCContent
    End If
    'Make sure that the scalemode is in pixels
    Form1.Picture4.ScaleMode = 3
    Form1.Picture11.ScaleMode = 3
    Dim StepSizeC As Single, ModStep As Single
    StepSizeB = LSeq / Form1.Picture4.ScaleWidth
    StepSizeC = Decompress(LSeq) / Form1.Picture4.ScaleWidth
    If StepSizeC <> StepSizeB Then
        ModStep = 0.25
    Else
        ModStep = 1
    End If
    If StepSizeC < 1 Then

        If StepSizeC <> 0 Then
            Chunk = CLng(1 / StepSizeC) + 1
        Else
            Chunk = 1
        End If

        StepSizeB = 1
        'StepSizeC = 1
    Else
        Chunk = 1
    End If
    
    HeightOfWindow = Form1.Picture4.ScaleHeight
    Interval = MaxID - MinID
    'Enable "ID Window Toggle" Button
    Form1.Command6(1).Enabled = True
    'Clear and prepare windows for drawing
    Form1.Picture11.DrawMode = 13
    Form1.Picture11.AutoRedraw = True
    Form1.Picture11.Picture = LoadPicture()
    Form1.Picture11.ForeColor = 0
    

    If HomologyIndicator = 2 Then
        Form1.Picture11.Visible = True
    Else
        Form1.Picture11.Visible = False
    End If

    Form1.Picture4.AutoRedraw = True
    Form1.Picture4.DrawMode = 13
    Form1.Picture4.Picture = LoadPicture()
    Form1.Picture4.DrawWidth = Chunk
  
     Dim SSB As Long, SSC As Long
    
    SSB = CLng(StepSizeB - 0.5) * ModStep
    If SSB < 1 Then SSB = 1
    
    If DebuggingFlag < 2 Then On Error Resume Next
    Pict = Form1.Picture4.hdc
    
    ubkg = 0
    ubkg = UBound(BkgIdentity, 1)
    On Error GoTo 0
    
    If ubkg < LSeq Then
        ReDim Preserve BkgIdentity(LSeq)
        Exit Sub
    End If
    
    On Error GoTo 0
    If Chunk = 1 Then
        For x = 1 To LSeq Step SSB
            If Interval > 0 Then
            
                Temp = (DisplayID(x) - MinID) / Interval
            Else
                Temp = 1
                Interval = 1
            End If
            ShortColourR = Int(Temp * 765)
    
            If ShortColourR > 255 Then
                ShortColourR = 255
                ShortColourG = Int(Temp * 765) - 255
    
                If ShortColourG > 255 Then
                    ShortColourB = Int(Temp * 765) - 510
                    ShortColourG = 255
                Else
                    ShortColourB = 0
                End If
    
            Else
                ShortColourB = 0
                ShortColourG = 0
            End If
    
            
            If ShortColourR < 0 Then ShortColourR = 0
            '@
            Form1.Picture4.ForeColor = RGB(ShortColourR, ShortColourB, ShortColourG)
            Dummy = MoveToEx(Pict, (Decompress(x) / StepSizeC), 0, Pnt)
            
            Dummy = LineTo(Pict, (Decompress(x) / StepSizeC) + (Chunk - 1), HeightOfWindow)
            
        Next 'X
    Else
        Form1.Picture4.FillStyle = 0
        For x = 1 To LSeq Step SSB
            If Interval > 0 Then
            
                Temp = (DisplayID(x) - MinID) / Interval
            Else
                Temp = 1
                Interval = 1
            End If
            ShortColourR = Int(Temp * 765)
    
            If ShortColourR > 255 Then
                ShortColourR = 255
                ShortColourG = Int(Temp * 765) - 255
    
                If ShortColourG > 255 Then
                    ShortColourB = Int(Temp * 765) - 510
                    ShortColourG = 255
                Else
                    ShortColourB = 0
                End If
    
            Else
                ShortColourB = 0
                ShortColourG = 0
            End If
    
            
            If ShortColourR < 0 Then ShortColourR = 0
            Form1.Picture4.ForeColor = RGB(ShortColourR, ShortColourB, ShortColourG)
            Dummy = Rectangle(Pict, (Decompress(x) / StepSizeC), 0, (Decompress(x) / StepSizeC) + (Chunk - 1), HeightOfWindow)
            
        Next 'X

    
    End If
        'XX = Form1.Picture4.AutoRedraw
    If Chunk = 1 Then
        Form1.Picture11.DrawWidth = 1
        Form1.Picture11.DrawMode = 13
        Form1.Picture11.ForeColor = 0
        Pict = Form1.Picture11.hdc

        For x = 1 To LSeq Step SSB
            Dummy = MoveToEx(Pict, Int((Decompress(x) / StepSizeC)), (1 - ((DisplayID(x) - MinID) / Interval)) * HeightOfWindow, Pnt)
            Dummy = LineTo(Pict, Int((Decompress(x) / StepSizeC)) + (Chunk - 1), HeightOfWindow)
        Next 'X

    Else
        Form1.Picture11.DrawWidth = 1
        'Pict = Form1.Picture11.hdc

        For x = 1 To LSeq Step SSB
            'Dummy = MoveToEx(Pict, Int((X * Chunk / StepSizeB) - Chunk), (1 - ((DisplayID(X) - MinID) / Interval)) * HeightOfWindow, Pnt)
            ' Dummy = LineTo(Pict, Int((X * Chunk / StepSizeB) - Chunk), HeightOfWindow)
            Form1.Picture11.Line (Int((Decompress(x) / StepSizeC)), (1 - ((DisplayID(x) - MinID) / Interval)) * HeightOfWindow)-(Int((Decompress(x) / StepSizeC)) + (Chunk - 1), HeightOfWindow), , BF
        Next 'X

    End If
    
    
    'Calculate distmods
    Dim Max As Double, Min As Double, AV As Double
    
    If DF = 1 Then
        ReDim DistMod(Len(StrainSeq(0)))
        FullWindowSize = OFull
        Max = -10
        Min = 100
        AV = 0
        For x = 1 To Len(StrainSeq(0))
            AV = AV + DisplayID(x)
            If Max < DisplayID(x) Then
                Max = DisplayID(x)
            End If
            If Min > DisplayID(x) Then
                Min = DisplayID(x)
            End If
        Next x
        AV = AV / Len(StrainSeq(0))
        For x = 1 To Len(StrainSeq(0))
            If DisplayID(x) > 0 Then
                DistMod(x) = AV / DisplayID(x)
            Else
                DistMod(x) = AV / 0.0000001
            End If
        Next x
    End If
    
    If ORFFlag = 1 Then
        Call DrawORFs
    End If
    
    Pic4Flag = 1
    Pic11Flag = 1
    Form1.Picture4.Refresh
    PositionIndicaterOn = 0
    Form1.Picture4.DrawWidth = 1
    Form1.Picture4.Enabled = True
    Form1.Picture11.DrawWidth = 1
    Form1.Picture11.Refresh
    Form1.Picture11.Enabled = True
    Form1.SSPanel1.Caption = ""
End Sub
Public Sub HomologyWindow()

    Dim Pnt As POINTAPI
    Dim StepSizeB As Long

    Y = Form1.Picture4.ScaleWidth
    StepSizeB = CLng(Len(StrainSeq(0)) / Y)

    If StepSizeB < 1 Then
        'stepsize = 1
        Chunk = Int(1 / StepSizeB) + 1
        StepSizeB = 1
        'addfactor = 2
    Else
        Chunk = 1
    End If

    Form1.Picture4.DrawWidth = Chunk
    Form1.Picture4.AutoRedraw = True
    Form1.Picture4.PSet (0, 0), QBColor(0)
    Form1.Picture4.Refresh
    PositionIndicaterOn = 0
    Form1.Picture11.DrawWidth = Chunk
    Form1.Picture11.AutoRedraw = True
    Form1.Picture11.PSet (0, 0), QBColor(0)
    Form1.Picture11.Refresh
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    BASE = RGB(255, 255, 255)

    Dim ShortColourB As Integer
    Dim ShortColourG As Integer
    Dim ShortColourR As Integer
    Dim HeightOfWindow As Integer

    HeightOfWindow = Form1.Picture4.ScaleHeight
    MaxHomology = 0
    MinHomology = 1

    For x = Beginning + 1 To Ending

        If BkgIdentity(x) > MaxHomology Then
            MaxHomology = BkgIdentity(x)
            MaxBkgIDPos = x
        End If

        If BkgIdentity(x) < MinHomology Then MinHomology = BkgIdentity(x)
    Next 'X

    Interval = MaxHomology - MinHomology
    Pict = Form1.Picture4.hdc

    For x = Beginning To Ending Step StepSizeB
        Temp = (BkgIdentity(x) - MinHomology) / Interval
        ShortColourR = Int(Temp * 765)

        If ShortColourR > 255 Then
            ShortColourR = 255
            ShortColourG = Int(Temp * 765) - 255

            If ShortColourG > 255 Then
                ShortColourB = Int(Temp * 765) - 510
                ShortColourG = 255
            Else
                ShortColourB = 0
            End If

        Else
            ShortColourB = 0
            ShortColourG = 0
        End If

        Form1.Picture4.ForeColor = RGB(ShortColourR, ShortColourB, ShortColourG)
        'Form1.Picture4.ForeColor = 0
        Dummy = MoveToEx(Pict, ((x - Beginning) * Chunk / StepSizeB) - Chunk, 0, Pnt)
        Dummy = LineTo(Pict, ((x - Beginning) * Chunk / StepSizeB) - Chunk, HeightOfWindow)
    Next 'X

    Form1.Picture11.Visible = False
    Form1.Picture11.Cls
    Form1.Picture11.ForeColor = 0
    Pict = Form1.Picture11.hdc

    For x = Beginning + 1 To Ending Step StepSizeB
        Dummy = MoveToEx(Pict, Int(((x - Beginning) * Chunk / StepSizeB) - Chunk), (1 - ((BkgIdentity(x) - MinHomology) / Interval)) * HeightOfWindow, Pnt)
        Dummy = LineTo(Pict, Int(((x - Beginning) * Chunk / StepSizeB) - Chunk), HeightOfWindow)
        Form1.Picture11.Visible = True
    Next 'X

    Form1.Picture4.DrawWidth = 1
    Form1.Picture4.Refresh
    PositionIndicaterOn = 0
    PositionIndicaterOn = 0
    Form1.Picture11.DrawWidth = 1
    Form1.Picture11.Refresh
End Sub

Public Sub PrintProbabilityII()
    'If ExeCheckFlag = 0 Then

    Dim Out As String
    
    ProbX = 30 + XFactor * ProbX - Form1.Picture7.TextWidth("0.00") / 2 + XFactor
    Form1.Picture7.CurrentX = 1 + ProbX
    Form1.Picture7.CurrentY = 1 + 18 + (1 - ProbY) * (PicHeight - 35)
    Out$ = Left$(ProbTest$, 5)
    Form1.Picture7.ForeColor = QuaterColour
    
    GPVTNum = GPVTNum + 1
    GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
    GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
    GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
    GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
    GPVText(GPVTNum) = "-" + Out$
    
    Form1.Picture7.Print Out$
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.CurrentX = ProbX
    Form1.Picture7.CurrentY = 18 + (1 - ProbY) * (PicHeight - 35)
    
    GPVTNum = GPVTNum + 1
    GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
    GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
    GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
    GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
    GPVText(GPVTNum) = Out$
    
    Form1.Picture7.Print Out$
    Form1.Picture7.Refresh
    'End If
    ProbY = ProbY - 0.1

    If ProbY < 0.5 Then ProbY = 1
End Sub

Public Sub PrintProbability()

    Dim OS As Long, Out As String, Power As String
    Dim OFSize As Integer, PY As Long
    Dim SP As Integer
    
    
    

    PY = 18 + (1 - ProbY) * (PicHeight - 35)
    Form1.Picture7.CurrentY = PY + 1
    OFSize = Form1.Picture7.FontSize

    Dim PV As String, EX As String

    PV = Trim(ProbTest$)
    If Left(PV, 1) = "." Then PV = "0" + PV
    If Len(PV) > 3 Then

        If Mid$(PV, Len(PV) - 3, 1) = "E" Then
            EX = Right$(PV, 2)
        ElseIf Len(PV) > 4 Then

            If Mid$(PV, Len(PV) - 4, 1) = "E" Then
                EX = Right$(PV, 3)
            ElseIf Len(PV) > 5 Then

                If Mid$(PV, Len(PV) - 5, 1) = "E" Then
                    EX = Right$(PV, 4)
                End If

            End If

        End If

    End If
    
    If Len(PV) >= 5 And Len(EX) = 0 Then
        If Left$(PV, 1) = "0" Then
            SP = 3
            Do
                If Mid$(PV, SP, 1) <> "0" Then
                    PV = Mid$(PV, SP, 1) & "." & Mid$(PV, SP + 1, 3)
                    EX = Trim$(CStr(SP - 2))
    
                    If SP - 2 < 10 Then
                        EX = "0" + EX
                    End If
    
                        Exit Do
                End If
    
                SP = SP + 1
            Loop
        End If
    End If
    
    If Left$(PV, 1) = "." Then
        PV = "0" + PV
    End If

    If Len(PV) >= 5 Then

        If val(Left$(PV, 5)) > 0 Then
            PV = Left$(PV, 5)
        Else
            SP = 3

            Do

                If Mid$(PV, SP, 1) <> "0" Then
                    PV = Mid$(PV, SP, 1) & "." & Mid$(PV, SP + 1, 3)
                    EX = Trim$(CStr(SP - 2))

                    If SP - 2 < 10 Then
                        EX = "0" + EX
                    End If

                    Exit Do
                End If

                SP = SP + 1
            Loop

        End If

    End If

    If Len(PV) < 5 Then
        Pos = InStr(1, PV, ".", vbBinaryCompare)
        If val(PV) <= 2 And Pos = 0 Then
            PV = PV + "."
            PV = PV + String$(5 - Len(PV), "0")
        Else
            PV = PV + String$(5 - Len(PV), "0")
        End If
    End If

    If Len(EX) > 0 Then
        PV = PV & " X 10"
        OS = Form1.Picture2.TextWidth(PV)
        PV = PV + String$(Len(EX) + 1, " ")
    End If

    Out = PV
    Power = EX

    If Len(EX) > 0 Then
        ProbX = 30 + XFactor * ProbX - Form1.Picture7.TextWidth("0.00 x 1000") / 2 + XFactor
        If Form1.Picture7.TextWidth("0.00 x 100000") + ProbX > Form1.Picture7.ScaleWidth Then
            ProbX = Form1.Picture7.ScaleWidth - Form1.Picture7.TextWidth("0.00 x 100000")
        End If
    Else
        ProbX = 30 + XFactor * ProbX - Form1.Picture7.TextWidth("0.000") / 2 + XFactor
        If Form1.Picture7.TextWidth("0.00000") + ProbX > Form1.Picture7.ScaleWidth Then
            ProbX = Form1.Picture7.ScaleWidth - Form1.Picture7.TextWidth("0.00000")
        End If
    End If
     
    Form1.Picture7.CurrentX = ProbX + 1
    'Do the shadow
    Form1.Picture7.ForeColor = QuaterColour
    
    GPVTNum = GPVTNum + 1
    If GPVTNum <= UBound(GPVTFont, 2) Then
        GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
        GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
        GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
        GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
        GPVText(GPVTNum) = Out$
        Form1.Picture7.Print Out$
    End If


'GPVTFont 0 = X
'GPVTFont 1 = y
'GPVTFont 2 = fontsize
'GPVTFont 3 = colour



    If Len(EX) > 0 Then

        If TwipPerPix = 12 Then
            Form1.Picture7.CurrentX = 1 + 55 + ProbX
        Else
            Form1.Picture7.CurrentX = 1 + 45 + ProbX
        End If
        
        Form1.Picture7.CurrentY = 1 + PY - 4
        Form1.Picture7.FontSize = CInt(Form1.Picture7.FontSize / 1.2)
        
        GPVTNum = GPVTNum + 1
        If UBound(GPVTFont, 2) < GPVTNum Then
            ReDim Preserve GPVTFont(5, GPVTNum + 100)
            ReDim Preserve GPVText(GPVTNum + 100)
        End If
        GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
        GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
        GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
        GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
        GPVText(GPVTNum) = "-" + Power
        '@
        Form1.Picture7.Print "-" + Power
    End If

    'Do the number
    Form1.Picture7.ForeColor = 0
    Form1.Picture7.FontSize = OFSize
    Form1.Picture7.CurrentX = ProbX
    Form1.Picture7.CurrentY = PY
    
    GPVTNum = GPVTNum + 1
    If GPVTNum <= UBound(GPVTFont, 2) Then
        GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
        GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
        GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
        GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
        GPVText(GPVTNum) = Out$
        Form1.Picture7.Print Out$
        Form1.Picture7.FontSize = CInt(Form1.Picture7.FontSize / 1.2)
    End If
    If Len(EX) > 0 Then

        If TwipPerPix = 12 Then
            Form1.Picture7.CurrentX = 55 + ProbX
        Else
            Form1.Picture7.CurrentX = 45 + ProbX
        End If

        Form1.Picture7.CurrentY = PY - 4
        GPVTNum = GPVTNum + 1
        If GPVTNum <= UBound(GPVTFont, 2) Then
            GPVTFont(0, GPVTNum) = Form1.Picture7.CurrentX: GPVTFont(4, GPVTNum) = Form1.Picture7.Width
            GPVTFont(1, GPVTNum) = Form1.Picture7.CurrentY: GPVTFont(5, GPVTNum) = Form1.Picture7.Height
            GPVTFont(2, GPVTNum) = Form1.Picture7.FontSize
            GPVTFont(3, GPVTNum) = Form1.Picture7.ForeColor
            GPVText(GPVTNum) = "-" + Power$
            Form1.Picture7.Print "-" + Power$
        End If
    End If

    'Form1.Picture7.Refresh
    Form1.Picture7.FontSize = OFSize
    ProbY = ProbY - 0.1

    If ProbY < 0.5 Then ProbY = 1
End Sub

Public Sub LoadGenBank(VarString As String)
    Dim WinSeq As Integer

    Dim HitXPos As Long, LeftBound As Long, RightBound As Long, PosWarn As Long, SS As Long, EE As Long, FF As Long, Genes As Integer, OMode As Integer, VarX As String
    Dim LSeq As Long, LastPos As Long, x As Long, Z As Long, Y As Long, F As Long, A As Long, oDirX As String
    Dim TempString As String
    Dim OS1 As Long, SSB As Long, Response As Long
    Dim CircularFlagX As Long, oStartInAlign As Long
    FF = FreeFile
    If SilentGBFlag = 0 Then
        Form1.Picture11.ForeColor = 0
        Form1.Picture11.DrawMode = 13
    
    End If
    Genes = 0
    LastPos = 1
    LSeq = Len(StrainSeq(0))
    'Varstring$ = SeqFile
    Open "test.txt" For Output As #10
    Print #10, VarString
    Close #10
    'XX = CurDir
    XX = Len(VarString)
    Pos = InStr(1, VarString, "DEFINITION", vbBinaryCompare)
    
    If Pos > 0 Then
        Pos2 = InStr(Pos, VarString, "complete", vbBinaryCompare)
        If Pos2 > 0 Then
            DatasetName = Trim(Mid(VarString, Pos + 11, Pos2 - Pos - 13))
            If Left(DatasetName, 1) = "A" Or Left(DatasetName, 1) = "E" Or Left(DatasetName, 1) = "I" Or Left(DatasetName, 1) = "O" Or Left(DatasetName, 1) = "U" Then
                DatasetName = " (looks like an " + DatasetName + " dataset)"
            Else
                DatasetName = " (looks like a " + DatasetName + " dataset)"
            End If
        End If
    End If
    
    
    Dim UnitLengthII As Double

    UnitLengthII = Form1.Picture20.ScaleWidth / LSeq
    'originalname(101) = originalname(100)
    WinSeq = -1
    Do
        Pos = InStr(LastPos, VarString$, "CDS ", vbBinaryCompare)
        'XX = Len(VarString$)
        If Pos = 0 Then
            Pos = InStr(LastPos, VarString$, "NC", vbBinaryCompare)
        End If
        Pos1 = InStr(LastPos, VarString$, "mat_peptide", vbTextCompare)
        If (Pos1 < Pos And Pos1 > 0) Or Pos = 0 Then
            Pos = Pos1
        End If
        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
        Else
            Exit Do
        End If

    Loop

    LastPos = 1
    ReDim GeneList(Genes * 10), ColBump(Genes * 10)

    

    GeneNumber = Genes
    Genes = 0

    Dim PosNextGene As Long
    Dim PosDot As Long
    Dim PosComplement As Long
    Dim PosJoin As Long
    Dim PosBracket As Long
    Dim PosComma As Long
    Dim PosGene As Long
    Dim PosPar As Long
    Dim PosProd As Long, PosTranslation As Long
    Dim IntronNo As Integer
    Dim ExonNo As Integer

    If ORFFlag = 1 Then
        Form1.Picture19.Cls
        Form1.Picture20.Cls
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        'Form1.Picture7.Width = Form1.Picture10.ScaleWidth
        Form1.Picture7.Top = -1
        'Form1.Picture7.Left = 0
    End If
    Dim PosNote As Long, NoteText As String
    Do
        Pos = InStr(LastPos, VarString$, "CDS ", vbBinaryCompare)
        Pos1 = InStr(LastPos, VarString$, "mat_peptide", vbTextCompare)
        If (Pos1 < Pos And Pos1 > 0) Or Pos = 0 Then
            Pos = Pos1
        End If
        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
            
            
            PosDot = InStr(Pos, VarString$, "..", vbBinaryCompare)
            PosComplement = InStr(Pos, VarString$, "complement", vbBinaryCompare)
            PosJoin = InStr(Pos, VarString$, "join", vbBinaryCompare)
            PosNextGene = InStr(PosDot, VarString$, "CDS ", vbBinaryCompare)
            PosGene = InStr(Pos, VarString$, "/gene=", vbBinaryCompare)
            PosNote = InStr(Pos, VarString$, "/note=", vbBinaryCompare)
            CircularFlagX = InStr(1, VarString$, "circular", vbTextCompare)
            If CircularFlagX < 1000 And CircularFlagX > 0 Then
                CircularFlagX = 1
            Else
                CircularFlagX = InStr(1, VarString$, "linear", vbTextCompare)
                If CircularFlagX < 1000 And CircularFlagX > 0 Then
                    CircularFlagX = 0
                Else
                    CircularFlagX = CircularFlag
                End If
            End If
            PosProd = InStr(Pos, VarString$, "/product=", vbBinaryCompare)
            PosTranslation = InStr(Pos, VarString$, "/translation", vbBinaryCompare)
            If PosNextGene > 0 And (PosTranslation > 0 And PosGene > PosTranslation) Then 'check to see if posgene actually found
                PosGene = 0
            End If
            'Circular
            x = x
       '     If PosComplement = 0 And PosJoin = 0 Then
       '         GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
       '         GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
       '
       '         If GeneList(Genes).Start < GeneList(Genes).End Then
       '             GeneList(Genes).Orientation = 1
       '         Else
       '             GeneList(Genes).Orientation = 2
       '         End If
       '     End If
            'codon_start
            OffsetX = 7
            If PosGene = 0 Then
                PosGene = InStr(Pos, VarString$, "/codon_start=", vbBinaryCompare)
                OffsetX = 14
            End If
            NoteText = ""
            If PosGene = 0 Then
                PosGene = InStr(Pos, VarString$, "/note=", vbBinaryCompare)
                OffsetX = 7
            Else
                If PosNote > 0 And (PosNote < PosNextGene Or PosNextGene = 0) Then
                    PosPar = InStr(PosNote + 7, VarString$, Chr$(34), vbBinaryCompare)
                    NoteText = Mid$(VarString$, PosNote + 7, PosPar - PosNote - 7)
                    NoteText = ": " + NoteText
                    x = x
                End If
            End If
            'I should also read in the "note here"
            If PosGene > 0 And ((PosGene < PosNextGene And PosNextGene > 0) Or PosNextGene = 0) Then
                PosNextGene = InStr(PosGene, VarString$, "CDS ", vbBinaryCompare)
                PosPar = InStr(PosGene + OffsetX + 1, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Name = Mid$(VarString$, PosGene + OffsetX, PosPar - PosGene - OffsetX) ' + NoteText
            End If

            
            'read to check if there are more products and read in the coords if there are - these are what you expect for polyproteins
            If Pos = Pos1 Then GeneList(Genes).Product = "*"
            If PosProd > 0 And (PosProd < PosNextGene Or PosNextGene = 0) Then
                PosPar = InStr(PosProd + 10, VarString$, Chr$(34), vbBinaryCompare)
                If Pos = Pos1 Then 'i.e. its probably a cleavage product
                    GeneList(Genes).Product = Mid$(VarString$, PosProd + 10, PosPar - PosProd - 10) + NoteText + GeneList(Genes).Product
                Else
                    GeneList(Genes).Product = Mid$(VarString$, PosProd + 10, PosPar - PosProd - 10) + NoteText
                End If
            Else
                GeneList(Genes).Product = NoteText + GeneList(Genes).Product
            End If
            GeneList(Genes).Name = Trim(GeneList(Genes).Name)
            If Right(GeneList(Genes).Name, 9) = "/product=" Then
                GeneList(Genes).Name = "" 'GeneList(Genes).Product '""  ' = Mid$(GeneList(Genes).Product, 10, Len(GeneList(Genes).Product))
            End If
            GeneList(Genes).Product = Trim(GeneList(Genes).Product)
            If Left(GeneList(Genes).Product, 9) = "/product=" Then
                GeneList(Genes).Product = Mid$(GeneList(Genes).Product, 10, Len(GeneList(Genes).Product))
            End If
            
            If (PosComplement > 0 And PosComplement < PosDot) Or (PosJoin > 0 And PosJoin < PosDot) Then

                If PosComplement > PosDot And PosJoin > PosDot Then
                    VarX = Mid$(VarString$, PosDot - 6, 6)
                    VarX = Trim(VarX)
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    GeneList(Genes).Start = CDbl(VarX)
                    
                    
                    'Mid$(VarString$, PosDot + 2, 6)
                    VarX = Mid$(VarString$, PosDot + 2, 6)
                    VarX = Trim(VarX)
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    
                    
                    GeneList(Genes).End = CDbl(VarX)
                    GeneList(Genes).Orientation = 1
                ElseIf PosComplement > 0 And PosComplement < PosDot And (PosJoin > PosDot Or PosJoin = 0) Then
                    GeneList(Genes).Orientation = 2
                    
                    
                    VarX = Mid$(VarString$, PosComplement + 11, PosDot - PosComplement - 11)
                    VarX = Trim(VarX)
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    
                    GeneList(Genes).End = CDbl(VarX)
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    
                    VarX = Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2)
                    VarX = Trim(VarX)
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    
                    GeneList(Genes).Start = CDbl(VarX)
                    x = x
                ElseIf PosJoin > 0 And (PosComplement > PosDot Or PosComplement = 0) And PosJoin < PosDot Then
'                    If Genes = 4 Then
'                    X = X
'                    End If
                    
                    GeneList(Genes).Orientation = 1
                    VarX = Mid$(VarString$, (PosJoin + 5), (PosDot - PosJoin - 5))
                    VarX = Trim(VarX)
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    GeneList(Genes).Start = CDbl(VarX)
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    VarX = Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2)
                    VarX = Trim(VarX)
                    
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    
                    GeneList(Genes).End = CDbl(VarX)
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop
'                    XX = CurDir
'                    Open "output.txt" For Output As #1
'                    Print #1, VarString
'                    Close #1
                    
                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1
                    
                    For x = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 1
                        
                        VarX = Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1)
                        VarX = Trim(VarX)
                        
                        
                        If Left(VarX, 1) = "<" Then
                            VarX = Right(VarX, Len(VarX) - 1)
                        ElseIf Left(VarX, 1) = ">" Then
                            VarX = Right(VarX, Len(VarX) - 1)
                        End If
                        
                        GeneList(Genes).Start = CDbl(VarX)
                        
                        If x = IntronNo Then
                            VarX = Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2)
                            VarX = Trim(VarX)
                            
                            
                            If Left(VarX, 1) = "<" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            ElseIf Left(VarX, 1) = ">" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            End If
                            PosComma = InStr(1, VarX, ",", vbBinaryCompare)
                            If PosComma = 0 Then
                                GeneList(Genes).End = CDbl(VarX)
                            Else
                                GeneList(Genes).End = CDbl(Left(VarX, PosComma - 1))
                                
                            End If
                            
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)
                            If PosComma - PosDot - 2 > 0 Then
                                VarX = Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2)
                                VarX = Trim(VarX)
                            
                            End If
                            If Left(VarX, 1) = "<" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            ElseIf Left(VarX, 1) = ">" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            End If
                            PosComma = InStr(1, VarX, ")", vbBinaryCompare)
                            If PosComma = 0 Then
                                GeneList(Genes).End = CDbl(VarX)
                            Else
                                GeneList(Genes).End = CDbl(Left(VarX, PosComma - 1))
                            End If
                            x = x
                        End If
                        
                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo
                        If GeneList(Genes).Start = GeneList(Genes - 1).End Then 'i.e. it is a frameshift
'                            Genes = Genes - 1
'                            GeneList(Genes).End = GeneList(Genes + 1).End
'                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
'                            IntronNo = IntronNo - 1
'                            ExonNo = ExonNo - 1
                        ElseIf GeneList(Genes).Start < GeneList(Genes - 1).Start Then
                            GeneList(Genes).IntronFlag = 0
                            Genes = Genes - 1
                            GeneList(Genes).End = GeneList(Genes + 1).End
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            IntronNo = IntronNo - 1
                            ExonNo = ExonNo - 1
                        End If

                    Next 'X

                ElseIf PosComplement > 0 And PosJoin > 0 And PosComplement < PosDot And PosJoin < PosDot Then
'                    If Genes = 4 Then
'                    X = X
'                    End If
                    
                    GeneList(Genes).Orientation = 2
                    
                    VarX = Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5)
                    VarX = Trim(VarX)
                    
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    GeneList(Genes).End = CDbl(VarX)
                    PosBracket = InStr(PosDot, VarString$, "))", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    
                    
                    VarX = Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2)
                    VarX = Trim(VarX)
                    
                    
                    If Left(VarX, 1) = "<" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    ElseIf Left(VarX, 1) = ">" Then
                        VarX = Right(VarX, Len(VarX) - 1)
                    End If
                    GeneList(Genes).Start = CDbl(VarX)
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For x = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 2
                        
                        VarX = Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1)
                        VarX = Trim(VarX)
                        
                        
                        If Left(VarX, 1) = "<" Then
                            VarX = Right(VarX, Len(VarX) - 1)
                        ElseIf Left(VarX, 1) = ">" Then
                            VarX = Right(VarX, Len(VarX) - 1)
                        End If
                        
                        
                        GeneList(Genes).End = CDbl(VarX)

                        If GeneList(Genes - 1).Start = GeneList(Genes).End Then 'it is a frameshift
                             
'                            Genes = Genes - 1
'
'                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
'                            ExonNo = ExonNo - 1
'                            IntronNo = IntronNo - 1
'
'                            VarX = Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2)
'                            VarX = Trim(VarX)
'
'
'                            If Left(VarX, 1) = "<" Then
'                                VarX = Right(VarX, Len(VarX) - 1)
'                            ElseIf Left(VarX, 1) = ">" Then
'                                VarX = Right(VarX, Len(VarX) - 1)
'                            End If
'
'                            GeneList(Genes).Start = CDbl(VarX)
                        ElseIf GeneList(Genes).End < GeneList(Genes - 1).End Then
                            
                            GeneList(Genes).End = GeneList(Genes - 1).End
                            Genes = Genes - 1
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            ExonNo = ExonNo - 1
                            IntronNo = IntronNo - 1
                            
                            VarX = Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2)
                            VarX = Trim(VarX)
                            
                            
                            If Left(VarX, 1) = "<" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            ElseIf Left(VarX, 1) = ">" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            End If
                        
                            GeneList(Genes).Start = CDbl(VarX)
                            x = x
                        End If

                        If x = IntronNo Then
                            
                            VarX = Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2)
                            VarX = Trim(VarX)
                            
                            
                            If Left(VarX, 1) = "<" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            ElseIf Left(VarX, 1) = ">" Then
                                VarX = Right(VarX, Len(VarX) - 1)
                            End If
                            GeneList(Genes).Start = CDbl(VarX)
                            x = x
                        Else
                            oposcomma = PosComma
                            PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                            PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                            If PosBracket < PosComma And PosBracket > 0 Then
                                PosComma = PosBracket
                            End If
                            If PosComma > 0 Then
                                VarX = Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2)
                                VarX = Trim(VarX)
                                
                                
                                If Left(VarX, 1) = "<" Then
                                    VarX = Right(VarX, Len(VarX) - 1)
                                ElseIf Left(VarX, 1) = ">" Then
                                    VarX = Right(VarX, Len(VarX) - 1)
                                End If
                                GeneList(Genes).Start = CDbl(VarX)
                                x = x
                            End If

                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo
                    Next 'X

                End If

            Else
                
                
                VarX = Mid$(VarString$, PosDot - 6, 6)
                VarX = Trim(VarX)
                If Left(VarX, 1) = "<" Then
                    VarX = Right(VarX, Len(VarX) - 1)
                ElseIf Left(VarX, 1) = ">" Then
                    VarX = Right(VarX, Len(VarX) - 1)
                End If
                
                
                GeneList(Genes).Start = CDbl(VarX)
                'xxxx = Mid$(VarString$, PosDot + 2, 100)
                VarX = Mid$(VarString$, PosDot + 2, 6)
                VarX = Trim(VarX)
                If Left(VarX, 1) = "<" Then
                    VarX = Right(VarX, Len(VarX) - 1)
                ElseIf Left(VarX, 1) = ">" Then
                    VarX = Right(VarX, Len(VarX) - 1)
                End If
                GeneList(Genes).End = CDbl(VarX)
                GeneList(Genes).Orientation = 1
            End If

        Else
            Exit Do
        End If
        'XX = GeneList(Genes).Name
    Loop
    
    
    'Make sure all entries in genelist have unique names
    Dim NumMatch As Long
    For x = 0 To Genes
        NumMatch = 1
        If GeneList(x).Name = "" And GeneList(x).Product <> "" Then
            GeneList(x).Name = GeneList(x).Product + " ORF"
        ElseIf GeneList(x).Name = "" Then 'And GeneList(x).ExonNumber = 1 Then
            
        End If
        For Y = x + 1 To Genes
            If GeneList(Y).Name = "" And GeneList(Y).Product <> "" Then
                GeneList(Y).Name = GeneList(Y).Product + " ORF"
            ElseIf GeneList(Y).Name = "" And GeneList(Y).ExonNumber > 1 Then
                If Y > 0 Then
                    If GeneList(Y).Product = "" Then
                        GeneList(Y).Product = GeneList(Y - 1).Product
                    End If
                    If GeneList(Y).Name = "" Then
                        GeneList(Y).Name = Trim(GeneList(Y - 1).Name) + " exon " + Trim(Str(GeneList(Y).ExonNumber))
                    End If
                End If
                
            End If
            If GeneList(x).Name = GeneList(Y).Name Then
                GeneList(Y).Name = GeneList(Y).Name + Trim(Str(NumMatch))
                NumMatch = NumMatch + 1
                
            End If
        Next Y
    Next x
    
'XX = GeneList(20).Start
'XX = GeneList(21).Start
'XX = GeneList(20).End
'XX = GeneList(21).End
'XX = GeneList(18).IntronFlag
'XX = GeneList(19).IntronFlag
'XX = GeneList(1).ExonNumber
'XX = GeneList(2).ExonNumber
'XX = GeneList(1).Name
'XX = GeneList(2).Name
'XX = GeneList(1).Product
'XX = GeneList(2).Product

XX = GeneList(1).Name
    GeneNumber = Genes
    
    If ORFFlag = 1 And SilentGBFlag = 0 Then Call HomologyWindow

    
    Pos = InStr(LastPos, VarString$, "BASE COUNT", vbBinaryCompare)

    If Pos > 0 Then
        Pos = InStr(LastPos, VarString$, "ORIGIN", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(LastPos, VarString$, "origin", vbBinaryCompare)
    Else
        'Give a message if the file is not a DNA file
        Pos = InStr(LastPos, VarString$, "ORIGIN", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(LastPos, VarString$, "origin", vbBinaryCompare)
    End If
    
    Close #FF
    Dim RefSeq As String, posBS As Long, CharS As String, PartSeq As String
    Dim PosOrigin As Long
    
    ReDim ORFWin(3, LSeq)
    
    If SilentGBFlag = 1 Then
        
        Pos = 1
        'find last posorigin
        Do While Pos > 0
            Pos = InStr(Pos + 1, VarString, "origin", vbTextCompare)
            If Pos > 0 Then
                PosOrigin = Pos
            Else
                Exit Do
            End If
        Loop
        If PosOrigin = 0 Then
            If SilentGBFlag = 0 Then
                Dummy = MsgBox("I cannot find a valid sequence within this genbank file - The file may have been truncated during download")
                ORFFlag = 0
            Else
                AbortflagGB = 1
                Exit Sub
            End If
            Form1.Picture20.Visible = False
            Form1.Refresh
            Close #FF
            GeneNumber = 0
            Exit Sub
        End If
        'PosOrigin = InStr(1, VarString, "origin", vbTextCompare)
        posBS = InStr(PosOrigin, VarString, "//", vbBinaryCompare)
        If posBS = 0 Then posBS = Len(VarString)
        RefSeq = ""
        PartSeq = Mid$(VarString, PosOrigin + 6, posBS - PosOrigin)
        RefSeq = String(Len(PartSeq), " ")
        Y = 0
        PartSeq = UCase(PartSeq)
        For x = 1 To Len(PartSeq)
            CharS = Mid$(PartSeq, x, 1)
            If CharS = "A" Or CharS = "C" Or CharS = "G" Or CharS = "T" Then
                Y = Y + 1
                Mid$(RefSeq, Y, 1) = CharS
            End If
         
        Next x
        
        RefSeq = Trim(RefSeq)
        'XX = Len(RefSeq)
    Else
    
        Open FName$ For Input Access Read As #FF
        'XX = LOF(FF)
        Line Input #FF, TempString
        If Len(TempString) > LOF(FF) * 0.5 Then
            Call ReformatFile(FF, TempString, SaveFlag)
        End If
        Do While Not EOF(FF)
            Line Input #FF, TempString
    
            If Trim$(Mid$(TempString, 1, 12)) = "BASE COUNT" Then
                Line Input #FF, TempString
    
                If Trim$(TempString) = "ORIGIN" Then
                    Exit Do
                End If
            ElseIf Trim$(TempString) = "ORIGIN" Or Trim$(TempString) = "origin" Or Trim$(TempString) = "Origin" Then
                    Exit Do
                
            End If
    
        Loop
    

        'Line Input #1, TempString

         

        RefSeq = ""
        
        Do While Not EOF(FF)
            Line Input #FF, TempString
    
            If Trim$(TempString) = "//" Then
                Exit Do
            End If
    
            For x = 1 To 6
                RefSeq = RefSeq + Mid$(TempString, x * 10 + x, 10)
            Next 'X
    
        Loop
        Close #FF
    End If
    Dim ORFSeq() As String
    
    
    RefSeq = UCase$(RefSeq)
    
    
    'find winseq
    If SilentGBFlag = 1 Or x = x Then
        Dim HitsToRefseq() As Long, TestSeq As String, MaxRefHits As Long, CheckSize As Long, CheckStep As Long, SegAdjust() As Long
        If ReassortmentFlag = 1 Then
            ReDim SegAdjust(RBPNum)
            For x = 1 To RBPNum - 1
                SegAdjust(x) = RBPPos(x + 1) - RBPPos(x)
                If SegAdjust(x) < Len(RefSeq) Then SegAdjust(x) = Len(RefSeq)
            Next x
        Else
            ReDim SegAdjust(1)
        End If
        
        Dim Segment() As Long
        ReDim Segment(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            
            For x = 1 To RBPNum - 1
                For Y = RBPPos(x) To RBPPos(x + 1)
                    Segment(Y) = x
                Next Y
            Next x
            
        Else
            For Y = 1 To Len(StrainSeq(0))
                Segment(Y) = 1
            Next Y
        End If
        
        
        If ReassortmentFlag = 0 Then
            CheckSize = Log(Len(StrainSeq(0)) * 10) / Log(4#)
            'XX = Log(30000) / Log(4#)
            If CheckSize > 20 Then
                CheckSize = 20
            ElseIf CheckSize < 8 Then
                CheckSize = 8
            End If
        Else
            CheckSize = 8
        End If
        'XX = 3000 / 500
        If ReassortmentFlag = 0 Then
            
            CheckStep = CLng(Len(StrainSeq(0)) / 100)
        Else
            CheckStep = CLng(Len(RefSeq) / 100)
        
        End If
        
        If CheckStep < CheckSize Then
            CheckStep = CheckSize
        End If
        
        
        ReDim HitsToRefseq(NextNo)
        SS = Abs(GetTickCount)
        
        Dim SeqStep As Long
        
        If NextNo > 20 Then
            SeqStep = 20
        Else
            SeqStep = NextNo
        End If
        'it would be better to od the 50 mostt divergent
        'XX = Nextno
        
        Dim BigEnough() As Long, AZ As Long
        ReDim BigEnough(NextNo)
        Dim SegmentHit()  As Long
        
        If ReassortmentFlag = 1 Then
            ReDim SegmentHit(RBPNum, PermNextno)
        Else
            ReDim SegmentHit(1, PermNextno)
        End If
        
        Dim SegPos() As Long
        ReDim SegPos(Len(StrainSeq(0)))
        'Open "Seghits.txt" For Output As #1
        Dim Done() As Long, MaxLen As Long
        
        ReDim DoneX(NextNo)
        Dim PosHitQR() As Long, PosHitNum As Long
        
        
        If Len(RefSeq) > Len(StrainSeq(0)) Then
            MaxLen = Len(RefSeq)
        Else
            MaxLen = Len(StrainSeq(0))
        End If
        
        ReDim PosHitQR(1, MaxLen)
        PosHitNum = 0
        Dim TargetNum As Long, LongWin As Long
        If MaxLen > 32000 Then
            TargetNum = 1
        Else
            TargetNum = SeqStep
        End If
        For AZ = 1 To TargetNum
            x = ORFRefList(AZ)
            LongWin = x
            If x > UBound(DoneX, 1) Then
                ReDim Preserve DoneX(x + 100)
            End If
            If DoneX(x) = 0 Then
                DoneX(x) = 1
        '        If X = 197 Then
        '            X = X
        '        End If
                'strip gaps
                Z = 0
                TestSeq = String(Len(StrainSeq(0)), " ")
                For Y = 1 To Len(StrainSeq(0))
                    If Mid$(StrainSeq(x), Y, 1) <> "-" Then
                        Z = Z + 1
                        Mid$(TestSeq, Z, 1) = Mid$(StrainSeq(x), Y, 1)
                        SegPos(Z) = Segment(Y)
                    
                    End If
                Next Y
                BigEnough(x) = Z
                
                TestSeq = Trim(TestSeq)
    
                For Y = 1 To Len(TestSeq) - CheckSize Step CheckStep
                    'XX = Mid(TestSeq, Y, 10)
                    Pos = 1
                    'XX = Len(RefSeq)
                    Do While Pos > 0
                        Pos = InStr(Pos + 1, RefSeq, Mid$(TestSeq, Y, CheckSize), vbBinaryCompare)
                        If Pos > 0 Then
                            HitsToRefseq(x) = HitsToRefseq(x) + 1
                            SegmentHit(SegPos(Y), x) = SegmentHit(SegPos(Y), x) + 1
                            PosHitNum = PosHitNum + 1
                            PosHitQR(1, PosHitNum) = Y
                            PosHitQR(0, PosHitNum) = Pos
                            'Print #1, Mid$(TestSeq, Y, CheckSize)
                        End If
                    Loop
                Next Y
            End If
        Next AZ
        'Close #1
        
        If MaxLen > 32000 Then
            Dim MatchBin() As Long, NewPosInBin As Long, WinBin As Long, BiggestBin As Long, NumEntries As Long, TotEntries As Long, AvEntries As Long
            Dim BreakPositions() As Long, NumSegments As Long, SegmentLen As Long
            ReDim MatchBin(CLng(MaxLen / 50) + 50)
            For Y = 1 To PosHitNum
                NewPosInBin = CLng(CLng(Abs(PosHitQR(0, Y) - PosHitQR(1, Y))) / 50)
'                If NewPosInBin > 10 Then
'                    X = X
'                End If
                MatchBin(NewPosInBin) = MatchBin(NewPosInBin) + 1
            Next Y
            'how many matchwin values are non-negative
            NumEntries = 0
            For Y = 0 To CLng(MaxLen / 50)
                If MatchBin(Y) > 0 Then
                    NumEntries = NumEntries + 1
                    TotEntries = TotEntries + MatchBin(Y)
                    If MatchBin(Y) > BiggestBin Then
                        BiggestBin = MatchBin(Y)
                        WinBin = Y
                    End If
                End If
            Next Y
            AvEntries = TotEntries / NumEntries
            NumSegments = CLng(MaxLen / 10000)
            ReDim BreakPositions(NumSegments)
            SegmentLen = 10000
            Dim DistToBreakPositions As Long
            For Y = 0 To NumSegments
                BreakPositions(Y) = Y * SegmentLen + 1
                x = x
            Next Y
            Dim BestMatchPos As Long, BestMatch() As Long, BestMatchVal() As Single, tMatch As Single, WinMatch() As Long, MBV As Long
            ReDim BestMatch(NumSegments), BestMatchVal(NumSegments)
            For Z = 0 To NumSegments
                BestMatchVal(Z) = MaxLen
            Next Z
            For Y = 1 To PosHitNum
                MBV = MatchBin(CLng(CLng(Abs(PosHitQR(0, Y) - PosHitQR(1, Y))) / 50))
                If MBV > AvEntries Then
                    
                    For Z = 0 To NumSegments
                        tMatch = Abs(BreakPositions(Z) - PosHitQR(1, Y)) / MBV
                        If tMatch < BestMatchVal(Z) Then
                            BestMatchVal(Z) = tMatch
                            BestMatch(Z) = Y
                        End If
                    Next Z
                End If
            Next Y
'            For Z = 0 To NumSegments
'                XX = BestMatchVal(Z)
'                XX = BestMatch(Z)
'                XX = PosHitQR(0, BestMatch(Z))
'                XX = PosHitQR(1, BestMatch(Z))
'                'XX = MatchBin(0)
'            Next Z
        Else
            NumSegments = 1
            'do other arrays for the 1 segment case
        End If
        
        
        EE = Abs(GetTickCount)
        TT = EE - SS '4000
        x = x
        Dim ExpectHits As Single
        'XX = GeneNumber
        If ReassortmentFlag = 0 Then
            ExpectHits = Len(StrainSeq(0)) / CheckStep 'number of checks
            ExpectHits = (1 / (4 ^ CheckSize)) * Len(RefSeq) * ExpectHits 'approximate probablilty of a hit*length of the refseq*number of checks
            'Len(RefSeq)
'            If Len(StrainSeq(0)) < Len(RefSeq) Then
'
'                ExpectHits = ((0.75 ^ CheckSize) * ExpectHits)
'
'            Else
'
'                ExpectHits = Len(RefSeq) / CheckStep
'                ExpectHits = ((0.75 ^ CheckSize) * ExpectHits)
'            End If
        Else
            ExpectHits = Len(StrainSeq(0)) / CheckStep 'number of checks
            ExpectHits = (1 / (4 ^ CheckSize)) * Len(RefSeq) * ExpectHits 'approximate probablilty of a hit*length of the refseq*number of checks
'            ExpectHits = Len(RefSeq) / CheckStep
'            'ExpectHits = ExpectHits / 4
'            ExpectHits = ((0.75 ^ CheckSize) * ExpectHits)
        End If
        If ExpectHits < 2 Then ExpectHits = 2
        Dim MaxSize As Long
        MaxSize = 0
        For AZ = 1 To SeqStep
            x = ORFRefList(AZ)
            If MaxSize < BigEnough(x) Then
                MaxSize = BigEnough(x)
                
            End If
        Next AZ
        For AZ = 1 To SeqStep
            x = ORFRefList(AZ)
            If BigEnough(x) > 0 And BigEnough(x) < MaxSize * 0.8 Then
'                If HitsToRefseq(X) > 0 Then
'                    X = X
'                End If
                HitsToRefseq(x) = 0
                
            End If
        Next AZ
        
        
        WinSeq = -1
        MaxHits = 0
        MaxRefHits = 0
        For AZ = 1 To SeqStep
            x = ORFRefList(AZ)
            If MaxHits < HitsToRefseq(x) Then
                MaxHits = HitsToRefseq(x)
                WinSeq = x
            End If
        Next AZ
        
        If MaxLen > 32000 Then
            WinSeq = ORFRefList(1)
        End If
        'ExpectHits = ExpectHits * 6
        'X = X
        
        If ((((ExpectHits - MaxHits) ^ 2) / ExpectHits) < 1.96 And ReassortmentFlag = 0) Or WinSeq = -1 Or MaxHits = 0 Then
            
        
            If RDPLGBFlag = 0 And SilentGBFlag = 0 Then
                Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
            End If
            If SilentGBFlag = 0 Then
                
                ORFFlag = 0
            End If
            Form1.Picture20.Visible = False
            Form1.Refresh
            Close #FF
            GeneNumber = 0
            Exit Sub
        End If
        
        'Make an alignment between refseq and winseq
        
        Dim SeqsIn() As Integer, SeqsOut() As Integer, MaxLen2 As Long
        If Len(StrainSeq(0)) > 32000 Or Len(RefSeq) > 32000 Then
            CircularFlagX = 0
        End If
        If Len(RefSeq) <= Len(StrainSeq(0)) Then
            If CircularFlagX = 1 Then
                ReDim SeqsIn(Len(StrainSeq(0)) * 3, 1), SeqsOut(Len(StrainSeq(0)) * 4, 1)
            Else
                ReDim SeqsIn(Len(StrainSeq(0)) * 2, 1), SeqsOut(Len(StrainSeq(0)) * 3, 1)
            End If
        
        Else
            If CircularFlagX = 1 Then
                ReDim SeqsIn(Len(RefSeq) * 3, 1), SeqsOut(Len(RefSeq) * 4, 1)
            Else
                ReDim SeqsIn(Len(RefSeq) * 2, 1), SeqsOut(Len(RefSeq) * 3, 1)
            End If
        End If
        
        
        Z = 0
        Dim WinSeg As Long, MaxSeg As Single, WSSS() As Long, TotSpace As Long
        ReDim WSSS(Len(StrainSeq(0)))
        TotSpace = 0
        'stores gap locations
        Dim NucCount() As Long
        
        For x = 1 To Len(StrainSeq(0))
           If SeqNum(x, WinSeq) = 46 Then
            TotSpace = TotSpace + 1
            WSSS(x) = TotSpace
           End If
        Next x
        Dim TBTA() As Long
        ReDim TBTA(Len(StrainSeq(0)))
        If ReassortmentFlag = 0 Then
            Y = 1
            For x = 1 To Len(StrainSeq(0))
               If SeqNum(x, WinSeq) <> 46 Then
               '     Z = Z + 1
                    SeqsIn(Y, 1) = SeqNum(x, WinSeq)
                    TBTA(Y) = x
                    Y = Y + 1
                Else
                    ReDim NucCount(100)
                    For AA = 0 To NextNo
                        NucCount(SeqNum(x, AA)) = NucCount(SeqNum(x, AA)) + 1
                    Next AA
                   ' XX = SeqNum(14225, 1)
                    If NucCount(66) > NucCount(68) And NucCount(66) > NucCount(72) And NucCount(66) > NucCount(85) And (NucCount(66) / NextNo) > 0.25 Then
                        SeqsIn(Y, 1) = 66
                        TBTA(Y) = x
                        Y = Y + 1
                    ElseIf NucCount(68) > NucCount(66) And NucCount(68) > NucCount(72) And NucCount(68) > NucCount(85) And NucCount(68) / NextNo > 0.25 Then
                        SeqsIn(Y, 1) = 68
                        TBTA(Y) = x
                        Y = Y + 1
                    ElseIf NucCount(72) > NucCount(68) And NucCount(72) > NucCount(66) And NucCount(72) > NucCount(85) And NucCount(72) / NextNo > 0.25 Then
                        SeqsIn(Y, 1) = 72
                        TBTA(Y) = x
                        Y = Y + 1
                    ElseIf NucCount(85) > NucCount(68) And NucCount(85) > NucCount(72) And NucCount(85) > NucCount(66) And NucCount(85) / NextNo > 0.25 Then
                        SeqsIn(Y, 1) = 85
                        TBTA(Y) = x
                        Y = Y + 1
                    End If
               End If
            Next x
            x = x
        Else
            MaxSeg = -1
            For x = 1 To RBPNum - 1
                If SegmentHit(x, WinSeq) / SegAdjust(x) > MaxSeg Then
'                    XX = MaxHits
                    MaxSeg = SegmentHit(x, WinSeq) / SegAdjust(x)
                    WinSeg = x ' 10, 1, 3,11,11,11, 7, 6, 1, 8
                                '10, 5, 3, 9, 8x, 4, 7, 6, 1, 8
                                '10, 6, 3, 8, 2, 4, 7, 9, 1, x(5)
                End If
            Next x
            'WinSeg = 5
            'XX = RBPPos(1) '3972 -7230
'            XX = SegAdjust(WinSeg)
'            XX = SegmentHit(WinSeg, WinSeq)
            'WinSeg = 2
            Y = 1
            For x = RBPPos(WinSeg) To RBPPos(WinSeg + 1) - 1
               If SeqNum(x, WinSeq) <> 46 Then
                    SeqsIn(Y, 1) = SeqNum(x, WinSeq)
                    TBTA(Y) = x
                    Y = Y + 1
               Else
                    ReDim NucCount(100)
                    For AA = 0 To NextNo
                        NucCount(SeqNum(x, AA)) = NucCount(SeqNum(x, AA)) + 1
                    Next AA
                   ' XX = SeqNum(14225, 1)
                    If NucCount(66) > NucCount(68) And NucCount(66) > NucCount(72) And NucCount(66) > NucCount(85) And (NucCount(66) / NextNo) > 0.25 Then
                        SeqsIn(Y, 1) = 66
                        TBTA(Y) = x
                        Y = Y + 1
                    ElseIf NucCount(68) > NucCount(66) And NucCount(68) > NucCount(72) And NucCount(68) > NucCount(85) And NucCount(68) / NextNo > 0.25 Then
                        SeqsIn(Y, 1) = 68
                        TBTA(Y) = x
                        Y = Y + 1
                    ElseIf NucCount(72) > NucCount(68) And NucCount(72) > NucCount(66) And NucCount(72) > NucCount(85) And NucCount(72) / NextNo > 0.25 Then
                        SeqsIn(Y, 1) = 72
                        TBTA(Y) = x
                        Y = Y + 1
                    ElseIf NucCount(85) > NucCount(68) And NucCount(85) > NucCount(72) And NucCount(85) > NucCount(66) And NucCount(85) / NextNo > 0.25 Then
                        SeqsIn(Y, 1) = 85
                        TBTA(Y) = x
                        Y = Y + 1
                    End If
               End If
               
            Next x
            Dim LenCurSeg  As Long
            LenCurSeg = Y - 1
        End If
        If ReassortmentFlag = 1 Then
            If Abs(DoneSegment(WinSeg)) > SegmentHit(WinSeg, WinSeq) Then
                If SilentGBFlag = 0 Then
                    ORFFlag = 0
                End If
                Form1.Picture20.Visible = False
                Form1.Refresh
                Close #FF
                GeneNumber = 0
                Exit Sub
            
            End If
            If DoneSegment(WinSeg) <> 0 Then
                RemoveSegment(LastSegment(WinSeg)) = 1
            End If
            LastSegment(WinSeg) = CurSegment
        End If
        Dim SplitOff As Long
        If CircularFlagX = 0 Or ReassortmentFlag = 1 Then
        
            For x = 1 To Len(RefSeq)
                'XX = SeqsIn(X, 1)
                SeqsIn(x, 0) = Asc(Mid$(RefSeq, x, 1)) + 1
                'X = X
            Next x
            SplitOff = 0
        Else
            
            
            SplitOff = CLng(Len(RefSeq) / 2)
            Y = 0
            For x = SplitOff To Len(RefSeq)
                Y = Y + 1
                SeqsIn(Y, 0) = Asc(Mid$(RefSeq, x, 1)) + 1
            Next x
            For x = 1 To Len(RefSeq)
                Y = Y + 1
                SeqsIn(Y, 0) = Asc(Mid$(RefSeq, x, 1)) + 1
            Next x
            For x = 1 To SplitOff
                Y = Y + 1
                
                SeqsIn(Y, 0) = Asc(Mid$(RefSeq, x, 1)) + 1
            Next x
            SplitOff = (Len(RefSeq) - SplitOff) + 1 'need this to ensure that we know where the 1st nt of the original refseq is.
        End If
        
        
        
        If CircularFlagX = 1 And ReassortmentFlag = 0 Then
            
        
            If Len(StrainSeq(0)) > Len(RefSeq) Then
                MaxLen2 = Len(StrainSeq(0)) * 2
            Else
                MaxLen2 = Len(RefSeq) * 2
            End If
        Else
            If ReassortmentFlag = 1 Then
                If LenCurSeg < Len(RefSeq) Then
                    MaxLen2 = Len(RefSeq)
                Else
                    MaxLen2 = LenCurSeg
                End If
                
            Else
                If Len(StrainSeq(0)) > Len(RefSeq) Then
                    MaxLen2 = Len(StrainSeq(0))
                Else
                    MaxLen2 = Len(RefSeq)
                End If
            End If
        End If
        SS = Abs(GetTickCount)
        
        If CircularFlagX = 1 And ReassortmentFlag = 0 Then
            OKToResizeF1 = 1
            Call doAlignmentSh(UFTag + "LGB", 0, SeqsIn(), SeqsOut(), 1, MaxLen2, 10, 5, 0)
            OKToResizeF1 = 0
        Else
            If ReassortmentFlag = 1 Then
                OKToResizeF1 = 1
                Call doAlignmentSh(UFTag + "LGB", 1, SeqsIn(), SeqsOut(), 1, MaxLen2, 10, 5, 0)
                OKToResizeF1 = 0
            Else
                If NumSegments < 3 Then
                    If Len(StrainSeq(0)) > Len(RefSeq) / 2 Then
                        OKToResizeF1 = 1
                        Call doAlignmentSh(UFTag + "LGB", 1, SeqsIn(), SeqsOut(), 1, MaxLen2, 10, 5, 0)
                        OKToResizeF1 = 0
                    Else
                        OKToResizeF1 = 1
                        Call doAlignmentSh(UFTag + "LGB", 0, SeqsIn(), SeqsOut(), 1, MaxLen2, 10, 5, 0)
                        OKToResizeF1 = 0
                    End If
                Else
                    Dim tSeqsIn() As Integer, tSeqsOut() As Integer, Spos(1) As Long, Epos(1) As Long, LastPosX(1) As Long, b As Long
                    Spos(0) = 1: Spos(1) = 1
                    LastPosX(0) = 1: LastPosX(1) = 1
                    For Y = 1 To NumSegments
                        Epos(0) = PosHitQR(0, BestMatch(Y))
                        Epos(1) = PosHitQR(1, BestMatch(Y))
                        If Epos(0) < Spos(0) Or Epos(1) < Spos(0) Then
                            Epos(0) = UBound(SeqsIn, 1)
                            Epos(1) = Epos(0)
                        End If
                        ReDim tSeqsIn(UBound(SeqsIn, 1), 1), tSeqsOut(UBound(SeqsOut, 1), 1)
                        For A = 0 To 1
                            b = 0
                            For Z = Spos(A) To Epos(A)
                                b = b + 1
                                tSeqsIn(b, A) = SeqsIn(Z, A)
                            Next Z
                        Next A
                        OKToResizeF1 = 1
                        Call doAlignmentSh(UFTag + "LGB", 0, tSeqsIn(), tSeqsOut(), 1, MaxLen2, 10, 5, 0)
                        OKToResizeF1 = 0
                        'XX = Mid$(RefSeq, EPos(0), 10)
                        For A = 0 To 1
                            For Z = 0 To UBound(tSeqsOut, 1)
                                If tSeqsOut(Z, A) > 0 Then
                                    SeqsOut(LastPosX(A), A) = tSeqsOut(Z, A)
                                    LastPosX(A) = LastPosX(A) + 1
                                End If
                            Next Z
                        Next A
                        If Epos(0) = UBound(SeqsIn, 1) Then Exit For
                        Spos(0) = Epos(0) + 1
                        Spos(1) = Epos(1) + 1
                    Next Y
                End If
            End If
        End If
                                '10, 5, 3, 9,8x , 4, 7, 6,1 , 8
                                '10, 6, 3, 8, 2, 4, 7, 9, 1, x(5)
        
        
        'work out hamming distance
        Dim ValidNo As Long, ValidDiffs As Long
        ValidDiffs = 0
        ValidNo = 0
        For x = 1 To MaxLen2
            If SeqsOut(x, 0) <> 0 And SeqsOut(x, 1) <> 0 Then
                If SeqsOut(x, 0) <> 46 And SeqsOut(x, 1) <> 46 Then
                    ValidNo = ValidNo + 1
                    If SeqsOut(x, 0) <> SeqsOut(x, 1) Then
                        ValidDiffs = ValidDiffs + 1
                    End If
                    
                End If
            End If
        Next x
        
        
        If ValidNo = 0 Then Exit Sub
        If (ValidDiffs / ValidNo) > 0.45 Then
            
            
        
            If RDPLGBFlag = 0 And SilentGBFlag = 0 Then
                Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
            End If
            If SilentGBFlag = 0 Then
                
                ORFFlag = 0
            End If
            Form1.Picture20.Visible = False
            Form1.Refresh
            Close #FF
            GeneNumber = 0
            Exit Sub
        End If
        
        XX = WinSeg
        
        'Call doAlignmentSh(UFTag,1, SeqsIn(), SeqsOut(), 1, MaxLen2, 10, 5, 0)
'        EE = abs(gettickcount)
'        TT = EE - SS '146438 (muscle - 54906)
'        X = X
        Dim UBSO As Long, RefToalign() As Long, TestToAlign() As Long
        
        UBSO = UBound(SeqsOut, 1)
        ReDim RefToalign(UBSO), TestToAlign(UBSO)
        
        Dim ZStart As Long
        
        If ReassortmentFlag = 0 Then
            ZStart = 0
        Else
            ZStart = 0
            For x = 1 To RBPPos(WinSeg) - 1
                If SeqsIn(x, 1) > 46 Then
                    ZStart = ZStart + 1
                End If
            Next x
            
        End If
        
        Z = 0
        If WinSeq > UBound(SeqNum, 2) Then Exit Sub
        
        
        
        If ReassortmentFlag = 0 Then
            For x = 1 To Len(StrainSeq(0))
               If SeqsIn(x, 1) <> 46 Then
                   Z = Z + 1
                   TestToAlign(Z) = x
                Else
                x = x
                End If
                
               'End If
            Next x
        Else
        
            For x = 1 To Len(StrainSeq(0))
               If SeqsIn(x, 1) <> 46 Then
                   Z = Z + 1
                   TestToAlign(Z) = x
                End If
                
               'End If
            Next x
        
        End If
        Y = 0
        Z = ZStart
        Dim UBTTA As Long
        UBTTA = UBound(TestToAlign, 1)
        For x = 1 To UBSO
           If SeqsOut(x, 0) <> 46 Then
                Y = Y + 1
           End If
           If SeqsOut(x, 1) <> 46 Then
                Z = Z + 1
           End If
'           If Y = 21563 Then
'            x = x
'           End If
           'XX = SeqSpaces(21563, WinSeq)
            If Z <= UBTTA And Y <= UBTTA Then
                If TestToAlign(Z) <= UBound(TBTA) Then
                    RefToalign(Y) = TBTA(TestToAlign(Z)) '4581=4658
               
                End If
                
            End If
        Next x
        '21563 is the correct answer
'
        x = x
'        If ReassortmentFlag = 1 Then
'            For X = 1 To RBPPos(WinSeg)
'                If RefToalign(X) > 0 Then
'                    X = X
'                End If
'                RefToalign(X) = RBPPos(WinSeg)
'
'
'            Next X
'            For X = RBPPos(WinSeg - 1) To UBound(RefToalign)
'                RefToalign(X) = RBPPos(WinSeg + 1)
'
'
'            Next X
'
'        End If
        
        If CircularFlagX = 1 And ReassortmentFlag = 0 Then
            Dim LRS As Long
            LRS = Len(RefSeq)
            For x = 1 To LRS
                If RefToalign(x) = 0 And RefToalign(x + LRS) > 0 Then
                    RefToalign(x) = RefToalign(x + LRS)
                ElseIf RefToalign(x) > 0 And RefToalign(x + LRS) = 0 Then
                    RefToalign(x + LRS) = RefToalign(x)
                End If
            Next x
        ElseIf ReassortmentFlag = 0 Then
            LRS = Len(RefSeq)
            For x = Y + 1 To LRS
                If Y <= UBTTA Then
                    RefToalign(Y) = RBPPos(WinSeg + 1)
                Else
                    Exit For
                End If
            Next x
        End If
'        XX = RefToalign(10000)
'        ZZ = RBPPos(10000)
        'find leftbound and rightbound
        Z = 0
        For x = 1 To UBound(SeqsOut, 1)
            If SeqsOut(x, 0) > 46 Then
                Z = Z + 1
            End If
            If SeqsOut(x, 0) > 46 And SeqsOut(x, 1) > 46 Then
                LeftBound = Z
                Exit For
            End If
        Next x
        Z = Len(RefSeq) * 2 + 1
        For x = UBound(SeqsOut, 1) To 1 Step -1
            If SeqsOut(x, 0) > 46 Then
                Z = Z - 1
            End If
            If SeqsOut(x, 0) > 46 And SeqsOut(x, 1) > 46 Then
                
                For Z = x To 0 Step -1
                    If SeqsOut(Z, 0) <= 46 Then
                        x = x - 1
                    End If
                   
                
                Next Z
                RightBound = x
                Exit For
            End If
        Next x
        
        'sort out splitoff
'        If SplitOff > 0 Then
'            For X = SplitOff + 1 To UBound(RefToalign, 1)
'                RefToalign(X) = RefToalign(X - SplitOff)
'
'            Next X
'        End If
        Dim GLStart As Long, GLEnd As Long
        
        For x = 1 To GeneNumber
            If x = 31 Then
                x = x
            End If
            GLStart = GeneList(x).Start + SplitOff '+ 2
            GLEnd = GeneList(x).End + SplitOff '+ 2
            If x = x Then
                GoOn = 2
                'XX = CurDir
'                XX = GeneList(6).StartInAlign '2906,2906
'                XX = GeneList(6).EndInAlign '2651,2906
'                XX = GeneList(6).Start '2625,2468
'                XX = GeneList(6).End '1531,2211
                
                If GeneList(x).End > GeneList(x).Start Then
                    If GeneList(x).Orientation = 1 Then
                        If GLStart < LeftBound And GLEnd < LeftBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        ElseIf GLStart > RightBound And GLEnd > RightBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        ElseIf GLStart < LeftBound - 2 And GLEnd > RightBound + 2 Then
                            GoOn = 1
                        End If
                    Else
                        If GLStart < LeftBound And GLEnd > RightBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        ElseIf GLStart > RightBound Or GLEnd < LeftBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        End If
                    End If
                Else
                    If GeneList(x).Orientation = 2 Then
                        If GLStart < LeftBound And GLEnd < LeftBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        ElseIf GLStart > RightBound And GLEnd > RightBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        ElseIf GLStart > RightBound + 2 And GLEnd < LeftBound - 2 Then
                            GoOn = 1
                        End If
                    Else
                        If GLEnd < LeftBound And GLStart > RightBound Then
                            If (RefToalign(GLStart) = 0 Or RefToalign(GLStart) = LSeq) And (RefToalign(GLEnd) = 0 Or RefToalign(GLEnd) = LSeq) Then
                                GoOn = 0
                            End If
                        ElseIf GLStart < LeftBound - 2 Or GLEnd > RightBound + 2 Then
                            GoOn = 1
                        End If
                    End If
                End If
                
                If RefToalign(GLStart) = RefToalign(GLEnd) Then
                    GoOn = 0
                ElseIf RefToalign(GLEnd) = 0 Then
                    If GeneList(x).Start = 1 And GeneList(x).End = Len(RefSeq) Then
                       GoOn = 0
                    End If
                ElseIf GeneList(x).Start = 1 And GeneList(x).End = Len(RefSeq) Then
                    If GeneList(x).End - GeneList(x).Start > 10000 And (GeneList(x).End - GeneList(x).Start) > Len(RefSeq) * 0.9 Then
                       GoOn = 0
                    End If
                
                End If
                
                If GoOn = 0 Then
            
                    GeneList(x).StartInAlign = -1
                    GeneList(x).EndInAlign = -1
                ElseIf GoOn = 1 Then
                    GeneList(x).StartInAlign = 1
                    GeneList(x).EndInAlign = Len(StrainSeq(0))
                    If ReassortmentFlag = 1 Then
                        DoneSegment(WinSeg) = -SegmentHit(WinSeg, WinSeq)
                    End If
                Else
                    If x = 31 Then
                        x = x
                    End If
                    GeneList(x).StartInAlign = RefToalign(GLStart) '21563 is the correct answer
'
                   ' XX = RefToalign(20500)
                   ' GeneList(x).StartInAlign = GLStart + WSSS(RefToalign(GLStart)) '21563 is the correct answer
'                    XX = RefToalign(100)
'                    XX = TestToAlign(GLStart)
'                    XX = RefToalign(GLStart)
'                    XX = WSSS(GLStart)
'                    XX = WSSS(RefToalign(GLStart))
'                    XX = WSSS(TestToAlign(GLStart))
                    GeneList(x).EndInAlign = RefToalign(GLEnd)
                    If ReassortmentFlag = 1 Then
                        DoneSegment(WinSeg) = -SegmentHit(WinSeg, WinSeq)
                    End If
                End If
            Else
                GeneList(x).StartInAlign = RefToalign(GLStart)
                GeneList(x).EndInAlign = RefToalign(GLEnd)
                
                
                
                If GeneList(x).StartInAlign = 0 Then GeneList(x).StartInAlign = -1
                If GeneList(x).EndInAlign = 0 Then GeneList(x).EndInAlign = -1
                If GeneList(x).StartInAlign = Len(StrainSeq(0)) And GeneList(x).EndInAlign = Len(StrainSeq(0)) Then
                    GeneList(x).StartInAlign = -1
                    GeneList(x).EndInAlign = -1
                End If
            End If
        Next x
        

        
        x = x
    Else
    
        'Public Sub doAlignmentSh(UFTag,0,SeqsIn() As Integer, SeqsOut() As Integer, NumSeqs As Long, MaxLen As Long, GapO As Long, GapE As Long, GapReset As Long)
    
        
        
        
        
        
        
        GoOn = 1
        
        
        
        
        x = Int(Len(RefSeq) / 10)
        If x > LSeq Then x = 1
        Do While x < Len(RefSeq)
            ReDim ORFSeq(NextNo)
    
            Z = WinSeq
            Y = x
    
            Do Until Len(ORFSeq(Z)) = 20
    
                If SeqsIn(Y, 1) > 64 And SeqsIn(Y, 1) < 86 Then
                    ORFSeq(Z) = ORFSeq(Z) + Chr$((SeqsIn(Y, 1) - 1))
                End If
    
                Y = Y + 1
    
                If Y = LSeq Then
                    GoOn = 0
                    Exit Do
                End If
    
            Loop
    
            
            Y = WinSeq
                'PosMarker = Mid$(RefSeq, X, 40)
            Pos = 0
    
            If Len(ORFSeq(Y)) >= 10 Then Pos = InStr(1, RefSeq, ORFSeq(Y), vbBinaryCompare)
    
            If Pos > 0 Then
                LeftBound = Pos + x - 1
                RightBound = LeftBound + Len(StrainSeq(0))
                GoOn = 1
                Exit Do
            End If
            x = x + 30
        Loop
        
        If GoOn = 0 Then
             x = Int(Len(RefSeq) / 10)
            Do While x < Len(RefSeq)
                ReDim ORFSeq(NextNo)
                Z = WinSeq
                
                Y = x
    
                Do Until Len(ORFSeq(Z)) = 15
    
                    If SeqNum(Y, Z) > 64 And SeqNum(Y, Z) < 86 Then
                        ORFSeq(Z) = ORFSeq(Z) + Chr$((SeqNum(Y, Z) - 1))
                    End If
    
                    Y = Y + 1
    
                    If Y = LSeq Then
                        GoOn = 0
                        Exit Do
                    End If
    
                Loop
        
                
                Y = WinSeq
                
                Pos = 0
    
                If Len(ORFSeq(Y)) >= 10 Then Pos = InStr(1, RefSeq, ORFSeq(Y), vbBinaryCompare)
    
                If Pos > 0 Then
                    WinSeq = Y
                    LeftBound = Pos + x - 1
                    RightBound = LeftBound + Len(StrainSeq(0))
                    GoOn = 1
                    Exit Do
                End If
        
        
                x = x + 30
            Loop
        
        
        
        End If
        
        If GoOn = 0 Then
             x = Int(Len(RefSeq) / 10)
            Do While x < Len(RefSeq)
                ReDim ORFSeq(NextNo)
        
                Z = WinSeq
                Y = x
    
                Do Until Len(ORFSeq(Z)) = 10
    
                    If SeqsIn(Y, 1) > 64 And SeqsIn(Y, 1) < 86 Then
                        ORFSeq(Z) = ORFSeq(Z) + Chr$((SeqsIn(Y, 1) - 1))
                    End If
    
                    Y = Y + 1
    
                    If Y = LSeq Then
                        If RDPLGBFlag = 0 And SilentGBFlag = 0 Then
                            Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
                        End If
                        ORFFlag = 0
                        Form1.Picture20.Visible = False
                        Form1.Refresh
                        Close #FF
                        GeneNumber = 0
                        Exit Sub
                    End If
    
                Loop
        
                Y = WinSeq
                
                Pos = 0
    
                If Len(ORFSeq(Y)) >= 10 Then Pos = InStr(1, RefSeq, ORFSeq(Y), vbBinaryCompare)
    
                If Pos > 0 Then
                    WinSeq = Y
                    LeftBound = Pos + x - 1
                    RightBound = LeftBound + Len(StrainSeq(0))
                    GoOn = 1
                    Exit Do
                End If
                
                x = x + 30
            Loop
        
        
        
        End If
        
        Dim UnitLength As Double
        Dim UnitHeight As Double
        Dim ORFHeight As Double
        Dim ORFRef As String
    
        If WinSeq = -1 Then
            If RDPLGBFlag = 0 And SilentGBFlag = 0 Then
                Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
            End If
            ORFFlag = 0
            Form1.Picture20.Visible = False
            Form1.Refresh
            Close #FF
            Exit Sub
        End If
        'place non-gaps in winseq into orfseq
        For Z = 0 To LSeq
    
            If SeqsIn(Z, 1) > 64 And SeqsIn(Z, 1) < 86 Then
                ORFRef = ORFRef + Chr$((SeqsIn(Z, 1) - 1))
            End If
    
        Next 'Z
        'ORFRef = StrainSeq(WinSeq)
        'XX = Len(ORFRef)
        x = Int(LSeq / 10)
        Y = 0
    
        Do While x < LSeq
            Pos = InStr(1, ORFRef, Mid$(RefSeq, x, 40), vbBinaryCompare)
    
            If Pos > 0 Then
                Exit Do
            End If
    
            x = x + 20
        Loop
        HitXPos = x
        
    
        Dim FrameRef As Integer
        Dim PosHit As Long, PosTest As String, PosOffset
        For Z = 1 To GeneNumber
            'test to see if the start and end of this gene could be within the bounds of the alignment
            
            GoOn = 2
            If GeneList(Z).End > GeneList(Z).Start Then
                If GeneList(Z).Orientation = 1 Then
                    If GeneList(Z).Start < LeftBound And GeneList(Z).End < LeftBound Then
                        GoOn = 0
                    ElseIf GeneList(Z).Start > RightBound And GeneList(Z).End > RightBound Then
                        GoOn = 0
                    ElseIf GeneList(Z).Start < LeftBound And GeneList(Z).End > RightBound Then
                        GoOn = 1
                    End If
                Else
                    If GeneList(Z).Start < LeftBound And GeneList(Z).End > RightBound Then
                        GoOn = 0
                    ElseIf GeneList(Z).Start > RightBound Or GeneList(Z).End < LeftBound Then
                        GoOn = 0
                    End If
                End If
            Else
                If GeneList(Z).Orientation = 2 Then
                    If GeneList(Z).Start < LeftBound And GeneList(Z).End < LeftBound Then
                        GoOn = 0
                    ElseIf GeneList(Z).Start > RightBound And GeneList(Z).End > RightBound Then
                        GoOn = 0
                    ElseIf GeneList(Z).Start > RightBound And GeneList(Z).End < LeftBound Then
                        GoOn = 1
                    End If
                Else
                    If GeneList(Z).End < LeftBound And GeneList(Z).Start > RightBound Then
                        GoOn = 0
                    ElseIf GeneList(Z).Start < LeftBound Or GeneList(Z).End > RightBound Then
                        GoOn = 1
                    End If
                End If
            End If
            
            
            
            
            If GoOn = 0 Then
            
                GeneList(Z).StartInAlign = -1
                GeneList(Z).EndInAlign = -1
            ElseIf GoOn = 1 Then
                GeneList(Z).StartInAlign = 1
                GeneList(Z).EndInAlign = Len(StrainSeq(0))
            Else
            
                PosOffset = 0
                If GeneList(Z).Orientation = 1 Then
                    Do
                        PosTest = Mid$(RefSeq, GeneList(Z).Start + PosOffset, 15)
                        PosHit = InStr(1, ORFRef, PosTest, vbBinaryCompare)
                        If PosHit > 0 Then
                            Exit Do
                        Else
                            PosOffset = PosOffset + 2
                            If PosOffset > 200 Then Exit Do
                        End If
                    Loop
                Else
                    Do
                        PosTest = Mid$(RefSeq, GeneList(Z).Start + PosOffset - 15, 15)
                        PosHit = InStr(GeneList(Z).End, ORFRef, PosTest, vbBinaryCompare)
                        If PosHit > 0 Then
                            Exit Do
                        Else
                            PosOffset = PosOffset - 2
                            If PosOffset < -200 Then Exit Do
                        End If
                    Loop
                End If
        '        XX = GeneList(Z).IntronFlag '1,1
        '        XX = GeneList(Z).ExonNumber '1,2
        '        XX = GeneList(Z).Name
        '        XX = GeneList(Z).Product
        '        XX = GeneList(Z).Orientation
        '        If GeneList(Z).Start = 6919 Or GeneList(Z).End = 6919 Then
        '            XX = WinSeq
        '            XX = GeneList(Z).Orientation
        '        End If
        '        If (GeneList(Z).Start + Pos - X) <> (PosHit - PosOffset) Then '1793,2527
        '            X = X '336,1637,1632,1637,1655,1799,2096,2096,3776,336
        '            '336,732,1425,1467,1632,1680,4587
        '        End If
        'XX = Len(StrainSeq(0)
                XX = LeftBound
                PosWarn = 0
                If PosHit = 0 Then
                    If Pos > 0 Then
                        GeneList(Z).StartInAlign = (GeneList(Z).Start + Pos - HitXPos)
                    Else
                        GeneList(Z).StartInAlign = 1
                        PosWarn = 1
                    End If
                    
                Else
                   ' XX = Mid$(ORFRef, PosHit - PosOffset, 20)
                    If GeneList(Z).Orientation = 1 Then
                        GeneList(Z).StartInAlign = PosHit - PosOffset
                    Else
                        GeneList(Z).StartInAlign = PosHit + PosOffset + 15
                    End If
                End If
                If SilentGBFlag = 0 Then
                    If GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) >= (Len(RefSeq) * 0.95) Or CircularFlagX > 0) Then
                        GeneList(Z).StartInAlign = GeneList(Z).StartInAlign - Len(ORFRef)
                    ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) >= (Len(RefSeq) * 0.95) Or CircularFlagX > 0) Then
                        GeneList(Z).StartInAlign = GeneList(Z).StartInAlign + Len(ORFRef)
                    ElseIf GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlagX = 0) Then
                        GeneList(Z).StartInAlign = Len(ORFRef)
                    ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlagX = 0) Then
                        GeneList(Z).StartInAlign = 1
                    End If
                Else
                    If GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) >= (Len(RefSeq)) And CircularFlagX > 0) Then
                        GeneList(Z).StartInAlign = GeneList(Z).StartInAlign - Len(ORFRef)
                    ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) >= (Len(RefSeq)) And CircularFlagX > 0) Then
                        GeneList(Z).StartInAlign = GeneList(Z).StartInAlign + Len(ORFRef)
                    ElseIf GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq)) Then
                        GeneList(Z).StartInAlign = Len(ORFRef)
                    ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) < Len(RefSeq)) Then
                        GeneList(Z).StartInAlign = 1
                    End If
                End If
                oStartInAlign = GeneList(Z).StartInAlign
                If SeqSpacesInFileFlag = 1 Then
                    SSB = 0
                    For Y = 1 To Len(StrainSeq(0))
                        If SeqsIn(Y, 1) <> 46 Then
                            SSB = SSB + 1
                            If SSB = GeneList(Z).StartInAlign Then
                                GeneList(Z).StartInAlign = Y
                                Exit For
                            End If
                        End If
                    Next Y
                Else
                    Y = 0
                    
                    Do
                        Y = Y + 1
                        If Y <= Len(StrainSeq(0)) + 2 Then
                            If SeqSpacesInFileFlag = 1 Then
                                oDirX = CurDir
                                ChDrive App.Path
                                ChDir App.Path
                                FF = FreeFile
                               
                                OS1 = WinSeq * (Len(StrainSeq(0)) + 3)
                                Open "RDP5SSFile" + UFTag For Binary As #FF
                                
                                Get #FF, (((Y + OS1) - 1) * 4) + 1, SSB
                                
                                
                                Close #FF
                                ChDrive oDirX
                                ChDir oDirX
                            Else
                                SSB = SeqSpaces(Y, WinSeq)
                                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                            End If
            
                            If Y - SSB = GeneList(Z).StartInAlign Then
                                GeneList(Z).StartInAlign = Y
                                Exit Do
                            End If
                        Else
                            Y = Y - 1
                            GeneList(Z).StartInAlign = Y
                            Exit Do
                        End If
                    Loop
                End If
                PosOffset = 0
                
                If GeneList(Z).Orientation = 1 Then
                
                    Do
                        PosTest = Mid$(RefSeq, GeneList(Z).End + PosOffset - 15, 15)
                        PosHit = InStr(GeneList(Z).StartInAlign, ORFRef, PosTest, vbBinaryCompare)
                        If PosHit > 0 Then
                            Exit Do
                        Else
                            PosOffset = PosOffset - 2
                            If PosOffset < -200 Then Exit Do
                        End If
                    Loop
                Else
                    'PosOffset = 0
                    Do
                        PosTest = Mid$(RefSeq, GeneList(Z).End + PosOffset, 15)
                        PosHit = InStr(1, ORFRef, PosTest, vbBinaryCompare)
                        If PosHit > 0 Then
                            Exit Do
                        Else
                            PosOffset = PosOffset + 2
                            If PosOffset > 200 Then Exit Do
                        End If
                    Loop
                
                End If
        '        XX = GeneList(Z).Start
        '        XX = GeneList(Z).End
        '        If (PosHit + PosOffset + 15) <> (GeneList(Z).End + Pos - X) Then '1353'1886
        '            X = X '1637,4642,1637,1798,4639,2548,3775,3415,4639,1838
        '            '731,1424,1466,1631,1679,1835,5165
        '        End If
                If PosHit = 0 Then
                    If PosWarn = 0 Then
                        If GeneList(Z).Orientation = 1 Then
                            If GeneList(Z).End > GeneList(Z).Start Then
                                GeneList(Z).EndInAlign = oStartInAlign + (GeneList(Z).End - GeneList(Z).Start)
                            Else
                                GeneList(Z).EndInAlign = oStartInAlign + (GeneList(Z).End + (Len(RefSeq) - GeneList(Z).Start))
                            End If
                        ElseIf GeneList(Z).Orientation = 2 Then
                            If GeneList(Z).End < GeneList(Z).Start Then
                                GeneList(Z).EndInAlign = oStartInAlign - (GeneList(Z).Start - GeneList(Z).End)
                            Else
                                GeneList(Z).EndInAlign = oStartInAlign - (GeneList(Z).Start + (Len(RefSeq) - GeneList(Z).End))
                            End If
                        End If
                    Else
                        GeneList(Z).EndInAlign = 1
                    End If
                Else
                     If GeneList(Z).Orientation = 1 Then
                        GeneList(Z).EndInAlign = PosHit + PosOffset + 15
                    Else
                        GeneList(Z).EndInAlign = PosHit - PosOffset
                    End If
                End If
                
                If SilentGBFlag = 0 Then
                    If GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlagX > 0) Then
                        GeneList(Z).EndInAlign = GeneList(Z).EndInAlign - Len(ORFRef)
                    ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlagX > 0) Then
                        GeneList(Z).EndInAlign = GeneList(Z).EndInAlign + Len(ORFRef)
                    ElseIf GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlagX = 0) Then
                        GeneList(Z).EndInAlign = Len(ORFRef)
                    ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlagX = 0) Then
                        GeneList(Z).EndInAlign = 1
                    End If
                Else
                    If GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) >= Len(RefSeq) And CircularFlagX > 0) Then
                        GeneList(Z).EndInAlign = GeneList(Z).EndInAlign - Len(ORFRef)
                    ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) And CircularFlagX > 0) Then
                        GeneList(Z).EndInAlign = GeneList(Z).EndInAlign + Len(ORFRef)
                    ElseIf GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq)) Then
                        GeneList(Z).EndInAlign = Len(ORFRef)
                    ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) < Len(RefSeq)) Then
                        GeneList(Z).EndInAlign = 1
                    End If
                
                End If
                If SeqSpacesInFileFlag = 1 Then
                    SSB = 0
                    For Y = 1 To Len(StrainSeq(0))
                        If SeqsIn(Y, 1) <> 46 Then
                            SSB = SSB + 1
                            If SSB = GeneList(Z).EndInAlign Then
                                GeneList(Z).EndInAlign = Y
                                Exit For
                            End If
                        End If
                    Next Y
                Else
                    Y = 0
            
                    Do
                        Y = Y + 1
                        If Y <= Len(StrainSeq(0)) + 2 Then
                            If SeqSpacesInFileFlag = 1 Then
                                oDirX = CurDir
                                ChDrive App.Path
                                ChDir App.Path
                                FF = FreeFile
                               
                                OS1 = WinSeq * (Len(StrainSeq(0)) + 3)
                                Open "RDP5SSFile" + UFTag For Binary As #FF
                                
                                Get #FF, (((Y + OS1) - 1) * 4) + 1, SSB
                                
                                
                                Close #FF
                                ChDrive oDirX
                                ChDir oDirX
                            Else
                                SSB = SeqSpaces(Y, WinSeq)
                                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                            End If
                            If Y - SSB = GeneList(Z).EndInAlign Then
                                GeneList(Z).EndInAlign = Y
                                'XX = GeneList(Z).StartInAlign
                                Exit Do
                            End If
                        
                        Else
                            Y = Y - 1
                            GeneList(Z).EndInAlign = Y
                            Exit Do
                        End If
                    Loop
                End If
                XX = GeneList(Z).End
                XX = GeneList(Z).Start
                EE = Abs(GetTickCount)
                If Abs(EE - SS) > 200 Then
                    SS = EE
                    If SilentGBFlag = 0 Then
                        Form1.SSPanel1.Caption = "Informtion loaded for " + Trim(Str(Z)) + " of " + Trim(Str(GeneNumber)) + " genes"
                        Form1.ProgressBar1.Value = (Z / GeneNumber) * 100
                        Call UpdateF2Prog
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                End If
                x = x
            End If
        Next 'Z
    End If
    
    'up to this point startinalign and endinalign do not actually include alignment gaps
    
    'find gap numbers preceeding startinalign/endinalign in winseq and add these back in
    Dim TargetPos As Long, NumGapsX As Long, NonGaps As Long
'    For Z = 1 To GeneNUmber
'        Targetpos = GeneList(Z).StartInAlign
'        NumGapsX = 0
'        NonGaps = 0
'        For X = 1 To Len(StrainSeq(WinSeq))
'            If SeqNum(X, WinSeq) <> 46 Then
'                NonGaps = NonGaps + 1
'                If NonGaps = Targetpos Then Exit For
'            Else
'                NumGapsX = NumGapsX + 1
'            End If
'        Next X
'        'GeneList(Z).StartInAlign = GeneList(Z).StartInAlign + NumGapsX
'        X = X
'        Targetpos = GeneList(Z).EndInAlign
'        NumGapsX = 0
'        NonGaps = 0
'        For X = 1 To Len(StrainSeq(WinSeq))
'            If SeqNum(X, WinSeq) <> 46 Then
'                NonGaps = NonGaps + 1
'                If NonGaps = Targetpos Then Exit For
'            Else
'                NumGapsX = NumGapsX + 1
'            End If
'        Next X
'        'GeneList(Z).EndInAlign = GeneList(Z).EndInAlign + NumGapsX
'        X = X
'    Next Z
    
    
    
    
    If x = x Then
         For Z = 1 To GeneNumber '2309 - 3182..1 - 1625,2850 - 3182..1- 837,3174 - 3182..1-837, 157-837, 1376 - 1840, 1816 - 2454, 1854 - 1922, 1903-2454
            XX = GeneList(Z).End
            If (GeneList(Z).Start / 3) = Int((GeneList(Z).Start) / 3) Then
                GeneList(Z).Frame = 1
            ElseIf ((GeneList(Z).Start - 1) / 3) = Int((GeneList(Z).Start - 1) / 3) Then
                GeneList(Z).Frame = 2
            Else
                GeneList(Z).Frame = 3
            End If
    
        Next 'Z
    Else
        For Z = 1 To GeneNumber
            'work out position in seq 1 with no gaps
            Dim NumGaps As Long
            NumGaps = 0
            For x = 1 To GeneList(Z).StartInAlign
                If SeqNum(x, 0) = 46 Then NumGaps = NumGaps + 1
            Next x
            NumGaps = GeneList(Z).StartInAlign - NumGaps
            If ((NumGaps) / 3) = Int((NumGaps - 1) / 3) Then
                GeneList(Z).Frame = 1
            ElseIf ((NumGaps - 2) / 3) = Int((NumGaps - 2) / 3) Then
                GeneList(Z).Frame = 2
            Else
                GeneList(Z).Frame = 3
            End If
    
        Next 'Z
    End If
'    Open "gbtemp.txt" For Output As #10
'        Print #10, VarString
'    Close #10
    XX = CurDir
    If SilentGBFlag = 0 Then
        
        Call DrawORFs
    
        Form1.Picture4.ScaleMode = 3
        Form1.Picture4.DrawMode = 13
        Form1.Picture11.ScaleMode = 3
        Form1.Picture19.DrawMode = 13
        DontDoH1Inc = 1
        OnlyDoPositionIndicator = 1
        OnlyDoPosBar = 1
        If Form1.HScroll1.Value > Form1.HScroll1.Min Then
            Form1.HScroll1.Value = Form1.HScroll1.Value - 1
            Form1.HScroll1.Value = Form1.HScroll1.Value + 1
        Else
            If Form1.HScroll1.Value < Form1.HScroll1.Max Then
                Form1.HScroll1.Value = Form1.HScroll1.Value + 1
                Form1.HScroll1.Value = Form1.HScroll1.Value - 1
            End If
        End If
        OnlyDoPositionIndicator = 0
        OnlyDoPosBar = 0
        DontDoH1Inc = 0
        
    End If
    

    If (RunFlag = 1 Or ManFlag) And (RelX > 0 Or RelY > 0) > 0 Then

        If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form1.Picture7.Top = Form1.Picture20.ScaleHeight
            Form1.Picture7.Height = Form1.Picture7.Height - Form1.Picture20.ScaleHeight
        End If

    End If

    Form1.Picture19.Refresh
    

    If RunFlag = 1 Or ManFlag > 0 Then
        Form1.Picture20.Visible = True
    End If

    'Form1.Picture20.Visible = True
    If SilentGBFlag = 0 Then
        ORFFlag = 1
    End If
    'Form1.Picture20.ScaleHeight = Form1.Picture4.ScaleHeight
    
    
    
    
    
    Close #FF
    
    
    'Get rid of white spaces in sequence names
    For Z = 1 To GeneNumber
        If GeneList(Z).Name = "" Then
            If GeneList(Z).Product <> "" Then
                GeneList(Z).Name = GeneList(Z).Product
                GeneList(Z).Product = ""
            End If
        End If
        If GeneList(Z).Name <> "" Then
            
            Do
                Pos = InStr(1, GeneList(Z).Name, "  ", vbBinaryCompare)
                If Pos > 0 Then
                    GeneList(Z).Name = Left(GeneList(Z).Name, Pos) + Mid$(GeneList(Z).Name, Pos + 2, Len(GeneList(Z).Name))
                Else
                    Exit Do
                End If
            Loop
        End If
    Next Z
    
    For Z = 1 To GeneNumber
        'Pos = InStr(1, GeneList(Z).Name, "  ", vbBinaryCompare)
        Do
            Pos = Pos = InStr(1, GeneList(Z).Name, "  ", vbBinaryCompare)
            'XX = Len(GeneList(Z).Product)
            If Pos > 0 Then
                GeneList(Z).Name = Left$(GeneList(Z).Product, Pos) + Right(GeneList(Z).Product, Len(GeneList(Z).Product) - Pos - 1)
            Else
                Exit Do
            End If
        Loop
        x = x
        Do
            Pos = InStr(1, GeneList(Z).Product, "  ", vbBinaryCompare)
            'XX = Len(GeneList(Z).Product)
            If Pos > 0 Then
                GeneList(Z).Product = Left$(GeneList(Z).Product, Pos) + Right(GeneList(Z).Product, Len(GeneList(Z).Product) - Pos - 1)
            Else
                Exit Do
            End If
        Loop
        x = x
    Next Z
    
    
    If SilentGBFlag = 0 Then
        Call CheckGenes(GeneList(), GeneNumber)
        
    End If
    If DatasetName <> "" Then
        Form1.Caption = Form1.Caption + DatasetName
    End If
    
End Sub

Public Sub LoadGenBankII(VarString As String)

    Dim LSeq As Long, GLS As Long, GLE As Long

    LSeq = Len(StrainSeq(0))
    Position = 1    'Sets the position to the start.
    Buffer = 0
    Genes = 0
    LastPos = 1
    '  Get #1, position, VarString$
    'VarString$ = SeqFile
    b = Len(VarString$)

    Dim UnitLengthII As Double

    UnitLengthII = Form1.Picture20.ScaleWidth / LSeq
    'originalname(101) = originalname(100)

    Do
        Pos = InStr(LastPos, VarString$, "CDS", vbBinaryCompare)

        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
        Else
            Exit Do
        End If

    Loop

    LastPos = 1
    ReDim GeneList(Genes * 10), ColBump(Genes * 10)

    Dim GeneNumber As Integer

    GeneNumber = Genes
    Genes = 0

    Dim PosDot As Long
    Dim PosComplement As Long
    Dim PosJoin As Long
    Dim PosBracket As Long
    Dim PosComma As Long
    Dim PosGene As Long
    Dim PosPar As Long
    Dim PosProd As Long
    Dim IntronNo As Integer
    Dim ExonNo As Integer

    If ORFFlag = 1 Then
        Form1.Picture19.Cls
        Form1.Picture20.Cls
        Form1.Picture7.Height = Form1.Picture10.ScaleHeight
        'Form1.Picture7.Width = Form1.Picture10.ScaleWidth
        Form1.Picture7.Top = -1
        'Form1.Picture7.Left = 0
    End If

    Do
        Pos = InStr(LastPos, VarString$, "CDS", vbBinaryCompare)

        If Pos > 0 Then
            LastPos = Pos + 1
            Genes = Genes + 1
            PosDot = InStr(Pos, VarString$, "..", vbBinaryCompare)
            PosComplement = InStr(Pos, VarString$, "complement", vbBinaryCompare)
            PosJoin = InStr(Pos, VarString$, "join", vbBinaryCompare)
            PosNextGene = InStr(PosDot, VarString$, "CDS", vbBinaryCompare)
            PosGene = InStr(Pos, VarString$, "/gene=", vbBinaryCompare)

            If PosGene = 0 Then
                PosGene = InStr(Pos, VarString$, "/note=", vbBinaryCompare)
            End If

            If PosGene > 0 And PosGene < PosNextGene Then
                PosNextGene = InStr(PosGene, VarString$, "CDS", vbBinaryCompare)
                PosPar = InStr(PosGene + 8, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Name = Mid$(VarString$, PosGene + 7, PosPar - PosGene - 7)
            End If

            PosProd = InStr(Pos, VarString$, "/product=", vbBinaryCompare)

            If PosProd > 0 And (PosProd < PosNextGene Or PosNextGene = 0) Then
                PosPar = InStr(PosProd + 10, VarString$, Chr$(34), vbBinaryCompare)
                GeneList(Genes).Product = Mid$(VarString$, PosProd + 10, PosPar - PosProd - 10)
            End If

            If (PosComplement > 0 And PosComplement < PosDot) Or (PosJoin > 0 And PosJoin < PosDot) Then

                If PosComplement > PosDot And PosJoin > PosDot Then
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
                    GeneList(Genes).Orientation = 1
                ElseIf PosComplement > 0 And PosComplement < PosDot And (PosJoin > PosDot Or PosJoin = 0) Then
                    GeneList(Genes).Orientation = 2
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosComplement + 11, PosDot - PosComplement - 11))
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                ElseIf PosJoin > 0 And (PosComplement > PosDot Or PosComplement = 0) And PosJoin < PosDot Then
                    GeneList(Genes).Orientation = 1
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5))
                    PosBracket = InStr(PosDot, VarString$, ")", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For x = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 1
                        GeneList(Genes).Start = CDbl(Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1))

                        If x = IntronNo Then
                            GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)
                            GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo

                        If GeneList(Genes).Start < GeneList(Genes - 1).Start Then
                            Genes = Genes - 1
                            GeneList(Genes).End = GeneList(Genes + 1).End
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            IntronNo = IntronNo - 1
                            ExonNo = ExonNo - 1
                        End If

                    Next 'X

                ElseIf PosComplement > 0 And PosJoin > 0 And PosComplement < PosDot And PosJoin < PosDot Then
                    GeneList(Genes).Orientation = 2
                    GeneList(Genes).End = CDbl(Mid$(VarString$, PosJoin + 5, PosDot - PosJoin - 5))
                    PosBracket = InStr(PosDot, VarString$, "))", vbBinaryCompare)
                    PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                    GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                    'Find number of introns
                    IntronNo = 1

                    Do
                        PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                        If PosComma > 0 And PosComma < PosBracket Then
                            IntronNo = IntronNo + 1
                        Else
                            Exit Do
                        End If

                    Loop

                    GeneList(Genes).IntronFlag = IntronNo
                    GeneList(Genes).ExonNumber = 1
                    ExonNo = 1

                    For x = 1 To IntronNo
                        PosComma = InStr(PosDot, VarString$, ",", vbBinaryCompare)
                        PosDot = InStr(PosDot + 1, VarString$, "..", vbBinaryCompare)
                        Genes = Genes + 1
                        ExonNo = ExonNo + 1
                        GeneList(Genes).Orientation = 2
                        GeneList(Genes).End = CDbl(Mid$(VarString$, PosComma + 1, PosDot - PosComma - 1))

                        If GeneList(Genes).End < GeneList(Genes - 1).End Then
                            GeneList(Genes).End = GeneList(Genes - 1).End
                            Genes = Genes - 1
                            GeneList(Genes).IntronFlag = GeneList(Genes).IntronFlag - 1
                            ExonNo = ExonNo - 1
                            IntronNo = IntronNo - 1
                            GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        End If

                        If x = IntronNo Then
                            GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosBracket - PosDot - 2))
                        Else
                            PosComma = InStr(PosComma + 1, VarString$, ",", vbBinaryCompare)

                            If PosComma > 0 Then
                                GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot + 2, PosComma - PosDot - 2))
                            End If

                        End If

                        GeneList(Genes).IntronFlag = IntronNo
                        GeneList(Genes).ExonNumber = ExonNo
                    Next 'X

                End If

            Else
                GeneList(Genes).Start = CDbl(Mid$(VarString$, PosDot - 6, 6))
                GeneList(Genes).End = CDbl(Mid$(VarString$, PosDot + 2, 6))
                GeneList(Genes).Orientation = 1
            End If

        Else
            Exit Do
        End If

    Loop

    GeneNumber = Genes

    If ORFFlag = 1 Then Call HomologyWindow

    For Z = 1 To GeneNumber

        If ((GeneList(Z).Start - 1) / 3) = Int((GeneList(Z).Start - 1) / 3) Then
            GeneList(Z).Frame = 1
        ElseIf ((GeneList(Z).Start - 2) / 3) = Int((GeneList(Z).Start - 2) / 3) Then
            GeneList(Z).Frame = 2
        Else
            GeneList(Z).Frame = 3
        End If

    Next 'Z

    Pos = InStr(LastPos, VarString$, "BASE COUNT", vbBinaryCompare)

    If Pos > 0 Then
        Pos = InStr(LastPos, VarString$, "ORIGIN", vbBinaryCompare)

        If Pos = 0 Then Pos = InStr(LastPos, VarString$, "origin", vbBinaryCompare)
    Else
        'Give a message if the file is not a DNA file
    End If

    'Close #1
    'Close #2
    'Open FName$ For Input Access Read As #2

    Do While Not EOF(1)
        Line Input #1, TempString

        If Trim$(Mid$(TempString, 1, 12)) = "BASE COUNT" Then
            Line Input #1, TempString

            If Trim$(TempString) = "ORIGIN" Then
                Exit Do
            End If

        End If

    Loop

    'Line Input #2, TempString

    Dim RefSeq As String

    RefSeq = ""

    Do
        Line Input #1, TempString

        If Trim$(TempString) = "//" Then
            Exit Do
        End If

        For x = 1 To 6
            RefSeq = RefSeq + Mid$(TempString, x * 10 + x, 10)
        Next 'X

    Loop

    Dim ORFSeq() As String
    Dim WinSeq As Integer

    x = Int(Len(RefSeq) / 10)

    Do While x < Len(RefSeq)
        ReDim ORFSeq(NextNo)

        For Z = 0 To NextNo
            Y = x

            Do Until Len(ORFSeq(Z)) = 40

                If SeqNum(Y, Z) > 64 And SeqNum(Y, Z) < 86 Then
                    ORFSeq(Z) = ORFSeq(Z) + Chr$((SeqNum(Y, Z) - 1))
                End If

                Y = Y + 1

                If Y = LSeq Then
                    Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
                    ORFFlag = 0
                    Form1.Picture20.Visible = False
                    Exit Sub
                End If

            Loop

        Next 'Z

        WinSeq = -1
        RefSeq = UCase$(RefSeq)

        For Y = 0 To NextNo
            'PosMarker = Mid$(RefSeq, X, 40)
            Pos = 0

            If Len(ORFSeq(Y)) > 20 Then Pos = InStr(1, RefSeq, ORFSeq(Y), vbBinaryCompare)

            If Pos > 0 Then
                WinSeq = Y
                Exit Do
            End If

        Next 'Y

        x = x + 30
    Loop

    Dim UnitLength As Double
    Dim UnitHeight As Double
    Dim ORFHeight As Double
    Dim ORFRef As String

    If WinSeq = -1 Then
        Response = MsgBox("There is no sequence in the multiple alignment that resembles the sequence in the GenBank file ", 48)
        ORFFlag = 0
        Form1.Picture20.Visible = False
        Exit Sub
    End If

    For Z = 0 To LSeq

        If SeqNum(Z, WinSeq) > 64 And SeqNum(Z, WinSeq) < 86 Then
            ORFRef = ORFRef + Chr$((SeqNum(Z, WinSeq) - 1))
        End If

    Next 'Z

    x = Int(LSeq / 10)
    Y = 0

    Do While x < LSeq
        Pos = InStr(1, ORFRef, Mid$(RefSeq, x, 40), vbBinaryCompare)

        If Pos > 0 Then
            Exit Do
        End If

        x = x + 20
    Loop

    ReDim ORFWin(3, LSeq)

    Dim FrameRef As Integer
    
    For Z = 1 To GeneNumber
        GeneList(Z).StartInAlign = GeneList(Z).Start + Pos - x

        If GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) >= (Len(RefSeq) * 0.95) Or CircularFlag = 1) Then
            GeneList(Z).StartInAlign = GeneList(Z).StartInAlign - Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).StartInAlign = GeneList(Z).StartInAlign + Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).StartInAlign = Len(ORFRef)
        ElseIf GeneList(Z).StartInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).StartInAlign = 1
        End If

        Y = 0

        Dim OS1 As Long, SSB As Long
        Do
            Y = Y + 1
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = WinSeq * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                
                Get #FF, (((Y + OS1) - 1) * 4) + 1, SSB
                
                
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(Y, WinSeq)
                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
            End If
            If Y - SSB = GeneList(Z).StartInAlign Then
                GeneList(Z).StartInAlign = Y
                Exit Do
            End If

        Loop

        GeneList(Z).EndInAlign = GeneList(Z).End + Pos - x

        If GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).EndInAlign = GeneList(Z).EndInAlign - Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) >= Len(RefSeq) * 0.95 Or CircularFlag = 1) Then
            GeneList(Z).EndInAlign = GeneList(Z).EndInAlign + Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign > Len(ORFRef) And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).EndInAlign = Len(ORFRef)
        ElseIf GeneList(Z).EndInAlign < 0 And (Len(ORFRef) < Len(RefSeq) * 0.95 Or CircularFlag = 0) Then
            GeneList(Z).EndInAlign = 1
        End If

        Y = 0

        Do
            Y = Y + 1
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = WinSeq * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                
                Get #FF, (((Y + OS1) - 1) * 4) + 1, SSB
                
                
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(Y, WinSeq)
                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
            End If
            If Y - SSB = GeneList(Z).EndInAlign Then
                GeneList(Z).EndInAlign = Y
                Exit Do
            End If

        Loop

        Form1.Picture4.ScaleMode = 3
        Form1.Picture11.ScaleMode = 3
        UnitLength = Form1.Picture4.ScaleWidth / LSeq
        UnitHeight = Int(Form1.Picture4.ScaleHeight / 6)

        If GeneList(Z).Frame = 3 Then
            ORFHeight = UnitHeight
            FrameRef = 0
        ElseIf GeneList(Z).Frame = 2 Then
            ORFHeight = UnitHeight * 3
            FrameRef = 1
        Else
            FrameRef = 2
            ORFHeight = UnitHeight * 5
        End If

        Form1.Picture4.AutoRedraw = True
        Form1.Picture4.ForeColor = 0
        Form1.Picture4.DrawMode = 13
        Form1.Picture4.DrawWidth = 1
        Form1.Picture11.AutoRedraw = True
        Form1.Picture11.ForeColor = RGB(0, 64, 64)
        Form1.Picture11.DrawWidth = 1
        Form1.Picture19.AutoRedraw = True
        Form1.Picture19.ForeColor = 0
        Form1.Picture19.DrawMode = 13
        Form1.Picture19.DrawWidth = 1
        Form1.Picture19.ScaleMode = 3
        Form1.Picture19.Height = Form1.Picture4.ScaleHeight + 3
        Form1.Picture20.Height = Form1.Picture4.ScaleHeight + 3

        If GeneList(Z).Orientation = 1 Then

            If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1) Then

                If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight)

                    For A = 1 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A)
                    Next 'A

                    Form1.Picture4.DrawWidth = 1
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight / 2 + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight / 2 - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight / 3 + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight / 3 - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight / 4 + 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                    '                 Form1.Picture11.Line (UnitLength * GeneList(z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight / 4 - 1)-(UnitLength * GeneList(z).EndInAlign, ORFHeight)
                Else

                    For F = 1 To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    'Form1.Picture4.Line (UnitLength * (GeneList(z).StartInAlign - 10), ORFHeight - UnitHeight + 1)-(UnitLength * (GeneList(z).StartInAlign - 100), ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture11.Line (UnitLength * 1, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture19.Line (UnitLengthII * 1, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)

                    For A = 0 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.DrawWidth = 1
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                End If

            Else

                If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                Else
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture11.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF

                    For F = GeneList(Z).StartInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = 1 To GeneList(Z).EndInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                End If

            End If

            Form1.Picture4.DrawWidth = 1
        Else

            If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = 1) Then

                If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then

                    For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.DrawWidth = 1
                    'Form1.Picture11.Line (UnitLength * GeneList(z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)

                    For A = 1 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                Else
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.DrawWidth = 1
                    'Form1.Picture11.Line (UnitLength * lseq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF

                    For F = GeneList(Z).EndInAlign To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = 1 To GeneList(Z).StartInAlign
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture11.Line (UnitLength * LSeq, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 64, 64)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
                    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF

                    For A = 0 To Int(UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 64, 64)
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 64, 64)
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                    Next 'A

                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                End If

            Else
                GLE = GeneList(Z).EndInAlign
                GLS = GeneList(Z).StartInAlign

                If GLS > GLE Then

                    For F = GLE To GLS
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight + UnitHeight - 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLS, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GLS, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GLE, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1)
                Else

                    For F = 1 To GLS
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    For F = GLE To LSeq
                        ORFWin(FrameRef, F) = Z
                    Next 'F

                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight + UnitHeight - 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight - UnitHeight + 1)
                    Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture4.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * GLS, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLS, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1), RGB(0, 64, 64), BF
                    Form1.Picture19.Line (UnitLengthII * GLS, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                    Form1.Picture4.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture11.Line (UnitLength * GLE, ORFHeight - UnitHeight + 1)-(UnitLength * GLE, ORFHeight + UnitHeight - 1)
                    Form1.Picture19.Line (UnitLengthII * GLE, ORFHeight - UnitHeight + 1)-(UnitLengthII * GLE, ORFHeight + UnitHeight - 1)
                End If

            End If

            Form1.Picture4.DrawWidth = 1
        End If

    Next 'Z
    
    Form1.Picture4.ScaleMode = 3
    Form1.Picture4.DrawMode = 13
    Picture11ScaleMode = 3
    Form1.Picture19.DrawMode = 13
    DontDoH1Inc = 1
    OnlyDoPositionIndicator = 1
    OnlyDoPosBar = 1
    If Form1.HScroll1.Value > Form1.HScroll1.Min Then
        Form1.HScroll1.Value = Form1.HScroll1.Value - 1
        Form1.HScroll1.Value = Form1.HScroll1.Value + 1
    Else
        If Form1.HScroll1.Value < Form1.HScroll1.Max Then
            Form1.HScroll1.Value = Form1.HScroll1.Value + 1
            Form1.HScroll1.Value = Form1.HScroll1.Value - 1
        End If
    End If
    OnlyDoPositionIndicator = 0
    OnlyDoPosBar = 0
    DontDoH1Inc = 0
    Form1.Picture20.Height = Form1.Picture4.ScaleHeight + 3
    If RunFlag = 1 Then

        If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form1.Picture7.Top = Form1.Picture20.ScaleHeight - 5
            Form1.Picture7.Height = Form1.Picture7.Height - Form1.Picture20.ScaleHeight + 5
        End If

    End If

    Form1.Picture19.Refresh
    'Form1.Picture20.Picture = Form1.Picture19.Image
    Call DrawORFsP20
    If RunFlag = 1 Then
        Form1.Picture20.Visible = True
    End If

    'Form1.Picture20.Visible = True
    ORFFlag = 1
    
End Sub
Public Function ShellAndClose(ByVal JobToDo As String, Optional ExecMode As Integer) As Long
    ' Most of this code was written by Carl E. Peterson
    ' Shells a new process and waits for it to complete.
    ' Calling application is responsive while new process
    ' executes. It will react to new events, though execution
    ' of the current thread will not continue.
    ' Will close a DOS box when Win95 doesn't. More overhead
    ' than ShellAndLoop but useful when needed.
    DoingShellFlag = DoingShellFlag + 1
    Dim oDir As String, TX As String, PosN As Long, FLen As Long, EE As Long, SS As Long, DivI As Long, oPos As Long, mSDV As Double, GCV As Double, mGCV As Double, x As Long, BailFlag As Long, LastSize As Long, LF As Long, CT As Long, lCT As Long, FFX As Long, SSS As Long, EEE As Long, LL As Long, FLe As Long, SizeTarget As Long, LongCount As Long, FL As Long, STartT As Long, EndT As Long, SleepInterval As Long, NumLines As Long, PID As Long, hProcess As Long, hWndJob As Long, nRet As Long, LOF1 As Long, ProcessID As Long, AddS As Long, LPos As Long, LastAdd As Long, OneTree As Long
    Dim Counter As Integer, DoneThis As Integer, FF As Integer
    Dim Getstring As String, TitleTmp As String
    Dim Hold As Double, Response As Long

    Const fdwAccess = PROCESS_QUERY_INFORMATION
    'This code checks to see whether the execution of a shelled program started earlier
    'was aborted - If it was then it either closes the "Finished" window or shuts
    'the program down the hard/bad way using TerminateProcess.

    If scProcess > 0 Then
        TitleTmp = Space$(256)
        nRet = GetWindowText(scWndJob, TitleTmp, Len(TitleTmp))

        If nRet Then
            TitleTmp = UCase$(Left$(TitleTmp, nRet))

            If InStr(TitleTmp, "FINISHED") = 1 Then

                Call SendMessage(scWndJob, WM_CLOSE, 0, 0)

            End If

        End If

        GetExitCodeProcess scProcess, nRet

        If nRet = STILL_ACTIVE Then
            TerminateProcess scProcess, nRet
        End If

        CloseHandle scProcess
        scProcess = 0
    End If

    'This checks whether any Phylip component is currently executing from
    'the  RDP directory - If they are it gives a warning message and quits.
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "outfile"
    On Error GoTo 0
    If DebuggingFlag < 2 Then On Error Resume Next
    FF = FreeFile
    Open "outfile" For Append As #FF
    FL = LOF(FF)

    If FL > 0 Then
        AbortFlag = 1
        Response = MsgBox("I have detected a Phylip/Phylip derived component (either Seqboot, NeighborRDP, Dnadist, FastDNAML, Fitch or Consense) is currently busy running from the RDP directory.  You may:" + Chr$(13) + "  (1) Wait for this program to finish execution before you try again. " + Chr$(13) + "  (2) Terminate it yourself and then try again.", vbInformation)
    End If

    Print #FF, "xx"
    Close #FF
    'GetString = Err
    Err = 0
    KillFile "outfile"

    If Err And AbortFlag = 0 Then
        AbortFlag = 1
        Response = MsgBox("I have detected a Phylip/Phylip derived component (either Seqboot, NeighborRDP, Dnadist, FastDNAML, Fitch or Consense) is currently busy running from the RDP directory.  You may:" + Chr$(13) + "  (1) Wait for this program to finish execution before you try again. " + Chr$(13) + "  (2) Terminate it yourself and then try again.", vbInformation)
    End If

    On Error GoTo 0

    If AbortFlag = 1 Then
        DoingShellFlag = DoingShellFlag - 1
        ShellAndClose = 0
        Exit Function
    End If
    If IsMissing(ExecMode) Then
        ExecMode = vbMinimizedNoFocus
    Else

        If ExecMode < vbHide Or ExecMode > vbMinimizedNoFocus Then
            ExecMode = vbMinimizedNoFocus
        End If

    End If

    On Error Resume Next
    '&
    ProcessID = Shell(JobToDo, CLng(ExecMode))

    If Err Then
        DoingShellFlag = DoingShellFlag - 1
        ShellAndClose = vbObjectError + Err.Number
        
        Exit Function
    End If

    On Error GoTo 0
    hWndJob = FindWindow(vbNullString, vbNullString)
     '@'@
    Sleep 50
    
    Do Until hWndJob = 0

        If GetParent(hWndJob) = 0 Then

            Call GetWindowThreadProcessId(hWndJob, PID)

            If PID = ProcessID Then Exit Do
        End If

        hWndJob = GetWindow(hWndJob, GW_HWNDNEXT)
    Loop

    hProcess = OpenProcess(fdwAccess, False, ProcessID)
    STartT = Abs(GetTickCount)
    If BatIndex = 553 Then
        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 100
            'AbortFlag = 1

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scProcess = hProcess
                scWndJob = hWndJob
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
                
            End If
            SS = Abs(GetTickCount)
            If Abs(SS - EE) > 500 Then
                Sleep 100
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                FF = FreeFile
                Dim TSX As String, PosR As Double
                Dim fso As New FileSystemObject
                On Error Resume Next
                KillFile "ofc"
                
                If Dir("outfilep") <> "" Then
                    fso.CopyFile "outfilep", "ofc"
                Else
                    'MsgBox ("There are no pairs of sites with a high enough minor allele frequency")
                    'AbortFlag = 1
                End If
                On Error GoTo 0
                TSX = String(50, " ")
                Open "ofc" For Binary Access Read As #FF
                'PosR = LOF(FF) - 50
                'If PosR < 0 Then PosR = 1
                'Get #FF, PosR, TSX
                PosR = LOF(FF)
                If PosR > 251000 Then
                    PosR = ((PosR - 251000) / 27000) * 30
                    If PosR > 0 And PosR < 30 Then
                    
                    ElseIf PosR < 0 Then
                        PosR = 0
                    ElseIf PosR > 30 Then
                    
                        PosR = 30
                    End If
                    Form1.ProgressBar1 = 40 + PosR
                    Call UpdateF2Prog
                    '251787
                
                End If
                'PosR = PosR / 267000
                
                Close #FF
                
                'Form1.ProgressBar1 = 40 + PosR * 30
                
                ChDir oDir
                ChDrive oDir
                
            End If
        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 1 Then
        Counter = 0

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 100
            'AbortFlag = 1

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scProcess = hProcess
                scWndJob = hWndJob
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Open "outfile" For Input As #1
                Hold = LOF(1) / OutSize
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)
                
                Close #1
                On Error GoTo 0
                Form1.SSPanel1.Caption = Int(Hold * BSBootReps) & " of " & Int(BSBootReps) & " replicates completed"
                EndT = Abs(GetTickCount)

                If Hold > 0 And Hold < 1 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((((EndT - STartT) / Hold) - (EndT - STartT))) & " remaining"
                End If

                BSEnd = Abs(GetTickCount)
                Form1.Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                Form1.Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)
                Counter = 0
                Call UpdateF2Prog
            End If

        Loop While nRet = STILL_ACTIVE

        Form1.SSPanel1.Caption = Int(BSBootReps) & " of " & Int(BSBootReps) & " replicates completed"
    ElseIf BatIndex = 2 Then
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep SleepInterval

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Open "outfile" For Input As #1
                Hold = LOF(1) / OutSize
                Close #1
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)

                If Int(Hold * Len(StrainSeq(0)) / BSStepSize) <= Int(Len(StrainSeq(0)) / BSStepSize) + 1 Then
                    Form1.SSPanel1.Caption = Int(Hold * Len(StrainSeq(0)) / BSStepSize) & " of " & Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " windows examined"
                End If

                EndT = Abs(GetTickCount)

                If Hold > 0 And Hold < 1 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((((EndT - STartT) / Hold) - (EndT - STartT))) & " remaining"
                End If

                BSEnd = Abs(GetTickCount)
                Form1.Label50(4).Caption = DoTimeII(BSEnd - BSStart) 'Str$((Int((BSEnd - BSStart) / 100)) / 10)
                Form1.Label50(12).Caption = DoTimeII(BSEnd - ST) 'Str$((Int((BSEnd - ST) / 100)) / 10)

                If Hold < 0.9 Then
                    SleepInterval = 500
                ElseIf Hold < 0.95 Then
                    SleepInterval = 500
                Else
                    SleepInterval = 100
                End If
                Call UpdateF2Prog
                On Error GoTo 0
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

        Form1.SSPanel1.Caption = Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " of " & Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " windows examined"
    ElseIf BatIndex = 4 Then 'fastDNAml
        Counter = 0
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "checkpoint.0"
        On Error GoTo 0
        Form1.SSPanel13 = ""
        SleepInterval = 100
        AddS = 2

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 500

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Open "checkpoint.0" For Binary Access Read As #1
                Getstring = String$(LOF(1), " ")
                Get #1, 1, Getstring
                Close #1
                Pos = 0
                NumLines = 0

                Do
                    Pos = InStr(Pos + 1, Getstring, "ntaxa =", vbBinaryCompare)

                    If Pos > 0 Then
                        LPos = Pos
                    End If

                    NumLines = NumLines + 1
                Loop While Pos > 0

                If LPos > 0 Then
                    Pos = InStr(LPos, Getstring, ",", vbBinaryCompare)
                    Hold = CDbl(Mid$(Getstring, LPos + 7, Pos - (LPos + 7)))

                    If Hold > NextNo Then Hold = NextNo
                    Form1.SSPanel1.Caption = "Adding " + Left(OriginalName(Hold), 17) + " to ML tree"
                    Form2.SSPanel3.Caption = Form1.SSPanel1.Caption

                    If LastAdd <> Hold Then
                        AddS = AddS + 1

                        If AddS > NextNo Then AddS = NextNo
                        Form1.ProgressBar1.Value = ((AddS ^ 3) / (NextNo ^ 3)) * 90
                        Form2.ProgressBar1.Value = Form1.ProgressBar1.Value
                        Call UpdateF2Prog
                        LastAdd = Hold
                    End If

                End If

                On Error GoTo 0
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

    ElseIf BatIndex = 5 Then
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep SleepInterval

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Open "outfile" For Input As #1
                Hold = LOF(1) / OutSize
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)

                If Int(Hold * Len(StrainSeq(0)) / BSStepSize) <= Int(Len(StrainSeq(0)) / BSStepSize) + 1 Then
                    Form1.SSPanel1.Caption = "Calculated for " & Int(Hold * TBSReps) & " of " & TBSReps & "  Replicates"
                End If

                EndT = Abs(GetTickCount)
                BSEnd = Abs(GetTickCount)

                If Hold < 0.9 Then
                    SleepInterval = 2000
                ElseIf Hold < 0.95 Then
                    SleepInterval = 500
                Else
                    SleepInterval = 100
                End If

                Close #1
                On Error GoTo 0
                Call UpdateF2Prog
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE

        Form1.SSPanel1.Caption = Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " of " & Int(Len(StrainSeq(0)) / BSStepSize) + 1 & " windows examined"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    ElseIf BatIndex = 6 Then 'neighbor/fitch
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            Sleep 100

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If

            Counter = Counter + 1

            If Counter = 2 And DoneThis <> 1 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Open "outtree" For Binary Access Read As #1
                Getstring = String$(LOF(1), " ")
                Get #1, 1, Getstring
                Close #1
                On Error GoTo 0
                Pos = 0
                Pos = InStr(1, Getstring, ";", vbBinaryCompare)

                If Pos > 0 Then
                    OneTree = Pos
                    DoneThis = 1
                End If

                Counter = 0
            ElseIf Counter = 2 And DoneThis = 1 Then
                If DebuggingFlag < 2 Then On Error Resume Next
                Open "outtree" For Binary Access Read As #1
                LOF1 = LOF(1)
                Close #1
                On Error GoTo 0
                Hold = (LOF1 / OneTree) / TBSReps

                If Hold > 1 Then Hold = 1
                Form1.ProgressBar1 = PBStart + Hold * (PBTarget - PBStart)
                Form1.SSPanel1.Caption = "Trees constructed for " & CInt(Hold * TBSReps) & " of " & TBSReps & "  replicates"
                Call UpdateF2Prog
                Counter = 0
            End If

        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 7 Then 'phyml
        
        Counter = 0
        Form1.SSPanel13 = ""
        SleepInterval = 100

        Do
            SizeTarget = ((23 * (NextNo + 1)) * TBSReps)
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            
            DoEvents
            Sleep 1000
            
            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            If DebuggingFlag < 2 Then On Error Resume Next
            
            'the filelen thing dowsnt work if the tree file is open in phyml
            FLe = 0 'FileLen("infile_phyml_boot_trees.txt")
            'On Error GoTo 0
            Open "infile_phyml_boot_trees.txt" For Binary Access Read As #1
            FLe = LOF(1)
            Close #1
            On Error GoTo 0
            If FLe > 0 Then
                If FLe < SizeTarget Then
                    Form1.ProgressBar1 = 5 + (FLe / SizeTarget) * 95
                    Form1.SSPanel1.Caption = "Trees drawn for " & Trim(Str(CInt((FLe / SizeTarget) * TBSReps))) & " of " & TBSReps & "  replicates"
                Else
                    Form1.ProgressBar1 = 100
                    Form1.SSPanel1.Caption = "Trees drawn for " & CInt(TBSReps) & " of " & TBSReps & "  replicates"
                End If
                Call UpdateF2Prog
            End If
        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 8 Then 'interval

        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            'Form1.Picture16.ScaleHeight = Nextno * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            Sleep 50
            
            'Open "infile_phyml_boot_trees.txt" For Binary Access Read As #1
            'fle = LOF(1)
            'Close #1
            SS = Abs(GetTickCount)
            If SS > LL + 1000 Then
                LL = SS
                If DebuggingFlag < 3 Then On Error Resume Next
                FLe = FileLen("rates.txt")
                On Error GoTo 0
            
                If FLe > 0 Then
                'XX = FLe / TargetFileSize
                    If FLe < TargetFileSize Then
                        Form1.ProgressBar1 = 5 + (FLe / TargetFileSize) * 95
                        Form1.SSPanel1.Caption = Trim(Str(CLng((FLe / TargetFileSize) * FullSize))) + " of " & Trim(Str(FullSize)) & "  MCMC updates completed"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    Else
                        Form1.ProgressBar1 = 100
                        Form1.SSPanel1.Caption = Trim(Str(FullSize)) + " of " & Trim(Str(FullSize)) & "  MCMC updates completed"
                        Form1.SSPanel1.Refresh
                        Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    End If
                    Call UpdateF2Prog
                    
                End If
                DoEvents
            End If
        Loop While nRet = STILL_ACTIVE
'X = X
   
    ElseIf BatIndex = 9 Then
        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            'Form1.Picture16.ScaleHeight = Nextno * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            Sleep 50
            SSS = Abs(GetTickCount)
            If Abs(SSS - EEE) > 500 Then
                EEE = SSS
                FFX = FreeFile
                
                On Error Resume Next
                Open "outfile" For Binary Access Read As #FFX
                    FLe = LOF(FFX)
                Close #FFX
                On Error GoTo 0
                Form1.ProgressBar1.Value = StartProgress + (EndProgress - StartProgress) * FLe / ExpectFL
                If EndProgress = 90 Then
                    Form1.SSPanel1.Caption = "Calculted " + CStr(CLng((FLe / ExpectFL) * (ExpectFL / 30))) + " of " + CStr(CLng(ExpectFL / 30)) + " SS scores"
                Else
                    Form1.SSPanel1.Caption = "Recalculted " + CStr(CLng((FLe / ExpectFL) * (ExpectFL / 30))) + " of " + CStr(CLng(ExpectFL / 30)) + " SS scores"
                End If
                Call UpdateF2Prog
            End If
        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 25 Then
        Dim tRead As String, SD As String, GenNo As String, xGenNo As Long, xSD As Double
        tRead = String(1000, " ")
        Do
            
            Form1.Command25.Enabled = True
            Form1.Command25.ToolTipText = "Stop the Bayesian tree construction"
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            'Form1.Picture16.ScaleHeight = Nextno * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            Sleep 50
            CT = Abs(GetTickCount)
            If Abs(CT - lCT) > 2000 Then
                lCT = CT
                FF = FreeFile
                Open "boptout" For Binary As #FF
                LF = LOF(FF)
                If LF > 1100 Then
                    Get #FF, LF - 1100, tRead
                End If
                Close #FF
                'Open "testout" For Output As #28
                'Close #28
                'Print#28, tread
                If LastSize = LF Then
                    BailFlag = BailFlag + 1
                    If BailFlag > 200 Then
                        MsgBox ("Something has gone wrong with MrBayes.  You may need to shut it down manually using Windows Task Manager.  Press 'ctl-alt-del', find 'MrBayes' on the Processes tab and shut it down")
                        AbortFlag = 1
                    End If
                Else
                    BailFlag = 0
                End If
                LastSize = LF
                
                If LF > 1100 Then
                    Pos = InStr(1, tRead, "Average standard deviation of split frequencies", vbBinaryCompare)
                    If Pos > 0 Then
                        Do While Pos > 0
                            LPos = Pos + 1
                            Pos = InStr(LPos, tRead, "Average standard deviation of split frequencies", vbBinaryCompare)
                            
                        Loop
                        SD = Trim(Mid$(tRead, LPos + 47, 9))
                        'X = X
                    End If
                    '-- (
                    Pos = InStr(1, tRead, "-- (", vbBinaryCompare)
                    If Pos = 0 Then Pos = InStr(1, tRead, "-- [", vbBinaryCompare)
                    If Pos > 0 Then
                        Do While Pos > 0
                            LPos = Pos + 1
                            Pos = InStr(LPos, tRead, "-- (", vbBinaryCompare)
                            If Pos = 0 Then Pos = InStr(LPos, tRead, "-- [", vbBinaryCompare)
                            
                        Loop
                        GenNo = Trim(Mid$(tRead, LPos - 13, 11))
                        'X = X
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next
                    'xSD = val(SD)
                    xSD = CDbl(val(SD))
                    xGenNo = val(GenNo)
                    On Error GoTo 0
                    If GenNo <> "" Or SD <> "" Then
                        x = x + 1
                        If x < 5 Or SD = "" Then
                            Form1.SSPanel1.Caption = GenNo + " of" + Str(TBNGens) + " generations completed"
                        ElseIf x < 10 Then
                           Form1.SSPanel1.Caption = "Standard deviation of split frequencies = " + SD
                           
                        Else
                            x = 0
                        End If
                        
                        If Form2.Visible = True Then
                            Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
                            x = x
                        End If
                        
                        Dim SDV As Double
                        GCV = GenNo / TBNGens
                        If SD <> "" And val(SD) > 0 Then
                            SDV = 0.01 / SD
                        Else
                            SDV = 0.02
                        End If
                        If GCV > mGCV Then mGCV = GCV
                        If SDV > mSDV Then mSDV = SDV
                        If mGCV > mSDV Then
                        If mGCV <= 1 Then
                            Form1.ProgressBar1.Value = mGCV * PBTarget
                        Else
                            Form1.ProgressBar1.Value = 100
                        End If
                        Call UpdateF2Prog
                        Else
                            If mSDV <= 1 Then
                                Form1.ProgressBar1.Value = mSDV * PBTarget
                            Else
                                Form1.ProgressBar1.Value = 100
                            End If
                            Call UpdateF2Prog
                        End If
                    End If
                End If
            End If
            
        Loop While nRet = STILL_ACTIVE
        x = x
    ElseIf BatIndex = 26 Then 'MrBayes ANcSeqEstimation
        Dim SDLeft As Long, SC As Long, CC As Long, SDCheck(3) As Double, CheckTime(3) As Long, SDRat(3) As Double
        SC = Abs(GetTickCount) 'start the clock
        tRead = String(3000, " ")
        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            'Form1.Picture16.ScaleHeight = Nextno * 13
            Form1.Command25.Enabled = True
            Form1.Command25.ToolTipText = "Stop the Bayesian tree construction"
            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            Sleep 50
            CT = Abs(GetTickCount)
            'Form1.Command1.SetFocus
            'Form1.Command3.SetFocus
            If Abs(CT - lCT) > 2000 Then
            If DebuggingFlag < 2 Then On Error Resume Next

                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                lCT = CT
                FF = FreeFile
                Open "boptout" For Binary As #FF
                LF = LOF(FF)
                If LF > 3100 Then
                    Get #FF, LF - 3100, tRead
                End If
                Close #FF
                'Open "testout" For Output As #28
                'Close #28
                'Print#28, tread
                If LastSize = LF Then
                    BailFlag = BailFlag + 1
                    If BailFlag > 1000 Then
                    '    MsgBox ("Something has gone wrong with MrBayes.  You may need to shut it down manually using Windows Task Manager.  Press 'ctl-alt-del', find 'MrBayes' on the Processes tab and shut it down")
                    '    AbortFlag = 1
                    End If
                Else
                    BailFlag = 0
                End If
                
                
                If LF > 3100 And LF <> LastSize Then
                    LastSize = LF
                    Pos = InStr(1, tRead, "Average standard deviation of split frequencies", vbBinaryCompare)
                    'XX = Len(tRead)
                    oPos = Pos
                    If Pos > 0 Then
                        
                        Do While Pos > 0
                            LPos = Pos + 1
                            Pos = InStr(LPos, tRead, "Average standard deviation of split frequencies", vbBinaryCompare)
                            
                        Loop
                        If PartNo > 0 Then
                            Pos = InStr(oPos + 1, tRead, ":", vbBinaryCompare)
                            If Pos > 0 Then
                                SD = Trim(Mid$(tRead, Pos + 1, 9))
                            End If
                        Else
                            SD = Trim(Mid$(tRead, LPos + 47, 9))
                        End If
                        x = x
                    End If
                    '-- (
                    Pos = InStr(1, tRead, "-- (", vbBinaryCompare)
                    If Pos = 0 Then Pos = InStr(1, tRead, "-- [", vbBinaryCompare)
                    If Pos = 0 Then Pos = InStr(1, tRead, "-- -", vbBinaryCompare)
                    If Pos > 0 Then
                        Do While Pos > 0
                            LPos = Pos + 1
                            Pos = InStr(LPos, tRead, "-- (", vbBinaryCompare)
                            If Pos = 0 Then Pos = InStr(LPos, tRead, "-- [", vbBinaryCompare)
                            If Pos = 0 Then Pos = InStr(LPos, tRead, "-- -", vbBinaryCompare)
                            
                        Loop
                        If LPos > 13 Then
                            'XX = Mid$(tRead, LPos - 13, 11)
                            GenNo = Trim(Mid$(tRead, LPos - 13, 11))
                        End If
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next
                    xSD = val(SD)
                    xSD = CDbl(val(SD))
                    If (SDCheck(3) = 0 Or SDCheck(3) > xSD) And xSD > 0 Then
                        SDCheck(0) = SDCheck(1)
                        SDCheck(1) = SDCheck(2)
                        SDCheck(2) = SDCheck(3)
                        SDCheck(3) = xSD
                        CheckTime(0) = CheckTime(1)
                        CheckTime(1) = CheckTime(2)
                        CheckTime(2) = CheckTime(3)
                        CheckTime(3) = Abs(GetTickCount) - SC
                        x = x
                        DivI = 0
                        If SDCheck(0) > 0 Then
                            SDRat(0) = (1 - SDCheck(1) / SDCheck(0)) / Abs(CheckTime(1) - CheckTime(0))
                            DivI = DivI + 1
                        End If
                        If SDCheck(1) > 0 Then
                            SDRat(1) = (1 - SDCheck(2) / SDCheck(1)) / Abs(CheckTime(2) - CheckTime(1))
                            DivI = DivI + 1
                        End If
                        
                        If SDCheck(2) > 0 Then
                            DivI = DivI + 1
                            SDRat(2) = (1 - SDCheck(3) / SDCheck(2)) / Abs(CheckTime(3) - CheckTime(2))
                        
                            SDRat(3) = (SDRat(0) + SDRat(1) + SDRat(2)) / DivI
                            
                        Else
                            x = 0
                        
                        End If
                        
                    End If
                    If SDCheck(3) > 0 And SDRat(3) > 0 Then
                        SDLeft = (1 - 0.01 / SDCheck(3)) / SDRat(3)
                        
                    End If
                    xGenNo = val(GenNo)
                    On Error GoTo 0
                    If GenNo <> "" Or SD <> "" Then
                        x = x + 1
                        LongCount = LongCount + 1
                        If LongCount = 5 Then
                            LongCount = 0
                            Call CheckAncSeq
                        End If
                        If x < 3 Or SD = "" Then
                            If InStr(1, GenNo, ".", vbBinaryCompare) = 0 Then
                                If Trim(Left(GenNo, 5)) <> "Chain" Then
                                    Form1.SSPanel1.Caption = GenNo + " of" + Str(TBNGens) + " generations completed"
                                End If
                            End If
                        ElseIf x < 6 Then
                           Form1.SSPanel1.Caption = "Standard deviation of split frequencies = " + SD
                           
                           
                        ElseIf x < 9 Then
                            'work out rate of sd decrease
                            If SDCheck(2) > 0 And SDLeft > 0 Then
                                Form1.SSPanel1.Caption = "At least " & DoTime(SDLeft) & " until convergence"
                            Else
                                x = 0
                            End If
                            
                        Else
                            x = 0
                        End If
                        
                        If DebuggingFlag < 2 Then On Error Resume Next
                        GCV = val(GenNo) / TBNGens
                        If CDbl(val(SD)) <> 0 Then
                            If SD <> "" Then
                                SDV = 0.01 / CDbl(val(SD))
                            End If
                        End If
                        If GCV > mGCV Then mGCV = GCV
                        If SDV > mSDV Then mSDV = SDV
                        If SDCheck(3) > 0 And SDRat(3) > 0 And SDLeft > 0 Then
                            SDLeft = (1 - 0.01 / SDCheck(3)) / SDRat(3)
                            If Form1.ProgressBar1.Value < 10 + (CheckTime(3) / (SDLeft + CheckTime(3))) * 90 Then
                                Form1.ProgressBar1.Value = 10 + (CheckTime(3) / (SDLeft + CheckTime(3))) * 90
                                
                            End If
                        End If
                        On Error GoTo 0
                        Call UpdateF2Prog
                    End If
                Else
                    LastSize = LF
                End If
            End If
            
        Loop While nRet = STILL_ACTIVE
    ElseIf BatIndex = 53 Then 'raxml
         
         Dim RaxTmp As String, SL As Long, ToggleBS As Long
         ToggleBS = 0
         Do
            
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))

                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
            DoEvents
            'Form1.Picture16.ScaleHeight = Nextno * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            Sleep 100
            SS = Abs(GetTickCount)
            If Abs(SS - EE) > 500 Then
                EE = SS
                'If DebuggingFlag < 2 Then On Error Resume Next
                On Error Resume Next
                FLen = FileLen("RAxML_info.treefile")
                On Error GoTo 0
                If FLen > 0 And ToggleBS > 10 Then
                
                    ToggleBS = ToggleBS + 1
                    If ToggleBS = 15 Then ToggleBS = 0
                    Open "RAxML_info.treefile" For Binary As #10
                    SL = LOF(10)
                    RaxTmp = String(150, " ")
                    If SL > 150 Then
                        'If SL > 150 Then
                            Get #10, SL - 150, RaxTmp
                            Pos = InStr(1, RaxTmp, "Bootstrap[", vbBinaryCompare)
                            If Pos > 0 Then
                                PosN = InStr(Pos, RaxTmp, "]", vbBinaryCompare)
                                TX = Mid$(RaxTmp, Pos + 10, PosN - (Pos + 10))
                                Form1.SSPanel1.Caption = "Making ML Tree (with RAxML; " + Trim(Str(val(TX) + 1)) + " of " + Trim(Str(TBSReps)) + " bootstrap replicates completed)"
                                Form1.ProgressBar1 = 5 + (val(TX) / TBSReps) * 90
                                If Form2.Visible = True Then
                                    Call UpdateF2Prog
                                    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
                                End If
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                            End If
                        'End If
                    End If
                    Close #10
                Else
                    ToggleBS = ToggleBS + 1
                    FLen = 0
                    On Error Resume Next
                    FLen = FileLen("RAxML_log.treefile")
                    On Error GoTo 0
                    If FLen > 0 Then
                        Open "RAxML_log.treefile" For Binary As #10
                        SL = LOF(10)
                        RaxTmp = String(20, " ")
                        If SL > 20 Then
                            'If SL > 150 Then
                                Get #10, SL - 20, RaxTmp
                                Pos = InStr(1, RaxTmp, "-", vbBinaryCompare)
                                If Pos > 0 Then
                                    
                                    TX = Mid$(RaxTmp, Pos, Len(RaxTmp) - Pos)
                                    Form1.SSPanel1.Caption = "Making ML Tree (with RAxML; log likelihood = " + Trim(Str(val(TX) + 1)) + ")"
                                    If Form2.Visible = True Then
                                        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
                                    End If
                                End If
                            'End If
                        End If
                        Close #10
                        x = x
                    End If
                    
                End If
                'On Error GoTo 0
            End If
        Loop While nRet = STILL_ACTIVE
    Else

        Do
            
            TitleTmp = Space$(256)
            nRet = GetWindowText(hWndJob, TitleTmp, Len(TitleTmp))

            If nRet Then
                TitleTmp = UCase$(Left$(TitleTmp, nRet))
                
                If InStr(TitleTmp, "FINISHED") = 1 Then

                    Call SendMessage(hWndJob, WM_CLOSE, 0, 0)

                End If

            End If

            GetExitCodeProcess hProcess, nRet
           ' DoEvents
            Form1.WindowState = Form1.WindowState
            'Form1.Picture16.ScaleHeight = Nextno * 13

            If AbortFlag = 1 Then
                'GetExitCodeProcess hProcess, tExitCode
                'TerminateProcess hProcess, tExitCode
                'CloseHandle hProcess
                scWndJob = hWndJob
                scProcess = hProcess
                BatIndex = 0
                DoingShellFlag = DoingShellFlag - 1
                ShellAndClose = 0
                
                Exit Function
            End If
            '@'@'@'@'@'$'$'$'$'&
            If AllowDoEvensFlag = 1 Then
                DoEvents
                Sleep 200
            Else
                Sleep 50
            End If
            
        Loop While nRet = STILL_ACTIVE

    End If

    Call CloseHandle(hProcess)

    BatIndex = 0
    DoingShellFlag = DoingShellFlag - 1
    ShellAndClose = nRet
    
End Function
Public Sub TreeFont(TNo As Integer)

    Dim NameWidth() As Integer
    Dim MaxNPos As Integer
    Dim x As Long

    ReDim NameWidth(NextNo)
    TRegion = 0.8 * Form1.Picture16.ScaleWidth
    '@
    Do
        MaxNPos = 0

        For x = 0 To NextNo
            
            If Len(OriginalName(x)) > 50 Then
                OriginalName(x) = Left(OriginalName(x), 50)
            End If
            '@
            NameWidth(x) = Form1.Picture16.TextWidth(OriginalName(x))

            If MaxNPos < NameWidth(x) Then MaxNPos = NameWidth(x)
        Next 'X

        If MaxNPos <= Form1.Picture16.ScaleWidth - TRegion Then
            Exit Do
        Else
            TRegion = TRegion * 0.9
        End If

        For x = 0 To NextNo
            NameWidth(x) = Form1.Picture16.TextWidth(OriginalName(x))
            
            If MaxNPos < NameWidth(x) Then MaxNPos = NameWidth(x)
        Next 'X

        If MaxNPos <= Form1.Picture16.ScaleWidth - TRegion Then
            Exit Do
        Else
            Form1.Picture16.FontSize = Form1.Picture16.FontSize - 0.5
            If Form1.Picture16.FontSize < 1.5 Then Exit Do
        End If

    Loop


    If CurTree(TNo) = 0 Then

        For x = 0 To NextNo
            XCord(0, TNo, x) = TRegion
        Next 'X

    End If

End Sub
Public Sub GetOutie()
    'Determines which sequence in an alignment
    'is likely to make the best outlyer

    Dim TD() As Double, x As Long, Y As Long, MD As Long

    If DistanceFlag = 0 Then  'If distancematrix not yet calculated

        Call CalcDistances(SeqNum(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)

    End If

    ReDim TempSeq(NextNo + 2)
    If UBound(StrainSeq, 1) < NextNo Then
        ReDim Preserve StrainSeq(NextNo)
    End If
    For x = 0 To NextNo
        TempSeq(x) = StrainSeq(x)
    Next 'X

    ReDim TD(UBound(Distance, 1))
    
    For x = 0 To UBound(Distance, 1)

        For Y = 0 To UBound(Distance, 2)
            TD(x) = TD(x) + Distance(x, Y)
        Next 'Y

    Next 'X
    
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
    
    MD = 1000000

    For x = 0 To NextNo
        If x <= UBound(TD, 1) Then
            If TD(x) < MD Then
                MD = TD(x)
                Outie = x
            End If
        End If
    Next 'X

End Sub
Public Sub CalcBPFreqs(AFreq As Double, CFreq As Double, GFreq As Double, TFreq As Double)
    'Calculates the frequency of different nucleotides in an alignment

    Dim x As Integer, Y As Integer
    Dim A As Long, C As Long, g As Long, T As Long, SeqLen As Long

    SeqLen = Len(StrainSeq(0))

    For x = 1 To SeqLen

        For Y = 0 To ToNumSeqs

            If SeqNum(x, Y) = 66 Then
                A = A + 1
            ElseIf SeqNum(x, Y) = 68 Then
                C = C + 1
            ElseIf SeqNum(x, Y) = 72 Then
                g = g + 1
            ElseIf SeqNum(x, Y) = 85 Then
                T = T + 1
            End If

        Next 'Y

    Next 'X

    AFreq = A / (A + C + g + T)
    CFreq = C / (A + C + g + T)
    GFreq = g / (A + C + g + T)
    TFreq = T / (A + C + g + T)
End Sub

Public Sub ReadDistMatrix(SeqNumber As Long, MatrixFileName As String)

    Dim MatrixByte() As Byte
    Dim Getstring As String
    Dim MatrixLen As Long
    Dim x As Integer, A As Integer, b As Integer

    'Open the phylip dnadist "outfile" and read data into a string and a byte array
    Open MatrixFileName For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component DNADIST.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    MatrixLen = LOF(1)
    Getstring = String$(MatrixLen, " ")
    ReDim MatrixByte(MatrixLen)
    Get #1, 1, MatrixByte()
    Get #1, 1, Getstring
    Close #1
    'Scan through the matrix for "." and read the number associated
    'into a double array with dimentions SeqNumber*SeqNumber
    A = 0
    b = 0

    Dim NoPeaces As Integer

    NoPeaces = (Len(TOSeq(0)) / 32000) + 1
    NewLen = Len(TOSeq(0)) / NoPeaces

    Dim MLenMO As Long

    If NoPeaces = 0 Then NoPeaces = 1
    MLenMO = MatrixLen - 1
    ReDim DistMatrix((SeqNumber + 1) * NoPeaces - 1, (SeqNumber + 1) * NoPeaces - 1)

    For x = 0 To MLenMO

        If MatrixByte(x) = 46 Then '"."
            DistMatrix(A, b) = CDbl(Mid$(Getstring, x - 1, 7))
            A = A + 1

            If A = (SeqNumber + 1) * NoPeaces Then
                A = 0
                b = b + 1
            End If

        End If

    Next 'X

End Sub

Public Function ChiPVal(x As Double)
Dim PValHolder As Double, Dummy As Double
    If x <= 0 Then
        ChiPVal = 1
    Else
        
        PValHolder = (NormalZ(-Sqr(x)))
        
        If PValHolder = 0 Then
            PValHolder = 10 ^ -9 / (x - 35)
        End If
        ChiPVal = PValHolder
    End If
    
End Function
Public Function NormalZ(Z As Double)
Dim WinP As Variant, Temp2 As Variant, Temp As Variant, Y As Variant, x As Variant, W As Variant
Dim Z_MAX As Double
Z_MAX = 6
    
'
If Abs(Z) < 6 Then
    If Z = 0# Then
        x = 0#
    Else
        Y = 0.5 * Abs(Z)
        If Y >= (Z_MAX * 0.5) Then
            x = 1#
        ElseIf Y < 1# Then
            
            W = Y * Y
            x = ((((((((0.000124818987 * W - 0.001075204047) * W + 0.005198775019) * W - 0.019198292004) * W + 0.059054035642) * W - 0.151968751364) * W + 0.319152932694) * W - 0.5319230073) * W + 0.797884560593) * Y * 2#
            
        Else
            
            Y = Y - 2#
            x = (((((((((((((-0.000045255659 * Y _
                + 0.00015252929) * Y - 0.000019538132) * Y _
                - 0.000676904986) * Y + 0.001390604284) * Y _
                - 0.00079462082) * Y - 0.002034254874) * Y _
                + 0.006549791214) * Y - 0.010557625006) * Y _
                + 0.011630447319) * Y - 0.009279453341) * Y _
                + 0.005353579108) * Y - 0.002141268741) * Y _
                    + 0.000535310849) * Y + 0.999936657524
        End If
           
        If ((x + 1#)) < ((1# - x)) Then
            NormalZ = (x + 1#)
        Else
            NormalZ = (1# - x)
        End If
    End If
Else
    Temp = ((Abs(Z) - 6) * 10)
    If Temp = 0 Then Temp = 1
    On Error GoTo finishup
    Temp2 = 1.6 ^ Temp
    WinP = (10 ^ -9) / Temp2
    NormalZ = WinP
    On Error GoTo 0
End If
Exit Function
finishup:
NormalZ = 10 ^ -30
End Function

Public Sub DoTreeMask()
Form1.AutoRedraw = True
Pict = 0
                        If DebuggingFlag < 2 Then On Error Resume Next
                        Pict = Form1.Picture16.hdc
                        On Error GoTo 0
                        
                        If Pict = 0 Then Form1.Picture16.AutoRedraw = False
                        
F2TreeIndex = 0

If TwipPerPix = 12 Then AddjNum = 14 Else AddjNum = 14
            OldFontSize = Form1.Picture16.FontSize
            For CurrentSeq = 0 To NextNo
                Form1.Picture16.CurrentY = YCord(CTF, F2TreeIndex, CurrentSeq)
                Form1.Picture16.CurrentX = XCord(CTF, F2TreeIndex, CurrentSeq)
                'th and tw
                If ((CurrentSeq <> Seq1 And CurrentSeq <> Seq2 And CurrentSeq <> Seq3) Or (RelX = 0 And RelY = 0)) And TreeTypeFlag = 0 Then 'And MultColour(CurrentSeq) > 0 Then
                        
                        A = Form1.Picture16.CurrentX
                        b = Form1.Picture16.CurrentY
                        
                        oB = b
                        
                        Form1.Picture16.Line (A, b + 3)-(A + 1500, b + AddjNum + 1), BackColours, BF
                        Form1.Picture16.CurrentX = A
                        Form1.Picture16.CurrentY = b
                        'form1.picture16.print originalname(CurrentSeq)
                        If MaskSeq(CurrentSeq) = 0 Then
                            Form1.Picture16.ForeColor = 0
                        ElseIf MaskSeq(CurrentSeq) = 1 Then
                            Form1.Picture16.ForeColor = QBColor(8)
                        ElseIf MaskSeq(CurrentSeq) = 2 Then
                            Form1.Picture16.ForeColor = ThreeQuaterColour
                        End If
                        'Form1.Picture16.ForeColor = SeqCol(CurrentSeq)
                        Form1.Picture16.Print OriginalName(CurrentSeq)
                        
                    
                    'On Error GoTo 0
                ElseIf (RelX > 0 Or RelY > 0) And TreeTypeFlag = 0 Then
                    A = Form1.Picture16.CurrentX
                    b = Form1.Picture16.CurrentY
                    Form1.Picture16.Line (A, b + 3)-(A + 1500, b + AddjNum + 1), BackColours, BF
                    Form1.Picture16.CurrentX = A
                    Form1.Picture16.CurrentY = b
                    If CurrentSeq = Seq2 Then
                        
                        'form1.picture16.print originalname(CurrentSeq)
                        
                        If OutsideFlagX = 2 Then
                            Form1.Picture16.ForeColor = RGB(0, 0, 128)
                        Else
                            Form1.Picture16.ForeColor = RGB(0, 0, 255)
                        End If
                        Form1.Picture16.Print OriginalName(Seq2)
                    ElseIf CurrentSeq = Seq1 Then
                        
                        If OutsideFlagX = 1 Then
                            Form1.Picture16.ForeColor = RGB(0, 0, 128)
                        Else
                            Form1.Picture16.ForeColor = RGB(0, 0, 255)
                        End If
                        Form1.Picture16.Print OriginalName(Seq1)
                        
                    Else
                        
                    
                        Form1.Picture16.ForeColor = RGB(255, 0, 0)
                        
                        Form1.Picture16.Print OriginalName(Seq3)
                        
                    End If
                End If
        
        Next 'CurrentSeq
        Form1.Picture16.FontSize = OldFontSize
        Form1.Picture16.ForeColor = 0
End Sub
Public Sub AverageMatrix(SeqNum As Long, AverageMatrix As Double)

    Dim x As Long, Y As Long, Z As Long
    Dim MatrixSum As Double

    'Sum matrix and divide by elements

    If Len(TOSeq(0)) < 32000 Then

        For x = 0 To SeqNum

            For Y = 0 To SeqNum
                MatrixSum = MatrixSum + TotMat(x, Y)
            Next 'Y

        Next 'X

        AverageMatrix = MatrixSum / ((SeqNum + 1) * (SeqNum + 1))
        x = x
    Else

        Dim NoPeaces As Long, NoPMO As Long

        NoPeaces = (Len(TOSeq(0)) / 32000) + 1
        NoPMO = NoPeaces - 1
        NewLen = Len(TOSeq(0)) / NoPeaces

        If NoPeaces = 0 Then NoPeaces = 1

        'For Z = 0 To NoPMO

            For x = 0 To SeqNum
                'XX = UBound(TotMat, 2)
                For Y = 0 To SeqNum
                    MatrixSum = MatrixSum + TotMat(x, Y)
                Next 'Y

            Next 'X

        'Next 'Z

        AverageMatrix = MatrixSum / ((((SeqNum + 1) * (SeqNum + 1))))
    End If

End Sub
Public Sub DoSelectInterface()




    Dim Current1 As Long, Current2 As Long
    
    Form5.Picture2.AutoRedraw = True
    Form5.Picture1.AutoRedraw = True
    Form5.Picture1.CurrentY = 0
    Form5.Picture2.CurrentY = 0
    Form5.Picture1.Picture = LoadPicture()
    Form5.Picture2.Picture = LoadPicture()




    Dim x As Integer




    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X
    If QvRSelectFlag = 1 Then
        Form5.Label3.Caption = "Sequences in reference group " + Trim(Str(Form5.Combo1.ListIndex))
        If QvRShowOnlyFlag = 0 Then
            Form5.Label2.Caption = "Sequences not in reference group " + Trim(Str(Form5.Combo1.ListIndex))
        Else
            Form5.Label2.Caption = "Sequences not in any reference group"
        End If
        If QvRShowOnlyFlag = 0 Then
            For x = 0 To PermNextno
        
                If ReferenceList(x) <> Form5.Combo1.ListIndex Then
                    
                    If ReferenceList(x) = 0 Then
                        UYPos(Current1) = x
                        Current1 = Current1 + 1
                    End If
                    
                ElseIf ReferenceList(x) = Form5.Combo1.ListIndex Then
                    SYPos(Current2) = x
                    Current2 = Current2 + 1
                End If
        
            Next 'X
            For x = 0 To PermNextno
        
                If ReferenceList(x) <> Form5.Combo1.ListIndex Then
                    If ReferenceList(x) <> 0 Then
                        UYPos(Current1) = x
                        Current1 = Current1 + 1
                    End If
                End If
        
            Next 'X
            x = x
        Else
        
            For x = 0 To PermNextno
        
                If ReferenceList(x) <> Form5.Combo1.ListIndex Then
                    
                    If ReferenceList(x) = 0 Then
                        UYPos(Current1) = x
                        Current1 = Current1 + 1
                    End If
                    
                ElseIf ReferenceList(x) = Form5.Combo1.ListIndex Then
                    SYPos(Current2) = x
                    Current2 = Current2 + 1
                End If
        
            Next 'X
        End If
    Else
        For x = 0 To PermNextno
    
            If Selected(x) = 0 And (x <> Form5.Combo1.ListIndex - 1 Or DDF5C = 1) Then
                UYPos(Current1) = x
                Current1 = Current1 + 1
            ElseIf Selected(x) = 1 And (x <> Form5.Combo1.ListIndex - 1 Or DDF5C = 1) Then
                SYPos(Current2) = x
                
                Current2 = Current2 + 1
                
                
            ElseIf x = Form5.Combo1.ListIndex - 1 And DontChangeAnything = 0 Then
                Selected(x) = 0
            End If
    
        Next 'X
    End If
    Dim TextHi As Long




    TextHi = Form5.Picture1.TextHeight(OriginalName(0)) / Screen.TwipsPerPixelY
    Current1 = (Current1 + 1) * Screen.TwipsPerPixelY * TextHi
    Current2 = (Current2 + 1) * Screen.TwipsPerPixelY * TextHi
    Form5.Picture1.Height = Current1
    Form5.Picture2.Height = Current2
    'print names now that pictureboxes are the right sizes
    
    If QvRSelectFlag = 1 Then
        For x = 0 To PermNextno
             If UYPos(x) > -1 Then
                If ReferenceList(UYPos(x)) <> Form5.Combo1.ListIndex Then
                    If QvRShowOnlyFlag = 0 Then
                       Form5.Picture1.Print (OriginalName(UYPos(x)))
                    Else
                       If ReferenceList(UYPos(x)) = 0 Then
                           Form5.Picture1.Print (OriginalName(UYPos(x)))
                       End If
                    End If
                End If
            End If
            If SYPos(x) > -1 Then
                 If ReferenceList(SYPos(x)) = Form5.Combo1.ListIndex Then
                    
                     
                     Form5.Picture2.Print (OriginalName(SYPos(x)))
                
                 End If
            End If
           
    
        Next 'X
    Else
        For x = 0 To PermNextno
            If x <= UBound(Selected, 1) Then
                 If Selected(x) = 0 And x <> Form5.Combo1.ListIndex - 1 Then
                     
                     Form5.Picture1.Print (OriginalName(x))
                     
                 ElseIf Selected(x) = 1 And x <> Form5.Combo1.ListIndex - 1 Then
                    
                     
                     Form5.Picture2.Print (OriginalName(x))
                
                 End If
            End If
    
        Next 'X
    End If
    
    
    



If Form5.Picture1.Height > Form5.Picture3.Height Then
        Form5.VScroll1.Enabled = True
        Form5.VScroll1.Max = (Form5.Picture1.Height - Form5.Picture3.Height) / Screen.TwipsPerPixelY
        Form5.VScroll1.SmallChange = TextHi
        Form5.VScroll1.LargeChange = TextHi * 5
    Else

        If Form5.VScroll1.Enabled = True Then
            Form5.VScroll1.Value = 0
            Form5.VScroll1.Enabled = False
        End If
    End If




    If Form5.Picture2.Height > Form5.Picture4.Height Then
        Form5.VScroll2.Enabled = True
        Form5.VScroll2.Max = (Form5.Picture2.Height - Form5.Picture4.Height) / Screen.TwipsPerPixelY
        Form5.VScroll2.SmallChange = TextHi
        Form5.VScroll2.LargeChange = TextHi * 5
        Form5.VScroll2.Value = Form5.VScroll2.Max
    Else
        If Form5.VScroll2.Enabled = True Then
            Form5.VScroll2.Value = 0
            Form5.VScroll2.Enabled = False
        End If
    End If




    Form5.Picture2.Refresh
    Form5.Picture1.Refresh
    x = x
End Sub
Public Sub MatrixMultiply(SeqNum As Long, MultFactor As Double)

    Dim x As Integer, Y As Integer

    'Multiply every element of the matrix by "Multfactor"

    If MultFactor > -1 Then

        For x = 0 To SeqNum

            For Y = 0 To SeqNum
                TotMat(x, Y) = CLng((TotMat(x, Y) * MultFactor) * 10000) / 10000
                'X = X
            Next 'Y

        Next 'X

    End If

End Sub
Public Sub WriteDistMatrix(SeqNumber As Long)

    Dim OutString As String
    Dim x As Integer, Y As Integer

    Open "infile" For Output As #1
    Print #1, "  " & CStr(SeqNumber + 1)

    For x = 0 To SeqNumber
        OutString = "S" & Trim$(CStr(x)) & String$(9 - Len(Trim$(CStr(x))), " ")

        For Y = 0 To SeqNumber

            If DistMatrix(x, Y) = 0 Then
                OutString = OutString & "  0.0000"
            ElseIf DistMatrix(x, Y) = 1 Then
                OutString = OutString & "  1.0000"
            ElseIf DistMatrix(x, Y) > 1 Then
                OutString = OutString & "  " & DistMatrix(x, Y) & String$((6 - Len(Trim$(CStr(DistMatrix(x, Y))))), "0")
            Else
                OutString = OutString & "  " & DistMatrix(x, Y) & String$((5 - Len(Trim$(CStr(DistMatrix(x, Y))))), "0")
            End If

        Next 'Y

        Print #1, OutString
    Next 'X

    Close #1
End Sub




Public Function DoTime(TimeS As Variant) As String

    Dim tMinR As Single, tHourR As Long, StringT As String, HourR As Long, MinR As Long, SecR As Double

    TimeS = TimeS / 1000
    If TimeS < 10 ^ 9 Then
        TimeS = CLng(TimeS)
    Else
        TimeS = 10 ^ 9
    End If
    If TimeS >= 3600 Then

        If TimeS / 3600 < 32000 Then
            HourR = Int(TimeS / 3600)
        Else
            HourR = TimeS / 3600 - 1
        End If

        If HourR < 10 Then StringT = "0"
        StringT = StringT + Trim$(CStr(HourR)) + "h:"
        tHourR = HourR
    End If

    If TimeS >= 60 Then
        
        tHourR = HourR
        tMinR = (TimeS - tHourR * 3600) / 60
        MinR = CLng(tMinR - 0.5)
        If MinR < 10 And HourR > 0 Then StringT = StringT + "0"

        If MinR > 0 Then
            StringT = StringT + Trim$(CStr(MinR)) + "m:"
        Else
            StringT = StringT + "0m:"
        End If

    End If

    SecR = TimeS - (tHourR * 3600) - (MinR * 60)

    If SecR < 10 And (MinR > 0 Or HourR > 0) Then
        StringT = StringT + "0"
    End If

    If SecR > 1 Then
        StringT = StringT + Trim$(CStr(SecR)) + "s"
    Else
        StringT = StringT + "0s"
    End If

    DoTime = StringT
End Function
Public Function DoTimeII(TimeS) As String

    Dim StringT As String, HourR As Long, MinR As Long, SecR As Double, SecD As String, Millis As String
    Millis = Trim(Str(CLng(TimeS)))
    If Len(Millis) >= 3 Then
        Millis = Right(Millis, 3)
        
    ElseIf Len(Millis) = 2 Then
        Millis = "0" + Millis
    ElseIf Len(Millis) = 1 Then
        Millis = "00" + Millis
    Else
        Millis = "000"
    End If
    Millis = Left(Millis, 2)
    SecD = Trim$(CStr(CInt((TimeS / 1000 - Int(TimeS / 1000)) * 100)))
    'SecD = CInt(SecD * 100)
    TimeS = CLng((TimeS / 1000) - 0.5)

    If TimeS >= 3600 Then

        If TimeS / 3600 < 32000 Then
            HourR = Int(TimeS / 3600)
        Else
            HourR = TimeS / 3600 - 1
        End If

        If HourR < 10 Then StringT = "0"
        StringT = StringT + Trim$(CStr(HourR)) + "h:"
    End If

    If TimeS >= 60 Then
        MinR = Int((TimeS - HourR * 3600) / 60)

        If MinR < 10 And HourR > 0 Then StringT = StringT + "0"

        If MinR > 0 Then
            StringT = StringT + Trim$(CStr(MinR)) + "m:"
        Else
            StringT = StringT + "0m:"
        End If

    End If

    SecR = TimeS - CLng(HourR * 3600) - CLng(MinR * 60)
'
    If SecR < 10 And (MinR > 0 Or HourR > 0) Then
        StringT = StringT + "0"
    End If

    If SecR >= 1 Then
        StringT = StringT + Trim$(CStr(SecR))
    Else
        StringT = StringT + "0"
    End If

    If MinR = 0 And HourR = 0 Then
'        If X = 12345 Then
'             If Len(SecD) = 0 Then
'                 SecD = "00"
'             ElseIf Len(SecD) = 1 Then
'                 SecD = SecD + "0"
'
'             ElseIf Len(SecD) >= 3 Then
'                 SecD = "00"
'             End If
'
'            StringT = StringT + "." + SecD
'        Else
            StringT = StringT + "." + Millis
'        End If
    End If

    StringT = StringT + "s"
    DoTimeII = StringT
End Function
Public Sub MakeBinArrayVB(Seq1 As Long, BinArray() As Byte)
Dim x As Long, Y As Long
For x = Seq1 + 1 To NextNo
    For Y = 1 To UBound(ISeq4, 1)
        BinArray(Y, x) = BinConverter4(ISeq4(Y, Seq1), ISeq4(Y, x))
    Next Y
Next x

End Sub
Public Sub NewScan()


Dim AAA As Long, Dummy As Long, GoOn As Long, b As Long, ZZZ As Long, LT As Long, oRec As Long


                        
ReDim BinArray(Len(StrainSeq(0)), NextNo)

Dim GoOnG() As Byte, ExitDoFlag As Byte, x As Long, UB As Long, ElementNum As Long, LenXOverSeqG() As Long, ElementSeq() As Long, XPosDiffG() As Long, XDiffPosG() As Long, AHG() As Long, XOverSeqnumWG() As Byte
Dim GrpTest As Long
Dim StSt As Long, SpacerSeqsG() As Integer, ValidSpacerG() As Integer, SpacerNoG() As Integer
GroupSize = 31

If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
    GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
End If
ReDim LenXOverSeqG(GroupSize)
ReDim ElementSeq(GroupSize)
ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize)
ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize)
ReDim AHG(2, GroupSize)
ReDim XOverSeqnumWG(UBound(XoverSeqNumW, 1), UBound(XoverSeqNumW, 2), GroupSize + 1)
UB = UBound(TreeDistance, 1)
ReDim SpacerSeqsG(UB, GroupSize), ValidSpacerG(UB, GroupSize), SpacerNoG(GroupSize)
ReDim Preserve MaskSeq(UB)

StSt = Abs(GetTickCount)


For AAA = 1 To 1
For Seq1 = 0 To NextNo

    If MaskSeq(Seq1) = 0 Then
        Dummy = MakeBinArrayP(Seq1, Len(StrainSeq(0)), NextNo, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0))
        'XX = BinArray(8, 3)
        For Seq2 = Seq1 + 1 To NextNo
            
            If MaskSeq(Seq2) = 0 Then
                Seq3 = Seq2
                'Need to refill xdiffposG, xposdiffG, ahG, xoverseqnumwG
                ExitDoFlag = 0
                Do
                    ElementNum = -1
                    
                    Do
                        
                        Seq3 = Seq3 + 1
                        If Seq3 > NextNo Then
                            ExitDoFlag = 1
                            Exit Do
                        End If
                        'If ExitDoFLag = 0 Then
                        If MaskSeq(Seq3) = 0 Then
                        
                            GoOn = 1
                            If SelGrpFlag > 0 Then
                                GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                If GrpTest >= 2 Then
                                    GoOn = 0
                                End If
                            End If
                            If GoOn = 1 Then
                                ElementNum = ElementNum + 1
                                ElementSeq(ElementNum) = Seq3
                            End If
                        End If
                    'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                        'For Seq3 = Seq2 + 1 To Nextno
                        If ElementNum = GroupSize Then Exit Do
                    Loop
                    'Do the xdiffpos calcs etc in parallel
                    If ElementNum > -1 Then
                        
                        
                        
                        ReDim GoOnG(ElementNum)
                        For x = 0 To ElementNum
                            
                            Seq3 = ElementSeq(x)
                            
                            GoOnG(x) = 1
                            If SpacerFlag > 0 Then
                                If SpacerFlag < 4 Then
                                    UB = UBound(TreeDistance, 1)
                                   If Seq1 <= UB And Seq2 <= UB And Seq3 <= UB Then
                                    InRangeFlag = SpacerFindB(UB, SpacerFlag, MiDistance, MaDistance, Seq1, Seq2, Seq3, Outlyer, SpacerNoG(x), TreeDistance(0, 0), Distance(0, 0), MaskSeq(0), SpacerSeqsG(0, x), ValidSpacerG(0, x))
                                   End If
                                    
                                    If InRangeFlag = 0 Then GoOnG(x) = 0
                                ElseIf SpacerFlag = 4 Then
                                    SpacerNoG(x) = 1
                                    
                                    SpacerSeqsG(1, x) = Spacer4No
                                End If
                            
                            
                            
                                'Find Information rich subsequences (takes 11/21)
                            
                                If SpacerNoG(x) = 0 Then
                                    GoOnG(x) = 0
                                End If
                            End If
                            
                            
                        Next x
                       ' ReDim XOverSeqnumWG(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3))
                        'WARNING: lenstrainseq here actually equals len(strainseq(0))+1
                        ''@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
                        Dummy = FindSubSeqP7(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXOverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, NextNo, Seq1, Seq2, ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
                        
                        For x = 0 To ElementNum
                            
                            Seq3 = ElementSeq(x)
                            
                            'If Maskseq(Seq3) = 0 Then
                                
                                LastY3 = -1
                                b = b + 1
                                ZZZ = ZZZ + 1
                                'aaa = Abs(GetTickCount)
                                'For X = 1 To 20                                            '
                                If LenXOverSeqG(x) >= XoverWindow * 2 Then
      
                                    Call XOverV(0, x, LenXOverSeqG(x), SpacerNoG(x), AHG(), XOverSeqnumWG(), SpacerSeqsG(), XDiffPosG(), XPosDiffG(), ValidSpacerG(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                
                                End If
                                If AbortFlag = 1 And NextNo * Len(StrainSeq(0)) > 50000 Then
                                    DoEvents
                                    Form1.SSPanel1.Caption = ""
                                    Form1.ProgressBar1.Value = 0
                                    Call UpdateF2Prog
                                    Seq1 = NextNo
                                    Seq2 = NextNo
                                    Seq3 = NextNo
                                End If
        
                            'End If
            
                            'Next 'Seq3
                        Next x
                        

                    End If
                    If ExitDoFlag = 1 Then Exit Do
                Loop
                Form1.WindowState = Form1.WindowState




                If AbortFlag = 1 Then
                    Form1.SSPanel1.Caption = ""
                    Form1.ProgressBar1.Value = 0
                    Call UpdateF2Prog
                    Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
                End If

                ET = Abs(GetTickCount)
                
                
            End If
            
            'Sleep 200
            ET = Abs(ET)
            If Abs(ET - LT) > 500 Then
                If (b + 1) <= (MCCorrection + 1) Then
                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
                End If
                Form1.Label50(0).Caption = DoTimeII(Abs(ET - ST))
                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                UpdateRecNums (SEventNumber)
                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    StartPlt(0) = 1
                    oRec = oRecombNo(100)
                    'SSS = abs(gettickcount)
                    'For ZZ = 0 To 20
                    Call UpdatePlotC
                    'Next ZZ
                    ET = Abs(GetTickCount)
                    'TT = ET - SSS '1516,1532,1500 with lines drawn in c++
                    '2140,2047,2047 with lines drawn in VB
                    
                    x = x
                End If
                LT = ET
                If Form1.ProgressBar1.Value > 0 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - ST)) * (100 / Form1.ProgressBar1.Value) - (Abs(ET - ST))) & " remaining"
                    Form1.SSPanel1.Caption = Str(b) & " of " & Str(MCCorrection) & " triplets examined"
                End If
                Call UpdateF2Prog
                If (CLine <> "" And CLine <> " ") Then
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole vbClearLine
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole "Running RDP scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                End If
                DoEvents
            End If
            

        Next 'Seq2

    End If

Next 'Seq1
Next AAA

If DoScans(0, 0) = 1 And (CLine <> "" And CLine <> " ") Then
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole vbClearLine
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole "Running RDP scan: 100% complete"
End If
'ETS = abs(gettickcount)
'ttt = ETS - StSt '4.766
'0.094
'8.609 for hiv75 - no fiddling with bppositions
'2.921 with exit pre xohomology -no parallelization
''1.046 with exit pre xohomology -with parallelization
'7.172, 7.063, 7.141 with 15 groupnum parallelization (but only after a hot start - 8.594 otherwise)
'7.141, 7.109, 7.094 with 23 groupnum parallelization (but only after a hot start - 8.547 otherwise)
'7.094, 7.156, 6.969 with 31 groupnum parallelization (but only after a hot start - 8.516 otherwise)
''6.531, 6.547, 6.481 with 31 groupnum parallelization (but only after a hot start 7.781 otherwise) ' better nesting in main loop
''6.500, 6.485, 6.468 with 31 groupnum parallelization (but only after a hot start 7.891 otherwise) ' readding xdiffpos bits
''5.687, 5.594, 5.641 with 31 groupnum parallelization (but only after a hot start 6.687 otherwise) ' dropping the bottom 0.1% of signals
'1.500 after startposx
'3.047
End Sub

Public Sub XOverV(FindallFlag As Byte, ElementX As Long, LenXoverSeq As Long, SpacerNo As Integer, AH() As Long, XoverSeqNumW() As Byte, SpacerSeqs() As Integer, XDiffPos() As Long, XPosDiff() As Long, ValidSpacer() As Integer, SeqNum() As Integer, Seq1 As Long, Seq2 As Long, Seq3 As Long, DoAllFlag)


Dim LowThresh As Double
Dim NumInList As Long
Dim SIP As Long, XOverLen As Long, A As Long, ENN As Long, BEE As Long, SPF As Byte, Dummy As Variant, MCC As Long, FF As Long, oDir As String, UB As Long, OldX As Long
Dim XPDDone As Byte, NumSame As Long
    XPDDone = 0
'
'XX = UBound(TreeDistance, 1)
'XX = UBound(Distance, 1)

'If QvRFlag = 1 Then
'    If ReferenceList(Seq1) = 0 Then
'        If ReferenceList(Seq2) > 0 And ReferenceList(Seq3) > 0 Then
'            If ReferenceList(Seq2) = ReferenceList(Seq3) Then
'                Exit Sub
'            End If
'        Else
'            Exit Sub
'        End If
'    ElseIf ReferenceList(Seq2) = 0 Then
'        If ReferenceList(Seq1) > 0 And ReferenceList(Seq3) > 0 Then
'            If ReferenceList(Seq1) = ReferenceList(Seq3) Then
'                Exit Sub
'            End If
'        Else
'            Exit Sub
'        End If
'    ElseIf ReferenceList(Seq3) = 0 Then
'        If ReferenceList(Seq1) > 0 And ReferenceList(Seq2) > 0 Then
'            If ReferenceList(Seq1) = ReferenceList(Seq2) Then
'                Exit Sub
'            End If
'        Else
'            Exit Sub
'        End If
'    Else
'        Exit Sub
'    End If
'End If


    '0.343 - 1K perms
    Dim AFact As Double, BWarn As Byte, EWarn As Byte, DoneRedo As Byte, b As Long, BTarget As Long, ETarget As Long, Split As Long, AD As Long, AMi As Long, AMa As Long, BE As Long, EN As Long, NCommon As Long, StartPosX As Long
    Dim NextPosX As Long
    Dim oProbXOver As Double, Inlyer As Integer
    Dim FindCycle As Integer, Store As Long, Storex As Long, ActiveSeq As Integer, ActiveMajorP As Integer, ActiveMinorP As Integer, SeqDaughter As Long, SeqMinorP As Long, Temp As Integer, EndFlag As Long, HighHomol As Long, MedHomol As Long, LowHomol As Long
    Dim DA As Long, Ma As Long, Mi  As Long, x As Long, NumDifferent As Long, Z As Long, PBinFlag As Long
    
    Dim SLen As Long, AmaTot As Double, AmiTot As Double, ATot As Double
    'Dim AH(2, elementx) As Long
    DoneRedo = 0
    
    
    SLen = Len(StrainSeq(0))
    PBinFlag = -1
    FirstDrawFlag = 0
    
    XPDDone = 1
    
'    For x = 0 To Len(StrainSeq(0))
'        If SeqNum(x, Nextno) = 0 Then
'            x = x
'        End If
'    Next x
'
    
    If AH(0, ElementX) < XoverWindow / 3 Or AH(1, ElementX) < XoverWindow / 3 Or AH(2, ElementX) < XoverWindow / 3 Then
        Exit Sub
    End If
    '@
    If AH(0, ElementX) = 0 Or AH(1, ElementX) = 0 Or AH(2, ElementX) = 0 Then
        Exit Sub
    End If
    AvHomol(1) = (AH(0, ElementX) / LenXoverSeq)
    AvHomol(2) = (AH(1, ElementX) / LenXoverSeq)
    AvHomol(3) = (AH(2, ElementX) / LenXoverSeq)
    
    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000 '0.3088
    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000 '0.4847
    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000 '0.2065
    
    If MCFlag = 0 Then
        MCC = MCCorrection
    Else
        MCC = 1
    End If
    'For X = 1 To 34
    '    For Y = 0 To 34
    '        For Z = 0 To 10
    '            If BinTable(X, Y, Z) > 0 And BinTable(X, Y, Z) < 1 Then
    '                X = X
    '            End If
    '
    '        Next Z
    '    Next Y
    'Next X
    
    '1.542
    
    'If SEventNumber = 2 Then
    '    If Seq1 = 20 Or Seq1 = 9 Or Seq1 = 4 Then
    '    If Seq2 = 20 Or Seq2 = 9 Or Seq2 = 4 Then
    '    If Seq3 = 20 Or Seq3 = 9 Or Seq3 = 4 Then
    '        X = X '152,28,0.3088,1045
    '        '152,18,0.3088,1045
    '        '150,17,0.3088,1045
    '    End If
    '    End If
    '    End If
    'End If
    
    
    
    
    
    
    LenXoverSeq = Abs(LenXoverSeq) - 1 '875
    
'    If DebuggingFlag < 2 Then On Error Resume Next
'    UB = 0
'    UB = UBound(TreeDistance, 1)
'
'
'    On Error GoTo 0
'
'    If UB = 0 Then
'        'it'll probably be much quicker to just load the individual distances
'        odir = CurDir
'        ChDir App.Path
'        ChDrive App.Path
'
'        ReDim Distance(PermNextno, PermNextno), TreeDistance(PermNextno, PermNextno)
'        FF = FreeFile
'
'        Open "RDP5Distance" + UFTag For Binary As #FF
'        Get #FF, , Distance()
'        Close #FF
'        Open "RDP5TreeDistance" + UFTag For Binary As #FF
'        Get #FF, , TreeDistance()
'        Close #FF
'        ChDir odir
'        ChDrive odir
'    End If

    
    'Work out identities (7.1/21)
    '
    XX = NextNo
    XX = UBound(Distance, 1)
    XX = UBTD1
    XX = ubtreedist
    If Seq1 > UBound(TreeDistance, 1) Or Seq2 > UBound(TreeDistance, 1) Or Seq3 > UBound(TreeDistance, 1) Then
        If Seq1 <= UBound(Distance) And Seq2 <= UBound(Distance) And Seq3 <= UBound(Distance) Then
            If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                HighHomol = 1
            ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                HighHomol = 2
            ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) Then
                HighHomol = 3
            End If
        End If
    Else
        If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
            HighHomol = 1
        ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
            HighHomol = 2
        ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
            HighHomol = 3
        End If
    End If
    
    
    

    'C Routine to work out moving identity averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    
    
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@
    'SS = abs(gettickcount)
    'For x = 0 To 1000000
        
        If LenXoverSeq < 2000 Then
            StartPosX = XOHomologyP(HighHomol, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0, ElementX), XOverHomologyNum(0, 0))
        Else
            StartPosX = XOHomologyPB5(HighHomol, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0, ElementX), XOverHomologyNum(0, 0))
        End If
    'Next x
    'EE = abs(gettickcount)
    'TT = EE - SS
    'x = x
    
'     If Seq1 = 8 Or Seq2 = 8 Or Seq3 = 8 Then
'    If Seq1 = 16 Or Seq2 = 16 Or Seq3 = 16 Then
'    If Seq1 = 19 Or Seq2 = 19 Or Seq3 = 19 Then
'    XX = CurDir
'    Open "test2.csv" For Output As #1
'    For X = 0 To 2
'        For Y = 0 To LenXoverSeq
'            Print #1, XOverHomologyNum(Y, X)
'        Next Y
'    Next X
'    Close #1
'    XX = UBound(XoverSeqNumW, 3) '9624,2
'    'xoverseqnumw = 9624,2,32
'    X = X
'    End If
'    End If
'    End If
    
    'Exit Sub
    'If Seq1 = 1 And Seq2 = 2 And Seq3 = 3 Then
'        XX = CurDir
'        Open "xol7.csv" For Append As #1
'        Print #1, " "
'        Print #1, Seq1
'        Print #1, Seq2
'        Print #1, Seq3
'        For X = 0 To 20
'            For Y = 0 To 2
'                Print #1, XOverHomologyNum(X, Y)
'            Next Y
'        Next X
'        Close #1
'        X = X
   ' End If
    If StartPosX = 0 And ShortOutFlag <> 3 Then Exit Sub
    'End If



   UB = UBound(Distance, 1)
    
    If Seq1 <= UB And Seq2 <= UB And Seq3 <= UB Then
        If AvHomol(1) = AvHomol(2) And AvHomol(1) = AvHomol(3) Then
            If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
                If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                    AvHomol(2) = AvHomol(2) - 0.00001
                    AvHomol(3) = AvHomol(3) - 0.00002
                Else
                    AvHomol(2) = AvHomol(2) - 0.00002
                    AvHomol(3) = AvHomol(3) - 0.00001
                End If
            ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
                If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                    AvHomol(1) = AvHomol(1) - 0.00001
                    AvHomol(3) = AvHomol(3) - 0.00002
                Else
                    AvHomol(1) = AvHomol(1) - 0.00002
                    AvHomol(3) = AvHomol(3) - 0.00001
                End If
            Else
                If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                    AvHomol(1) = AvHomol(1) - 0.00001
                    AvHomol(2) = AvHomol(2) - 0.00002
                Else
                    AvHomol(1) = AvHomol(1) - 0.00002
                    AvHomol(2) = AvHomol(2) - 0.00001
                End If
            End If
        ElseIf AvHomol(1) = AvHomol(2) Then
            If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
                AvHomol(2) = AvHomol(2) - 0.00001
            Else
                AvHomol(1) = AvHomol(1) - 0.00001
            End If
        ElseIf AvHomol(1) = AvHomol(3) Then
            If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
                AvHomol(3) = AvHomol(3) - 0.00001
            Else
                AvHomol(1) = AvHomol(1) - 0.00001
            End If
        ElseIf AvHomol(2) = AvHomol(3) Then
            If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
                AvHomol(3) = AvHomol(3) - 0.00001
            Else
                AvHomol(2) = AvHomol(2) - 0.00001
            End If
        End If
    
    End If
    'If PermNextno > LowMemThreshold Then
    '    Erase Distance
    'End If
    
    
    '2.142
    
    
    
    If AvHomol(1) >= AvHomol(2) And AvHomol(1) >= AvHomol(3) Then
        HighHomol = 1

        If AvHomol(2) >= AvHomol(3) Then
            MedHomol = 2: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        
        Else 'If AvHomol(3) > AvHomol(2) Then
            MedHomol = 3: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(3) Then
        HighHomol = 2

        If AvHomol(1) >= AvHomol(3) Then
            MedHomol = 1: LowHomol = 3
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        Else 'If AvHomol(3) > AvHomol(1) Then
            MedHomol = 3: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        'Else
        '    Exit Sub
        End If

    ElseIf AvHomol(3) >= AvHomol(1) And AvHomol(3) >= AvHomol(2) Then
        HighHomol = 3

        If AvHomol(1) >= AvHomol(2) Then
            MedHomol = 1: LowHomol = 2
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        Else 'If AvHomol(2) > AvHomol(1) Then
            MedHomol = 2: LowHomol = 1
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        'Else
        '    Exit Sub
        End If

    End If
 
 

   
   '1.823
    FindCycle = 0
    
    'XX = Seq1: XX = Seq2: XX = Seq3
    'Exit Sub
    
    OldX = -1
    Dim AVal As Long, TC As Long
    AVal = 1
    Dim UBXOHN As Long, g As Long
    UBXOHN = UBound(XOverHomologyNum, 1)
    
'    If FastestFlag = 1 Then
'        If FindallFlag = 0 Then
'            If MCFlag = 0 Then
'                LowThresh = (LowestProb / (MCCorrection / 1000))
'
'                If LowThresh > LowestProb Then LowThresh = LowestProb
'            Else
'                LowThresh = LowestProb
'            End If
'        Else
'            LowThresh = LowestProb
'        End If
'    Else
'    'Exit Sub
'        LowThresh = LowestProb
'    End If
    LowThresh = LowestProb
     
'       If Seq1 = 8 Or Seq2 = 8 Or Seq3 = 8 Then
'    If Seq1 = 16 Or Seq2 = 16 Or Seq3 = 16 Then
'    If Seq1 = 19 Or Seq2 = 19 Or Seq3 = 19 Then
'    X = X
'    End If
'    End If
'    End If
'
'XX = ReassortmentFlag
     
    Do
        '
        NextPosX = 1 'StartPosX
        Storex = 0
        
        Do
            
            
            'This could be speeded up a bit
            ''@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
            x = FindNextP(UBXOHN, NextPosX, HighHomol, MedHomol, LowHomol, LenXoverSeq, XoverWindow, XOverHomologyNum(0, 0))
                
                
            '
            If x > -1 And x <> OldX Then
                OldX = x
                '5.078 - 1K perms
                
                If CircularFlag = 1 And XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, HighHomol - 1) And x = 1 Then 'And ReassortmentFlag = 0 Then
                    If x = x Then
                        x = FindFirstCOP(x, MedHomol, HighHomol, LenXoverSeq, UBXOHN, XOverHomologyNum(0, 0))
                    Else
                        x = 1
                        Do Until XOverHomologyNum(x, MedHomol - 1) <= XOverHomologyNum(x, HighHomol - 1)
                            x = x + 1
                        Loop
                        If XOverHomologyNum(LenXoverSeq, MedHomol - 1) <= XOverHomologyNum(LenXoverSeq, HighHomol - 1) Then
                            XOverHomologyNum(LenXoverSeq, MedHomol - 1) = XOverHomologyNum(1, MedHomol - 1)
                            XOverHomologyNum(LenXoverSeq, HighHomol - 1) = XOverHomologyNum(1, HighHomol - 1)
                        End If
                    End If
'                    XX = XOverHomologyNum(6, 0)
                    x = x
'                    XX = Seq1
'                    XX = Seq2
'                    XX = Seq3
                Else
                    NCommon = 0
                    XOverLength = 0
                    '@'@'@'@'@'@
                    x = DefineEventP2(UBXOHN, ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, x, XoverWindow, SLen, LenXoverSeq, SeqMinorP, SeqDaughter, EndFlag, BE, EN, NCommon, XOverLength, XoverSeqNumW(0, 0, ElementX), XOverHomologyNum(0, 0))
                          
                   x = x
                    
                    
                    'Uncommenting this code uses the bintable - it reduces the number of probxover tests BUT not enough to make a difference
                    
                    '2.183
                    'If Int(indprob * 100) + 1 <= 100 Then
                    '    ip = Int(indprob * 100) + 1
                    'Else
                    '    ip = 100
                    'End If
                    'Dim GoOnXX As Byte
                    'GoOnXX = 1
                    'If Int(XOverLength / 5) + 1 <= 34 And (Int(NCommon / 5) + 1) <= 34 Then
                    '    If BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) > 0.05 Then
                    '
                    '        GoOnXX = 0
                    '    End If
                    'End If
                    'GoOnXX = 1 ' 0.5 cutoff 40 seconds = 1 reassortment
                    '@
                    If XOverLength > 2 And EN <> BE And (EN > BE Or CircularFlag = 1) Then ' And GoOnXX = 1 Then ' And BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) < 0.5 Then
                        
                        NumDifferent = XOverLength - NCommon
                        
                        If NCommon > NumDifferent * 0.8 Then
                    
                        
                            If XOverLength >= 170 Then
                                AFact = XOverLength / 169
                                NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                                XOverLength = 169
                                NumSame = XOverLength - NumDifferent
                            Else
                                '
                                AFact = 1
                                NumSame = NCommon
                            End If
                        
                        
                             'if i put the worthwhile scan filter here it skips ~1900 trips and gets the right answer - not much of a time reduction though
                        
                             
                            
                                                
 
                            
                            'C routine that calculates the "probability" of the "recomination signal" having occured by chance mutation without recombination.
                            'ProbabilityXOver = ProbCalc(Fact(0), XOverLength, XOverLength - NumDifferent, indprob, LenXOverSeq)
                            '
                            '169,6,16
    '                       If Seq1 = 21 And Seq2 = 22 And Seq3 = 24 Then
    '                            X = X
    '                        End If
    '@
                            IndProb = AvHomol(MedHomol)
                            '@
                            If ProbEstimate(XOverLength, NumSame, Int(IndProb * 50)) < LowThresh Then  '169,169-6,16, lenxoverseq =1644
                                '
                                'if i put the worthwhile scan filter here it skips ~2399 trips and gets the right answer - on;y ~5% time reduction though
                                
                                If XOverLength <= UBFact3x3 Then
                                    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
                                    ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOverLength, NumSame, IndProb, LenXoverSeq)
                                Else
                                    
                                    ProbabilityXOver = ProbCalcP(Fact(0), XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                                End If
                           
                        
                        
                            
                                 
                                If ProbabilityXOver < 0.5 Then
                                    'if i put the worthwhile scan filter here it skips ~3000 trips and gets the right answer - only ~5% time reduction though
                                    
                                    
                                    
                                    If AFact <> 1 Then
                                        If ProbabilityXOver > 0 Then
                                            ProbabilityXOver = ProbabilityXOver ^ AFact
                                        Else
                                            ProbabilityXOver = 0.05
                                        End If
                                    End If
                                    
                                
                                
                                    If APermFlag = 1 Then
                                        If ProbabilityXOver > 0 And (ProbabilityXOver < BestPermP(CPermNo, 0) Or BestPermP(CPermNo, 0) = 0) Then
                                            BestPermP(CPermNo, 0) = ProbabilityXOver
                                        End If
                                    Else
                                        oProbXOver = ProbabilityXOver
                                        If MCFlag = 0 Then
                                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                                        End If
                                        
                                        ''@
                                        If ShortOutFlag = 3 Then
                                            If ProbabilityXOver <= mtP(0) Then
                                                mtP(0) = ProbabilityXOver
                                            End If
                                        End If
                                        
                                        '2.323
                                        
                                        
                                        
                                        'If (ProbabilityXOver < LowestProb Or oProbXOver < CritPVals(0)) And ProbabilityXOver > 0 And ProbabilityXOver <> 1 Then
                                        
                                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                        'need to determin xdiffpos/xposdiff here
                                        'need to convert BE and EN to full sequence versions
                                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                            
                                            
                                          
                                        
                                            '2.033
                                            '
'                                            If SEventNumber = 0 And ProbabilityXOver < LowestProb * MCCorrection / 20 Then
'                                                    'if i put the worthwhile scan filter here mccorrection/20 cutoff it skips ~184000 trips and gets the wrong answer - 254 instead of 263 only a ~2% time reduction though for some reason
'                                                    'if i put the worthwhile scan filter here with mccorrection/10 cutoff it skips ~99499 trips and gets the wrongish answer - 262 instead of 263 only a ~6% time reduction though
'                                                    'if i put the worthwhile scan filter here mccorrection/5 cutoff it skips ~54000 trips and gets the wrongish answer - 262 instead of 263 only a ~5% time reduction though
'                                                    If FastestFlag = 1 Then
'                                                        If PBinFlag = -1 Then
'                                                            NuminList = GetNumInList(Seq1, Seq2, Seq3)
'                                                            PBinFlag = 1
'                                                            If ProgBinRead(0, Worthwhilescan(NuminList)) = 0 Then
'                                                            If Worthwhilescan(NuminList) > 0 Then
'                                                                X = X
'                                                            End If
'                                                                Worthwhilescan(NuminList) = Worthwhilescan(NuminList) + 1
'                                                            End If
'
'                                                        End If
'                                                    End If
'                                                End If
                                            If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                                 'if i put the worthwhile scan filter here it skips ~1.146M trips and gets the wrongish answer - 247 instead of 263 ~50% time reduction though
                                                If SEventNumber = 0 Then
                                                    If FastestFlag = 1 Then
                                                        If PBinFlag = -1 Then
                                                            If UseALFlag = 0 Then
                                                                NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                                            Else
                                                                NumInList = CurrentTripListNum
                                                            End If
                                                            PBinFlag = 1
                                                            If ProgBinRead(0, Worthwhilescan(NumInList)) = 0 Then
                                                            
                                                                Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 1
                                                            End If
                                                            
                                                        End If
                                                    End If
                                                End If
                                                Dim oEN As Long, OBE As Long
                                                oEN = EN
                                                OBE = BE
                                                
                                                If CircularFlag = 0 Then
                                                    If BE = 1 Then
                                                        If XDiffPos(BE, ElementX) < TargetX Then
                                                            BE = 1
                                                            OBE = 1
                                                        Else
                                                            BE = XDiffPos(BE, ElementX)
                                                        End If
                                                    
                                                    Else
                                                        BE = XDiffPos(BE, ElementX)
                                                    End If
                                                
                                                Else
                                                    BE = XDiffPos(BE, ElementX)
                                                End If
                                                
                                                
                                                If EN = LenXoverSeq And CircularFlag = 0 Then
                                                    If ShortOutFlag = 0 Or ShortOutFlag = 6 Or ShortOutFlag = 10 Then
                                                        EN = Len(StrainSeq(0))
                                                    Else
                                                        
                                                        EN = XDiffPos(LenXoverSeq, ElementX)
                                                    End If
                                                    oEN = LenXoverSeq
                                        
                                                Else
                                                    '
                                                    If EN >= LenXoverSeq Then
                                                        If LongWindedFlag = 0 Then
                                                            XDiffPos(EN, ElementX) = 0
                                                        Else
                                                            EN = LenXoverSeq + 1
                                                        End If
                                        
                                                    ElseIf EN < 1 Then
                                                        EN = LenXoverSeq + 1
                                                        
                                                    End If
                                                    oEN = EN
                                                    EN = XDiffPos(EN, ElementX)
                                                End If
                                        
                                                
                                                If EN = 0 Then
                                        
                                                    If ShortOutFlag = 0 Or ShortOutFlag = 6 Or ShortOutFlag = 10 Then
                                                        EN = Len(StrainSeq(0))
                                                        
                                                    Else
                                                        EN = XDiffPos(LenXoverSeq, ElementX)
                                                    End If
                                                    oEN = LenXoverSeq
                                                End If
                                            
                                                If ShowPlotFlag = 1 Then 'Draw plots if necessary
                                        
                            
                                                    If FirstDrawFlag = 0 Then
                                    
                                                        Call DrawPlots(Seq1, Seq2, Seq3)
                                    
                                                        FirstDrawFlag = 1
                                                    End If
                                    
                                                    If BE < EN Then
                                                        ProbX = 10 + Decompress(BE) * XFactor
                                                    Else
                                                        ProbX = 10
                                                    End If
                                                    'XPosDiff not calculated anymore
                                                    ProbY = PicHeight - (15 + XOverHomologyNum((OBE + ((oEN - OBE) / 2)), MedHomol - 1) * (PicHeight - 35))
                                                    ProbTest$ = ProbabilityXOver
                                                    Pos = InStr(1, ProbTest$, "E", vbBinaryCompare)
                                    
                                                    If Pos > 0 Then
                                                        If SPF = 0 Then Call PrintProbability
                                                    Else
                                                        If SPF = 0 Then Call PrintProbabilityII
                                                    End If
                                                End If
                                                'beginning and ending breakpoint positions here
                                                
                                                EWarn = 0: BWarn = 0
                                                Split = 0
                                                If LongWindedFlag = 1 Then
                                                    
                                                    
                                                    
                                                    
                                                    If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                                        AD = Seq1
                                                        AMa = Seq2
                                                        AMi = Seq3
                                                       
                                                    ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                                        AD = Seq2
                                                        AMa = Seq1
                                                        AMi = Seq3
                                                      
                                                        
                                                    ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                                        AD = Seq3
                                                        AMa = Seq1
                                                        AMi = Seq2
                                                       
                                                        
                                                    ElseIf StoreLPV(0, Seq1) >= StoreLPV(0, Seq2) And StoreLPV(0, Seq1) >= StoreLPV(0, Seq3) Then
                                                        AD = Seq1
                                                        AMa = Seq2
                                                        AMi = Seq3
                                                    ElseIf StoreLPV(0, Seq2) >= StoreLPV(0, Seq1) And StoreLPV(0, Seq2) >= StoreLPV(0, Seq3) Then
                                                        AD = Seq2
                                                        AMa = Seq1
                                                        AMi = Seq3
                                                    ElseIf StoreLPV(0, Seq3) >= StoreLPV(0, Seq1) And StoreLPV(0, Seq3) >= StoreLPV(0, Seq2) Then
                                                        AD = Seq3
                                                        AMa = Seq1
                                                        AMi = Seq2
                                                    End If

                                                    'If ReassortmentFlag = 0 Then
                                                        'check to see if an event has been extended accross a tract of
                                                        'missing data
                                                        'xposdiff isnt calculated anymore
                    '                                    If  XPosDIff(elementx,BE) > 0 Then
                    '                                        BEE = XDiffpos(elementx, XPosDIff(elementx,BE) - 1)
                    '                                    Else
                    '                                        BEE = BE
                    '                                    End If
                    '
                                                        If XDiffPos(OBE, ElementX) > 1 Then
                                                            BEE = XDiffPos(OBE - 1, ElementX)
                                                        Else
                                                            BEE = BEE
                                                        End If
                                                        
                                                        If XDiffPos(oEN, ElementX) < SLen Then
                                                            ENN = XDiffPos(oEN + 1, ElementX)
                                                        Else
                                                            ENN = EN
                                                        End If
                                                        If ENN < EN Then ENN = EN
                                                        If BEE < 1 Then BEE = SLen
                                                        If ENN > SLen Then ENN = 1
                                                        
                                                        If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                                            BWarn = 0: EWarn = 0
                                                            Split = 0
                                                            If BEE <> BE Then
                                                                '@
                                                                Z = CheckSplit2(2, SLen, BEE, BE, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                                            End If
                                                            If Split = 1 Then BWarn = 1
                                                            Split = 0
                                                            If EN <> ENN Then
                                                                Z = CheckSplit2(2, SLen, EN, ENN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                                            End If
                                                            If Split = 1 Then EWarn = 1
                                                            Split = 0
                                                            '@'@'@
                                                            Z = CheckSplit2(10, SLen, BE, EN, Seq1, Seq2, Seq3, Split, MissingData(0, 0))
                                                           
                                                        End If
                    '                                Else
                    '                                    Split = 0
                    '                                End If
                                                End If
                                                
                                                '@
                                                If Split = 1 Then
                                                    If XPDDone = 0 Then
                                                        XPDDone = 1
                                                        Dummy = MakeXPD2(LenXoverSeq, XDiffPos(0, ElementX), XPosDiff(0, ElementX))
                                                        
                                                    End If
                                                    'go back and recalculate the p-value between be and Z
                                                    For A = 0 To 1
                                                        NCommon = 0
                                                        XOverLen = 0
                                                        If A = 0 Then
                                                            BTarget = BE
                                                            If BE = Z Then Z = Z + 1
                                                            'Find point in the variable site subsequence that is immediately before BE
                                                            If XPosDiff(Z, ElementX) > 0 Then
                                                                ETarget = XDiffPos(XPosDiff(Z, ElementX) - 1, ElementX)
                                                            Else
                                                                ETarget = SLen
                                                            End If
                                                        Else
                                                            '@
                                                            b = FindMissing(SLen, Seq1, Seq2, Seq3, Z, EN, MissingData(0, 0))
                                                            If EN = b Then
                                                                BTarget = EN - 1
                                                                ETarget = EN
                                                            Else
                                                        '        XX = LenXoverSeq
                                                                If XPosDiff(b, ElementX) + 1 < LenXoverSeq And (XDiffPos(XPosDiff(b, ElementX) + 1, ElementX) > b Or XDiffPos(XPosDiff(b, ElementX) + 1, ElementX) < EN) Then
                                                                    BTarget = XDiffPos(XPosDiff(b, ElementX) + 1, ElementX)
                                                                Else
                                                                    
                                                                    Do
                                                                        If SeqNum(b, Seq1) <> 46 And SeqNum(b, Seq2) <> 46 And SeqNum(b, Seq3) <> 46 Then
                                                                            If SeqNum(b, Seq1) <> SeqNum(b, Seq2) Or SeqNum(b, Seq1) <> SeqNum(b, Seq3) Then
                                                                                Exit Do
                                                                            End If
                                                                        End If
                                                                        b = b + 1
                                                                        If b = EN Then b = b + 1: Exit Do
                                                                        If b > SLen Then b = 1
                                                                    Loop
                                                                    If b > SLen Then
                                                                        b = 1
                                                                    End If
                                                                    BTarget = b
                                                                End If
                                                                ETarget = EN
                                                            End If
                                                        End If
                                                        '@'@
                                                        NumDifferent = SplitEvent(XoverWindow, SLen, LenXoverSeq, SeqDaughter, SeqMinorP, BTarget, ETarget, XOverLength, NCommon, XPosDiff(0, ElementX), XoverSeqNumW(0, 0, ElementX))
                                                        '
                                                        x = XPosDiff(ETarget, ElementX) + 1
                                                        
                                                        If XOverLength > 2 Then
                                                            If XOverLength >= 170 Then
                                                                NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                                                                XOverLength = 169
                                                            End If
                                                            'C routine that calculates the probability of the recomination signal having arisen through mutation.
                                                            '@'@
                                                            If XOverLength <= UBFact3x3 Then
                                                                ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                                                                
                                                            Else
                                                                ProbabilityXOver = ProbCalcP(Fact(0), XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                                                            End If
                                                            
                                                            If ProbabilityXOver > 1 Then
                                                                ProbabilityXOver = 1
                                                            End If
                                                    
                                                        Else
                                                            ProbabilityXOver = 1
                                                        End If
                                                        If MCFlag = 0 Then
                                                            ProbabilityXOver = ProbabilityXOver * MCCorrection
                                                        End If
                                                        
                                                        If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                                            
                                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            Call ProcessEvent2(ElementX, 0, ProbabilityXOver, BTarget, ETarget, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            If ShortOutFlag = 1 Then
                                                                ShortOutput(0) = 1
                                                                AbortFlag = 1
                                                                Exit Sub
                                                            End If
                                                            If ShortOutFlag = 50 Then ShortOutput(0) = 1
                                                        End If
                                                    Next A
                                                Else
                                                    'If BE = 8129 And EN = 8440 Then
                                                    '        XX = SEventNumber
                                                    '        XX = Seq1 '21,1,9
                                                    '        XX = Seq2
                                                    '        XX = Seq3
                                                    '        '0,19,23,25
                                                    '    End If
                                                    'If Seq2 = 3 And Seq3 = 6 Then
                                                    '    X = X
                                                    'End If
                                                
                                                    If APermFlag = 0 Then
                                                        Call UpdateXOList3(AD, CurrentXOver(), XoverList(), 0, ProbabilityXOver, SIP)
                                                    Else
                                                        SIP = 1
                                                    End If
                                                    
                                                    
                                                    If MCFlag = 2 Then
                                                        If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                                        ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                                        End If
                                                    End If
                                                    
                                                    oRecombNo(100) = oRecombNo(100) + 1
                                                    oRecombNo(0) = oRecombNo(0) + 1
                                                    NewOneFound = 1
                                                    ActualFound = 1
                                                    If SIP > 0 Then
                                                        'XOverlist(AD, CurrentXOver(AD)).lholder = NCommon
                                                        
                                                        'If ReassortmentFlag = 0 Then
                                                        If XPDDone = 0 Then
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            Call CentreBP2(ElementX, OBE, oEN, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                        Else
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                            Call CentreBP2(ElementX, 0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                        End If
                                                        'End If
                                                       
                                                        If AD > UBound(XoverList, 1) Then Exit Sub
                                                        
                                                        XoverList(AD, SIP).Beginning = BE
                                                        XoverList(AD, SIP).Ending = EN
                                                        XoverList(AD, SIP).MajorP = AMa
                                                        XoverList(AD, SIP).MinorP = AMi
                                                        XoverList(AD, SIP).Daughter = AD
                                                        XoverList(AD, SIP).ProgramFlag = 0
                                                        XoverList(AD, SIP).DHolder = 0
                                                        XoverList(AD, SIP).Probability = ProbabilityXOver
                
                                                        '@
                                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                                            StartPlt(0) = 1
                                                            Call UpdatePlotB(AD, AMa, AMi, SIP)
                                                                
                                                        End If
                                                        'If ReassortmentFlag = 0 Then
                                                            If SEventNumber > 0 Then
                                                                If XPDDone = 0 Then
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                    If EWarn = 0 Then Call CheckEndsVB2(ElementX, OBE, oEN, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                                    If BWarn = 0 Then Call CheckEndsVB2(ElementX, OBE, oEN, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                Else
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                    '@
                                                                    If EWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                                    If BWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                                                End If
                                                            End If
                                                            If BWarn = 1 And EWarn = 1 Then
                                                                XoverList(AD, SIP).SBPFlag = 3
                                                            ElseIf BWarn = 1 Then
                                                                XoverList(AD, SIP).SBPFlag = 1
                                                            ElseIf EWarn = 1 Then
                                                                XoverList(AD, SIP).SBPFlag = 2
                                                            End If
                                                        'End If
                                                        
                                                                
                                                        If ShortOutFlag = 1 Then
                                                            ShortOutput(0) = 1
                                                            AbortFlag = 1
                                                            Exit Sub
                                                        End If
                                                        If ShortOutFlag = 50 Then ShortOutput(0) = 1
                                                        'Do shortend distance calculation here?
                                                                
                                                        
                                                    ElseIf DoneRedo = 0 Then
                                                        DoneRedo = 1
                                                        Call AddToRedoList(0, Seq1, Seq2, Seq3)
                                                        
                                                        
                                                    End If
                                                End If
                                            
                                            End If
                                        
                                        'End If
                                    End If
                                ElseIf APermFlag = 1 Then
                                    If ProbabilityXOver > 0 And (ProbabilityXOver < BestPermP(CPermNo, 0) Or BestPermP(CPermNo, 0) = 0) Then
                                        BestPermP(CPermNo, 0) = ProbabilityXOver
                                    End If
                                End If
                            '@'@
                            End If
                            
                            
                        End If
                        ''''''
                    
                    End If
                    ''''''''''
                End If
                
                '1.923
                '
                If EndFlag = 1 Then
                    EndFlag = 0
                    x = LenXoverSeq
                End If
                ''@'@
                If (x < LenXoverSeq + 1 And x > NextPosX) Then 'Or ReassortmentFlag = 1 Then
                    NextPosX = x + 1
                    
                Else
                    Exit Do
                End If
                
                '5.719 1K perms
                
            Else
                Exit Do
            End If
        Loop
        '3.895
        
        
        
        If FindCycle = 0 Then
            Temp = MedHomol
            MedHomol = LowHomol
            LowHomol = Temp
        ElseIf FindCycle = 1 Then
            'Exit Sub
            '5.027
            
            If AvHomol(HighHomol) < 0.7 Or DoAllFlag = 1 Then
                Temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = Temp
            Else
                Exit Do
            End If

        Else
            Exit Do
        End If

        If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
            SeqDaughter = 0: SeqMinorP = 2
        ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
            SeqDaughter = 1: SeqMinorP = 2
        ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
            ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
            SeqDaughter = 0: SeqMinorP = 1
        ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
            SeqDaughter = 2: SeqMinorP = 1
        ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
            ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
            SeqDaughter = 1: SeqMinorP = 0
        ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
            ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
            SeqDaughter = 2: SeqMinorP = 0
        End If
        
        FindCycle = FindCycle + 1
        
        'Exit Sub
    Loop
    'Exit Sub
        '10.359 1K perms
        x = x
End Sub
