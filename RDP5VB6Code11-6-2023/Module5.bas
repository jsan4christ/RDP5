Attribute VB_Name = "Module5"

Public SeqDolist() As Long
Public StrainSeqDls() As Long
Public UnafoldInput As String

Public IndSEvent As Long

Public Prnt1_Arr() As String, Prnt2_Arr() As String, Prnt1_Mat() As Single, Prnt2_Mat() As Single

Public LenSeq, MatDim As Integer
Public minFE As Single


'hybrid-ss-min parameters
Public NA, Circular, Suffix, mFold As String
Public MinTemperature, Sodium, Magnesium As Single


Public Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
Public Declare Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
Public Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long

'process waiting varibles
Public lPid As Long          'Process ID
Public lHnd As Long          'Process Hnd
Public lRet As Long          'Return code


Const SYNCHRONIZE = &H100000
Const INFINITE = &HFFFF    'Wait forever
'Const WAIT_OBJECT_0 = 0    'The state of the specified object is signaled.
Const WAIT_TIMEOUT = &H102 'The time-out interval elapsed, and the
Public Sub SetupDoneTests(NextNo As Long, TestPVs() As Double, PXOList() As XOverDefine, PCurrentXover() As Integer, DoneSeq() As Byte)
Dim x As Long, Y As Long
ReDim TestPVs(UBound(PXOList, 2), UBound(PXOList, 1))
Dummy = MakeTestPVs(UBound(DoneSeq, 1), DoneSeq(0, 0), NextNo, UBound(PXOList, 1), UBound(PXOList, 2), PCurrentXover(0), PXOList(0, 0), TestPVs(0, 0))
'@
'For x = 0 To NextNo
'    For Y = 1 To PCurrentXOver(x)
'        If PXOList(x, Y).OutsideFlag = 1 Then
'
'            DoneSeq(x, Y) = 1
'
'        End If
'    Next Y
'Next x

End Sub
    Public Sub AddjustCXOVB(NextNo, WinPP, LowestProb, DoneSeq() As Byte, TempDone() As Byte, oRecombNo() As Long, RNum() As Long, RList() As Long, DoPairs() As Byte, TraceSub() As Long, tCurrentxover() As Integer, TempXOList() As XOverDefine, PCurrentXover() As Integer, PXOList() As XOverDefine)
                Dim PCXO As Long
            '@'@'@'@'@'@'$
            
'            XX = TempXOList(27, 11).Ending '  1328
'                XX = TempXOList(27, 11).Beginning '1013
'                XX = TempXOList(27, 11).Daughter '27
'                XX = TempXOList(27, 11).MinorP '46
'                XX = TempXOList(27, 11).MajorP '38
'                XX = TempXOList(27, 11).Probability
            For x = 0 To NextNo
'                If x = 27 Then
'                    x = x
'                End If
                PCXO = PCurrentXover(x)
                For Y = 1 To PCXO
                  If Y <= UBound(PXOList, 2) Then
                    DA = PXOList(x, Y).Daughter
                    Mi = PXOList(x, Y).MinorP
                    Ma = PXOList(x, Y).MajorP
                    If DA > NextNo Then
                        DA = TraceSub(PXOList(x, Y).Daughter)
                    End If
                    If Mi > UBTS Then
                        Mi = 0
                    End If
                    If Ma > UBTS Then
                        Ma = 0
                    End If
                    'XX = UBound(TraceSub, 1)
                    If Mi > NextNo Then
    
                        Mi = TraceSub(Mi)
                    End If
                    If Ma > NextNo Then
                        Ma = TraceSub(Ma)
                    End If
                    WinPPY = MakePairsP(NextNo, DA, Ma, Mi, WinPP, RNum(0), RList(0, 0), DoPairs(0, 0))
                    '@
                    If PXOList(x, Y).Probability <= LowestProb Then
                        If WinPPY = RNum(WinPP) + 1 Then
                            If tCurrentxover(DA) <= tCurrentxover(Mi) And tCurrentxover(DA) <= tCurrentxover(Ma) Then
                                tCurrentxover(x) = tCurrentxover(x) + 1
                                If tCurrentxover(x) < UBound(TempXOList, 2) Then
'                                    If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                    TempXOList(x, tCurrentxover(x)) = PXOList(x, Y)
                                    If tCurrentxover(x) <= UBound(TempDone, 2) And Y <= UBound(DoneSeq, 2) Then
                                        TempDone(x, tCurrentxover(x)) = DoneSeq(x, Y)
                                    End If
                                Else
                                    tCurrentxover(x) = tCurrentxover(x) - 1
'                                    If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                End If
                            ElseIf tCurrentxover(Mi) <= tCurrentxover(DA) And tCurrentxover(Mi) <= tCurrentxover(Ma) Then
                                tCurrentxover(Mi) = tCurrentxover(Mi) + 1
'                                If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                If tCurrentxover(Mi) <= UBound(TempXOList, 2) Then
                                    '@
                                    TempXOList(Mi, tCurrentxover(Mi)) = PXOList(x, Y)
                                    TempXOList(Mi, tCurrentxover(Mi)).Daughter = Mi
                                    TempXOList(Mi, tCurrentxover(Mi)).MinorP = DA
                                    If tCurrentxover(Mi) <= UBound(TempDone, 2) And Y <= UBound(DoneSeq, 2) Then
                                        TempDone(Mi, tCurrentxover(Mi)) = DoneSeq(x, Y)
                                    End If
                                Else
'                                    If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                    tCurrentxover(Mi) = tCurrentxover(Mi) - 1
'                                    If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                End If
    
                            Else
                                '@
                                tCurrentxover(Ma) = tCurrentxover(Ma) + 1
'                                If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                If tCurrentxover(Ma) <= UBound(TempXOList, 2) Then
                                    TempXOList(Ma, tCurrentxover(Ma)) = PXOList(x, Y)
                                    TempXOList(Ma, tCurrentxover(Ma)).Daughter = Ma
                                    TempXOList(Ma, tCurrentxover(Ma)).MajorP = DA
                                    If tCurrentxover(Ma) <= UBound(TempDone, 2) And Y <= UBound(DoneSeq, 2) Then
                                        TempDone(Ma, tCurrentxover(Ma)) = DoneSeq(x, Y)
                                    End If
                                Else
'                                    If tCurrentxover(x) = 11 Then
'                                        x = x
'                                    End If
                                    tCurrentxover(Ma) = tCurrentxover(Ma) - 1
'                                    If tCurrentxover(x) = 11 And x = 27 Then
'                                        x = x
'                                    End If
                                End If
                            End If
                            oRecombNo(100) = oRecombNo(100) + 1
                            oRecombNo(PXOList(x, Y).ProgramFlag) = oRecombNo(PXOList(x, Y).ProgramFlag) + 1
                        End If
                    End If
                    PCurrentXover(x) = PCurrentXover(x) - 1
                  End If
                Next Y
            Next x
        
    End Sub
    
    
    
    Public Sub LoadActualEvents(ActualEventList() As Single, FName As String, NumActualEvents As Long)
        Dim FN As Long, NumRows As Long, Temp As String
        Dim LPos As Long, Pos As Long
        ReDim ActualEventList(7, 1000)
        FN = FreeFile
        Open FName For Input As FN
        Do While UCase(Left(Temp, 16)) <> "SANTAEVENTNUMBER"
            Line Input #FN, Temp
        Loop
        XX = Len(Temp)
        Do While UCase(Left(Temp, 16)) = "SANTAEVENTNUMBER"
            Line Input #FN, Temp
        Loop
        NumRows = 0
        Do While Not EOF(FN)
            x = x
            Pos = 1
            LPos = 1
            Pos = InStr(Pos, Temp, Chr(9), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Pos - LPos))
            ActualEventList(0, NumRows) = val(Mid(Temp, LPos, Pos - LPos))
               
            LPos = Pos + 1
            Pos = InStr(LPos, Temp, Chr(9), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Pos - LPos))
            ActualEventList(1, NumRows) = val(Mid(Temp, LPos, Pos - LPos))
            
            LPos = Pos + 1
            Pos = InStr(LPos, Temp, Chr(9), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Pos - LPos))
            ActualEventList(2, NumRows) = val(Mid(Temp, LPos, Pos - LPos))
            LPos = Pos + 1
            Pos = InStr(LPos, Temp, Chr(9), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Pos - LPos))
            ActualEventList(3, NumRows) = val(Mid(Temp, LPos, Pos - LPos))
            LPos = Pos + 1
            Pos = InStr(LPos, Temp, Chr(9), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Pos - LPos))
            ActualEventList(4, NumRows) = val(Mid(Temp, LPos, Pos - LPos))
            LPos = Pos + 1
            Pos = InStr(LPos, Temp, Chr(9), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Pos - LPos))
            ActualEventList(5, NumRows) = val(Mid(Temp, LPos, Pos - LPos))
            LPos = Pos + 1
            Pos = InStr(LPos, Temp, Chr(13), vbBinaryCompare)
            XX = (Mid(Temp, LPos, Len(Temp) - LPos + 1))
            ActualEventList(6, NumRows) = (Mid(Temp, LPos, Len(Temp) - LPos + 1))
            If ActualEventList(0, NumRows) = 38437 Then
                x = x
            End If
            
            NumRows = NumRows + 1
            If NumRows > UBound(ActualEventList, 2) Then
                ReDim Preserve ActualEventList(7, NumRows + 1000)
            End If
            Line Input #FN, Temp
        Loop
        NumActualEvents = NumRows
        Close #FN
    End Sub
    Public Sub AddSomeExcludes(TraceSub() As Long, MinSeqSize, NextNo As Long, SeqNum() As Integer, ActualSeqSize() As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno, MissingData() As Byte, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer)

Dim AList() As Integer, FirstStepNo As Long, SSN As Long, OSN As Long, CurSeed As Long, BoundsMD() As Long, NumMD As Long, Y As Long, Y1 As Long, Y2 As Long, oNextno As Long, UB As Long, Z As Long, x As Long, oDirX As String, Pos As Long, FF As Long, EListNum As Long, TELong As Long, TEString As String
Dim UB1 As Long, UB2 As Long, g As Long

FirstStepNo = StepNo


Dim STartT As Variant
STartT = Abs(GetTickCount)


Redo:
ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
        ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
        ReDim Chivals(Len(StrainSeq(0)), 2)
        ReDim SmoothChi(Len(StrainSeq(0)), 2)
        ReDim XDiffPos(Len(StrainSeq(0)) + 200)
        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
        ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
'For x = PermNextno To Nextno
Steps(0, StepNo) = 6 'this erases all sequences with numbers above permnextno by resetting nextno to permnextno
Steps(4, StepNo) = SEventNumber + 1
StepNo = StepNo + 1
UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

'This is test code to see whether restoring seqnum and missingdata outside of this exclude
'group will reveal more hidden signals
Dim RedoAllDists As Long
RedoAllDists = 0
If x = x Then
    'reset seqnum and modseqnum to state of first addsomeexcludes
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SMDrop" + UFTag For Binary As #FF
    If FirstAddSome = 0 Then
        FirstAddSome = 1
        UB1 = UBound(SeqNum, 1)
        UB2 = UBound(SeqNum, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , SeqNum()
        UB1 = UBound(MissingData, 1)
        UB2 = UBound(MissingData, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , MissingData()
        
        
    Else
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim SeqNum(UB1, UB2)
        Get #FF, , SeqNum()
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim MissingData(UB1, UB2)
        Get #FF, , MissingData()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    RedoAllDists = 1
    'XX = UBound(SeqNum, 2)
ElseIf x = 123456 Then
 
    RedoAllDists = 1
    'Dim tSeqNum() As Integer
    'ReDim tSeqNum(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
        Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
    End If
    ReDim MissingData(Len(StrainSeq(0)), PermNextno + 1)
    'now add missingdata and indels back to the seed sequence
    For x = 0 To PermNextno
        If DoneExcludes(x) = 0 Then
            If x <= UBound(ExcludeCoords) Then
                If ExcludeCoords(x) > 0 Then
                    CurSeed = x
                    Exit For
                End If
            End If
        End If
    Next x
    If x = x Then 'edit the anchor sequence
        For x = 1 To StepNo - 1
            If Steps(0, x) = 2 Then
                If Steps(1, x) = CurSeed Then
                    Dummy = ModSeqNumE(PermNextno, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
                    'tRedoDist(Steps(1, x)) = 1
                End If
            End If
        Next x
    End If
End If





UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

NextNo = PermNextno
'Next x
BusyWithExcludes = 1


ReDim BoundsMD(Len(StrainSeq(0)), 1)
NumMD = 0
Dim GoOn As Byte
'erase any sequences >permenxtno


NextNo = PermNextno
oNextno = NextNo
Dim SSBak() As Long
ReDim SSBak(Len(StrainSeq(0)))
GoOn = 0
Dim EPosX As Long, BreakB As Long, BreakE As Long, DSX As Long


SS = Abs(GetTickCount)
Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (2% of this cluster completed)"
UpdateRecNums (SEventNumber)
GlobalTimer = SS
'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'SS = Abs(SS)
Call UpdateTimeCaps(SS, STartT)
Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

DoEvents

For x = 0 To PermNextno
'     If x = 97 Then
'            x = x
'        End If
    If DoneExcludes(x) = 0 And MaskSeq(x) = 0 Then
       
        If x <= UBound(ExcludeCoords) Then
            If ExcludeCoords(x) > 0 Then
'                Open "progress.txt" For Append As #20
'                Print #20, SEventNumber, "exrras", x
'                Close #20
                'establish boundaries of missing data in sequence X
                CurSeed = x
                
                For Y1 = 0 To Len(StrainSeq(0))
                    If MissingData(Y1, x) = 1 Then
                        For Y2 = Y1 + 1 To Len(StrainSeq(0))
                            If MissingData(Y2, x) = 0 Then
                                Y2 = Y2 - 1
                                Exit For
                            End If
                        Next Y2
                        BoundsMD(NumMD, 0) = Y1
                        BoundsMD(NumMD, 1) = Y2
                        NumMD = NumMD + 1
                        Y1 = Y2
                    End If
                Next Y1
                Pos = ExcludeCoords(x)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                Get #FF, Pos, EListNum
                'now add these elistnnum sequences to the alignment and record the edits in the steps array
                ReDim OSNPos(NextNo + EListNum)
                
                For Z = 1 To EListNum
                    GoOn = 1
                    
                    NextNo = NextNo + 1
                    If (UBound(SeqNum, 1) * NextNo) > 40000000 Then
                        NextNo = NextNo - 1
                        Exit For
                    End If
                    
                    If NextNo > UBound(GrpMaskSeq, 1) Or NextNo > UBound(OriginalName, 1) Or NextNo > UBound(TraceSub, 1) Or NextNo > UBound(MaskSeq, 1) Then
                        ReDim Preserve TraceSub(NextNo + 50), OriginalName(NextNo + 50), StraiName(NextNo + 50), MaskSeq(NextNo + 50)
                        ReDim Preserve GrpMaskSeq(NextNo + 50)
                    End If
                    If NextNo > UBound(OriginalPos, 1) Then
                        ReDim Preserve OriginalPos(NextNo + 50)
                    End If
                    TraceSub(NextNo) = x
                    
                    MaskSeq(NextNo) = 0
                    EPosX = Seek(FF) 'remember the position of this specific sequence
                    Get #FF, , SSN 'Original number of the sequence that this unexcluded sequence this sequence is most similar to
                    Get #FF, , OSN 'original seq number
'                    If OSN = 6709 Then
'                        x = x
'                        '258
'                        For BBx = 0 To NextnoBak
'                            If OriginalPos(BBx) = 4541 Then
'                                x = x
'                            End If
'                        Next BBx
'                    End If
                    OSNPos(NextNo) = OSN
                    Get #FF, , TELong 'discard number
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'originalname
                    XX = SEventNumber
                    OriginalName(NextNo) = TEString
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString
                    StraiName(NextNo) = TEString 'strainame
                    Get #FF, , TELong 'seqeunec length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'sequence
                    'XX = SEventNumber
                    
                    If UBound(SeqNum, 2) < NextNo Then
                        ReDim Preserve SeqNum(UBound(SeqNum, 1), NextNo + 10)
                    End If
                    'copy the sequence into the nextno slot
                    
                    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                    'there is sequence compression and the loaded sequence needs to be modified accordingly
                       TEString = CompressTEString(Decompress(), TEString)
                    End If
                    
                    Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), TEString, SSBak(0))
                    ReDim Preserve StrainSeq(NextNo)
                    StrainSeq(NextNo) = TEString
                    'this is the original sequence that gets copied into seqnum so it must be edited to account for
                    'all recombination event that were previously inferred for this sequence
                    Steps(0, StepNo) = 1 'ie create a new sequence ....
'                    If x = 159 Then
'                        x = x
'                    End If
                    Steps(1, StepNo) = x 'using this seqence as the source of the current exclude
                    Steps(2, StepNo) = -EPosX 'the specific excluded sequence (the negative will indicate to modseqnum that the additional sequence is from the excludelist
                    Steps(3, StepNo) = 0 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                    'XX = UBound(SeqNum, 1)
                    If NextNo > UBound(MissingData, 2) Then
                        ReDim Preserve MissingData(UBound(MissingData, 1), NextNo)
                    End If
'                    If SEventNumber = 9 Then
'                        x = x
'                    End If
                    '@
                    For Y1 = 1 To Len(StrainSeq(0))
                        MissingData(Y1, NextNo) = 0
                    Next Y1
                    'For G = 0 To ExcludedEventNum
                    
                    '    If EventsInExcludeds(3, G) = CurSeed Then
                            For Y = 0 To NumMD - 1
                                If BoundsMD(Y, 1) > Len(StrainSeq(0)) Then BoundsMD(Y, 1) = Len(StrainSeq(0))
                                If BoundsMD(Y, 0) > Len(StrainSeq(0)) Then BoundsMD(Y, 0) = Len(StrainSeq(0))
                                
                                For Y1 = BoundsMD(Y, 0) To BoundsMD(Y, 1)
                                    SeqNum(Y1, NextNo) = 46
                                    MissingData(Y1, NextNo) = 1
                                Next Y1
                                
                                Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                                Steps(1, StepNo) = NextNo  'from this seqence.....
                                Steps(2, StepNo) = BoundsMD(Y, 0) 'from this position....
                                Steps(3, StepNo) = BoundsMD(Y, 1) 'to this position....
                                Steps(4, StepNo) = SEventNumber + 1
                               
                                StepNo = StepNo + 1
                                
                                UB = UBound(Steps, 2)
                                If StepNo > UB Then
                                    ReDim Preserve Steps(4, UB + 100)
                                End If
                            
                            Next Y
                        'End If
                    'Next G
                    
                    
                Next Z
                Close #FF
                '@
                ChDrive oDirX
                ChDir oDirX
                '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                'This could be a rescan
                'Need to check the the already accepted events in bestxolist to see if any of the
                'current batch of added in excludes contain sequences in that list
                'basically I need to search bestxolist for matches to the seed sequence where the .beginp property is <0
                'I then simply check if the .daughter is >permnextno and, if so,
                'add in an edit to that sequence and record the edit in steps
                ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                For Y = 1 To BCurrentXOver(CurSeed)
                    If BestXOList(CurSeed, Y).BeginP < 0 Then
                        If BestXOList(CurSeed, Y).Daughter > PermNextno Then
                             DSX = BestXOList(CurSeed, Y).Daughter
                             BreakB = BestXOList(CurSeed, Y).Beginning
                             BreakE = BestXOList(CurSeed, Y).Ending
                             Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                             Steps(1, StepNo) = DSX  'from this seqence.....
                             Steps(2, StepNo) = BreakB 'from this position....
                             Steps(3, StepNo) = BreakE 'to this position....
                             Steps(4, StepNo) = SEventNumber + 1
                             
                             StepNo = StepNo + 1
                             
                             UB = UBound(Steps, 2)
                             If StepNo > UB Then
                                 ReDim Preserve Steps(4, UB + 100)
                             End If
                             XX = UBound(SeqNum, 2)
                             If BreakB < BreakE Then
                                For Z = BreakB To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             Else
                                For Z = BreakB To Len(StrainSeq(0))
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                                For Z = 1 To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             
                             End If
                             
                        End If
                    End If
                Next Y
                
                
                
                DoneExcludes(x) = 1
                Exit For
            
            End If
            
           
        End If
    End If
Next x
If GoOn = 0 Then
    DoExcludes = 0
    
    Exit Sub
End If

ReDim CurrentXOver(NextNo), XoverList(NextNo, XOverListSize), MaxXOP(AddNum - 1, NextNo)
Call ResetMaxPVCO(NextNo)
SS = Abs(GetTickCount)
Form1.ProgressBar1 = (((CurSeed + 1) / (PermNextno + 1))) * 100
Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (3% of this cluster completed)"
GlobalTimer = SS
'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
Call UpdateTimeCaps(SS, STartT)
Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

DoEvents

'Dummy = MakeActualSeqSize(Len(StrainSeq(0)), Nextno, WinPP, RNum(0), RList(0, 0), ActualSeqSize(0), SeqNum(0, 0))
ReDim Preserve ActualSeqSize(NextNo)
For x = oNextno + 1 To NextNo
    ActualSeqSize(x) = 0
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 46 Then ActualSeqSize(x) = ActualSeqSize(x) + 1
    Next Y
Next x
'XX = Nextno
'XX = ActualSeqSize(53)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'need to mimic everything in dordp up to the innerscan call
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


If QvRFlag = 1 Then
    ReDim Preserve ReferenceList(NextNo)
End If
'Update the treedistance used for RDP and SiScan
ReDim TreeDistance(NextNo, NextNo)



Dim TDiffs() As Single, TValid() As Single, Uninvolved() As Long
ReDim Uninvolved(NextNo)
For x = 0 To NextNo
    Uninvolved(x) = 1
Next x


If PermNextno > MemPoc Then
    
    GetPermDiffs
'    XX = ActualSeqSize(3)
'    XX = Uninvolved(3)
    ReDim TDiffs(NextNo, NextNo)
    
    Dummy = MakeTDiffs2(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), PermDIffs(0, 0), Uninvolved(0), ActualSeqSize(0))
   
'    XX = TDiffs(3, 1)
'    XX = TDiffs(0, 1)
'    XX = PermDiffs(3, 1)
    ReDim PermDIffs(0, 0)
    
    GetPermValid
    
    'XX = PermValid(0, 1)
'    XX = Uninvolved(0)
'    XX = Uninvolved(1)
    ReDim TValid(NextNo, NextNo)
    
    Dummy = MakeTDiffs3(NextNo, UBound(PermValid, 1), TValid(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
    
'    XX = TValid(1, 0)
'    XX = PermValid(0, 1)
    ReDim PermValid(0, 0)
Else
    ReDim TDiffs(NextNo, NextNo), TValid(NextNo, NextNo)
     
    Dummy = MakeTDiffs(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), TValid(0, 0), PermDIffs(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
'XX = oNextno
End If

'XX = TValid(0, 1)
ReDim Distance(NextNo, NextNo)

'AvDst = 0
Dim tRedoDist() As Integer, Invert(1) As Byte
Invert(0) = 1
Invert(1) = 0
ReDim tRedoDist(NextNo)
If RedoAllDists = 0 Then
    For x = oNextno + 1 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
Else
    For x = 0 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
End If
   SS = Abs(GetTickCount)
Call FastDistanceCalcZ(1, 0, 1, Len(StrainSeq(0)), NextNo, TDiffs(), TValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
 
'EE = abs(gettickcount)
'         TT = EE - SS
'         If TT < 7 Then TT = 7
'         FBD = FBD + TT
ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo)
Dummy = FinishDists2(NextNo, PermValid(0, 0), PermDIffs(0, 0), TValid(0, 0), TDiffs(0, 0), Distance(0, 0))


If PermNextno > MemPoc And x = 1234567 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    UBDistance = UBound(Distance, 1)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Put #FF, , Distance()
    Close #FF
    DistanceInFileFlag = 1
    ReDim Distance(0, 0)
    ChDir oDir
    ChDrive oDir
End If
    

If PermNextno > MemPoc Then
    Call PutPermValid
    Call PutPermDiffs
    'ReDim PermDiffs(0, 0)
    'ReDim PermValid(0, 0)
End If


Erase TDiffs
Erase TValid

DistanceFlag = 1
TreeDistFlag = 0

Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
'XX = TreeDistance(1, 0)
DoEvents

Dim DP() As Byte
ReDim DP(NextNo, NextNo)
If x = 123456 Then
'    For x = 0 To Nextno
'
'    For Y = 0 To Nextno
'        If TreeDistance(x, Y) <> 0 Then
'            x = x
'        End If
'
'    Next Y
'
'    Next x
    'find a phylogenetically representative selection of sequences in the includes that must be compared with the excludes in the
    'last recombination screen loops at the end - these are specified with the DP arrays
    Dim Seq1List() As Long, TV As Single, SL As Long, Longest As Long, DS() As Byte
    ReDim Seq1List(NextNo), DS(NextNo)
    SL = -1
    Seq1List(0) = CurSeed
    DS(CurSeed) = 1
    For x = 0 To oNextno - 1
        If DS(x) = 0 Then
            DS(x) = 1
            SL = SL + 1
            Longest = ActualSeqSize(x)
            Seq1List(SL) = x
            TV = TreeDistance(CurSeed, x)
            For Y = x + 1 To oNextno
                If DS(Y) = 0 Then
                    If TreeDistance(CurSeed, Y) = TV Then
                        DS(Y) = 1
                        If Longest < ActualSeqSize(Y) Then
                            Longest = ActualSeqSize(Y)
                            Seq1List(SL) = Y
                        End If
                    End If
                End If
            Next Y
        End If
        
    Next x
    For x = 0 To SL
        For Y = oNextno + 1 To NextNo
            DP(Seq1List(x), Y) = 1
            DP(Y, Seq1List(x)) = 1
        Next Y
    Next x
'    For x = 0 To oNextno
'        For Y = oNextno + 1 To Nextno
'            DP(x, Y) = 1
'            DP(Y, x) = 1
'        Next Y
'    Next x
End If
If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        
    End If
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        Erase TreeX
    End If
    ChDrive oDirX
    ChDir oDirX
End If

Dim tMaskseq() As Byte
ReDim tMaskseq(NextNo)

If MaskThresh = 0 Then
    Dim Correx, AA
    AA = x
    
    Correx = MCCorrection * (Len(StrainSeq(0)) / XOverWindowX)
    
    'If LowestProb = 0 Then LowestProb = 0.05
    Correx = LowestProb / Correx
    Correx = 1 / Correx
    Correx = Log(Correx) / Log(4)
 'XX = (2 * Log(4 * X))
    'Y = (2 * Log(4 * X)) / Len(StrainSeq(0))
     MaskThresh = Correx / Len(StrainSeq(0))
     MaskThresh = MaskThresh / 3
End If

If MaskThresh > 0 Then
    'mask sequences that are almost identical
    For x = 0 To PermNextno
        tMaskseq(x) = MaskSeq(x)
    Next x
    For x = oNextno To NextNo
        If ((1 - Distance(x, CurSeed)) < MaskThresh) Then
            tMaskseq(x) = 1
        Else
            If tMaskseq(x) = 0 Then
                For Y = x + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        If ((1 - Distance(x, Y)) < MaskThresh) Then
                            If ActualSeqSize(x) < ActualSeqSize(Y) Then
                                tMaskseq(x) = 1
                            
                            Else
                                tMaskseq(Y) = 1
                            End If
                            x = oNextno - 1
                            Exit For
                        End If
                    End If
                Next Y
            End If
        End If
    Next x
End If


SSSss = Abs(GetTickCount)
UseCompress = 1
Call MakeScanCompressArrays(NextNo, SeqNum())
EE = Abs(GetTickCount)
TT = EE - SSSss
'first scan all the excludes against one another and one of the includes
Dim SP As Long, oDWS As Byte
oDWS = DontWorryAboutSplitsFlag
DontWorryAboutSplitsFlag = 1


If DoScans(0, 0) = 1 Then
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
End If
If DoScans(0, 3) = 1 Then
    Call SetupMCArrays
End If
'If DoScans(0, 3) = 1 Then
'    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
'End If
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Prefilter which pairs of includes to bother with here using the fastrecchecks and a very high p-val cutoff to look for
'instances where, curseed and one of the excludes when scanned against one of the includes yields even a very marginally significant p-value.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'UCThresh = 1
Dim BotherWith() As Byte, AtLeastOne As Byte
ReDim BotherWith(NextNo)

LowestProb = pLowestProb
'If CurSeed = 6 Then
'    x = x
'End If
If x = 12345 Then
    
        'Make a seq1 list that samples the logest sequence off every branch below curseed
        
        
        UCThresh = LowestProb / (MCCorrection / 10000)
        If UCThresh > 0.05 Then UCThresh = 0.05
        AtLeastOne = 0
        EarlyBale = 1
'        For x = 0 To oNextno
'            BotherWith(x) = 1
'        Next x
        
        Seq1 = CurSeed
'        For x = 0 To SL
'            Seq1 = Seq1List(x)
            For Seq2 = 0 To oNextno
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = oNextno + 1 To NextNo
                            If Seq1 <> Seq2 And tMaskseq(Seq3) = 0 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
                                            
                                            For x = oNextno + 1 To NextNo
                                                DP(x, Seq2) = 1
                                                DP(Seq2, x) = 1
                                            Next x
                                            
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            Exit For
                                        End If
                                    End If
                                End If
                            End If
                        Next Seq3
                    End If
                
            Next Seq2
             For Seq2 = oNextno + 1 To NextNo - 1
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = Seq2 + 1 To NextNo
                            'If Seq1 <> Seq3 And Seq2 <> Seq3 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize And tMaskseq(Seq3) = 0 Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
'                                            If x <= oNextno And BotherWith(Seq3) = 0 Then
'                                                For x = oNextno + 1 To Nextno
'                                                    DP(x, Seq3) = 1
'                                                    DP(Seq3, x) = 1
'                                                Next x
'                                            End If
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            'Exit For
                                        End If
                                    End If
                                End If
                            'End If
                        Next Seq3
                    End If
                
            Next Seq2
        'Next x
        EarlyBale = 0
        For x = oNextno + 1 To NextNo
            DP(CurSeed, x) = 1
            DP(x, CurSeed) = 1
        Next x
        

Else
    AtLeastOne = 1
    For x = oNextno + 1 To NextNo
        BotherWith(x) = 1
    Next x
End If


'XX = Nextno - oNextno

'AtLeastOne = 1
'For x = 0 To Nextno
'   BotherWith(x) = 1
'Next x

Dim FRC As Long
SS = Abs(GetTickCount)
Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (10% of this cluster completed)"
GlobalTimer = SS
'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
Call UpdateTimeCaps(SS, STartT)
Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

DoEvents


Dim FindAllFlagX As Byte
FindAllFlagX = 1

SSSss = Abs(GetTickCount)
If x = x Then
    Dim TP() As Byte
        ReDim DP(NextNo, NextNo), TP(NextNo, NextNo)
        For x = 0 To NextNo
            If tMaskseq(x) = 0 Then
                For Y = oNextno + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        TP(x, Y) = 1
                        'TP(Y, X) = 1
                    End If
                Next Y
            End If
        Next x
       ' Call FastRecCheckGC(Nextno, (LowestProb / (oNextno * (Nextno - oNextno))) * 10000, DP(), SeqNum(), TP(), tMaskseq())
        Call FastRecCheckGC(NextNo, 0.05, DP(), SeqNum(), TP(), tMaskseq())
        'Dim VarSites() As Long
        'ReDim VarSites(Len(StrainSeq(0)))
    Dim SubThresh As Double
    SubThresh = (LowestProb / MCCorrection) * 100
    
    Dim NumRedos As Long ', RedoL() As Long
    'ReDim RedoL(2, oNextno * (NextNo - oNextno + 1) * (NextNo - oNextno + 1) / 2)
    Dim RedoL2() As Long
    Dim DP2() As Byte ', DP3() As Byte
    ReDim DP2(NextNo, NextNo) ', DP3(NextNo, NextNo)
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            DP2(x, Y) = DP2(x, Y)
'        Next Y
'    Next x
    XX = CurSeed
'    XX = PermValid(22, 245)
'    XX = PermValid(22, 285)
'    XX = PermValid(245, 285)
    
'    If CurSeed > 7 Then
'        StepNo = FirstStepNo 'StepNo - 1
'        GoTo Redo
'    End If
    
    
    
'SSSS = abs(gettickcount)
'For Z = 0 To 10
'        ReDim XoverList(NextNo, 20)
'        ReDim CurrentXOver(NextNo)
   
   SS = Abs(GetTickCount)
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (10% of this cluster completed)"
    UpdateRecNums (SEventNumber)
    GlobalTimer = SS
    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    
   Dim UBPV2 As Long
    UBPV2 = UBound(PermValid, 2)
    
    
    'Make ALIst
    Dim BAL As Variant, ALC As Long
    BAL = (oNextno + 1)
    BAL = BAL * (NextNo - oNextno)
    BAL = BAL * (NextNo - oNextno - 1)
    BAL = BAL / 6
    'BAL = BAL * oNextno + 1
    If BAL < 6000000 Then
        ReDim AList(2, BAL)
    Else
        BAL = 6000000
        ReDim AList(2, 6000000)
    End If
    Dim RestartPos() As Long, PropP As Variant
    ReDim RestartPos(2)
    Dim SProg As Single
    SProg = 0
    
    Do While RestartPos(0) > -1
'        If x = x Then
            lrsp = RestartPos(0)
            ALC = MakeAListASEF(BAL, RestartPos(0), oNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DP, 1), DP(0, 0), tMaskseq(0), UBound(PermValid, 1), PermValid(0, 0), PermDIffs(0, 0))
            If lrsp = RestartPos(0) Then
                RestartPos(0) = RestartPos(0) + 1
                If RestartPos(0) > oNextno Then
                    RestartPos(0) = -1
                End If
            End If
'        Else
'            ALC = -1
'            For Seq1 = 0 To oNextno '0 To oNextno
'                 If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
'
'                     For Seq2 = oNextno + 1 To NextNo - 1
'                             If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
'                                 If PermDiffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
'                                     For Seq3 = Seq2 + 1 To NextNo
'                                         If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 And (DP(Seq3, Seq2) + DP(Seq3, Seq1) + DP(Seq2, Seq1) > 0) Then
'                                             If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
'                                                 If PermDiffs(Seq2, Seq3) > 2 Then
'                                                     ALC = ALC + 1
'                                                     AList(0, ALC) = Seq1
'                                                     AList(1, ALC) = Seq2
'                                                     AList(2, ALC) = Seq3
'                                                 End If
'                                             End If
'                                         End If
'                                     Next Seq3
'                                 End If
'                             End If
'                     Next Seq2
'                 End If
'
'             Next Seq1
'        End If
            DoEvents
            Dim RedoL3() As Byte, EPX As Long
            Dim StepsX As Long
'        If CurSeed = 7 Then
'            x = x
'        End If
            NumP = 0
            curp = 0
            For x = 0 To AddNum
                NumP = NumP + DoScans(0, x)
            Next x
            If RestartPos(0) = -1 Then
                PropP = 1
            Else
                PropP = oNextno - (RestartPos(0) - 1)
            End If
            PropP = PropP * (NextNo - oNextno)
            PropP = PropP * ((NextNo - oNextno - 1))
            
            PropP = PropP / 6
            If BAL > 0 Then
                PropP = PropP / BAL
            Else
                PropP = 0
            End If
            PropP = 1 - PropP
            If PropP > 1 Or PropP = 0 Then PropP = 1
            PropP = PropP - SProg
        ReDim SubSeq(Len(StrainSeq(0)), 6)
        Dim BPropP As Single, BSProg As Single
        BPropP = PropP
        
        BSProg = SProg
        If DoScans(0, 3) = 1 Then
            Call SetupMCArrays
        End If
        
        'XX = NextNo
        If DoScans(0, 0) = 1 Or DoScans(0, 1) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Then
            
'            If x = x Then
            
                If ALC > -1 Then
                    
                    StepsX = CLng(100000000 / Len(StrainSeq(0)))
                    UseCompress = 1
                    LT = GetTickCount
                    If DoScans(0, 0) = 1 Then
                        ReDim RedoL3(ALC)
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'@'@
                            NumRedos = AEFirstAlistRDP3(UBound(DP2), DP2(0, 0), AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                            'If NumRedos > 0 Then
                                
                            For x = Y To EPX
                                If RedoL3(x) > 0 Then
                                    Seq1 = AList(0, x)
                                    Seq2 = AList(1, x)
                                    Seq3 = AList(2, x)
                                    ''22,245,285
                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                End If
                            Next x
                            'End If
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                
                                If Y + StepsX - 1 <= ALC Then
                                    If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str(10 + CLng((RestartPos(0) / oNextno) * 250) / 10)) + "% of this cluster completed)"
                                    Else
                                    
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + CLng(SProg * 250) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 250)) / 10))) + "% of this cluster completed)"
                                    End If
                                Else
                                   'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + SProg * 25 + (PropP * 10) / 10))) + "% of this cluster completed)"
                                End If
                                UpdateRecNums (SEventNumber)
                                GlobalTimer = ET
                                
                                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                                MethodTime(0) = MethodTime(0) + (ET - LT)
                                Call UpdateTimeCaps(ET, ET)
                                LT = ET
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                DoEvents
                                x = x
                            End If
                        Next Y
                    End If
                    If DoScans(0, 1) = 1 Then
                        PropP = BPropP
                        SProg = BSProg
                        ReDim RedoL3(ALC)
                        LT = GetTickCount
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'@'@
                            NumRedos = AEFirstAlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, UBound(DP2), DP2(0, 0), AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    
                                
                            For x = Y To EPX
                                If RedoL3(x) > 0 Then
                                    Seq1 = AList(0, x)
                                    Seq2 = AList(1, x)
                                    Seq3 = AList(2, x)
                                    ''22,245,285
                                     NewOneFound = 0
                                    Call GCXoverD(0)
'                                    If NewOneFound = 0 Then
'                                        x = x
'                                    End If
                                End If
                            Next x
                            'End If
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                
                                If Y + StepsX - 1 <= ALC Then
                                    If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str(10 + CLng((RestartPos(0) / oNextno) * 250) / 10)) + "% of this cluster completed)"
                                    Else
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + CLng(SProg * 250) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 250)) / 10))) + "% of this cluster completed)"
                                    End If
                                Else
                                   'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + SProg * 25 + (PropP * 10) / 10))) + "% of this cluster completed)"
                                End If
                                UpdateRecNums (SEventNumber)
                                GlobalTimer = ET
                                
                                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                                MethodTime(1) = MethodTime(1) + (ET - LT)
                                Call UpdateTimeCaps(ET, ET)
                                LT = ET
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                DoEvents
                                x = x
                            End If
                        Next Y
                    
                    End If
                    
                    If DoScans(0, 3) = 1 Then
                        PropP = BPropP
                        SProg = BSProg
                        ReDim RedoL3(ALC)
                        LT = GetTickCount
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'@'@
                            'NumRedos = AlistMC2(Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindallFlag, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCTHresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                            HWindowWidth = CLng(MCWinSize / 2)
                            lHWindowWidth = HWindowWidth
                            'findallflag must match with the mcxoverf switch
                            NumRedos = AEFirstAlistMC(SEventNumber, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, UBound(DP2), DP2(0, 0), AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                            'NumRedos = AlistGC2(UBound(StoreLPV, 1), StoreLPV(0, 0), GCIndelFlag, GCMissmatchPen, GCDimSize, Analysislist(0, 0), TripListLen, Y, EPX, NextNo, UCTHresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            'NumRedos = AEFirstAlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, UBound(DP2), DP2(0, 0), AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                            
                                
                            For x = Y To EPX
                                If RedoL3(x) > 0 Then
                                    Seq1 = AList(0, x)
                                    Seq2 = AList(1, x)
                                    Seq3 = AList(2, x)
                                    ''22,245,285
                                    
                                    BQPV = 1

                                    NewOneFound = 0
                                    Call MCXoverF(FindAllFlagX, 0, 0)
                                    'End If
                                    x = x
'                                    If BQPV > 0 Then
'                                       If BQPV < SubThresh Then
'                                            NewOneFound = 1
'                                            If DP2(Seq3, Seq1) = 0 Or DP2(Seq1, Seq3) = 0 Or DP2(Seq2, Seq1) = 0 Or DP2(Seq1, Seq2) = 0 Then
'                                                x = x
'                                            End If
'                                            DP2(Seq3, Seq1) = 1
'                                            DP2(Seq1, Seq3) = 1
'                                            DP2(Seq2, Seq1) = 1
'                                            DP2(Seq1, Seq2) = 1
'                                        End If
'                                    End If
                                End If
                            Next x
                            'End If
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                
                                If Y + StepsX - 1 <= ALC Then
                                    If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str(10 + CLng((RestartPos(0) / oNextno) * 250) / 10)) + "% of this cluster completed)"
                                    Else
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + CLng(SProg * 250) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 250)) / 10))) + "% of this cluster completed)"
                                    End If
                                Else
                                   'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + SProg * 25 + (PropP * 10) / 10))) + "% of this cluster completed)"
                                End If
                                UpdateRecNums (SEventNumber)
                                GlobalTimer = ET
                                
                                MethodTime(3) = MethodTime(3) + (ET - LT)
                                Call UpdateTimeCaps(ET, ET)
                                LT = ET
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                DoEvents
                                x = x
                            End If
                        Next Y
                    
                    End If
                    If DoScans(0, 4) = 1 Then
                        PropP = BPropP
                        SProg = BSProg
                        ReDim RedoL3(ALC)
                        LT = GetTickCount
                        For Y = 0 To ALC Step StepsX
                            If Y + StepsX - 1 > ALC Then
                                EPX = ALC
                            Else
                                EPX = Y + StepsX - 1
                            End If
                            '@'@'@'@'@'@
                            HWindowWidth = CLng(MCWinSize / 2)
                            lHWindowWidth = HWindowWidth
                            'findallflag must match with the mcxoverf switch
                            'NumRedos = AlistMC2(Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindallFlag, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), Analysislist(0, 0), TripListLen, RedoL3(0), CircularFlag, MCCorrection, MCFlag, UCTHresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                            NumRedos = AEFirstAlistChi(SEventNumber, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, FindAllFlagX, UBound(DP2), DP2(0, 0), AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSRDP, 2), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                            For x = Y To EPX
'                                If RedoL3(x) > 0 Then
'                                    Seq1 = AList(0, x)
'                                    Seq2 = AList(1, x)
'                                    Seq3 = AList(2, x)
'                                    BQPV = 1
'
'                                    NewOneFound = 0
'                                    Call MCXoverF(0, 0, 0)
'                                End If
                                If RedoL3(x) > 0 Then
                                    If ProgBinRead(0, RedoL3(x)) = 1 Then
                                        
                                        Seq1 = AList(0, x) '0
                                        Seq2 = AList(1, x) '31
                                        Seq3 = AList(2, x) '83
                                        
                                        BQPV = 1
        '                                If Y = 4229 Then
        '                                    x = x
        '                                End If
                                        
                                        NewOneFound = 0
                                        Call CXoverA(FindAllFlagX, 0, 0)
        '                                If (NewOneFound = 0 And ProgBinRead(0, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(0, RedoL3(x)) = 0) Then
        '                                    x = x
        '                                End If
                                        
                                    End If
                                    If ProgBinRead(2, RedoL3(x)) = 1 Then
                                        
                                        Seq3 = AList(0, x) '5
                                        Seq1 = AList(1, x) '83
                                        Seq2 = AList(2, x) '104
                                        
                                        BQPV = 1
                                        NewOneFound = 0
                                        Call CXoverA(FindAllFlagX, 0, 0)
        '                                If (NewOneFound = 0 And ProgBinRead(2, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(2, RedoL3(x)) = 0) Then
        '                                    x = x
        '                                End If
                                    End If
                                    If ProgBinRead(4, RedoL3(x)) = 1 Then
                                        
                                        Seq2 = AList(0, x) '5
                                        Seq3 = AList(1, x) '83
                                        Seq1 = AList(2, x) '107
                                       
                                        BQPV = 1
                                        NewOneFound = 0
                                        Call CXoverA(FindAllFlagX, 0, 0)
        '                                If (NewOneFound = 0 And ProgBinRead(4, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(4, RedoL3(x)) = 0) Then
        '                                    x = x
        '                                End If
                                    End If
    '                                If ProgBinRead(1, RedoL3(x)) = 1 Or ProgBinRead(3, RedoL3(x)) = 1 Or ProgBinRead(5, RedoL3(x)) = 1 Then
    '                                    ZZZ = ZZZ + 1
    '    '                                If ProgBinRead(4, Worthwhilescan(x)) = 0 Then
    '    '                                    Worthwhilescan(x) = Worthwhilescan(x) + 5
    '    '                                End If
    '                                    Call AddToRedoList(4, AList(0, x), AList(1, x), AList(2, x))
    '                                End If
                                End If
                            Next x
                            'End If
                            
                            ET = Abs(GetTickCount)
                            ET = Abs(ET)
                            If Abs(ET - LT) > 500 Then
                                
                                If Y + StepsX - 1 <= ALC Then
                                    If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str(10 + CLng((RestartPos(0) / oNextno) * 250) / 10)) + "% of this cluster completed)"
                                    Else
                                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + CLng(SProg * 250) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 250)) / 10))) + "% of this cluster completed)"
                                    End If
                                Else
                                   'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + SProg * 25 + (PropP * 10) / 10))) + "% of this cluster completed)"
                                End If
                                UpdateRecNums (SEventNumber)
                                GlobalTimer = ET
                                
                                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                                MethodTime(4) = MethodTime(4) + (ET - LT)
                                Call UpdateTimeCaps(ET, ET)
                                LT = ET
                                Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                
                                DoEvents
                                x = x
                            End If
                        Next Y
                    
                    End If
                    If (NumProgs > 1 And RestartPos(0) > 0) Then
                    Else
                        SProg = SProg + PropP
                    End If
                    
                    UseCompress = 0
'                Else
'                '@'@
'                    ReDim RedoL(2, ((oNextno * (oNextno + 1)) / 2) * (NextNo - oNextno + 1))
'                    NumRedos = AEFirstRDP3(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDiffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
'                    If NumRedos > 0 Then
'                        If x = x Then 'reorder redos
'                            'sort seq 1
'                            SSS = abs(gettickcount)
'                            Dim S1Count() As Long, CurS1 As Long, SPS1() As Long
'                            ReDim S1Count(oNextno), SPS1(oNextno)
'                            For x = 1 To NumRedos
'                                CurS1 = RedoL(0, x)
'                                S1Count(CurS1) = S1Count(CurS1) + 1
'                            Next x
'                            SPS1(0) = S1Count(0)
'                            For x = 1 To oNextno
'                                SPS1(x) = SPS1(x - 1) + S1Count(x)
'                            Next x
'                            ReDim RedoL2(2, NumRedos)
'                            Dim L2Pos As Long
'                            For x = NumRedos To 0 Step -1
'                                L2Pos = SPS1(RedoL(0, x))
'                                RedoL2(0, L2Pos) = RedoL(0, x)
'                                RedoL2(1, L2Pos) = RedoL(1, x)
'                                RedoL2(2, L2Pos) = RedoL(2, x)
'                                SPS1(RedoL(0, x)) = SPS1(RedoL(0, x)) - 1
'                            Next x
'        '                    XX = SPS1(4)
'        '                    XX = S1Count(4)
'        '                    SSS = abs(gettickcount)
'        '                    For x = 0 To NumRedos
'        '                        For y = x + 1 To NumRedos
'        '                            If RedoL2(0, x) > RedoL2(0, y) Then
'        '                                Call SwapSort(RedoL2(), x, y)
'        '                            ElseIf RedoL2(0, x) = RedoL2(0, y) Then
'        '                                If RedoL2(1, x) > RedoL2(1, y) Then
'        '                                    Call SwapSort(RedoL2(), x, y)
'        '                                ElseIf RedoL2(1, x) = RedoL2(1, y) Then
'        '                                    If RedoL2(2, x) > RedoL2(2, y) Then
'        '                                        Call SwapSort(RedoL2(), x, y)
'        '                                    End If
'        '                                End If
'        '                            End If
'        '                        Next y
'        '                    Next x
'                        End If
'                        For x = 1 To NumRedos
'
'                          Seq1 = RedoL2(0, x)
'                          Seq2 = RedoL2(1, x)
'                          Seq3 = RedoL2(2, x)
'                          ''22,245,285
'                          Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                        Next x
'                        SS = abs(gettickcount)
'                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (35% of this cluster completed)"
'                        UpdateRecNums (SEventNumber)
'                        GlobalTimer = SS
'                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'                        Call UpdateTimeCaps(SS, STartT)
'                        Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'
'                        DoEvents
'                    End If
                End If
            
'            Else
'                For Seq1 = 0 To oNextno '0 To oNextno
'                'if I let other sequences in besides curseed here it is very difficult to properly group recombinants
'                'Also, The way it was it was possible to get all three signal sequences from this exclude list cluster.
'        '            If Seq1 = 22 Then
'        '                x = x
'        '            End If
'
'
'                    NumRedos = AEFirstRDP(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDiffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
'                    'NumRedos = AEFirstRDP2(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDiffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
'
'
'
'                    If NumRedos > 0 Then
'                        For x = 1 To NumRedos
'                          Seq2 = RedoL(1, x)
'                          Seq3 = RedoL(2, x)
'                          ''22,245,285
'                          Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                        Next x
'                    End If
'
'                    SS = abs(gettickcount)
'                    If Abs(SS - GlobalTimer) > 500 Then
'                        GlobalTimer = SS
'                        'If Seq1 >= oNextno Then
'                            Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
'                        'End If
'                        DoEvents
'                        If AbortFlag = 1 Then
'                            Seq1 = NextNo
'                            Seq2 = NextNo
'                            Seq3 = NextNo
'                        End If
'                        UpdateRecNums (SEventNumber)
'                        GlobalTimer = SS
'                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'                        Call UpdateTimeCaps(SS, STartT)
'                        Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
'
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'                        If AbortFlag = 1 Then
'                            Exit For
'                        End If
'                    End If
'                Next Seq1
'            End If
            
            
    
            x = x
       End If
   Loop
   
   If DoScans(0, 2) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then 'Or DoScans(0, 4) = 1
        
         For Seq1 = 0 To oNextno '0 To oNextno
            If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
               
                For Seq2 = oNextno + 1 To NextNo - 1
                    'If BotherWith(Seq2) = 1 Or x = x Then
                        If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
                            If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
                                For Seq3 = Seq2 + 1 To NextNo
        '                            If Seq2 = 258 Or Seq3 = 258 Then
        '                                x = x
        '                            End If
                                    If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 And (DP(Seq3, Seq2) + DP(Seq3, Seq1) + DP(Seq2, Seq1) > 0) Then
                                        If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                            If PermDIffs(Seq2, Seq3) > 2 Then
                                                'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                    NewOneFound = 0
'                                                    If DoScans(0, 0) = 1 Then
'
'                                                        'Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                        'FRC = FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV)
'                                                        'FRC = 1
'                                                        BQPV = 0
'                                                        '22,245,285
''                                                        If Seq1 = 22 And Seq2 = 245 And Seq3 = 285 Then
''                                                            x = x
''                                                            Seq1 = 22: Seq2 = 245: Seq3 = 285
''                                                        End If
'                                                        If FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV) = 1 Then
'                                                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                           ' x = x
'                                                        Else
'                                                            If BQPV > 0 Then
'                                                               If BQPV < SubThresh Then
'                                                                    NewOneFound = 1
'                                                               End If
'                                                            End If
'
'                                                        End If
'                                                    End If
'                                                    'XX = UseCompress
'                                                    If DoScans(0, 1) = 1 Then
'                                                        Call GCXoverD(0)
'                                                    End If
                                                    If DoScans(0, 2) = 1 Then
                                                        Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                    End If
                                                    
                                                    
                                                    'GoOn = FastRecCheckMC(10, LongWindedFlag, BQPV, EarlyBale, UCTHresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidthX, HWindowWidth, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), CriticalDiffX, FindallFlag, BEP, ENP, UBound(FSSMC, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSMC(0, 0, 0, 0), SeqNum(0, 0), UBound(Winscores, 1), Scores(0, 0), Winscores(0, 0), XDiffPos(0), Chivals(0, 0), UBound(BanWin, 1), BanWin(0, 0), UBound(MDMap, 1), MDMap(0, 0), ChiTable2(0), Chimap(0, 0), mtP(0), SmoothChi(0, 0))
'                                                    If DoScans(0, 3) = 1 Then
''                                                        If Seq1 = 48 And Seq2 = 229 And Seq3 = 234 Then
''                                                            Seq3 = 234
''                                                        End If
'                                                        BQPV = 1
''                                                        If Seq1 = 46 And Seq2 = 240 And Seq3 = 291 And CurSeed = 21 Then
''                                                            x = x
''                                                        End If
'                                                        'Dim BQPV2 As Double
'                                                        'BQPV2 = 1
'                                                        'GoOn = FastRecCheckMC(10, LongWindedFlag, BQPV, EarlyBale, SubThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), CriticalDiff, 1, UBound(FSSMC, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSMC(0, 0, 0, 0), SeqNum(0, 0), UBound(Winscores, 1), Scores(0, 0), Winscores(0, 0), XDiffPos(0), Chivals(0, 0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChi(0, 0))
'                                                        'If GoOn = 1 Then
'                                                            NewOneFound = 0
'                                                            Call MCXoverF(0, 0, 0)
'                                                        'End If
'
'                                                        If BQPV > 0 Then
'                                                           If BQPV < SubThresh Then
'                                                                NewOneFound = 1
'
'                                                            End If
'                                                        End If
'                                                    End If
'                                                    If DoScans(0, 4) = 1 Then
'                                                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
'
'                                                        Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
'
'                                                        Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
'
'                                                        Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
'                                                    End If
                                                    
                                                    If DoScans(0, 5) = 1 Then
                                                        oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                        Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                        Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                    End If
                                                    
                                                    
                                                    If DoScans(0, 8) = 1 Then
                                                                                         
                                                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                            
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                    End If
                                                    '22,245,285
                                                    XX = (LowestProb / MCCorrection) 'UCTHresh
                                                    If NewOneFound = 1 Then
                                                        If DP2(Seq3, Seq1) = 0 Then
                                                            x = x
                                                        End If
                                                        '48,229,249
                                                        DP2(Seq3, Seq1) = 1
                                                        DP2(Seq1, Seq3) = 1
                                                        DP2(Seq2, Seq1) = 1
                                                        DP2(Seq1, Seq2) = 1
                                                    End If
                                                'End If
                                            End If
                                        End If
                                    End If
                                Next Seq3
                            End If
                        End If
                    'End If
                Next Seq2
                'XX = DP(1, 228)
                
                SS = Abs(GetTickCount)
                If Abs(SS - GlobalTimer) > 500 Then
                    GlobalTimer = SS
                    'If Seq1 >= oNextno Then
                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
                    'End If
                    DoEvents
                    If AbortFlag = 1 Then
                        Seq1 = NextNo
                        Seq2 = NextNo
                        Seq3 = NextNo
                    End If
                    UpdateRecNums (SEventNumber)
                    GlobalTimer = SS
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(SS, STartT)
                    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                    
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    If AbortFlag = 1 Then
                        Exit For
                    End If
                End If
            End If
        
        Next Seq1
   End If

'Next Z
'eeee = abs(gettickcount)
'tttt = eeee - SSSS '5.188, 6.125, 7.187
'x = x
End If
'For x = 0 To NextNo
'    For Y = 0 To NextNo
''        If DP2(x, Y) > 0 Then
''            x = x
''        End If
'        If DP2(x, Y) <> DP3(x, Y) Then '22,285
'            x = x
'        End If
'    Next Y
'Next x
'Open "PTestN.csv" For Append As #1
'For x = 0 To NextNo
'    For Y = 1 To CurrentXOver(x)
'        Print #1, Str(XoverList(x, Y).Probability) + "," + Str(XoverList(x, Y).Daughter) + "," + Str(XoverList(x, Y).MinorP) + "," + Str(XoverList(x, Y).MajorP)
'    Next Y
'Next x
'Close #1

If DoScans(0, 3) = 1 Then
    Call SetupMCArrays
End If


If AtLeastOne > 0 Then
        tSS = Abs(GetTickCount)
        
        
        
        '''For T = 1 To 10
'        For x = 0 To oNextno
'            For Y = oNextno + 1 To Nextno
'                If DP(x, Y) > 0 Then
'                    BotherWith(x) = 1
'                    Exit For
'                End If
'            Next Y
'        Next x
'        For x = 0 To oNextno
'            If BotherWith(x) = 0 Then
'                x = x
'            End If
'        Next x
    
    
    UBPV2 = UBound(PermValid, 2)
    'ReDim RedoL(2, ((oNextno * (oNextno + 1)) / 2) * (NextNo - oNextno + 1))
    
    BAL = oNextno + 1
    BAL = BAL * oNextno
    BAL = BAL * (NextNo - oNextno)
    BAL = BAL / 6
    'BAL = BAL * oNextno + 1
    If BAL < 6000000 Then
        ReDim AList(2, BAL)
    Else
        ReDim AList(2, 6000000)
        BAL = 6000000
    End If
    ReDim RestartPos(2)
    SProg = 0
    BSProg = 0
    Do While RestartPos(0) > -1 And RestartPos(0) <= oNextno
        'If x = x Then
            lrsp = RestartPos(0)
            ALC = MakeAListASES(BAL, RestartPos(0), oNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), tMaskseq(0), UBound(PermValid, 1), PermValid(0, 0), PermDIffs(0, 0))
            If lrsp = RestartPos(0) Then
                RestartPos(0) = RestartPos(0) + 1
                If RestartPos(0) > oNextno Then
                    RestartPos(0) = -1
                End If
            End If

       
        If RestartPos(0) = -1 Then
            PropP = 1
        Else
            PropP = (oNextno - (RestartPos(0) - 1))
        End If
        PropP = PropP * (oNextno - (RestartPos(0) - 1) - 1)
        PropP = PropP * ((NextNo - oNextno))
        
        PropP = PropP / 6
        
        NumProgs = 0
        For x = 0 To AddNum
            NumProgs = NumProgs + DoScans(0, x)
        Next x
        
        PropP = PropP * NumProgs
        
        If BAL > 0 Then
            PropP = PropP / BAL
        Else
            PropP = 0
        End If
        PropP = 1 - PropP
        If PropP > 1 Or PropP <= 0 Then PropP = 1
        'SProg = 0
        PropP = PropP - SProg
        
        
        
        ggg = Abs(GetTickCount)
        
        If DoScans(0, 3) = 1 Then
            Call SetupMCArrays
        End If
        
        If ALC > -1 Then
            If DoScans(0, 0) = 1 Then
                '@'@'@'@'@
                'ReDim Preserve AList(2, ALC)
                'If x = x Then
                   
                    curp = curp + 1
                    XX = TripListLen
                    ReDim RedoL3(ALC)
                    
                    StepsX = CLng(100000000 / Len(StrainSeq(0)))
                    UseCompress = 1
                    LT = GetTickCount
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@'@'@'@'@'@'@'@'@'@'@
                        NumRedos = AlistRDP3(AList(0, 0), ALC, Y, EPX, NextNo, (LowestProb / MCCorrection), RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                        'If NumRedos > 0 Then
                         'XX = UCThresh
                        'aaaa = 0
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                ''22,245,285
                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                aaaa = aaaa + 1
'                                x = x
                            End If
                        Next x
                        'End If
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            
                            If (Y + StepsX - 1) <= ALC Then
                                If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(RestartPos(0) / oNextno * 600) / 10))) + "% of this cluster completed)"
                                
                                Else
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(SProg * 600) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 600)) / 10))) + "% of this cluster completed)"
                                End If
                                'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(((Y + StepsX - 1) / (ALC)) * 600 * PropP) / 10))) + "% of this cluster completed)"
                            Else
                               'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
                            End If
                            UpdateRecNums (SEventNumber)
                            GlobalTimer = ET
                            
                            'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                            MethodTime(0) = MethodTime(0) + (ET - LT)
                            LT = ET
                            Call UpdateTimeCaps(ET, ET)
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            DoEvents
        
                        End If
                    Next Y
                    If (NumProgs > 1 And RestartPos(0) > 0) Then
                    Else
                        SProg = SProg + PropP
                    End If
                    UseCompress = 0
'                Else
'                    NumRedos = AESecondRDP3(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDiffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
'                    If NumRedos > 0 Then
'
'                        SS = abs(gettickcount)
'                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
'                        UpdateRecNums (SEventNumber)
'                        GlobalTimer = SS
'                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'                        Call UpdateTimeCaps(SS, STartT)
'                        Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'
'                        DoEvents
'                        If x = x Then 'reorder redos
'                            'sort seq 1
'                            SSS = abs(gettickcount)
'                            'Dim S1Count() As Long, CurS1 As Long, SPS1() As Long
'                            ReDim S1Count(oNextno), SPS1(oNextno)
'                            For x = 1 To NumRedos
'                                CurS1 = RedoL(0, x)
'                                S1Count(CurS1) = S1Count(CurS1) + 1
'                            Next x
'                            SPS1(0) = S1Count(0)
'                            For x = 1 To oNextno
'                                SPS1(x) = SPS1(x - 1) + S1Count(x)
'                            Next x
'                            ReDim RedoL2(2, NumRedos)
'                            'Dim L2Pos As Long
'                            For x = NumRedos To 0 Step -1
'                                L2Pos = SPS1(RedoL(0, x))
'                                RedoL2(0, L2Pos) = RedoL(0, x)
'                                RedoL2(1, L2Pos) = RedoL(1, x)
'                                RedoL2(2, L2Pos) = RedoL(2, x)
'                                SPS1(RedoL(0, x)) = SPS1(RedoL(0, x)) - 1
'                            Next x
'            '                    XX = SPS1(4)
'            '                    XX = S1Count(4)
'            '                    SSS = abs(gettickcount)
'            '                    For x = 0 To NumRedos
'            '                        For y = x + 1 To NumRedos
'            '                            If RedoL2(0, x) > RedoL2(0, y) Then
'            '                                Call SwapSort(RedoL2(), x, y)
'            '                            ElseIf RedoL2(0, x) = RedoL2(0, y) Then
'            '                                If RedoL2(1, x) > RedoL2(1, y) Then
'            '                                    Call SwapSort(RedoL2(), x, y)
'            '                                ElseIf RedoL2(1, x) = RedoL2(1, y) Then
'            '                                    If RedoL2(2, x) > RedoL2(2, y) Then
'            '                                        Call SwapSort(RedoL2(), x, y)
'            '                                    End If
'            '                                End If
'            '                            End If
'            '                        Next y
'            '                    Next x
'                        End If
'                        For x = 1 To NumRedos
'
'                          Seq1 = RedoL2(0, x)
'                          Seq2 = RedoL2(1, x)
'                          Seq3 = RedoL2(2, x)
'                          ''22,245,285
'                          Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                        Next x
'
'                        For x = 0 To NextNo
'                            XXX = XXX + CurrentXOver(x) '7753
'                        Next x
'                        SS = abs(gettickcount)
'                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (100% of this cluster completed)"
'                        UpdateRecNums (SEventNumber)
'                        GlobalTimer = SS
'                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'                        Call UpdateTimeCaps(SS, STartT)
'                        Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'
'                        DoEvents
'                    End If
'                End If
        '        XXX = 0
        '        For x = 0 To NextNo
        '            XXX = XXX + CurrentXOver(x) '7753
        '        Next x
        '        EEE = abs(gettickcount)
        '        ttt = EEE - ggg
                x = x
            End If
            If DoScans(0, 1) = 1 Then
                
                '@'@'@'@'@
                'ReDim Preserve AList(2, ALC)
                'If x = x Then
                   
                    
                    XX = TripListLen
                    ReDim RedoL3(ALC)
                    
                    StepsX = CLng(100000000 / Len(StrainSeq(0)))
                    UseCompress = 1
                    LT = GetTickCount
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@'@'@'@'@'@'@'@'@'@'@
                        NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                    'If NumRedos > 0 Then
                    '@'@
                    For x = Y To EPX
                        If RedoL3(x) > 0 Then
                            Seq1 = AList(0, x)
                            Seq2 = AList(1, x)
                            Seq3 = AList(2, x)
                            'ZZZ = ZZZ + 1
                            'CurrentTripListNum = x
                            ''22,245,285
                             NewOneFound = 0
                            Call GCXoverD(0)
                            
                        End If
                    Next x
                        'End If
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            
                            If Y + StepsX - 1 <= ALC Then
                            
                                If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(RestartPos(0) / oNextno * 600) / 10))) + "% of this cluster completed)"
                                
                                Else
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(SProg * 600) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 600)) / 10))) + "% of this cluster completed)"
                                End If
                                'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(((Y + StepsX - 1) / (ALC)) * 600 * PropP) / 10))) + "% of this cluster completed)"
                            Else
                               'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
                            End If
                            UpdateRecNums (SEventNumber)
                            GlobalTimer = ET
                            'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                            MethodTime(1) = MethodTime(1) + (ET - LT)
                            Call UpdateTimeCaps(ET, ET)
                            LT = ET
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            DoEvents
        
                        End If
                    Next Y
                    If (NumProgs > 1 And RestartPos(0) > 0) Then
                    Else
                        SProg = SProg + PropP
                    End If
                    UseCompress = 0
'                Else
'                    NumRedos = AESecondRDP3(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDiffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
'                    If NumRedos > 0 Then
'
'                        SS = abs(gettickcount)
'                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
'                        UpdateRecNums (SEventNumber)
'                        GlobalTimer = SS
'                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'                        Call UpdateTimeCaps(SS, STartT)
'                        Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'
'                        DoEvents
'                        If x = x Then 'reorder redos
'                            'sort seq 1
'                            SSS = abs(gettickcount)
'                            'Dim S1Count() As Long, CurS1 As Long, SPS1() As Long
'                            ReDim S1Count(oNextno), SPS1(oNextno)
'                            For x = 1 To NumRedos
'                                CurS1 = RedoL(0, x)
'                                S1Count(CurS1) = S1Count(CurS1) + 1
'                            Next x
'                            SPS1(0) = S1Count(0)
'                            For x = 1 To oNextno
'                                SPS1(x) = SPS1(x - 1) + S1Count(x)
'                            Next x
'                            ReDim RedoL2(2, NumRedos)
'                            'Dim L2Pos As Long
'                            For x = NumRedos To 0 Step -1
'                                L2Pos = SPS1(RedoL(0, x))
'                                RedoL2(0, L2Pos) = RedoL(0, x)
'                                RedoL2(1, L2Pos) = RedoL(1, x)
'                                RedoL2(2, L2Pos) = RedoL(2, x)
'                                SPS1(RedoL(0, x)) = SPS1(RedoL(0, x)) - 1
'                            Next x
'            '                    XX = SPS1(4)
'            '                    XX = S1Count(4)
'            '                    SSS = abs(gettickcount)
'            '                    For x = 0 To NumRedos
'            '                        For y = x + 1 To NumRedos
'            '                            If RedoL2(0, x) > RedoL2(0, y) Then
'            '                                Call SwapSort(RedoL2(), x, y)
'            '                            ElseIf RedoL2(0, x) = RedoL2(0, y) Then
'            '                                If RedoL2(1, x) > RedoL2(1, y) Then
'            '                                    Call SwapSort(RedoL2(), x, y)
'            '                                ElseIf RedoL2(1, x) = RedoL2(1, y) Then
'            '                                    If RedoL2(2, x) > RedoL2(2, y) Then
'            '                                        Call SwapSort(RedoL2(), x, y)
'            '                                    End If
'            '                                End If
'            '                            End If
'            '                        Next y
'            '                    Next x
'                        End If
'                        For x = 1 To NumRedos
'
'                          Seq1 = RedoL2(0, x)
'                          Seq2 = RedoL2(1, x)
'                          Seq3 = RedoL2(2, x)
'                          ''22,245,285
'                          Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                        Next x
'
'                        For x = 0 To NextNo
'                            XXX = XXX + CurrentXOver(x) '7753
'                        Next x
'                        SS = abs(gettickcount)
'                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (100% of this cluster completed)"
'                        UpdateRecNums (SEventNumber)
'                        GlobalTimer = SS
'                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
'                        Call UpdateTimeCaps(SS, STartT)
'                        Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
'                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'
'                        DoEvents
'                    End If
'                End If
        '        XXX = 0
        '        For x = 0 To NextNo
        '            XXX = XXX + CurrentXOver(x) '7753
        '        Next x
        '        EEE = abs(gettickcount)
        '        ttt = EEE - ggg
                x = x
            End If
            If DoScans(0, 3) = 1 Then 'And x = 123456 Then
                
                '@'@'@'@'@
                'ReDim Preserve AList(2, ALC)
                'If x = x Then
                    'If DoScans(0, 3) = 1 Then
                    
                    'End If
                    
                    
                    ReDim RedoL3(ALC)
                    
                    StepsX = CLng(100000000 / Len(StrainSeq(0)))
                    UseCompress = 1
                    LT = GetTickCount
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@'@'@'@'@'@'@'@'@'@'@
                        'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                        'HWindowWidth = CLng(MCWinSize / 2)
                        'lHWindowWidth = HWindowWidth
                        'Do
                        NumRedos = AlistMC3(SEventNumber, Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, CLng(MCWinSize / 2), CLng(MCWinSize / 2), CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, SubThresh, LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                            'DoEvents
                        'Loop
                        'If NumRedos > 0 Then
                        '@'@
                        'Do
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then 'Or x = x Then
                                Seq1 = AList(0, x) '177, seventnnumber = 88
                                Seq2 = AList(1, x) '207
                                Seq3 = AList(2, x) '261
                                'ZZZ = ZZZ + 1
                                'CurrentTripListNum = x
                                ''22,245,285
                                NewOneFound = 0
                                'Call SetupMCArrays
                                'TotMCCycles = TotMCCycles + 1
'                                If Seq1 = 177 And Seq2 = 207 And Seq3 = 261 And SEventNumber = 88 Then
'                                    x = x
'                                End If
                                'Do
                                Call MCXoverF(FindAllFlagX, 0, 0)
                                'DoEvents
                                'Loop
'                                If NewOneFound > 0 And RedoL3(x) <= 0 Then
'
'                                    x = x
'                                End If
'                                If NewOneFound <= 0 And RedoL3(x) > 0 Then
'
                                    x = x
'                                End If
                                
                            End If
                        Next x
                        'End If
                        'DoEvents
                        'Loop
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            
                            If Y + StepsX - 1 <= ALC Then
                                If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(RestartPos(0) / oNextno * 600) / 10))) + "% of this cluster completed)"
                                
                                Else
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(SProg * 600) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 600)) / 10))) + "% of this cluster completed)"
                                End If
                                'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(((Y + StepsX - 1) / (ALC)) * 600 * PropP) / 10))) + "% of this cluster completed)"
                            Else
                               'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
                            End If
                            UpdateRecNums (SEventNumber)
                            GlobalTimer = ET
                            'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                            MethodTime(3) = MethodTime(3) + (ET - LT)
                            Call UpdateTimeCaps(ET, ET)
                            LT = ET
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            DoEvents
        
                        End If
                    Next Y
                    If (NumProgs > 1 And RestartPos(0) > 0) Then
                    Else
                        SProg = SProg + PropP
                    End If
                    UseCompress = 0
'
            End If
            If DoScans(0, 4) = 1 Then
                
                '@'@'@'@'@
                'ReDim Preserve AList(2, ALC)
                'If x = x Then
                    'If DoScans(0, 3) = 1 Then
                    
                    'End If
                    
                    XX = TripListLen
                    ReDim RedoL3(ALC)
                    
                    StepsX = CLng(100000000 / Len(StrainSeq(0)))
                    UseCompress = 1
                    LT = GetTickCount
                    For Y = 0 To ALC Step StepsX
                        If Y + StepsX - 1 > ALC Then
                            EPX = ALC
                        Else
                            EPX = Y + StepsX - 1
                        End If
                        '@'@'@'@'@'@'@'@'@'@'@'@'@'@
                        'NumRedos = AlistGC(GCIndelFlag, GCMissmatchPen, GCDimSize, AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(FSSGC, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), FSSGC(0, 0, 0, 0))
                        'HWindowWidth = CLng(MCWinSize / 2)
                        'lHWindowWidth = HWindowWidth
                        HWindowWidth = CLng(CWinSize / 2)
                        lHWindowWidth = HWindowWidth
                        'NumRedos = AlistMC3(SEventNumber,                  Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, HWindowWidth, lHWindowWidth, CriticalDiff, 0,             NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, CDbl(LowestProb / MCCorrection), LowestProb, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSMC, 2), FSSMC(0, 0, 0, 0), SeqNum(0, 0), MissingData(0, 0), Chimap(0), ChiTable2(0))
                        
                        NumRedos = AlistChi(SEventNumber, MissingData(0, 0), Worthwhilescan(0), Y, EPX, LongWindedFlag, ShortOutFlag, MaxABWin, CLng(CWinSize / 2), CLng(CWinSize / 2), CriticalDiff, FindAllFlagX, NextNo, UBound(StoreLPV, 1), StoreLPV(0, 0), AList(0, 0), ALC, RedoL3(0), CircularFlag, MCCorrection, MCFlag, SubThresh, LowestProb, CWinFract, CWinSize, CProportionFlag, Len(StrainSeq(0)), UBound(CompressSeq, 1), CompressSeq(0, 0), UBound(FSSRDP, 2), FSSRDP(0, 0, 0, 0), SeqNum(0, 0), Chimap(0), ChiTable2(0))
                        
                        '@'@
                        For x = Y To EPX
                            '1578,4229, 4348
                            
                            'CurrentTripListNum = x
                            If RedoL3(x) > 0 Then
                                If ProgBinRead(0, RedoL3(x)) = 1 Then
                                    
                                    Seq1 = AList(0, x) '0
                                    Seq2 = AList(1, x) '31
                                    Seq3 = AList(2, x) '83
                                    ZZZ = ZZZ + 1
                                    BQPV = 1
    '                                If Y = 4229 Then
    '                                    x = x
    '                                End If
                                    
                                    NewOneFound = 0
                                    Call CXoverA(FindAllFlagX, 0, 0)
    '                                If (NewOneFound = 0 And ProgBinRead(0, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(0, RedoL3(x)) = 0) Then
    '                                    x = x
    '                                End If
                                    
                                End If
                                If ProgBinRead(2, RedoL3(x)) = 1 Then
                                    
                                    Seq3 = AList(0, x) '5
                                    Seq1 = AList(1, x) '83
                                    Seq2 = AList(2, x) '104
                                    ZZZ = ZZZ + 1
                                    BQPV = 1
                                    NewOneFound = 0
                                    Call CXoverA(FindAllFlagX, 0, 0)
    '                                If (NewOneFound = 0 And ProgBinRead(2, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(2, RedoL3(x)) = 0) Then
    '                                    x = x
    '                                End If
                                End If
                                If ProgBinRead(4, RedoL3(x)) = 1 Then
                                    
                                    Seq2 = AList(0, x) '5
                                    Seq3 = AList(1, x) '83
                                    Seq1 = AList(2, x) '107
                                    ZZZ = ZZZ + 1
                                    BQPV = 1
                                    NewOneFound = 0
                                    Call CXoverA(FindAllFlagX, 0, 0)
    '                                If (NewOneFound = 0 And ProgBinRead(4, RedoL3(x)) = 1) Or (NewOneFound = 1 And ProgBinRead(4, RedoL3(x)) = 0) Then
    '                                    x = x
    '                                End If
                                End If
'                                If ProgBinRead(1, RedoL3(x)) = 1 Or ProgBinRead(3, RedoL3(x)) = 1 Or ProgBinRead(5, RedoL3(x)) = 1 Then
'                                    ZZZ = ZZZ + 1
'    '                                If ProgBinRead(4, Worthwhilescan(x)) = 0 Then
'    '                                    Worthwhilescan(x) = Worthwhilescan(x) + 5
'    '                                End If
'                                    Call AddToRedoList(4, AList(0, x), AList(1, x), AList(2, x))
'                                End If
                            End If
                            
                            
                        Next x
                        'End If
                        
                        ET = Abs(GetTickCount)
                        ET = Abs(ET)
                        If Abs(ET - LT) > 500 Then
                            
                            If Y + StepsX - 1 <= ALC Then
                                If ((PropP <= 0 Or SProg <= 0) And RestartPos(0) > 0) Or (NumProgs > 1 And RestartPos(0) > 0) Then
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(RestartPos(0) / oNextno * 600) / 10))) + "% of this cluster completed)"
                                
                                Else
                                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(SProg * 600) / 10 + CLng(((Y + StepsX - 1) / ALC) * (PropP * 600)) / 10))) + "% of this cluster completed)"
                                End If
                                'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(((Y + StepsX - 1) / (ALC)) * 600 * PropP) / 10))) + "% of this cluster completed)"
                            Else
                               'Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
                            End If
                            UpdateRecNums (SEventNumber)
                            GlobalTimer = ET
                            'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                            MethodTime(4) = MethodTime(4) + (ET - LT)
                            Call UpdateTimeCaps(ET, ET)
                            LT = ET
                            Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                            
                            DoEvents
        
                        End If
                    Next Y
                    If (NumProgs > 1 And RestartPos(0) > 0) Then
                    Else
                        SProg = SProg + PropP
                    End If
                    UseCompress = 0
'
            End If
        End If
        
        'Exit Do
    Loop
    
    If DoScans(0, 3) = 1 Then
        Call SetupMCArrays
    End If
     ZZZ = 0
    If DoScans(0, 2) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then 'Or DoScans(0, 3) = 1 Then   'Or DoScans(0, 3) = 1 Then
        For Seq1 = 0 To oNextno - 1
            If Seq1 <= UBPV2 And tMaskseq(Seq1) = 0 Then ' And BotherWith(Seq1) = 1 Then
                For Seq2 = Seq1 + 1 To oNextno
                    If Seq2 <= UBPV2 And tMaskseq(Seq2) = 0 Then
        '                 If Seq2 = 142 And Seq1 = 112 Then
        '                    x = x
        '                 End If
                        If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then 'And BotherWith(Seq2) = 1 Then
        '                    NN = 0
        '                    XX = (PermNextno - Nextno)
                            For Seq3 = oNextno + 1 To NextNo
                                
                                If tMaskseq(Seq3) = 0 Then 'And BotherWith(Seq3) = 1 Then
                                    'NN = NN + 1
                                    '@'@
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize And ((DP(Seq1, Seq3) + DP(Seq2, Seq3) > 0) Or (DP2(Seq1, Seq3) + DP2(Seq2, Seq3)) = 2) Then

                                        'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                 'XX = PermValid(225, 230)
'                                                If DoScans(0, 0) = 1 Then
'                                                     '@'@'@
''                                                     XX = CompressSeq(1, 0)
''                                                     XX = CompressSeq(500, 0)
''                                                     XX = CompressSeq(1, 1)
'                                                     'FRC = FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV)
''                                                     If frc = 1 Then
''                                                        x = x
''                                                     End If
'                                                     'FRC = 1
'                                                    If FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV) = 1 Then
'                                                        Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
'                                                    End If
'                                                End If
'                                                If DoScans(0, 1) = 1 Then
'                                                    Call GCXoverD(0)
'                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    
                                                    BQPV = 1
                                                    'GoOn = FastRecCheckMC(10, LongWindedFlag, BQPV, EarlyBale, SubThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, HWindowWidth, lHWindowWidth, MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), CriticalDiff, FindAllFlagX, UBound(FSSMC, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSMC(0, 0, 0, 0), SeqNum(0, 0), UBound(Winscores, 1), Scores(0, 0), Winscores(0, 0), XDiffPos(0), Chivals(0, 0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChi(0, 0))
                                                   ' If GoOn = 1 Then
                                                        NewOneFound = 0
                                                        'osen = SEventNumber
                                                        'SEventNumber = 0
                                                        'Call SetupMCArrays
'                                                        HWindowWidth = CLng(MCWinSize / 2)
'                                                        pHWindowWidth = HWindowWidth
'                                                        lHWindowWidth = HWindowWidth
'                                                        ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
'                                                        ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
'                                                        ReDim Chivals(Len(StrainSeq(0)), 2)
                                                        
                                                        'ReDim SmoothChi(Len(StrainSeq(0)), 2)
                                                        'ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'                                                        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'
'                                                        ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
                                                        'TotMCCycles2 = TotMCCycles2 + 1
                                                        Call MCXoverF(FindAllFlagX, 0, 0)
                                                        'SEventNumber = osen
'                                                    If GoOn = 0 And NewOneFound = 1 Then
'                                                        x = x
'                                                    End If
'                                                    If AList(0, ZZZ) <> Seq1 Or AList(1, ZZZ) <> Seq2 Or AList(2, ZZZ) <> Seq3 Then
'                                                        x = x
'                                                    End If
'                                                    If RedoL3(ZZZ) = 0 And NewOneFound = 1 Then
'                                                        x = x
'                                                    End If
'                                                    ZZZ = ZZZ + 1
                                                    'End If
                                                End If
'                                                If DoScans(0, 4) = 1 Then
'                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
'
'                                                    Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
'
'                                                    Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
'
'                                                    Call CXoverA(FindAllFlagX, 0, 0)
'
'                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
'                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                '@
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                
                                            'End If
                                        'End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                    x = x
                Next Seq2
            End If
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    '@
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng(250 + ((Seq1 / (oNextno + 1)) * 750)) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        Next Seq1
        
        
   End If
   ess = Abs(GetTickCount)
   TotASET = TotASET + Abs(ess - tSS)
   
End If
'If TotMCCycles2 <> TotMCCycles Then
'    x = x
'End If
If DoScans(0, 3) = 1 Then
    Call SetupMCArrays
End If
'EE = abs(gettickcount)
'TT = EE - SSSss
'TotFGCT = TotFGCT + TT
'Form1.Caption = TotFGCT



DontWorryAboutSplitsFlag = oDWS
Dim NumNew
NumNew = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        NumNew = NumNew + 1
'        XX = XoverList(x, Y).Daughter '7
'        XX = XoverList(x, Y).MajorP '15
'        XX = XoverList(x, Y).MinorP '9
        'XoverList(x, Y).BeginP = -100
        If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
        ElseIf XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        'XX = XoverList(x, Y).EndP '0
        End If
    Next Y
Next x
XX = CurDir
'Open "resultslist2.csv" For Append As #48
'For x = 0 To NextNo
'    For Y = 1 To CurrentXOver(x)
'        Print #48, Str(XoverList(x, Y).Daughter) + "," + Str(XoverList(x, Y).MajorP) + "," + Str(XoverList(x, Y).MinorP) + "," + Str(XoverList(x, Y).Daughter) + ","
'    Next Y
'Next x
'Close #48
'For x = 0 To Nextno
'    If ActualSeqSize(x) = 0 Then
'        x = x
'    End If
'Next x
UseCompress = 0

SS = Abs(GetTickCount)
If Abs(SS - LS) > 500 Then
    LS = SS
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined"
    DoEvents
End If
For x = 0 To AddNum - 1
    MethodTime(x) = MethodTime(x) + Abs(SS - STartT) * TimeFract(x)
Next x
CurSeedExtras = CurSeed
If AbortFlag = 1 Then
    StepNo = FirstStepNo
    Exit Sub
End If
If NumNew = 0 Then
    x = x
    StepNo = FirstStepNo 'StepNo - 1
    GoTo Redo
Else
    x = x
End If

End Sub
Public Sub AddSomeExcludesC(TraceSub() As Long, MinSeqSize, NextNo As Long, SeqNum() As Integer, ActualSeqSize() As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno, MissingData() As Byte, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer)

Dim AList() As Integer, FirstStepNo As Long, SSN As Long, OSN As Long, CurSeed As Long, BoundsMD() As Long, NumMD As Long, Y As Long, Y1 As Long, Y2 As Long, oNextno As Long, UB As Long, Z As Long, x As Long, oDirX As String, Pos As Long, FF As Long, EListNum As Long, TELong As Long, TEString As String
Dim UB1 As Long, UB2 As Long, g As Long

FirstStepNo = StepNo


Dim STartT As Variant
STartT = Abs(GetTickCount)


Redo:
'For x = PermNextno To Nextno
Steps(0, StepNo) = 6 'this erases all sequences with numbers above permnextno by resetting nextno to permnextno
Steps(4, StepNo) = SEventNumber + 1
StepNo = StepNo + 1
UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

'This is test code to see whether restoring seqnum and missingdata outside of this exclude
'group will reveal more hidden signals
Dim RedoAllDists As Long
RedoAllDists = 0
If x = x Then
    'reset seqnum and modseqnum to state of first addsomeexcludes
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SMDrop" + UFTag For Binary As #FF
    If FirstAddSome = 0 Then
        FirstAddSome = 1
        UB1 = UBound(SeqNum, 1)
        UB2 = UBound(SeqNum, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , SeqNum()
        UB1 = UBound(MissingData, 1)
        UB2 = UBound(MissingData, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , MissingData()
        
        
    Else
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim SeqNum(UB1, UB2)
        Get #FF, , SeqNum()
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim MissingData(UB1, UB2)
        Get #FF, , MissingData()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    RedoAllDists = 1
ElseIf x = 123456 Then
 
    RedoAllDists = 1
    'Dim tSeqNum() As Integer
    'ReDim tSeqNum(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
        Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
    End If
    ReDim MissingData(Len(StrainSeq(0)), PermNextno + 1)
    'now add missingdata and indels back to the seed sequence
    For x = 0 To PermNextno
        If DoneExcludes(x) = 0 Then
            If x <= UBound(ExcludeCoords) Then
                If ExcludeCoords(x) > 0 Then
                    CurSeed = x
                    Exit For
                End If
            End If
        End If
    Next x
    If x = x Then 'edit the anchor sequence
        For x = 1 To StepNo - 1
            If Steps(0, x) = 2 Then
                If Steps(1, x) = CurSeed Then
                    Dummy = ModSeqNumE(PermNextno, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
                    'tRedoDist(Steps(1, x)) = 1
                End If
            End If
        Next x
    End If
End If





UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

NextNo = PermNextno
'Next x
BusyWithExcludes = 1


ReDim BoundsMD(Len(StrainSeq(0)), 1)
NumMD = 0
Dim GoOn As Byte
'erase any sequences >permenxtno


NextNo = PermNextno
oNextno = NextNo
Dim SSBak() As Long
ReDim SSBak(Len(StrainSeq(0)))
GoOn = 0
Dim EPosX As Long, BreakB As Long, BreakE As Long, DSX As Long


SS = Abs(GetTickCount)
Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (2% of this cluster completed)"
UpdateRecNums (SEventNumber)
GlobalTimer = SS
'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
Call UpdateTimeCaps(SS, STartT)
Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

DoEvents

For x = 0 To PermNextno
'     If x = 97 Then
'            x = x
'        End If
    If DoneExcludes(x) = 0 And MaskSeq(x) = 0 Then
       
        If x <= UBound(ExcludeCoords) Then
            If ExcludeCoords(x) > 0 Then
'                Open "progress.txt" For Append As #20
'                Print #20, SEventNumber, "exrras", x
'                Close #20
                'establish boundaries of missing data in sequence X
                CurSeed = x
                
                For Y1 = 0 To Len(StrainSeq(0))
                    If MissingData(Y1, x) = 1 Then
                        For Y2 = Y1 + 1 To Len(StrainSeq(0))
                            If MissingData(Y2, x) = 0 Then
                                Y2 = Y2 - 1
                                Exit For
                            End If
                        Next Y2
                        BoundsMD(NumMD, 0) = Y1
                        BoundsMD(NumMD, 1) = Y2
                        NumMD = NumMD + 1
                        Y1 = Y2
                    End If
                Next Y1
                Pos = ExcludeCoords(x)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                Get #FF, Pos, EListNum
                'now add these elistnnum sequences to the alignment and record the edits in the steps array
                ReDim OSNPos(NextNo + EListNum)
                
                For Z = 1 To EListNum
                    GoOn = 1
                    NextNo = NextNo + 1
                    If NextNo > UBound(GrpMaskSeq, 1) Or NextNo > UBound(OriginalName, 1) Or NextNo > UBound(TraceSub, 1) Or NextNo > UBound(MaskSeq, 1) Then
                        ReDim Preserve TraceSub(NextNo + 50), OriginalName(NextNo + 50), StraiName(NextNo + 50), MaskSeq(NextNo + 50)
                        ReDim Preserve GrpMaskSeq(NextNo + 50)
                    End If
                    If NextNo > UBound(OriginalPos, 1) Then
                        ReDim Preserve OriginalPos(NextNo + 50)
                    End If
                    TraceSub(NextNo) = x
                    
                    MaskSeq(NextNo) = 0
                    EPosX = Seek(FF) 'remember the position of this specific sequence
                    Get #FF, , SSN 'Original number of the sequence that this unexcluded sequence this sequence is most similar to
                    Get #FF, , OSN 'original seq number
'                    If OSN = 6709 Then
'                        x = x
'                        '258
'                        For BBx = 0 To NextnoBak
'                            If OriginalPos(BBx) = 4541 Then
'                                x = x
'                            End If
'                        Next BBx
'                    End If
                    OSNPos(NextNo) = OSN
                    Get #FF, , TELong 'discard number
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'originalname
                    XX = SEventNumber
                    OriginalName(NextNo) = TEString
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString
                    StraiName(NextNo) = TEString 'strainame
                    Get #FF, , TELong 'seqeunec length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'sequence
                    'XX = SEventNumber
                    
                    If UBound(SeqNum, 2) < NextNo Then
                        ReDim Preserve SeqNum(UBound(SeqNum, 1), NextNo + 10)
                    End If
                    'copy the sequence into the nextno slot
                    
                    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                    'there is sequence compression and the loaded sequence needs to be modified accordingly
                       TEString = CompressTEString(Decompress(), TEString)
                    End If
                    
                    Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), TEString, SSBak(0))
                    ReDim Preserve StrainSeq(NextNo)
                    StrainSeq(NextNo) = TEString
                    'this is the original sequence that gets copied into seqnum so it must be edited to account for
                    'all recombination event that were previously inferred for this sequence
                    Steps(0, StepNo) = 1 'ie create a new sequence ....
'                    If x = 159 Then
'                        x = x
'                    End If
                    Steps(1, StepNo) = x 'using this seqence as the source of the current exclude
                    Steps(2, StepNo) = -EPosX 'the specific excluded sequence (the negative will indicate to modseqnum that the additional sequence is from the excludelist
                    Steps(3, StepNo) = 0 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                    'XX = UBound(SeqNum, 1)
                    If NextNo > UBound(MissingData, 2) Then
                        ReDim Preserve MissingData(UBound(MissingData, 1), NextNo)
                    End If
'                    If SEventNumber = 9 Then
'                        x = x
'                    End If
                    '@
                    For Y1 = 1 To Len(StrainSeq(0))
                        MissingData(Y1, NextNo) = 0
                    Next Y1
                    'For G = 0 To ExcludedEventNum
                    
                    '    If EventsInExcludeds(3, G) = CurSeed Then
                            For Y = 0 To NumMD - 1
                                If BoundsMD(Y, 1) > Len(StrainSeq(0)) Then BoundsMD(Y, 1) = Len(StrainSeq(0))
                                If BoundsMD(Y, 0) > Len(StrainSeq(0)) Then BoundsMD(Y, 0) = Len(StrainSeq(0))
                                
                                For Y1 = BoundsMD(Y, 0) To BoundsMD(Y, 1)
                                    SeqNum(Y1, NextNo) = 46
                                    MissingData(Y1, NextNo) = 1
                                Next Y1
                                
                                Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                                Steps(1, StepNo) = NextNo  'from this seqence.....
                                Steps(2, StepNo) = BoundsMD(Y, 0) 'from this position....
                                Steps(3, StepNo) = BoundsMD(Y, 1) 'to this position....
                                Steps(4, StepNo) = SEventNumber + 1
                               
                                StepNo = StepNo + 1
                                
                                UB = UBound(Steps, 2)
                                If StepNo > UB Then
                                    ReDim Preserve Steps(4, UB + 100)
                                End If
                            
                            Next Y
                        'End If
                    'Next G
                    
                    
                Next Z
                Close #FF
                '@
                ChDrive oDirX
                ChDir oDirX
                '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                'This could be a rescan
                'Need to check the the already accepted events in bestxolist to see if any of the
                'current batch of added in excludes contain sequences in that list
                'basically I need to search bestxolist for matches to the seed sequence where the .beginp property is <0
                'I then simply check if the .daughter is >permnextno and, if so,
                'add in an edit to that sequence and record the edit in steps
                ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                For Y = 1 To BCurrentXOver(CurSeed)
                    If BestXOList(CurSeed, Y).BeginP < 0 Then
                        If BestXOList(CurSeed, Y).Daughter > PermNextno Then
                             DSX = BestXOList(CurSeed, Y).Daughter
                             BreakB = BestXOList(CurSeed, Y).Beginning
                             BreakE = BestXOList(CurSeed, Y).Ending
                             Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                             Steps(1, StepNo) = DSX  'from this seqence.....
                             Steps(2, StepNo) = BreakB 'from this position....
                             Steps(3, StepNo) = BreakE 'to this position....
                             Steps(4, StepNo) = SEventNumber + 1
                            
                             StepNo = StepNo + 1
                             
                             UB = UBound(Steps, 2)
                             If StepNo > UB Then
                                 ReDim Preserve Steps(4, UB + 100)
                             End If
                             
                             If BreakB < BreakE Then
                                For Z = BreakB To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             Else
                                For Z = BreakB To Len(StrainSeq(0))
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                                For Z = 1 To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             
                             End If
                             
                        End If
                    End If
                Next Y
                
                
                
                DoneExcludes(x) = 1
                Exit For
            
            End If
            
           
        End If
    End If
Next x
If GoOn = 0 Then
    DoExcludes = 0
    
    Exit Sub
End If

ReDim CurrentXOver(NextNo), XoverList(NextNo, XOverListSize), MaxXOP(AddNum - 1, NextNo)
Call ResetMaxPVCO(NextNo)
SS = Abs(GetTickCount)
Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (3% of this cluster completed)"
GlobalTimer = SS
'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
Call UpdateTimeCaps(SS, STartT)
Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

DoEvents

'Dummy = MakeActualSeqSize(Len(StrainSeq(0)), Nextno, WinPP, RNum(0), RList(0, 0), ActualSeqSize(0), SeqNum(0, 0))
ReDim Preserve ActualSeqSize(NextNo)
For x = oNextno + 1 To NextNo
    ActualSeqSize(x) = 0
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 46 Then ActualSeqSize(x) = ActualSeqSize(x) + 1
    Next Y
Next x
'XX = Nextno
'XX = ActualSeqSize(53)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'need to mimic everything in dordp up to the innerscan call
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


If QvRFlag = 1 Then
    ReDim Preserve ReferenceList(NextNo)
End If
'Update the treedistance used for RDP and SiScan
ReDim TreeDistance(NextNo, NextNo)



Dim TDiffs() As Single, TValid() As Single, Uninvolved() As Long
ReDim Uninvolved(NextNo)
For x = 0 To NextNo
    Uninvolved(x) = 1
Next x


If PermNextno > MemPoc Then
    
    GetPermDiffs
'    XX = ActualSeqSize(3)
'    XX = Uninvolved(3)
    ReDim TDiffs(NextNo, NextNo)
    
    Dummy = MakeTDiffs2(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), PermDIffs(0, 0), Uninvolved(0), ActualSeqSize(0))
   
'    XX = TDiffs(3, 1)
'    XX = TDiffs(0, 1)
'    XX = PermDiffs(3, 1)
    ReDim PermDIffs(0, 0)
    
    GetPermValid
    
    'XX = PermValid(0, 1)
'    XX = Uninvolved(0)
'    XX = Uninvolved(1)
    ReDim TValid(NextNo, NextNo)
    
    Dummy = MakeTDiffs3(NextNo, UBound(PermValid, 1), TValid(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
    
'    XX = TValid(1, 0)
'    XX = PermValid(0, 1)
    ReDim PermValid(0, 0)
Else
    ReDim TDiffs(NextNo, NextNo), TValid(NextNo, NextNo)
     
    Dummy = MakeTDiffs(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), TValid(0, 0), PermDIffs(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
'XX = oNextno
End If

'XX = TValid(0, 1)
ReDim Distance(NextNo, NextNo)
AvDst = 0
Dim tRedoDist() As Integer, Invert(1) As Byte
Invert(0) = 1
Invert(1) = 0
ReDim tRedoDist(NextNo)
If RedoAllDists = 0 Then
    For x = oNextno + 1 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
Else
    For x = 0 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
End If
    
Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, TDiffs(), TValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
    
ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo)
Dummy = FinishDists2(NextNo, PermValid(0, 0), PermDIffs(0, 0), TValid(0, 0), TDiffs(0, 0), Distance(0, 0))


If PermNextno > MemPoc And x = 1234567 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    UBDistance = UBound(Distance, 1)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Put #FF, , Distance()
    Close #FF
    DistanceInFileFlag = 1
    ReDim Distance(0, 0)
    ChDir oDir
    ChDrive oDir
End If
    

If PermNextno > MemPoc Then
    Call PutPermValid
    Call PutPermDiffs
    'ReDim PermDiffs(0, 0)
    'ReDim PermValid(0, 0)
End If


Erase TDiffs
Erase TValid

DistanceFlag = 1
TreeDistFlag = 0

Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
'XX = TreeDistance(1, 0)
DoEvents

Dim DP() As Byte
ReDim DP(NextNo, NextNo)
If x = 123456 Then
'    For x = 0 To Nextno
'
'    For Y = 0 To Nextno
'        If TreeDistance(x, Y) <> 0 Then
'            x = x
'        End If
'
'    Next Y
'
'    Next x
    'find a phylogenetically representative selection of sequences in the includes that must be compared with the excludes in the
    'last recombination screen loops at the end - these are specified with the DP arrays
    Dim Seq1List() As Long, TV As Single, SL As Long, Longest As Long, DS() As Byte
    ReDim Seq1List(NextNo), DS(NextNo)
    SL = -1
    Seq1List(0) = CurSeed
    DS(CurSeed) = 1
    For x = 0 To oNextno - 1
        If DS(x) = 0 Then
            DS(x) = 1
            SL = SL + 1
            Longest = ActualSeqSize(x)
            Seq1List(SL) = x
            TV = TreeDistance(CurSeed, x)
            For Y = x + 1 To oNextno
                If DS(Y) = 0 Then
                    If TreeDistance(CurSeed, Y) = TV Then
                        DS(Y) = 1
                        If Longest < ActualSeqSize(Y) Then
                            Longest = ActualSeqSize(Y)
                            Seq1List(SL) = Y
                        End If
                    End If
                End If
            Next Y
        End If
        
    Next x
    For x = 0 To SL
        For Y = oNextno + 1 To NextNo
            DP(Seq1List(x), Y) = 1
            DP(Y, Seq1List(x)) = 1
        Next Y
    Next x
'    For x = 0 To oNextno
'        For Y = oNextno + 1 To Nextno
'            DP(x, Y) = 1
'            DP(Y, x) = 1
'        Next Y
'    Next x
End If
If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        
    End If
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        Erase TreeX
    End If
    ChDrive oDirX
    ChDir oDirX
End If

Dim tMaskseq() As Byte
ReDim tMaskseq(NextNo)

If MaskThresh = 0 Then
    Dim Correx, AA
    AA = x
    
    Correx = MCCorrection * (Len(StrainSeq(0)) / XOverWindowX)
    
    'If LowestProb = 0 Then LowestProb = 0.05
    Correx = LowestProb / Correx
    Correx = 1 / Correx
    Correx = Log(Correx) / Log(4)
 'XX = (2 * Log(4 * X))
    'Y = (2 * Log(4 * X)) / Len(StrainSeq(0))
     MaskThresh = Correx / Len(StrainSeq(0))
     MaskThresh = MaskThresh / 3
End If

If MaskThresh > 0 Then
    'mask sequences that are almost identical
    For x = 0 To PermNextno
        tMaskseq(x) = MaskSeq(x)
    Next x
    For x = oNextno To NextNo
        If ((1 - Distance(x, CurSeed)) < MaskThresh) Then
            tMaskseq(x) = 1
        Else
            If tMaskseq(x) = 0 Then
                For Y = x + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        If ((1 - Distance(x, Y)) < MaskThresh) Then
                            If ActualSeqSize(x) < ActualSeqSize(Y) Then
                                tMaskseq(x) = 1
                            
                            Else
                                tMaskseq(Y) = 1
                            End If
                            x = oNextno - 1
                            Exit For
                        End If
                    End If
                Next Y
            End If
        End If
    Next x
End If


SSSss = Abs(GetTickCount)
UseCompress = 1
Call MakeScanCompressArrays(NextNo, SeqNum())
EE = Abs(GetTickCount)
TT = EE - SSSss
'first scan all the excludes against one another and one of the includes
Dim SP As Long, oDWS As Byte
oDWS = DontWorryAboutSplitsFlag
DontWorryAboutSplitsFlag = 1


If DoScans(0, 0) = 1 Then
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Prefilter which pairs of includes to bother with here using the fastrecchecks and a very high p-val cutoff to look for
'instances where, curseed and one of the excludes when scanned against one of the includes yields even a very marginally significant p-value.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'UCThresh = 1
Dim BotherWith() As Byte, AtLeastOne As Byte
ReDim BotherWith(NextNo)

LowestProb = pLowestProb
'If CurSeed = 6 Then
'    x = x
'End If
If x = 12345 Then
    
        'Make a seq1 list that samples the logest sequence off every branch below curseed
        
        
        UCThresh = LowestProb / (MCCorrection / 10000)
        If UCThresh > 0.05 Then UCThresh = 0.05
        AtLeastOne = 0
        EarlyBale = 1
'        For x = 0 To oNextno
'            BotherWith(x) = 1
'        Next x
        
        Seq1 = CurSeed
'        For x = 0 To SL
'            Seq1 = Seq1List(x)
            For Seq2 = 0 To oNextno
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = oNextno + 1 To NextNo
                            If Seq1 <> Seq2 And tMaskseq(Seq3) = 0 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
                                            
                                            For x = oNextno + 1 To NextNo
                                                DP(x, Seq2) = 1
                                                DP(Seq2, x) = 1
                                            Next x
                                            
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            Exit For
                                        End If
                                    End If
                                End If
                            End If
                        Next Seq3
                    End If
                
            Next Seq2
             For Seq2 = oNextno + 1 To NextNo - 1
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = Seq2 + 1 To NextNo
                            'If Seq1 <> Seq3 And Seq2 <> Seq3 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize And tMaskseq(Seq3) = 0 Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
'                                            If x <= oNextno And BotherWith(Seq3) = 0 Then
'                                                For x = oNextno + 1 To Nextno
'                                                    DP(x, Seq3) = 1
'                                                    DP(Seq3, x) = 1
'                                                Next x
'                                            End If
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            'Exit For
                                        End If
                                    End If
                                End If
                            'End If
                        Next Seq3
                    End If
                
            Next Seq2
        'Next x
        EarlyBale = 0
        For x = oNextno + 1 To NextNo
            DP(CurSeed, x) = 1
            DP(x, CurSeed) = 1
        Next x
        

Else
    AtLeastOne = 1
    For x = oNextno + 1 To NextNo
        BotherWith(x) = 1
    Next x
End If


'XX = Nextno - oNextno

'AtLeastOne = 1
'For x = 0 To Nextno
'   BotherWith(x) = 1
'Next x

Dim FRC As Long
SS = Abs(GetTickCount)
Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (10% of this cluster completed)"
GlobalTimer = SS
'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
Call UpdateTimeCaps(SS, STartT)
Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

DoEvents

SSSss = Abs(GetTickCount)
If x = x Then
    Dim TP() As Byte
        ReDim DP(NextNo, NextNo), TP(NextNo, NextNo)
        For x = 0 To NextNo
            If tMaskseq(x) = 0 Then
                For Y = oNextno + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        TP(x, Y) = 1
                        'TP(Y, X) = 1
                    End If
                Next Y
            End If
        Next x
       ' Call FastRecCheckGC(Nextno, (LowestProb / (oNextno * (Nextno - oNextno))) * 10000, DP(), SeqNum(), TP(), tMaskseq())
        Call FastRecCheckGC(NextNo, 0.05, DP(), SeqNum(), TP(), tMaskseq())
        'Dim VarSites() As Long
        'ReDim VarSites(Len(StrainSeq(0)))
    Dim SubThresh As Double
    SubThresh = (LowestProb / MCCorrection) * 100
    
    Dim NumRedos As Long, RedoL() As Long
    ReDim RedoL(2, oNextno * (NextNo - oNextno + 1) * (NextNo - oNextno + 1) / 2)
    Dim RedoL2() As Long
    Dim DP2() As Byte ', DP3() As Byte
    ReDim DP2(NextNo, NextNo) ', DP3(NextNo, NextNo)
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            DP2(x, Y) = DP2(x, Y)
'        Next Y
'    Next x
    XX = CurSeed
'    XX = PermValid(22, 245)
'    XX = PermValid(22, 285)
'    XX = PermValid(245, 285)
    
'    If CurSeed > 7 Then
'        StepNo = FirstStepNo 'StepNo - 1
'        GoTo Redo
'    End If
    
    
    
'SSSS = abs(gettickcount)
'For Z = 0 To 10
'        ReDim XoverList(NextNo, 20)
'        ReDim CurrentXOver(NextNo)
   
   SS = Abs(GetTickCount)
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (10% of this cluster completed)"
    UpdateRecNums (SEventNumber)
    GlobalTimer = SS
    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    
   Dim UBPV2 As Long
    UBPV2 = UBound(PermValid, 2)
    
    
    'Make ALIst
    Dim BAL As Variant, ALC As Long
    BAL = ((NextNo - oNextno + 1) * (NextNo - oNextno + 1)) / 2
    BAL = BAL * oNextno + 1
    ReDim AList(2, BAL)
    Dim RestartPos() As Long
    ReDim RestartPos(2)
    
    If x = x Then
        ALC = MakeAListASEF(BAL, RestartPos(0), oNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DP, 1), DP(0, 0), tMaskseq(0), UBound(PermValid, 1), PermValid(0, 0), PermDIffs(0, 0))
    Else
        ALC = -1
        For Seq1 = 0 To oNextno '0 To oNextno
             If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
                
                 For Seq2 = oNextno + 1 To NextNo - 1
                         If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
                             If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
                                 For Seq3 = Seq2 + 1 To NextNo
                                     If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 And (DP(Seq3, Seq2) + DP(Seq3, Seq1) + DP(Seq2, Seq1) > 0) Then
                                         If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                             If PermDIffs(Seq2, Seq3) > 2 Then
                                                 ALC = ALC + 1
                                                 AList(0, ALC) = Seq1
                                                 AList(1, ALC) = Seq2
                                                 AList(2, ALC) = Seq3
                                             End If
                                         End If
                                     End If
                                 Next Seq3
                             End If
                         End If
                 Next Seq2
             End If
         
         Next Seq1
   End If
   DoEvents
   Dim RedoL3() As Byte, EPX As Long
   Dim StepsX As Long, A As Long, b As Long, C As Long
   If DoScans(0, 0) = 1 Then
        
        If x = x Then
            UseCompress = 1
            Dim Teams() As Integer, Members() As Integer
            Call MakeTeams(0, PermNextno, NextNo, TreeDistance, Distance, ActualSeqSize(), Teams(), Members())
            If x = x And ALC > -1 Then
                
                
                
                ReDim RedoL3(ALC)
                
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                
                For x = 0 To NextNo
                    If Members(x) < 0 Then
                        tMaskseq(x) = 1
                    Else
                        tMaskseq(x) = 0
                    End If
                Next x
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@
                    NumRedos = AEFirstAlistRDP3(UBound(DP2), DP2(0, 0), AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                    'If NumRedos > 0 Then
                    If x = x Then
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                For A = 0 To Members(AList(0, x))
                                    Seq1 = Teams(AList(0, x), A)
                                    For b = 0 To Members(AList(1, x))
                                        Seq2 = Teams(AList(1, x), b)
                                        For C = 0 To Members(AList(2, x))
                                            Seq3 = Teams(AList(2, x), C)
                                ''22,245,285
                                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                        Next C
                                    Next b
                                Next A
                            End If
                        Next x
                    Else
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                ''22,245,285
                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                        
                            End If
                        Next x
                    
                    
                    End If
                    'End If
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        LT = ET
                        If Y + StepsX - 1 <= ALC Then
                            Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((10 + CLng(((Y + StepsX - 1) / ALC) * 250) / 10))) + "% of this cluster completed)"
                        Else
                           Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (35% of this cluster completed)"
                        End If
                        UpdateRecNums (SEventNumber)
                        GlobalTimer = ET
                        
                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                        Call UpdateTimeCaps(ET, STartT)
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        DoEvents
                        x = x
                    End If
                Next Y
                UseCompress = 0
            Else
            '@'@
                ReDim RedoL(2, ((oNextno * (oNextno + 1)) / 2) * (NextNo - oNextno + 1))
                NumRedos = AEFirstRDP3(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDIffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                If NumRedos > 0 Then
                    If x = x Then 'reorder redos
                        'sort seq 1
                        SSS = Abs(GetTickCount)
                        Dim S1Count() As Long, CurS1 As Long, SPS1() As Long
                        ReDim S1Count(oNextno), SPS1(oNextno)
                        For x = 1 To NumRedos
                            CurS1 = RedoL(0, x)
                            S1Count(CurS1) = S1Count(CurS1) + 1
                        Next x
                        SPS1(0) = S1Count(0)
                        For x = 1 To oNextno
                            SPS1(x) = SPS1(x - 1) + S1Count(x)
                        Next x
                        ReDim RedoL2(2, NumRedos)
                        Dim L2Pos As Long
                        For x = NumRedos To 0 Step -1
                            L2Pos = SPS1(RedoL(0, x))
                            RedoL2(0, L2Pos) = RedoL(0, x)
                            RedoL2(1, L2Pos) = RedoL(1, x)
                            RedoL2(2, L2Pos) = RedoL(2, x)
                            SPS1(RedoL(0, x)) = SPS1(RedoL(0, x)) - 1
                        Next x
    '                    XX = SPS1(4)
    '                    XX = S1Count(4)
    '                    SSS = abs(gettickcount)
    '                    For x = 0 To NumRedos
    '                        For y = x + 1 To NumRedos
    '                            If RedoL2(0, x) > RedoL2(0, y) Then
    '                                Call SwapSort(RedoL2(), x, y)
    '                            ElseIf RedoL2(0, x) = RedoL2(0, y) Then
    '                                If RedoL2(1, x) > RedoL2(1, y) Then
    '                                    Call SwapSort(RedoL2(), x, y)
    '                                ElseIf RedoL2(1, x) = RedoL2(1, y) Then
    '                                    If RedoL2(2, x) > RedoL2(2, y) Then
    '                                        Call SwapSort(RedoL2(), x, y)
    '                                    End If
    '                                End If
    '                            End If
    '                        Next y
    '                    Next x
                    End If
                    For x = 1 To NumRedos
                    
                      Seq1 = RedoL2(0, x)
                      Seq2 = RedoL2(1, x)
                      Seq3 = RedoL2(2, x)
                      ''22,245,285
                      Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                    Next x
                    SS = Abs(GetTickCount)
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (35% of this cluster completed)"
                    UpdateRecNums (SEventNumber)
                    GlobalTimer = SS
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(SS, STartT)
                    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    
                    DoEvents
                End If
            End If
        
        Else
            For Seq1 = 0 To oNextno '0 To oNextno
            'if I let other sequences in besides curseed here it is very difficult to properly group recombinants
            'Also, The way it was it was possible to get all three signal sequences from this exclude list cluster.
    '            If Seq1 = 22 Then
    '                x = x
    '            End If
                
                
                NumRedos = AEFirstRDP(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDIffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                'NumRedos = AEFirstRDP2(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDiffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                
            
                
                If NumRedos > 0 Then
                    For x = 1 To NumRedos
                      Seq2 = RedoL(1, x)
                      Seq3 = RedoL(2, x)
                      ''22,245,285
                      Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                    Next x
                End If
            
                SS = Abs(GetTickCount)
                If Abs(SS - GlobalTimer) > 500 Then
                    GlobalTimer = SS
                    'If Seq1 >= oNextno Then
                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
                    'End If
                    DoEvents
                    If AbortFlag = 1 Then
                        Seq1 = NextNo
                        Seq2 = NextNo
                        Seq3 = NextNo
                    End If
                    UpdateRecNums (SEventNumber)
                    GlobalTimer = SS
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(SS, STartT)
                    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                    
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    If AbortFlag = 1 Then
                        Exit For
                    End If
                End If
            Next Seq1
        End If
        
        

        x = x
   End If
   If DoScans(0, 1) = 1 Or DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then
        
         For Seq1 = 0 To oNextno '0 To oNextno
            If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
               
                For Seq2 = oNextno + 1 To NextNo - 1
                    'If BotherWith(Seq2) = 1 Or x = x Then
                        If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
                            If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
                                For Seq3 = Seq2 + 1 To NextNo
        '                            If Seq2 = 258 Or Seq3 = 258 Then
        '                                x = x
        '                            End If
                                    If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 And (DP(Seq3, Seq2) + DP(Seq3, Seq1) + DP(Seq2, Seq1) > 0) Then
                                        If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                            If PermDIffs(Seq2, Seq3) > 2 Then
                                                'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                    NewOneFound = 0
                                                    If DoScans(0, 0) = 1 Then
                                                                    
                                                        'Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                        'FRC = FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV)
                                                        'FRC = 1
                                                        BQPV = 0
                                                        '22,245,285
'                                                        If Seq1 = 22 And Seq2 = 245 And Seq3 = 285 Then
'                                                            x = x
'                                                            Seq1 = 22: Seq2 = 245: Seq3 = 285
'                                                        End If
                                                        If FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV) = 1 Then
                                                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                           ' x = x
                                                        Else
                                                            If BQPV > 0 Then
                                                               If BQPV < SubThresh Then
                                                                    NewOneFound = 1
                                                               End If
                                                            End If
                                                            
                                                        End If
                                                    End If
                                                    If DoScans(0, 1) = 1 Then
                                                        Call GCXoverD(0)
                                                    End If
                                                    If DoScans(0, 2) = 1 Then
                                                        Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                    End If
                                                    If DoScans(0, 3) = 1 Then
                                                        GoOn = FastRecCheckMC(10, LongWindedFlag, BQPV, EarlyBale, UCThresh, MCFlag, ShortOutFlag, MCCorrection, LowestProb, CircularFlag, NextNo, MaxABWin, CLng(MCWinSize / 2), CLng(MCWinSize / 2), MCWinFract, MCWinSize, MCProportionFlag, Len(StrainSeq(0)), CriticalDiff, 0, UBound(FSSMC, 2), UBound(CompressSeq, 1), Seq1, Seq2, Seq3, CompressSeq(0, 0), FSSMC(0, 0, 0, 0), SeqNum(0, 0), UBound(Winscores, 1), Scores(0, 0), Winscores(0, 0), XDiffPos(0), Chivals(0, 0), BanWin(0), MDMap(0), ChiTable2(0), Chimap(0), mtP(0), SmoothChi(0, 0))
                                                        If GoOn = 1 Then
                                                            Call MCXoverF(0, 0, 0)
                                                        End If
                                                    End If
                                                    If DoScans(0, 4) = 1 Then
                                                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                    
                                                        Call CXoverA(0, 0, 0)
                                                                                    
                                                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                    
                                                        Call CXoverA(0, 0, 0)
                                                                                    
                                                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                    
                                                        Call CXoverA(0, 0, 0)
                                                                                    
                                                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                    End If
                                                    
                                                    If DoScans(0, 5) = 1 Then
                                                        oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                        Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                        Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                    End If
                                                    
                                                    
                                                    If DoScans(0, 8) = 1 Then
                                                                                         
                                                        tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                            
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                
                                                        Call TSXOver(0)
                                                                
                                                        Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                    End If
                                                    '22,245,285
                                                    If NewOneFound = 1 Then
                                                        DP2(Seq3, Seq1) = 1
                                                        DP2(Seq1, Seq3) = 1
                                                        DP2(Seq2, Seq1) = 1
                                                        DP2(Seq1, Seq2) = 1
                                                    End If
                                                'End If
                                            End If
                                        End If
                                    End If
                                Next Seq3
                            End If
                        End If
                    'End If
                Next Seq2
                'XX = DP(1, 228)
                SS = Abs(GetTickCount)
                If Abs(SS - GlobalTimer) > 500 Then
                    GlobalTimer = SS
                    'If Seq1 >= oNextno Then
                        Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
                    'End If
                    DoEvents
                    If AbortFlag = 1 Then
                        Seq1 = NextNo
                        Seq2 = NextNo
                        Seq3 = NextNo
                    End If
                    UpdateRecNums (SEventNumber)
                    GlobalTimer = SS
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(SS, STartT)
                    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                    
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    If AbortFlag = 1 Then
                        Exit For
                    End If
                End If
            End If
        
        Next Seq1
   End If

'Next Z
'eeee = abs(gettickcount)
'tttt = eeee - SSSS '5.188, 6.125, 7.187
'x = x
End If
'For x = 0 To NextNo
'    For Y = 0 To NextNo
''        If DP2(x, Y) > 0 Then
''            x = x
''        End If
'        If DP2(x, Y) <> DP3(x, Y) Then '22,285
'            x = x
'        End If
'    Next Y
'Next x
'Open "PTestN.csv" For Append As #1
'For x = 0 To NextNo
'    For Y = 1 To CurrentXOver(x)
'        Print #1, Str(XoverList(x, Y).Probability) + "," + Str(XoverList(x, Y).Daughter) + "," + Str(XoverList(x, Y).MinorP) + "," + Str(XoverList(x, Y).MajorP)
'    Next Y
'Next x
'Close #1

If AtLeastOne > 0 Then
        tSS = Abs(GetTickCount)
        
        
        
        '''For T = 1 To 10
'        For x = 0 To oNextno
'            For Y = oNextno + 1 To Nextno
'                If DP(x, Y) > 0 Then
'                    BotherWith(x) = 1
'                    Exit For
'                End If
'            Next Y
'        Next x
'        For x = 0 To oNextno
'            If BotherWith(x) = 0 Then
'                x = x
'            End If
'        Next x
    
    
    UBPV2 = UBound(PermValid, 2)
    ReDim RedoL(2, ((oNextno * (oNextno + 1)) / 2) * (NextNo - oNextno + 1))
    
    'Make ALIst
    BAL = ((oNextno + 1) * oNextno) / 2
    BAL = BAL * (NextNo - oNextno + 1)
    ReDim AList(2, BAL)
    ReDim RestartPos(2)
    If x = x Then
       ' ALC = MakeAListASES(oNextno, NextNo, MinSeqSize, UBound(AList, 1), AList(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), tMaskseq(0), UBound(PermValid, 1), PermValid(0, 0), PermDiffs(0, 0))
    Else
        ALC = -1
        For Seq1 = 0 To oNextno - 1
            If Seq1 <= UBPV2 And tMaskseq(Seq1) = 0 Then ' And BotherWith(Seq1) = 1 Then
                For Seq2 = Seq1 + 1 To oNextno
                    If Seq2 <= UBPV2 And tMaskseq(Seq2) = 0 Then
                        If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize Then 'And BotherWith(Seq2) = 1 Then
                            For Seq3 = oNextno + 1 To NextNo
                                If tMaskseq(Seq3) = 0 And BotherWith(Seq3) = 1 Then
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize And ((DP(Seq1, Seq3) + DP(Seq2, Seq3) > 0) Or (DP2(Seq1, Seq3) + DP2(Seq2, Seq3)) = 2) Then
                                        ALC = ALC + 1
                                        AList(0, ALC) = Seq1
                                        AList(1, ALC) = Seq2
                                        AList(2, ALC) = Seq3
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                Next Seq2
            End If
        Next Seq1
    End If
    
'    ReDim XoverList(NextNo, 100)
'    ReDim CurrentXOver(NextNo)
'    ReDim MaxXOP(AddNum - 1, NextNo)

    
    ggg = Abs(GetTickCount)
    If ALC > -1 Then
        If DoScans(0, 0) = 1 Then
            '@'@'@'@'@
            'ReDim Preserve AList(2, ALC)
            If x = x Then
               
                
                XX = TripListLen
                ReDim RedoL3(ALC)
                
                StepsX = CLng(100000000 / Len(StrainSeq(0)))
                UseCompress = 1
                For Y = 0 To ALC Step StepsX
                    If Y + StepsX - 1 > ALC Then
                        EPX = ALC
                    Else
                        EPX = Y + StepsX - 1
                    End If
                    '@'@'@'@'@'@'@
                    NumRedos = AlistRDP3(AList(0, 0), ALC, Y, EPX, NextNo, SubThresh, RedoL3(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                    'If NumRedos > 0 Then
                    
                    If x = x Then
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                For A = 0 To Members(AList(0, x))
                                    Seq1 = Teams(AList(0, x), A)
                                    For b = 0 To Members(AList(1, x))
                                        Seq2 = Teams(AList(1, x), b)
                                        For C = 0 To Members(AList(2, x))
                                            Seq3 = Teams(AList(2, x), C)
                                ''22,245,285
                                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                        Next C
                                    Next b
                                Next A
                            End If
                        Next x
                    Else
                        For x = Y To EPX
                            If RedoL3(x) > 0 Then
                                Seq1 = AList(0, x)
                                Seq2 = AList(1, x)
                                Seq3 = AList(2, x)
                                ''22,245,285
                                Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                        
                            End If
                        Next x
                    
                    
                    End If
                    'End If
                    
                    ET = Abs(GetTickCount)
                    ET = Abs(ET)
                    If Abs(ET - LT) > 500 Then
                        LT = ET
                        If Y + StepsX - 1 <= ALC Then
                            Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((35 + CLng(((Y + StepsX - 1) / ALC) * 600) / 10))) + "% of this cluster completed)"
                        Else
                           Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
                        End If
                        UpdateRecNums (SEventNumber)
                        GlobalTimer = ET
                        'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                        Call UpdateTimeCaps(ET, STartT)
                        Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                        
                        DoEvents
    
                    End If
                Next Y
                UseCompress = 0
            Else
                NumRedos = AESecondRDP3(Seq1, 2, MinSeqSize, oNextno, NextNo, SubThresh, UBound(RedoL, 1), RedoL(0, 0), UBound(DP, 1), DP(0, 0), DP2(0, 0), UBound(PermValid, 2), PermDIffs(0, 0), PermValid(0, 0), tMaskseq(0), CircularFlag, MCCorrection, MCFlag, LowestProb, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), CompressSeq(0, 0), SeqNum(0, 0), XoverWindow, XOverWindowX, FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0))
                If NumRedos > 0 Then
                    
                    SS = Abs(GetTickCount)
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (95% of this cluster completed)"
                    UpdateRecNums (SEventNumber)
                    GlobalTimer = SS
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(SS, STartT)
                    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    
                    DoEvents
                    If x = x Then 'reorder redos
                        'sort seq 1
                        SSS = Abs(GetTickCount)
                        'Dim S1Count() As Long, CurS1 As Long, SPS1() As Long
                        ReDim S1Count(oNextno), SPS1(oNextno)
                        For x = 1 To NumRedos
                            CurS1 = RedoL(0, x)
                            S1Count(CurS1) = S1Count(CurS1) + 1
                        Next x
                        SPS1(0) = S1Count(0)
                        For x = 1 To oNextno
                            SPS1(x) = SPS1(x - 1) + S1Count(x)
                        Next x
                        ReDim RedoL2(2, NumRedos)
                        'Dim L2Pos As Long
                        For x = NumRedos To 0 Step -1
                            L2Pos = SPS1(RedoL(0, x))
                            RedoL2(0, L2Pos) = RedoL(0, x)
                            RedoL2(1, L2Pos) = RedoL(1, x)
                            RedoL2(2, L2Pos) = RedoL(2, x)
                            SPS1(RedoL(0, x)) = SPS1(RedoL(0, x)) - 1
                        Next x
        '                    XX = SPS1(4)
        '                    XX = S1Count(4)
        '                    SSS = abs(gettickcount)
        '                    For x = 0 To NumRedos
        '                        For y = x + 1 To NumRedos
        '                            If RedoL2(0, x) > RedoL2(0, y) Then
        '                                Call SwapSort(RedoL2(), x, y)
        '                            ElseIf RedoL2(0, x) = RedoL2(0, y) Then
        '                                If RedoL2(1, x) > RedoL2(1, y) Then
        '                                    Call SwapSort(RedoL2(), x, y)
        '                                ElseIf RedoL2(1, x) = RedoL2(1, y) Then
        '                                    If RedoL2(2, x) > RedoL2(2, y) Then
        '                                        Call SwapSort(RedoL2(), x, y)
        '                                    End If
        '                                End If
        '                            End If
        '                        Next y
        '                    Next x
                    End If
                    For x = 1 To NumRedos
                    
                      Seq1 = RedoL2(0, x)
                      Seq2 = RedoL2(1, x)
                      Seq3 = RedoL2(2, x)
                      ''22,245,285
                      Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                    Next x
                    
                    For x = 0 To NextNo
                        XXX = XXX + CurrentXOver(x) '7753
                    Next x
                    SS = Abs(GetTickCount)
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (100% of this cluster completed)"
                    UpdateRecNums (SEventNumber)
                    GlobalTimer = SS
                    'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                    Call UpdateTimeCaps(SS, STartT)
                    Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    
                    DoEvents
                End If
            End If
    '        XXX = 0
    '        For x = 0 To NextNo
    '            XXX = XXX + CurrentXOver(x) '7753
    '        Next x
    '        EEE = abs(gettickcount)
    '        ttt = EEE - ggg
            x = x
        End If
    End If
    If DoScans(0, 1) = 1 Or DoScans(0, 2) = 1 Or DoScans(0, 3) = 1 Or DoScans(0, 4) = 1 Or DoScans(0, 5) = 1 Or DoScans(0, 8) = 1 Then
        For Seq1 = 0 To oNextno - 1
            If Seq1 <= UBPV2 And tMaskseq(Seq1) = 0 Then ' And BotherWith(Seq1) = 1 Then
                For Seq2 = Seq1 + 1 To oNextno
                    If Seq2 <= UBPV2 And tMaskseq(Seq2) = 0 Then
        '                 If Seq2 = 142 And Seq1 = 112 Then
        '                    x = x
        '                 End If
                        If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq2) > MinSeqSize Then 'And BotherWith(Seq2) = 1 Then
        '                    NN = 0
        '                    XX = (PermNextno - Nextno)
                            For Seq3 = oNextno + 1 To NextNo
                                
                                If tMaskseq(Seq3) = 0 And BotherWith(Seq3) = 1 Then
                                    'NN = NN + 1
                                    '@'@
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize And ((DP(Seq1, Seq3) + DP(Seq2, Seq3) > 0) Or (DP2(Seq1, Seq3) + DP2(Seq2, Seq3)) = 2) Then

                                        'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                 'XX = PermValid(225, 230)
                                                If DoScans(0, 0) = 1 Then
                                                     '@'@'@
'                                                     XX = CompressSeq(1, 0)
'                                                     XX = CompressSeq(500, 0)
'                                                     XX = CompressSeq(1, 1)
                                                     'FRC = FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV)
'                                                     If frc = 1 Then
'                                                        x = x
'                                                     End If
                                                     'FRC = 1
                                                    If FastRecCheckP(CircularFlag, 0, MCCorrection, MCFlag, 1, (LowestProb / MCCorrection), LowestProb, NextNo, TargetX, Len(StrainSeq(0)), ShortOutFlag, UBound(Distance, 1), Distance(0, 0), UBound(TreeDistance, 1), TreeDistance(0, 0), UBound(FSSRDP, 2), UBound(CompressSeq, 1), UBound(XoverSeqNumW, 1), CompressSeq(0, 0), SeqNum(0, 0), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(0, 0), XoverSeqNumW(0, 0), UBound(XOverHomologyNum, 1), XOverHomologyNum(0, 0), FSSRDP(0, 0, 0, 0), ProbEstimateInFileFlag, UBound(ProbEstimate, 1), UBound(ProbEstimate, 2), ProbEstimate(0, 0, 0), UBound(Fact3X3, 1), Fact3X3(0, 0, 0), Fact(0), BQPV) = 1 Then
                                                        Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                    End If
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                '@
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                
                                            'End If
                                        'End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                    x = x
                Next Seq2
            End If
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    '@
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng(250 + ((Seq1 / (oNextno + 1)) * 750)) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        Next Seq1
        
        
   End If
   ess = Abs(GetTickCount)
   TotASET = TotASET + Abs(ess - tSS)
   
End If


'EE = abs(gettickcount)
'TT = EE - SSSss
'TotFGCT = TotFGCT + TT
'Form1.Caption = TotFGCT



DontWorryAboutSplitsFlag = oDWS
Dim NumNew
NumNew = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        NumNew = NumNew + 1
'        XX = XoverList(x, Y).Daughter '7
'        XX = XoverList(x, Y).MajorP '15
'        XX = XoverList(x, Y).MinorP '9
        'XoverList(x, Y).BeginP = -100
        If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
        ElseIf XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        'XX = XoverList(x, Y).EndP '0
        End If
    Next Y
Next x

'For x = 0 To Nextno
'    If ActualSeqSize(x) = 0 Then
'        x = x
'    End If
'Next x
UseCompress = 0

SS = Abs(GetTickCount)
If Abs(SS - LS) > 500 Then
    LS = SS
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined"
    DoEvents
End If
For x = 0 To AddNum - 1
    MethodTime(x) = MethodTime(x) + Abs(SS - STartT) * TimeFract(x)
Next x
CurSeedExtras = CurSeed
If NumNew = 0 Then
    x = x
    StepNo = FirstStepNo 'StepNo - 1
    GoTo Redo
Else
    x = x
End If

End Sub

Public Sub AddSomeExcludesOld3(TraceSub() As Long, MinSeqSize, NextNo As Long, SeqNum() As Integer, ActualSeqSize() As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno, MissingData() As Byte, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer)

Dim FirstStepNo As Long, SSN As Long, OSN As Long, CurSeed As Long, BoundsMD() As Long, NumMD As Long, Y As Long, Y1 As Long, Y2 As Long, oNextno As Long, UB As Long, Z As Long, x As Long, oDirX As String, Pos As Long, FF As Long, EListNum As Long, TELong As Long, TEString As String
Dim UB1 As Long, UB2 As Long, g As Long

FirstStepNo = StepNo





Redo:
'For x = PermNextno To Nextno
Steps(0, StepNo) = 6 'this erases all sequences with numbers above permnextno by resetting nextno to permnextno
Steps(4, StepNo) = SEventNumber + 1
StepNo = StepNo + 1
UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

'This is test code to see whether restoring seqnum and missingdata outside of this exclude
'group will reveal more hidden signals
Dim RedoAllDists As Long
RedoAllDists = 0
If x = x Then
    'reset seqnum and modseqnum to state of first addsomeexcludes
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SMDrop" + UFTag For Binary As #FF
    If FirstAddSome = 0 Then
        FirstAddSome = 1
        UB1 = UBound(SeqNum, 1)
        UB2 = UBound(SeqNum, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , SeqNum()
        UB1 = UBound(MissingData, 1)
        UB2 = UBound(MissingData, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , MissingData()
        
        
    Else
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim SeqNum(UB1, UB2)
        Get #FF, , SeqNum()
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim MissingData(UB1, UB2)
        Get #FF, , MissingData()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    RedoAllDists = 1
ElseIf x = 123456 Then
 
    RedoAllDists = 1
    'Dim tSeqNum() As Integer
    'ReDim tSeqNum(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
        Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
    End If
    ReDim MissingData(Len(StrainSeq(0)), PermNextno + 1)
    'now add missingdata and indels back to the seed sequence
    For x = 0 To PermNextno
        If DoneExcludes(x) = 0 Then
            If x <= UBound(ExcludeCoords) Then
                If ExcludeCoords(x) > 0 Then
                    CurSeed = x
                    Exit For
                End If
            End If
        End If
    Next x
    If x = x Then 'edit the anchor sequence
        For x = 1 To StepNo - 1
            If Steps(0, x) = 2 Then
                If Steps(1, x) = CurSeed Then
                    Dummy = ModSeqNumE(PermNextno, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
                    'tRedoDist(Steps(1, x)) = 1
                End If
            End If
        Next x
    End If
End If





UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

NextNo = PermNextno
'Next x
BusyWithExcludes = 1


ReDim BoundsMD(Len(StrainSeq(0)), 1)
NumMD = 0
Dim GoOn As Byte
'erase any sequences >permenxtno


NextNo = PermNextno
oNextno = NextNo
Dim SSBak() As Long
ReDim SSBak(Len(StrainSeq(0)))
GoOn = 0
Dim EPosX As Long, BreakB As Long, BreakE As Long, DSX As Long

For x = 0 To PermNextno
'     If x = 97 Then
'            x = x
'        End If
    If DoneExcludes(x) = 0 And MaskSeq(x) = 0 Then
       
        If x <= UBound(ExcludeCoords) Then
            If ExcludeCoords(x) > 0 Then
'                Open "progress.txt" For Append As #20
'                Print #20, SEventNumber, "exrras", x
'                Close #20
                'establish boundaries of missing data in sequence X
                CurSeed = x
                
                For Y1 = 0 To Len(StrainSeq(0))
                    If MissingData(Y1, x) = 1 Then
                        For Y2 = Y1 + 1 To Len(StrainSeq(0))
                            If MissingData(Y2, x) = 0 Then
                                Y2 = Y2 - 1
                                Exit For
                            End If
                        Next Y2
                        BoundsMD(NumMD, 0) = Y1
                        BoundsMD(NumMD, 1) = Y2
                        NumMD = NumMD + 1
                        Y1 = Y2
                    End If
                Next Y1
                Pos = ExcludeCoords(x)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                Get #FF, Pos, EListNum
                'now add these elistnnum sequences to the alignment and record the edits in the steps array
                ReDim OSNPos(NextNo + EListNum)
                
                For Z = 1 To EListNum
                    GoOn = 1
                    NextNo = NextNo + 1
                    If NextNo > UBound(GrpMaskSeq, 1) Or NextNo > UBound(OriginalName, 1) Or NextNo > UBound(TraceSub, 1) Or NextNo > UBound(MaskSeq, 1) Then
                        ReDim Preserve TraceSub(NextNo + 50), OriginalName(NextNo + 50), StraiName(NextNo + 50), MaskSeq(NextNo + 50)
                        ReDim Preserve GrpMaskSeq(NextNo + 50)
                    End If
                    If NextNo > UBound(OriginalPos, 1) Then
                        ReDim Preserve OriginalPos(NextNo + 50)
                    End If
                    TraceSub(NextNo) = x
                    
                    MaskSeq(NextNo) = 0
                    EPosX = Seek(FF) 'remember the position of this specific sequence
                    Get #FF, , SSN 'Original number of the sequence that this unexcluded sequence this sequence is most similar to
                    Get #FF, , OSN 'original seq number
'                    If OSN = 6709 Then
'                        x = x
'                        '258
'                        For BBx = 0 To NextnoBak
'                            If OriginalPos(BBx) = 4541 Then
'                                x = x
'                            End If
'                        Next BBx
'                    End If
                    OSNPos(NextNo) = OSN
                    Get #FF, , TELong 'discard number
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'originalname
                    XX = SEventNumber
                    OriginalName(NextNo) = TEString
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString
                    StraiName(NextNo) = TEString 'strainame
                    Get #FF, , TELong 'seqeunec length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'sequence
                    'XX = SEventNumber
                    
                    If UBound(SeqNum, 2) < NextNo Then
                        ReDim Preserve SeqNum(UBound(SeqNum, 1), NextNo + 10)
                    End If
                    'copy the sequence into the nextno slot
                    
                    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                    'there is sequence compression and the loaded sequence needs to be modified accordingly
                       TEString = CompressTEString(Decompress(), TEString)
                    End If
                    
                    Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), TEString, SSBak(0))
                    ReDim Preserve StrainSeq(NextNo)
                    StrainSeq(NextNo) = TEString
                    'this is the original sequence that gets copied into seqnum so it must be edited to account for
                    'all recombination event that were previously inferred for this sequence
                    Steps(0, StepNo) = 1 'ie create a new sequence ....
'                    If x = 159 Then
'                        x = x
'                    End If
                    Steps(1, StepNo) = x 'using this seqence as the source of the current exclude
                    Steps(2, StepNo) = -EPosX 'the specific excluded sequence (the negative will indicate to modseqnum that the additional sequence is from the excludelist
                    Steps(3, StepNo) = 0 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                    'XX = UBound(SeqNum, 1)
                    If NextNo > UBound(MissingData, 2) Then
                        ReDim Preserve MissingData(UBound(MissingData, 1), NextNo)
                    End If
'                    If SEventNumber = 9 Then
'                        x = x
'                    End If
                    For Y1 = 1 To Len(StrainSeq(0))
                        MissingData(Y1, NextNo) = 0
                    Next Y1
                    'For G = 0 To ExcludedEventNum
                    
                    '    If EventsInExcludeds(3, G) = CurSeed Then
                            For Y = 0 To NumMD - 1
                                If BoundsMD(Y, 1) > Len(StrainSeq(0)) Then BoundsMD(Y, 1) = Len(StrainSeq(0))
                                If BoundsMD(Y, 0) > Len(StrainSeq(0)) Then BoundsMD(Y, 0) = Len(StrainSeq(0))
                                
                                For Y1 = BoundsMD(Y, 0) To BoundsMD(Y, 1)
                                    SeqNum(Y1, NextNo) = 46
                                    MissingData(Y1, NextNo) = 1
                                Next Y1
                                
                                Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                                Steps(1, StepNo) = NextNo  'from this seqence.....
                                Steps(2, StepNo) = BoundsMD(Y, 0) 'from this position....
                                Steps(3, StepNo) = BoundsMD(Y, 1) 'to this position....
                                Steps(4, StepNo) = SEventNumber + 1
                               
                                StepNo = StepNo + 1
                                
                                UB = UBound(Steps, 2)
                                If StepNo > UB Then
                                    ReDim Preserve Steps(4, UB + 100)
                                End If
                            
                            Next Y
                        'End If
                    'Next G
                    
                    
                Next Z
                Close #FF
                ChDrive oDirX
                ChDir oDirX
                '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                'This could be a rescan
                'Need to check the the already accepted events in bestxolist to see if any of the
                'current batch of added in excludes contain sequences in that list
                'basically I need to search bestxolist for matches to the seed sequence where the .beginp property is <0
                'I then simply check if the .daughter is >permnextno and, if so,
                'add in an edit to that sequence and record the edit in steps
                ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                For Y = 1 To BCurrentXOver(CurSeed)
                    If BestXOList(CurSeed, Y).BeginP < 0 Then
                        If BestXOList(CurSeed, Y).Daughter > PermNextno Then
                             DSX = BestXOList(CurSeed, Y).Daughter
                             BreakB = BestXOList(CurSeed, Y).Beginning
                             BreakE = BestXOList(CurSeed, Y).Ending
                             Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                             Steps(1, StepNo) = DSX  'from this seqence.....
                             Steps(2, StepNo) = BreakB 'from this position....
                             Steps(3, StepNo) = BreakE 'to this position....
                             Steps(4, StepNo) = SEventNumber + 1
                            
                             StepNo = StepNo + 1
                             
                             UB = UBound(Steps, 2)
                             If StepNo > UB Then
                                 ReDim Preserve Steps(4, UB + 100)
                             End If
                             
                             If BreakB < BreakE Then
                                For Z = BreakB To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             Else
                                For Z = BreakB To Len(StrainSeq(0))
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                                For Z = 1 To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             
                             End If
                             
                        End If
                    End If
                Next Y
                
                
                
                DoneExcludes(x) = 1
                Exit For
            
            End If
            
           
        End If
    End If
Next x
If GoOn = 0 Then
    DoExcludes = 0
    
    Exit Sub
End If

ReDim CurrentXOver(NextNo), XoverList(NextNo, XOverListSize)


'Dummy = MakeActualSeqSize(Len(StrainSeq(0)), Nextno, WinPP, RNum(0), RList(0, 0), ActualSeqSize(0), SeqNum(0, 0))
ReDim Preserve ActualSeqSize(NextNo)
For x = oNextno + 1 To NextNo
    ActualSeqSize(x) = 0
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 46 Then ActualSeqSize(x) = ActualSeqSize(x) + 1
    Next Y
Next x
'XX = Nextno
'XX = ActualSeqSize(53)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'need to mimic everything in dordp up to the innerscan call
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If QvRFlag = 1 Then
    ReDim Preserve ReferenceList(NextNo)
End If
'Update the treedistance used for RDP and SiScan
ReDim TreeDistance(NextNo, NextNo)



Dim TDiffs() As Single, TValid() As Single, Uninvolved() As Long
ReDim Uninvolved(NextNo)
For x = 0 To NextNo
    Uninvolved(x) = 1
Next x


If PermNextno > MemPoc Then
    
    GetPermDiffs
'    XX = ActualSeqSize(3)
'    XX = Uninvolved(3)
    ReDim TDiffs(NextNo, NextNo)
    
    Dummy = MakeTDiffs2(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), PermDIffs(0, 0), Uninvolved(0), ActualSeqSize(0))
   
'    XX = TDiffs(3, 1)
'    XX = TDiffs(0, 1)
'    XX = PermDiffs(3, 1)
    ReDim PermDIffs(0, 0)
    
    GetPermValid
    
    'XX = PermValid(0, 1)
'    XX = Uninvolved(0)
'    XX = Uninvolved(1)
    ReDim TValid(NextNo, NextNo)
    
    Dummy = MakeTDiffs3(NextNo, UBound(PermValid, 1), TValid(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
    
'    XX = TValid(1, 0)
'    XX = PermValid(0, 1)
    ReDim PermValid(0, 0)
Else
    ReDim TDiffs(NextNo, NextNo), TValid(NextNo, NextNo)
     
    Dummy = MakeTDiffs(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), TValid(0, 0), PermDIffs(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
'XX = oNextno
End If

'XX = TValid(0, 1)
ReDim Distance(NextNo, NextNo)
AvDst = 0
Dim tRedoDist() As Integer, Invert(1) As Byte
Invert(0) = 1
Invert(1) = 0
ReDim tRedoDist(NextNo)
If RedoAllDists = 0 Then
    For x = oNextno + 1 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
Else
    For x = 0 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
End If
    
Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, TDiffs(), TValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
    
ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo)
Dummy = FinishDists2(NextNo, PermValid(0, 0), PermDIffs(0, 0), TValid(0, 0), TDiffs(0, 0), Distance(0, 0))


If PermNextno > MemPoc And x = 1234567 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    UBDistance = UBound(Distance, 1)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Put #FF, , Distance()
    Close #FF
    DistanceInFileFlag = 1
    ReDim Distance(0, 0)
    ChDir oDir
    ChDrive oDir
End If
    

If PermNextno > MemPoc Then
    Call PutPermValid
    Call PutPermDiffs
    'ReDim PermDiffs(0, 0)
    'ReDim PermValid(0, 0)
End If


Erase TDiffs
Erase TValid

DistanceFlag = 1
TreeDistFlag = 0

Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
'XX = TreeDistance(1, 0)
DoEvents

Dim DP() As Byte
ReDim DP(NextNo, NextNo)
If x = 123456 Then
'    For x = 0 To Nextno
'
'    For Y = 0 To Nextno
'        If TreeDistance(x, Y) <> 0 Then
'            x = x
'        End If
'
'    Next Y
'
'    Next x
    'find a phylogenetically representative selection of sequences in the includes that must be compared with the excludes in the
    'last recombination screen loops at the end - these are specified with the DP arrays
    Dim Seq1List() As Long, TV As Single, SL As Long, Longest As Long, DS() As Byte
    ReDim Seq1List(NextNo), DS(NextNo)
    SL = -1
    Seq1List(0) = CurSeed
    DS(CurSeed) = 1
    For x = 0 To oNextno - 1
        If DS(x) = 0 Then
            DS(x) = 1
            SL = SL + 1
            Longest = ActualSeqSize(x)
            Seq1List(SL) = x
            TV = TreeDistance(CurSeed, x)
            For Y = x + 1 To oNextno
                If DS(Y) = 0 Then
                    If TreeDistance(CurSeed, Y) = TV Then
                        DS(Y) = 1
                        If Longest < ActualSeqSize(Y) Then
                            Longest = ActualSeqSize(Y)
                            Seq1List(SL) = Y
                        End If
                    End If
                End If
            Next Y
        End If
        
    Next x
    For x = 0 To SL
        For Y = oNextno + 1 To NextNo
            DP(Seq1List(x), Y) = 1
            DP(Y, Seq1List(x)) = 1
        Next Y
    Next x
'    For x = 0 To oNextno
'        For Y = oNextno + 1 To Nextno
'            DP(x, Y) = 1
'            DP(Y, x) = 1
'        Next Y
'    Next x
End If
If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        
    End If
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        Erase TreeX
    End If
    ChDrive oDirX
    ChDir oDirX
End If

Dim tMaskseq() As Byte
ReDim tMaskseq(NextNo)

If MaskThresh = 0 Then
    Dim Correx, AA
    AA = x
    
    Correx = MCCorrection * (Len(StrainSeq(0)) / XOverWindowX)
    
    'If LowestProb = 0 Then LowestProb = 0.05
    Correx = LowestProb / Correx
    Correx = 1 / Correx
    Correx = Log(Correx) / Log(4)
 'XX = (2 * Log(4 * X))
    'Y = (2 * Log(4 * X)) / Len(StrainSeq(0))
     MaskThresh = Correx / Len(StrainSeq(0))
     MaskThresh = MaskThresh / 3
End If

If MaskThresh > 0 Then
    'mask sequences that are almost identical
    For x = 0 To PermNextno
        tMaskseq(x) = MaskSeq(x)
    Next x
    For x = oNextno To NextNo
        If ((1 - Distance(x, CurSeed)) < MaskThresh) Then
            tMaskseq(x) = 1
        Else
            If tMaskseq(x) = 0 Then
                For Y = x + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        If ((1 - Distance(x, Y)) < MaskThresh) Then
                            If ActualSeqSize(x) < ActualSeqSize(Y) Then
                                tMaskseq(x) = 1
                            
                            Else
                                tMaskseq(Y) = 1
                            End If
                            x = oNextno - 1
                            Exit For
                        End If
                    End If
                Next Y
            End If
        End If
    Next x
End If


SSSss = Abs(GetTickCount)
UseCompress = 1
Call MakeScanCompressArrays(NextNo, SeqNum())
EE = Abs(GetTickCount)
TT = EE - SSSss
'first scan all the excludes against one another and one of the includes
Dim SP As Long, oDWS As Byte
oDWS = DontWorryAboutSplitsFlag
DontWorryAboutSplitsFlag = 1
Dim STartT As Variant
STartT = Abs(GetTickCount)

If DoScans(0, 0) = 1 Then
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Prefilter which pairs of includes to bother with here using the fastrecchecks and a very high p-val cutoff to look for
'instances where, curseed and one of the excludes when scanned against one of the includes yields even a very marginally significant p-value.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'UCThresh = 1
Dim BotherWith() As Byte, AtLeastOne As Byte
ReDim BotherWith(NextNo)

LowestProb = pLowestProb
'If CurSeed = 6 Then
'    x = x
'End If

Dim DPR() As Byte, DPG() As Byte, DPF() As Byte, DPS() As Byte

ReDim DPR(NextNo, NextNo), DPG(NextNo, NextNo), DPF(NextNo, NextNo), DPS(NextNo, NextNo)
If x = x Then
    
        'Make a seq1 list that samples the logest sequence off every branch below curseed
        
        
        UCThresh = LowestProb / (MCCorrection / 10000)
        If UCThresh > 0.05 Then UCThresh = 0.05
        AtLeastOne = 0
        EarlyBale = 1
'        For x = 0 To oNextno
'            BotherWith(x) = 1
'        Next x
        
        
        
        
        Seq1 = CurSeed
'        For x = 0 To SL
'            Seq1 = Seq1List(x)
            For Seq2 = 0 To oNextno
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = oNextno + 1 To NextNo
                            If Seq1 <> Seq2 And tMaskseq(Seq3) = 0 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
                                            
                                            'For x = oNextno + 1 To NextNo
                                                DP(Seq3, Seq2) = 1
                                                DP(Seq2, Seq3) = 1
                                            'Next x
                                            
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            'Exit For
                                        End If
                                    End If
                                End If
                            End If
                        Next Seq3
                    End If
                
            Next Seq2
             For Seq2 = oNextno + 1 To NextNo - 1
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = Seq2 + 1 To NextNo
                            'If Seq1 <> Seq3 And Seq2 <> Seq3 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize And tMaskseq(Seq3) = 0 Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
'                                            If x <= oNextno And BotherWith(Seq3) = 0 Then
'                                                For x = oNextno + 1 To Nextno
                                                    DP(Seq2, Seq3) = 1
                                                    DP(Seq3, Seq2) = 1
'                                                Next x
'                                            End If
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            'Exit For
                                        End If
                                    End If
                                End If
                            'End If
                        Next Seq3
                    End If
                
            Next Seq2
        'Next x
        EarlyBale = 0
        For x = oNextno + 1 To NextNo
            DP(CurSeed, x) = 1
            DP(x, CurSeed) = 1
        Next x
        
        
        For x = 0 To NextNo
            For Y = 0 To NextNo
                DPR(x, Y) = DP(x, Y)
            Next Y
            BotherWith(x) = 1
        Next x

Else
    AtLeastOne = 1
    For x = oNextno + 1 To NextNo
        BotherWith(x) = 1
    Next x
End If


'XX = Nextno - oNextno

'AtLeastOne = 1
'For x = 0 To Nextno
'   BotherWith(x) = 1
'Next x


If x = x Then
    Dim TP() As Byte
        ReDim TP(NextNo, NextNo)
        For x = 0 To NextNo
            If tMaskseq(x) = 0 Then
                For Y = oNextno + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        TP(x, Y) = 1
                        'TP(Y, X) = 1
                    End If
                Next Y
            End If
        Next x
       ' Call FastRecCheckGC(Nextno, (LowestProb / (oNextno * (Nextno - oNextno))) * 10000, DP(), SeqNum(), TP(), tMaskseq())
        ReDim DP(NextNo, NextNo)
        Call FastRecCheckGC(NextNo, 0.05, DP(), SeqNum(), TP(), tMaskseq())
        
        For x = 0 To NextNo
            For Y = 0 To NextNo
                DPG(x, Y) = DP(x, Y)
                DP(x, Y) = 1
            Next Y
            BotherWith(x) = 1
        Next x
        ReDim DP(NextNo, NextNo)
        'Dim VarSites() As Long
        'ReDim VarSites(Len(StrainSeq(0)))
        
    For Seq1 = 0 To oNextno '0 To oNextno
        'if I let other sequences in besides curseed here it is very difficult to properly group recombinants
        'Also, The way it was it was possible to get all three signal sequences from this exclude list cluster.
        If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
           
            For Seq2 = oNextno + 1 To NextNo - 1
                'If BotherWith(Seq2) = 1 Or x = x Then
                    If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
                        If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
                            For Seq3 = Seq2 + 1 To NextNo
    '                            If Seq2 = 258 Or Seq3 = 258 Then
    '                                x = x
    '                            End If
                                If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 And (DPR(Seq3, Seq2) + DPR(Seq3, Seq1) + DPR(Seq2, Seq1) > -1) And (DPG(Seq3, Seq2) + DPG(Seq3, Seq1) + DPG(Seq2, Seq1) > -1) Then 'And ((DPR(Seq3, Seq2) + DPR(Seq3, Seq1) + DPR(Seq2, Seq1) > 1) And (DPG(Seq3, Seq2) + DPG(Seq3, Seq1) + DPG(Seq2, Seq1) > 0) Or (DPR(Seq3, Seq2) + DPR(Seq3, Seq1) + DPR(Seq2, Seq1) > 0) And (DPG(Seq3, Seq2) + DPG(Seq3, Seq1) + DPG(Seq2, Seq1) > 1)) Then
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                        If PermDIffs(Seq2, Seq3) > 2 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                NewOneFound = 0
                                                
                                                ActualFound = 0
                                                If DoScans(0, 0) = 1 Then
                                                                
                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                If NewOneFound = 1 Then
                                                    DP(Seq3, Seq1) = 1
                                                    DP(Seq1, Seq3) = 1
                                                    DP(Seq2, Seq1) = 1
                                                    DP(Seq1, Seq2) = 1
                                                End If
                                                If ActualFound = 1 Then
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) > 1 Then
                                                        HitFirstRDP2 = HitFirstRDP2 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 Then
                                                        HitFirstRDP1 = HitFirstRDP1 + 1
                                                    Else
                                                        MissFirstRDP = MissFirstRDP + 1
                                                    End If
                                                    If DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) > 1 Then
                                                        HitFirstGDP2 = HitFirstGDP2 + 1
                                                    ElseIf DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        HitFirstGDP1 = HitFirstGDP1 + 1
                                                    Else
                                                        MissFirstGDP = MissFirstGDP + 1
                                                    End If
                                                    
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) > 1 Then
                                                        HitFirstRGDP22 = HitFirstRGDP22 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) > 1 Then
                                                        HitFirstRGDP12 = HitFirstRGDP12 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        HitFirstRGDP21 = HitFirstRGDP21 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        HitFirstRGDP11 = HitFirstRGDP11 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 0 Then
                                                        HitFirstRGDP10 = HitFirstRGDP10 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 0 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        HitFirstRGDP01 = HitFirstRGDP01 + 1
                                                    Else
                                                        MissFirstRGDP = MissFirstRGDP + 1
                                                    End If
                                                Else
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) > 1 Then
                                                        FPHitFirstRDP2 = FPHitFirstRDP2 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 Then
                                                        FPHitFirstRDP1 = FPHitFirstRDP1 + 1
                                                    Else
                                                        FPMissFirstRDP = FPMissFirstRDP + 1
                                                    End If
                                                    If DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) > 1 Then
                                                        FPHitFirstGDP2 = FPHitFirstGDP2 + 1
                                                    ElseIf DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        FPHitFirstGDP1 = FPHitFirstGDP1 + 1
                                                    Else
                                                        FPMissFirstGDP = FPMissFirstGDP + 1
                                                    End If
                                                    
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) > 1 Then
                                                        FPHitFirstRGDP22 = FPHitFirstRGDP22 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) > 1 Then
                                                        FPHitFirstRGDP12 = FPHitFirstRGDP12 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        FPHitFirstRGDP21 = FPHitFirstRGDP21 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        FPHitFirstRGDP11 = FPHitFirstRGDP11 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 0 Then
                                                        FPHitFirstRGDP10 = FPHitFirstRGDP10 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 0 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        FPHitFirstRGDP01 = FPHitFirstRGDP01 + 1
                                                    Else
                                                    
                                                        FPMissFirstRGDP = FPMissFirstRGDP + 1
                                                    End If
                                                End If
                                            'End If
                                        End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                'End If
            Next Seq2
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                GlobalTimer = SS
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        End If
    
    Next Seq1
End If

For x = 0 To NextNo
    For Y = 0 To NextNo
'        If DP(x, Y) = 0 And x <> Y And Y > oNextno Then '0,225; 0,226; 0,227
'            x = x
'        End If
        DPF(x, Y) = DP(x, Y)
        DP(x, Y) = 1
    Next Y
    BotherWith(x) = 1
Next x
If AtLeastOne > 0 Then
        tSS = Abs(GetTickCount)
        
        
        
        '''For T = 1 To 10
'        For x = 0 To oNextno
'            For Y = oNextno + 1 To Nextno
'                If DP(x, Y) > 0 Then
'                    BotherWith(x) = 1
'                    Exit For
'                End If
'            Next Y
'        Next x
'        For x = 0 To oNextno
'            If BotherWith(x) = 0 Then
'                x = x
'            End If
'        Next x
    Dim UBPV2 As Long
    UBPV2 = UBound(PermValid, 2)
        For Seq1 = 0 To oNextno - 1
            If Seq1 <= UBPV2 And tMaskseq(Seq1) = 0 Then ' And BotherWith(Seq1) = 1 Then
                For Seq2 = Seq1 + 1 To oNextno
                    If Seq2 <= UBPV2 And tMaskseq(Seq2) = 0 Then
        '                 If Seq2 = 142 And Seq1 = 112 Then
        '                    x = x
        '                 End If
                        If PermValid(Seq1, Seq2) > MinSeqSize Then 'And BotherWith(Seq2) = 1 Then
        '                    NN = 0
        '                    XX = (PermNextno - Nextno)
                            For Seq3 = oNextno + 1 To NextNo
                                
                                If tMaskseq(Seq3) = 0 And BotherWith(Seq3) = 1 Then
                                    'NN = NN + 1
                                    '@'@
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize And (DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > -1) And (DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > -1) Then

                                        'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                NewOneFound = 0
                                                ActualFound = 0
                                                If DoScans(0, 0) = 1 Then
                                                     '@'@'@
                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                '@
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                If ActualFound = 1 Then
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > 1 Then
                                                        HitSecondRDP2 = HitSecondRDP2 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) = 1 Then
                                                        HitSecondRDP1 = HitSecondRDP1 + 1
                                                    Else
                                                        MissSecondRDP = MissSecondRDP + 1
                                                    End If
                                                    If DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > 1 Then
                                                        HitSecondGDP2 = HitSecondGDP2 + 1
                                                    ElseIf DPG(Seq1, Seq3) + DPG(Seq2, Seq3) = 1 Then
                                                        HitSecondGDP1 = HitSecondGDP1 + 1
                                                    Else
                                                        MissSecondGDP = MissSecondGDP + 1
                                                    End If
                                                    If DPF(Seq1, Seq3) + DPF(Seq2, Seq3) > 1 Then
                                                        HitSecondFDP2 = HitSecondFDP2 + 1
                                                    ElseIf DPF(Seq1, Seq3) + DPF(Seq2, Seq3) = 1 Then
                                                        HitSecondFDP1 = HitSecondFDP1 + 1
                                                    Else
                                                        MissSecondFDP = MissSecondFDP + 1
                                                    End If
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > 1 Then
                                                        HitSecondRGDP22 = HitSecondRGDP22 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > 1 Then
                                                        HitSecondRGDP12 = HitSecondRGDP12 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) = 1 Then
                                                        HitSecondRGDP21 = HitSecondRGDP21 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) = 1 Then
                                                        HitSecondRGDP11 = HitSecondRGDP11 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 0 Then
                                                        HitSecondRGDP10 = HitSecondRGDP10 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 0 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        HitSecondRGDP01 = HitSecondRGDP01 + 1
                                                    Else
                                                    
                                                        MissSecondRGDP = MissSecondRGDP + 1
                                                    End If
                                                Else
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > 1 Then
                                                        FPHitSecondRDP2 = FPHitSecondRDP2 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) = 1 Then
                                                        FPHitSecondRDP1 = FPHitSecondRDP1 + 1
                                                    Else
                                                        FPMissSecondRDP = FPMissSecondRDP + 1
                                                    End If
                                                    If DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > 1 Then
                                                        FPHitSecondGDP2 = FPHitSecondGDP2 + 1
                                                    ElseIf DPG(Seq1, Seq3) + DPG(Seq2, Seq3) = 1 Then
                                                        FPHitSecondGDP1 = FPHitSecondGDP1 + 1
                                                    Else
                                                        FPMissSecondGDP = FPMissSecondGDP + 1
                                                    End If
                                                    If DPF(Seq1, Seq3) + DPF(Seq2, Seq3) > 1 Then
                                                        FPHitSecondFDP2 = FPHitSecondFDP2 + 1
                                                    ElseIf DPF(Seq1, Seq3) + DPF(Seq2, Seq3) = 1 Then
                                                        FPHitSecondFDP1 = FPHitSecondFDP1 + 1
                                                    Else
                                                        FPMissSecondFDP = FPMissSecondFDP + 1
                                                    End If
                                                    If DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > 1 Then
                                                        FPHitSecondRGDP22 = FPHitSecondRGDP22 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) > 1 Then
                                                        FPHitSecondRGDP12 = FPHitSecondRGDP12 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) > 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) = 1 Then
                                                        FPHitSecondRGDP21 = FPHitSecondRGDP21 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) = 1 Then
                                                        FPHitSecondRGDP11 = FPHitSecondRGDP11 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 1 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 0 Then
                                                        FPHitSecondRGDP10 = FPHitSecondRGDP10 + 1
                                                    ElseIf DPR(Seq1, Seq3) + DPR(Seq2, Seq3) + DPR(Seq1, Seq2) = 0 And DPG(Seq1, Seq3) + DPG(Seq2, Seq3) + DPG(Seq1, Seq2) = 1 Then
                                                        FPHitSecondRGDP01 = FPHitSecondRGDP01 + 1
                                                    Else
                                                        FPMissSecondRGDP = FPMissSecondRGDP + 1
                                                    End If
                                                End If
                                            'End If
                                        'End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                    x = x
                Next Seq2
            End If
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    '@
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng(250 + ((Seq1 / (oNextno + 1)) * 750)) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        Next Seq1
        
        ess = Abs(GetTickCount)
        TotASET = TotASET + Abs(ess - tSS)
   ' End If
End If
DontWorryAboutSplitsFlag = oDWS
Dim NumNew
NumNew = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        NumNew = NumNew + 1
'        XX = XoverList(x, Y).Daughter '7
'        XX = XoverList(x, Y).MajorP '15
'        XX = XoverList(x, Y).MinorP '9
        'XoverList(x, Y).BeginP = -100
        If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
        ElseIf XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        'XX = XoverList(x, Y).EndP '0
        End If
    Next Y
Next x

'For x = 0 To Nextno
'    If ActualSeqSize(x) = 0 Then
'        x = x
'    End If
'Next x
UseCompress = 0

SS = Abs(GetTickCount)
If Abs(SS - LS) > 500 Then
    LS = SS
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined"
    DoEvents
End If
For x = 0 To AddNum - 1
    MethodTime(x) = MethodTime(x) + Abs(SS - STartT) * TimeFract(x)
Next x
CurSeedExtras = CurSeed
If NumNew = 0 Then
    x = x
    StepNo = FirstStepNo 'StepNo - 1
    GoTo Redo
Else
    x = x
End If

End Sub                                 'objects state is nonsignaled.
Public Sub AddSomeExcludesOld2(TraceSub() As Long, MinSeqSize, NextNo As Long, SeqNum() As Integer, ActualSeqSize() As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno, MissingData() As Byte, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer)

Dim FirstStepNo As Long, SSN As Long, OSN As Long, CurSeed As Long, BoundsMD() As Long, NumMD As Long, Y As Long, Y1 As Long, Y2 As Long, oNextno As Long, UB As Long, Z As Long, x As Long, oDirX As String, Pos As Long, FF As Long, EListNum As Long, TELong As Long, TEString As String
Dim UB1 As Long, UB2 As Long, g As Long

FirstStepNo = StepNo





Redo:
'For x = PermNextno To Nextno
Steps(0, StepNo) = 6 'this erases all sequences with numbers above permnextno by resetting nextno to permnextno
Steps(4, StepNo) = SEventNumber + 1
StepNo = StepNo + 1
UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

'This is test code to see whether restoring seqnum and missingdata outside of this exclude
'group will reveal more hidden signals
Dim RedoAllDists As Long
RedoAllDists = 0
If x = x Then
    'reset seqnum and modseqnum to state of first addsomeexcludes
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SMDrop" + UFTag For Binary As #FF
    If FirstAddSome = 0 Then
        FirstAddSome = 1
        UB1 = UBound(SeqNum, 1)
        UB2 = UBound(SeqNum, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , SeqNum()
        UB1 = UBound(MissingData, 1)
        UB2 = UBound(MissingData, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , MissingData()
        
        
    Else
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim SeqNum(UB1, UB2)
        Get #FF, , SeqNum()
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim MissingData(UB1, UB2)
        Get #FF, , MissingData()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    RedoAllDists = 1
ElseIf x = 123456 Then
 
    RedoAllDists = 1
    'Dim tSeqNum() As Integer
    'ReDim tSeqNum(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
        Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
    End If
    ReDim MissingData(Len(StrainSeq(0)), PermNextno + 1)
    'now add missingdata and indels back to the seed sequence
    For x = 0 To PermNextno
        If DoneExcludes(x) = 0 Then
            If x <= UBound(ExcludeCoords) Then
                If ExcludeCoords(x) > 0 Then
                    CurSeed = x
                    Exit For
                End If
            End If
        End If
    Next x
    If x = x Then 'edit the anchor sequence
        For x = 1 To StepNo - 1
            If Steps(0, x) = 2 Then
                If Steps(1, x) = CurSeed Then
                    Dummy = ModSeqNumE(PermNextno, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
                    'tRedoDist(Steps(1, x)) = 1
                End If
            End If
        Next x
    End If
End If





UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

NextNo = PermNextno
'Next x
BusyWithExcludes = 1


ReDim BoundsMD(Len(StrainSeq(0)), 1)
NumMD = 0
Dim GoOn As Byte
'erase any sequences >permenxtno


NextNo = PermNextno
oNextno = NextNo
Dim SSBak() As Long
ReDim SSBak(Len(StrainSeq(0)))
GoOn = 0
Dim EPosX As Long, BreakB As Long, BreakE As Long, DSX As Long

For x = 0 To PermNextno
'     If x = 97 Then
'            x = x
'        End If
    If DoneExcludes(x) = 0 And MaskSeq(x) = 0 Then
       
        If x <= UBound(ExcludeCoords) Then
            If ExcludeCoords(x) > 0 Then
'                Open "progress.txt" For Append As #20
'                Print #20, SEventNumber, "exrras", x
'                Close #20
                'establish boundaries of missing data in sequence X
                CurSeed = x
                
                For Y1 = 0 To Len(StrainSeq(0))
                    If MissingData(Y1, x) = 1 Then
                        For Y2 = Y1 + 1 To Len(StrainSeq(0))
                            If MissingData(Y2, x) = 0 Then
                                Y2 = Y2 - 1
                                Exit For
                            End If
                        Next Y2
                        BoundsMD(NumMD, 0) = Y1
                        BoundsMD(NumMD, 1) = Y2
                        NumMD = NumMD + 1
                        Y1 = Y2
                    End If
                Next Y1
                Pos = ExcludeCoords(x)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                Get #FF, Pos, EListNum
                'now add these elistnnum sequences to the alignment and record the edits in the steps array
                ReDim OSNPos(NextNo + EListNum)
                
                For Z = 1 To EListNum
                    GoOn = 1
                    NextNo = NextNo + 1
                    If NextNo > UBound(GrpMaskSeq, 1) Or NextNo > UBound(OriginalName, 1) Or NextNo > UBound(TraceSub, 1) Or NextNo > UBound(MaskSeq, 1) Then
                        ReDim Preserve TraceSub(NextNo + 50), OriginalName(NextNo + 50), StraiName(NextNo + 50), MaskSeq(NextNo + 50)
                        ReDim Preserve GrpMaskSeq(NextNo + 50)
                    End If
                    If NextNo > UBound(OriginalPos, 1) Then
                        ReDim Preserve OriginalPos(NextNo + 50)
                    End If
                    TraceSub(NextNo) = x
                    
                    MaskSeq(NextNo) = 0
                    EPosX = Seek(FF) 'remember the position of this specific sequence
                    Get #FF, , SSN 'Original number of the sequence that this unexcluded sequence this sequence is most similar to
                    Get #FF, , OSN 'original seq number
'                    If OSN = 6709 Then
'                        x = x
'                        '258
'                        For BBx = 0 To NextnoBak
'                            If OriginalPos(BBx) = 4541 Then
'                                x = x
'                            End If
'                        Next BBx
'                    End If
                    OSNPos(NextNo) = OSN
                    Get #FF, , TELong 'discard number
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'originalname
                    XX = SEventNumber
                    OriginalName(NextNo) = TEString
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString
                    StraiName(NextNo) = TEString 'strainame
                    Get #FF, , TELong 'seqeunec length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'sequence
                    'XX = SEventNumber
                    
                    If UBound(SeqNum, 2) < NextNo Then
                        ReDim Preserve SeqNum(UBound(SeqNum, 1), NextNo + 10)
                    End If
                    'copy the sequence into the nextno slot
                    
                    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                    'there is sequence compression and the loaded sequence needs to be modified accordingly
                       TEString = CompressTEString(Decompress(), TEString)
                    End If
                    
                    Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), TEString, SSBak(0))
                    ReDim Preserve StrainSeq(NextNo)
                    StrainSeq(NextNo) = TEString
                    'this is the original sequence that gets copied into seqnum so it must be edited to account for
                    'all recombination event that were previously inferred for this sequence
                    Steps(0, StepNo) = 1 'ie create a new sequence ....
'                    If x = 159 Then
'                        x = x
'                    End If
                    Steps(1, StepNo) = x 'using this seqence as the source of the current exclude
                    Steps(2, StepNo) = -EPosX 'the specific excluded sequence (the negative will indicate to modseqnum that the additional sequence is from the excludelist
                    Steps(3, StepNo) = 0 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                    'XX = UBound(SeqNum, 1)
                    If NextNo > UBound(MissingData, 2) Then
                        ReDim Preserve MissingData(UBound(MissingData, 1), NextNo)
                    End If
'                    If SEventNumber = 9 Then
'                        x = x
'                    End If
                    For Y1 = 1 To Len(StrainSeq(0))
                        MissingData(Y1, NextNo) = 0
                    Next Y1
                    'For G = 0 To ExcludedEventNum
                    
                    '    If EventsInExcludeds(3, G) = CurSeed Then
                            For Y = 0 To NumMD - 1
                                If BoundsMD(Y, 1) > Len(StrainSeq(0)) Then BoundsMD(Y, 1) = Len(StrainSeq(0))
                                If BoundsMD(Y, 0) > Len(StrainSeq(0)) Then BoundsMD(Y, 0) = Len(StrainSeq(0))
                                
                                For Y1 = BoundsMD(Y, 0) To BoundsMD(Y, 1)
                                    SeqNum(Y1, NextNo) = 46
                                    MissingData(Y1, NextNo) = 1
                                Next Y1
                                
                                Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                                Steps(1, StepNo) = NextNo  'from this seqence.....
                                Steps(2, StepNo) = BoundsMD(Y, 0) 'from this position....
                                Steps(3, StepNo) = BoundsMD(Y, 1) 'to this position....
                                Steps(4, StepNo) = SEventNumber + 1
                               
                                StepNo = StepNo + 1
                                
                                UB = UBound(Steps, 2)
                                If StepNo > UB Then
                                    ReDim Preserve Steps(4, UB + 100)
                                End If
                            
                            Next Y
                        'End If
                    'Next G
                    
                    
                Next Z
                Close #FF
                ChDrive oDirX
                ChDir oDirX
                '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                'This could be a rescan
                'Need to check the the already accepted events in bestxolist to see if any of the
                'current batch of added in excludes contain sequences in that list
                'basically I need to search bestxolist for matches to the seed sequence where the .beginp property is <0
                'I then simply check if the .daughter is >permnextno and, if so,
                'add in an edit to that sequence and record the edit in steps
                ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                For Y = 1 To BCurrentXOver(CurSeed)
                    If BestXOList(CurSeed, Y).BeginP < 0 Then
                        If BestXOList(CurSeed, Y).Daughter > PermNextno Then
                             DSX = BestXOList(CurSeed, Y).Daughter
                             BreakB = BestXOList(CurSeed, Y).Beginning
                             BreakE = BestXOList(CurSeed, Y).Ending
                             Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                             Steps(1, StepNo) = DSX  'from this seqence.....
                             Steps(2, StepNo) = BreakB 'from this position....
                             Steps(3, StepNo) = BreakE 'to this position....
                             Steps(4, StepNo) = SEventNumber + 1
                            
                             StepNo = StepNo + 1
                             
                             UB = UBound(Steps, 2)
                             If StepNo > UB Then
                                 ReDim Preserve Steps(4, UB + 100)
                             End If
                             
                             If BreakB < BreakE Then
                                For Z = BreakB To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             Else
                                For Z = BreakB To Len(StrainSeq(0))
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                                For Z = 1 To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             
                             End If
                             
                        End If
                    End If
                Next Y
                
                
                
                DoneExcludes(x) = 1
                Exit For
            
            End If
            
           
        End If
    End If
Next x
If GoOn = 0 Then
    DoExcludes = 0
    
    Exit Sub
End If

ReDim CurrentXOver(NextNo), XoverList(NextNo, XOverListSize)


'Dummy = MakeActualSeqSize(Len(StrainSeq(0)), Nextno, WinPP, RNum(0), RList(0, 0), ActualSeqSize(0), SeqNum(0, 0))
ReDim Preserve ActualSeqSize(NextNo)
For x = oNextno + 1 To NextNo
    ActualSeqSize(x) = 0
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 46 Then ActualSeqSize(x) = ActualSeqSize(x) + 1
    Next Y
Next x
'XX = Nextno
'XX = ActualSeqSize(53)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'need to mimic everything in dordp up to the innerscan call
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If QvRFlag = 1 Then
    ReDim Preserve ReferenceList(NextNo)
End If
'Update the treedistance used for RDP and SiScan
ReDim TreeDistance(NextNo, NextNo)



Dim TDiffs() As Single, TValid() As Single, Uninvolved() As Long
ReDim Uninvolved(NextNo)
For x = 0 To NextNo
    Uninvolved(x) = 1
Next x


If PermNextno > MemPoc Then
    
    GetPermDiffs
'    XX = ActualSeqSize(3)
'    XX = Uninvolved(3)
    ReDim TDiffs(NextNo, NextNo)
    
    Dummy = MakeTDiffs2(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), PermDIffs(0, 0), Uninvolved(0), ActualSeqSize(0))
   
'    XX = TDiffs(3, 1)
'    XX = TDiffs(0, 1)
'    XX = PermDiffs(3, 1)
    ReDim PermDIffs(0, 0)
    
    GetPermValid
    
    'XX = PermValid(0, 1)
'    XX = Uninvolved(0)
'    XX = Uninvolved(1)
    ReDim TValid(NextNo, NextNo)
    
    Dummy = MakeTDiffs3(NextNo, UBound(PermValid, 1), TValid(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
    
'    XX = TValid(1, 0)
'    XX = PermValid(0, 1)
    ReDim PermValid(0, 0)
Else
    ReDim TDiffs(NextNo, NextNo), TValid(NextNo, NextNo)
     
    Dummy = MakeTDiffs(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), TValid(0, 0), PermDIffs(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
'XX = oNextno
End If

'XX = TValid(0, 1)
ReDim Distance(NextNo, NextNo)
AvDst = 0
Dim tRedoDist() As Integer, Invert(1) As Byte
Invert(0) = 1
Invert(1) = 0
ReDim tRedoDist(NextNo)
If RedoAllDists = 0 Then
    For x = oNextno + 1 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
Else
    For x = 0 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
End If
    
Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, TDiffs(), TValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
    
ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo)
Dummy = FinishDists2(NextNo, PermValid(0, 0), PermDIffs(0, 0), TValid(0, 0), TDiffs(0, 0), Distance(0, 0))


If PermNextno > MemPoc And x = 1234567 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    UBDistance = UBound(Distance, 1)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Put #FF, , Distance()
    Close #FF
    DistanceInFileFlag = 1
    ReDim Distance(0, 0)
    ChDir oDir
    ChDrive oDir
End If
    

If PermNextno > MemPoc Then
    Call PutPermValid
    Call PutPermDiffs
    'ReDim PermDiffs(0, 0)
    'ReDim PermValid(0, 0)
End If


Erase TDiffs
Erase TValid

DistanceFlag = 1
TreeDistFlag = 0

Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
'XX = TreeDistance(1, 0)
DoEvents

Dim DP() As Byte
ReDim DP(NextNo, NextNo)
If x = 123456 Then
'    For x = 0 To Nextno
'
'    For Y = 0 To Nextno
'        If TreeDistance(x, Y) <> 0 Then
'            x = x
'        End If
'
'    Next Y
'
'    Next x
    'find a phylogenetically representative selection of sequences in the includes that must be compared with the excludes in the
    'last recombination screen loops at the end - these are specified with the DP arrays
    Dim Seq1List() As Long, TV As Single, SL As Long, Longest As Long, DS() As Byte
    ReDim Seq1List(NextNo), DS(NextNo)
    SL = -1
    Seq1List(0) = CurSeed
    DS(CurSeed) = 1
    For x = 0 To oNextno - 1
        If DS(x) = 0 Then
            DS(x) = 1
            SL = SL + 1
            Longest = ActualSeqSize(x)
            Seq1List(SL) = x
            TV = TreeDistance(CurSeed, x)
            For Y = x + 1 To oNextno
                If DS(Y) = 0 Then
                    If TreeDistance(CurSeed, Y) = TV Then
                        DS(Y) = 1
                        If Longest < ActualSeqSize(Y) Then
                            Longest = ActualSeqSize(Y)
                            Seq1List(SL) = Y
                        End If
                    End If
                End If
            Next Y
        End If
        
    Next x
    For x = 0 To SL
        For Y = oNextno + 1 To NextNo
            DP(Seq1List(x), Y) = 1
            DP(Y, Seq1List(x)) = 1
        Next Y
    Next x
'    For x = 0 To oNextno
'        For Y = oNextno + 1 To Nextno
'            DP(x, Y) = 1
'            DP(Y, x) = 1
'        Next Y
'    Next x
End If
If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        
    End If
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        Erase TreeX
    End If
    ChDrive oDirX
    ChDir oDirX
End If

Dim tMaskseq() As Byte
ReDim tMaskseq(NextNo)

If MaskThresh = 0 Then
    Dim Correx, AA
    AA = x
    
    Correx = MCCorrection * (Len(StrainSeq(0)) / XOverWindowX)
    
    'If LowestProb = 0 Then LowestProb = 0.05
    Correx = LowestProb / Correx
    Correx = 1 / Correx
    Correx = Log(Correx) / Log(4)
 'XX = (2 * Log(4 * X))
    'Y = (2 * Log(4 * X)) / Len(StrainSeq(0))
     MaskThresh = Correx / Len(StrainSeq(0))
     MaskThresh = MaskThresh / 3
End If

If MaskThresh > 0 Then
    'mask sequences that are almost identical
    For x = 0 To PermNextno
        tMaskseq(x) = MaskSeq(x)
    Next x
    For x = oNextno To NextNo
        If ((1 - Distance(x, CurSeed)) < MaskThresh) Then
            tMaskseq(x) = 1
        Else
            If tMaskseq(x) = 0 Then
                For Y = x + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        If ((1 - Distance(x, Y)) < MaskThresh) Then
                            If ActualSeqSize(x) < ActualSeqSize(Y) Then
                                tMaskseq(x) = 1
                            
                            Else
                                tMaskseq(Y) = 1
                            End If
                            x = oNextno - 1
                            Exit For
                        End If
                    End If
                Next Y
            End If
        End If
    Next x
End If


SSSss = Abs(GetTickCount)
UseCompress = 1
Call MakeScanCompressArrays(NextNo, SeqNum())
EE = Abs(GetTickCount)
TT = EE - SSSss
'first scan all the excludes against one another and one of the includes
Dim SP As Long, oDWS As Byte
oDWS = DontWorryAboutSplitsFlag
DontWorryAboutSplitsFlag = 1
Dim STartT As Variant
STartT = Abs(GetTickCount)

If DoScans(0, 0) = 1 Then
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Prefilter which pairs of includes to bother with here using the fastrecchecks and a very high p-val cutoff to look for
'instances where, curseed and one of the excludes when scanned against one of the includes yields even a very marginally significant p-value.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'UCThresh = 1
Dim BotherWith() As Byte, AtLeastOne As Byte
ReDim BotherWith(NextNo)

LowestProb = pLowestProb
'If CurSeed = 6 Then
'    x = x
'End If
If x = 12345 Then
    
        'Make a seq1 list that samples the logest sequence off every branch below curseed
        
        
        UCThresh = LowestProb / (MCCorrection / 10000)
        If UCThresh > 0.05 Then UCThresh = 0.05
        AtLeastOne = 0
        EarlyBale = 1
'        For x = 0 To oNextno
'            BotherWith(x) = 1
'        Next x
        
        Seq1 = CurSeed
'        For x = 0 To SL
'            Seq1 = Seq1List(x)
            For Seq2 = 0 To oNextno
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = oNextno + 1 To NextNo
                            If Seq1 <> Seq2 And tMaskseq(Seq3) = 0 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
                                            
                                            For x = oNextno + 1 To NextNo
                                                DP(x, Seq2) = 1
                                                DP(Seq2, x) = 1
                                            Next x
                                            
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            Exit For
                                        End If
                                    End If
                                End If
                            End If
                        Next Seq3
                    End If
                
            Next Seq2
             For Seq2 = oNextno + 1 To NextNo - 1
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = Seq2 + 1 To NextNo
                            'If Seq1 <> Seq3 And Seq2 <> Seq3 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize And tMaskseq(Seq3) = 0 Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
'                                            If x <= oNextno And BotherWith(Seq3) = 0 Then
'                                                For x = oNextno + 1 To Nextno
'                                                    DP(x, Seq3) = 1
'                                                    DP(Seq3, x) = 1
'                                                Next x
'                                            End If
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            'Exit For
                                        End If
                                    End If
                                End If
                            'End If
                        Next Seq3
                    End If
                
            Next Seq2
        'Next x
        EarlyBale = 0
        For x = oNextno + 1 To NextNo
            DP(CurSeed, x) = 1
            DP(x, CurSeed) = 1
        Next x
        

Else
    AtLeastOne = 1
    For x = oNextno + 1 To NextNo
        BotherWith(x) = 1
    Next x
End If


'XX = Nextno - oNextno

'AtLeastOne = 1
'For x = 0 To Nextno
'   BotherWith(x) = 1
'Next x


If x = x Then
    Dim TP() As Byte
        ReDim DP(NextNo, NextNo), TP(NextNo, NextNo)
        For x = 0 To NextNo
            If tMaskseq(x) = 0 Then
                For Y = oNextno + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        TP(x, Y) = 1
                        'TP(Y, X) = 1
                    End If
                Next Y
            End If
        Next x
        Call FastRecCheckGC(NextNo, 0.05, DP(), SeqNum(), TP(), tMaskseq())
        'Call FastRecCheckGC(Nextno, 0.5, DP(), SeqNum(), TP(), tMaskseq())
        
    For Seq1 = 0 To oNextno '0 To oNextno
        'if I let other sequences in besides curseed here it is very difficult to properly group recombinants
        'Also, The way it was it was possible to get all three signal sequences from this exclude list cluster.
        If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
           
            For Seq2 = oNextno + 1 To NextNo - 1
                'If BotherWith(Seq2) = 1 Or x = x Then
                    If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
                        If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
                            For Seq3 = Seq2 + 1 To NextNo
                                If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 And (DP(Seq3, Seq2) + DP(Seq3, Seq1) + DP(Seq2, Seq1) > 0) Then
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                        If PermDIffs(Seq2, Seq3) > 2 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                NewOneFound = 0
                                                ActualFound = 0
                                                If DoScans(0, 0) = 1 Then
                                                                
                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                If NewOneFound = 1 Then
                                                    DP(Seq3, Seq1) = 1
                                                    DP(Seq1, Seq3) = 1
                                                    DP(Seq2, Seq1) = 1
                                                    DP(Seq1, Seq2) = 1
                                                End If
                                            'End If
                                        End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                'End If
            Next Seq2
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                GlobalTimer = SS
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        End If
    
    Next Seq1
End If


If AtLeastOne > 0 Then
        tSS = Abs(GetTickCount)
        
        
        
        '''For T = 1 To 10
'        For x = 0 To oNextno
'            For Y = oNextno + 1 To Nextno
'                If DP(x, Y) > 0 Then
'                    BotherWith(x) = 1
'                    Exit For
'                End If
'            Next Y
'        Next x
'        For x = 0 To oNextno
'            If BotherWith(x) = 0 Then
'                x = x
'            End If
'        Next x
    Dim UBPV2 As Long
    UBPV2 = UBound(PermValid, 2)
        For Seq1 = 0 To oNextno - 1
            If Seq1 <= UBPV2 And tMaskseq(Seq1) = 0 Then ' And BotherWith(Seq1) = 1 Then
                For Seq2 = Seq1 + 1 To oNextno
                    If Seq2 <= UBPV2 And tMaskseq(Seq2) = 0 Then
        '                 If Seq2 = 142 And Seq1 = 112 Then
        '                    x = x
        '                 End If
                        If PermValid(Seq1, Seq2) > MinSeqSize Then 'And BotherWith(Seq2) = 1 Then
        '                    NN = 0
        '                    XX = (PermNextno - Nextno)
                            For Seq3 = oNextno + 1 To NextNo
                                
                                If tMaskseq(Seq3) = 0 And BotherWith(Seq3) = 1 Then
                                    'NN = NN + 1
                                    '@'@
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize And (DP(Seq1, Seq3) + DP(Seq2, Seq3) > 1) Then

                                        'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                 
                                                If DoScans(0, 0) = 1 Then
                                                     '@'@'@
                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                '@
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                
                                            'End If
                                        'End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                    x = x
                Next Seq2
            End If
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    '@
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng(250 + ((Seq1 / (oNextno + 1)) * 750)) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        Next Seq1
        
        ess = Abs(GetTickCount)
        TotASET = TotASET + Abs(ess - tSS)
   ' End If
End If
DontWorryAboutSplitsFlag = oDWS
Dim NumNew
NumNew = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        NumNew = NumNew + 1
'        XX = XoverList(x, Y).Daughter '7
'        XX = XoverList(x, Y).MajorP '15
'        XX = XoverList(x, Y).MinorP '9
        'XoverList(x, Y).BeginP = -100
        If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
        ElseIf XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        'XX = XoverList(x, Y).EndP '0
        End If
    Next Y
Next x

'For x = 0 To Nextno
'    If ActualSeqSize(x) = 0 Then
'        x = x
'    End If
'Next x
UseCompress = 0

SS = Abs(GetTickCount)
If Abs(SS - LS) > 500 Then
    LS = SS
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined"
    DoEvents
End If
For x = 0 To AddNum - 1
    MethodTime(x) = MethodTime(x) + Abs(SS - STartT) * TimeFract(x)
Next x
CurSeedExtras = CurSeed
If NumNew = 0 Then
    x = x
    StepNo = FirstStepNo 'StepNo - 1
    GoTo Redo
Else
    x = x
End If

End Sub
Public Sub AddSomeExcludesOlder(TraceSub() As Long, MinSeqSize, NextNo As Long, SeqNum() As Integer, ActualSeqSize() As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte, BackUpNextno, MissingData() As Byte, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer)

Dim FirstStepNo As Long, SSN As Long, OSN As Long, CurSeed As Long, BoundsMD() As Long, NumMD As Long, Y As Long, Y1 As Long, Y2 As Long, oNextno As Long, UB As Long, Z As Long, x As Long, oDirX As String, Pos As Long, FF As Long, EListNum As Long, TELong As Long, TEString As String
Dim UB1 As Long, UB2 As Long, g As Long

FirstStepNo = StepNo





Redo:
ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + (CLng(MCWinSize / 2)) * 2, 2) ' 0=s1,s2Matches etc
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + (CLng(MCWinSize / 2)) * 2)

'For x = PermNextno To Nextno
Steps(0, StepNo) = 6 'this erases all sequences with numbers above permnextno by resetting nextno to permnextno
Steps(4, StepNo) = SEventNumber + 1
StepNo = StepNo + 1
UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

'This is test code to see whether restoring seqnum and missingdata outside of this exclude
'group will reveal more hidden signals
Dim RedoAllDists As Long
RedoAllDists = 0
If x = x Then
    'reset seqnum and modseqnum to state of first addsomeexcludes
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SMDrop" + UFTag For Binary As #FF
    If FirstAddSome = 0 Then
        FirstAddSome = 1
        UB1 = UBound(SeqNum, 1)
        UB2 = UBound(SeqNum, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , SeqNum()
        UB1 = UBound(MissingData, 1)
        UB2 = UBound(MissingData, 2)
        Put #FF, , UB1
        Put #FF, , UB2
        Put #FF, , MissingData()
        
        
    Else
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim SeqNum(UB1, UB2)
        Get #FF, , SeqNum()
        
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim MissingData(UB1, UB2)
        Get #FF, , MissingData()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    RedoAllDists = 1
ElseIf x = 123456 Then
 
    RedoAllDists = 1
    'Dim tSeqNum() As Integer
    'ReDim tSeqNum(Len(StrainSeq(0)), PermNextno)
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim Preserve SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
    Else
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim SeqNum(Len(StrainSeq(0)), PermNextno + 1)
        On Error GoTo 0
        Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
    End If
    ReDim MissingData(Len(StrainSeq(0)), PermNextno + 1)
    'now add missingdata and indels back to the seed sequence
    For x = 0 To PermNextno
        If DoneExcludes(x) = 0 Then
            If x <= UBound(ExcludeCoords) Then
                If ExcludeCoords(x) > 0 Then
                    CurSeed = x
                    Exit For
                End If
            End If
        End If
    Next x
    If x = x Then 'edit the anchor sequence
        For x = 1 To StepNo - 1
            If Steps(0, x) = 2 Then
                If Steps(1, x) = CurSeed Then
                    Dummy = ModSeqNumE(PermNextno, Len(StrainSeq(0)), Steps(1, x), Steps(2, x), Steps(3, x), SeqNum(0, 0), MissingData(0, 0))
                    'tRedoDist(Steps(1, x)) = 1
                End If
            End If
        Next x
    End If
End If





UB = UBound(Steps, 2)
If StepNo > UB Then
    ReDim Preserve Steps(4, UB + 100)
End If

NextNo = PermNextno
'Next x
BusyWithExcludes = 1


ReDim BoundsMD(Len(StrainSeq(0)), 1)
NumMD = 0
Dim GoOn As Byte
'erase any sequences >permenxtno


NextNo = PermNextno
oNextno = NextNo
Dim SSBak() As Long
ReDim SSBak(Len(StrainSeq(0)))
GoOn = 0
Dim EPosX As Long, BreakB As Long, BreakE As Long, DSX As Long

For x = 0 To PermNextno
'     If x = 97 Then
'            x = x
'        End If
    If DoneExcludes(x) = 0 And MaskSeq(x) = 0 Then
       
        If x <= UBound(ExcludeCoords) Then
            If ExcludeCoords(x) > 0 Then
'                Open "progress.txt" For Append As #20
'                Print #20, SEventNumber, "exrras", x
'                Close #20
                'establish boundaries of missing data in sequence X
                CurSeed = x
                
                For Y1 = 0 To Len(StrainSeq(0))
                    If MissingData(Y1, x) = 1 Then
                        For Y2 = Y1 + 1 To Len(StrainSeq(0))
                            If MissingData(Y2, x) = 0 Then
                                Y2 = Y2 - 1
                                Exit For
                            End If
                        Next Y2
                        BoundsMD(NumMD, 0) = Y1
                        BoundsMD(NumMD, 1) = Y2
                        NumMD = NumMD + 1
                        Y1 = Y2
                    End If
                Next Y1
                Pos = ExcludeCoords(x)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                Get #FF, Pos, EListNum
                'now add these elistnnum sequences to the alignment and record the edits in the steps array
                ReDim OSNPos(NextNo + EListNum)
                
                For Z = 1 To EListNum
                    GoOn = 1
                    NextNo = NextNo + 1
                    If NextNo > UBound(GrpMaskSeq, 1) Or NextNo > UBound(OriginalName, 1) Or NextNo > UBound(TraceSub, 1) Or NextNo > UBound(MaskSeq, 1) Then
                        ReDim Preserve TraceSub(NextNo + 50), OriginalName(NextNo + 50), StraiName(NextNo + 50), MaskSeq(NextNo + 50)
                        ReDim Preserve GrpMaskSeq(NextNo + 50)
                    End If
                    If NextNo > UBound(OriginalPos, 1) Then
                        ReDim Preserve OriginalPos(NextNo + 50)
                    End If
                    TraceSub(NextNo) = x
                    
                    MaskSeq(NextNo) = 0
                    EPosX = Seek(FF) 'remember the position of this specific sequence
                    Get #FF, , SSN 'Original number of the sequence that this unexcluded sequence this sequence is most similar to
                    Get #FF, , OSN 'original seq number
'                    If OSN = 6709 Then
'                        x = x
'                        '258
'                        For BBx = 0 To NextnoBak
'                            If OriginalPos(BBx) = 4541 Then
'                                x = x
'                            End If
'                        Next BBx
'                    End If
                    OSNPos(NextNo) = OSN
                    Get #FF, , TELong 'discard number
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'originalname
                    XX = SEventNumber
                    OriginalName(NextNo) = TEString
                    Get #FF, , TELong 'name length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString
                    StraiName(NextNo) = TEString 'strainame
                    Get #FF, , TELong 'seqeunec length
                    TEString = String(TELong, " ")
                    Get #FF, , TEString 'sequence
                    'XX = SEventNumber
                    
                    If UBound(SeqNum, 2) < NextNo Then
                        ReDim Preserve SeqNum(UBound(SeqNum, 1), NextNo + 10)
                    End If
                    'copy the sequence into the nextno slot
                    
                    If Decompress(Len(StrainSeq(0))) <> Len(StrainSeq(0)) Then
                    'there is sequence compression and the loaded sequence needs to be modified accordingly
                       TEString = CompressTEString(Decompress(), TEString)
                    End If
                    
                    Dummy = CopyString(Len(StrainSeq(0)), SeqNum(0, NextNo), TEString, SSBak(0))
                    ReDim Preserve StrainSeq(NextNo)
                    StrainSeq(NextNo) = TEString
                    'this is the original sequence that gets copied into seqnum so it must be edited to account for
                    'all recombination event that were previously inferred for this sequence
                    Steps(0, StepNo) = 1 'ie create a new sequence ....
'                    If x = 159 Then
'                        x = x
'                    End If
                    Steps(1, StepNo) = x 'using this seqence as the source of the current exclude
                    Steps(2, StepNo) = -EPosX 'the specific excluded sequence (the negative will indicate to modseqnum that the additional sequence is from the excludelist
                    Steps(3, StepNo) = 0 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                    'XX = UBound(SeqNum, 1)
                    If NextNo > UBound(MissingData, 2) Then
                        ReDim Preserve MissingData(UBound(MissingData, 1), NextNo)
                    End If
'                    If SEventNumber = 9 Then
'                        x = x
'                    End If
                    For Y1 = 1 To Len(StrainSeq(0))
                        MissingData(Y1, NextNo) = 0
                    Next Y1
                    'For G = 0 To ExcludedEventNum
                    
                    '    If EventsInExcludeds(3, G) = CurSeed Then
                            For Y = 0 To NumMD - 1
                                If BoundsMD(Y, 1) > Len(StrainSeq(0)) Then BoundsMD(Y, 1) = Len(StrainSeq(0))
                                If BoundsMD(Y, 0) > Len(StrainSeq(0)) Then BoundsMD(Y, 0) = Len(StrainSeq(0))
                                
                                For Y1 = BoundsMD(Y, 0) To BoundsMD(Y, 1)
                                    SeqNum(Y1, NextNo) = 46
                                    MissingData(Y1, NextNo) = 1
                                Next Y1
                                
                                Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                                Steps(1, StepNo) = NextNo  'from this seqence.....
                                Steps(2, StepNo) = BoundsMD(Y, 0) 'from this position....
                                Steps(3, StepNo) = BoundsMD(Y, 1) 'to this position....
                                Steps(4, StepNo) = SEventNumber + 1
                               
                                StepNo = StepNo + 1
                                
                                UB = UBound(Steps, 2)
                                If StepNo > UB Then
                                    ReDim Preserve Steps(4, UB + 100)
                                End If
                            
                            Next Y
                        'End If
                    'Next G
                    
                    
                Next Z
                Close #FF
                ChDrive oDirX
                ChDir oDirX
                '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                'This could be a rescan
                'Need to check the the already accepted events in bestxolist to see if any of the
                'current batch of added in excludes contain sequences in that list
                'basically I need to search bestxolist for matches to the seed sequence where the .beginp property is <0
                'I then simply check if the .daughter is >permnextno and, if so,
                'add in an edit to that sequence and record the edit in steps
                ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                For Y = 1 To BCurrentXOver(CurSeed)
                    If BestXOList(CurSeed, Y).BeginP < 0 Then
                        If BestXOList(CurSeed, Y).Daughter > PermNextno Then
                             DSX = BestXOList(CurSeed, Y).Daughter
                             BreakB = BestXOList(CurSeed, Y).Beginning
                             BreakE = BestXOList(CurSeed, Y).Ending
                             Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
                             Steps(1, StepNo) = DSX  'from this seqence.....
                             Steps(2, StepNo) = BreakB 'from this position....
                             Steps(3, StepNo) = BreakE 'to this position....
                             Steps(4, StepNo) = SEventNumber + 1
                            
                             StepNo = StepNo + 1
                             
                             UB = UBound(Steps, 2)
                             If StepNo > UB Then
                                 ReDim Preserve Steps(4, UB + 100)
                             End If
                             
                             If BreakB < BreakE Then
                                For Z = BreakB To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             Else
                                For Z = BreakB To Len(StrainSeq(0))
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                                For Z = 1 To BreakE
                                    SeqNum(Z, DSX) = 46
                                    MissingData(Z, DSX) = 1
                                Next Z
                             
                             End If
                             
                        End If
                    End If
                Next Y
                
                
                
                DoneExcludes(x) = 1
                Exit For
            
            End If
            
           
        End If
    End If
Next x
If GoOn = 0 Then
    DoExcludes = 0
    
    Exit Sub
End If

ReDim CurrentXOver(NextNo), XoverList(NextNo, XOverListSize)


'Dummy = MakeActualSeqSize(Len(StrainSeq(0)), Nextno, WinPP, RNum(0), RList(0, 0), ActualSeqSize(0), SeqNum(0, 0))
ReDim Preserve ActualSeqSize(NextNo)
For x = oNextno + 1 To NextNo
    ActualSeqSize(x) = 0
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 46 Then ActualSeqSize(x) = ActualSeqSize(x) + 1
    Next Y
Next x
'XX = Nextno
'XX = ActualSeqSize(53)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'need to mimic everything in dordp up to the innerscan call
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If QvRFlag = 1 Then
    ReDim Preserve ReferenceList(NextNo)
End If
'Update the treedistance used for RDP and SiScan
ReDim TreeDistance(NextNo, NextNo)



Dim TDiffs() As Single, TValid() As Single, Uninvolved() As Long
ReDim Uninvolved(NextNo)
For x = 0 To NextNo
    Uninvolved(x) = 1
Next x


If PermNextno > MemPoc Then
    
    GetPermDiffs
'    XX = ActualSeqSize(3)
'    XX = Uninvolved(3)
    ReDim TDiffs(NextNo, NextNo)
    
    Dummy = MakeTDiffs2(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), PermDIffs(0, 0), Uninvolved(0), ActualSeqSize(0))
   
'    XX = TDiffs(3, 1)
'    XX = TDiffs(0, 1)
'    XX = PermDiffs(3, 1)
    ReDim PermDIffs(0, 0)
    
    GetPermValid
    
    'XX = PermValid(0, 1)
'    XX = Uninvolved(0)
'    XX = Uninvolved(1)
    ReDim TValid(NextNo, NextNo)
    
    Dummy = MakeTDiffs3(NextNo, UBound(PermValid, 1), TValid(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
    
'    XX = TValid(1, 0)
'    XX = PermValid(0, 1)
    ReDim PermValid(0, 0)
Else
    ReDim TDiffs(NextNo, NextNo), TValid(NextNo, NextNo)
     
    Dummy = MakeTDiffs(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), TValid(0, 0), PermDIffs(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
'XX = oNextno
End If

'XX = TValid(0, 1)
ReDim Distance(NextNo, NextNo)
AvDst = 0
Dim tRedoDist() As Integer, Invert(1) As Byte
Invert(0) = 1
Invert(1) = 0
ReDim tRedoDist(NextNo)
If RedoAllDists = 0 Then
    For x = oNextno + 1 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
Else
    For x = 0 To NextNo
        tRedoDist(x) = 1 'Invert(Uninvolved(x))
    Next x
End If
    
Call FastDistanceCalcZ(0, 0, 1, Len(StrainSeq(0)), NextNo, TDiffs(), TValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
    
ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo)
Dummy = FinishDists2(NextNo, PermValid(0, 0), PermDIffs(0, 0), TValid(0, 0), TDiffs(0, 0), Distance(0, 0))


If PermNextno > MemPoc And x = 1234567 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    UBDistance = UBound(Distance, 1)
    Open "RDP5Distance" + UFTag For Binary As #FF
    Put #FF, , Distance()
    Close #FF
    DistanceInFileFlag = 1
    ReDim Distance(0, 0)
    ChDir oDir
    ChDrive oDir
End If
    

If PermNextno > MemPoc Then
    Call PutPermValid
    Call PutPermDiffs
    'ReDim PermDiffs(0, 0)
    'ReDim PermValid(0, 0)
End If


Erase TDiffs
Erase TValid

DistanceFlag = 1
TreeDistFlag = 0

Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
'XX = TreeDistance(1, 0)
DoEvents

Dim DP() As Byte
ReDim DP(NextNo, NextNo)
If x = 123456 Then
'    For x = 0 To Nextno
'
'    For Y = 0 To Nextno
'        If TreeDistance(x, Y) <> 0 Then
'            x = x
'        End If
'
'    Next Y
'
'    Next x
    'find a phylogenetically representative selection of sequences in the includes that must be compared with the excludes in the
    'last recombination screen loops at the end - these are specified with the DP arrays
    Dim Seq1List() As Long, TV As Single, SL As Long, Longest As Long, DS() As Byte
    ReDim Seq1List(NextNo), DS(NextNo)
    SL = -1
    Seq1List(0) = CurSeed
    DS(CurSeed) = 1
    For x = 0 To oNextno - 1
        If DS(x) = 0 Then
            DS(x) = 1
            SL = SL + 1
            Longest = ActualSeqSize(x)
            Seq1List(SL) = x
            TV = TreeDistance(CurSeed, x)
            For Y = x + 1 To oNextno
                If DS(Y) = 0 Then
                    If TreeDistance(CurSeed, Y) = TV Then
                        DS(Y) = 1
                        If Longest < ActualSeqSize(Y) Then
                            Longest = ActualSeqSize(Y)
                            Seq1List(SL) = Y
                        End If
                    End If
                End If
            Next Y
        End If
        
    Next x
    For x = 0 To SL
        For Y = oNextno + 1 To NextNo
            DP(Seq1List(x), Y) = 1
            DP(Y, Seq1List(x)) = 1
        Next Y
    Next x
'    For x = 0 To oNextno
'        For Y = oNextno + 1 To Nextno
'            DP(x, Y) = 1
'            DP(Y, x) = 1
'        Next Y
'    Next x
End If
If PermNextno > MemPoc Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        
    End If
    If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
        TreeXUB = UBound(TreeX, 1)
        TreeXInFileFlag = 1
        Open "RDP5TreeX" + UFTag For Binary As #FF
        Put #FF, , TreeX()
        Close #FF
        Erase TreeX
    End If
    ChDrive oDirX
    ChDir oDirX
End If

Dim tMaskseq() As Byte
ReDim tMaskseq(NextNo)

If MaskThresh = 0 Then
    Dim Correx, AA
    AA = x
    
    Correx = MCCorrection * (Len(StrainSeq(0)) / XOverWindowX)
    
    'If LowestProb = 0 Then LowestProb = 0.05
    Correx = LowestProb / Correx
    Correx = 1 / Correx
    Correx = Log(Correx) / Log(4)
 'XX = (2 * Log(4 * X))
    'Y = (2 * Log(4 * X)) / Len(StrainSeq(0))
     MaskThresh = Correx / Len(StrainSeq(0))
     MaskThresh = MaskThresh / 3
End If

If MaskThresh > 0 Then
    'mask sequences that are almost identical
    For x = 0 To PermNextno
        tMaskseq(x) = MaskSeq(x)
    Next x
    For x = oNextno To NextNo
        If ((1 - Distance(x, CurSeed)) < MaskThresh) Then
            tMaskseq(x) = 1
        Else
            If tMaskseq(x) = 0 Then
                For Y = x + 1 To NextNo
                    If tMaskseq(Y) = 0 Then
                        If ((1 - Distance(x, Y)) < MaskThresh) Then
                            If ActualSeqSize(x) < ActualSeqSize(Y) Then
                                tMaskseq(x) = 1
                            
                            Else
                                tMaskseq(Y) = 1
                            End If
                            x = oNextno - 1
                            Exit For
                        End If
                    End If
                Next Y
            End If
        End If
    Next x
End If


SSSss = Abs(GetTickCount)
UseCompress = 1
Call MakeScanCompressArrays(NextNo, SeqNum())
EE = Abs(GetTickCount)
TT = EE - SSSss
'first scan all the excludes against one another and one of the includes
Dim SP As Long, oDWS As Byte
oDWS = DontWorryAboutSplitsFlag
DontWorryAboutSplitsFlag = 1
Dim STartT As Variant
STartT = Abs(GetTickCount)

If DoScans(0, 0) = 1 Then
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Prefilter which pairs of includes to bother with here using the fastrecchecks and a very high p-val cutoff to look for
'instances where, curseed and one of the excludes when scanned against one of the includes yields even a very marginally significant p-value.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'UCThresh = 1
Dim BotherWith() As Byte, AtLeastOne As Byte
ReDim BotherWith(NextNo)

LowestProb = pLowestProb
'If CurSeed = 6 Then
'    x = x
'End If
If x = x Then
    
        'Make a seq1 list that samples the logest sequence off every branch below curseed
        
        
        UCThresh = LowestProb / (MCCorrection / 10000)
        If UCThresh > 0.05 Then UCThresh = 0.05
        AtLeastOne = 0
        EarlyBale = 1
'        For x = 0 To oNextno
'            BotherWith(x) = 1
'        Next x
        
        Seq1 = CurSeed
'        For x = 0 To SL
'            Seq1 = Seq1List(x)
            For Seq2 = 0 To oNextno
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = oNextno + 1 To NextNo
                            If Seq1 <> Seq2 And tMaskseq(Seq3) = 0 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
                                            
                                            For x = oNextno + 1 To NextNo
                                                DP(x, Seq2) = 1
                                                DP(Seq2, x) = 1
                                            Next x
                                            
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            Exit For
                                        End If
                                    End If
                                End If
                            End If
                        Next Seq3
                    End If
                
            Next Seq2
             For Seq2 = oNextno + 1 To NextNo - 1
                
                    If PermValid(Seq1, Seq2) > MinSeqSize And tMaskseq(Seq2) = 0 Then
                        For Seq3 = Seq2 + 1 To NextNo
                            'If Seq1 <> Seq3 And Seq2 <> Seq3 Then
                                If PermValid(Seq1, Seq3) > MinSeqSize And tMaskseq(Seq3) = 0 Then
                                    If PermValid(Seq2, Seq3) > MinSeqSize Then
                                        GoOn = 0
                                        GoOn = FastRecCheck(NextNo, SeqNum(), Seq1, Seq2, Seq3, Len(StrainSeq(0)) + 1, XoverWindow, XOverWindowX, XoverSeqNum(), XoverSeqNumW())
                                        If GoOn = 0 Then
                                            GoOn = FastRecCheck2(NextNo, 0, 0, 0, PermDIffs(), XDiffPos(), XPosDiff(), SeqNum()) 'this is the maxchi check
                                        End If
                                        If GoOn = 1 Then
                                            
'                                            If x <= oNextno And BotherWith(Seq3) = 0 Then
'                                                For x = oNextno + 1 To Nextno
'                                                    DP(x, Seq3) = 1
'                                                    DP(Seq3, x) = 1
'                                                Next x
'                                            End If
                                            BotherWith(Seq2) = 1
                                            BotherWith(Seq3) = 1
                                            AtLeastOne = 1
                                            'Exit For
                                        End If
                                    End If
                                End If
                            'End If
                        Next Seq3
                    End If
                
            Next Seq2
        'Next x
        EarlyBale = 0
        For x = oNextno + 1 To NextNo
            DP(CurSeed, x) = 1
            DP(x, CurSeed) = 1
        Next x
        

Else
    AtLeastOne = 1
    For x = oNextno + 1 To NextNo
        BotherWith(x) = 1
    Next x
End If


'XX = Nextno - oNextno

'AtLeastOne = 1
'For x = 0 To Nextno
'   BotherWith(x) = 1
'Next x


If x = x Then

    For Seq1 = 0 To oNextno '0 To oNextno
        'if I let other sequences in besides curseed here it is very difficult to properly group recombinants
        'Also, The way it was it was possible to get all three signal sequences from this exclude list cluster.
        If Seq1 <= UBound(PermValid, 2) And tMaskseq(Seq1) = 0 Then
           
            For Seq2 = oNextno + 1 To NextNo - 1
                'If BotherWith(Seq2) = 1 Or x = x Then
                    If Seq2 <= UBound(PermValid, 2) And tMaskseq(Seq2) = 0 Then
                        If PermDIffs(Seq1, Seq2) > 2 And PermValid(Seq1, Seq2) > MinSeqSize Then
                            For Seq3 = Seq2 + 1 To NextNo
    '                            If Seq2 = 258 Or Seq3 = 258 Then
    '                                x = x
    '                            End If
                                If Seq3 <= UBound(PermValid, 2) And tMaskseq(Seq3) = 0 Then
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                                        If PermDIffs(Seq2, Seq3) > 2 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                NewOneFound = 0
                                                ActualFound = 0
                                                If DoScans(0, 0) = 1 Then
                                                                
                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                If NewOneFound = 1 Then
                                                    DP(Seq3, Seq1) = 1
                                                    DP(Seq1, Seq3) = 1
                                                    DP(Seq2, Seq1) = 1
                                                    DP(Seq1, Seq2) = 1
                                                End If
                                            'End If
                                        End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                'End If
            Next Seq2
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng((Seq1 / oNextno) * 250) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                GlobalTimer = SS
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        End If
    
    Next Seq1
End If


If AtLeastOne > 0 Then
        tSS = Abs(GetTickCount)
        
        
        Dim TP() As Byte
        ReDim DP(NextNo, NextNo), TP(NextNo, NextNo)
        For x = 0 To oNextno
            For Y = oNextno + 1 To NextNo
                TP(x, Y) = 1
                TP(Y, x) = 1
            Next Y
        Next x
        Call FastRecCheckGC(NextNo, (LowestProb / (oNextno * (NextNo - oNextno))) * 10000, DP(), SeqNum(), TP(), tMaskseq())
        
        '''For T = 1 To 10
'        For x = 0 To oNextno
'            For Y = oNextno + 1 To Nextno
'                If DP(x, Y) > 0 Then
'                    BotherWith(x) = 1
'                    Exit For
'                End If
'            Next Y
'        Next x
'        For x = 0 To oNextno
'            If BotherWith(x) = 0 Then
'                x = x
'            End If
'        Next x
    Dim UBPV2 As Long
    UBPV2 = UBound(PermValid, 2)
        For Seq1 = 0 To oNextno - 1
            If Seq1 <= UBPV2 And tMaskseq(Seq1) = 0 Then ' And BotherWith(Seq1) = 1 Then
                For Seq2 = Seq1 + 1 To oNextno
                    If Seq2 <= UBPV2 And tMaskseq(Seq2) = 0 Then
        '                 If Seq2 = 142 And Seq1 = 112 Then
        '                    x = x
        '                 End If
                        If PermValid(Seq1, Seq2) > MinSeqSize Then 'And BotherWith(Seq2) = 1 Then
        '                    NN = 0
        '                    XX = (PermNextno - Nextno)
                            For Seq3 = oNextno + 1 To NextNo
                                
                                If tMaskseq(Seq3) = 0 And BotherWith(Seq3) = 1 Then
                                    'NN = NN + 1
                                    '@'@
                                    If PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize And (DP(Seq1, Seq3) > 0 Or DP(Seq2, Seq3) > 0) Then

                                        'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                                            'If Seq1 <= Nextno And Seq2 <= Nextno And Seq3 <= Nextno Then
                                                 
                                                If DoScans(0, 0) = 1 Then
                                                     '@'@'@
                                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                                End If
                                                If DoScans(0, 1) = 1 Then
                                                    Call GCXoverD(0)
                                                End If
                                                If DoScans(0, 2) = 1 Then
                                                    Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                                End If
                                                If DoScans(0, 3) = 1 Then
                                                    Call MCXoverF(0, 0, 0)
                                                End If
                                                If DoScans(0, 4) = 1 Then
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                                
                                                    Call CXoverA(0, 0, 0)
                                                                                
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                                
                                                If DoScans(0, 5) = 1 Then
                                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                                End If
                                                
                                                '@
                                                If DoScans(0, 8) = 1 Then
                                                                                     
                                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                            
                                                    Call TSXOver(0)
                                                            
                                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                                End If
                                               
                                                
                                            'End If
                                        'End If
                                    End If
                                End If
                            Next Seq3
                        End If
                    End If
                    x = x
                Next Seq2
            End If
            SS = Abs(GetTickCount)
            If Abs(SS - GlobalTimer) > 500 Then
                GlobalTimer = SS
                'If Seq1 >= oNextno Then
                    '@
                    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined (" + Trim(Str((CLng(250 + ((Seq1 / (oNextno + 1)) * 750)) / 10))) + "% of this cluster completed)"
                'End If
                DoEvents
                If AbortFlag = 1 Then
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                UpdateRecNums (SEventNumber)
                
                'Form1.Label50(12).Caption = DoTimeII(Abs(ETx - STime))
                Call UpdateTimeCaps(SS, STartT)
                Form1.Label50(12).Caption = DoTimeII(Abs(SS - ST))
                
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                If AbortFlag = 1 Then
                    Exit For
                End If
            End If
        Next Seq1
        
        ess = Abs(GetTickCount)
        TotASET = TotASET + Abs(ess - tSS)
   ' End If
End If
DontWorryAboutSplitsFlag = oDWS
Dim NumNew
NumNew = 0
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        NumNew = NumNew + 1
'        XX = XoverList(x, Y).Daughter '7
'        XX = XoverList(x, Y).MajorP '15
'        XX = XoverList(x, Y).MinorP '9
        'XoverList(x, Y).BeginP = -100
        If XoverList(x, Y).MajorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        ElseIf XoverList(x, Y).MinorP > PermNextno And XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MajorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MajorP), (XoverList(x, Y).MajorP))
        ElseIf XoverList(x, Y).MinorP > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).MinorP), (XoverList(x, Y).MinorP))
        ElseIf XoverList(x, Y).Daughter > PermNextno Then
            XoverList(x, Y).EndP = 0
            XoverList(x, Y).BeginP = -CombineP(OSNPos(XoverList(x, Y).Daughter), (XoverList(x, Y).Daughter))
        'XX = XoverList(x, Y).EndP '0
        End If
    Next Y
Next x

'For x = 0 To Nextno
'    If ActualSeqSize(x) = 0 Then
'        x = x
'    End If
'Next x
UseCompress = 0

SS = Abs(GetTickCount)
If Abs(SS - LS) > 500 Then
    LS = SS
    Form1.SSPanel1.Caption = Str(CurSeed) + " of" + Str(oNextno) + " closely related sequence clusters reexamined"
    DoEvents
End If
For x = 0 To AddNum - 1
    MethodTime(x) = MethodTime(x) + Abs(SS - STartT) * TimeFract(x)
Next x
CurSeedExtras = CurSeed
If NumNew = 0 Then
    x = x
    StepNo = FirstStepNo 'StepNo - 1
    GoTo Redo
Else
    x = x
End If

End Sub
Public Sub MakeScanCompressArrays(NextNo As Long, SeqNum() As Integer)

Dim Recoded() As Byte
Call RecodeSeqs(NextNo, SeqNum(), Recoded())
XX = Len(StrainSeq(0))
If FSSRDP(2, 1, 1, 2) = 0 Then
    Call FillFSSRDP
End If
'Makes as generic 3 nuceotide encoded compressed sequence
Call MakeCompressSeq(NextNo, Recoded(), CompressSeq())

'Call FindSubSeqRDPFast(CompressSeq(), 1, 2, 3, XoverSeqNumW())
End Sub
Public Function CompressTEString(Decompress() As Long, TEString As String) As String
Dim DecompressSeq As String, A As Long
    DecompressSeq = String(Len(StrainSeq(0)), " ")
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
    If x = x Then
        Dummy = CompressTE(Len(StrainSeq(0)), DecompressSeq, TEString, Decompress(0))
'        x = x
'        TestS = DecompressSeq
'        x = x
    Else
        For A = 1 To Len(StrainSeq(0))
            Mid$(DecompressSeq, A, 1) = Mid$(TEString, Decompress(A), 1)
        Next A
    End If
'    If DecompressSeq <> TestS Then
'        x = x
'    End If
    CompressTEString = DecompressSeq

End Function
Public Sub MakeSumEventCount()

Dim x As Long, Y As Long, Z As Long, CountHold() As Long, DV1 As Long, DV2 As Long

ReDim SumEventCount(SEventNumber)
For Z = 1 To SEventNumber

    
    If UBound(OriginalPos, 1) < PermNextno Then
        ReDim OriginalPos(NextNo), FullOName(NextNo)
        For x = 0 To NextNo
            OriginalPos(x) = x
            FullOName(x) = OriginalName(x)
        Next x
        ReDim CountHold(PermNextno)
    Else
        ReDim CountHold(NextnoBak)
    End If
    If UBound(CountHold, 1) < PermNextno Then
        ReDim CountHold(PermNextno)
    End If
    For x = 0 To PermNextno
       For Y = 1 To CurrentXOver(x)
            If SuperEventList(XoverList(x, Y).Eventnumber) = Z Then
                If XoverList(x, Y).Daughter <= PermNextno Then ' this was an addsomeextras exclude
                    If CountHold(OriginalPos(XoverList(x, Y).Daughter)) = 0 Then
                        CountHold(OriginalPos(XoverList(x, Y).Daughter)) = 1 '4302
                    End If
                ElseIf XoverList(x, Y).BeginP < 0 Then
                    Call SplitP(-XoverList(x, Y).BeginP, DV1, DV2)
                    If DV2 = XoverList(x, Y).Daughter Then
                        If CountHold(DV1) <> 1 Then
                            CountHold(DV1) = 1 '1701
                        End If
                    ElseIf XoverList(x, Y).EndP < 0 Then
                        Call SplitP(-XoverList(x, Y).EndP, DV1, DV2)
                        If DV2 = XoverList(x, Y).Daughter Then
                            CountHold(DV1) = 1
                        End If
                    End If
                End If
            End If
       Next Y
    Next x
    
    For x = 0 To UBound(ELLite, 2)
        If ELLite(3, x) <= UBound(Daught, 2) Then
            
            If Z = Abs(ELLite(1, x)) Then
'                If Z = 85 Then
'                x = x
'            End If
                If ELLite(1, x) > 0 Then
                    If ELLite(5, x) > 0 Then
                        If CountHold(ELLite(4, x)) = 0 Then
                          CountHold(ELLite(4, x)) = 1 '19,333,1044
                        End If
        '            ElseIf Z = -ELLite(1, X) Then
                    End If
                Else
                    If ELLite(5, x) > 0 And ELLite(3, x) = 3 Then 'remember that (3,x) in elistlite corresponds with (0,x) in excluededventslist for the addsomeextras
                        If CountHold(ELLite(4, x)) = 0 Then
                          CountHold(ELLite(4, x)) = 1 '1701,13,15,16
                        End If
                          'XX = ELLite(2, x) '234,235
        '            ElseIf Z = -ELLite(1, X) Then
                    End If
                End If
            End If
        End If
    Next x
    For x = 0 To NextnoBak
'        If X = 2933 Then
'            X = X
'        End If
        SumEventCount(Z) = SumEventCount(Z) + CountHold(x)
    Next x
    'XX = SumEventCount(320)
Next Z


End Sub

Public Sub MakeELLite(ELLite() As Long, EventsInExcludeds() As Long, Daught() As Byte)
Dim x As Long, Y As Long, CN As Long, UB1 As Long, UB2 As Long

CN = 0

ReDim ELLite(UBound(EventsInExcludeds, 1), 1000)
If NumExcludedEventNum > 0 Then
    'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
    NF3 = FreeFile
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
    Put #NF3, 1, ExcludedEventNum
    Put #NF3, , EventsInExcludeds
    Close #NF3
    ReDim EventsInExcludeds(5, 1000)
    'ExcludedEventNum = 1
    ChDrive oDirX
    ChDir oDirX
End If
For j = 0 To NumExcludedEventNum
    If NumExcludedEventNum > 0 Then
        NF3 = FreeFile
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
        Get #NF3, , ExcludedEventNum
        ReDim EventsInExcludeds(5, ExcludedEventNum)
        Get #NF3, , EventsInExcludeds
        Close #NF3
        'ExcludedEventNum = 1
        ChDrive oDirX
        ChDir oDirX
    End If

    UB1 = UBound(EventsInExcludeds, 1)
    UB2 = UBound(EventsInExcludeds, 2)
    
    For x = 1 To UB2
    '    If Abs(EventsInExcludeds(1, x)) = 85 Then
    '
    '    End If
        If EventsInExcludeds(1, x) < 0 Then 'These are for the "addsomeextras" excludeds
            If EventsInExcludeds(5, x) > 0 And EventsInExcludeds(0, x) = 3 Then 'i.e. t(0,x) means this is possibly a corecombinant/recombinant, (5,x) indicates the support level
                CN = CN + 1
                If CN > UBound(ELLite, 2) Then
                    ReDim Preserve ELLite(UB1, CN + 1000)
                End If
                For Y = 0 To UB1
                    ELLite(Y, CN) = EventsInExcludeds(Y, x)
                Next Y
                ELLite(0, CN) = EventsInExcludeds(3, x) 'need to swap these (in the "addsomeextras" excludes the root sequence is stored in element 3
                                                       'and the extras are all pinned to this "real" root sequence
                                                       'In these excludes the root sequence IS the exclude itself (which will be added to the alignment in modseqnum) when it is looked at
                                                       'The event in this added sequence is still "held/stored" within the permanent root sequence so that it can be accessed via the picture 6 interface
                                                       'so what that means from the ellite perspective is that elements 3 and 0 need to be swapped to ensure that
                                                       'things work properly in the "makesummary" subroutine wrt reading out numbers of detected event in the summary table.
                ELLite(3, CN) = EventsInExcludeds(0, x)
                'XX = EventsInExcludeds(2, x)
    '            If ELLite(3, CN) > PermNextno Then
    '                x = x
    '            End If
            End If
        ElseIf Abs(EventsInExcludeds(1, x)) <= UBound(Daught, 1) And EventsInExcludeds(3, x) <= UBound(Daught, 2) Then
            If Daught(CLng(Abs(EventsInExcludeds(1, x))), EventsInExcludeds(3, x)) > 0 Then
                CN = CN + 1
                If CN > UBound(ELLite, 2) Then
                    ReDim Preserve ELLite(UB1, CN + 1000)
                End If
                For Y = 0 To UB1
                    ELLite(Y, CN) = EventsInExcludeds(Y, x)
                Next Y
            End If
        End If
    Next x
Next j
ReDim Preserve ELLite(UB1, CN)


Call MakeSumEventCount

End Sub
Public Sub FindMiCon(BPos As Long, Epos As Long, ISeqs() As Long, SMat() As Single, FMat() As Single, CurrentXOver() As Integer, XoverList() As XOverDefine, Trace() As Long, DoneSeq() As Byte, TraceSub() As Long)
'find relevant triplet involved in the fewest recombination events - more specific because it includes only events involving teh same genome region
'(also doesnt include hits in redolist)
Dim Connect() As Long
ReDim Connect(NextNo)

'work out the ranking of the iseqs in the two lists
Dim MDF As Single, MDS As Single, MS As Long, DA As Long, Ma As Long, Mi As Long

Dim MinC As Long
Dim SiteMap() As Long, LenR As Long, LenT As Long, BPosT As Long, EPosT As Long, MinCT As Long, LowCT As Long, WinCT(1) As Long, DaM As Long, MiM As Long, MaM As Long
Dim IS0 As Byte, IS1 As Byte, IS2 As Byte, ESeq As Long
ReDim SiteMap(Len(StrainSeq(0)))

If BPos < Epos Then
    LenR = Epos - BPos
    For x = BPos To Epos
        SiteMap(x) = 1
    Next x
Else
    LenR = Epos + Len(StrainSeq(0)) - BPos
    For x = 1 To Epos
        SiteMap(x) = 1
    Next x
    For x = BPos To Len(StrainSeq(0))
        SiteMap(x) = 1
    Next x
End If

WinCT(0) = Trace(0)
WinCT(1) = Trace(1)

Dim TtX() As Long
ReDim TtX(NextNo)
For x = 0 To NextNo
    TtX(x) = x
Next x


Dim Relevant() As Byte
'go through xoverlist
ReDim Relevant(NextNo, UBound(XoverList, 2))
'If SEventNumber = 7 Then
'    x = x
'End If
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If DoneSeq(x, Y) = 0 Then
            MS = 0
            DA = XoverList(x, Y).Daughter
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            DaM = -1
            MiM = -1
            MaM = -1
            IS0 = 0
            IS1 = 0
            IS2 = 0
            If DA = ISeqs(0) Then
                MS = MS + 1
                DaM = ISeqs(0)
                IS0 = 1
            ElseIf DA = ISeqs(1) Then
                MS = MS + 1
                DaM = ISeqs(1)
                IS1 = 1
            ElseIf DA = ISeqs(2) Then
                MS = MS + 1
                DaM = ISeqs(2)
                IS2 = 1
            End If
            If Mi = ISeqs(0) Then
                MS = MS + 1
                MiM = ISeqs(0)
                IS0 = 1
            ElseIf Mi = ISeqs(1) Then
                MS = MS + 1
                MiM = ISeqs(1)
                IS1 = 1
            ElseIf Mi = ISeqs(2) Then
                MS = MS + 1
                MiM = ISeqs(2)
                IS2 = 1
            End If
            If Ma = ISeqs(0) Then
                MS = MS + 1
                MaM = ISeqs(0)
                IS0 = 1
            ElseIf Ma = ISeqs(1) Then
                MS = MS + 1
                MaM = ISeqs(1)
                IS1 = 1
            ElseIf Ma = ISeqs(2) Then
                MS = MS + 1
                MaM = ISeqs(2)
                IS2 = 1
            End If
            If MS = 2 Then
                'test for site overlap
                BPosT = XoverList(x, Y).Beginning
                EPosT = XoverList(x, Y).Ending
                If BPosT < EPosT Then
                    LenT = 0
                    For Z = BPosT To EPosT
                        LenT = LenT + SiteMap(Z)
                    Next Z
                Else
                    LenT = 0
                    For Z = 1 To EPosT
                        LenT = LenT + SiteMap(Z)
                    Next Z
                    
                    For Z = BPosT To Len(StrainSeq(0))
                        LenT = LenT + SiteMap(Z)
                    Next Z
                
                End If
                If LenT / LenR > 0.4 Then
                    'at this point we have 2 parent overlaps and >40% region overlap
                    If IS0 = 0 Then
                        ESeq = ISeqs(0)
                        
                    ElseIf IS1 = 0 Then
                        ESeq = ISeqs(1)
                    Else
                        ESeq = ISeqs(2)
                    End If
                    
                    If DaM = -1 Then
                        Call CalcMatch(TtX(), 0, SeqNum(), DA, ESeq, Mi, Ma, BPos, Epos)
                    ElseIf MiM = -1 Then
                        Call CalcMatch(TtX(), 0, SeqNum(), Mi, ESeq, DA, Ma, BPos, Epos)
                    ElseIf MaM = -1 Then
                        Call CalcMatch(TtX(), 0, SeqNum(), Ma, ESeq, Mi, DA, BPos, Epos)
                    End If
                    
                    If BEVSS(0) > 0.7 Or BEVSS(1) > 0.7 Then
                        Relevant(x, Y) = 1
                    'at this point we have at least one matching breakpoint
                        Connect(TraceSub(DA)) = Connect(TraceSub(DA)) + 1
                        Connect(TraceSub(Mi)) = Connect(TraceSub(Mi)) + 1
                        Connect(TraceSub(Ma)) = Connect(TraceSub(Ma)) + 1
                    End If
                    
                End If
            End If
        End If
    Next Y
Next x
Connect(ISeqs(0)) = Connect(ISeqs(0)) + 1
Connect(ISeqs(1)) = Connect(ISeqs(1)) + 1
Connect(ISeqs(2)) = Connect(ISeqs(2)) + 1
LowCT = Connect(TraceSub(ISeqs(0))) + Connect(TraceSub(ISeqs(1))) + Connect(TraceSub(ISeqs(2)))
WinCT(0) = Trace(0)
WinCT(1) = Trace(1)
'For x = 0 To Len(StrainSeq(0))
'    If MissingData(x, ISeqs(0)) = 1 Then '5680-9099
'        x = x
'    End If
'Next x
'go through xoverlist
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If Relevant(x, Y) = 1 Then
            DA = TraceSub(XoverList(x, Y).Daughter)
            Mi = TraceSub(XoverList(x, Y).MinorP)
            Ma = TraceSub(XoverList(x, Y).MajorP)
            MinCT = Connect(DA) + Connect(Mi) + Connect(Ma)
            If MinCT < LowCT Then
                LowCT = MinCT
                WinCT(0) = x
                WinCT(1) = Y
                
            End If

                   
        End If
    Next Y
Next x


If WinCT(0) <> Trace(0) Or WinCT(1) <> Trace(1) Then
    XX = SEventNumber + 1 '1,2,3,4,5,6,7,11,12,13,17
    Trace(0) = WinCT(0)
    Trace(1) = WinCT(1)
    BPos = XoverList(Trace(0), Trace(1)).Beginning
    Epos = XoverList(Trace(0), Trace(1)).Ending
    If BPos = 0 Then BPos = 1
    If Epos = 0 Then Epos = 1
    ISeqs(0) = XoverList(Trace(0), Trace(1)).Daughter
    ISeqs(1) = XoverList(Trace(0), Trace(1)).MinorP
    ISeqs(2) = XoverList(Trace(0), Trace(1)).MajorP
End If
End Sub
Public Sub FindMiConB(BPos As Long, Epos As Long, ISeqs() As Long, SMat() As Single, FMat() As Single, CurrentXOver() As Integer, XoverList() As XOverDefine, Trace() As Long, DoneSeq() As Byte, TraceSub() As Long)
'find relevant triplet involved in the fewest recombination events - more general because it includes every scanned triplet always
'(the other version in findmecon only looks at events in xoverlist but is more specific for events involving the same genome region)
Dim Connect() As Long
ReDim Connect(NextNo)

'work out the ranking of the iseqs in the two lists
Dim MDF As Single, MDS As Single, MS As Long, DA As Long, Ma As Long, Mi As Long

Dim MinC As Long
Dim SiteMap() As Long, LenR As Long, LenT As Long, BPosT As Long, EPosT As Long, MinCT As Long, LowCT As Long, WinCT(1) As Long, DaM As Long, MiM As Long, MaM As Long
Dim IS0 As Byte, IS1 As Byte, IS2 As Byte, ESeq As Long
ReDim SiteMap(Len(StrainSeq(0)))

If BPos < Epos Then
    LenR = Epos - BPos
    For x = BPos To Epos
        SiteMap(x) = 1
    Next x
Else
    LenR = Epos + Len(StrainSeq(0)) - BPos
    For x = 1 To Epos
        SiteMap(x) = 1
    Next x
    For x = BPos To Len(StrainSeq(0))
        SiteMap(x) = 1
    Next x
End If

WinCT(0) = Trace(0)
WinCT(1) = Trace(1)

Dim TtX() As Long
ReDim TtX(NextNo)
For x = 0 To NextNo
    TtX(x) = x
Next x




LowCT = ISInvolved(TraceSub(ISeqs(0))) + ISInvolved(TraceSub(ISeqs(1))) + ISInvolved(TraceSub(ISeqs(2)))
WinCT(0) = Trace(0)
WinCT(1) = Trace(1)
'For x = 0 To Len(StrainSeq(0))
'    If MissingData(x, ISeqs(0)) = 1 Then '5680-9099
'        x = x
'    End If
'Next x
'go through xoverlist

For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
    
        If DoneSeq(x, Y) = 0 Then
            If XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb Then
                If DoScans(0, XoverList(x, Y).ProgramFlag) = 1 Then
                    MS = 0
                    DA = XoverList(x, Y).Daughter
                    Mi = XoverList(x, Y).MinorP
                    Ma = XoverList(x, Y).MajorP
                    DaM = -1
                    MiM = -1
                    MaM = -1
                    IS0 = 0
                    IS1 = 0
                    IS2 = 0
                    If DA = ISeqs(0) Then
                        MS = MS + 1
                        DaM = ISeqs(0)
                        IS0 = 1
                    ElseIf DA = ISeqs(1) Then
                        MS = MS + 1
                        DaM = ISeqs(1)
                        IS1 = 1
                    ElseIf DA = ISeqs(2) Then
                        MS = MS + 1
                        DaM = ISeqs(2)
                        IS2 = 1
                    End If
                    If Mi = ISeqs(0) Then
                        MS = MS + 1
                        MiM = ISeqs(0)
                        IS0 = 1
                    ElseIf Mi = ISeqs(1) Then
                        MS = MS + 1
                        MiM = ISeqs(1)
                        IS1 = 1
                    ElseIf Mi = ISeqs(2) Then
                        MS = MS + 1
                        MiM = ISeqs(2)
                        IS2 = 1
                    End If
                    If Ma = ISeqs(0) Then
                        MS = MS + 1
                        MaM = ISeqs(0)
                        IS0 = 1
                    ElseIf Ma = ISeqs(1) Then
                        MS = MS + 1
                        MaM = ISeqs(1)
                        IS1 = 1
                    ElseIf Ma = ISeqs(2) Then
                        MS = MS + 1
                        MaM = ISeqs(2)
                        IS2 = 1
                    End If
                    If MS = 2 Then
                        'test for site overlap
                        BPosT = XoverList(x, Y).Beginning
                        EPosT = XoverList(x, Y).Ending
                        If BPosT < EPosT Then
                            LenT = 0
                            For Z = BPosT To EPosT
                                LenT = LenT + SiteMap(Z)
                            Next Z
                        Else
                            LenT = 0
                            For Z = 1 To EPosT
                                LenT = LenT + SiteMap(Z)
                            Next Z
                            
                            For Z = BPosT To Len(StrainSeq(0))
                                LenT = LenT + SiteMap(Z)
                            Next Z
                        
                        End If
                        If LenT / LenR > 0.4 Then
                            'at this point we have 2 parent overlaps and >40% region overlap
                            If IS0 = 0 Then
                                ESeq = ISeqs(0)
                                
                            ElseIf IS1 = 0 Then
                                ESeq = ISeqs(1)
                            Else
                                ESeq = ISeqs(2)
                            End If
                            
                            If DaM = -1 Then
                                Call CalcMatch(TtX(), 0, SeqNum(), DA, ESeq, Mi, Ma, BPos, Epos)
                            ElseIf MiM = -1 Then
                                Call CalcMatch(TtX(), 0, SeqNum(), Mi, ESeq, DA, Ma, BPos, Epos)
                            ElseIf MaM = -1 Then
                                Call CalcMatch(TtX(), 0, SeqNum(), Ma, ESeq, Mi, DA, BPos, Epos)
                            End If
                            
                            'bevss(0)=match over the bpos
                            'bevss(1)=match over the epos
                            If BEVSS(0) > 0.8 Or BEVSS(1) > 0.8 Then
                            'at this point we have at least one matching breakpoint
                                MinCT = ISInvolved(TraceSub(DA)) + ISInvolved(TraceSub(Mi)) + ISInvolved(TraceSub(Ma))
                                If MinCT < LowCT Then
                                    LowCT = MinCT
                                    WinCT(0) = x
                                    WinCT(1) = Y
                                    XX = SEventNumber '1
                                End If
        
        
                            End If
                            
                        End If
                    End If
                End If
            End If
        End If
    Next Y
Next x




If WinCT(0) <> Trace(0) Or WinCT(1) <> Trace(1) Then
    XX = SEventNumber + 1 '1,2,3,4,5,6,7,11,12,13,17
    Trace(0) = WinCT(0)
    Trace(1) = WinCT(1)
    BPos = XoverList(Trace(0), Trace(1)).Beginning
    Epos = XoverList(Trace(0), Trace(1)).Ending
    If BPos = 0 Then BPos = 1
    If Epos = 0 Then Epos = 1
    ISeqs(0) = XoverList(Trace(0), Trace(1)).Daughter
    ISeqs(1) = XoverList(Trace(0), Trace(1)).MinorP
    ISeqs(2) = XoverList(Trace(0), Trace(1)).MajorP
End If
End Sub

Public Sub FindLoRCA(BPos As Long, Epos As Long, ISeqs() As Long, SMat() As Single, FMat() As Single, CurrentXOver() As Integer, XoverList() As XOverDefine, Trace() As Long, DoneSeq() As Byte)
'test rank changes
'test to see if some of the iseqs are overly outlyerish - could indicate that they have recombined with something outside the dataset
'need to do this because it creates fake signals of corecombination
Dim MoveDistF() As Single, MoveDistS() As Single, RankF() As Long
ReDim MoveDistF(NextNo), MoveDistS(NextNo)
For x = 0 To NextNo
    For Y = 0 To NextNo
        MoveDistF(x) = MoveDistF(x) + FMat(x, Y)
        MoveDistS(x) = MoveDistS(x) + SMat(x, Y)
    Next Y
Next x

'work out the ranking of the iseqs in the two lists
Dim MDF As Single, MDS As Single, MS As Long, DA As Long, Ma As Long, Mi As Long
ReDim RankF(NextNo, 1)

For x = 0 To NextNo
    For Y = 0 To NextNo
        If MoveDistF(x) > MoveDistF(Y) Then
            RankF(x, 0) = RankF(x, 0) + 1
        End If
        If MoveDistS(x) > MoveDistS(Y) Then
            RankF(x, 1) = RankF(x, 1) + 1
        End If
    Next Y
Next x
Dim MinC As Long
'MinC = 0
'If (RankF(ISeqs(0), 1) > RankF(ISeqs(0), 0)) Then
'    MinC = MinC + (RankF(ISeqs(0), 1) - RankF(ISeqs(0), 0))
'End If
'If (RankF(ISeqs(1), 1) > RankF(ISeqs(1), 0)) Then
'    MinC = MinC + (RankF(ISeqs(1), 1) - RankF(ISeqs(1), 0))
'End If
'If (RankF(ISeqs(2), 1) > RankF(ISeqs(2), 0)) Then
'    MinC = MinC + (RankF(ISeqs(2), 1) - RankF(ISeqs(2), 0))
'End If
MinC = (RankF(ISeqs(0), 0) - RankF(ISeqs(0), 1)) + Abs(RankF(ISeqs(1), 0) - RankF(ISeqs(1), 1)) + Abs(RankF(ISeqs(2), 0) - RankF(ISeqs(2), 1))
Dim SiteMap() As Long, LenR As Long, LenT As Long, BPosT As Long, EPosT As Long, MinCT As Long, LowCT As Long, WinCT(1) As Long, DaM As Long, MiM As Long, MaM As Long
Dim IS0 As Byte, IS1 As Byte, IS2 As Byte, ESeq As Long
ReDim SiteMap(Len(StrainSeq(0)))
LowCT = MinC
If BPos < Epos Then
    LenR = Epos - BPos
    For x = BPos To Epos
        SiteMap(x) = 1
    Next x
Else
    LenR = Epos + Len(StrainSeq(0)) - BPos
    For x = 1 To Epos
        SiteMap(x) = 1
    Next x
    For x = BPos To Len(StrainSeq(0))
        SiteMap(x) = 1
    Next x
End If

WinCT(0) = Trace(0)
WinCT(1) = Trace(1)

Dim TtX() As Long
ReDim TtX(NextNo)
For x = 0 To NextNo
    TtX(x) = x
Next x

'go through xoverlist
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If DoneSeq(x, Y) = 0 Then
            MS = 0
            DA = XoverList(x, Y).Daughter
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            DaM = -1
            MiM = -1
            MaM = -1
            IS0 = 0
            IS1 = 0
            IS2 = 0
            If DA = ISeqs(0) Then
                MS = MS + 1
                DaM = ISeqs(0)
                IS0 = 1
            ElseIf DA = ISeqs(1) Then
                MS = MS + 1
                DaM = ISeqs(1)
                IS1 = 1
            ElseIf DA = ISeqs(2) Then
                MS = MS + 1
                DaM = ISeqs(2)
                IS2 = 1
            End If
            If Mi = ISeqs(0) Then
                MS = MS + 1
                MiM = ISeqs(0)
                IS0 = 1
            ElseIf Mi = ISeqs(1) Then
                MS = MS + 1
                MiM = ISeqs(1)
                IS1 = 1
            ElseIf Mi = ISeqs(2) Then
                MS = MS + 1
                MiM = ISeqs(2)
                IS2 = 1
            End If
            If Ma = ISeqs(0) Then
                MS = MS + 1
                MaM = ISeqs(0)
                IS0 = 1
            ElseIf Ma = ISeqs(1) Then
                MS = MS + 1
                MaM = ISeqs(1)
                IS1 = 1
            ElseIf Ma = ISeqs(2) Then
                MS = MS + 1
                MaM = ISeqs(2)
                IS2 = 1
            End If
            If MS = 2 Then
                'test for site overlap
                BPosT = XoverList(x, Y).Beginning
                EPosT = XoverList(x, Y).Ending
                If BPosT < EPosT Then
                    LenT = 0
                    For Z = BPosT To EPosT
                        LenT = LenT + SiteMap(Z)
                    Next Z
                Else
                    LenT = 0
                    For Z = 1 To EPosT
                        LenT = LenT + SiteMap(Z)
                    Next Z
                    
                    For Z = BPosT To Len(StrainSeq(0))
                        LenT = LenT + SiteMap(Z)
                    Next Z
                
                End If
                If LenT / LenR > 0.4 Then
                    'at this point we have 2 parent overlaps and >40% region overlap
                    If IS0 = 0 Then
                        ESeq = ISeqs(0)
                        
                    ElseIf IS1 = 0 Then
                        ESeq = ISeqs(1)
                    Else
                        ESeq = ISeqs(2)
                    End If
                    
                    If DaM = -1 Then
                        Call CalcMatch(TtX(), 0, SeqNum(), DA, ESeq, Mi, Ma, BPos, Epos)
                    ElseIf MiM = -1 Then
                        Call CalcMatch(TtX(), 0, SeqNum(), Mi, ESeq, DA, Ma, BPos, Epos)
                    ElseIf MaM = -1 Then
                        Call CalcMatch(TtX(), 0, SeqNum(), Ma, ESeq, Mi, DA, BPos, Epos)
                    End If
                    
                    'bevss(0)=match over the bpos
                    'bevss(1)=match over the epos
                    XX = BEVSS(0)
                    XX = BEVSS(1)
                    If BEVSS(0) > 0.8 Or BEVSS(1) > 0.8 Then
                    'at this point we have at least one matching breakpoint
                        MinCT = Abs(RankF(DA, 0) - RankF(DA, 1)) + Abs(RankF(Mi, 0) - RankF(Mi, 1)) + Abs(RankF(Ma, 0) - RankF(Ma, 1))
                        If MinCT < LowCT Then
                            LowCT = MinCT
                            WinCT(0) = x
                            WinCT(1) = Y
                        End If

                    End If
'                    MinCT = 0
'                    If RankF(Da, 1) > RankF(Da, 0) Then
'                        MinCT = MinCT + RankF(Da, 1) - RankF(Da, 0)
'                    End If
'                    If RankF(Da, 1) > RankF(Da, 0) Then
'                        MinCT = MinCT + RankF(Mi, 1) - RankF(Mi, 0)
'                    End If
'                    If RankF(Da, 1) > RankF(Da, 0) Then
'                        MinCT = MinCT + RankF(Ma, 1) - RankF(Ma, 0)
'                    End If
                    
                End If
            End If
        End If
    Next Y
Next x



If WinCT(0) <> Trace(0) Or WinCT(1) <> Trace(1) Then
    Trace(0) = WinCT(0)
    Trace(1) = WinCT(1)
    BPos = XoverList(Trace(0), Trace(1)).Beginning
    Epos = XoverList(Trace(0), Trace(1)).Ending
    If BPos = 0 Then BPos = 1
    If Epos = 0 Then Epos = 1
    ISeqs(0) = XoverList(Trace(0), Trace(1)).Daughter
    ISeqs(1) = XoverList(Trace(0), Trace(1)).MinorP
    ISeqs(2) = XoverList(Trace(0), Trace(1)).MajorP
End If
End Sub
Public Sub GetBinProbs()
    Dim FF As Long, oDirX As String
    ReDim ProbEstimate(171, 171, 50)
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    'XX = App.Path
    FF = FreeFile
    Open "BinProbs" For Binary As #FF
    Get #FF, , ProbEstimate()
    Close #FF
    ChDrive oDirX
    ChDir oDirX
End Sub
Public Function FastRecCheck2(NextNo As Long, FindallFlag As Byte, BEP, ENP, PermDIffs() As Single, XDiffPos() As Long, XPosDiff() As Long, SeqNum() As Integer)
'@
Dim UB As Long, Dummy As Long, Redox As Long, CurWinPos As Long, NumInList As Long, EWarn As Long, BWarn As Long, SIP As Long
Dim ENX As Long, BEX As Long, ZZ As Long, oActive As Long, oMajP As Long, oMinP As Long, CF As Long, YScaleFactor As Single
Dim Y As Long


Dim FullMC As Double, xMPV As Variant, GoOn As Byte, XB As Long, XE As Long, XBP As Double, XEP As Double, DoneRedo As Byte, LOT(1) As Double, BPP As Double, EPP As Double, BPV As Double, EPV As Double, PPVal As Double, BE As Long, EN As Long, DoneThis As Byte
Dim maxz As Long, MaxX As Long, WinWin As Long
Dim Failcount As Long
Dim MPV As Double, HMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long
Dim mPrbL As Double, ZP As Double

Dim WasteOfTime As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim ProbabilityXOver As Double
Dim Pict As Long
Dim PntAPI As POINTAPI
Dim PV As Double, MaxFailCount As Long, PBinFlag As Long
'If Seq1 = 0 Or Seq1 = 1 Or Seq1 = 12 Then
'If Seq2 = 0 Or Seq2 = 1 Or Seq2 = 12 Then
'If Seq3 = 0 Or Seq3 = 1 Or Seq3 = 12 Then
'X = X
'End If
'End If
'End If


'13,17
'15,18
PBinFlag = -1


'XX = UBound(PermDiffs, 1)

If (PermDIffs(Seq1, Seq2) < 3 Or PermDIffs(Seq1, Seq3)) < 3 Or PermDIffs(Seq2, Seq3) < 3 Then
    If CLine = "" Or CLine = " " Then
        FastRecCheck2 = 0
        Exit Function
    End If
End If


UB = 0
 On Error Resume Next
UB = UBound(Chivals, 1)
On Error GoTo 0
If UB <> Len(StrainSeq(0)) Then
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim Winscores(Len(StrainSeq(0)) + (CLng(MCWinSize / 2)) * 2, 2)
    'XX = UBound(Winscores, 1)
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + (CLng(MCWinSize / 2)) * 2)
End If

'Erase Scores
'Erase Winscores
'Erase Chivals
'Erase SmoothChi
'Erase ScoresX
'Erase WinScoresX
'Erase ChiValsX
'Erase SmoothChiX


'1.641,1.562
'This could be speeded up with better nesting
'SSSS = abs(gettickcount)
'For Z = 1 To 100000
'LenXoverSeq1 = FindSubSeqCP(Len(StrainSeq(0)) + 1, Nextno, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
'@'@'@'@'@'@
LenXoverSeq = FindSubSeqMCPB(UBound(FSSMC, 2), UBound(CompressSeq, 1), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), XDiffPos(0), XPosDiff(0), FSSMC(0, 0, 0, 0))
'Next Z
'EEee = abs(gettickcount)
'TT = EEee - SSSS '563 down to 250 with compresseq
x = x
'3.015,3.078



'I must calculate a more severe critical diff for the mccorrection - ie 2 diffs
'must be calculated - one for here and one for later on in calcchivals.
'XX = PermSeqNumInFile

If LenXoverSeq < CriticalDiff * 2 Then
    FastRecCheck2 = 0
    Exit Function

End If
If LenXoverSeq < 7 Then
    FastRecCheck2 = 0
    Exit Function
End If

'
Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXoverSeq, MCWinFract, MCWinSize, HWindowWidth, lHWindowWidth, GoOn, FindallFlag, MCProportionFlag, XPosDiff())

'3.375,3.281



If GoOn = 0 Then
    FastRecCheck2 = 0
    Exit Function
End If

'If HWindowWidth <> lHWindowWidth Then
'    '
'    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
'
'    lHWindowWidth = HWindowWidth
'End If


'3.312
'@'@
Dummy = WinScoreCalcP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffPos(0), SeqNum(0, 0), Winscores(0, 0))

'4.656,4.750


'This could be speeded up with better nesting

 

If FindallFlag = 0 And (CircularFlag = 0) Then
    
        
    Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
    Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        
    
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXoverSeq) = 1
        '
        For x = (LenXoverSeq - HWindowWidth + 2) To LenXoverSeq
            BanWin(x) = 1
        Next x
        
    End If

    '10.605
    '10.465 using offsets
    '
    
    
    'MChi = CalcChiVals4P2(UBound(ChiTable, 1), UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable(0, 0, 0))
    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
        '
        MChi = CalcChiVals4P3(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable2(Chimap(HWindowWidth)))
    Else
        MChi = CalcChiVals4P(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
    End If
    'MChi = CalcChiVals4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
Else
    
'    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
'        MChi = CalcChiValsP2(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), ChiTable2(ChiMap(HWindowWidth)))
'    Else
'@
        MChi = CalcChiValsP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0))
'    End If
   x = x
End If




'8.203
'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub

If MCProportionFlag = 0 Then
    '@
        If (ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Then
            FastRecCheck2 = 0
            Exit Function
        End If
    Else
        If ((ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then
            FastRecCheck2 = 0
            Exit Function
        End If
    End If
'8.313

If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXoverSeq, HWindowWidth, mtP(), 3)
End If


'Smooth to find peaks (uses a window of positions)


'test if this p version is quicker
'SmoothChiValsP LenXOverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'The p - varsion is slower
'@
SmoothChiVals LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'9.125,9.172





MChi = 0
'
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events


'XX = SEventNumber
Redox = 0
If MCFlag = 0 Then
    FullMC = 3 * LenXoverSeq / HWindowWidth
    FullMC = FullMC * MCCorrection
Else
    FullMC = 3 * LenXoverSeq / HWindowWidth
End If
Do
    
    Redox = Redox + 1
    
    FindMChiP Len(StrainSeq(0)), LenXoverSeq, MaxX, MaxY, MChi, Chivals(0, 0)
    
    '8.828,8.844
    
    If MaxX = -1 Or MaxY = -1 Or Redox > 100 Then
        FastRecCheck2 = 0
        Exit Function
    End If
    
    'The p-version of this seems slower than the old one
    mPrb = ChiPVal2(MChi)
    If MCProportionFlag = 0 Then
    '
        If (mPrb * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then
            FastRecCheck2 = 0
            Exit Function
        End If
    Else
        If ((mPrb * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then
            FastRecCheck2 = 0
            Exit Function
        End If
    End If
    '8.907
    'Exit Sub
    'XX = XPosDiff(2688)
    '10.000
    'Exit Sub
    If mPrb < LowestProb Then
        '
        maxz = MaxX
        
        If MaxX = 0 Then MaxX = 1
       
        Call MakeTWin(FindallFlag, HWindowWidth, TWin, LenXoverSeq)
        
        
        MaxFailCount = HWindowWidth * 2
        
        If MaxFailCount > Int((LenXoverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXoverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        '
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        ''
        Dummy = GetAC(LenXoverSeq, Len(StrainSeq(0)), MaxY, MaxX, TWin, A, C, Scores(0, 0))
        
        
        'Now find the other breakpoint.
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXoverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXoverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXoverSeq
            Else
                MaxX = LenXoverSeq - 1
            End If
        End If
        
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXoverSeq / HWindowWidth)
        
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXoverSeq + LO
        '
        RO = (MaxX + TWin)
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO >= LenXoverSeq Then
            If MDMap(LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                TWin = TWin - 1
                RO = LenXoverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXoverSeq + LO
                        
            End If
        End If
        'XX = MDMap(1)
        'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        '
        If FindallFlag = 0 Then
            
            
            If LongWindedFlag = 1 And (CircularFlag = 0) Then
                'better use of floats might help here - also the p-version gives a slightly different result to the non-p version
                'These routines give slightly different results to the vc5 versions
                
                'compilerdiffs
                '
                'If X = X Then
                    ''
                    'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                    Dummy = GrowMChiWin2P2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0), ChiTable2(0), Chimap(0))
                    If WinWin < HWindowWidth Then
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                        'MPV = MPV
                    Else
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                        'MPV = MPV
                    End If
                    'MPV = MPV * MCCorrection
                    '5.6988-4,3.118, 1912, 4755, 35, 4655
                    x = x
'                Else
'                    '20.9878
'                    '6.8674 x 10-4
'                    Dummy = GrowMChiWin2(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
'                    X = X
'                End If
                'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                x = x
            Else
                'compilerdiffs
                'Dummy = GrowMChiWinP(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                
                
                If x = x Then
                    If x = x Then
                        
                        Dummy = GrowMChiWinP2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), ChiTable2(0), Chimap(0))
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            If MChi < 20000 Then
                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            Else
'                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                                XX = ChiPVal2(20000)
                                MPV = 10 ^ -200
                            End If
                            'MPV = MPV
                        End If
                    Else
                        Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            'MPV = MPV
                        End If
                        'Dummy = GrowMChiWin(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                    End If
                Else
                    Dummy = GrowMChiWin(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                End If
                x = x
            End If
           
        End If
        'xMPV
       
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        xMPV = MPV 'MCCorrection * 3
        '
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        
        
        If xMPV < UCThresh And EarlyBale = 1 Then
        
            FastRecCheck2 = 1
            Exit Function
        End If
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        '
        On Error GoTo 0
        
        If ShortOutFlag = 3 Then
            If MPV <= mtP(3) Then
                mtP(3) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        '@
        RO = MaxX + WinWin - 1
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO > LenXoverSeq Then
            If MDMap(RO - LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                RO = LenXoverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXoverSeq
        End If
        '34.42
        '
        If MPV < LowestProb Then
            FastRecCheck2 = 1
            BQPV = MPV
            Exit Function
            
            
        Else
            WasteOfTime = WasteOfTime + 1
            
            If WasteOfTime = 3 Then
                FastRecCheck2 = 0
                Exit Function
            End If
            
            
            RO = pMaxX
            LO = pMaxX
            '
            'destroy the maxx peak
            
            Dummy = DestroyPeak(MaxY, Len(StrainSeq(0)), RO, LO, LenXoverSeq, LOT(0), SmoothChi(0, 0), Chivals(0, 0))
            
            If maxz = -1 Or MaxY = -1 Then
                FastRecCheck2 = 0
                Exit Function
            End If
            '
            Chivals(maxz, MaxY) = 0
            If Dummy = 0 Then
                FastRecCheck2 = 0
                Exit Function
            End If
            
        End If
    Else
        Exit Do
    End If
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop

End Function
Public Sub ResetDefaults()
Dim SetDef As Byte
SetDef = 1

If NP = 0 Or SetDef = 1 Then
        DoScans(0, 0) = 1
        DoScans(0, 1) = 1
        DoScans(0, 3) = 1
    End If
    
    
    
    If (TBNChains = 0 And TBNGens = 0) Or SetDef = 1 Then
        TBModel = 2
        TBGamma = 1
        TBGammaCats = 4
        TBNGens = 10000000
        TBNChains = 4
        TBSampFreq = 100
        TBTemp = 0.2
        TBSwapFreq = 1
        TBSwapNum = 1
    End If
    'Public TPTVRat As Double, TPGamma As Long, TPAlpha As Double, TPInvSites As Double, TPModel As Byte, xTPModel As Byte, TPBPFEstimate As Byte, xTPBPFEstimate As Byte
    If TPGamma = 0 Or SetDef = 1 Then
        TPInvSites = 0
        TPTVRat = 2
        TPGamma = 1
        TPAlpha = 2
        TPModel = 6
        TPBPFEstimate = 0
        BSTreeStrat = 5
        BSupTest = 0
    End If
    
    'LDHAT Variables
    If MCMCUpdates < 100000 Or SetDef = 1 Then
        BlockPen = 10
        StartRho = 30
        MCMCUpdates = 1000000
        FreqCo = 0.05
        FreqCoMD = 0.1
        GCFlag = 1
        GCTractLen = 1000
    End If
    If PPWinLen = 0 Or SetDef = 1 Then
        PPWinLen = 60
        PPStripGaps = 0
        IncSelf = 0
        PPSeed = 3
        PPPerms = 1000
    End If
    
    If CWinSize = 0 Or SetDef = 1 Then
        CWinFract = 0.1
        CProportionFlag = 0
        CWinSize = 60
        
    End If
    
    If SSWinLen = 0 Or SetDef = 1 Then
        SSFastFlag = 1
        SSGapFlag = 0
        SSVarPFlag = 2
        SSOutlyerFlag = 1
        SSRndSeed = 3
        SSWinLen = 200
        SSStep = 20
        SSNumPerms = 1000
        SSNumPerms2 = 100
    End If
    
    
    
    
    If TTVRat = 0 Or (TAfreq + TCFreq + TGFreq + TTFreq = 0) Or SetDef = 1 Then
        ModelTestFlag = 0
        TBSReps = 100
        TRndSeed = 3
        TTVRat = 2
        TModel = 0
        TOCoeffVar = 1
        TBaseFreqFlag = 0
        TAfreq = 0.25
        TCFreq = 0.25
        TGFreq = 0.25
        TTFreq = 0.25
        TPower = 2
        TNegBLFlag = 0
        TSubRepsFlag = 0
        TGRFlag = 0
        TRndIOrderFlag = 0
        RAxMLCats = 25
    End If
    
    If TModel = 3 Then
        If TBSReps < 13 Then TBSReps = 13 'I need to do this to avoid a memory leak in DNADIST - I don't know why its leaking but it is.
    End If
    If BSCoeffVar = 0 Then BSCoeffVar = 1

    If TOCoeffVar = 0 Then TOCoeffVar = 1

    If DPCoeffVar = 0 Then DPCoeffVar = 1

    If curdirx$ = "" Or ShowPlotFlag > 4 Or SetDef = 1 Then
        MCFlag = 0
        ShowPlotFlag = 2
        CircularFlag = 1
        FullWindowSize = 40
        HomologyIndicator = 1
        LowestProb = 0.05
        SpacerFlag = 0
        XOverWindowX = 30
        Form3.Text2.Text = 30
        ForcePhylE = 1
        PolishBPFlag = 1
        
        ConsensusProg = 1
        AllowConflict = 1
        RealignFlag = 1
    End If
    GCSeqTypeFlag = 0
    If GCOutfileName = "" Or SetDef = 1 Then
        DoScans(0, 0) = 1
        DoScans(0, 1) = 1
        DoScans(0, 2) = 0
        DoScans(1, 2) = 1
        DoScans(0, 3) = 1
        DoScans(0, 5) = 0
        DoScans(1, 5) = 1
        DoScans(0, 4) = 0
        DoScans(0, 6) = 0
        DoScans(0, 7) = 0
        DoScans(1, 7) = 0
        DoScans(1, 6) = 0
        DoScans(0, 8) = 0
        
        GCIndelFlag = 0
        
        GCMonoSiteFlag = 0
        ReDim GCSeqRange(1)
        GCOutfileName = "tf"
        GCOutFlag = 0
        GCOutFlagII = 0
        GCSortFlag = 0
        
        GCOffsetAddjust = 0
        GCLogFlag = 0
        GCMissmatchPen = 1
        
        GCMinFragLen = 1
        GCMinPolyInFrag = 2
        GCMinPairScore = 2
        GCMaxOverlapFrags = 1
        GCNumPerms = 0
        
        
        GCtripletflag = 1
    End If
    GCPermPolyFlag = 0
    GCMaxPermPVal = 0.05
    GCMaxGlobFrags = 2000
    GCMaxPairFrags = 0
    GCEndLen = 0
    If BSStepWin < 10 Or SetDef = 1 Then
        BSPValFlag = 1
        BSStepWin = 200
        BSStepSize = 20
        BSCutOff = 0.7
        BSBootReps = 100
        BSRndNumSeed = 3
        BSSubModelFlag = 0
        BSFreqFlag = 0
        BSFreqA = 0.25
        BSFreqC = 0.25
        BSFreqG = 0.25
        BSFreqT = 0.25
        BSTTRatio = 2#
        
        
        
        
        BSCDecreaseStepFlag = 1
        BSCDStepSize = 10
       
        'BSCDBootReps = 200
        BSCDSpan = 100
        BSTypeFlag = 0
        
    End If

    If MCWinSize < 10 Or SetDef = 1 Then
        
        'MCMaxP = 0.05
        MCSteplen = 1
        MCWinSize = 70
    End If

    If MCWinFract = 0 Or SetDef = 1 Then
        MCWinFract = 0.1
        MCProportionFlag = 0
        MCTripletFlag = 0
        MCStripGapsFlag = 1
    End If
    If LRDStep = 0 Or SetDef = 1 Then
        LRDModel = 0
        LRDCategs = 0
        LRDShape = 0.5
        LRDTvRat = 2#
        LRDACCoeff = 1
        LRDAGCoeff = 1
        LRDATCoeff = 1
        LRDCGCoeff = 1
        LRDCTCoeff = 1
        LRDGTCoeff = 1
        LRDBaseFreqFlag = 1
        LRDAFreq = 0.25
        LRDCFreq = 0.25
        LRDGFreq = 0.25
        LRDTFreq = 0.25
        LRDCodon1 = 1
        LRDCodon2 = 1
        LRDCodon3 = 1
        LRDStep = 20
        LRDRegion = 1
    End If
    
    If DPWindow = 0 Or SetDef = 1 Then
        DPModelFlag = 1
        DPWindow = 200
        DPStep = 20
        DPTVRatio = 2#
        DPBFreqFlag = 0
        DPBFreqA = 0.25
        DPBFreqC = 0.25
        DPBFreqG = 0.25
        DPBFreqT = 0.25
    End If

   

    If TOWinLen = 0 Or SetDef = 1 Then
        TOPFlag = 0
        TORndNum = 3
        TOModel = 0
        TOTreeType = 1
        TOPerms = 100
        TOWinLen = 200
        TOStepSize = 10
        TOSmooth = 10
        TOPower = 2
        TOPValCOff = LowestProb
        TOTvTs = 2
        TOFreqFlag = 0
        TOFreqA = 0.25
        TOFreqC = 0.25
        TOFreqG = 0.25
        TOFreqT = 0.25
    End If
    If SetDef = 1 Then
        AllowConflict = 1
    Else
        If AllowConflict < 0 Then AllowConflict = 0
        If AllowConflict > 1 Then AllowConflict = 1
        AllowConflict = Int(AllowConflict)
    End If
    
    If MatPermNo = 0 Or SetDef = 1 Then
        MatPermNo = 1000
        MatWinSize = 200
    End If
    
    If BSFreqA = 0 Or SetDef = 1 Then
        BSTypeFlag = 0
        BSFreqA = 0.25
        BSFreqC = 0.25
        BSFreqG = 0.25
        BSFreqT = 0.25
    End If
End Sub

Public Sub MakeEList(NextNo As Long, EList() As Integer, ISeqs() As Long, INList() As Byte, SAMatSmall() As Single, FAMatSmall() As Single)
Dim x As Long, Y As Long, Z As Long

For x = 0 To 2
             
    For Y = 0 To 2
        For Z = 0 To NextNo
            EList(x, Y, Z) = -1
        Next Z
    Next Y
Next x
'DO NO - ie we do the situation where the outlyer in the recombinant region is recombinant
'we are assuming that iseqs(inlist(0)) is the recombinant and trying to
'figure out what rlists would be obtained if this were the case



For x = 0 To NextNo
    If FAMatSmall(INList(0), x) < FAMatSmall(INList(0), ISeqs(INList(1))) And SAMatSmall(INList(0), x) < SAMatSmall(INList(0), ISeqs(INList(1))) Then
        EList(0, INList(0), x) = 0
    End If
    
    If FAMatSmall(INList(0), x) < FAMatSmall(INList(0), ISeqs(INList(2))) And FAMatSmall(INList(0), x) > 0 And SAMatSmall(INList(1), x) < SAMatSmall(INList(0), ISeqs(INList(1))) Then
        EList(0, INList(1), x) = 0
    End If
    
    If FAMatSmall(INList(0), x) > FAMatSmall(INList(0), ISeqs(INList(2))) And SAMatSmall(INList(0), x) > SAMatSmall(INList(2), x) Then
        EList(0, INList(1), x) = 2
    End If
    
    If FAMatSmall(INList(0), x) > FAMatSmall(INList(0), ISeqs(INList(1))) And SAMatSmall(INList(0), x) > SAMatSmall(INList(1), x) Then
        EList(0, INList(2), x) = 0
    End If
    If FAMatSmall(INList(0), x) < FAMatSmall(INList(0), ISeqs(INList(1))) And FAMatSmall(INList(0), x) > 0 And SAMatSmall(INList(0), x) > SAMatSmall(INList(1), x) Then
        EList(0, INList(2), x) = 2
    End If
    
Next x

'DO PI - ie we do the situation where the inlyer in both the recombinant region and
'the background is recombinant
'we are assuming that iseqs(inlist(1)) is the recombinant and trying to
'figure out what rlists would be obtained if this were the case
For x = 0 To NextNo
    If FAMatSmall(INList(1), x) > 0 And FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(2))) And SAMatSmall(INList(1), x) > SAMatSmall(INList(0), x) Then
        EList(1, INList(0), x) = 0
    End If
    If FAMatSmall(INList(2), x) > 0 And FAMatSmall(INList(2), x) < FAMatSmall(INList(1), ISeqs(INList(2))) And SAMatSmall(INList(2), x) > SAMatSmall(INList(1), ISeqs(INList(2))) Then
        EList(1, INList(0), x) = 1
    End If
    
    If FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(0))) And SAMatSmall(INList(1), x) < SAMatSmall(INList(1), ISeqs(INList(0))) Then
        EList(1, INList(1), x) = 0
    End If
    
    If FAMatSmall(INList(2), x) < FAMatSmall(INList(0), ISeqs(INList(2))) And SAMatSmall(INList(2), x) < FAMatSmall(INList(0), ISeqs(INList(2))) Then
        EList(1, INList(2), x) = 0
    End If
    If FAMatSmall(INList(1), x) > FAMatSmall(INList(1), ISeqs(INList(0))) And FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(2))) Then
        EList(1, INList(2), x) = 1
    End If
    If FAMatSmall(INList(1), x) > 0 And FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(0))) And SAMatSmall(INList(1), x) < SAMatSmall(INList(1), ISeqs(INList(0))) Then
        EList(1, INList(2), x) = 4
    End If
Next x

'DO NI - ie we do the situation where the outlyer in the background region is recombinant
'we are assuming that iseqs(inlist(2)) is the recombinant and trying to
'figure out what rlists would be obtained if this were the case
For x = 0 To NextNo
    If FAMatSmall(INList(1), x) > 0 And FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(2))) Then
        EList(2, INList(0), x) = 0
    End If
    If FAMatSmall(INList(2), x) > 0 And FAMatSmall(INList(2), x) < FAMatSmall(INList(0), ISeqs(INList(2))) And SAMatSmall(INList(2), x) < SAMatSmall(INList(0), x) Then
        EList(2, INList(0), x) = 1
    End If
    
    If FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(0))) And SAMatSmall(INList(1), x) < SAMatSmall(INList(1), ISeqs(INList(0))) Then
        EList(2, INList(1), x) = 0
    End If
    If FAMatSmall(INList(2), x) > 0 And FAMatSmall(INList(2), x) < FAMatSmall(INList(0), ISeqs(INList(2))) And SAMatSmall(INList(2), x) < FAMatSmall(INList(0), x) Then
        EList(2, INList(1), x) = 4
    End If
    If FAMatSmall(INList(1), x) > FAMatSmall(INList(1), ISeqs(INList(0))) And FAMatSmall(INList(1), x) < FAMatSmall(INList(1), ISeqs(INList(2))) Then
        EList(2, INList(1), x) = 2
    End If
    
    If FAMatSmall(INList(2), x) < FAMatSmall(INList(0), ISeqs(INList(2))) And SAMatSmall(INList(2), x) < SAMatSmall(INList(0), ISeqs(INList(2))) Then
        EList(2, INList(2), x) = 0
    End If
    
Next x

End Sub
 Public Sub RecombMapIIIS()
'Call RecombMapIII
'
'  Exit Sub
    ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    
    Call UnModNextno
    Call UnModSeqNum(0)
    Dim TargetS(4) As Single
    'tragets(4) = 0.0005
    TargetS(0) = 0.005
    TargetS(1) = 0.025
    TargetS(2) = 0.975
    TargetS(3) = 0.995
    CurrentlyRunningFlag = 1
    Call DisableInterface
    If Form1.Combo1.ListIndex = 18 Then
        Call RecombMapIIIc
        
        
        CurrentlyRunningFlag = 0
        Call EnableInterface
        
        Exit Sub
    End If
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double, Win As Long
    
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    Dim PermutationX As Long
    
    PermutationX = MatPermNo
    
    If PermutationX * Len(StrainSeq(0)) > 50000000 Then
        PermutationX = 50000000 / Len(StrainSeq(0))
    End If
    'Exit Sub
    If PermutationX > 10000 Then PermutationX = 10000
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
    
    Dim BPV() As Double
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
    
    For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                    If XoverList(x, Y).Eventnumber <= Eventnumber Then
                        If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                            BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                        End If
                    End If
                End If
            Next Y
    Next x
    Dim PValCon As Double
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
    
    
    Dim AccX As Byte, NAccX As Byte
    AccX = 0
    NAccX = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            
            If XoverList(x, Y).Accept = 1 Then
                AccX = 1
                If NAccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            ElseIf XoverList(x, Y).Accept = 0 Then
                NAccX = 1
                If AccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            End If
            
        Next Y
        
    Next x
    
    
    If AccX = 1 And NAccX = 1 Then
        If CLine = "" Or CLine = " " Then
            If ReassortmentFlag = 1 Then
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination/reassortment events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the plot being constructed based only on accepted recombination/reassortment events. Pressing 'No' will result in the plot being constructed based on all un-rejected recombination/reassortment events.", vbYesNo, "Construct a breakpoint distribution plot")
            Else
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the plot being constructed based only on accepted recombination events. Pressing 'No' will result in the plot being constructed based on all un-rejected recombination events.", vbYesNo, "Construct a breakpoint distribution plot")
            End If
        Else
            Response = 7 'No
        End If
        If Response = 6 Then 'yes
            UseAll = 0
        Else
            UseAll = 1
        End If
    Else
        UseAll = 1
    End If
    
    
    Dim OnlyReassortmentFlag As Byte '0 = consider both recombination and reassortment, 1 = only reassortment, 2 = only recombination
    
    If ReassortmentFlag > 0 Then
        Dim Segbound() As Byte
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                tBP = RBPPos(x)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
        
        Dim ReassortmentNo As Long, RecombinationNo As Long
        
        For x = 0 To SEventNumber
            
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or UseAll = 1 Then
                If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
                    ReassortmentNo = ReassortmentNo + 1
                Else
                    RecombinationNo = RecombinationNo + 1
                End If
                If RecombinationNo > 0 And ReassortmentNo > 0 Then
                    Exit For
                End If
            End If
        Next x
        If RecombinationNo > 0 And ReassortmentNo > 0 Then
            Response = MsgBox("Both reassortment and recombination events have been detected. Would you like to only consider the recombination events? It would make sense to ignor the reassortment events because their associated 'breakpoints' are not real.", vbYesNo, "Construct a breakpoint distribution plot")
            If Response = 7 Then
                Response = MsgBox("OK. So would you like to only consider the reassortment events then? Reassortment events don't really involve breakpoints so this analysis would be kind've meaningless. If you press 'no' then both the recombination and reassortment events will be considered (which will be another meaningless type of analysis).", vbYesNo, "Construct a breakpoint distribution plot")
                If Response = 7 Then
                    OnlyReassortmentFlag = 0
                Else
                    OnlyReassortmentFlag = 1
                End If
            Else
                OnlyReassortmentFlag = 2
            End If
        Else
            OnlyReassortmentFlag = 0
        End If
    Else
        OnlyReassortmentFlag = 0
    End If
    
    
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).Eventnumber <= Eventnumber Then
                Enu = SuperEventList(XoverList(x, Y).Eventnumber)
                If Excl(Enu) = 0 Then
                    'If Enu = 4 Then
                    '    X = X
                    'End If
                    'If Enu = 23 Then
                    '    X = X
                    'End If
                    NC = 0
                    For Z = 0 To AddNum - 1
                        If BPV(Enu, Z) < LowestProb Then
                        
                            NC = NC + 1
                        
                        End If
                    Next Z
                    
                    
                    If Enu > 0 And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                        If OnlyReassortmentFlag = 0 Then
                            Excl(Enu) = 1
                        ElseIf OnlyReassortmentFlag = 1 Then 'only reassortment
                            If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) = 1 Then
                                Excl(Enu) = 1
                            End If
                        ElseIf OnlyReassortmentFlag = 2 Then 'only recombination
                            If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) <> 1 And Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) <> 1 Then
                                Excl(Enu) = 1
                            End If
                        End If
                    
                    End If
                End If
            End If
        Next Y
    Next x
   
    
    Dim BPos() As Long, TypeSeq
    Call MakeAPos(APos(), BPos())
    
    TypeSeq = TypeSeqNumber
    
    Win = MatWinSize
    If Win = 0 Then Win = 200
    b = 0
    C = 0
    
    
    
    If ExRecFlag = 1 Then
        MultBPFlag = 0
        For x = 0 To NextNo
            If CurrentXOver(x) > 2 Then
                MultBPFlag = 1: Exit For
            End If
        Next x
        If MultBPFlag = 1 Then
            'sort out plant numbers
            Dim TraceHost() As Long, KeepTrack As Long
            Call GetPlantNums(KeepTrack, TraceHost())
            
            Dim IntervalMap() As Long, CountPos As Long
            Call MakeIntervalMap(CountPos, IntervalMap())
            
            
            
            Dim DoneMap() As Byte
            ReDim DoneMap(CountPos, KeepTrack)
        End If
        
        
    End If
    
    
    If BPCvalFlag = 0 Or x = x Then
        BPCvalFlag = 1
        ReDim BPCVal(1, 1)
         Dim DN As Long
        DN = 1
        'Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
        'Dim oPermutationX As Long
        'oPermutationX = PermutationX
        Call RecombMapPermsS(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3, TargetS())
        'PermutationX = oPermutationX
        x = x
        'Exit Sub
    End If
    
    Dim ModnumX() As Double, ModnumY() As Double
    ReDim ModnumX(NextNo), ModnumY(Len(StrainSeq(0)))
    
    If AbortFlag = 1 Then
        Screen.MousePointer = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        AbortFlag = 0
        CurrentlyRunningFlag = 0
        Call EnableInterface
        Exit Sub
    End If
    
    If ExRecFlag = 2 Then
        For x = 0 To NextNo - 1
            If ParentSeqs(0) <> x And ParentSeqs(1) <> x Then
                
                    For Y = 1 To Len(StrainSeq(0))
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            ST = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = Len(StrainSeq(0)) To 1 Step -1
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            EN = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = ST To EN
                        
                        ModnumY(Y) = ModnumY(Y) + 1
                        
                    Next Y
                    x = x + 1
            End If
        Next x
        'XX = ModnumY(1690)
        For x = 0 To NextNo
            'pair_00-85_461A-210C    0,0739
            
            'pair_00-85_859A-914G    0,0654
            'pair_Heather_A115-D89   0,1000
            'pair_Heather_A115-D126  0,0380
            'pair_Heather_A120-D89   0,0440
            'pair_Heather_D126-A120  0,0480
            'pair_90-35_899-122  0,0591
            'pair_90-35_905A-858G    0,0617
            'pair_140-35_461A-210C   0,0568
            'pair_140-35_461A-1033G  0,0617
            'pair_140-35_461A-2116D  0,0573
            'pair_140-35_914-899     0,0620
            'pair_140-35_O5-914G     0,0216
            'pair_140-35_O5-O2   0,0596
            'pair_140-03_899-914     0,0990
            'pair_EPRRE-03_899A-122D     0,0526
            
            'pair_00-85_461A-1033G   0,0761
            If InStr(1, OriginalName(x), "AG00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7610 / 20)
            ElseIf InStr(1, OriginalName(x), "AC00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7390 / 22)
            ElseIf InStr(1, OriginalName(x), "859A-914G00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6540 / 15)
            ElseIf InStr(1, OriginalName(x), "D126-A120", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4800 / 43)
            ElseIf InStr(1, OriginalName(x), "A120-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4400 / 21)
            ElseIf InStr(1, OriginalName(x), "A115-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(10000 / 20)
            ElseIf InStr(1, OriginalName(x), "A115-D126", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(3800 / 20)
            ElseIf InStr(1, OriginalName(x), "A905-G858", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 38)
            ElseIf InStr(1, OriginalName(x), "899A-122D", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5910 / 33)
            ElseIf InStr(1, OriginalName(x), "O32-O35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5960 / 24)
            ElseIf InStr(1, OriginalName(x), "G914-O32", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(2160 / 18)
            ElseIf InStr(1, OriginalName(x), "AG140-35b", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5730 / 25)
            ElseIf InStr(1, OriginalName(x), "AC140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5680 / 26)
            ElseIf InStr(1, OriginalName(x), "AG140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 26)
            ElseIf InStr(1, OriginalName(x), "A899-G914", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(9900 / 24)
            ElseIf InStr(1, OriginalName(x), "914G-899A", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6200 / 24)
            ElseIf InStr(1, OriginalName(x), "A899-D122", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5260 / 14)
            Else
                ModnumX(x) = 1
            End If
            
            
        Next x
    Else
        For x = 0 To NextNo
            ModnumX(x) = 1
        Next x
         For Y = 1 To Len(StrainSeq(0))
            ModnumY(Y) = 1
        Next Y
    End If

    'Make exclusions
    'maxm = 0
    BPNum = 0
    
    'Open "bpdist.csv" For Output As #10
    Dim Par1 As Long, Pasr2 As Long
    For x = 1 To ENumb
        
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
           
            
            If x = x Then
                D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending ' 596,817,596,595,564,595,789,696,932,752
                
                If ExRecFlag = 1 Then
                    
                    
                   
                    If PermPlantNum(D) > 0 Then
'                        If Chimaeraflag = 1 Then
'                           Par1 = RefChimaera(PermPlantNum(D), 0)
'                           Par2 = RefChimaera(PermPlantNum(D), 1)
'                        Else
'                           Par1 = ParentSeqs(0)
'                           Par2 = ParentSeqs(1)
'                        End If
                        If MultBPFlag = 1 Then
                            MapPos = IntervalMap(ST)
                            CurHost = TraceHost(D)
                            If DoneMap(MapPos, CurHost) = 0 Then
                                DoneMap(MapPos, CurHost) = 1
                                Size = 1
                                RecMap(ST) = RecMap(ST) + (1 / Size) * ModnumX(D)
                                BPNum = BPNum + ModnumX(D)
                                
                            
                            End If
                        Else
                            Size = 1
                            RecMap(ST) = RecMap(ST) + (1 / Size) * ModnumX(D)
                            BPNum = BPNum + ModnumX(D)
                        End If
                    End If
                Else
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        'zzz = zzz + 1
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 Then
                           ' Print #10, APos(ST)
                            Z = ST
                            Size = 1
                            If Z <= ST Then
                                For Y = Z To ST
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            Else
                                For Y = Z To Len(StrainSeq(0))
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                                For Y = 1 To ST
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            End If
                            'zzz = zzz + 1
                        Else
                            x = x
                        End If
                        If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 Then
                            Z = EN
                            Size = 1
                            'zzz = zzz + 1
                            ' Print #10, APos(EN)
                            If EN <= Z Then
                                For Y = EN To Z
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            Else
                                For Y = EN To Len(StrainSeq(0))
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                                For Y = 1 To Z
                                    RecMap(Y) = RecMap(Y) + (1 / Size) * ModnumX(D)
                                    BPNum = BPNum + ModnumX(D)
                                    'If RecMap(Y) > maxm Then maxm = RecMap(Y)
                                Next Y
                            End If
                            'RecMap(En) = RecMap(En) + 1
                        Else
                        x = x
                        End If
                    Else
                        x = x
                    End If
                End If
            End If
        End If
    'RecombMapPermsS
        
    Next x
    x = x
    RememberBreakpointNum = BPNum
    Dim tRecMap() As Double
    ReDim tRecMap(UBound(RecMap, 1)) '
    
    'tRecMap() = RecMap()
    'XX = tRecMap(Len(StrainSeq(0)))
    For x = 0 To UBound(RecMap, 1)
        tRecMap(x) = RecMap(x)
    Next x
    ReDim RecMap(Len(StrainSeq(0)))
    Dim SR As Long, ER As Long, PltV As Single
    For x = 1 To SEventNumber
    
        If Excl(x) = 1 Then
            For Y = 0 To UBound(BPProbDist, 1) - 1
'                If Y = 154 Then
'                    x = x
'                End If
                If MapBack(Y + 1, x) > 0 Then
'                    If MapBack(Y + 1, x) > 3100 Then
'                        x = x
'                    End If
'                     Z = APos(MapBack(Y, x))
'                     RecMap(Z) = RecMap(Z) + BPProbDist(Y, x)
                    
                    SR = (MapBack(Y, x))
                    ER = (MapBack(Y + 1, x))
                    
                    If ER <> SR Then
                        PltV = BPProbDist(Y, x) / (ER - SR)
                        For Z = SR To ER - 1
                            RecMap(Z) = RecMap(Z) + PltV
                        Next Z
                    Else
                        BPProbDist(Y + 1, x) = BPProbDist(Y + 1, x) + BPProbDist(Y, x)
                    End If
                End If
            Next Y
            x = x
        End If
    Next x
    
    
    
    XX = BPNum '385
  '  Close #10
    XX = RecMap(Len(StrainSeq(0)))
    For x = 1 To Len(StrainSeq(0))
        If ModnumY(x) > 1 Then
'            If RecMap(X) > 0 Then
'                X = X
'            End If
        
            RecMap(x) = CLng(RecMap(x) / ModnumY(x))
            x = x
        End If
    Next x
    
    Erase ModnumY
    
    'XX = RecMap(697)
    
    'Map sites to positions in type sequence that will be used to modify the plot
    
    PPMax = 0
    
    For x = 1 To Len(StrainSeq(0))
        If RecMap(x) > PPMax Then PPMax = RecMap(x)
    Next x
    Dim hWin As Long
    hWin = CLng(Win / 2)
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        
        If CircularFlag = 0 And x = 12345 Then
            ST = CLng(Win / 2)
            EN = APos(Len(StrainSeq(0))) - ST
        Else
            ST = 1
            EN = APos(Len(StrainSeq(0)))
        End If
    Else
        ST = 1
        EN = Decompress(Len(StrainSeq(0)))
        
    End If
    Dim Tot As Double
    mrs = 0
    
        
    Tot = 0
    lastv = -1
    lastw = -1
    For x = ST To EN
        
        
        If x = ST Then 'if this is the first window
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then 'if there is no compression
                'do first window
                For A = ST - hWin To ST + hWin - 1
                    If CircularFlag = 1 Or (A >= ST And A <= EN) Then
                        If A < 1 Then
                            STX = APos(Len(StrainSeq(0))) + A
                            If STX < Len(StrainSeq(0)) Then
                                ENX = BPos(STX + 1) - 1
                            ElseIf STX = Len(StrainSeq(0)) Then
                                ENX = Len(StrainSeq(0))
                            Else
                                ENX = BPos(STX + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                            End If
                            STX = BPos(STX)
                        
                        ElseIf A > APos(Len(StrainSeq(0))) Then
                            STX = A - APos(Len(StrainSeq(0)))
                            ENX = BPos(STX + 1) - 1
                            STX = BPos(STX)
                        Else
                            ENX = BPos(A + 1) - 1
                            STX = BPos(A)
                        End If
                        If ENX = 0 Then ENX = Len(StrainSeq(0))
                    
                        For V = STX To ENX
                            Z = Recompress(V)
                        
                            If Z < 1 Then
                                Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                
                            ElseIf Z > Len(StrainSeq(0)) Then
                                Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                
                            Else
                                Tot = Tot + RecMap(Z)
                                
                            End If
                        Next V
                        
                    
                    End If
                Next A
            Else 'if there is compression
                'do first window
                
                For A = ST - hWin To ST + hWin - 1
                    If CircularFlag = 1 Or (A >= ST And A <= EN) Then
                        If A < 1 Then
                            STX = Decompress(Len(StrainSeq(0))) + A
                            If STX < Decompress(Len(StrainSeq(0))) Then
                                ENX = (STX + 1) - 1
                            ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                                ENX = Decompress(Len(StrainSeq(0)))
                            Else
                                ENX = STX + 1
                            End If
                            STX = STX
                        
                        ElseIf A > Decompress(Len(StrainSeq(0))) Then
                            STX = A - Decompress(Len(StrainSeq(0)))
                            ENX = (STX + 1) - 1
                            STX = (STX)
                        Else
                            ENX = (A + 1) - 1
                            STX = (A)
                        End If
                        If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                        If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                    
                        For V = STX To ENX
                            Z = Recompress(V)
                            If Z <> lastv Then
                                If Z < 1 Then
                                    Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                    lastw = Z
                                    
                                ElseIf Z > Len(StrainSeq(0)) Then
                                    Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                    lastw = Z
                                    
                                Else
                                    Tot = Tot + RecMap(Z)
                                    lastw = Z
                                    
                                End If
                                lastv = Z
                            End If
                        Next V
                        If Tot > 0 Then
                            x = x
                        End If
                        x = x
                    
                    End If
                Next A
            End If
            x = x
            
        Else
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then 'i.e. no compression
                
                A = x - hWin - 1
'                If CircularFlag = 0 Then
'                    If A < 1 Then A = 1
'                End If
                If CircularFlag = 1 Or (A >= ST And A <= EN) Then
                    If A < 1 Then
                        
                        STX = APos(Len(StrainSeq(0))) + A
                        'ENX = BPos(STX - 1) + 1
                        If STX < Len(StrainSeq(0)) Then
                            ENX = BPos(STX - 1) + 1
                        ElseIf STX = Len(StrainSeq(0)) Then
                            ENX = Len(StrainSeq(0))
                        Else
                            ENX = BPos(STX + 1 - Len(StrainSeq(0))) + Len(StrainSeq(0))
                        End If
                        
                        STX = BPos(STX)
                    
                    ElseIf A > APos(Len(StrainSeq(0))) Then
                        STX = A - APos(Len(StrainSeq(0)))
                        ENX = BPos(STX - 1) + 1
                        STX = BPos(STX)
                    Else
                        ENX = BPos(A - 1) + 1
                        STX = BPos(A)
                       
                    End If
                    'If ENx <> stx Then
                    '    X = X
                    'End If
                    For Z = ENX To STX
                        If Z < 1 Then
                            Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                        Else
                            Tot = Tot - RecMap(Z)
                        End If
                    Next Z
                End If
                
                A = x + hWin - 1
                If CircularFlag = 1 Or (A >= ST And A <= EN) Then
                    If A < 1 Then
                            STX = APos(Len(StrainSeq(0))) + A
                            ENX = BPos(STX + 1) - 1
                            STX = BPos(STX)
                        
                        ElseIf A >= APos(Len(StrainSeq(0))) Then
                            STX = A - APos(Len(StrainSeq(0)))
                            ENX = BPos(STX + 1) - 1
                            STX = BPos(STX)
                        Else
                            ENX = BPos(A + 1) - 1
                            STX = BPos(A)
                        
                    End If
                    
                    For Z = STX To ENX
                        If Z < 1 Then
                            Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                            
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                            
                        Else
                            Tot = Tot + RecMap(Z)
                            
                        End If
                    Next Z
                End If
'                If Tot <> 0 Then
'                    x = x '565-u,571-u-u,597-u-u-u,615-d,646-d-d,647-d-d-d,753-u,803-d,818 -u,868-d,933-u,983-d
'                End If
                If Tot < 0 Then
                    Tot = 0 'this is needed because occasionally a -1 is possible because w're looking at breakpoints
                                        'mapped from the alignment onto individuals equences that may have gaps at particular alignment
                                        'positions
                End If
            
            Else 'there is compression
                A = x - hWin - 1
                If CircularFlag = 1 Or (A >= ST And A <= EN) Then
                    If A < 1 Then
                        STX = Decompress(Len(StrainSeq(0))) + A
                        If STX < Decompress(Len(StrainSeq(0))) Then
                            ENX = (STX + 1) - 1
                        ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                            ENX = Decompress(Len(StrainSeq(0)))
                        Else
                            ENX = STX + 1
                        End If
                        STX = STX
                    
                    ElseIf A > Decompress(Len(StrainSeq(0))) Then
                        STX = A - Decompress(Len(StrainSeq(0)))
                        ENX = (STX + 1) - 1
                        STX = (STX)
                    Else
                        ENX = (A + 1) - 1
                        STX = (A)
                    End If
                    If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                    If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                    
                    For V = STX To ENX
                        Z = Recompress(V)
                        If Z <> lastv Then
                            If Z < 1 Then
                                Tot = Tot - RecMap(Len(StrainSeq(0)) + Z)
                                
                            ElseIf Z > Len(StrainSeq(0)) Then
                                Tot = Tot - RecMap(Z - Len(StrainSeq(0)))
                                
                            Else
                                Tot = Tot - RecMap(Z)
                                
                            End If
                            lastv = Z
                            
                        End If
                    Next V
                End If
                A = x + hWin - 1
                If CircularFlag = 1 Or (A >= ST And A <= EN) Then
                    If A < 1 Then
                        STX = Decompress(Len(StrainSeq(0))) + A
                        If STX < Decompress(Len(StrainSeq(0))) Then
                            ENX = (STX + 1) - 1
                        ElseIf STX = Decompress(Len(StrainSeq(0))) Then
                            ENX = Decompress(Len(StrainSeq(0)))
                        Else
                            ENX = STX + 1
                        End If
                        STX = STX
                    
                    ElseIf A > Decompress(Len(StrainSeq(0))) Then
                        STX = A - Decompress(Len(StrainSeq(0)))
                        ENX = (STX + 1) - 1
                        STX = (STX)
                    Else
                        ENX = (A + 1) - 1
                        STX = (A)
                    End If
                    If ENX = 0 Then ENX = Decompress(Len(StrainSeq(0)))
                    If ENX > Decompress(Len(StrainSeq(0))) Then ENX = Decompress(Len(StrainSeq(0)))
                    
                    For V = STX To ENX
                        'Z = v
                        Z = Recompress(V)
                       ' If Z = 1 Then
                       '     X = X
                       ' End If
                        
                        If Z <> lastw Then
                            If Z < 1 Then
                                Tot = Tot + RecMap(Len(StrainSeq(0)) + Z)
                                
                            ElseIf Z > Len(StrainSeq(0)) Then
                                Tot = Tot + RecMap(Z - Len(StrainSeq(0)))
                                
                            Else
                                Tot = Tot + RecMap(Z)
                                
                            End If
                            lastw = Z
                        End If
                    Next V
                End If
                
                If Tot < 0 Then
                    Tot = 0 'this is needed because occasionally a -1 is possible because w're looking at breakpoints
                                        'mapped from the alignment onto individuals equences that may have gaps at particular alignment
                                        'positions
                End If
            End If
        
            
        
        End If
        
        RecMapSmooth(Recompress(x)) = Tot / Win
        '565-u,571-u-u,597-u-u-u,615-d,646-d-d,647-d-d-d,753-u,803-d,818 -u,868-d,933-u,983-d
        
        If mrs < RecMapSmooth(Recompress(x)) Then
            mrs = RecMapSmooth(Recompress(x))
        End If
    Next x
    
   'XX = RecMapSmooth(799) '0.11'0.12'0.14
        'XX = RecMapSmooth(565)
        
        
    For x = 0 To UBound(RecMap, 1)
        RecMap(x) = tRecMap(x)
    Next x
        
        
    x = x
    'GPerms = 5
    'Adjust recmap
    Dim RMapSmooth() As Double, RMapBounds() As Double
        ReDim RMapSmooth(GPerms, Len(StrainSeq(0)))
 '*************************************
 'This bit gets left out
 '*************************************
    If GPerms > 0 And x = 12345 Then
        
        
        For A = 1 To GPerms
            Tot = 0
            'BPListHolder(X, CPermNo)
            For x = ST To EN
                If x = ST Then
                    'do first window
                    For Z = ST - hWin To ST + hWin - 1
                        If Z < 1 Then
                            'XX = UBound(BPListHolder, 1)
                            Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                        ElseIf Z > Len(StrainSeq(0)) Then
                            Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                        Else
                            Tot = Tot + BPListHolder(Z, A)
                        End If
                        
                    Next Z
                    
                Else
                    Z = x - hWin
                    If Z < 1 Then
                        Tot = Tot - BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot - BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot - BPListHolder(Z, A)
                    End If
                    Z = x + hWin - 1
                    If Z < 1 Then
                        Tot = Tot + BPListHolder(Len(StrainSeq(0)) + Z, A)
                    ElseIf Z > Len(StrainSeq(0)) Then
                        Tot = Tot + BPListHolder(Z - Len(StrainSeq(0)), A)
                    Else
                        Tot = Tot + BPListHolder(Z, A)
                    End If
                    
                End If
                RMapSmooth(A, x) = Tot / Win
            Next x
        Next A
        
        
        Dim OrderArray() As Long, Tester As Double
        ReDim RMapBounds(4, Len(StrainSeq(0)))
        For Y = 1 To Len(StrainSeq(0))
            ReDim OrderArray(GPerms)
            For x = 1 To GPerms
                Tester = RMapSmooth(x, Y)
                For Z = 1 To GPerms
                    If Tester < RMapSmooth(Z, Y) Then OrderArray(x) = OrderArray(x) + 1
                Next Z
                x = x
            Next x
            Dim Target(4) As Double
            Target(0) = Int((GPerms * TargetS(3)) + 1)
            If Target(0) > GPerms Then Target(0) = GPerms
            Target(1) = Int((GPerms * TargetS(2)) + 1)
            If Target(1) > GPerms Then Target(1) = GPerms
            Target(2) = Int((GPerms * TargetS(1)))
            If Target(2) < 0 Then Target(2) = 0
            Target(3) = Int((GPerms * TargetS(0)))
            If Target(3) < 0 Then Target(3) = 0
            Target(4) = Int(GPerms * 0.5)
            
            For x = 0 To 3
                For Z = 1 To GPerms
                    If OrderArray(Z) = Target(x) Then
                        RMapBounds(x, Y) = RMapSmooth(Z, Y)
                        Exit For
                    End If
                Next Z
                If Z > GPerms Then
                    If x < 2 Then
                    'find closest smaller value to target
                        Tot = 0
                        For Z = 1 To GPerms
                            If OrderArray(Z) < Target(x) Then
                                If OrderArray(Z) > Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the smallest value
                            Tot = 0
                            For Z = 1 To GPerms
                                If OrderArray(Z) > Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                    x = x
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    Else
                        'find closest larger value to target
                        Tot = 1000000
                        For Z = 1 To GPerms
                            If OrderArray(Z) > Target(x) Then
                                If OrderArray(Z) < Tot Then
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                End If
                                
                            End If
                           
                        Next Z
                        If Z > GPerms Then
                            'find the largest value
                            Tot = 1000
                            For Z = 1 To GPerms
                                If OrderArray(Z) < Tot Then
                                
                                    Tot = OrderArray(Z)
                                    RMapBounds(x, Y) = RMapSmooth(Z, Y)
                                
                                
                                End If
                             
                            Next Z
                            x = x
                        End If
                    End If
                End If
            Next x
            Tot = 0
            For Z = 1 To GPerms
                Tot = Tot + RMapSmooth(Z, Y)
            Next Z
            RMapBounds(4, Y) = Tot / GPerms
        Next Y
        'RecMapSmooth(X)
        For x = DN To Len(StrainSeq(0)) - DN + 1
            
            RecMapSmooth(x) = RecMapSmooth(x) - RMapBounds(4, x)
        Next x
        
        For x = DN To Len(StrainSeq(0)) - DN + 1
            RMapBounds(0, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(0, x))
            RMapBounds(1, x) = RecMapSmooth(x) + (RMapBounds(4, x) - RMapBounds(1, x))
            RMapBounds(2, x) = RecMapSmooth(x) - (RMapBounds(2, x) - RMapBounds(4, x))
            RMapBounds(3, x) = RecMapSmooth(x) - (RMapBounds(3, x) - RMapBounds(4, x))
            x = x
        Next x
    End If
    '****************************************
    'end of left out bit
    '****************************************
    PPMax = 0
    Dim PPMin As Double
    PPMin = 100
    
    If CLine <> "" Then
        ReDim HSCord(10, 10)
        '0 = hot(1)/cold(0)
        '1 = start bp 95 global
        '2 = end bp 95 global
        '3 = start bp 99 global
        '4 = end bp 99 global
        '5 = start bp 95 local
        '6 = end bp 95 local
        '7 = start bp 99 local
        '8 = end bp 99 local
        HSNum = 0
        If CircularFlag = 1 Then
            ST = DN + 1
            EN = APos(Len(StrainSeq(0)) - DN + 1)
        Else
            ST = CLng(Win / 2) + DN + 1
            EN = APos(Len(StrainSeq(0)) - DN + 1) - CLng(Win / 2)
        End If
        '-f test.txt -nordpfile -nocsvfile -hotspot
        '-f 4 -nordpfile -nocsvfile -hotspot
        Dim LastEqual As Long
        
        For Z = ST To EN
            
            If (RecMapSmooth(Z) * Win) > PValMap(Z, (PermutationX * TargetS(0))) Then '546 = 3, 747=2,817=2, 913=2
                HSNum = HSNum + 1
                If HSNum > UBound(HSCord, 2) Then
                    ReDim Preserve HSCord(10, HSNum + 10)
                End If
                Spos = Z
                LastEqual = Spos
                For A = Spos To EN
                    
                    If (RecMapSmooth(A) * Win) < PValMap(A, (PermutationX * TargetS(0))) Then
                        
                        
                        Epos = LastEqual - 1
                        
                        Exit For
                    
                            
                    ElseIf A = EN Then
                    
                        Epos = A
                    
                    End If
                    If (RecMapSmooth(A) * Win) > PValMap(A, (PermutationX * TargetS(0))) Then
                        LastEqual = A
                    
                    End If
                Next A
                
                Z = A
                HSCord(0, HSNum) = 1 'ie this is a hotspot
                HSCord(3, HSNum) = Spos
                HSCord(4, HSNum) = Epos
                Max = 0
                For A = Spos To Epos
                    If Max < RecMapSmooth(A) * Win Then
                        Max = RecMapSmooth(A) * Win
                    End If
                Next A
                HSCord(1, HSNum) = Max
                'If BPCVal(0, 0) <> BPCVal(0, 1) Then
                '    x = x
                'End If
                For A = Spos To Epos
                    If (RecMapSmooth(A) * Win) >= BPCVal(0, 1) Then
                        Spos = A
                        For b = Epos To A + 1 Step -1
                           If (RecMapSmooth(b) * Win) >= BPCVal(0, 1) Then
                                Exit For
                           End If
                        Next b
                        
                        HSCord(5, HSNum) = Spos
                        HSCord(6, HSNum) = b
                        Epos = b
                        Exit For
                    End If
                    
                Next A
                x = x
                For A = Spos To Epos
                    If (RecMapSmooth(A) * Win) >= BPCVal(0, 0) Then
                        Spos = A
                        For b = Epos To A + 1 Step -1
                           If (RecMapSmooth(b) * Win) >= BPCVal(0, 0) Then
                                Exit For
                           End If
                        Next b
                        
                        HSCord(7, HSNum) = Spos
                        HSCord(8, HSNum) = b
                        Epos = b
                        Exit For
                    End If
                    
                Next A
                x = x
            End If
           ' If PValMap(Z, PermutationX * targets(1)) > 0 Then
           '         x = x
           '     End If
        Next Z
        x = x
        
    End If
    
    
    
    For x = DN To Len(StrainSeq(0)) - DN + 1
        If RecMapSmooth(x) > PPMax Then PPMax = RecMapSmooth(x)
        If RecMapSmooth(x) < PPMin Then PPMin = RecMapSmooth(x)
        
        
        '************************************
        'Restore this if GPerms is reinstated
        '************************************
        'For Y = 0 To 3
        '    If RMapBounds(Y, X) > PPMax Then PPMax = RMapBounds(Y, X)
        '    If RMapBounds(Y, X) < PPMin Then PPMin = RMapBounds(Y, X)
        'Next Y
    Next x
    
    
    
    If PPMax < (BPCVal(0, 0) / Win) Then PPMax = BPCVal(0, 0) / Win
    
    ReDim MCPrintPos(APos(Len(StrainSeq(0))))
    ReDim MCPrintData(6, APos(Len(StrainSeq(0))))
    For Z = 1 To APos(Len(StrainSeq(0)))
        MCPrintData(0, Z) = RecMapSmooth(Z)
        MCPrintPos(Z) = Z
    Next Z
    Dim TempXDiffpos() As Long
    ReDim TempXDiffpos(Len(StrainSeq(0)))
    Z = 1
    For x = 1 To Len(StrainSeq(0))
        TempXDiffpos(x) = XDiffPos(x)
        XDiffPos(x) = 0
        If RecMap(x) > 0 Then
            XDiffPos(Z) = x
            Z = Z + 1
        End If
        
    Next x
    
    Erase RecMap
    Form1.Picture7.Cls
    
    
    
    For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
        
        XDiffPos(x) = APos(XDiffPos(x))
        MCPrintData(6, x) = XDiffPos(x)
        
    Next x
    olenxoverseq = LenXoverSeq
    LenXoverSeq = Z
    MinPVal = PPMax
    MCMinChiP = PPMax
    PPMin = 0
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        GYAxHi(1) = APos(Decompress(Len(StrainSeq(0))))
        'DoAxes 1, Decompress(APos((Len(StrainSeq(0))))), TypeSeq, PPMax * Win, PPMin * Win, 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"
    Else
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'DoAxes 1, Decompress(((Len(StrainSeq(0))))), TypeSeq, PPMax * Win, (PPMin * Win), 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"

    End If
    RDPUD = PPMax * Win
    LenXoverSeq = olenxoverseq
    BSStepWin = Win
    
    
    Dim PV As Double
    LOffset = 30
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        WFactor = ((Form1.Picture7.Width - 40) / Decompress(APos(Len(StrainSeq(0)))))
    Else
        WFactor = ((Form1.Picture7.Width - 40) / Decompress((Len(StrainSeq(0)))))
    End If
    HFactor = (PicHeight - 35)
    TOffset = 20
    Dim PntAPI As POINTAPI
    If Form1.Picture7.DrawWidth = 0 Then Form1.Picture7.DrawWidth = 1
    Form1.Picture7.DrawStyle = 2
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.ForeColor = 0
    'Form1.Picture7.AutoRedraw = True
    'MoveToEx MhDC, LOffset + BE * WFactor, TOffset + (1 - (RecMapSmooth(1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    MhDC = Form1.Picture7.hdc
    
    If PPMax - PPMin > 0 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
'            MoveToEx MhDC, LOffset + Decompress(1) * WFactor - 5, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'
'            MoveToEx MhDC, (LOffset - 5 + Decompress(1) * WFactor), (TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor), PntAPI
'            LineTo MhDC, (LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor), (TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor)
        
        Else
'            MoveToEx MhDC, LOffset + Decompress(1) * WFactor - 5, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress((Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (BPCVal(0, 0) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'
'            MoveToEx MhDC, LOffset - 5 + (Decompress(1) * WFactor), TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + (Decompress((Len(StrainSeq(0)))) * WFactor), TOffset + (1 - (BPCVal(0, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        ' Form1.Picture7.DrawWidth = 100
        'Form1.Picture1.DrawStyle = 1
        'Form1.Picture1.AutoRedraw = True
        'MhDC = Form1.Picture1.hdc
        '                MoveToEx MhDC, 1, 1, PntAPI
        '    LineTo MhDC, 1000, 1000
x = x
        End If
    Else
        PPMax = 1 / Win
        PPMin = 0
'        Form1.Picture7.DrawStyle = 0
'        CurrentlyRunningFlag = 0
'        Call EnableInterface
'        Exit Sub
    End If
    
    MCPrintData(5, 0) = BPCVal(0, 0) / Win
    MCPrintData(5, 1) = BPCVal(0, 1) / Win
    
    Form1.Picture7.DrawStyle = 0
    
    'XX = UBound(PValMap, 2)
    
    
    If x = 12345 Then
    'show only local 99 and 95% CIs
        Form1.Picture7.ForeColor = RGB(255, 255, 255)
        
        If x = x Then ' draw with polygon
            Dim PolyPoints() As POINTAPI
'            Form1.Picture7.Refresh
            ReDim PolyPoints(APos(Len(StrainSeq(0)) - DN + 1) * 2)
            Form1.Picture7.FillStyle = 0
            Form1.Picture7.FillColor = RGB(255, 255, 255)
            A = -1
            For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
            For x = APos(Len(StrainSeq(0)) - DN + 1) To DN Step -1
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
'            Polygon MhDC, PolyPoints(0), A
            
            Form1.Picture7.FillStyle = 0
            Form1.Picture7.FillColor = RGB(150, 150, 150)
            Form1.Picture7.ForeColor = RGB(150, 150, 150)
            A = -1
            For x = DN To APos(Len(StrainSeq(0)) - DN + 1)
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
            For x = APos(Len(StrainSeq(0)) - DN + 1) To DN Step -1
                A = A + 1
                PolyPoints(A).x = LOffset + Decompress(x) * WFactor
                PolyPoints(A).Y = TOffset + (1 - (PValMap(x, PermutationX * TargetS(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
                
            Next x
'            Polygon MhDC, PolyPoints(0), A
            
'            Form1.Picture7.Refresh
            x = x
        Else 'draw it with lines
'            MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * Targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * Targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            For X = DN + 1 To APos((Len(StrainSeq(0))) - DN + 1)
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            Next X
'            Form1.Picture7.ForeColor = RGB(150, 150, 150)
'            MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * Targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + (Decompress(DN)) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * Targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX * Targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            Next X
        End If
        x = x
    ElseIf x = 12345 Then
        'do coulourful plot
        For Z = PermutationX To PermutationX / 2 Step -1
            If Z > 0.75 * PermutationX Then
                Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - PermutationX / 2) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX * 0.75)) / (PermutationX * 0.25)))
            Else
                Form1.Picture7.ForeColor = RGB((200 + 55 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (0 + 255 * (Z - (PermutationX / 2)) / (PermutationX / 2)), (255 - 255 * ((PermutationX * 0.75) - Z) / (PermutationX * 0.25)))
            End If
            
            'Form1.Picture7.ForeColor = RGB(127 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50, 50 + 128 * (Z - 50) / 50)
            'Form1.Picture7.ForeColor = RGB(200 + 55 * (Z - 50) / 50, 0 + 255 * (Z - 50) / 50, 127 + 128 * (Z - 50) / 50)
            
'            MoveToEx MhDC, LOffset + Decompress(1) * WFactor, TOffset + (1 - (PValMap(1, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(1) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0))), Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            For X = 2 To APos(Len(StrainSeq(0)))
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, PermutationX - Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Z) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            Next X
        
        Next Z
    End If
    
    Form1.Picture7.ForeColor = RGB(128, 128, 128)
   ' MoveToEx MhDC, LOffset + 1 * WFactor, TOffset + (1 - (PValmap( 1, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
   ' For X = 2 To Len(StrainSeq(0))
   '     LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValmap( X, 1) / Win - PPMin) / (PPMax - PPMin)) * HFactor
   ' Next X
    Form1.Picture7.ForeColor = RGB(130, 130, 130)
    XX = MCPrintData(1, 0)
    XX = MCPrintData(2, 0)
    XX = MCPrintData(3, 0)
    XX = MCPrintData(4, 0)
   XX = UBound(PValMap, 1)
   If x = 12345 Then
    MCPrintData(1, 1) = PValMap(1, CLng(TargetS(1) * PermutationX)) / Win
    
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(1) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(1) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(1, x) = PValMap(x, TargetS(1) * PermutationX) / Win
    Next x
    
    MCPrintData(2, 1) = PValMap(1, ((TargetS(2) * PermutationX))) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(2) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(2) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(2, x) = PValMap(x, TargetS(2) * PermutationX) / Win
    Next x
    Form1.Picture7.ForeColor = RGB(200, 200, 200)
    MCPrintData(3, 1) = PValMap(1, (TargetS(0) * PermutationX)) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(0) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(0) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(3, x) = PValMap(x, 0.01 * PermutationX) / Win
    Next x
    MCPrintData(4, 1) = PValMap(1, (TargetS(3) * PermutationX)) / Win
'    MoveToEx MhDC, LOffset + Decompress((DN)) * WFactor, TOffset + (1 - (PValMap(DN, Targets(3) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
    For x = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'        LineTo MhDC, LOffset + Decompress(X) * WFactor, TOffset + (1 - (PValMap(X, Targets(3) * PermutationX) / Win - PPMin) / (PPMax - PPMin)) * HFactor
        MCPrintData(4, x) = PValMap(x, TargetS(3) * PermutationX) / Win
    Next x
'    MCPrintData(1, 2) = 100 ' MCPrintData(1, 1)
'    MCPrintData(2, 0) = MCPrintData(2, 1)
'    MCPrintData(3, 0) = MCPrintData(3, 1)
'    MCPrintData(4, 0) = MCPrintData(4, 1)
   End If
    Form1.Picture7.ForeColor = 0
    '***********************************
    'Left out
    '***********************************
    If GPerms > 0 And x = 123425 Then
        Form1.Picture7.DrawWidth = CLng((Form1.Picture7.ScaleWidth - LOffset * 2) / Len(StrainSeq(0)) + 0.5)
        
        Form1.Picture7.DrawStyle = 0
'        For X = 0 To 1
'            If X = 0 Or X = 3 Then
'                Form1.Picture7.ForeColor = HalfColour
'                Y = 3
'            Else
'                Form1.Picture7.ForeColor = RGB(128, 128, 128)
'                Y = 2
'            End If
'            MhDC = Form1.Picture7.hDC
'            MoveToEx MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RMapBounds(X, 1) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'            LineTo MhDC, LOffset + Decompress(BE) * WFactor, TOffset + (1 - (RMapBounds(Y, 1) - PPMin) / (PPMax - PPMin)) * HFactor
'            For Z = 2 To APos(Len(StrainSeq(0)))
'
'                MhDC = Form1.Picture7.hDC
'                LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RMapBounds(X, Z) - PPMin) / (PPMax - PPMin)) * HFactor
'                LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RMapBounds(Y, Z) - PPMin) / (PPMax - PPMin)) * HFactor
'            Next Z
'        Next X
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.DrawStyle = 0
        Form1.Picture7.ForeColor = 0
'        MoveToEx MhDC, LOffset - 5 + 0 * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + Decompress(APos(Len(StrainSeq(0)))) * WFactor, TOffset + (1 - (0 - PPMin) / (PPMax - PPMin)) * HFactor
        Erase RMapBounds
    End If
    
'    Form1.Picture7.ForeColor = 0
'    MhDC = Form1.Picture7.hDC
'    MoveToEx MhDC, LOffset + Decompress(DN) * WFactor, TOffset + (1 - (RecMapSmooth(DN) - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'    For Z = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'
'        MhDC = Form1.Picture7.hDC
'        LineTo MhDC, LOffset + Decompress(Z) * WFactor, TOffset + (1 - (RecMapSmooth(Z) - PPMin) / (PPMax - PPMin)) * HFactor
'    Next Z
    
    

    
'get everything into standard save/copy format
GPrintNum = 2 'three lines
NSites = APos(Len(StrainSeq(0)))


ReDim GVarPos(0, NSites)
For x = 1 To NSites
    GVarPos(0, x) = XDiffPos(x)
Next x
For x = 1 To Len(StrainSeq(0))
    XDiffPos(x) = TempXDiffpos(x)
Next x

Erase TempXDiffpos

ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)

ReDim GCritval(10)



GCritval(2) = BPCVal(0, 0)
GCritval(3) = BPCVal(0, 1)

GLegend = "Breakpoints per " & Trim(Str(Win)) & " nt window"
GPrintLen = NSites * 2  'how many points to plot
GPrintCol(2) = 0 'line is black
GPrintCol(0) = RGB(198, 198, 198) 'RGB(128, 128, 128) 'line is grey
GPrintCol(1) = RGB(128, 128, 128) 'line is light grey

GPrintType = 0 'a normal line plot
GPrintMin(0) = PPMin * Win  'bottom val
GPrintMin(1) = CLng((PPMax * Win) + 0.5) 'upper val


'Form1.Picture7.ForeColor = RGB(255, 255, 255)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(0)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(3)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X
'        Form1.Picture7.ForeColor = RGB(150, 150, 150)
'        MoveToEx MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(DN, PermutationX * targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor, PntAPI
'        LineTo MhDC, LOffset + (DN) * WFactor, TOffset + (1 - (PValMap(APos(Len(StrainSeq(0)) - DN + 1), PermutationX * targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        For X = DN + 1 To APos(Len(StrainSeq(0)) - DN + 1)
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(1)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'            LineTo MhDC, LOffset + X * WFactor, TOffset + (1 - (PValMap(X, PermutationX * targets(2)) / Win - PPMin) / (PPMax - PPMin)) * HFactor
'        Next X

For x = 0 To NSites - 1
    
    GPrint(2, x) = RecMapSmooth(x + 1) * Win 'GraphPlt(0, X)
   ' GPrint(0, NSites * 2 - X) = RecMapSmooth(X + 1) * Win 'GraphPlt(0, X)
    GPrintPos(2, x) = x + 1 'PltPos(X)
   ' GPrintPos(0, NSites * 2 - X) = X + 1 ' PltPos(X)
    
    
Next x

Erase RecMapSmooth

GBlockNum = -1


'PermutationX = 1000
For x = 0 To NSites - 1
    'PValMap(DN, PermutationX * targets(0))
    GPrint(0, x) = PValMap(x + 1, CLng(PermutationX * TargetS(0))) 'GraphPlt(1, X)
    GPrint(0, NSites * 2 - x) = PValMap(x + 1, (UBound(PValMap, 2) + CLng(PermutationX * TargetS(3)) - PermutationX)) 'GraphPlt(2, X)
    GPrintPos(0, x) = x + 1 'PltPos(X)
    GPrintPos(0, NSites * 2 - x) = x + 1 'PltPos(X)
    
    GPrint(1, x) = PValMap(x + 1, CLng(PermutationX * TargetS(1))) 'GraphPlt(1, X)
    GPrint(1, NSites * 2 - x) = PValMap(x + 1, (UBound(PValMap, 2) + CLng(PermutationX * TargetS(2)) - PermutationX)) 'GraphPlt(2, X)
    GPrintPos(1, x) = x + 1 'PltPos(X)
    GPrintPos(1, NSites * 2 - x) = x + 1 'PltPos(X)
Next x
GPrintPos(0, GPrintLen - 1) = GPrintPos(1, 0)
GPrintPos(1, GPrintLen - 1) = GPrintPos(2, 0)
'GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
GPrintPos(0, GPrintLen) = GPrintPos(1, 0)
'GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
GPrintPos(1, GPrintLen) = GPrintPos(2, 0)
'GPrint(0, GPrintLen - 1) = GPrint(0, 0)
GPrint(0, GPrintLen - 1) = GPrint(0, GPrintLen - 2)
GPrint(0, GPrintLen) = GPrint(0, 0)
GPrint(1, GPrintLen - 1) = GPrint(1, GPrintLen - 2)
GPrint(1, GPrintLen) = GPrint(1, 0)
GExtraTNum = 2
ReDim GExtraText(GExtraTNum)
GExtraText(0) = "Breakpoint number"
GExtraText(1) = "Local 95% confidence interval"
GExtraText(2) = "Local 99% confidence interval"


CurrentlyRunningFlag = 0
Call EnableInterface
        
Call RedrawPlotAA(1)
Form1.ZOrder
If DebuggingFlag < 2 Then
    Form1.WindowState = Form1.WindowState
End If
Erase PValMap
    'Call SelectionMod
    
    Form1.Picture7.Refresh
    
    
    
End Sub
Public Function UngapSeq(ByVal InSeq As String) As String
    Dim outSeq As String
    outSeq = ""
    For x = 1 To Len(InSeq)
        If Mid$(InSeq, x, 1) <> "-" Then
            outSeq = outSeq & Mid$(InSeq, x, 1)
        End If
    Next x
    
    UngapSeq = outSeq
End Function

Public Sub Split(ByVal Expression As String, varTemp() As String, Optional Delimiter As String)
    Dim i As Long
    Dim lNextPos As Long
    Dim sText As String
    Dim lCount As Long
   
    For i = 1 To Len(Expression)
        
        lNextPos = InStr(i + 1, Expression, Delimiter)
        If lNextPos = 0 Then
            lNextPos = Len(Expression) + 1
        End If
        sText = Mid$(Expression, i, lNextPos - i)
        ReDim Preserve varTemp(lCount)
        varTemp(lCount) = sText
        lCount = lCount + 1
        i = lNextPos + Len(Delimiter) - 1
        
    Next
    
End Sub

Public Sub SplitSeq(ByVal InputSeq As String, SplitedSeq() As String)
    Dim StringLen As Integer
    StringLen = Len(InputSeq)
    ReDim SplitedSeq(StringLen - 1)
    For Z = 0 To StringLen - 1
        SplitedSeq(Z) = Mid$(InputSeq, Z + 1, 1)
    Next Z
    
End Sub

Public Function FoldSeq(InSeq As String) As Long
   Dim Commandline As String, ProcID As Long
   Commandline = "hybrid-ss-min.exe " & InSeq & " -n " & NA & " -N " & Str(Sodium) & " -M " & Str(Magnasium) & " -t " & Str(MinTemperature) & " -T " & Str(MaxTemperature) & " -C " & Circular & " --mfold " & mFold & " --suffix DAT"
   ProcID = Shell("cmd.exe /c " & Commandline, vbHide)
   FoldSeq = ProcID
   Exit Function
End Function

Public Sub SaveMatrix(Matrix() As Single, ByVal MatrixFileName As String, ByVal dimension As Integer)
    Dim strline As String, FF1 As Long
    FF1 = FreeFile
    If DebuggingFlag < 2 Then On Error Resume Next
    Kill (MatrixFileName)
    On Error GoTo 0
    Open MatrixFileName For Output As #FF1
    For x = 0 To dimension
        For Y = 0 To dimension
            If strline = "" Then
                strline = Str(Matrix(x, Y))
            Else
                strline = strline & vbTab & Str(Matrix(x, Y))
            End If
        Next Y
        Print #FF1, strline
        strline = ""
        DoEvents 'xxxxxxxxxxxxxxxxxxxxxxxpotentially dangerous
    Next x
    Close #FF1
End Sub

Public Sub GetConsensusMatrix(ByVal FullLenSeq As String, ByVal UngappedSeqFile As String, ByVal Index, ByRef minFE As Single, FullSeqMatrixTemp() As Single)
    Dim SeqLenF, SeqLenU As Integer
    SeqLenF = Len(FullLenSeq)
        
    'Create and save the full len temporary sequence matrix
    Dim SplitedFullLenSeq() As String
    ReDim FullSeqMatrixTemp(SeqLenF - 1, SeqLenF - 1)
    
    'ReDim SplitedFullLenSeq(SeqLen)
     Call SplitSeq(FullLenSeq, SplitedFullLenSeq())
      
    'For H = 0 To SeqLenF - 1
     '   For K = 0 To SeqLenF - 1
      '      If SplitedFullLenSeq(K) = "-" Then
       '        FullSeqMatrixTemp(H, K) = 1
        '       FullSeqMatrixTemp(K, H) = 1
         '   End If
        'Next K
    'Next H

    'save the full len matrix where gaps are represented by -1
    Dim MatFileG As String
    'MatFileG = UngappedSeqFile & "_matrixWithGaps_.txt"
    'SaveMatrix FullSeqMatrixTemp(), MatFileG, SeqLenF - 1
  
    'reading the ungapped sequences, get the length of the sequence
    Dim FF As Long, CtFile As String
    If Dir$(UngappedSeqFile) = "" Then
        MsgBox ("Could not find " & Infile)
    End If
    
    Dim Lines() As String, LinesIndex, SeqLenUngapped As Integer
    ReDim Lines(2)
    LinesIndex = 0
    FF = FreeFile()
    Open UngappedSeqFile For Input As #FF '
    Do While Not EOF(FF)
       Line Input #FF, fields
       Lines(LinesIndex) = fields
       'MsgBox (Lines(LinesIndex))
       LinesIndex = LinesIndex + 1
    Loop
    Close #FF
    
      
    SeqLenU = Len(Lines(1))
     
    'create structure matrix
    Dim StructureMatrix() As Single, RecLists() As String, str1 As String, str2() As String, lists() As String
    ReDim StructureMatrix(SeqLenU - 1, SeqLenU - 1)
    'not necessary
       
    'open the ct file, check whether the file exists
    CtFile = UngappedSeqFile & ".ct"
    If Dir$(CtFile) = "" Then
        MsgBox ("Could not find " & CtFile)
    End If
    ' reading in the lines
    Open CtFile For Input As #FF
    
       
    Line Input #FF, fields
    'RecLists = Split(fields)
    Call Split(fields, RecLists())
    str1 = Trim(RecLists(2))
    'str2 = Split(str1, vbTab)
    Call Split(str1, str2(), vbTab)
    
    minFE = CSng(str2(0))
    
    Do While Not EOF(FF)
        Line Input #FF, fields
        If InStr(fields, "dG") = 0 Then
            'PairsLines(PairsLinesIndex) = fields
            Call Split(fields, lists(), vbTab)
            
            If Int(lists(4)) <> 0 Then
                StructureMatrix(Int(lists(5)) - 1, Int(lists(4)) - 1) = StructureMatrix(Int(lists(5) - 1), Int(lists(4)) - 1) + 1
            End If
        End If
    Loop
    Close #FF
    'Save the ungapped sequence structures matrix
    'MatFile = UngappedSeqFile & "Ungapped_Matrix.txt"
    'SaveMatrix StructureMatrix(), MatFile, SeqLenU - 1
    
    'map base pairs positions after condering the initial gap positions
    Dim ValMapping() As Integer
    ReDim ValMapping(SeqLenU - 1)
    Dim Counter As Integer
    
    Counter = 0
    For P = 0 To SeqLenF - 1
        If SplitedFullLenSeq(P) <> "-" Then
            ValMapping(Counter) = P
            Counter = Counter + 1
        
        End If
    Next P
    For r = 0 To SeqLenU - 1
        For T = 0 To SeqLenU - 1
            FullSeqMatrixTemp(ValMapping(r), ValMapping(T)) = StructureMatrix(r, T)
        Next T
    Next r
    'save concensus matrix with gaps
    Dim ConsMatFile As String
    ConsMatFile = UngappedSeqFile & "Cons_matrix.txt"
    Call SaveMatrix(FullSeqMatrixTemp(), ConsMatFile, SeqLenF - 1)
    
End Sub

Public Function ReadMatrix(ByVal MatFileName As String, ByRef TempMatrix() As Single, ByVal dimension As Integer) As Single
    'Dimension = Len(StrainSeq(0))-1
    Dim list_rec() As String
    ReDim list_rec(dimension)

    Dim FF As Long
    FF = FreeFile()
    If Dir$(MatFileName) = "" Then
        MsgBox ("Could not find " & MatFileName)
    End If
    Open MatFileName For Input As #FF
    For x = 0 To dimension
        For Y = 0 To dimension
            Input #FF, TempMatrix(x, Y)
        Next Y
    Next x
    Close #FF
    'ReadMatrix = TempMatrix()
End Function

Public Function GetPairDisruption(P1_Matrix() As Single, P2_Matrix() As Single, Recomb_A() As String, ByVal MatDim, ByRef BpDisruption, ByRef BpCreated)
        'use the recombinant array to check positions that contain bases forming a potential base pair AT CG TGs
        BpCreated = 0
        BpDisruption = 0
        For H = 0 To MatDim
            For k = 0 To MatDim
                If P1_Matrix(H, k) <> 0 And P2_Matrix(H, k) <> 0 Then
                    
                    'P1P2_PairNum = P1P2_PairNum + 1
                    If Recomb_A(H) = "A" Then
                        If Recomb_A(k) <> "T" Then
                            BpDisruption = BpDisruption + 1
                        End If
                    End If
                    If Recomb_A(H) = "T" Then
                        If Recomb_A(k) <> "A" Or Recomb_A(k) <> "G" Then
                            BpDisruption = BpDisruption + 1
                        End If
                    End If
                    If Recomb_A(H) = "C" Then
                        If Recomb_A(k) <> "G" Then
                            BpDisruption = BpDisruption + 1
                        End If
                    End If
                    If Recomb_A(H) = "G" Then
                        If Recomb_A(k) <> "C" Or Recomb_A(k) <> "T" Then
                            BpDisruption = BpDisruption + 1
                        End If
                    End If
                    
                ElseIf P1_Matrix(H, k) = 0 And P2_Matrix(H, k) = 0 Then
                   
                    If (Recomb_A(H) = "A" And Recomb_A(k) = "T") Or (Recomb_A(H) = "T" And Recomb_A(k) = "A") Then
                        BpCreated = BpCreated + 1
                    ElseIf (Recomb_A(H) = "G" And Recomb_A(k) = "T") Or (Recomb_A(H) = "T" And Recomb_A(k) = "G") Then
                        BpCreated = BpCreated + 1
                    ElseIf (Recomb_A(H) = "G" And Recomb_A(k) = "C") Or (Recomb_A(H) = "C" And Recomb_A(k) = "G") Then
                        BpCreated = BpCreated + 1
                    End If
                    
                End If
                    
             Next k
        Next H
End Function
Public Function GetPairDisruption2(P1_Matrix() As Single, P2_Matrix() As Single, Recomb_Mat() As Single, ByVal MatDim, ByRef BpDisrupted, ByRef BpCreated)
    'uses recombinant pairing matrix for recombinat
    BpDisrupted = 0
    BpCreated = 0
    For H = 0 To MatDim
        For k = 0 To MatDim
            If P1_Matrix(H, k) <> 0 And P2_Matrix(H, k) <> 0 And Recomb_Mat(H, k) = 0 Then
                BpDisrupted = BpDisrupted + 1
            ElseIf P1_Matrix(H, k) = 0 And P2_Matrix(H, k) = 0 And Recomb_Mat(H, k) <> 0 Then
                BpCreated = BpCreated + 1
            End If
        Next k
    Next H
End Function
'____________________________________________________
'Public Function VarSites_Counter(PrntOne() As String, PrntTwo() As String, dimension As Integer) As Single
'    Dim VarSiteNumber As Single
'    ReDim VarSite_Arr(dimension - 1)
'    VarSiteNumber = 0
'    For x = 0 To dimension
'        If PrntOne(x) <> "-" And PrntTwo(x) <> "-" And PrntOne(x) <> PrntTwo(x) Then
'
'            VarSiteNumber = VarSiteNumber + 1
'        End If
'    Next x
'    VarSites_Counter = VarSiteNumber
'End Function
'___________________________________________________

Public Function MakeVarSiteArr(PrntOne() As String, PrntTwo() As String, ByRef VarSite_Arr() As Single, dimension As Integer) As Single
    Dim Counter As Integer
    ReDim VarSite_Arr(dimension - 1)
    Counter = 0
    For x = 0 To dimension
        If PrntOne(x) <> "-" And PrntTwo(x) <> "-" And PrntOne(x) <> PrntTwo(x) Then
            VarSite_Arr(Counter) = x
            Counter = Counter + 1
        End If
    Next x
    MakeVarSiteArr = Counter + 1
End Function

Public Function RndNumGen(ByVal UpperBound As Single, ByVal LowerBound As Single)
Randomize
Dim random As Integer
If UpperBound = LowerBound Then
    MsgBox ("error, the lower bound and upper bound are equal, no rnd # can be generated between these 2 values")
ElseIf UpperBound > LowerBound Then
     random = Int(Rnd * (UpperBound - LowerBound)) + LowerBound
Else
    random = Int(Rnd * (LowerBound - UpperBound) + UpperBound)
End If
    RndNumGen = random
End Function

Public Function SaveSeqDols(ByVal InSeq As String, ByVal SeqNum As Long) As String
    Dim InputSeq As String, FF As Long
    InputSeq = "Prnt" & Trim(Str(SeqNum)) & ".fas"
    FF = FreeFile
    If DebuggingFlag < 2 Then On Error Resume Next
    Kill (InputSeq & ".ct")
    On Error GoTo 0
    Open InputSeq For Output As #FF
    Print #FF, ">" & Trim(Str(SeqNum))
    Print #FF, InSeq
    Close #FF
    SaveSeqDols = InputSeq
End Function

Public Function SaveRecomb(ByVal recomb As String, ByVal SeqNum As Long) As String
    Dim InputRecomb As String, FF As Long
    InputRecomb = "Recomb" & Trim(Str(SeqNum)) & ".fas"
    FF = FreeFile
    If DebuggingFlag < 2 Then On Error Resume Next
    Kill (InputRecomb & ".ct")
    On Error GoTo 0
    Open InputRecomb For Output As #FF
    Print #FF, ">" & Trim(Str(SeqNum))
    Print #FF, recomb
    Close #FF
    SaveRecomb = InputRecomb
End Function

Public Function SaveSimRecomb(ByVal recomb As String, ByVal SeqNum As Long) As String
    Dim InputRecomb As String, FF As Long
    InputRecomb = "SimRec" & Trim(Str(SeqNum)) & ".fas"
    FF = FreeFile
    If DebuggingFlag < 2 Then On Error Resume Next
    Kill (InputRecomb & ".ct")
    On Error GoTo 0
    Open InputRecomb For Output As #FF
    Print #FF, ">" & Trim(Str(SeqNum))
    Print #FF, recomb
    Close #FF
    SaveSimRecomb = InputRecomb
End Function

Public Function Save_AllSimRecomb(ByVal Pmjor As String, ByVal Pminor As String, ByVal Recombinent As String, InputArray() As String, ByVal EventNum As Integer)
        Dim FF As Long, RecSeqFile As String
        RecSeqFile = "All_recomb" & Trim(Str(EventNum)) & ".fas"
        FF = FreeFile
        Open RecSeqFile For Output As #FF
        Print #FF, ">Major Parent"
        Print #FF, Pmjor
        Print #FF, ">Minor Parent"
        Print #FF, Pminor
        Print #FF, ">Real Rec"
        Print #FF, Recombinent
        For i = 0 To 99
            Print #FF, ">Rec" & Trim(Str(i))
            Print #FF, InputArray(i)
        Next i
        Close #FF

End Function

Public Function SeqUngapAndFoldDols(ByRef inputAlign() As String, ByVal numProcessor As Integer)
    'set timing
    'process waiting varibles
    Dim lPidList() As Long          'arrays for process IDs
    ReDim lPidList(numProcessor - 1)
    Dim lHnd As Long          'Process Hnd
    Dim lRet As Long          'Return
    
    ProcNum = 0               'store the number of process running
    Dim procIndex As Integer, Seqs As String
    procIndex = 0
    FoldingCancel1 = False
    'folding sequences (4 at a time)
    For CurrentSeq1 = 0 To (NextNo)
        If SeqDolist(CurrentSeq1) = 1 Then
            TempSeq1 = UngapSeq(inputAlign(CurrentSeq1))                       'ungaping the sequence from strainseq and returing the ungapped sequence
            UnafoldInput = SaveSeqDols(TempSeq1, CurrentSeq1)                     'saving the sequence and returning the sequence name for input
            lPidList(procIndex) = FoldSeq(UnafoldInput)
            Form1.ProgressBar1.Value = (CurrentSeq1 / NextNo) * 100        'setting the progress bar to reflect the progress of folding process
            Call UpdateF2Prog
            ProcNum = ProcNum + 1
            procIndex = procIndex + 1
            If Seqs = "" Then
                Seqs = Str(CurrentSeq1)
            ElseIf Seqs <> "" Then
                Seqs = Seqs & ", " & Str(CurrentSeq1)
            End If
            'if test cancell kill all the running jobs
            
            If ProcNum = numProcessor Then
                If numProcessor = 1 Then
                    Form1.SSPanel1.Caption = "Folding parental sequence " & Str(CurrentSeq1) 'caption indicating the sequences being folded
                Else
                    Form1.SSPanel1.Caption = "Folding parental sequences: " & Seqs 'caption indicating the sequences being folded
                End If
                'wait for all the job to fenist before lauching new jobs
                For x = 0 To (numProcessor - 1)
                    If lPidList(x) <> O Then
                    
                        lHnd = OpenProcess(SYNCHRONIZE, 0, lPidList(x))                    'Get a handle to the shelled process.
                        If lHnd <> 0 Then                                       'If successful, wait for the
                            Do
                                lRet = WaitForSingleObject(lHnd, 0)          'application to end.
                                'Sleep (100)
                                DoEvents
                                'If FoldingCancel1 Then
                                '   Exit For
                                'End If
                                'kill all runnig jobs when the user click on cancel button or else wait for the jobs to finish
                                                        
                                If lRet = 0 Then
                                    Exit Do
                                End If
                            Loop
                            CloseHandle (lHnd)
                        End If
                    End If                                                     'reseting the number of process to 0
                Next x
                'If FoldingCancel1 Then Exit For
                ProcNum = 0
                procIndex = 0
                Seqs = ""
            End If
            
        
        End If
        
    Next CurrentSeq1
    
    'kill all runnig jobs when the user click on cancel button or else wait for the jobs to finish
    If FoldingCancel1 = True Then
        
       For P = 0 To (numProcessor - 1)
           If lPidList(P) <> O Then
               Shell "cmd.exe /c " & "taskkill /pid " & Str(lPidList(P))
           End If
       Next P
       Form1.SSPanel1.Caption = "Folding cancelled"
       Form1.ProgressBar1.Value = 0
       Call UpdateF2Prog
        'stop BrejMod2()
     ElseIf (CurrentSeq1 Mod numProcessor) <> 0 Then
        Form1.SSPanel1.Caption = "Folding sequences" & Str(CurrentSeq1 - ((CurrentSeq1 Mod numProcessor) - 1)) & " , " & Str(CurrentSeq1) 'caption indicating the sequences being folded 'displaying the remaining sequence which are being folded
        For x = 0 To (numProcessor - 1)
            If lPidList(x) <> O Then
                lHnd = OpenProcess(SYNCHRONIZE, 0, lPidList(x))                    'Get a handle to the shelled process.
                If lHnd <> 0 Then                                       'If successful, wait for the
                    Do
                        lRet = WaitForSingleObject(lHnd, 0)          'application to end.
                         If lRet = 0 Then
                            Exit Do
                         End If
                    Loop
                    CloseHandle (lHnd)
                End If
            End If                                                     'reseting the number of process to 0
        Next x
       
        'If FoldingCancel1 Then
        '    Exit Sub
        'End If
        'MsgBox ("(" & Trim(Str(Ending - Start)) & " milliseconds)")
    End If
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
End Function

Public Function SNP_Counter(PrntOne() As String, PrntTwo() As String, ByVal StPos As Single, ByVal EndPos As Single, dimension As Integer) As Integer
    Dim SNP_Num As Integer
    SNP_Num = 0
    If StPos < EndPos Then
        If EndPos <= dimension Then
            For x = StPos To EndPos
                If PrntOne(x) <> PrntTwo(x) Then
                    SNP_Num = SNP_Num + 1
                End If
            Next x
        ElseIf EndPos > dimension Then
            For x = StPos To dimension
                If PrntOne(x) <> PrntTwo(x) Then
                    SNP_Num = SNP_Num + 1
                End If
            Next x
            For x = 0 To (EndPos - dimension - 1)
                If PrntOne(x) <> PrntTwo(x) Then
                    SNP_Num = SNP_Num + 1
                End If
            Next x
        End If
    ElseIf StPos > EndPos Then
        If StPos <= dimension Then
            For x = StPos To dimension
                If PrntOne(x) <> PrntTwo(x) Then
                    SNP_Num = SNP_Num + 1
                End If
            Next x
            For x = 0 To EndPos
                If PrntOne(x) <> PrntTwo(x) Then
                    SNP_Num = SNP_Num + 1
                End If
            Next x
            
        ElseIf StPos > dimension Then
            Dim Start1 As Single
            Start1 = StPos - dimension
            If Start1 < EndPos Then
                For x = Start1 To EndPos
                    If PrntOne(x) <> PrntTwo(x) Then
                        SNP_Num = SNP_Num + 1
                    End If
                Next x
            End If
        End If
    End If
    SNP_Counter = SNP_Num
End Function

Public Sub RecombSim2_gaps(ByVal MajorP As String, ByVal MinorP As String, VarSiteArr() As Single, dimension As Integer, NumVarSites As Single, ByVal NumVarSite_Bp1_Bp2 As Single, RecombSim2X As String)
    'allow break points next to the gaps
    Dim SimBreakSt, SimBreakEn, Index As Integer
    Dim SimRecomb As String
        
    Index = RndNumGen(0, NumVarSites - 1)
    
    SimBreakSt = VarSiteArr(Index)
    
        
    If Index + NumVarSite_Bp1_Bp2 <= NumVarSites Then
        SimBreakEn = VarSiteArr(Index + NumVarSite_Bp1_Bp2 - 1)
    ElseIf Index + NumVarSite_Bp1_Bp2 > NumVarSites Then
        SimBreakEn = VarSiteArr((Index + NumVarSite_Bp1_Bp2 - 1) - NumVarSites)
    End If
    SimRecomb = CreateRecomb2(MajorP, MinorP, SimBreakSt, SimBreakEn, dimension + 1)
    RecombSim2X = SimRecomb
    
   'MsgBox ("sim rec: no of variable sites between Bpts" & Str(SNP_Counter2(Prnt1_Arr(), Prnt2_Arr(), SimBreakSt, SimBreakEn, MatDim)) & " sim st pt " & Str(SimBreakSt) & " sim en pt " & Str(SimBreakEn) & "  the lenth of recomb: " & Str(Len(SimRecomb)))
   'DoEvents
End Sub

Public Sub RecombSim(ByVal MajorP As String, ByVal MinorP As String, VarSiteArr() As Single, dimension As Integer, NumVarSites As Single, NumVarSite_Bp1_Bp2 As Single)
    Dim SimBreakSt, SimBreakEn, Index As Integer
    Dim SimRecomb() As String
    ReDim SimRecomb(dimension)
    
    Index = RndNumGen(0, NumVarSites - 1)
    SimBreakSt = VarSiteArr(Index + 1)
    
    If Index + 1 + NumVarSite_Bp1_Bp2 <= NumVarSites - 1 Then
        SimBreakEn = VarSiteArr(Index + 1 + NumVarSite_Bp1_Bp2)
    ElseIf Index + 1 + NumVarSite_Bp1_Bp2 > NumVarSites - 1 Then
        'SimBreakEn = VarSiteArr(NumVarSiteBp1_Bp2 - (NumVarSites - SimBreakSt))
        SimBreakEn = VarSiteArr((Index + 1 + NumVarSite_Bp1_Bp2) - NumVarSites)
    End If
'CreateRecomb(ByVal MajorPrnt As String, ByVal MinorPrnt As String, ByVal BreakSt As Integer, ByVal BreakEn As Integer, ByVal SequenceLen As Integer, TestString() As String)
    Call CreateRecomb(MajorP, MinorP, SimBreakSt, SimBreakEn, dimension + 1, SimRecomb())
    'RecombSim = SimRecomb()
End Sub

Public Sub RecombSim2(ByVal MajorP As String, ByVal MinorP As String, VarSiteArr() As Single, dimension As Integer, NumVarSites As Single, ByVal NumVarSite_Bp1_Bp2 As Single, RecombSim2X As String)
    Dim SimBreakSt, SimBreakEn, Index As Integer
    Dim SimRecomb, bp_neigborhood As String
    Dim bp_flag As Integer
    bp_flag = 0
    For x = 0 To 1000
        Index = RndNumGen(0, NumVarSites - 1)
        SimBreakSt = VarSiteArr(Index)
        If Index + NumVarSite_Bp1_Bp2 <= NumVarSites - 1 Then
            SimBreakEn = VarSiteArr(Index + NumVarSite_Bp1_Bp2)
        ElseIf Index + NumVarSite_Bp1_Bp2 > NumVarSites - 1 Then
            SimBreakEn = VarSiteArr((Index + NumVarSite_Bp1_Bp2) - NumVarSites)
        End If
        'avoid the end break point to fall at position 0
        If SimBreakEn = 0 Then
            SimBreakEn = 1
        End If
        If Mid$(MajorP, SimBreakSt, 1) <> "-" And Mid$(MinorP, SimBreakSt, 1) <> "-" And Mid$(MajorP, SimBreakSt + 1, 1) <> "-" And Mid$(MinorP, SimBreakSt + 1, 1) <> "-" And Mid$(MajorP, SimBreakEn, 1) <> "-" And Mid$(MinorP, SimBreakEn, 1) <> "-" And Mid$(MajorP, SimBreakEn + 1, 1) <> "-" And Mid$(MinorP, SimBreakEn + 1, 1) <> "-" And (Mid$(MajorP, SimBreakSt, 1) = Mid$(MinorP, SimBreakSt, 1) Or Mid$(MajorP, SimBreakSt + 1, 1) = Mid$(MinorP, SimBreakSt + 1, 1)) And (Mid$(MajorP, SimBreakEn, 1) = Mid$(MinorP, SimBreakEn, 1) Or Mid$(MajorP, SimBreakEn + 1, 1) = Mid$(MinorP, SimBreakEn + 1, 1)) Then
            bp_flag = 1
            SimRecomb = CreateRecomb2(MajorP, MinorP, SimBreakSt, SimBreakEn, dimension + 1)
            RecombSim2X = SimRecomb
            Exit For
        End If
    Next x
    If bp_flag = 0 Then
        MsgBox ("all simulated recombination break point are located next to gaps. The recombination siquence could not be constructed")
    End If
    
    
End Sub
Sub CreateRecomb(ByVal MajorPrnt As String, ByVal MinorPrnt As String, ByVal BreakSt As Integer, ByVal BreakEn As Integer, ByVal SequenceLen As Integer, TestString() As String)
   Dim RecSeq As String, Recomb_Arr() As String
    ReDim Recomb_Arr(SequenceLen - 1)
    If BreakSt < BreakEn Then
        If BreakSt > 1 And BreakEn < SequenceLen Then
            RecSeq = Mid$(MajorPrnt, 1, BreakSt - 1) & Mid$(MinorPrnt, BreakSt, BreakEn - (BreakSt - 1)) & Mid$(MajorPrnt, BreakEn + 1, (SequenceLen - (BreakEn)))
        ElseIf BreakSt <= 1 Then
            RecSeq = Mid$(MinorPrnt, 1, BreakEn) & Mid$(MajorPrnt, BreakEn + 1, SequenceLen - BreakEn)
        ElseIf BreakEn >= SequenceLen Then
            RecSeq = Mid$(MajorPrnt, 1, BreakSt - 1) & Mid$(MinorPrnt, BreakSt, SequenceLen - (BreakSt - 1))
        End If
    ElseIf BreakSt > BreakEn Then
        If BreakEn > 1 And breakest < seqnencelen Then
                RecSeq = Mid$(MinorPrnt, 1, BreakEn) & Mid$(MajorPrnt, BreakEn + 1, BreakSt - (BreakEn + 1)) & Mid$(MinorPrnt, BreakSt, SequenceLen - (BreakSt - 1))
        ElseIf BreakEnd <= 1 Then
            RecSeq = Mid$(MajorPrnt, 1, BreakSt) & Mid$(MinorPrnt, BreakSt + 1, SequenceLen - BreakSt)
        End If
    End If
    Call SplitSeq(RecSeq, Recomb_Arr())
    For x = 0 To UBound(TestString, 1)
        TestString(x) = Recomb_Arr(x)
    Next x
End Sub
Public Function CreateRecomb2(ByVal MajorPrnt As String, ByVal MinorPrnt As String, ByVal BreakSt As Integer, ByVal BreakEn As Integer, ByVal SequenceLen As Integer) As String 'creates as saves the recombinant sequence
    Dim RecSeq As String
    If BreakSt < BreakEn Then
        If BreakSt > 1 And BreakEn < SequenceLen Then
            RecSeq = Mid$(MajorPrnt, 1, BreakSt - 1) & Mid$(MinorPrnt, BreakSt, BreakEn - (BreakSt - 1)) & Mid$(MajorPrnt, BreakEn + 1, (SequenceLen - (BreakEn)))
        ElseIf BreakSt <= 1 Then
            RecSeq = Mid$(MinorPrnt, 1, BreakEn) & Mid$(MajorPrnt, BreakEn + 1, SequenceLen - BreakEn)
        ElseIf BreakEn >= SequenceLen Then

            RecSeq = Mid$(MinorPrnt, 1, (BreakEn - SequenceLen)) & Mid$(MajorPrnt, (BreakEn - SequenceLen + 1), BreakSt - (BreakEn - SequenceLen)) & Mid$(MinorPrnt, BreakSt, SequenceLen - BreakSt)
            'RecSeq = Mid$(MajorPrnt, 1, BreakSt - 1) & Mid$(MinorPrnt, BreakSt, SequenceLen - (BreakSt - 1))
        End If
    ElseIf BreakSt > BreakEn Then
        If BreakEn > 1 And BreakSt < SequenceLen Then
                RecSeq = Mid$(MinorPrnt, 1, BreakEn) & Mid$(MajorPrnt, BreakEn + 1, BreakSt - (BreakEn + 1)) & Mid$(MinorPrnt, BreakSt, SequenceLen - (BreakSt - 1))
        ElseIf BreakEn <= 1 Then
            RecSeq = Mid$(MajorPrnt, 1, BreakSt) & Mid$(MinorPrnt, BreakSt + 1, SequenceLen - BreakSt)
        ElseIf BreakSt >= SequenceLen Then
            
            RecSeq = Mid$(MinorPrnt, 1, (BreakSt - SequenceLen)) & Mid$(MajorPrnt, ((BreakSt - SequenceLen) + 1), BreakEn - (BreakSt - SequenceLen)) & Mid$(MinorPrnt, BreakEn, SequenceLen - BreakEn)
            MsgBox (Len(RecSeq))
        
        End If
    End If
    CreateRecomb2 = RecSeq
End Function

Public Function SimRecUngapFold(ByRef inputAlign() As String, ByVal numProcessor As Integer)
    'set timing
    'process waiting varibles
    Dim lPidList() As Long          'arrays for process IDs
    ReDim lPidList(numProcessor - 1)
    Dim lHnd As Long          'Process Hnd
    Dim lRet As Long          'Return
    
    ProcNum = 0               'store the number of process running
    Dim procIndex As Integer
    procIndex = 0
    FoldingCancel1 = False
    
    Dim Seqs As String
    'folding sequences (4 at a time)
    For CurrentSeq1 = 0 To 99
        TempSeq1 = UngapSeq(inputAlign(CurrentSeq1))                       'ungaping the sequence from strainseq and returing the ungapped sequence
        TempSeq1 = inputAlign(CurrentSeq1)
        UnafoldInput = SaveSimRecomb(TempSeq1, CurrentSeq1)                     'saving the sequence and returning the sequence name for input
        lPidList(procIndex) = FoldSeq(UnafoldInput)
        Form1.ProgressBar1.Value = (CurrentSeq1 / 99) * 100          'setting the progress bar to reflect the progress of folding process
        Call UpdateF2Prog
        ProcNum = ProcNum + 1
        procIndex = procIndex + 1
        
        If Seqs = "" Then
            Seqs = Str(CurrentSeq1 + 1)
        ElseIf Seqs <> "" Then
            Seqs = Seqs & ", " & Str(CurrentSeq1 + 1)
        End If
        'if test cancell kill all the running jobs
   
        If ProcNum = numProcessor Then
            If numProcessor = 1 Then
                Form1.SSPanel1.Caption = "Folding simulated recombinants: event" & Str(IndSEvent) & ": " & Str(CurrentSeq1 + 1) 'caption indicating the sequences being folded
            Else
                'Form1.SSPanel1.Caption = "Folding simulated recombinants for event" & Str(IndSEvent) & ", " & Str(Currentseq1 - (numProcessor - 2)) & " - " & Str(Currentseq1 + 1) 'caption indicating the sequences being folded
                Form1.SSPanel1.Caption = "Folding simulated recombinants for event" & Str(IndSEvent) & ": " & Seqs
                Seqs = ""
            End If
            'wait for all the job to fenist before lauching new jobs
            For x = 0 To (numProcessor - 1)
                If lPidList(x) <> O Then
                    
                    lHnd = OpenProcess(SYNCHRONIZE, 0, lPidList(x))                    'Get a handle to the shelled process.
                    If lHnd <> 0 Then                                       'If successful, wait for the
                        Do
                            lRet = WaitForSingleObject(lHnd, 0)          'application to end.
                            'Sleep (100)
                            DoEvents
                            'If FoldingCancel1 Then
                             '   Exit For
                            'End If
                            'kill all runnig jobs when the user click on cancel button or else wait for the jobs to finish
                                                        
                            If lRet = 0 Then
                                Exit Do
                            End If
                        Loop
                        CloseHandle (lHnd)
                    End If
                End If                                                     'reseting the number of process to 0
            Next x
            'If FoldingCancel1 Then Exit For
            ProcNum = 0
            procIndex = 0
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "*.ann"
            On Error GoTo 0
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "*.run"
            On Error GoTo 0
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "*.plot"
            On Error GoTo 0
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "*.dG"
            On Error GoTo 0
        End If
    Next CurrentSeq1
    
    'kill all runnig jobs when the user click on cancel button or else wait for the jobs to finish
    If FoldingCancel1 Then
        
       For P = 0 To (numProcessor - 1)
           If lPidList(P) <> O Then
               Shell "cmd.exe /c " & "taskkill /pid " & Str(lPidList(P))
           End If
      Next P
       Form1.SSPanel1.Caption = "Folding cancelled"
        Form1.ProgressBar1.Value = 0
        Call UpdateF2Prog
        'stop BrejMod2()
    ElseIf (CurrentSeq1 Mod numProcessor) <> 0 Then
        Form1.SSPanel1.Caption = "Folding simulated recombinant " & Str(CurrentSeq1 - ((CurrentSeq1 Mod numProcessor) - 1)) & " - " & Str(CurrentSeq1) 'caption indicating the sequences being folded 'displaying the remaining sequence which are being folded
        For x = 0 To (numProcessor - 1)
            If lPidList(x) <> O Then
                lHnd = OpenProcess(SYNCHRONIZE, 0, lPidList(x))                    'Get a handle to the shelled process.
                If lHnd <> 0 Then                                       'If successful, wait for the
                    Do
                        lRet = WaitForSingleObject(lHnd, 0)          'application to end.
                        'Sleep (100)
                        DoEvents
                        'If FoldingCancel1 Then
                         '   If lRet = 0 Then                        'wait for the remaining processes
                          '      Exit For
                           ' End If
                        'Else
                         If lRet = 0 Then
                            Exit Do
                         End If
                    Loop
                    CloseHandle (lHnd)
                End If
            End If                                                     'reseting the number of process to 0
        Next x
       
        'If FoldingCancel1 Then
        '    Exit Sub
        'End If
        'MsgBox ("(" & Trim(Str(Ending - Start)) & " milliseconds)")
    End If
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
End Function

Public Sub BrejMod5()
Dim Commandline As String, oDir As String, Start As Long, EndingFolding, EndingFullTest As Long, FullTestFlag As Boolean
'make sure that you remember where the user was last on the drive
FullTestFlag = True
Start = Abs(GetTickCount)
oDir = CurDir
ChDir App.Path
ChDrive App.Path

'default values for hybrid-ss-min.exe
If ntType = 0 Then
    NA = "DNA"
Else
    NA = "RNA"
End If

If CircularFlag = 1 Then
    Circular = "circular"
Else
    Circular = "linear"
End If

mFold = "MAX"

'MaxTemperature = 37
MinTemperature = MaxTemperature

Sodium = 1
Magnesium = 0

BatIndex = 127

Dim NumOfProcessor As Integer


LenSeq = Len(StrainSeq(0))          ' DNA/RNA sequence length
MatDim = LenSeq - 1                 ' matrix dimension (Len(StrainSeq(0)-1)

'calling the main function
Dim A, b As Single


ReDim SeqDolist(NextNo)
ReDim StrainSeqDls(NextNo, 2)

If SEventNumber = 0 Then
    MsgBox ("No recombination event detected! The analysis could not proceed!")
    Exit Sub
ElseIf SEventNumber > 0 Then
    Count = 0
    For x = 1 To SEventNumber
        A = BestEvent(x, 0)
        b = BestEvent(x, 1)
        If XoverList(A, b).OutsideFlag = 0 And (XoverList(A, b).MissIdentifyFlag = 0 Or XoverList(A, b).MissIdentifyFlag = 10) Then
            SeqDolist(XoverList(A, b).MajorP) = 1
            SeqDolist(XoverList(A, b).MinorP) = 1
            StrainSeqDls(x, 0) = XoverList(A, b).MajorP
            StrainSeqDls(x, 1) = XoverList(A, b).MinorP
            Count = Count + 1
        End If
    Next x
End If
Dim SysInfo As SYSTEM_INFO
GetSystemInfo SysInfo
NumOfProcessor = SysInfo.dwNumberOrfProcessors
SeqUngapAndFoldDols StrainSeq, NumOfProcessor

'kill unafold temporaly files

If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*.ann"
On Error GoTo 0
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*.run"
On Error GoTo 0
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*.plot"
On Error GoTo 0
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*.dG"
On Error GoTo 0

EndingFolding = Abs(GetTickCount)
Dim ConsMatrix() As Single, AvHumDist As Single, PrntMinFE() As Single
Dim mat1() As Single
Dim mat2() As Single
ReDim mat1(MatDim, MatDim)
ReDim mat2(MatDim, MatDim)
ReDim ConsMatrix(MatDim, MatDim)
ReDim PrntMinFE(NextNo)
x = x

Dim SeqFileName, SeqFileName2 As String

Dim mat() As Single
For x = 0 To NextNo
    If SeqDolist(x) = 1 Then
        Form1.SSPanel1.Caption = "Constructing concensus matrix for parental sequence: " & Str(x)
        Form1.ProgressBar1.Value = (x / NextNo) * 100
        Call UpdateF2Prog
        SeqFileName = "Prnt" & Trim(Str(x)) & ".fas"                 'ungapped fast file
        Call GetConsensusMatrix(StrainSeq(x), SeqFileName, x, minFE, mat())
        PrntMinFE(x) = minFE
    End If
Next x
Form1.ProgressBar1.Value = 0          'progress bar while writing concensus matrices
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
'pairing disruption test
Dim BreakStart, BreakEnd As Single, P_Major, P_Minor As String
Dim P1P2_PairNum, BpCreated, BpDisrupted, DisruptionScore As Single
ReDim Prnt1_Mat(MatDim, MatDim)
ReDim Prnt2_Mat(MatDim, MatDim)
ReDim Prnt1_Arr(MatDim)
ReDim Prnt2_Arr(MatDim)

'open "filex" as binary for output as #1
'put #1, arrayx()
'close#1

'open "filex" as binary for input as #1
'get #1, arrayx()
'close#1


Dim NumSNP, NumVarSites As Single
Dim Recomb_Array() As String, Rec_StrainSeq() As String, SimRec_Mat() As Single, Rec_Mat() As Single, Rec_Seq, Rec_SeqU, Recomb_Nam As String
ReDim Recomb_Array(MatDim)               'MatDim = Len(StrainSeq(0))-1
ReDim Rec_Mat(MatDim)
ReDim SimRec_Mat(MatDim)
Dim Recomb_Sim_Arr() As String
ReDim Recomb_Sim_Arr(MatDim)


'MsgBox ("number of recombination events detected " & Str(SEventNumber))
BpCreated = 0
BpDisrupted = 0
P1P2_PairNum = 0
Dim ConsPair As String, DisruptScores() As Long, BpCreatedScores() As Long, MinFreeEnergy() As Single
ReDim DisruptScores(SEventNumber, 100)
ReDim BpCreatedScores(SEventNumber, 100)
ReDim MinFreeEnergy(SEventNumber, 101)
Dim counterFl As Integer
counterFl = 0

For IndSEvent = 1 To SEventNumber
    A = BestEvent(IndSEvent, 0)
    b = BestEvent(IndSEvent, 1)
    If XoverList(A, b).OutsideFlag = 0 And (XoverList(A, b).MissIdentifyFlag = 0 Or XoverList(A, b).MissIdentifyFlag = 10) Then
        counterFl = counterFl + 1
        Form1.SSPanel1.Caption = "Constructing recombinant for recombination event " & Str(IndSEvent) & "..."
        BreakStart = XoverList(A, b).Beginning
        BreakEnd = XoverList(A, b).Ending
        P1 = XoverList(A, b).MajorP
        P2 = XoverList(A, b).MinorP
        
        Prnt1_MatName = "Prnt" & Trim(Str(P1)) & ".fasCons_matrix.txt"
        Prnt2_MatName = "Prnt" & Trim(Str(P2)) & ".fasCons_matrix.txt"
        'get p2 p1 average minimum free energy
        MinFreeEnergy(IndSEvent, 0) = (PrntMinFE(P1) + PrntMinFE(P2)) / 2
        
        ReadMatrix Prnt1_MatName, Prnt1_Mat(), MatDim
        ReadMatrix Prnt2_MatName, Prnt2_Mat(), MatDim
                    
        P_Major = StrainSeq(P1)
        P_Minor = StrainSeq(P2)
        
        Call SplitSeq(P_Major, Prnt1_Arr())
        Call SplitSeq(P_Minor, Prnt2_Arr())
        
        Dim Scores_file As String, FF As Long
        Scores_file = "BPcount" & Trim(Str(IndSEvent)) & ".txt"
        FF = FreeFile
        If DebuggingFlag < 2 Then On Error Resume Next
        Kill (Scores_file)
        On Error GoTo 0
        Open Scores_file For Output As #FF
        Print #FF, "Seq Name" & vbTab & "Disrupted BP" & vbTab & "Aberrant BP"
                
        If FullTestFlag = True Then
            Rec_Seq = CreateRecomb2(P_Major, P_Minor, BreakStart, BreakEnd, LenSeq) 'full test involve foding each inividual simulated recombinant
            'MsgBox ("real rec: no of var site btwn Bpts " & Str(SNP_Counter2(Prnt1_Arr(), Prnt2_Arr(), BreakStart, BreakEnd, MatDim)) & "; st pt " & Str(BreakStart) & "; en pt " & Str(BreakEnd))
            Rec_SeqU = UngapSeq(Rec_Seq)                       'ungaping the sequence from strainseq and returing the ungapped sequence
            Recomb_Nam = SaveRecomb(Rec_SeqU, IndSEvent)
            Form1.SSPanel1.Caption = "Folding the real recombinant: event " & Str(IndSEvent) & " Major Prnt: " & Str(P1) & " Minor Prnt: " & Str(P2)
            lPid = FoldSeq(Recomb_Nam)
            If lPid <> 0 Then
                lHnd = OpenProcess(SYNCHRONIZE, 0, lPid)       'Get a handle to the shelled process.
                If lHnd <> 0 Then
                    Do
                        lRet = WaitForSingleObject(lHnd, 0)          'application to end.
                        DoEvents
                        If lRet = 0 Then
                             Exit Do
                        End If
                     Loop
                     CloseHandle (lHnd)
                 End If
            End If
            Form1.SSPanel1.Caption = "Calculating the fold disruption score for recombinant " & Str(IndSEvent) & "..."
            Call GetConsensusMatrix(Rec_Seq, Recomb_Nam, IndSEvent, minFE, Rec_Mat())
            
            'Real recombinant minimum free energy
            MinFreeEnergy(IndSEvent, 1) = minFE
            
            GetPairDisruption2 Prnt1_Mat(), Prnt2_Mat(), Rec_Mat(), MatDim, BpDisrupted, BpCreated
            Print #FF, "Real_recomb:" & vbTab & BpDisrupted & vbTab & BpCreated
        ElseIf FullTestFlag = False Then
            Call CreateRecomb(P_Major, P_Minor, BreakStart, BreakEnd, LenSeq, Recomb_Array()) 'created recombinat sequence from break point and parental sequences
            GetPairDisruption Prnt1_Mat(), Prnt2_Mat(), Recomb_Array, MatDim, BpDisrupted, BpCreated
        End If
               
                
        ConsPair = Str(BpDisrupted)
        DisruptScores(IndSEvent, 0) = BpDisrupted
        BpCreatedScores(IndSEvent, 0) = BpCreated
       
        Dim VarSitesArr() As Single
        Dim VarSitesBp1_Bp2 As Single
        
        VarSitesBp1_Bp2 = SNP_Counter(Prnt1_Arr(), Prnt2_Arr(), BreakStart, BreakEnd, MatDim)
        NumVarSites = MakeVarSiteArr(Prnt1_Arr(), Prnt2_Arr(), VarSitesArr(), MatDim)
        
        'getting disruption score for simulated recombinants
        If FullTestFlag = True Then
            ReDim Rec_StrainSeq(99)
            For S = 0 To 99
                Form1.SSPanel1.Caption = "Simulations : event " & Str(IndSEvent) & "sim recombinant " & Str(S + 1)
                Call RecombSim2(P_Major, P_Minor, VarSitesArr(), MatDim, NumVarSites, VarSitesBp1_Bp2, Rec_StrainSeq(S))
            Next S
            Save_AllSimRecomb P_Major, P_Minor, Rec_Seq, Rec_StrainSeq(), IndSEvent
            SimRecUngapFold Rec_StrainSeq(), NumOfProcessor
                        
            For S = 0 To 99
                Form1.SSPanel1.Caption = "Calculating the fold disruption score: event " & Str(IndSEvent) & ", sim recombinant " & Str(S + 1)
                Form1.ProgressBar1.Value = S + 1
                Call UpdateF2Prog
                Recomb_Nam = "SimRec" & Trim(Str(S)) & ".fas"
                 Call GetConsensusMatrix(Rec_StrainSeq(S), Recomb_Nam, S, minFE, SimRec_Mat())
                GetPairDisruption2 Prnt1_Mat(), Prnt2_Mat(), SimRec_Mat(), MatDim, BpDisrupted, BpCreated
                DisruptScores(IndSEvent, S + 1) = BpDisrupted 'distruption scores
                BpCreatedScores(IndSEvent, S + 1) = BpCreated 'aberrant base pairs
                MinFreeEnergy(IndSEvent, S + 2) = minFE 'Minimum Free Energy for simulated recombinants
                Print #FF, "Sim_recomb:" & Trim(Str(S + 1)) & vbTab & BpDisrupted & vbTab & BpCreated
            Next S
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1.Value = 0
                Call UpdateF2Prog
        ElseIf FullTestFlag = False Then
            Form1.SSPanel1.Caption = "Simulating 100 recombinants from parental sequences " & Str(P1) & " and " & Str(P2)
            For S = 0 To 99
                'Dim BpDisrupt, BpCons As Single
                'BpDisrupt = 0
                'BpCons = 0
                Call RecombSim(P_Major, P_Minor, VarSitesArr(), MatDim, NumVarSites, VarSitesBp1_Bp2)
                'Recomb_Sim_Arr = RecombSim(P_Major, P_Minor, Daughter, Recomb_Array(), NumSNP, LenSeq)
                GetPairDisruption Prnt1_Mat(), Prnt2_Mat(), Recomb_Sim_Arr(), MatDim, BpDisrupted, BpCreated
                DisruptScores(IndSEvent, S + 1) = BpDisrupted
                BpCreatedScores(IndSEvent, S + 1) = BpCreated
                MinFreeEnergy(IndSEvent, S + 2) = minFE 'Minimum Free Energy for simulated recombinants
                Form1.ProgressBar1.Value = S + 1
                Call UpdateF2Prog
                Print #FF, "Sim_recomb:" & Trim(Str(S + 1)) & vbTab & BpDisrupted & vbTab & BpCreated
                ConsPair = ConsPair & " " & Str(BpDisrupted)
                DoEvents
            Next S
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Call UpdateF2Prog
            'MsgBox (ConsPair)
        End If
    End If
    Close #FF
   
Next IndSEvent


'delete other temporaly files
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*Cons_matrix.txt"
On Error GoTo 0
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*.ct"
On Error GoTo 0
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "*.fas"
On Error GoTo 0


'MsgBox ("disruption test completed!")

Dim PermNo, RandNo, RandNoMFE, RealDisrupt, RealBpCreated, TotLower, TotLowerCreated, TotalLowerMFE, PermDisrupt, AberrantMin, PermCreated As Long, FinalPVal, FinalPValCreated, AberrantPValMin, RealMFEdiff, SimMFEdiff, PvalMFE As Single
PermNo = 1000000
RealDisrupt = 0
RealBpCreated = 0
RealMFEdiff = 0

Form1.SSPanel1.Caption = "Performing permutation test..."
For x = 1 To SEventNumber
    A = BestEvent(x, 0)
    b = BestEvent(x, 1)
    If XoverList(A, b).OutsideFlag = 0 And (XoverList(A, b).MissIdentifyFlag = 0 Or XoverList(A, b).MissIdentifyFlag = 10) Then
        RealDisrupt = RealDisrupt + DisruptScores(x, 0)
        RealBpCreated = RealBpCreated + BpCreatedScores(x, 0)
        RealMFEdiff = RealMFEdiff + Abs(Abs(MinFreeEnergy(x, 0)) - Abs(MinFreeEnergy(x, 1)))
    End If
Next x

TotLower = 0
TotLowerCreated = 0
TotLowermin = 0
AberrantMin = 0
For j = 1 To PermNo
    PermDisrupt = 0
    PermCreated = 0
    SimMFEdiff = 0
    For Y = 1 To SEventNumber
        A = BestEvent(Y, 0)
        b = BestEvent(Y, 1)
        If XoverList(A, b).OutsideFlag = 0 And (XoverList(A, b).MissIdentifyFlag = 0 Or XoverList(A, b).MissIdentifyFlag = 10) Then
            RandNo = RndNumGen(1, 100)
            RandNoMFE = RndNumGen(2, 101)
            PermDisrupt = PermDisrupt + DisruptScores(Y, RandNo)
            PermCreated = PermCreated + BpCreatedScores(Y, RandNo)
            
            SimMFEdiff = SimMFEdiff + Abs(Abs(MinFreeEnergy(Y, 0)) - Abs(MinFreeEnergy(Y, RandNoMFE)))
        End If
    Next Y
    
    If PermDisrupt <= RealDisrupt Then
         TotLower = TotLower + 1
    End If
    If PermDisrupt < RealDisrupt Then
         TotLowermin = TotLowermin + 1
    End If
    
    If PermCreated <= RealBpCreated Then
        TotLowerCreated = TotLowerCreated + 1
    End If
    
    If PermCreated < RealBpCreated Then
        AberrantMin = AberrantMin + 1
    End If
    
    If SimMFEdiff < RealMFEdiff Then
       TotalLowerMFE = TotalLowerMFE + 1
    End If
    DoEvents
Next j
Form1.SSPanel1.Caption = "Test completed"
        
FinalPVal = TotLower / PermNo
FinalPValCreated = TotLowerCreated / PermNo
MinPVal = TotLowermin / PermNo
AberrantPValMin = AberrantMin / PermNo
PvalMFE = TotalLowerMFE / PermNo

EndingFullTest = Abs(GetTickCount)
'MsgBox ("folding completed after " & "(" & Trim(Str(Ending - Start)) & " milliseconds)")

FoldingDuration = (EndingFolding - Start)
FullTestDuration = (EndingFullTest - Start)

Y = counterFl
Z = SEventNumber

'Form1.Picture2.Print ("|> Recombination Events       : " & Trim(Str(counterFl)) & " / " & Trim(SEventNumber))
'Form1.Picture2.Print ("|> Disruption P-value         : " & Trim(Str(FinalPVal)))
'Form1.Picture2.Print ("|> Disruption Min P-value     : " & Trim(Str(MinPVal)))
'Form1.Picture2.Print ("|> Aberrant Bp P-value        : " & Trim(Str(FinalPValCreated)))
'Form1.Picture2.Print ("|> Aberrant Bp min P-value    : " & Trim(Str(AberrantPValMin)))
'Form1.Picture2.Print ("|> Minimum Free Energy        : " & Trim(Str(PvalMFE)))
XX = x

Dim OutputFile As String
OutputFile = "P-Val_Output.txt"
FF = FreeFile
If DebuggingFlag < 2 Then On Error Resume Next
Kill (OutputFile)
On Error GoTo 0
Open OutputFile For Output As #FF
Print #FF, "|> Recombination Events       : " & Trim(Str(counterFl)) & " / " & Trim(SEventNumber)
Print #FF, "|> Disruption P-value         : " & Trim(Str(FinalPVal))
Print #FF, "|> Disruption Min P-value     : " & Trim(Str(MinPVal))
Print #FF, "|> Aberrant Bp P-value        : " & Trim(Str(FinalPValCreated))
Print #FF, "|> Aberrant Bp min P-value    : " & Trim(Str(AberrantPValMin))
Print #FF, "|> Minimum Free Energy        : " & Trim(Str(PvalMFE))
Close #FF
MsgBox (Str(FinalPVal))


ChDir oDir
ChDrive oDir
End Sub
Public Sub ReadCoords(CoordsFile As String)
Dim Genes As Long, oDir As String, TypeSeq As Long, Pos As Long, FrameX  As Long, StartG As Long, EndG As Long
Dim AVID() As Double, CurTot() As Long, CurValid() As Long, CurID() As Double, A As Long, b As Long, TCount As Long, VCount As Double
ReDim AVID(Len(StrainSeq(0))), CurTot(NextNo, NextNo), CurValid(NextNo, NextNo), CurID(NextNo, NextNo)

oDir = CurDir
ChDrive App.Path
ChDir App.Path
'XX = RefSeq
'XX = TypeSeq
TypeSeq = TypeSeqNumber

'Exit Sub
If x = x Then ' this loads >idco% identity as genes
    If x = 12345 Then 'this loads etsim.csv
        
        Dim TypeConv() As Long, fillval As Double
        ReDim TypeConv(Len(StrainSeq(0)))
        Y = 0
        For x = 1 To Len(StrainSeq(0))
            If SeqNum(x, TypeSeq) > 50 Then
                Y = Y + 1
                TypeConv(Y) = x
            End If
        
        Next x
        'Open "etsim.csv" For Input As #1
        Open CoordsFile For Input As #1
        
       
        

        
        For x = 1 To Len(StrainSeq(0))
            Y = TypeConv(x)
            Input #1, AVID(Y)
            If EOF(1) Then Exit For
        Next x
        Close #1
        For x = 1 To Len(StrainSeq(0))
            If AVID(x) > 0 Then
                fillval = AVID(x)
            Else
                AVID(x) = fillval
            End If
        Next x
        
        If x = 12345 Then 'this saves it in the same format as idco
            Open "IDEt.csv" For Output As #1
            
            For x = 1 To Len(StrainSeq(0))
                Print #1, AVID(x)
            Next x
            Close #1
        End If
     
    Else 'this loads id.csv/idet.csv
        If x = x Then 'load from file
            'Open "ID.csv" For Input As #1
            Open "IDet.csv" For Input As #1
            For x = 1 To Len(StrainSeq(0))
                Input #1, AVID(x)
            Next x
            Close #1
           ' Z = 0: Y = 0
           ' For X = 1 To Len(StrainSeq(0))
           '     If AVID(X) > 0.9065 Then
           '         Z = Z + 1
           '     Else
           '         Y = Y + 1
           '     End If
           ' Next X
            
           ' X = X
        Else 'work it out from scratch
            For A = -WSize / 2 To WSize / 2
                If A < 1 Then
                    b = Len(StrainSeq(0)) + A
                ElseIf A > Len(StrainSeq(0)) Then
                    b = A - Len(StrainSeq(0))
                Else
                    b = A
                End If
                
                For x = 0 To NextNo
                    For Z = x + 1 To NextNo
                        If SeqNum(b, x) > 50 And SeqNum(b, Z) > 50 Then
                            CurValid(x, Z) = CurValid(x, Z) + 1
                            CurValid(Z, x) = CurValid(x, Z)
                            If SeqNum(b, x) = SeqNum(b, Z) Then
                                CurTot(x, Z) = CurTot(x, Z) + 1
                                CurTot(Z, x) = CurTot(x, Z)
                            End If
                        End If
                    Next Z
                Next x
                
            Next A
            TCount = 0: VCount = 0
            For x = 0 To NextNo
                For Z = x + 1 To NextNo
                    If CurValid(x, Z) > 0 Then
                        CurID(x, Z) = CurTot(x, Z) / CurValid(x, Z)
                        
                        CurID(Z, x) = CurID(x, Z)
                        TCount = TCount + 1
                        VCount = VCount + CurID(x, Z)
                    End If
                Next Z
            Next x
            AVID(1) = VCount / TCount
            
            For Y = 2 To (Len(StrainSeq(0)))
                A = (Y - 1) - WSize / 2
                If A < 1 Then
                    b = Len(StrainSeq(0)) + A
                ElseIf A > Len(StrainSeq(0)) Then
                    b = A - Len(StrainSeq(0))
                Else
                    b = A
                End If
                
                For x = 0 To NextNo
                     For Z = x + 1 To NextNo
                        If SeqNum(b, x) > 50 And SeqNum(b, Z) > 50 Then
                            CurValid(x, Z) = CurValid(x, Z) - 1
                            CurValid(Z, x) = CurValid(x, Z)
                            If SeqNum(b, x) = SeqNum(b, Z) Then
                                CurTot(x, Z) = CurTot(x, Z) - 1
                                CurTot(Z, x) = CurTot(x, Z)
                            End If
                        End If
                    Next Z
                Next x
                
                A = Y + WSize / 2
                If A < 1 Then
                    b = Len(StrainSeq(0)) + A
                ElseIf A > Len(StrainSeq(0)) Then
                    b = A - Len(StrainSeq(0))
                Else
                    b = A
                End If
                
                For x = 0 To NextNo
                     For Z = x + 1 To NextNo
                        If SeqNum(b, x) > 50 And SeqNum(b, Z) > 50 Then
                            CurValid(x, Z) = CurValid(x, Z) + 1
                            CurValid(Z, x) = CurValid(x, Z)
                            If SeqNum(b, x) = SeqNum(b, Z) Then
                                CurTot(x, Z) = CurTot(x, Z) + 1
                                CurTot(Z, x) = CurTot(x, Z)
                            End If
                        End If
                    Next Z
                Next x
                TCount = 0: VCount = 0
                For x = 0 To NextNo
                    For Z = x + 1 To NextNo
                        If CurValid(x, Z) > 0 Then
                            CurID(x, Z) = CurTot(x, Z) / CurValid(x, Z)
                            
                            CurID(Z, x) = CurID(x, Z)
                            TCount = TCount + 1
                            VCount = VCount + CurID(x, Z)
                        End If
                    Next Z
                Next x
                AVID(Y) = VCount / TCount
                If AVID(Y) < 0.7 Then
                    x = x
                End If
                x = x
                Form1.ProgressBar1.Value = (Y / (Len(StrainSeq(0)))) * 100
                Call UpdateF2Prog
            Next Y
            Form1.ProgressBar1 = 0
            Call UpdateF2Prog
            'ODir = CurDir
            'ChDrive App.Path
            'ChDir App.Path
            
            Open "ID.csv" For Output As #1
            For x = 1 To Len(StrainSeq(0))
                Print #1, AVID(x)
            Next x
            Close #1
        End If
        
        
    End If
    
    ReDim GeneList(100), ColBump(100)
    FrameX = 0
    Genes = 0
    
    
    
    For x = 1 To Len(StrainSeq(0))
        If AVID(x) > IDCO Then
            Genes = Genes + 1
            FrameX = FrameX + 1
            If FrameX = 4 Then FrameX = 1
            
            
            GLS = UBound(GeneList, 1)
            If Genes > UBound(GeneList, 1) Then
                ReDim Preserve GeneList(GLS + 100)
            End If
            GeneList(Genes).Name = Genes
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                
                Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
                
                
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(x, TypeSeq)
                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
            End If
            GeneList(Genes).Start = x - SSB
            GeneList(Genes).StartInAlign = x
            GeneList(Genes).ExonNumber = 1
            GeneList(Genes).Frame = FrameX
            GeneList(Genes).IntronFlag = 0
            GeneList(Genes).Orientation = 1
            GeneList(Genes).Product = Genes
            For Y = x + 1 To Len(StrainSeq(0))
                If AVID(Y) <= IDCO Then
                    If SeqSpacesInFileFlag = 1 Then
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        FF = FreeFile
                       
                        OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                        Open "RDP5SSFile" + UFTag For Binary As #FF
                        
                        Get #FF, (((Y - 1 + OS1) - 1) * 4) + 1, SSB
                        
                        
                        Close #FF
                        ChDrive oDirX
                        ChDir oDirX
                    Else
                        SSB = SeqSpaces(Y - 1, TypeSeq)
                        'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                    End If
                    GeneList(Genes).End = Y - SSB
                    GeneList(Genes).EndInAlign = Y - 1
                    Exit For
                End If
            Next Y
            If Y < Len(StrainSeq(0)) - 1 Then
                x = Y - 1
            Else
                Y = Len(StrainSeq(0)) + 1
                If SeqSpacesInFileFlag = 1 Then
                    oDirX = CurDir
                    ChDrive App.Path
                    ChDir App.Path
                    FF = FreeFile
                   
                    OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                    Open "RDP5SSFile" + UFTag For Binary As #FF
                    
                    Get #FF, (((Y - 1 + OS1) - 1) * 4) + 1, SSB
                    
                    Close #FF
                    ChDrive oDirX
                    ChDir oDirX
                Else
                    SSB = SeqSpaces(Y - 1, TypeSeq)
                    'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                End If
                GeneList(Genes).End = SSB
                GeneList(Genes).EndInAlign = Y - 1
                Exit For
            End If
            If GeneList(Genes).StartInAlign = GeneList(Genes).EndInAlign Then
                Genes = Genes - 1
            End If
            x = x
        End If
    
    Next x
    
    GeneNumber = Genes
    ReDim ORFWin(3, Len(StrainSeq(0)))
    Call DrawORFs
    Close #1
    
    ORFFlag = 1
    ChDrive oDir
    ChDir oDir
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        Call RecombMapIIIS
    Else
        Call RecombMapIII
    End If
    x = x
Else

    StartG = 601: EndG = 601
    
    For g = StartG To EndG
        
        ReDim GeneList(100), ColBump(100)
        TypeSeq = NextNo 'this is hxb2 in matteo negronis dataset
        Genes = 0
        Open "genes" + Trim(Str(g)) + ".csv" For Input As #1
        FrameX = 0
        Do While Not EOF(1)
            FrameX = FrameX + 1
            If FrameX = 4 Then FrameX = 1
            Genes = Genes + 1
            Input #1, GeneList(Genes).Name
            Input #1, GeneList(Genes).Start
            Input #1, GeneList(Genes).End
            GeneList(Genes).ExonNumber = 1
            GeneList(Genes).Frame = FrameX
            GeneList(Genes).IntronFlag = 0
            GeneList(Genes).Orientation = 1
            GeneList(Genes).Product = GeneList(Genes).Name
            Pos = 0
            For x = 1 To Len(StrainSeq(0))
                If SeqNum(x, TypeSeq) <> 46 Then
                    Pos = Pos + 1
                    If Pos = GeneList(Genes).Start Then
                        GeneList(Genes).StartInAlign = x
                        Exit For
                    End If
                End If
                
            Next x
            Pos = 0
            For x = 1 To Len(StrainSeq(0))
                If SeqNum(x, TypeSeq) <> 46 Then
                    Pos = Pos + 1
                    If Pos = GeneList(Genes).End Then
                        GeneList(Genes).EndInAlign = x
                        Exit For
                    End If
                End If
                
            Next x
          
        Loop
        If GeneList(Genes).EndInAlign <> 0 Or GeneList(Genes).StartInAlign <> 0 Then
            GeneNumber = Genes
            ReDim ORFWin(3, Len(StrainSeq(0)))
            Call DrawORFs
            Close #1
            
            ORFFlag = 1
            ChDrive oDir
            ChDir oDir
            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                Call RecombMapIIIS
            Else
                Call RecombMapIII
            End If
        Else
            Close #1
        End If
        
    Next g
End If
End Sub
Public Sub MakeSmallArrays(ISeqs() As Long, BigA() As Single, SmallA() As Single)
Dim x As Long, Y As Long, UB As Long
UB = UBound(BigA)
If UB = 0 Then Exit Sub
ReDim SmallA(2, UB)
XX = UBound(BigA, 1)
For x = 0 To 2
    
    For Y = 0 To UB
        SmallA(x, Y) = BigA(ISeqs(x), Y)
    Next Y
Next x

'XX = PermNextno

End Sub
Public Sub LoadLikelihoodLookup(CFC As Byte, FN As String, TSeq() As String)
Dim NewNo As Long
'Check for the available likelihood lookup files and choose one
        MaxSize = 99 'set maxsize according to the max size of the lookup file
        
    
    Rnd (-BSRndNumSeed)
    
    'Get sequences to analyse
    'currently can handle only 100 sequences
    
    If NextNo > MaxSize And x = 123446 Then
        'if over 100 sequences in the alignment then a random sample of 100 is looked at
        DoSeqNo = MaxSize
        ReDim DS(NextNo)
        Rnd (-BSRndNumSeed)
        ReDim TSeq(MaxSize)
        For x = 0 To MaxSize
            Do
                NewNo = Int((NextNo * Rnd) + 1)
                
                If DS(NewNo) = 0 Then
                    DS(NewNo) = 1
                    Exit Do
                End If
            Loop
            TSeq(x) = StrainSeq(NewNo)
        Next x
    Else
        'DoSeqNo = Nextno
        ReDim TSeq(NextNo)
        DoSeqNo = -1
        
        
        
        For x = 0 To NextNo
            If Selected(x) = 1 Then
                GoOn = 1
                For Y = x + 1 To NextNo
                    If Distance(x, Y) = 1 Then
                        GoOn = 0
                    End If
                Next Y
                If GoOn = 1 Then
                    DoSeqNo = DoSeqNo + 1
                    TSeq(DoSeqNo) = StrainSeq(x)
                    If DoSeqNo > 98 Then Exit For
                    
                    
                End If
            End If
        Next x
        x = x
        If DoSeqNo = -1 Then
            x = x
            For x = 0 To NextNo
                'If Selected(X) = 1 Then
                GoOn = 1
                For Y = x + 1 To NextNo
                    If Distance(x, Y) = 1 Then
                        GoOn = 0
                    End If
                Next Y
                If GoOn = 1 Then
                    DoSeqNo = DoSeqNo + 1
                    TSeq(DoSeqNo) = StrainSeq(x)
                    If DoSeqNo > 98 Then Exit For
                    
                    
                End If
                'End If
            Next x
        End If
        
        If PermNextno > MemPoc And x = 1234567 Then
            ReDim Distance(0, 0)
        End If
        
    End If
    
    
    
    'get rid of gap only columns
    Dim NumGap As Long
    For x = 1 To Len(TSeq(0))
        NumGap = 0
        For Y = 0 To DoSeqNo
            If Mid$(TSeq(Y), x, 1) = "-" Then
                NumGap = NumGap + 1
            Else
                Exit For
            End If
        Next Y
        If NumGap >= DoSeqNo Then
            For Y = 0 To DoSeqNo
                Mid$(TSeq(Y), x, 1) = "G"
            Next Y
        End If
    Next x
    
    
    If CircularFlag = 1 And CFC = 1 Then
        HS = CLng(Len(StrainSeq(0)) / 2)
        For x = 0 To DoSeqNo
            TSeq(x) = Right$(TSeq(x), HS) + TSeq(x) + Left$(TSeq(x), HS)
           
        Next x
    End If
    
    
    'Make sequence file
    Close #1
    Open "seqs.fas" For Output As #1
    Print #1, Str(DoSeqNo + 1) + " " + Str(Len(TSeq(0))) + " 1"
    For x = 0 To DoSeqNo
        Print #1, ">S" + Trim(Str(x))
        Print #1, TSeq(x)
    Next x
    Close #1
    'vrflag = 1
    Dim FC As Long
    Form1.ProgressBar1.Value = 2
    Call UpdateF2Prog
    'Make batch file to run "infiles"
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "of"
    KillFile "convert.bat"
    
    FLen = 0
    Dim FString As String
    
    If Dir("convert.bat") <> "" Then
        FLen = FileLen("convert.bat")
    Else
        FLen = 0
    End If
    
    If FLen > 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
        Randomize
        FString = "convert" & Trim(Str(Rnd)) & ".bat"
    Else
        FString = "convert.bat"
        
    End If
    
    
    On Error GoTo 0
    Open FString For Output As #1
    Print #1, "convert < infile > of"
    Print #1, "del " + FString
    Close #1
    'Make infile for convert
    'first do it without the frequency cutoff (this is to get estimates of theta etc.
    Open "infile" For Output As #1
    Print #1, "seqs.fas"
    Print #1, "0"
    Print #1, "2"
    Print #1, "0"
    Print #1, Str(FreqCoMD)
    Print #1, "1"
    Print #1, "0"
    Close #1
    'XX = CurDir
    'run convert
    Call ShellAndClose(FString, 0)
    
    Open "of" For Binary Access Read As #1
    Dim InString As String, TS As String
    
    InString = String(LOF(1), " ")
    Get #1, , InString
    Close #1
    Pos = InStr(1, InString, "Summary of output data", vbBinaryCompare)
    For x = 0 To 5
        LastPos = Pos + 1
        Pos = InStr(LastPos, InString, "=", vbBinaryCompare)
        TS = Mid$(InString, Pos + 1, 10)
        TS = Trim(TS)
        VarRho(4 + x) = val(TS)
        If Pos = 0 Then Exit For
    Next x
    If CircularFlag = 1 Then
        VarRho(5) = VarRho(5) / 2
        VarRho(9) = VarRho(9) / 4
    End If
    Dim LFCode As Integer, ThetaPerNT As Double, FE(2) As Byte, FNX, FacDiff(2) As Double
    ThetaPerNT = VarRho(6) / Len(TSeq(0))
    
    
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    FNX = FreeFile
    
    'given theta per nt choose the most suitable likelihood file
    XX = CurDir
    'Check and see which lookup files are available
    FE(0) = 0
    FE(1) = 0
    FE(2) = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "LF0100" For Input As #FNX
    If LOF(FNX) > 0 Then FE(0) = 1
    Close #FNX
    Open "LF1100" For Input As #FNX
    If LOF(FNX) > 0 Then FE(1) = 1
    Close #FNX
    Open "LF250" For Input As #FNX
    If LOF(FNX) > 0 Then FE(2) = 1
    Close #FNX
    On Error GoTo 0
    
    
    If ThetaPerNT = 0 Then Exit Sub
    If ThetaPerNT < 0.001 Then
        FacDiff(0) = 0.001 / ThetaPerNT
    Else
        FacDiff(0) = ThetaPerNT / 0.001
    End If
    If ThetaPerNT < 0.01 Then
        FacDiff(1) = 0.01 / ThetaPerNT
    Else
        FacDiff(1) = ThetaPerNT / 0.01
    End If
    If ThetaPerNT < 0.1 Then
        FacDiff(2) = 0.1 / ThetaPerNT
    Else
        FacDiff(2) = ThetaPerNT / 0.1
    End If
    
    
    If FE(0) = 0 Then FacDiff(0) = 10000000
    If FE(1) = 0 Then FacDiff(1) = 10000000
    If FE(2) = 0 Then FacDiff(2) = 10000000
    Min = 10000000
    LFCode = -1
    For x = 0 To 2
        If FacDiff(x) < Min Then
            Min = FacDiff(x)
            LFCode = x
        End If
    Next x
    
    
    
    If LFCode = -1 Then
        Response = MsgBox("No likelihood lookup file was found.  Go to the LDHat web site, download a likelihood lookup file, rename it 'LF0100' and copy it to " + App.Path, 0, "RDP Warning")
        Exit Sub
    ElseIf LFCode = 2 And DoSeqNo > 49 Then
        'A maximum of 50 sequences can be analysed with this lookup table
        If DoSeqNo < 100 Then 'need to reselect a random sample
            
            DoSeqNo = 49
            MaxSize = 49
            ReDim DS(NextNo)
            Rnd (-BSRndNumSeed)
            ReDim TSeq(MaxSize)
            For x = 0 To MaxSize
                Do
                    NewNo = Int((NextNo * Rnd) + 1)
                    
                    If DS(NewNo) = 0 Then
                        DS(NewNo) = 1
                        Exit Do
                    End If
                Loop
                TSeq(x) = StrainSeq(NewNo)
            Next x
        End If
        
        DoSeqNo = 49
        
        If CircularFlag = 1 And CFC = 1 Then
            HS = CInt(Len(StrainSeq(0)) / 2)
            For x = 0 To DoSeqNo
                TSeq(x) = Right$(TSeq(x), HS) + TSeq(x) + Left$(TSeq(x), HS)
               
            Next x
        End If
        
        
        ReDim Preserve TSeq(49)
        Open "seqs.fas" For Output As #1
        Print #1, Str(DoSeqNo + 1) + " " + Str(Len(TSeq(0))) + " 1"
        For x = 0 To DoSeqNo
            Print #1, ">S" + Trim(Str(x))
            Print #1, TSeq(x)
        Next x
        Close #1
    End If
    
    If VRFlag = 0 Then
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "lkgen.bat"
    
        FLen = 0
        'Dim FString As String
        If Dir("lkgen.bat") <> "" Then
            FLen = FileLen("lkgen.bat")
        Else
            FLen = 0
        End If
        
        
        If FLen > 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
            
            LKString = "lkgen" & Trim(Str(Rnd)) & ".bat"
        Else
            LKString = "lkgen.bat"
            
        End If
        Rnd (-BSRndNumSeed)
        On Error GoTo 0
        'this bit finds the lookup table of nearest size to that needed.
        Open LKString For Output As #1
        Print #1, "lkgen < infile"
        Print #1, "del " + LKString
        Close #1
        FN = "LF" + Trim(Str(LFCode)) + Trim(Str(DoSeqNo + 1))
        Open FN For Append As #1
        
        If LOF(1) = 0 Then
            Close #1
            Z = DoSeqNo + 2
            Do
                If DebuggingFlag < 2 Then On Error Resume Next

                ChDrive App.Path
                ChDir App.Path
                On Error GoTo 0
                
                FN = "LF" + Trim(Str(LFCode)) + Trim(Str(Z))
                Open FN For Append As #1
                FC = LOF(1)
                Close #1
                If FC > 0 Then
                    Exit Do
                ElseIf Z < 100 Then
                    If FN <> "LF0100" And FN <> "LF1100" And FN <> "LF250" Then
                        Kill FN
                    End If
                End If
                Z = Z + 1
                
                If Z > 100 Then
                    Response = MsgBox("No likelihood lookup file was found.  Go to the LDHat web site, download a likelihood lookup file, rename it 'LF0100' and copy it to " + App.Path, 0, "RDP Warning")
                
                    Exit Sub
                    
                End If
            Loop
            'make likelihood file
            'make infile for lkgen
            Call LoadLF(FN, DoSeqNo, LFCode)
            If ErrorFlag = 1 Then
                ErrorFlag = 0
                Close #1
                Exit Sub
            End If
        Else
            Close #1
        End If
        
    End If
End Sub
Public Sub WriteAlignFile(NumSeqs, AName As String, TempName() As String, TempSeq() As String)
Dim FF As Long, NameString() As String
Dim Addj As Long

FF = FreeFile
Open AName For Output As #FF
    If Right$(AName, 4) = ".msd" Or Right$(AName, 4) = ".MSD" Then
        'Save DNAMAN file
        Print #FF, "FILE: Multiple_Sequence_Alignment"
        Print #FF, "PROJECT:"
        Print #FF, "NUMBER:" + CStr(NumSeqs + 1)
        Print #FF, "MAXLENGTH:" + CStr(Len(TempSeq(0)))
        Addj = 65

        For x = 0 To NumSeqs

            If Len(TempName(x)) > 9 Then
                TempName(x) = Mid$(TempName(x), 1, 8) + Str$(Addj)
                Addj = Addj + 1
            End If

        Next 'X

        ReDim NameString(Int((NumSeqs + 1) / 6) + 1)
        NameString(0) = "NAMES:"

        For x = 1 To Int((NumSeqs + 1) / 6)
            NameString(x) = "      "
        Next 'X

        For x = 0 To Int((NumSeqs + 1) / 6)
            Y = 0

            Do Until Y = 6 Or (x * 6 + Y) > NumSeqs
                NameString(x) = NameString(x) + " " + TempName(x * 6 + Y)
                Y = Y + 1
            Loop

        Next 'X

        For x = 0 To Int((NumSeqs + 1) / 6)
            Print #FF, NameString(x)
        Next 'X

        Print #FF, ""
        Print #FF, "ORIGIN"

        For x = 0 To NumSeqs
            Addon = 10 - Len(TempName(x))
            If Addon >= 0 Then
                TempName(x) = TempName(x) + String$(Addon, 32)
            End If
        Next 'X

        For x = 1 To Int(Len(TempSeq(0)) / 60)

            For Y = 0 To NumSeqs
                Print #FF, TempName(Y) + Mid$(TempSeq(Y), x * 60 - 59, 60)
            Next 'Y

            Print #FF, ""
        Next 'X

        For Y = 0 To NumSeqs
            Print #FF, TempName(Y) + Mid$(TempSeq(Y), x * 60 - 59, Len(TempSeq(0)) - (x * 60 - 60))
        Next 'Y

    ElseIf Right$(AName, 4) = ".aln" Or Right$(AName, 4) = ".ALN" Then
        Addj = 0

        For x = 0 To NumSeqs

            If Len(TempName(x)) > 15 Then
                TempName(x) = Mid$(TempName(x), 1, 13) + Trim(Str(Addj))
                Addj = Addj + 1
            End If

            Addon = 16 - Len(TempName(x))
            If Addon >= 0 Then
            TempName(x) = TempName(x) + String$(Addon, 32)
            End If
        Next 'X

        Print #FF, "CLUSTAL multiple sequence alignment"
        Print #FF, ""
        Print #FF, ""

        For Y = 1 To Len(TempSeq(0)) Step 60

            For x = 0 To NumSeqs
                Print #FF, TempName(x) + Mid$(TempSeq(x), Y, 60)
            Next 'X

            Print #FF, ""
            Print #FF, ""
        Next 'Y

    ElseIf Right$(AName, 4) = ".phy" Or Right$(AName, 4) = ".PHY" Then
        'Save alignment in phylip Format
        Addj = 65
        MaxNS = 0
        For x = 0 To NumSeqs
            If MaxNS < Len(TempName(x)) Then MaxNS = Len(TempName(x))
        Next x
        MaxNS = MaxNS + 1
        MaxNS = 10
        If x = x Then
            Print #FF, Trim$(CStr(NumSeqs + 1)) & " " & Trim$(CStr(Len(TempSeq(0)))) & " 1"
            For x = 0 To NumSeqs
                If Len(TempName(x)) < 10 Then
                    Print #FF, TempName(x) + String(MaxNS - Len(TempName(x)), " ") + TempSeq(x)
                Else
                    Print #FF, Left(TempName(x), 10) + TempSeq(x)
                End If
            Next 'X
            Close #FF
            Exit Sub
        Else
            For x = 0 To NumSeqs
    
                If Len(TempName(x)) > 10 Then
                    TempName(x) = Mid$(TempName(x), 1, 8) + Chr$(Addj)
                    Addj = Addj + 1
                End If
    
                Addon = 10 - Len(TempName(x))
                TempName(x) = TempName(x) + String$(Addon, 32)
            Next 'X
        End If
        Print #FF, "    " & Trim$(CStr(NumSeqs + 1)) & "   " & Trim$(CStr(Len(TempSeq(0))))

        For Y = 1 To Len(TempSeq(0)) Step 50

            For x = 0 To NumSeqs
                TString = ""

                For Z = 0 To 49 Step 10
                    TString = TString + " " + Mid$(TempSeq(x), Y + Z, 10)
                Next 'Z

                Print #FF, TempName(x) + TString

                If Y = 1 Then
                    TempName(x) = String$(10, " ")
                End If

            Next 'X

            Print #FF, ""
        Next 'Y

    ElseIf Right$(AName, 4) = ".gde" Or Right$(AName, 4) = ".GDE" Then
        'Save alignment in GDE Format

        For x = 0 To NumSeqs
            Print #FF, "#" & TempName(x)

            For Y = 1 To Len(TempSeq(0)) + 60 Step 60
                Print #FF, Mid$(TempSeq(x), Y, 60)
            Next 'Y

        Next 'X
    ElseIf Right$(AName, 4) = ".nex" Or Right$(AName, 4) = ".NEX" Then
        x = x
        Print #FF, "#NEXUS"
        Print #FF, ""
        Print #FF, "BEGIN DATA;"
        Print #FF, "DIMENSIONS NTAX=" & Trim(Str(NumSeqs + 1)) & " NCHAR=" & Trim(Str(Len(TempSeq(0)))) & ";"
        Print #FF, "FORMAT MISSING=? GAP=- DATATYPE=DNA;"
        Print #FF, "MATRIX"
        Dim MaxNLen As Long
        MaxNLen = 0
        For x = 0 To NumSeqs
            If Len(TempName(x)) > MaxNLen Then MaxNLen = Len(TempName(x))
        Next x
        MaxNLen = MaxNLen + 2
        For x = 0 To NumSeqs
            Print #FF, TempName(x) + String(MaxNLen - Len(TempName(x)), " ") + TempSeq(x)
            x = x
        Next x
        Print #FF, ";"
        Close #FF
    Else
        'Save alignment in FASTA format

        For x = 0 To NumSeqs
            Print #FF, ">" & TempName(x)

            For Y = 1 To Len(TempSeq(0)) + 70 Step 70
                Print #FF, Mid$(TempSeq(x), Y, 70)
            Next 'Y

        Next 'X

    End If
    

    Close #FF

End Sub
Public Sub MakeAcceptC(SIndex, AcceptC() As Byte)

    Dim NumAccept As Long
    If SIndex = 1 Or SIndex = 2 Or SIndex = 3 Or SIndex = 7 Or SIndex = 23 Or SIndex = 24 Then
        For x = 0 To PermNextno
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).Accept = 1 Then
                    NumAccept = NumAccept + 1
                End If
            Next Y
        Next x
        If NumAccept = 0 Then
            AcceptC(0) = 1
            AcceptC(1) = 1
        Else
        
            Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the saved alignment(s) being modified only according to accepted recombination events. Pressing 'No' will result in the saved alignment(s) being modified according to all recombination events.", vbYesNo, "Save modified alignment")
            
            If Response = 6 Then
                AcceptC(1) = 1
                AcceptC(0) = 0
            Else
                AcceptC(0) = 1
                AcceptC(1) = 1
            End If
        
        End If
    ElseIf SIndex = 17 Then
        AcceptC(0) = 1
        AcceptC(1) = 1
    End If
End Sub
Public Sub DrawDiffsVB(Pict As Long, LenXoverSeq As Long, XFactor As Double, XDiffPos() As Long)

'int FAR pascal DrawDiffs(HDC pict,int lenxoverseq, double xfactor,int *xdiffpos)
  
'{
    Dim Bakw As Long, Forw As Long
    Dim StartC As Long, Y As Long, T As Long, Overlap As Long, InC As Long
    
    
    
    Overlap = CLng(((1 / XFactor) + 1) / 2)
    
    InC = CLng(164 / ((Overlap * 2) + 1)) - 1
    If InC < 1 Then
        InC = 1
    End If
    '
    Dim XDPX As Long
    For x = 0 To LenXoverSeq
        XDPX = XDiffPos(x)
        If XDPX = 0 And x > 10 Then Exit For
        Bakw = XDPX - Overlap
        Forw = XDPX + Overlap
        StartC = InC
        Y = x - 1
        T = 1
        
        Do While (Y > 0)
            If XDiffPos(Y) < Bakw Then
                Exit Do
            End If
            T = T + 1
            Y = Y - 1
        Loop
        
        Y = x + 1
        '
        Do While Y <= LenXoverSeq
            If XDiffPos(Y) > Forw Then
                Exit Do
            End If
            T = T + 1
            Y = Y + 1
        Loop
        StartC = 164 - CLng(InC * T)
        
        Dim Xpos As Long, ColX As Long
        Xpos = CLng(30 + XDPX * XFactor)
        ColX = StartC * 65793
        
        For Z = 11 To 15
           ' Tmp = Decompress(XDiffPos(X))
           ' Tmp = Tmp * xFactor
            Dummy = SetPixelV(Pict, Xpos, Z, ColX)
        Next Z
        'X = Y - 1
        x = x
        '672,697
    Next x
x = x



End Sub
Public Sub DrawDiffsVBAA(ImageData() As Byte, LenXoverSeq As Long, XFactor As Double, XDiffPos() As Long)

'int FAR pascal DrawDiffs(HDC pict,int lenxoverseq, double xfactor,int *xdiffpos)
  
'{
    
    Dim x As Long, Dummy As Long, Bakw As Long, Forw As Long
    Dim StartC As Long, Y As Long, T As Long, Overlap As Long, InC As Long
    Dim Teststrip() As Single, UBTS As Long, LB As Single, RB As Single, MaxTS As Single, UBX As Long
    Dim Xpos As Single, ColX As Long
    UBTS = Form1.Picture7.ScaleWidth
    ReDim Teststrip(UBTS)
    UBX = UBound(XDiffPos, 1)
    '@
    'If X = X Then
        '@
        Dummy = MakeTestStrip(UBX, XFactor, XDiffPos(0), Teststrip(0))
'    Else
'
'        For X = 0 To UBX
'            If XDiffPos(X) > 0 Then
'                Xpos = 30 + XDiffPos(X) * XFactor
'                LB = Xpos - 0.5
'                RB = Xpos + 0.5
'                Teststrip(Int(LB)) = Teststrip(Int(LB)) + (1 - (LB - Int(LB)))
'                Teststrip(Int(RB)) = Teststrip(Int(RB)) + (RB - Int(RB))
'
'    '        ElseIf X > 3 Then
'    '            Exit For
'    '            UBX = X
'            End If
'        Next X
'    End If
    MaxTS = 0
    For x = 0 To UBTS
        
        If MaxTS < Teststrip(x) Then MaxTS = Teststrip(x)
        
        
    Next x
    
    Dim PixVal As Single
    If MaxTS > 20 Then MaxTS = 20
    If MaxTS > 0 Then
        MaxTS = 1 / MaxTS
    Else
        MaxTS = 1
    End If
    Dim SP As Long, EP As Long
    SP = 11: EP = 15
    If x = x Then
        Dummy = DrawDiffsC(SP, EP, UBTS, MaxTS, UBound(ImageData, 1), UBound(ImageData, 2), Teststrip(0), ImageData(0, 0, 0))
    Else
        Dim RB1 As Long, RB2 As Long, RB3 As Long, PV1 As Long, PV2 As Long, PV3 As Long
        RB1 = ImageData(0, 0, 0) - 10
        RB2 = ImageData(1, 0, 0) - 10
         RB3 = ImageData(2, 0, 0) - 10
        For x = 0 To UBTS
            
            If Teststrip(x) > 0 Then
                PixVal = 255 - ((Teststrip(x) * MaxTS) * 255)
                PV1 = RB1 - ((Teststrip(x) * MaxTS) * 255)
                If PV1 > 255 Then
                    PV1 = 255
                ElseIf PV1 < 0 Then
                    PV1 = 0
                End If
                PV1 = CLng(PV1)
                PV2 = RB1 - ((Teststrip(x) * MaxTS) * RB1)
                If PV2 > 255 Then
                    PV2 = 255
                ElseIf PV2 < 0 Then
                    PV2 = 0
                End If
                PV2 = CLng(PV2)
                PV3 = RB1 - ((Teststrip(x) * MaxTS) * RB1)
                If PV3 > 255 Then
                    PV3 = 255
                ElseIf PV3 < 0 Then
                    PV3 = 0
                End If
                PV3 = CLng(PV3)
                For Y = SP To EP
                    ImageData(0, x, Y) = PV1
                    ImageData(1, x, Y) = PV2
                    ImageData(2, x, Y) = PV3
                Next Y
                
            End If
        Next x
    End If
    
    



End Sub
Public Sub DrawDiffsVBAA2(ImageData() As Byte, LenXoverSeq As Long, XFactor As Double, XDiffPos() As Long)

'int FAR pascal DrawDiffs(HDC pict,int lenxoverseq, double xfactor,int *xdiffpos)
  
'{
    Dim Bakw As Long, Forw As Long
    Dim StartC As Long, Y As Long, T As Long, Overlap As Long, InC As Long
    Dim Teststrip() As Single, UBTS As Long, LB As Single, RB As Single, MaxTS As Single, UBX As Long
    Dim Xpos As Single, ColX As Long
    Dim PntAPI As POINTAPI
    Dim red As Long, Green As Long, blue As Long
    Dim ColAdj(2, 2) As Long
    ColAdj(0, 0) = 2
    ColAdj(0, 1) = 6
    ColAdj(0, 2) = 2
    ColAdj(1, 0) = 6
    ColAdj(1, 1) = 2
    ColAdj(1, 2) = 2
    ColAdj(2, 0) = 2
    ColAdj(2, 1) = 2
    ColAdj(2, 2) = 6
    
    Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
    red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
    blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
    
    UBTS = Form1.Picture7.ScaleWidth
    ReDim Teststrip(UBTS)
    UBX = UBound(XDiffPos, 1)
    SP = 10
    EP = 12
    For Z = 0 To 2
        
            
        
        For x = 0 To UBX
            If XDiffPos(x, Z) > 0 Then
                Xpos = 30 + Decompress(XDiffPos(x, Z)) * XFactor * CurveArray(Decompress(XDiffPos(x, Z)))
                LB = Xpos - 0.5
                RB = Xpos + 0.5
                Teststrip(Int(LB)) = Teststrip(Int(LB)) + (1 - (LB - Int(LB)))
                Teststrip(Int(RB)) = Teststrip(Int(RB)) + (RB - Int(RB))
                
    '        ElseIf X > 3 Then
    '            Exit For
    '            UBX = X
            End If
        Next x
    
        MaxTS = 0
        For x = 0 To UBTS
            
            If MaxTS < Teststrip(x) Then MaxTS = Teststrip(x)
            
            
        Next x
        
        Dim PixVal As Single
        If MaxTS > 2 Then MaxTS = 2
        If MaxTS > 0 Then
            MaxTS = 1 / MaxTS
        Else
            MaxTS = 1
        End If
        If x = x Then
            Dummy = DrawDiffsD(Z, BkR, BkG, BkB, SP, EP, UBound(Teststrip, 1), MaxTS, UBound(ImageData, 1), UBound(ImageData, 2), ColAdj(0, 0), Teststrip(0), ImageData(0, 0, 0))
        Else
            Dim PVG As Long, PVR As Long, PVB As Long, tPVG As Long, tPVR As Long, tPVB As Long
        
            For x = 0 To UBTS
                
                If Teststrip(x) > 0 Then
                    
                    tPVR = CLng(BkR - (BkR / ColAdj(Z, 0) * (Teststrip(x) * MaxTS)))
                    tPVG = CLng(BkG - (BkG / ColAdj(Z, 1) * (Teststrip(x) * MaxTS)))
                    tPVB = CLng(BkB - (BkB / ColAdj(Z, 2) * (Teststrip(x) * MaxTS)))
                    
                    
                    'PixVal = 255 - ((Teststrip(X) * MaxTS) * 255)
                    If tPVR > 255 Then tPVR = 255
                    If tPVG > 255 Then tPVG = 255
                    If tPVB > 255 Then tPVB = 255
                    If tPVR < 0 Then tPVR = 0
                    If tPVG < 0 Then tPVG = 0
                    If tPVB < 0 Then tPVB = 0
                    
                    For Y = SP To EP
                        ImageData(0, x, Y) = tPVR
                        ImageData(1, x, Y) = tPVG
                        ImageData(2, x, Y) = tPVB
                    Next Y
                    
                End If
            Next x
        End If
        SP = SP + 3
        EP = EP + 3
    Next Z
    Exit Sub
    
        Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
        red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
        blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))

        For Z = 0 To 2
                
            
            If Z = 0 Then
                Form1.Picture7.ForeColor = Green
                SP = 10
                EP = 13
            ElseIf Z = 1 Then
                Form1.Picture7.ForeColor = blue
                SP = SP + 3
                EP = EP + 3
            Else
                SP = SP + 3
                EP = EP + 3
                Form1.Picture7.ForeColor = red
            End If
            Pict = Form1.Picture7.hdc
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB = UBound(CurveArray, 1)
            
            On Error GoTo 0
            If UB < LSx Then Call MakeCurveArray(0)
            
            For x = 1 To xLenXoverSeq(Z)
                MoveToEx Pict, (30 + Decompress(XDiffPosC(x, Z)) * XFactor * CurveArray(Decompress(XDiffPosC(x, Z)))), SP, PntAPI
                LineTo Pict, (30 + Decompress(XDiffPosC(x, Z)) * XFactor * CurveArray(Decompress(XDiffPosC(x, Z)))), EP
            Next x
        Next Z
        Form1.Picture7.ForeColor = 0
    



End Sub
Public Sub SCHEMA()
If DebuggingFlag < 2 Then On Error Resume Next
oDir = CurDir
ChDrive App.Path
ChDir App.Path
On Error GoTo 0


ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1

'XX = SCHEMAPermNo
Dim DoAllFlag As Byte, CountAccept As Long
CountAccept = 0
For x = 0 To NextNo
    For Y = 0 To CurrentXOver(x)
        If XoverList(x, Y).Accept = 1 Then
            CountAccept = CountAccept + 1
        End If
    Next Y
Next x

If CountAccept = 0 Then
    DoAllFlag = 1
Else
     If CLine = "" Or CLine = " " Then
        Response = MsgBox("Would you like to only account for 'accepted' recombination events (those depicted with a coloured square with a red border in the bottom right panel of the program)?.  Pressing 'No' will take into consideration all of the recombination events depicted in the bottom right panel of the program.", vbYesNo)
     Else
        Response = 7
     End If
     If Response = 6 Then
        DoAllFlag = 1
    Else
        DoAllFlag = 0
    End If
End If


'Make exclude list
Dim Excl() As Byte, Enu As Long, NC As Long, OSX As String, TempXDiffpos() As Long, M As Long, e As Long
ReDim Preserve XDiffPos(Len(StrainSeq(0)))
ReDim TempXDiffpos(Len(StrainSeq(0)))
For x = 0 To Len(StrainSeq(0))
    TempXDiffpos(x) = XDiffPos(x)
Next x
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
    
    Dim BPV() As Double
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
    
    For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                    If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                        BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                    End If
                End If
            Next Y
    Next x
    Dim PValCon As Double
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And (Confirm(x, Y) > 0 Or ExRecFlag <> 1) Then
                If Confirm(x, Y) > 0 Then
                    PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                    PValCon = 10 ^ (-PValCon)
                    'ConfirmP(X, Y) = PValCon
                    If BPV(x, Y) > PValCon Then
                        BPV(x, Y) = PValCon
                    End If
                End If
            End If
        Next Y
    Next x
    
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Enu = SuperEventList(XoverList(x, Y).Eventnumber)
            If Excl(Enu) = 0 Then
                'If Enu = 4 Then
                '    X = X
                'End If
                'If Enu = 23 Then
                '    X = X
                'End If
                NC = 0
                For Z = 0 To AddNum - 1
                    If BPV(Enu, Z) < LowestProb Then
                    
                        NC = NC + 1
                    
                    End If
                Next Z
                
                
                If Enu > 0 And XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 Then
                    Excl(Enu) = 1
                Else
                    x = x
                End If
            End If
        Next Y
    Next x

Dim Bev0 As Long, Bev1 As Long, BE As Long, EN As Long, MaP As Long, MiP As Long, Rec As Long, MiF As Long

'make Prot-prot interact matrix

Dim ProtInteractMatrix() As Byte
ReDim ProtInteractMatrix(PermPDBNo, PermPDBNo)
Dim RelevantPos() As Byte, aaP1 As Long, aaP2 As Long, ntP1 As Long, ntP2 As Long, proP1 As Long, proP2 As Long
ReDim RelevantPos(Len(StrainSeq(0)))
'make "nt-nt" interactmatrx
For x = 0 To PermContactNumberT
    If ContactMapT(4, x) <= SCHEMADistCO Then
        'add it to the list
        aaP1 = ContactMapT(0, x)
        aaP2 = ContactMapT(1, x)
        proP1 = ContactMapT(2, x)
        proP2 = ContactMapT(3, x)
        ntP1 = PermSeq2Align(aaP1, proP1)
        ntP2 = PermSeq2Align(aaP2, proP2)
        RelevantPos(ntP1) = 1
        RelevantPos(ntP2) = 1
        
        
        'RelevantPos
    End If
Next x

'now make the compressed "nt-nt" interaction matrix
Dim RelevantNo As Long, ntInteractMat() As Byte, ForwardC() As Long, BackwardC() As Long
RelevantNo = 0
ReDim ForwardC(Len(StrainSeq(0))), BackwardC(Len(StrainSeq(0)))
For x = 0 To Len(StrainSeq(0))
    
    If RelevantPos(x) = 1 Then
        RelevantNo = RelevantNo + 1
        ForwardC(RelevantNo) = x
    End If
    BackwardC(x) = RelevantNo
Next x

Dim aaInteractMat() As Long
ReDim aaInteractMat(PermPDBNo, MaxaaLen, MaxaaLen)
ReDim ntInteractMat(RelevantNo, RelevantNo)

For x = 0 To PermContactNumberT
    If ContactMapT(4, x) <= SCHEMADistCO Then
        'add it to the list
        aaP1 = ContactMapT(0, x)
        aaP2 = ContactMapT(1, x)
        proP1 = ContactMapT(2, x)
        proP2 = ContactMapT(3, x)
        ntP1 = PermSeq2Align(aaP1, proP1)
        ntP2 = PermSeq2Align(aaP2, proP2)
        ntInteractMat(BackwardC(ntP1), BackwardC(ntP2)) = 1 'I don't use this now - I use just the translated aa seqs
        ntInteractMat(BackwardC(ntP2), BackwardC(ntP1)) = 1
        If proP1 = proP2 Then
            aaInteractMat(proP1, aaP1, aaP2) = 1
            aaInteractMat(proP1, aaP2, aaP1) = 1
        'XX = ForwardC(BackwardC(ntP1))
        End If
        'RelevantPos
    End If
Next x

For x = 1 To PermInterProtInteracts
    ProtInteractMatrix(InterProtMap(0, x), InterProtMap(1, x)) = 1
Next x


Dim RelevantPDB() As Byte, XDP() As Long, XPD() As Long, XPC() As Long, XCP() As Long
ReDim RelevantPDB(Len(StrainSeq(0)), PermPDBNo)
For x = 0 To PermPDBNo
    If ProtInfo(0, x) > 0 And ProtInfo(1, x) > 0 Then
        
        If ProtInfo(2, x) <= 2 Then
            If ProtInfo(0, x) < ProtInfo(1, x) Then
                For Y = ProtInfo(0, x) To ProtInfo(1, x)
                    If Y > Len(StrainSeq(0)) Then
                        Z = Y - Len(StrainSeq(0))
                    Else
                        Z = Y
                    End If
                    RelevantPDB(Z, x) = 1
                Next Y
            Else
                For Y = ProtInfo(0, x) To Len(StrainSeq(0))
                    If Y > Len(StrainSeq(0)) Then
                        Z = Y - Len(StrainSeq(0))
                    Else
                        Z = Y
                    End If
                    RelevantPDB(Z, x) = 1
                Next Y
                For Y = 1 To ProtInfo(1, x)
                    If Y > Len(StrainSeq(0)) Then
                        Z = Y - Len(StrainSeq(0))
                    Else
                        Z = Y
                    End If
                    RelevantPDB(Z, x) = 1
                Next Y
            End If
        Else
            If ProtInfo(1, x) < ProtInfo(0, x) Then '2951-3317
                For Y = ProtInfo(1, x) To ProtInfo(0, x)
                    If Y > Len(StrainSeq(0)) Then
                        Z = Y - Len(StrainSeq(0))
                    Else
                        Z = Y
                    End If
                    RelevantPDB(Z, x) = 1
                Next Y
            Else
                For Y = ProtInfo(1, x) To Len(StrainSeq(0))
                    If Y > Len(StrainSeq(0)) Then
                        Z = Y - Len(StrainSeq(0))
                    Else
                        Z = Y
                    End If
                    RelevantPDB(Z, x) = 1
                Next Y
                For Y = 1 To ProtInfo(0, x)
                    If Y > Len(StrainSeq(0)) Then
                        Z = Y - Len(StrainSeq(0))
                    Else
                        Z = Y
                    End If
                    RelevantPDB(Z, x) = 1
                Next Y
            End If
        
        End If
    End If
Next x
Dim ENC As Long, BEC As Long, SEC As Long, SBC As Long
Dim NucOutput() As Double, NucOutputNum() As Long
ReDim NucOutput(Len(StrainSeq(0)), 2), NucOutputNum(Len(StrainSeq(0))) '0=total that is eventually/nucoutputnum 1=max e, =min e
For x = 0 To Len(StrainSeq(0))
    NucOutput(x, 2) = 10000000
Next x

FF = FreeFile
On Error Resume Next
KillFile "clustal.bat"

FLen = 0

FLen = FileLen("clustal.bat")


If FLen > 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
    
    FString = "clustal" & Trim(Str(Rnd)) & ".bat"
Else
    FString = "clustal.bat"
    
End If
Rnd (-BSRndNumSeed)
Open FString For Output As #FF
On Error GoTo 0

OSX = "clustalw /infile=IF" + UFTag + ".seq /output=fasta /outorder=INPUT /type=p /gapopen=" + "5" + " /gapext=" + "0.5"
Print #FF, OSX
Print #FF, "del " + FString
Close #FF
Dim posHold As Long, ZtF() As Byte, P1S As String, P2S As String, STemp As String, CSeq As Long, WholeFile() As Byte, AlignedSeqs(1) As String
Dim AlignNum() As Byte, PosF As Long, PosR As Long, TotCX() As Long
ReDim AlignNum(1, Len(StrainSeq(0)))
ReDim TotCX(PermPDBNo)
'Dim pdbtoalign() As Long
'make contact maps for all the individual proteins in permpdbno


ReDim NumEScores(PermPDBNo, SEventNumber), SCHEMAMScores(PermPDBNo, SEventNumber, 100), SCHEMAEScores(PermPDBNo, SEventNumber, 100), RealEScores(PermPDBNo, SEventNumber), RealMScores(PermPDBNo, SEventNumber)
Dim RelEvents() As Byte, SBP As Long, NumE As Long
ReDim NOC(PermPDBNo)  'count number of frags for each pdb
ReDim RelEvents(PermPDBNo, SEventNumber)
'Dim NumBreaks() As Long
'ReDim NumBreaks(PermPDBNo)
ReDim XDiffPos(Len(StrainSeq(0)))
Dim NBreaksX As Long, MEX As Double, MMX As Double
NBreaksX = 0
ReDim MeanE(PermPDBNo, 1), MeanM(PermPDBNo, 1)
Dim DoneEvent() As Byte
ReDim DoneEvent(SEventNumber)



For x = 1 To SEventNumber
    If DoneEvent(x) = 0 Then
        Bev0 = BestEvent(x, 0)
        Bev1 = BestEvent(x, 1)
        If Bev0 > 0 Or Bev1 > 0 Then
            MiF = XoverList(Bev0, Bev1).MissIdentifyFlag
            MiF = 0
            OF = XoverList(Bev0, Bev1).OutsideFlag
            If (((XoverList(Bev0, Bev1).Accept = 1 Or DoAllFlag = 1) And Excl(x) = 1) Or ExRecFlag = 1) And (MiF = 0 Or MiF = 10) And OF = 0 Then
                  EN = XoverList(Bev0, Bev1).Ending
                  BE = XoverList(Bev0, Bev1).Beginning
                  MaP = XoverList(Bev0, Bev1).MajorP
                  MiP = XoverList(Bev0, Bev1).MinorP
                  
                  'If BE = 915 And EN = 2066 Then 'originalname(MiP) = "AY795983" Then
                  '  X = X
                  '  XX = originalname(MaP)
                  'End If
                  Rec = XoverList(Bev0, Bev1).Daughter
                  BEC = BackwardC(BE)
                  ENC = BackwardC(EN)
                  SBP = XoverList(Bev0, Bev1).SBPFlag
                  'SBP = 0
                    'first check intra-protein disruptions
                    If BE > 2000 Or EN < 4000 Then
                        x = x
                    End If
                    For Y = 0 To PermPDBNo 'check to see if breakpoints occur within sequences encoding aas in a pdb file
                        GoOn = 0
                        MEX = 0
                        MMX = 0
                        NumE = 0
                        If RelevantPDB(BE, Y) = 1 And (SBP = 0 Or (SBP = 2 And RelevantPDB(EN, Y) = 0)) Then
                            GoOn = 1
                            NBreaksX = NBreaksX + 1
                            XDiffPos(NBreaksX) = BE
                            'For zz = 0 To Len(StrainSeq(0))
                            '    If RelevantPDB(zz, 0) = 0 Then '0-236;832-end
                            '        X = X
                            '    End If
                            'Next zz
                            'X = X
                        End If
                        If RelevantPDB(EN, Y) = 1 And (SBP = 0 Or (SBP = 1 And RelevantPDB(BE, Y) = 0)) Then
                            GoOn = 1
                            NBreaksX = NBreaksX + 1
                            XDiffPos(NBreaksX) = EN
                        End If
                        
                    
                        If GoOn = 1 Then
                            'NOC(Y) = NOC(Y) + 1
                            'XX = ProtInfo(0, 0)
                            P1S = ""
                            P2S = ""
                            Dim TargB As Long, TargE As Long, BNoSpace() As Long, ENoSpace() As Long, BNoSpaceX() As Long, ENoSpaceX() As Long
                            ReDim BNoSpace(1, 1, 5), ENoSpace(1, 1, 5)
                            ReDim BNoSpaceX(1, 1, 5), ENoSpaceX(1, 1, 5)
                            TargB = BE '- SeqSpaces(BE, CSeq)
                            TargE = EN '- SeqSpaces(EN, CSeq)
                            
                            
                            
                            
                            For b = 0 To 1
                                If b = 0 Then CSeq = MaP Else CSeq = MiP
                                For A = 0 To 5
                                    Translation(A) = ""
                                Next A
                                'step1 find the frame of permpdbno=y homologue in P1 and P2
                                'step2 align aminoacid of pdb1 with aminoacids of parent1 and parent2 separately in six frames from protinfo(0,y) to protingfo(1,y)
                                
                                ReDim ZtF(Len(StrainSeq(0)) * 2, 1)
                                PosF = 0
                                PosR = 0
                                
                                For A = 0 To Len(StrainSeq(0)) * 2 '*2 because we are going to dimerise the translation to capture genes that overlap the ends of circular genomes
                                    If A > Len(StrainSeq(0)) Then
                                        Z = A - Len(StrainSeq(0))
                                    Else
                                        Z = A
                                    End If
                                    If SeqNum(Z, CSeq) > 46 Then
                                        ZtF(PosF, 0) = Nucs(SeqNum(Z, CSeq))
                                        
                                        PosF = PosF + 1
                                    End If
                                    If SeqNum(Len(StrainSeq(0)) - Z, CSeq) > 46 Then
                                        ZtF(PosR, 1) = RevNucs(SeqNum(Len(StrainSeq(0)) - Z, CSeq))
                                        
                                        PosR = PosR + 1
                                    End If
                                    If Len(StrainSeq(0)) - Z = TargB Then
                                        For g = 3 To 5
                                            If A <= Len(StrainSeq(0)) Then
                                                BNoSpace(b, 0, g) = PosR
                                            Else
                                                BNoSpace(b, 1, g) = PosR
                                            End If
                                        Next g
                                    End If
                                    If Z = TargB Then
                                        For g = 0 To 2
                                            If A <= Len(StrainSeq(0)) Then
                                                BNoSpace(b, 0, g) = PosF
                                            Else
                                                BNoSpace(b, 1, g) = PosF
                                            End If
                                        Next g
                                    End If
                                    If Len(StrainSeq(0)) - Z = TargE Then
                                        For g = 3 To 5
                                            If A <= Len(StrainSeq(0)) Then
                                                ENoSpace(b, 0, g) = PosR
                                            Else
                                                ENoSpace(b, 1, g) = PosR
                                            End If
                                        Next g
                                    End If
                                    If Z = TargE Then
                                        For g = 0 To 2
                                            If A <= Len(StrainSeq(0)) Then
                                                ENoSpace(b, 0, g) = PosF
                                            Else
                                                ENoSpace(b, 1, g) = PosF
                                            End If
                                        Next g
                                    End If
                                Next A
                                
                                
                                If ProtInfo(2, Y) <= 2 Then
                                    SBC = ProtInfo(0, Y) - 21
                                    SEC = ProtInfo(1, Y) + 21
                                    osbc = SBC
                                    osec = SEC
                                   
                                Else
                                    SBC = Len(StrainSeq(0)) - ProtInfo(0, Y) - 21
                                    SEC = Len(StrainSeq(0)) - ProtInfo(1, Y) + 21
                                    osbc = ProtInfo(0, Y) + 21
                                    osec = ProtInfo(1, Y) - 21
                                    'If SBC > Len(StrainSeq(0)) Then SBC = Len(StrainSeq(0))
                                    If SEC < 1 Then SEC = 1
                                    
                                End If
                                If SBC < 1 Then SBC = 1
                                If SEC < SBC Then
                                    SEC = SEC + Len(StrainSeq(0))
                                End If
                                
                                
                                
                                
                                
                                Dim SAdjE As Long, SAdjB As Long, OS1 As Long, SSB As Long, SSC As Long
                                If ProtInfo(2, Y) <= 2 Then
                                    
                                    If SEC < Len(StrainSeq(0)) Then
                                        If SeqSpacesInFileFlag = 1 Then
                                            oDirX = CurDir
                                            ChDrive App.Path
                                            ChDir App.Path
                                            FF = FreeFile
                                           
                                            OS1 = CSeq * (Len(StrainSeq(0)) + 3)
                                            Open "RDP5SSFile" + UFTag For Binary As #FF
                                            XX = LOF(FF)
                                            Get #FF, (((osec + OS1) - 1) * 4) + 1, SSB
                                            Close #FF
                                            ChDrive oDirX
                                            ChDir oDirX
                                        Else
                                            SSB = SeqSpaces(osec, CSeq)
                                            'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                                        End If
                                        SAdjE = SSB
                                    Else
                                        If osec - Len(StrainSeq(0)) > 0 Then
                                            If SeqSpacesInFileFlag = 1 Then
                                                oDirX = CurDir
                                                ChDrive App.Path
                                                ChDir App.Path
                                                FF = FreeFile
                                               
                                                OS1 = CSeq * (Len(StrainSeq(0)) + 3)
                                                Open "RDP5SSFile" + UFTag For Binary As #FF
                                                Get #FF, (((Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSB
                                                Get #FF, (((osec - Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSC
                                                Close #FF
                                                ChDrive oDirX
                                                ChDir oDirX
                                            Else
                                                SSB = SeqSpaces(Len(StrainSeq(0)), CSeq)
                                                SSC = SeqSpaces(osec - Len(StrainSeq(0)), CSeq)
                                                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                                            End If
                                            SAdjE = SSB + SSC
                                        Else
                                            If SeqSpacesInFileFlag = 1 Then
                                                oDirX = CurDir
                                                ChDrive App.Path
                                                ChDir App.Path
                                                FF = FreeFile
                                               
                                                OS1 = CSeq * (Len(StrainSeq(0)) + 3)
                                                Open "RDP5SSFile" + UFTag For Binary As #FF
                                                Get #FF, (((Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSB
                                                Get #FF, (((osec + OS1) - 1) * 4) + 1, SSC
                                                Close #FF
                                                ChDrive oDirX
                                                ChDir oDirX
                                            Else
                                                SSB = SeqSpaces(Len(StrainSeq(0)), CSeq)
                                                SSC = SeqSpaces(osec, CSeq)
                                                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                                            End If
                                            SAdjE = SSB + SSB
                                        End If
                                    End If
                                    
                                    If osbc <= Len(StrainSeq(0)) Then
                                       If SeqSpacesInFileFlag = 1 Then
                                            oDirX = CurDir
                                            ChDrive App.Path
                                            ChDir App.Path
                                            FF = FreeFile
                                            OS1 = CSeq * (Len(StrainSeq(0)) + 3)
                                            Open "RDP5SSFile" + UFTag For Binary As #FF
                                            Get #FF, (((osbc + OS1) - 1) * 4) + 1, SSB
                                            
                                            Close #FF
                                            ChDrive oDirX
                                            ChDir oDirX
                                        Else
                                            SSB = SeqSpaces(osbc, CSeq)
                                            
                                        End If
                                       SAdjB = SSB
                                    Else
                                        If SeqSpacesInFileFlag = 1 Then
                                            oDirX = CurDir
                                            ChDrive App.Path
                                            ChDir App.Path
                                            FF = FreeFile
                                           
                                            OS1 = CSeq * (Len(StrainSeq(0)) + 3)
                                            Open "RDP5SSFile" + UFTag For Binary As #FF
                                            Get #FF, (((osbc - Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSB
                                            
                                            Close #FF
                                            ChDrive oDirX
                                            ChDir oDirX
                                        Else
                                            SSB = SeqSpaces(osbc - Len(StrainSeq(0)), CSeq)
                                            
                                            'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
                                        End If
                                        SAdjB = SSB
                                    End If
                                Else
                                    If SeqSpacesInFileFlag = 1 Then
                                        oDirX = CurDir
                                        ChDrive App.Path
                                        ChDir App.Path
                                        FF = FreeFile
                                       
                                        OS1 = CSeq * (Len(StrainSeq(0)) + 3)
                                        Open "RDP5SSFile" + UFTag For Binary As #FF
                                        Get #FF, (((Len(StrainSeq(0)) + OS1) - 1) * 4) + 1, SSB
                                        Get #FF, (((osec + OS1) - 1) * 4) + 1, SSC
                                        Get #FF, (((osbc + OS1) - 1) * 4) + 1, SSE
                                        Close #FF
                                        ChDrive oDirX
                                        ChDir oDirX
                                    Else
                                        SSB = SeqSpaces(Len(StrainSeq(0)), CSeq)
                                        SSC = SeqSpaces(osec, CSeq)
                                        SSE = SeqSpaces(osbc, CSeq)
                                    End If
                                    SAdjE = SSB - SSC
                                    If SEC > Len(StrainSeq(0)) Then
                                        SAdjE = SAdjE + SSB
                                    End If
                                    SAdjB = SSB - SSE
                                    If SBC > Len(StrainSeq(0)) Then
                                    
                                        SAdjB = SAdjB + SSB
                                    End If
                                End If
                                If osbc < SAdjB Then
                                    SAdjB = osbc - 1
                                End If
                                
                                If SEC > Len(StrainSeq(0)) * 2 Then SEC = Len(StrainSeq(0)) * 2
                                If SBC > Len(StrainSeq(0)) * 2 Then SBC = Len(StrainSeq(0)) * 2
                                For A = 0 To 5
                                    Translation(A) = ""
                                Next A
                                If SBC > SEC Then
                                    Temp = SBC
                                    SBC = SEC
                                    SEC = Temp
                                    Temp = SAdjB
                                    SAdjB = SAdjE
                                    SAdjE = Temp
                                End If
                                
                                For A = SBC - SAdjB To SEC - SAdjE Step 3
                                    If ProtInfo(2, Y) <= 2 Then
                                        Translation(0) = Translation(0) + Trans(ZtF(A, 0), ZtF(A + 1, 0), ZtF(A + 2, 0))
                                        Translation(1) = Translation(1) + Trans(ZtF(A + 1, 0), ZtF(A + 2, 0), ZtF(A + 3, 0))
                                        Translation(2) = Translation(2) + Trans(ZtF(A + 2, 0), ZtF(A + 3, 0), ZtF(A + 4, 0))
                                        
                                    Else
                                        Translation(3) = Translation(3) + Trans(ZtF(A, 1), ZtF(A + 1, 1), ZtF(A + 2, 1))
                                        Translation(4) = Translation(4) + Trans(ZtF(A + 1, 1), ZtF(A + 2, 1), ZtF(A + 3, 1))
                                        Translation(5) = Translation(5) + Trans(ZtF(A + 2, 1), ZtF(A + 3, 1), ZtF(A + 4, 1))
                                        
                                    End If
                                    
                                    For g = 0 To 5
                                    If (g <= 2 And ProtInfo(2, Y) <= 2) Or (g > 2 And ProtInfo(2, Y) > 2) Then
                                        If g > 2 Then
                                            i = g - 3
                                        Else
                                            i = g
                                        
                                        End If
                                        Dim PAdj(2) As Long
                                        For H = 0 To 2
                                            If H = 0 Then
                                                PAdj(0) = 0
                                                PAdj(1) = -1
                                                PAdj(2) = -1
                                            ElseIf H = 1 Then
                                                PAdj(0) = 0
                                                PAdj(1) = 0
                                                PAdj(2) = -1
                                            ElseIf H = 1 Then
                                                PAdj(0) = 0
                                                PAdj(1) = 0
                                                PAdj(2) = 0
                                            End If
                                            If ENoSpace(b, 0, g) = A + H Then
                                                ENoSpaceX(b, 0, g) = Len(Translation(g)) - PAdj(i)
                                            End If
                                            If ENoSpace(b, 1, g) = A + H Then
                                                ENoSpaceX(b, 1, g) = Len(Translation(g)) - PAdj(i)
                                            End If
                                            If BNoSpace(b, 0, g) = A + H Then
                                                BNoSpaceX(b, 0, g) = Len(Translation(g)) - PAdj(i)
                                            End If
                                            If BNoSpace(b, 1, g) = A + H Then
                                                BNoSpaceX(b, 1, g) = Len(Translation(g)) - PAdj(i)
                                            End If
                                        Next H
                                    End If
                                    Next g
                                Next A
                            
                                For A = 0 To 5
                                    If (A <= 2 And ProtInfo(2, Y) <= 2) Or (A > 2 And ProtInfo(2, Y) > 2) Then
                                        STemp = Translation(A)
                                        LPos = 1
                                        Do
                                            Pos = InStr(LPos, STemp, "*", vbBinaryCompare)
                                            If Pos = 0 Then Exit Do
                                            Mid$(STemp, Pos, 1) = "X"
                                            LPos = Pos + 1
                                        Loop
                                        
                                        Open "IF" + UFTag + ".seq" For Output As #FF
                                        Print #FF, ">S1"
                                        Print #FF, STemp
                                        Print #FF, ">S2"
                                        Print #FF, PermPDBSeq(Y)
                                        Close #FF
                                        If DebuggingFlag < 2 Then On Error Resume Next
                                        KillFile "IF" + UFTag + ".fasta"
                                        On Error GoTo 0
                                        
                                        ShellAndClose App.Path + "\" + FString, 0
                                        
                                        If DebuggingFlag < 2 Then On Error Resume Next
                                        ChDrive App.Path
                                        ChDir App.Path
                                        On Error GoTo 0
                                        FF = FreeFile
                                        Open "IF" + UFTag + ".fasta" For Binary As #FF
                                        XX = LOF(FF)
                                        ReDim WholeFile(LOF(FF))
                                        Get #FF, , WholeFile()
                                        Close #FF
                                        UB = UBound(WholeFile, 1)
                                        If UB = 0 Then 'this checks whether shellandclose has messed up and uses an alternative approach if it has - I've no idea why shellandclose soemtimes messes up with clustalw
                                            Call GetCommandOutput(OSX, 0, True, True)
                                            Open "IF" + UFTag + ".fasta" For Binary As #FF
                                            ReDim WholeFile(LOF(FF))
                                            Get #FF, , WholeFile()
                                            
                                            Close #FF
                                        End If
                                        ReDim AlignNum(1, Len(StrainSeq(0)))
                                        AScore = 0
                                        VScore = 0
                                        D = -1
                                        For C = 0 To UBound(WholeFile)
                                            
                                            If WholeFile(C) = 62 Then
                                                D = D + 1
                                                e = 0
                                                AlignedSeqs(D) = ""
                                                C = C + 5
                                                
                                                Do While WholeFile(C) <> 62 And C <= UBound(WholeFile)
                                                    
                                                    If WholeFile(C) > 15 And WholeFile(C) < 100 Then
                                                        AlignedSeqs(D) = AlignedSeqs(D) + Chr(WholeFile(C))
                                                        AlignNum(D, e) = WholeFile(C)
                                                        e = e + 1
                                                    End If
                                                    
                                                    C = C + 1
                                                    If C > UBound(WholeFile) Then Exit Do
                                                Loop
                                                C = C - 1
                                            End If
                                        Next C
                                        For Z = 0 To Len(StrainSeq(0))
                                            If AlignNum(0, Z) > 60 And AlignNum(1, Z) > 60 Then
                                                
                                                VScore = VScore + 1
                                                If AlignNum(0, Z) = AlignNum(1, Z) Then
                                                    AScore = AScore + 1
                                                End If
                                            End If
                                        
                                        Next Z
                                        AScore = AScore / VScore
                                        
                                        If AScore > 0.5 Then
                                            If b = 0 Then
                                                P1S = AlignedSeqs(0)
                                            Else
                                                P2S = AlignedSeqs(0)
                                            End If
                                            Exit For
                                        End If
                                    End If
                                Next A
                            Next b
                                'step 3 realign the 3 amino acid seqs together
                            
                            If P1S <> "" And P2S <> "" Then
                                Open "IF" + UFTag + ".seq" For Output As #FF
                                Print #FF, ">S1"
                                Print #FF, PermPDBSeq(Y)
                                Print #FF, ">S2"
                                Print #FF, P1S
                                Print #FF, ">S3"
                                Print #FF, P2S
                                Close #FF
                                If DebuggingFlag < 2 Then On Error Resume Next
                                KillFile "IF" + UFTag + ".fasta"
                                On Error GoTo 0
                                
                                ShellAndClose App.Path + "\" + FString, 0
                                
                                If DebuggingFlag < 2 Then On Error Resume Next
                                ChDrive App.Path
                                ChDir App.Path
                                On Error GoTo 0
                                FF = FreeFile
                                Open "IF" + UFTag + ".fasta" For Binary As #FF
                                XX = LOF(FF)
                                ReDim WholeFile(LOF(FF))
                                Get #FF, , WholeFile()
                                Close #FF
                                UB = UBound(WholeFile, 1)
                                If UB = 0 Then 'this checks whether shellandclose has messed up and uses an alternative approach if it has - I've no idea why shellandclose sometimes messes up with clustalw
                                    Call GetCommandOutput(OSX, 0, True, True)
                                    Open "IF" + UFTag + ".fasta" For Binary As #FF
                                    ReDim WholeFile(LOF(FF))
                                    Get #FF, , WholeFile()
                                    
                                    Close #FF
                                End If
                                If x = 40 Then
                                    x = x
                                End If
                                ReDim AlignNum(2, Len(StrainSeq(0)))
                                
                                D = -1
                                For C = 0 To UBound(WholeFile)
                                    
                                    If WholeFile(C) = 62 Then
                                        D = D + 1
                                        e = 0
                                        
                                        C = C + 5
                                        
                                        Do While WholeFile(C) <> 62 And C <= UBound(WholeFile)
                                            
                                            If WholeFile(C) > 15 And WholeFile(C) < 100 Then
                                                
                                                AlignNum(D, e) = WholeFile(C)
                                                e = e + 1
                                            End If
                                            
                                            C = C + 1
                                            If C > UBound(WholeFile) Then Exit Do
                                        Loop
                                        If D = 0 Then
                                            LSx = e - 1
                                        End If
                                        C = C - 1
                                    End If
                                Next C
                                
                                'make an array that keeps track of the aa positions in seqs1 and 2 relative to those in seq 0 (the one in the pdb file)
                                ReDim XPD(LSx + 1), XDP(LSx + 1), XPC(LSx + 1), XCP(LSx + 1)
                                Dim S1PtoS0P() As Long, S2PtoS0P() As Long, S0PtoS1P() As Long, S0PtoS2P() As Long, S1N As Long, S2N As Long, S0N As Long, NoSPaceAlign() As Byte
                                ReDim S1PtoS0P(LSx + 1), S2PtoS0P(LSx + 1), S0PtoS1P(LSx + 1), S0PtoS2P(LSx + 1), NoSPaceAlign(2, LSx + 1)
                                S0N = 0
                                D = 0
                                S1N = 0
                                S2N = 0
                                Dim XProbflag As Byte
                                XProbflag = 0
                                For C = 0 To LSx
                                    
                                    
                                    If AlignNum(1, C) > 62 Then
                                       S1N = S1N + 1
                                       S1PtoS0P(S1N) = S0N
                                       NoSPaceAlign(1, S1N) = AlignNum(1, C)
                                    End If
                                    If AlignNum(2, C) > 62 Then
                                       S2N = S2N + 1
                                       S2PtoS0P(S2N) = S0N
                                       NoSPaceAlign(2, S2N) = AlignNum(2, C)
                                    End If
                                    If AlignNum(0, C) > 62 Then
                                        If AlignNum(2, C) = 88 Or AlignNum(1, C) = 88 Then 'this tests for stop codons and disqualifies the event if there is one
                                            XProbflag = 1
                                            
                                        End If
                                        S0N = S0N + 1
                                        NoSPaceAlign(0, S0N) = AlignNum(0, C)
                                        S0PtoS1P(S0N) = S1N
                                        S0PtoS2P(S0N) = S2N
                                    End If
                                    
                                    
                                        
                                Next C
                                'XX = S0PtoS1P(273)
                                If XProbflag = 0 Then
                                     'use bnospacex and enospacex to work out rhe position in pdb prot where the real breakpoint occurs.
                                     Dim PBE(1) As Long, PEN(1) As Long
                                     PBE(0) = 0: PBE(1) = 0
                                     PEN(0) = 0: PEN(1) = 0
                                     
                                     For g = 0 To 5
                                         For H = 0 To 1
                                             If BNoSpaceX(0, H, g) > 0 Then
                                                If BNoSpaceX(0, H, g) > UBound(S1PtoS0P, 1) Then
                                                    BNoSpaceX(0, H, g) = UBound(S1PtoS0P, 1)
                                                End If
                                                PBE(0) = S1PtoS0P(BNoSpaceX(0, H, g))
                                                
                                                
                                             End If
                                             If ENoSpaceX(0, H, g) > LSx Then ENoSpaceX(0, H, g) = LSx
                                             If ENoSpaceX(0, H, g) > 0 Then
                                                 PEN(0) = S1PtoS0P(ENoSpaceX(0, H, g))
                                             End If
                                             If BNoSpaceX(1, H, g) > UBound(S2PtoS0P, 1) Then
                                                 BNoSpaceX(1, H, g) = UBound(S2PtoS0P, 1)
                                             End If
                                             If BNoSpaceX(1, H, g) > 0 Then
                                                 PBE(1) = S2PtoS0P(BNoSpaceX(1, H, g))
                                             End If
                                             If ENoSpaceX(1, H, g) > LSx Then ENoSpaceX(1, H, g) = LSx
                                             If ENoSpaceX(1, H, g) > 0 Then
                                                 PEN(1) = S2PtoS0P(ENoSpaceX(1, H, g))
                                             End If
                                         Next H
                                     Next g
                                     PBE(0) = CLng((PBE(0) + PBE(1)) / 2)
                                     PEN(0) = CLng((PEN(0) + PEN(1)) / 2)
                                     
                                     Dim DiffCount(1) As Long
                                     DiffCount(0) = 0
                                     DiffCount(1) = 0
                                     Dim BCnt As Byte
                                     
                                    BCnt = 2
                                    If ProtInfo(2, Y) <= 2 Then
                                       If PEN(0) = 0 Then PEN(0) = S0N: BCnt = 1 'S0N:bcnt=1
                                       If PBE(0) = 0 Then PBE(0) = 1: BCnt = 1
                                    Else
                                       If PEN(0) = 0 Then PEN(0) = 1: BCnt = 1 'S0N
                                       If PBE(0) = 0 Then PBE(0) = S0N: BCnt = 1
                                    End If
                                    If ExRecFlag = 1 Then ' this bit is specific for the experimental recombinant tests
                                        'work out how many breakpoints there are in this region in this sequence
                                        Dim BPlist() As Long
                                        ReDim BPlist(Len(StrainSeq(0)))
                                        If RelevantPDB(BE, Y) = 1 Then
                                            BPlist(BE) = 2 '2549,2455,2480
                                            '2623,2497,2627,2618
                                                            
                                        End If
                                        If RelevantPDB(EN, Y) = 1 Then
                                            BPlist(EN) = 2 '2455,2480,2549
                                        End If
                                        For A = x + 1 To SEventNumber 'collect all the other breakpoints for this sequence
                                            bev2 = BestEvent(A, 0)
                                            bev3 = BestEvent(A, 1)
                                            If XoverList(Bev0, Bev1).Daughter = XoverList(bev2, bev3).Daughter And XoverList(Bev0, Bev1).MajorP = XoverList(bev2, bev3).MajorP Then 'is this event in teh current sequence
                                                'XX = BE
                                                'XX = EN
                                                ENX = XoverList(bev2, bev3).Ending
                                                BEX = XoverList(bev2, bev3).Beginning
                                                'is the breakpoint within the current region?
                                                If RelevantPDB(BEX, Y) = 1 Then
                                                    BCnt = BCnt + 1
                                                    NBreaksX = NBreaksX + 1
                                                    XDiffPos(NBreaksX) = BEX
                                                    DoneEvent(A) = 1
                                                    BPlist(BEX) = 1
                                                End If
                                                If RelevantPDB(ENX, Y) = 1 Then
                                                    BCnt = BCnt + 1
                                                    NBreaksX = NBreaksX + 1
                                                    XDiffPos(NBreaksX) = ENX
                                                    DoneEvent(A) = 1
                                                    BPlist(ENX) = 1
                                                End If
                                                
                                                
                                            ElseIf XoverList(Bev0, Bev1).Daughter = XoverList(bev2, bev3).Daughter And XoverList(Bev0, Bev1).MajorP = XoverList(bev2, bev3).MinorP Then 'is this event in teh current sequence
                                                XX = BE
                                                XX = EN
                                                ENX = XoverList(bev2, bev3).Ending
                                                BEX = XoverList(bev2, bev3).Beginning
                                                'is the breakpoint within the current region?
                                                If RelevantPDB(BEX, Y) = 1 Then
                                                    
                                                    DoneEvent(A) = 1
                                                    
                                                End If
                                                If RelevantPDB(ENX, Y) = 1 Then
                                                    
                                                    DoneEvent(A) = 1
                                                   
                                                End If
                                            End If
                                        Next A
                                        Dim RecNoSpace() As Long, CC As Long, BListX() As Long
                                        ReDim BListX(Len(StrainSeq(0)))
                                        ReDim RecNoSpace(Len(StrainSeq(0)))
                                        DS = XoverList(Bev0, Bev1).Daughter
                                        CC = 0
                                        For A = 0 To Len(StrainSeq(0))
                                            If SeqNum(A, DS) > 50 Then
                                                CC = CC + 1
                                                RecNoSpace(A) = CC
                                            End If
                                        Next A
                                        CC = 0
                                        If ProtInfo(2, Y) <= 2 Then 'forwards gene
                                            
                                            
                                            For A = 1 To Len(StrainSeq(0))
                                                If BPlist(A) = 2 Then
                                                    For b = 1 To Len(StrainSeq(0))
                                                        If BPlist(b) > 0 Then
                                                            CC = CC + 1
                                                            BListX(CC) = Abs(RecNoSpace(b) - RecNoSpace(A))
                                                            'If BListX(CC) < 0 Then
                                                            '    X = X
                                                            'End If
                                                        End If
                                                    Next b
                                                    Exit For
                                                End If
                                            Next A
                                        
                                        Else 'backwards gene
                                            For A = Len(StrainSeq(0)) To 1 Step -1
                                                If BPlist(A) = 2 Then
                                                    For b = Len(StrainSeq(0)) To 1 Step -1
                                                        If BPlist(b) > 0 Then
                                                            CC = CC + 1
                                                            BListX(CC) = Abs(RecNoSpace(A) - RecNoSpace(b))
                                                            'If BListX(CC) < 0 Then
                                                            '    X = X
                                                            'End If
                                                        End If
                                                    Next b
                                                    Exit For
                                                End If
                                            Next A
                                        End If
                                    End If
                                     
                                     
                                     'work out the number of differences between s1 and s2 in and out of the recombinant region
                                     
                                     Dim RecombinantBPs() As Long, RecombinantBPsRev() As Long, BPCount As Long
                                     BPCount = 0
                                     ReDim RecombinantBPs(S0N), RecombinantBPsRev(S0N)
                                    
                                     For g = 1 To S0N
                                          XX = Chr(NoSPaceAlign(0, g))
                                         Yy = Chr(NoSPaceAlign(1, S0PtoS1P(g)))
                                         ZZ = Chr(NoSPaceAlign(2, S0PtoS2P(g)))
                                         If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                             BPCount = BPCount + 1
                                             RecombinantBPs(BPCount) = g
                                         End If
                                         RecombinantBPsRev(g) = BPCount
                                     Next g
                                     If x = 15 Then
                                        x = x
                                     End If
                                     If ProtInfo(2, Y) <= 2 Then
                                        If PBE(0) < PEN(0) Then
                                            For g = 1 To PBE(0) - 1
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(0) = DiffCount(0) + 1
                                                End If
                                            Next g
                                            For g = PBE(0) To PEN(0)
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(1) = DiffCount(1) + 1
                                                End If
                                            Next g
                                            For g = PEN(0) + 1 To S0N
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(0) = DiffCount(0) + 1
                                                End If
                                            Next g
                                            x = x
                                        Else
                                            For g = PBE(0) To S0N
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(1) = DiffCount(1) + 1
                                                End If
                                            Next g
                                            For g = 1 To PEN(0)
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(1) = DiffCount(1) + 1
                                                End If
                                            Next g
                                            For g = PEN(0) + 1 To PBE(0) - 1
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(0) = DiffCount(0) + 1
                                                End If
                                            Next g
                                            
                                            x = x
                                        End If
                                    Else
                                        If PBE(0) < PEN(0) Then
                                            For g = 1 To PBE(0)
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(1) = DiffCount(1) + 1
                                                End If
                                            Next g
                                            For g = PBE(0) + 1 To PEN(0) - 1
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(0) = DiffCount(0) + 1
                                                End If
                                            Next g
                                            For g = PEN(0) To S0N
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(1) = DiffCount(1) + 1
                                                End If
                                            Next g
                                            x = x
                                        Else
                                            For g = PBE(0) + 1 To S0N
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(0) = DiffCount(0) + 1
                                                End If
                                            Next g
                                            For g = 1 To PEN(0) - 1
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(0) = DiffCount(0) + 1 '6
                                                End If
                                            Next g
                                            For g = PEN(0) To PBE(0)
                                                If NoSPaceAlign(1, S0PtoS1P(g)) <> NoSPaceAlign(2, S0PtoS2P(g)) Then
                                                    DiffCount(1) = DiffCount(1) + 1 '15
                                                End If
                                            Next g
                                            
                                            x = x
                                        End If
                                    
                                    End If
                                     'step 4 make every possible recombinant between p1 and p2 and work out the degree of disruption of each
                                     'make and estimate M and E for all the unique recombinants
                                     
                                     Dim TotE As Double, SWinMa
                                     Dim RealE As Long
                                     TotE = 0
                                     RealE = 0
                                     If DiffCount(1) < DiffCount(0) Then
                                                
                                        SWinMa = CLng(DiffCount(1) * 2)
                                        If SWinMa > BPCount Then SWinMa = BPCount
                                        
                                    Else
                                        SWinMa = CLng(DiffCount(0) * 2)
                                        If SWinMa > BPCount Then SWinMa = BPCount
                                    End If
                                     
                                    
                                     Dim MutConst As Byte
                                     MutConst = 1
                                     For g = 1 To BPCount
                                         
                                         e = 0
                                        
                                         If BCnt > 2 And ExRecFlag = 1 Then
                                            If g = 1 Then
                                                For A = 1 To CC
                                                    BListX(A) = CLng(BListX(A) / 3)
                                                    If BListX(A) < 0 Then
                                                        x = x
                                                    End If
                                                Next A
                                            Dim BinSeq() As Byte
                                            ReDim BinSeq(Len(StrainSeq(0)))
                                                If ProtInfo(2, Y) <= 2 Then
                                                    If PBE(0) > 1 Then
                                                        For A = 1 To CC
                                                            BListX(A) = BListX(A) + PBE(0)
                                                            If BListX(A) < 0 Then
                                                                x = x
                                                            End If
                                                        Next A
                                                    Else
                                                        For A = 1 To CC
                                                            BListX(A) = BListX(A) + PEN(0)
                                                            If BListX(A) < 0 Then
                                                                x = x
                                                            End If
                                                        Next A
                                                    End If
                                                Else
                                                    If PBE(0) > 1 Then
                                                        For A = 1 To CC
                                                            BListX(A) = BListX(A) + PBE(0)
                                                            If BListX(A) < 0 Then
                                                                x = x
                                                            End If
                                                        Next A
                                                    Else
                                                        For A = 1 To CC
                                                            BListX(A) = BListX(A) + PEN(0)
                                                            If BListX(A) < 0 Then
                                                                x = x
                                                            End If
                                                        Next A
                                                    End If
                                                End If
                                                CVal = 0
                                                For A = 1 To CC
                                                    
                                                    For b = BListX(A - 1) + 1 To BListX(A)
                                                        BinSeq(b) = CVal
                                                    Next b
                                                    CVal = CVal + 1
                                                    If CVal > 1 Then CVal = 0
                                                
                                                Next A
                                                For A = BListX(CC) + 1 To S0N
                                                    BinSeq(A) = CVal
                                                Next A
                                                For A = 1 To S0N
                                                    
                                                Next A
                                                DiffCount(1) = 0
                                                DiffCount(0) = 0
                                                For A = 1 To BPCount
                                                    T = RecombinantBPs(A)
                                                    T = BinSeq(T)
                                                    DiffCount(T) = DiffCount(T) + 1
                                                       
                                                Next A
                                                 If DiffCount(1) > DiffCount(0) Then
                                                    M = DiffCount(0)
                                                Else
                                                    M = DiffCount(1)
                                                End If
                                                
                                            End If
                                            
                                            e = 0
                                            For H = 1 To BPCount
                                                For j = H + 1 To BPCount
                                                    i = H + (g - 1)
                                                    If i > BPCount Then i = i - BPCount
                                                    k = j + (g - 1)
                                                    If k > BPCount Then k = k - BPCount
                                                    If aaInteractMat(Y, RecombinantBPs(H), RecombinantBPs(j)) = 1 Then
                                                        If BinSeq(RecombinantBPs(i)) <> BinSeq(RecombinantBPs(k)) Then
                                                            e = e + 1
                                                        End If
                                                    End If
                                                Next j
                                            Next H
                                            
                                            
                                            NumEScores(Y, x) = NumEScores(Y, x) + 1
                                            If NumEScores(Y, x) > UBound(SCHEMAEScores, 3) Then
                                                ReDim Preserve SCHEMAEScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                ReDim Preserve SCHEMAMScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                            End If
                                            SCHEMAEScores(Y, x, NumEScores(Y, x)) = e
                                            SCHEMAMScores(Y, x, NumEScores(Y, x)) = M
                                            If g = 1 Then 'this is the real recombinant
                                            'If ProtInfo(2, Y) <= 2 Then
                                            '   If (RecombinantBPs(G + 1) > PBE(0) And RecombinantBPs(G) <= PBE(0)) Or (PBE(0) = 1 And G = 1) Then
                                                    'step 5 note degree of disruption estimated for the real recombinant.
                                                   
                                                   
                                                   RealEScores(Y, x) = e '7'2
                                                   RealMScores(Y, x) = M
                                                   NOC(Y) = NOC(Y) + 2
                                                   RelEvents(Y, x) = 1
                                                    
                                            '   End If
                                            'Else
                                            '   If (RecombinantBPs(G + 1) > PEN(0) And RecombinantBPs(G) <= PEN(0)) Or (PEN(0) = 1 And G = 1) Then
                                                    'step 5 note degree of disruption estimated for the real recombinant.
                                                  
                                                    
                                            '   End If
                                            End If
                                         ElseIf BCnt = 2 Then 'And MutConst = 1 And X = 12345 Then 'if there are 2 bps in the region keeping muts constant
                                            If DiffCount(1) > DiffCount(0) Then
                                                M = DiffCount(0)
                                            Else
                                                M = DiffCount(1)
                                            End If
                                            e = 0
                                            For H = g To (g + DiffCount(1) - 1)
                                                If H > BPCount Then
                                                    i = H - BPCount
                                                Else
                                                    i = H
                                                End If
                                                For j = (g + DiffCount(1)) To (g + DiffCount(1) + DiffCount(0) - 1)
                                                    If j > BPCount Then
                                                        k = j - BPCount
                                                    Else
                                                        k = j
                                                    End If
                                                    'XX = UBound(aaInteractMat, 2)
                                                    If aaInteractMat(Y, RecombinantBPs(i), RecombinantBPs(k)) = 1 Then
                                                        e = e + 1
                                                    End If
                                                Next j
                                            Next H
                                            NumEScores(Y, x) = NumEScores(Y, x) + 1
                                            If NumEScores(Y, x) > UBound(SCHEMAEScores, 3) Then
                                                ReDim Preserve SCHEMAEScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                ReDim Preserve SCHEMAMScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                            End If
                                            SCHEMAEScores(Y, x, NumEScores(Y, x)) = e
                                            SCHEMAMScores(Y, x, NumEScores(Y, x)) = M
                                            If ProtInfo(2, Y) <= 2 Then
                                               If (RecombinantBPs(g + 1) > PBE(0) And RecombinantBPs(g) <= PBE(0)) Or (PBE(0) = 1 And g = 1) Then
                                                    'step 5 note degree of disruption estimated for the real recombinant.
                                                   
                                                   
                                                   RealEScores(Y, x) = e '7'2
                                                   RealMScores(Y, x) = M
                                                   NOC(Y) = NOC(Y) + 2
                                                    RelEvents(Y, x) = 1
                                                    
                                               End If
                                            Else
                                               If (RecombinantBPs(g + 1) > PEN(0) And RecombinantBPs(g) <= PEN(0)) Or (PEN(0) = 1 And g = 1) Then
                                                    'step 5 note degree of disruption estimated for the real recombinant.
                                                   RealEScores(Y, x) = e '7
                                                   RealMScores(Y, x) = M
                                                   NOC(Y) = NOC(Y) + 2
                                                    RelEvents(Y, x) = 1
                                                    
                                               End If
                                            End If
                                        ElseIf BCnt = 1 And MutConst = 1 And x = 12345 Then 'if there is only 1 bp in the region and av mutations must be constant
                                            If g < BPCount - g Then
                                                M = g
                                            Else
                                                M = BPCount - g
                                            End If
                                            e = 0
                                            If g < SWinMa Or g > BPCount - SWinMa And SWinMa <= CLng(BPCount / 3) Then
                                                For H = g + 1 To BPCount
                                                 
                                                    
                                                    For j = 1 To g
                                                        
                                                           
                                                       
                                                        'XX = UBound(aaInteractMat, 2)
                                                        If aaInteractMat(Y, RecombinantBPs(H), RecombinantBPs(j)) = 1 Then
                                                            e = e + 1
                                                        End If
                                                    Next j
                                                Next H
                                                
                                                NumEScores(Y, x) = NumEScores(Y, x) + 1
                                                If NumEScores(Y, x) > UBound(SCHEMAEScores, 3) Then
                                                    ReDim Preserve SCHEMAEScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                    ReDim Preserve SCHEMAMScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                End If
                                                SCHEMAEScores(Y, x, NumEScores(Y, x)) = e
                                                SCHEMAMScores(Y, x, NumEScores(Y, x)) = M
                                                If g < SWinMa And g > BPCount - SWinMa Then
                                                    NumEScores(Y, x) = NumEScores(Y, x) + 1
                                                    If NumEScores(Y, x) > UBound(SCHEMAEScores, 3) Then
                                                        ReDim Preserve SCHEMAEScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                        ReDim Preserve SCHEMAMScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                    End If
                                                    SCHEMAEScores(Y, x, NumEScores(Y, x)) = e
                                                    SCHEMAMScores(Y, x, NumEScores(Y, x)) = M
                                                End If
                                                'If ProtInfo(2, Y) <= 2 Then
                                                If PBE(0) > 1 And PBE(0) < RecombinantBPs(BPCount) Then
                                                    If (RecombinantBPs(g + 1) > PBE(0) And RecombinantBPs(g) <= PBE(0)) Then
                                                         'step 5 note degree of disruption estimated for the real recombinant.
                                                        
                                                        XX = BE: XX = EN: XX = DiffCount(1): XX = DiffCount(0)
                                                        RealEScores(Y, x) = e '7'2
                                                        RealMScores(Y, x) = M
                                                        NOC(Y) = NOC(Y) + 1
                                                        RelEvents(Y, x) = 1
                                                       
                                                    End If
                                                ElseIf PEN(0) > 1 And PEN(0) < RecombinantBPs(BPCount) Then
                                                    If (RecombinantBPs(g + 1) > PEN(0) And RecombinantBPs(g) <= PEN(0)) Then
                                                         'step 5 note degree of disruption estimated for the real recombinant.
                                                        
                                                        XX = BE: XX = EN: XX = DiffCount(1): XX = DiffCount(0)
                                                        RealEScores(Y, x) = e '7'2
                                                        RealMScores(Y, x) = M
                                                        NOC(Y) = NOC(Y) + 1
                                                        RelEvents(Y, x) = 1
                                                        
                                                    End If
                                                
                                                End If
                                            End If
                                                
                                            'End If
                                        ElseIf BCnt = 1 Then 'And MutConst = 0 Then  'if there is only 1 bp in the region
                                            If g < BPCount - g Then
                                                M = g
                                            Else
                                                M = BPCount - g
                                            End If
                                            e = 0
                                            For H = g + 1 To BPCount
                                             
                                                
                                                For j = 1 To g
                                                    
                                                       
                                                   
                                                    'XX = UBound(aaInteractMat, 2)
                                                    If aaInteractMat(Y, RecombinantBPs(H), RecombinantBPs(j)) = 1 Then
                                                        e = e + 1
                                                    End If
                                                Next j
                                            Next H
                                            If e > 20 Then
                                                x = x
                                            End If
                                            For H = RecombinantBPs(g - 1) + 1 To RecombinantBPs(g)
                                                posHold = PDBtoAlign(H, Y)
                                                
                                                If ProtInfo(2, Y) <= 2 Then
                                                    For j = 0 To 2
                                                        NucOutput(posHold + j, 0) = NucOutput(posHold + j, 0) + e
                                                        NucOutputNum(posHold + j) = NucOutputNum(posHold + j) + 1
                                                        If e < NucOutput(posHold + j, 2) Then
                                                            NucOutput(posHold + j, 2) = e
                                                        End If
                                                        If e > NucOutput(posHold + j, 1) Then
                                                            NucOutput(posHold + j, 1) = e
                                                        End If
                                                    Next j
                                                Else
                                                    For j = 0 To 2
                                                        NucOutput(posHold - j, 0) = NucOutput(posHold - j, 0) + e
                                                        NucOutputNum(posHold - j) = NucOutputNum(posHold - j) + 1
                                                        If e < NucOutput(posHold - j, 2) Then
                                                            NucOutput(posHold - j, 2) = e
                                                        End If
                                                        If e > NucOutput(posHold - j, 1) Then
                                                            NucOutput(posHold - j, 1) = e
                                                        End If
                                                    Next j
                                                End If
                                                
                                            Next H
                                            
                                            NumEScores(Y, x) = NumEScores(Y, x) + 1
                                            If NumEScores(Y, x) > UBound(SCHEMAEScores, 3) Then
                                                ReDim Preserve SCHEMAEScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                ReDim Preserve SCHEMAMScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                            End If
                                            SCHEMAEScores(Y, x, NumEScores(Y, x)) = e
                                            SCHEMAMScores(Y, x, NumEScores(Y, x)) = M
                                            'If ProtInfo(2, Y) <= 2 Then
                                            If PBE(0) > 1 And PBE(0) < RecombinantBPs(BPCount) Then
                                                If (RecombinantBPs(g + 1) > PBE(0) And RecombinantBPs(g) <= PBE(0)) Then
                                                     'step 5 note degree of disruption estimated for the real recombinant.
                                                    
                                                    XX = BE: XX = EN: XX = DiffCount(1): XX = DiffCount(0)
                                                    RealEScores(Y, x) = e '7'2
                                                    RealMScores(Y, x) = M
                                                    NOC(Y) = NOC(Y) + 1
                                                    RelEvents(Y, x) = 1
                                                    
                                                End If
                                            ElseIf PEN(0) > 1 And PEN(0) < RecombinantBPs(BPCount) Then
                                                If (RecombinantBPs(g + 1) > PEN(0) And RecombinantBPs(g) <= PEN(0)) Then
                                                     'step 5 note degree of disruption estimated for the real recombinant.
                                                    
                                                    XX = BE: XX = EN: XX = DiffCount(1): XX = DiffCount(0)
                                                    RealEScores(Y, x) = e '7'2
                                                    RealMScores(Y, x) = M
                                                    NOC(Y) = NOC(Y) + 1
                                                    RelEvents(Y, x) = 1
                                                    
                                                End If
                                            
                                            End If
                                            'End If
                                        ElseIf BCnt = 2 And MutConst = 0 And x = 12345 Then 'if there is only 1 bp in the region
                                            If DiffCount(1) > DiffCount(0) Then
                                                M = DiffCount(0)
                                            Else
                                                M = DiffCount(1)
                                            End If
                                            e = 0
                                            For H = 1 To BPCount
                                                If H <> g Then
                                                
                                                    'For J = 1 To G
                                                        
                                                           
                                                       
                                                        'XX = UBound(aaInteractMat, 2)
                                                        If aaInteractMat(Y, RecombinantBPs(H), RecombinantBPs(g)) = 1 Then
                                                            e = e + 1
                                                        End If
                                                    'Next J
                                            
                                                    NumEScores(Y, x) = NumEScores(Y, x) + 1
                                                    If NumEScores(Y, x) > UBound(SCHEMAEScores, 3) Then
                                                        ReDim Preserve SCHEMAEScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                        ReDim Preserve SCHEMAMScores(PermPDBNo, SEventNumber, NumEScores(Y, x) + 100)
                                                    End If
                                                    SCHEMAEScores(Y, x, NumEScores(Y, x)) = e
                                                    SCHEMAMScores(Y, x, NumEScores(Y, x)) = M
                                                    'If ProtInfo(2, Y) <= 2 Then
                                                    If (RecombinantBPs(H + 1) > PBE(0) And RecombinantBPs(H) <= PBE(0)) And (RecombinantBPs(g + 1) > PEN(0) And RecombinantBPs(g) <= PEN(0)) Then
                                                        'If (RecombinantBPs(G + 1) > PBE(0) And RecombinantBPs(G) <= PBE(0)) Then
                                                             'step 5 note degree of disruption estimated for the real recombinant.
                                                            
                                                            
                                                            RealEScores(Y, x) = e '7'2
                                                            RealMScores(Y, x) = M
                                                            NOC(Y) = NOC(Y) + 1
                                                            RelEvents(Y, x) = 1
                                                            
                                                        'End If
                                                   ' ElseIf (PEN(0) = 1 Or PEN(0) = RecombinantBPs(BPCount)) And (RecombinantBPs(G + 1) > PBE(0) And RecombinantBPs(G) <= PBE(0)) Then
                                                   '     'If (RecombinantBPs(G + 1) > PEN(0) And RecombinantBPs(G) <= PEN(0)) Then
                                                   '          'step 5 note degree of disruption estimated for the real recombinant.
                                                   '
                                                   '         XX = BE: XX = EN: XX = DiffCount(1): XX = DiffCount(0)
                                                   '         RealEScores(Y, X) = E '7'2
                                                   '     'End If
                                                   '
                                                    End If
                                                End If
                                            Next H
                                            'End If
                                        End If
                                        MEX = MEX + e
                                        NumE = NumE + 1
                                        MMX = MMX + M
                                        'If G < BPCount - G Then
                                        '    MMX = MMX + G
                                        'Else
                                        '    MMX = MMX + (BPCount - G)
                                        'End If
                                   
                                        
                                         
                                         
                                     Next g
                                     x = x
                                End If
                                x = x
                            End If
                            
                            
                            
                            
                        End If
                        If NumE > 0 Then
                            MEX = MEX / NumE
                            MMX = MMX / NumE
                            MeanE(Y, 1) = MeanE(Y, 1) + MEX
                            MeanM(Y, 1) = MeanM(Y, 1) + MMX
                            TotCX(Y) = TotCX(Y) + 1
                            MMX = 0
                            MEX = 0
                            NumE = 0
                        End If
                    Next Y
                  
                    
                   
            End If
        End If
    End If
    Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(SEventNumber)) + " recombination events examined"
Next x



'work out mreanE for the real datasets
Dim DivBy() As Long
ReDim DivBy(PermPDBNo)
For x = 1 To SEventNumber
    
    For Y = 0 To PermPDBNo
        If RelEvents(Y, x) = 1 Then
            MeanE(Y, 0) = MeanE(Y, 0) + RealEScores(Y, x)
            MeanM(Y, 0) = MeanM(Y, 0) + RealMScores(Y, x)
            DivBy(Y) = DivBy(Y) + 1
        End If
    Next Y
Next x

For Y = 0 To PermPDBNo
    If DivBy(Y) > 0 Then
        MeanE(Y, 0) = MeanE(Y, 0) / DivBy(Y)
        MeanM(Y, 0) = MeanM(Y, 0) / DivBy(Y)
    End If
    If TotCX(Y) > 0 Then
        MeanE(Y, 1) = MeanE(Y, 1) / TotCX(Y) 'MeanM(Y, 1)
        MeanM(Y, 1) = MeanM(Y, 1) / TotCX(Y)
    End If
    x = x
Next Y




XX = NOC(0)
'step6 - work out the disruption avoidance p-values
'what is the total for the real recombinants
Dim RealRecTotM() As Double, PermRecTotM() As Double, RealRecTot() As Double, PermRecTot() As Double, BPRnd As Long, MaxEScores As Long
'0.9 - 1 (-750)
'0.00046 - 9 (-500), 1 - 0
'0.25 - 18 (-250), 0.81 - 7
'0.7 - 22 (-125), 0.62 - 3
'0.0026 -25, 0.066 - 5
'0.79 - 17 (+125), 0.75 - 3
'0.41 - 18 (+250), 0.18 - 2
'0.07 - 11 (+500), 0.78 - 1
'0.76 - 9 (+750)
'0.53 -4 (+1000)
'0.01 -11 (+1500)
'0.48 -4 (+2000)

'SCHEMAPermNo = 10000

'Work out ranks in the calculated e value distributions

'SCHEMAEScores(PermPDBNo, SEventNumber, 100), RealEScores(PermPDBNo, SEventNumber)
Dim ERank() As Double, ERankReal() As Double, HT As Long, LT As Long, ET As Long, MRank() As Double, MRankReal() As Double
MaxEScores = UBound(SCHEMAEScores, 3)
ReDim ERank(PermPDBNo, SEventNumber, MaxEScores)
ReDim ERankReal(PermPDBNo, SEventNumber)
ReDim MRank(PermPDBNo, SEventNumber, MaxEScores)
ReDim MRankReal(PermPDBNo, SEventNumber)
For x = 1 To SEventNumber
    
    For Y = 0 To PermPDBNo
        If RelEvents(Y, x) = 1 Then
            For Z = 1 To NumEScores(Y, x)
                HT = 0
                LT = 0
                ET = 0
                For A = 1 To NumEScores(Y, x)
                    If A <> Z Then
                        If SCHEMAEScores(Y, x, Z) > SCHEMAEScores(Y, x, A) Then
                            HT = HT + 1
                        ElseIf SCHEMAEScores(Y, x, Z) < SCHEMAEScores(Y, x, A) Then
                            LT = LT + 1
                        ElseIf SCHEMAEScores(Y, x, Z) = SCHEMAEScores(Y, x, A) Then
                            ET = ET + 1
                        End If
                    End If
                Next A
                ERank(Y, x, Z) = ((ET / 2 + HT) / (LT + HT + ET))
                If RealEScores(Y, x) = SCHEMAEScores(Y, x, Z) Then
                    ERankReal(Y, x) = ERank(Y, x, Z)
                End If
                
                HT = 0
                LT = 0
                ET = 0
                For A = 1 To NumEScores(Y, x)
                    If A <> Z Then
                        If SCHEMAMScores(Y, x, Z) > SCHEMAMScores(Y, x, A) Then
                            HT = HT + 1
                        ElseIf SCHEMAMScores(Y, x, Z) < SCHEMAMScores(Y, x, A) Then
                            LT = LT + 1
                        ElseIf SCHEMAMScores(Y, x, Z) = SCHEMAMScores(Y, x, A) Then
                            ET = ET + 1
                        End If
                    End If
                Next A
                MRank(Y, x, Z) = ((ET / 2 + HT) / (LT + HT + ET))
                If RealMScores(Y, x) = SCHEMAMScores(Y, x, Z) Then
                    MRankReal(Y, x) = MRank(Y, x, Z)
                End If
            Next Z
            x = x
        End If
    Next Y
Next x

ReDim RealRecTot(PermPDBNo), LowerThanReal(PermPDBNo), RealRecTotM(PermPDBNo), LowerThanRealM(PermPDBNo)
For x = 1 To SEventNumber
    For Y = 0 To PermPDBNo
        If NumEScores(Y, x) > 0 Then
            RealRecTot(Y) = RealRecTot(Y) + ERankReal(Y, x)
            RealRecTotM(Y) = RealRecTotM(Y) + MRankReal(Y, x)
            'RealRecTot(Y) = RealRecTot(Y) + RealEScores(Y, X) '1,6,9,0,0,0,0,0,0,0
            
        End If
    Next Y
Next x
For Z = 1 To SCHEMAPermNo
    ReDim PermRecTot(PermPDBNo)
    ReDim PermRecTotM(PermPDBNo)
    For x = 1 To SEventNumber
        
        For Y = 0 To PermPDBNo
            
            If RelEvents(Y, x) = 1 Then
                If NumEScores(Y, x) > 0 Then
                    BPRnd = CLng((NumEScores(Y, x) * Rnd) + 1)
                   
                    If BPRnd > 0 And BPRnd <= NumEScores(Y, x) Then
                        PermRecTot(Y) = PermRecTot(Y) + ERank(Y, x, BPRnd) 'SCHEMAEScores(Y, X, BPRnd)
                        PermRecTotM(Y) = PermRecTotM(Y) + MRank(Y, x, BPRnd)
                    End If
                    
                End If
            End If
        Next Y
    Next x
    For Y = 0 To PermPDBNo
    
        If PermRecTot(Y) <= RealRecTot(Y) Then
            LowerThanReal(Y) = LowerThanReal(Y) + 1
        End If
        If PermRecTotM(Y) <= RealRecTotM(Y) Then
            LowerThanRealM(Y) = LowerThanRealM(Y) + 1
        End If
    Next Y
    SS = Abs(GetTickCount)
    If Abs(SS - EE) > 500 Then
        EE = SS
        If Z > 0 Then
            Form1.SSPanel1.Caption = Trim(Str(Z)) + " of " + Trim(Str(SCHEMAPermNo)) + " permutations completed" ' (p-val = 0" + Trim(Str(LowerThanReal(0) / Z)) + ")"
            Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    End If
Next Z
For Y = 0 To PermPDBNo
    LowerThanReal(Y) = LowerThanReal(Y) / SCHEMAPermNo
    LowerThanRealM(Y) = LowerThanRealM(Y) / SCHEMAPermNo
    x = x
Next Y






'Draw the graph
'Draw the graph
Dim MNo As Double
MNo = 0
For x = 0 To Len(StrainSeq(0))
    If NucOutputNum(x) > 0 Then
        NucOutput(x, 0) = NucOutput(x, 0) / NucOutputNum(x)
        If MNo < NucOutput(x, 1) Then MNo = NucOutput(x, 1)
    End If
Next x
XX = UBound(TempXDiffpos, 1)

'fill in the blanks within nucoutput'needs to be redone in C++ it is unbelievably slow in VB
For x = 0 To Len(StrainSeq(0))
'xxx = Form1.SSPanel1.Caption
    If NucOutputNum(x) > 0 Then
        For Y = x + 1 To Len(StrainSeq(0))
            If NucOutputNum(Y) = 0 Then
                For Z = Y + 1 To Len(StrainSeq(0))
                    If NucOutputNum(Z) > 0 Then
                        If (Z - Y < 20) Then
                            For A = Y To Z - 1
                                NucOutputNum(A) = CLng((NucOutputNum(Y - 1) + NucOutputNum(Z)) / 2)
                                NucOutput(A, 0) = (NucOutput(Z, 0) + NucOutput(Y - 1, 0)) / 2
                                NucOutput(A, 1) = (NucOutput(Z, 1) + NucOutput(Y - 1, 1)) / 2
                                NucOutput(A, 2) = (NucOutput(Z, 2) + NucOutput(Y - 1, 2)) / 2
                            Next A
                        
                        
                        End If
                        x = Z
                        Y = Len(StrainSeq(0))
                        Exit For
                    End If
                Next Z
            End If
        Next Y
        
    End If
    SS = Abs(GetTickCount)
    If Abs(SS - oo) > 500 Then
        
        oo = SS
        Form1.SSPanel1.Caption = "Calculating recombination induced disruption at position " + Trim(Str(x))
        
    End If
Next x
GYAxHi(1) = Decompress(Len(StrainSeq(0)))
'Call DoAxes(0,0,decompress( Len(StrainSeq(0))), -1, MinL, 0, 1, "Log likelihood ratio")
'DoAxes(0,0,decompress( Len(StrainSeq(0))), -1, 100, 0, 0, "Occupancy (%)")
Dim PntAPI As POINTAPI
Dim YScaleFactor As Double, FirstLineX As Double, MaxLineX As Double, lX As Double, fX As Double

Form1.Picture7.ScaleMode = 3
Form1.Picture10.BackColor = BackColours
Form1.Picture7.BackColor = BackColours
Form1.Picture10.ScaleMode = 3
Form1.Picture7.ScaleMode = 3
YScaleFactor = 0.85
'XX = UBound(APos, 1)
Call MakeAPos(APos(), XPD())
PicHeight = Form1.Picture7.Height * YScaleFactor

XFactor = ((Form1.Picture7.Width - 40) / Decompress(APos(Len(StrainSeq(0)))))

For x = 0 To NBreaksX - 1
    XDiffPos(x) = APos(XDiffPos(x + 1))
    
Next x
XDiffPos(NBreaksX) = 0
For x = 0 To NBreaksX - 1
    For Y = x + 1 To NBreaksX
        If XDiffPos(x) > XDiffPos(Y) Then
            Temp = XDiffPos(x)
            XDiffPos(x) = XDiffPos(Y)
            XDiffPos(Y) = Temp
        End If
    Next Y
Next x
LenXoverSeq = NBreaksX
If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
    GYAxHi(1) = Decompress(APos(Len(StrainSeq(0))))
Else
    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
End If
'GYAxHi(1) = Decompress(Len(StrainSeq(0)))
'Call DoAxes(0,1, Decompress(APos(Len(StrainSeq(0)))), TypeSeq, MNo, 0, 1, "Predicted disruption (E)")
' DoAxes 1, APos(Len(StrainSeq(0))), TypeSeq, PPMax * Win, PPMin * Win, 1, "Breakpoints per " & Trim(Str(Win)) & " nt window"
Dim Pict As Long

Pict = Form1.Picture7.hdc


Form1.Picture7.ForeColor = RGB(128, 128, 128)
dX = -1
dy = -1
Dim InIt As Byte, MaxInIt As Double, Optx As Double

Dim NumLines As Long

hNumLines = 0 'this is used to keep track of how many lines must be saved for the metafile

Dim StartPos As Long, EndPos As Long

If MNo > 0 Then
    For x = 1 To Len(StrainSeq(0)) - 1
        If NucOutputNum(x) And NucOutputNum(x + 1) > 0 Then
            If x = 1 Then NumLines = NumLines + 1
'            MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 1) / MNo) * (PicHeight - 35)), PntAPI
'            LineTo Pict, 30 + Decompress((APos(X + 1))) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 1) / MNo) * (PicHeight - 35))
            'Form1.Picture7.Refresh
            'this tracks along the top
            'X = X
        Else
            If NucOutputNum(x) > 0 Then
                'Form1.Picture7.Refresh
'                MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 1) / MNo) * (PicHeight - 35)), PntAPI
'                LineTo Pict, 30 + (Decompress(APos(X))) * XFactor, PicHeight - (15 + (NucOutput(X, 2) / MNo) * (PicHeight - 35))
                'MoveToEx Pict, 30 + X * XFactor, PicHeight - (15 + (0) * (PicHeight - 35)), PntAPI
                'LineTo Pict, 30 + (LastX) * XFactor, PicHeight - (15 + (0) * (PicHeight - 35))
                'this is the right bound of the polygon
'                EndPos = X
'                For Z = X - 1 To StartPos Step -1
'
'                Next Z
'                Form1.Picture7.Refresh
                'X = X
            ElseIf NucOutputNum(x + 1) > 0 Then
                
'                MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 2) / MNo) * (PicHeight - 35)), PntAPI
'                LineTo Pict, 30 + (Decompress(APos(X))) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 1) / MNo) * (PicHeight - 35))
                'Form1.Picture7.Refresh
                NumLines = NumLines + 1
'                StartPos = X
                'this initiates a new polygon
            End If
            
        End If
    Next 'X
End If
'Form1.Picture7.Refresh
'do the bottom line and floodfill while going along
MaxLineX = 0
InIt = 0
MaxInIt = 10000
Optx = 0
FirstLineX = 0
fX = 0
lX = 0
For x = 3 To Len(StrainSeq(0)) - 1
'X = X - 100
   ' If NucOutputNum(X) > 0 Then
   '     X = X
   ' End If
   ' If NucOutput(X, 1) <> NucOutput(X, 2) And NucOutputNum(X) > 0 Then
   '     X = X
   ' End If
    If NucOutputNum(x) > 0 And NucOutputNum(x + 1) > 0 And NucOutput(x, 1) <> NucOutput(x, 2) Then
        If FirstLineX = 0 Then
            FirstLineX = 30 + Decompress(APos(x)) * XFactor
            fX = x
        End If
'        MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 2) / MNo) * (PicHeight - 35)), PntAPI
'        LineTo Pict, 30 + (Decompress(APos(X + 1))) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 2) / MNo) * (PicHeight - 35))
        MaxLineX = 30 + APos(x) * XFactor: lX = x
        InIt = 1
        If MaxInIt > PicHeight - (15 + (NucOutput(x, 0) / MNo) * (PicHeight - 35)) Then
            MaxInIt = PicHeight - (15 + (NucOutput(x, 0) / MNo) * (PicHeight - 35))
            Optx = 30 + Decompress(APos(x)) * XFactor
            If x > 0 Then
                If NucOutput(x - 1, 1) <= 0 Then
                  Optx = Optx + 1
                End If
            End If
                
            WinX = x
        
        
        End If
        
        
    Else
        
        If NucOutputNum(x) > 0 Then
            If MNo > 0 Then
            If NucOutput(x, 2) <> NucOutput(x, 1) Then
                If FirstLineX = 0 Then
                    FirstLineX = 30 + Decompress(APos(x)) * XFactor
                    fX = x
                End If
'                MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 2) / MNo) * (PicHeight - 35)), PntAPI
'                LineTo Pict, 30 + (Decompress(APos(X))) * XFactor, PicHeight - (15 + (NucOutput(X, 1) / MNo) * (PicHeight - 35))
                MaxLineX = 30 + Decompress(APos(x)) * XFactor: lX = x
                'MoveToEx Pict, 30 + X * XFactor, PicHeight - (15 + (0) * (PicHeight - 35)), PntAPI
                'LineTo Pict, 30 + (LastX) * XFactor, PicHeight - (15 + (0) * (PicHeight - 35))
            ElseIf NucOutputNum(x) > 0 And NucOutputNum(x + 1) > 0 And NucOutput(x, 1) = NucOutput(x, 2) Then
                If FirstLineX = 0 Then
                    FirstLineX = 30 + Decompress(APos(x)) * XFactor
                    fX = x
                End If
'                MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 2) / MNo) * (PicHeight - 35)), PntAPI
'                LineTo Pict, 30 + (Decompress(APos(X))) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 2) / MNo) * (PicHeight - 35))
                MaxLineX = 30 + Decompress(APos(x)) * XFactor: lX = x
            End If
        '
            End If
            
        End If
        If InIt = 1 Then
            'If GoOn = 1 Then
                Form1.Picture7.FillStyle = 0
                Form1.Picture7.FillColor = RGB(128, 128, 128)
                Pict = Form1.Picture7.hdc
                
                Optx = FirstLineX + (MaxLineX - FirstLineX) / 2
                WinX = CLng(fX + (lX - fX) / 2)
                
                If CLng(Optx) = CLng((30 + Decompress(APos(x)) * XFactor)) And CLng(FirstLineX) < CLng(Optx) Then
                    Optx = Optx - 1
                    WinX = WinX - 1 / XFactor
                ElseIf CLng(Optx) <= CLng(FirstLineX) Then
                    Optx = Optx + 1
                    WinX = WinX + 1 / XFactor
                End If
                
                'XX = BPos(WinX)
                Form1.Picture7.DrawWidth = 1
                If CLng(PicHeight - (15 + (NucOutput(WinX, 2) / MNo) * (PicHeight - 35))) > CLng(PicHeight - (15 + (NucOutput(WinX, 1) / MNo) * (PicHeight - 35))) Then
                    MaxInIt = (PicHeight - (15 + (NucOutput(WinX, 1) / MNo) * (PicHeight - 35))) + (((PicHeight - (15 + (NucOutput(WinX, 2) / MNo) * (PicHeight - 35))) - (PicHeight - (15 + (NucOutput(WinX, 1) / MNo) * (PicHeight - 35))))) / 2
                    
                End If
                
                'Form1.Picture7.PSet (Optx, MaxInIt), RGB(255, 0, 0)
                SetPixelV Pict, CLng(Optx), MaxInIt, RGB(255, 0, 0)
                'SetPixelV Pict, 202, 10, RGB(255, 0, 0)
                If WinX > 1 And NucOutputNum(WinX) > 0 And CLng(Optx) < CLng(MaxLineX) And CLng(PicHeight - (15 + (NucOutput(WinX, 1) / MNo) * (PicHeight - 35))) <> CLng(PicHeight - (15 + (NucOutput(WinX, 2) / MNo) * (PicHeight - 35))) Then
                    'PSet (Optx, MaxInIt), RGB(255, 0, 0)
                    
                    
                    '*******Uncomment to do floodfill
                    'FloodFill Pict, Optx, MaxInIt, RGB(128, 128, 128)
                End If
                FirstLineX = 0
                fX = 0
            'End If
            
            MaxInIt = 100000
            InIt = 0
        
        
        End If
        If NucOutputNum(x) = 0 Then
            FirstLineX = 0
            fX = 0
        End If
    End If
Next 'X
Dim GreyNum As Long
GreyNum = NumLines
Form1.Picture7.FillStyle = 1
'outline of grey done by this point
LastY = 0
LastX = 0
Form1.Picture7.ForeColor = 0
For x = 1 To Len(StrainSeq(0)) - 1
    If MNo > 0 Then
        If NucOutputNum(x) > 0 And NucOutputNum(x + 1) > 0 Then
            If x = 1 Then NumLines = NumLines + 1
'            MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 0) / MNo) * (PicHeight - 35)), PntAPI
'            LineTo Pict, 30 + (Decompress(APos(X + 1))) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 0) / MNo) * (PicHeight - 35))
            LastY = NucOutput(APos(x + 1), 0)
            
            'LastX = X
            'If NucOutput(X, 0) > 0 Then
            '    X = X
            'End If
        Else
            If MNo > 0 Then
                If NucOutputNum(x) > 0 Then
'                    MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X, 0) / MNo) * (PicHeight - 35)), PntAPI
'                    LineTo Pict, 30 + (Decompress(APos(X))) * XFactor, PicHeight - (15 + (NucOutput(X, 0) / MNo) * (PicHeight - 35))
                ElseIf NucOutputNum(x + 1) > 0 Then
'                    MoveToEx Pict, 30 + Decompress(APos(X)) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 0) / MNo) * (PicHeight - 35)), PntAPI
'                    LineTo Pict, 30 + (Decompress(APos(X))) * XFactor, PicHeight - (15 + (NucOutput(X + 1, 0) / MNo) * (PicHeight - 35))
                    NumLines = NumLines + 1
                    LastX = x + 1
                End If
                If LastY <> 0 Then
                    LastY = 0
                    LastX = x
                End If
            End If
        End If
    End If
Next 'X


'black line done by here

Dim YPos() As Double, SeqPos() As Byte
ReDim YPos(PermPDBNo)

For Y = 0 To PermPDBNo 'work out ycoords for p-val printing
    ReDim SeqPos(Len(StrainSeq(0)))
    ProbY = 1
    If ProtInfo(0, Y) < ProtInfo(1, Y) Then
        For x = ProtInfo(0, Y) To ProtInfo(1, Y)
            SeqPos(x) = 1
        Next x
    Else
        For x = ProtInfo(1, Y) To ProtInfo(0, Y)
            SeqPos(x) = 1
        Next x
    End If
    For Z = Y - 1 To 0 Step -1 'check for overlap
        If ProtInfo(0, Z) < ProtInfo(1, Z) Then
            For x = ProtInfo(0, Z) To ProtInfo(1, Z)
                If SeqPos(x) = 1 Then
                    ProbY = ProbY - 0.05
                    Exit For
                End If
            Next x
        Else
            For x = ProtInfo(1, Z) To ProtInfo(0, Z)
                If SeqPos(x) = 1 Then
                    ProbY = ProbY - 0.05
                    Exit For
                End If
            Next x
        End If
    Next Z
    YPos(Y) = ProbY
Next Y



For Y = 0 To PermPDBNo
     ProbY = YPos(Y)
    ProbTest$ = LowerThanReal(Y)
    If ProtInfo(1, Y) > ProtInfo(0, Y) Then
        If ProtInfo(2, Y) <= 2 Then
            ProbX = Decompress(ProtInfo(0, Y)) + Decompress((ProtInfo(1, Y)) - Decompress(ProtInfo(0, Y))) / 2
        Else
            If Len(StrainSeq(0)) - ProtInfo(1, Y) > ProtInfo(0, Y) Then
                ProbX = Decompress(ProtInfo(1, Y)) + (Decompress(Len(StrainSeq(0))) - Decompress(ProtInfo(1, Y))) / 2
            Else
                ProbX = Decompress(ProtInfo(0, Y)) / 2
            End If
        End If
    Else
        If ProtInfo(2, Y) > 2 Then
            ProbX = Decompress(ProtInfo(1, Y)) + (Decompress(ProtInfo(0, Y)) - Decompress(ProtInfo(1, Y))) / 2
        Else
            If Len(StrainSeq(0)) - ProtInfo(0, Y) > ProtInfo(1, Y) Then
                ProbX = Decompress(ProtInfo(0, Y)) + (Decompress(Len(StrainSeq(0))) - Decompress(ProtInfo(0, Y))) / 2
            Else
                ProbX = Decompress(ProtInfo(1, Y)) / 2
            End If
        End If
    
    End If
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
        ProbX = APos(CLng(ProbX))
    Else
    
    End If
    'If SFlag = 0 Then
        Call PrintProbability
    'End If
Next Y

GPrintNum = NumLines - 1
If GPrintNum = -1 Then GPrintNum = 0
NSites = APos(Len(StrainSeq(0)))
ReDim GVarPos(0, NBreaksX)
For x = 1 To NBreaksX - 1
    
    GVarPos(0, x) = XDiffPos(x)
    
Next x
For x = 1 To NSites
    XDiffPos(x) = TempXDiffpos(x)
Next x

Erase TempXDiffpos
If GPrintNum < 0 Then Exit Sub
ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)

ReDim GCritval(10)

GLegend = "Predicted disruption (E)"
GPrintLen = NSites * 2  'how many points to plot
For x = 0 To GreyNum - 1
    GPrintCol(x) = RGB(128, 128, 128) 'line is grey
Next x

For x = GreyNum + 1 To GPrintNum
    GPrintCol(x) = 0 'line is black
Next x


GPrintType = 0 'a normal line plot
GPrintMin(0) = 0  'bottom val
GPrintMin(1) = MNo 'upper val

NumLines = -1 'this is used to keep track of how many lines must be saved for the metafile
Dim cpPos As Long
cpPos = 0
For x = 1 To Len(StrainSeq(0)) - 1
    If NucOutputNum(x) > 0 And NucOutputNum(x + 1) > 0 Then
        'tracks along the top of the polygon
        If x = 1 Then NumLines = NumLines + 1
        GPrint(NumLines, cpPos) = NucOutput(x, 1)
        GPrintPos(NumLines, cpPos) = APos(x)
        cpPos = cpPos + 1
        
    Else
        If NucOutputNum(x) > 0 Then
            'right side of the polygon
            GPrint(NumLines, cpPos) = NucOutput(x, 1)
            GPrintPos(NumLines, cpPos) = APos(x)
            cpPos = cpPos + 1
            'no go back
            For Y = x To 1 Step -1
                If NucOutputNum(Y) > 0 And NucOutputNum(Y - 1) > 0 Then
                    GPrint(NumLines, cpPos) = NucOutput(Y, 2)
                    GPrintPos(NumLines, cpPos) = APos(Y)
                    cpPos = cpPos + 1
                ElseIf NucOutputNum(Y) > 0 Then
                    GPrint(NumLines, cpPos) = NucOutput(Y, 2)
                    GPrintPos(NumLines, cpPos) = APos(Y)
                    cpPos = cpPos + 1
                    GPrint(NumLines, cpPos) = NucOutput(Y, 1)
                    GPrintPos(NumLines, cpPos) = APos(Y)
                    cpPos = cpPos + 1
                    
                    Exit For
                End If
            Next Y
        
        ElseIf NucOutputNum(x + 1) > 0 Then
            'left end of the polygon
            NumLines = NumLines + 1
            GPrint(NumLines, cpPos) = NucOutput(x + 1, 2)
            GPrintPos(NumLines, cpPos) = APos(x + 1)
            cpPos = cpPos + 1
            GPrint(NumLines, cpPos) = NucOutput(x + 1, 1)
            GPrintPos(NumLines, cpPos) = APos(x + 1)
            StartPos = x + 1
            
            cpPos = cpPos + 1
        End If
        
    End If
Next 'X
'do the bottom line and floodfill while going along
cpPos = 0
'NumLines = 0

For x = 1 To Len(StrainSeq(0)) - 1
    If NucOutputNum(x) And NucOutputNum(x + 1) > 0 Then
        'scanning along
        If x = 1 Then NumLines = NumLines + 1
        GPrint(NumLines, cpPos) = NucOutput(x, 0)
        GPrintPos(NumLines, cpPos) = APos(x)
        cpPos = cpPos + 1
    Else
        
        If NucOutputNum(x) > 0 Then
            'left end
            GPrint(NumLines, cpPos) = NucOutput(x, 0)
            GPrintPos(NumLines, cpPos) = APos(x)
            cpPos = cpPos + 1
'            GPrint(NumLines, cpPos) = 0
'            GPrintPos(NumLines, cpPos) = APos(X)
'            cpPos = cpPos + 1
        ElseIf NucOutputNum(x + 1) > 0 Then
            'right end
            NumLines = NumLines + 1
            cpPos = 1
            'GPrint(NumLines, cpPos) = 0
            'GPrintPos(NumLines, cpPos) = APos(X + 1)
            'cpPos = cpPos + 1
           
        End If
        
    End If
Next 'X


'need to now reverse the order of the entries into gprintcol, gprint and gprintpos
Dim tGPrint() As Double, tGPrintCol() As Long, tGPrintPos() As Long
ReDim tGPrint(GPrintNum, NSites * 2 + 2), tGPrintCol(GPrintNum), tGPrintPos(GPrintNum, NSites * 2 + 2)
'For X = 0 To GPrintNum
'    tGPrintCol(X) = GPrintCol(X)
'    For Y = 1 To NSites * 2 + 2
'        tGPrint(X, Y) = GPrint(X, Y)
'        tGPrintPos(X, Y) = GPrintPos(X, Y)
'    Next Y
'
'Next X




Z = -1
'For X = GPrintNum To 0 Step -1
'    Z = Z + 1
''    GPrintCol(Z) = tGPrintCol(X)
''    For Y = 1 To NSites * 2 + 2
''        GPrint(Z, Y) = tGPrint(X, Y)
''        GPrintPos(Z, Y) = tGPrintPos(X, Y)
''    Next Y
'
'Next X
GBlockNum = -1
GExtraTNum = -1

'For X = 0 To GPrintNum
'    If GPrintCol(X) = 0 Then
''        tGPrintCol(X) = GPrintCol(X)
''        For Y = 1 To NSites * 2 + 2
''            If GPrintPos(X, Y) > 0 And GPrint(X, Y) = 0 Then
''                If Y > 0 And Y < NSites * 2 + 2 Then
''                    If GPrint(X, Y - 1) = 0 Or GPrint(X, Y + 1) = 0 Then
''                        GPrintPos(X, Y) = 0
''                    End If
''                End If
''
''            End If
''        Next Y
'    End If
'Next X
'Form1.Picture7.Refresh
Call RedrawPlotAA(1)
'Call RedrawPlot(0)
x = x
'Call DoAxes(0,1, APos(Len(StrainSeq(0))), TypeSeq, MNo, 0, 1, "Predicted disruption (E)")


'ReDim GExtraText(GExtraTNum)
'GExtraText(0) = "Breakpoint number"
'GExtraText(1) = "Local 95% confidence interval"
'GExtraText(2) = "Local 99% confidence interval"



Form1.Picture7.ForeColor = 0
'ProtInfo(0, PermPDBNo) = WinRange(0, X) '0:894-1155
'        ProtInfo(1, PermPDBNo) = WinRange(1, X)
ManFlag = 60
Call DoLegend
Form1.SSPanel1.Caption = ""
If DebuggingFlag < 2 Then On Error Resume Next
ChDrive oDir
ChDir oDir
On Error GoTo 0
End Sub
Public Sub MakeTrans()
Dim x As Long, Y As Long, Z As Long, A As Long
Dim Syn As Byte
Dim nSyn As Byte

ReDim Nucs(255), RevNucs(255)

Nucs(66) = 1: RevNucs(66) = 4
Nucs(68) = 2: RevNucs(68) = 3
Nucs(72) = 3: RevNucs(72) = 2
Nucs(85) = 4: RevNucs(85) = 1

Trans(3, 2, 4) = "A": Trans(3, 2, 2) = "A": Trans(3, 2, 1) = "A": Trans(3, 2, 3) = "A"
Trans(4, 4, 1) = "L": Trans(4, 4, 3) = "L": Trans(2, 4, 4) = "L": Trans(2, 4, 2) = "L": Trans(2, 4, 1) = "L": Trans(2, 4, 3) = "L"
Trans(2, 3, 4) = "R": Trans(2, 3, 2) = "R": Trans(2, 3, 1) = "R": Trans(2, 3, 3) = "R": Trans(1, 3, 1) = "R": Trans(1, 3, 3) = "R"
Trans(1, 1, 1) = "K": Trans(1, 1, 3) = "K"
Trans(1, 1, 4) = "N": Trans(1, 1, 2) = "N": Trans(1, 4, 3) = "M"
Trans(3, 1, 4) = "D": Trans(3, 1, 2) = "D"
Trans(4, 4, 2) = "F": Trans(4, 4, 4) = "F"
Trans(4, 3, 2) = "C": Trans(4, 3, 4) = "C"
Trans(2, 2, 4) = "P": Trans(2, 2, 2) = "P": Trans(2, 2, 1) = "P": Trans(2, 2, 3) = "P"
Trans(2, 1, 1) = "Q": Trans(2, 1, 3) = "Q"
Trans(4, 2, 4) = "S": Trans(4, 2, 2) = "S": Trans(4, 2, 1) = "S": Trans(4, 2, 3) = "S": Trans(1, 3, 4) = "S": Trans(1, 3, 2) = "S"
Trans(3, 1, 1) = "E": Trans(3, 1, 3) = "E"
Trans(1, 2, 4) = "T": Trans(1, 2, 2) = "T": Trans(1, 2, 1) = "T": Trans(1, 2, 3) = "T"
Trans(3, 3, 4) = "G": Trans(3, 3, 2) = "G": Trans(3, 3, 1) = "G": Trans(3, 3, 3) = "G"
Trans(4, 3, 3) = "W"
Trans(2, 1, 4) = "H": Trans(2, 1, 2) = "H"
Trans(4, 1, 4) = "Y": Trans(4, 1, 2) = "Y"
Trans(1, 4, 4) = "I": Trans(1, 4, 2) = "I": Trans(1, 4, 1) = "I"
Trans(3, 4, 4) = "V": Trans(3, 4, 2) = "V": Trans(3, 4, 1) = "V": Trans(3, 4, 3) = "V"
Trans(1, 4, 3) = "M"
Trans(4, 1, 1) = "*": Trans(4, 3, 1) = "*": Trans(4, 1, 3) = "*"




For x = 1 To 4
    For Y = 1 To 4
        For Z = 1 To 4
            
            Syn = 0
            nSyn = 0
            For A = 1 To 4
                If A <> x Then
                    If Trans(x, Y, Z) = Trans(A, Y, Z) Then
                        Syn = Syn + 1
                    Else
                        nSyn = nSyn + 1
                    End If
                End If
            Next A
            For A = 1 To 4
                If A <> x Then
                    If Trans(x, Y, Z) = Trans(x, A, Z) Then
                        Syn = Syn + 1
                    Else
                        nSyn = nSyn + 1
                    End If
                End If
            Next A
            For A = 1 To 4
                If A <> x Then
                    If Trans(x, Y, Z) = Trans(x, Y, A) Then
                        Syn = Syn + 1
                    Else
                        nSyn = nSyn + 1
                    End If
                End If
                
                
                
            Next A
            PropSynMuts(x, Y, Z) = Syn / 9
            x = x
        Next Z
    Next Y
Next x



End Sub

Public Sub OpenPDB()
Dim oDir As String, CN As Long, NF As Long, SeqFile As String, LastChain As Long, Pos As Long, LPos As Long, Spos As Long, LineNum As Long, LastLineNum As Long
Dim TempPDBtoAlign() As Long, TempPDBtoAlign2() As Long
Dim SeqspacesB() As Long
 XX = SCHEMAPermNo
NF = FreeFile
For x = 0 To 5
    Translation(x) = ""
Next x

Open PDBFile For Binary Access Read As #NF

SeqFile = String$(LOF(1), " ")
Get #NF, 1, SeqFile

Close #NF

PDBFileNumber = PDBFileNumber + 1
ReDim Preserve PDBFileName(PDBFileNumber)
PDBFileName(PDBFileNumber) = PDBFile


If DebuggingFlag < 2 Then On Error Resume Next
oDir = CurDir
ChDrive App.Path
ChDir App.Path
On Error GoTo 0

'Read amino acid sequence in
ReDim PDBSeq(0)


'A.................Ala.................Alanine
'B.................Asx.................Aspartic acid or Asparagine
'C.................Cys.................Cysteine
'D.................Asp.................Aspartic Acid
'E.................Glu.................Glutamic Acid
'F.................Phe.................Phenylalanine
'G.................Gly.................Glycine
'H.................His.................Histidine
'I.................Ile.................Isoleucine
'K.................Lys.................Lysine
'L.................Leu.................Leucine
'M.................Met.................Methionine
'N.................Asn.................Asparagine
'P.................Pro.................Proline
'Q.................Gln.................Glutamine
'R.................Arg.................Arginine
'S.................Ser.................Serine
'T.................Thr.................Threonine
'V.................Val.................Valine
'W.................Trp.................Tryptophan
'X.................Xaa.................Any amino acid
'Y.................Tyr.................Tyrosine
'Z.................Glx.................Glutamine or Glutamic acid

LPos = 1
'WPos = 2
LastLineNum = -1
TotStructs = -1
CN = TotStructs + 1
Dim NPos As Long, TestAmino As String, LD As Long, WPos As Long ', AAtoProtPos() As Long
LD = 0
If x = x Then 'this does ATOM the other does SEQRES
    Dim MB2 As Long, TotAmino As Long, AN As Long, TestAA As String, TestPos As Long, LastTest As Long, TP As Long, AtomArray() As Double, AtomTrack() As Long, CNSTart() As Long
    ReDim AtomTrack(100) ', AAtoProtPos(100)
    
    MB2 = 100
    ReDim AtomArray(2, MB2, 100)
    For A = 0 To 2
        For b = 0 To MB2
            For C = 0 To 100
                AtomArray(A, b, C) = 1000000
            Next C
        Next b
    Next A
    AN = 0
    TP = 0
    TestPos = -1
    Do
       'read chain
        Pos = InStr(LPos, SeqFile, "ATOM  ", vbBinaryCompare)
        'If LPos < WPos Then
            WPos = InStr(LPos, SeqFile, "TER  ", vbBinaryCompare)
        'End If
        If WPos = 0 Then
            WPos = InStr(LPos, SeqFile, "TER", vbBinaryCompare)
        End If
        
        If WPos < Pos Then
            If CN >= 0 Then
                If MaxaaLen < Len(PDBSeq(CN)) Then
                    MaxaaLen = Len(PDBSeq(CN))
                End If
            End If
            If CN = 1 Then
                Form1.SSPanel1.Caption = Trim(Str(CN)) + " structure loaded"
            ElseIf CN > 1 Then
                Form1.SSPanel1.Caption = Trim(Str(CN)) + " structures loaded"
            End If
            CN = CN + 1
            ReDim Preserve PDBSeq(CN)
            ReDim Preserve CNSTart(CN)
            CNSTart(CN) = TotAmino + 1
        End If
        NPos = InStr(Pos + 1, SeqFile, Chr(10), vbBinaryCompare)
        If NPos = 0 Then NPos = InStr(Pos + 1, SeqFile, Chr(13), vbBinaryCompare)
        
        
        
        If Pos > 0 Then
            LPos = Pos + 1
            
            
            TestPos = val(Trim(Mid$(SeqFile, Pos + 22, 4)))
            
            
            If TestPos <> LastPos Then
                AN = 0
                TestAmino = Mid$(SeqFile, Pos + 17, 3)
                TP = TP + 1
                TotAmino = TotAmino + 1
                If TotAmino > UBound(AtomArray, 3) Then
                    ReDim Preserve AtomArray(2, MB2, TotAmino + 100)
                    ReDim Preserve AtomTrack(TotAmino + 100)
                   ' ReDim Preserve AAtoProtPos(TotAmino + 100)
                    For A = 0 To 2
                        For b = 0 To MB2
                            For C = TotAmino To TotAmino + 100
                                AtomArray(A, b, C) = 1000000
                            Next C
                        Next b
                    Next A
                End If
               ' XX = Len(PDBSeq(CN))
                If TestAmino = "ALA" Then
                    PDBSeq(CN) = PDBSeq(CN) + "A"
                ElseIf TestAmino = "ASX" Then
                    PDBSeq(CN) = PDBSeq(CN) + "B"
                ElseIf TestAmino = "CYS" Then
                    PDBSeq(CN) = PDBSeq(CN) + "C"
                ElseIf TestAmino = "ASP" Then
                    PDBSeq(CN) = PDBSeq(CN) + "D"
                ElseIf TestAmino = "GLU" Then
                    PDBSeq(CN) = PDBSeq(CN) + "E"
                ElseIf TestAmino = "PHE" Then
                    PDBSeq(CN) = PDBSeq(CN) + "F"
                ElseIf TestAmino = "GLY" Then
                    PDBSeq(CN) = PDBSeq(CN) + "G"
                ElseIf TestAmino = "HIS" Then
                    PDBSeq(CN) = PDBSeq(CN) + "H"
                ElseIf TestAmino = "ILE" Then
                    PDBSeq(CN) = PDBSeq(CN) + "I"
                ElseIf TestAmino = "LYS" Then
                    PDBSeq(CN) = PDBSeq(CN) + "K"
                ElseIf TestAmino = "LEU" Then
                    PDBSeq(CN) = PDBSeq(CN) + "L"
                ElseIf TestAmino = "MET" Then
                    PDBSeq(CN) = PDBSeq(CN) + "M"
                ElseIf TestAmino = "ASN" Then
                    PDBSeq(CN) = PDBSeq(CN) + "N"
                ElseIf TestAmino = "PRO" Then
                    PDBSeq(CN) = PDBSeq(CN) + "P"
                ElseIf TestAmino = "GLN" Then
                    PDBSeq(CN) = PDBSeq(CN) + "Q"
                ElseIf TestAmino = "ARG" Then
                    PDBSeq(CN) = PDBSeq(CN) + "R"
                ElseIf TestAmino = "SER" Then
                    PDBSeq(CN) = PDBSeq(CN) + "S"
                ElseIf TestAmino = "THR" Then
                    PDBSeq(CN) = PDBSeq(CN) + "T"
                ElseIf TestAmino = "VAL" Then
                    PDBSeq(CN) = PDBSeq(CN) + "V"
                ElseIf TestAmino = "TRP" Then
                    PDBSeq(CN) = PDBSeq(CN) + "W"
                ElseIf TestAmino = "XAA" Then
                    PDBSeq(CN) = PDBSeq(CN) + "X"
                ElseIf TestAmino = "TYR" Then
                    PDBSeq(CN) = PDBSeq(CN) + "Y"
                ElseIf TestAmino = "GLX" Then
                    PDBSeq(CN) = PDBSeq(CN) + "Z"
                
                End If
               ' AAtoProtPos(TotAmino) = Len(PDBSeq(CN))
            End If
            LastPos = TestPos
            'Pos = Pos + 6
            
            
        Else
            Exit Do
        End If
        'XX = Mid$(SeqFile, Pos + 46, 8)
        'XX = Mid$(SeqFile, Pos, 38)
        'XX = UBound(AtomArray, 3)
        'XX = Val(Trim(Mid$(SeqFile, Pos + 30, 8)))
        AtomArray(0, AN, TotAmino) = val(Trim(Mid$(SeqFile, Pos + 30, 8)))
        AtomArray(1, AN, TotAmino) = val(Trim(Mid$(SeqFile, Pos + 38, 8)))
        AtomArray(2, AN, TotAmino) = val(Trim(Mid$(SeqFile, Pos + 46, 8)))
        AtomTrack(TotAmino) = CN
        AN = AN + 1
    Loop
Else

   
End If

Form1.ProgressBar1.Value = 25
Call UpdateF2Prog
If CN = 0 Then
     If CN >= 0 Then
        If MaxaaLen < Len(PDBSeq(CN)) Then
            MaxaaLen = Len(PDBSeq(CN))
        End If
    End If
    '    CN = CN + 1
    ReDim Preserve PDBSeq(CN)
    ReDim Preserve CNSTart(CN)
    CNSTart(CN) = 1

End If

Dim Dist As Double, MinDist() As Double
ReDim MinDist(TotAmino, TotAmino)
For x = 0 To TotAmino
    For Y = 0 To TotAmino
        MinDist(x, Y) = 100000
    Next Y
Next x

For x = 1 To TotAmino
    If x = x Then
        Dummy = AtomDists(x, MB2, TotAmino, AtomArray(0, 0, 0), MinDist(0, 0))
    Else
        For Y = 0 To MB2
            If AtomArray(0, Y, x) < 100000 Then
                For A = x + 1 To TotAmino
                    For b = 0 To MB2
                        If AtomArray(0, b, A) < 100000 Then
                            Dist = (AtomArray(0, b, A) - AtomArray(0, Y, x)) ^ 2
                            Dist = Dist + (AtomArray(1, b, A) - AtomArray(1, Y, x)) ^ 2
                            Dist = Dist + (AtomArray(2, b, A) - AtomArray(2, Y, x)) ^ 2
                            Dist = Dist ^ (0.5)
                            If Dist < MinDist(x, A) Then
                                MinDist(x, A) = Dist
                                MinDist(A, x) = Dist
                                If MinDist(1, 2) = 0 Then
                                    x = x
                                End If
                            End If
                        Else
                            Exit For
                        End If
                    Next b
                Next A
            Else
                Exit For
            End If
        
        Next Y
    End If
    SS = Abs(GetTickCount)
    If Abs(SS - EE) > 500 Then
        EE = SS
        Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(TotAmino)) + " amino acids scanned"
        Form1.ProgressBar1.Value = (x / TotAmino) * 25 + 60
        Call UpdateF2Prog
        Form1.Refresh
    End If
Next x
'XX = MinDist(1, 2) '1.3295
Dim D As Long
'Consolidate the distances (there may be duplicates because of polymerisation that is accounted for in the structures)
Dim MarkRemove() As Byte, Backtrack() As Long
ReDim Backtrack(CN)
For x = 0 To CN
    Backtrack(x) = x
Next x
Form1.Refresh
ReDim MarkRemove(CN)
For x = TotStructs + 1 To CN
    For Y = x + 1 To CN
    
        If PDBSeq(x) = PDBSeq(Y) Then 'merge the two
            Backtrack(Y) = x
            A = CNSTart(x)
            b = CNSTart(Y)
           
            Do
                For C = 1 To TotAmino
                    If MinDist(A, C) > MinDist(b, C) Then
                        MinDist(A, C) = MinDist(b, C)
                    End If
                    
                    MinDist(b, C) = 10000
                    
                Next C
                A = A + 1
                b = b + 1
                D = D + 1
                If A > TotAmino Then Exit Do
                If b > TotAmino Then Exit Do
                If AtomTrack(A) <> x Then Exit Do
                If AtomTrack(b) <> Y Then Exit Do
            Loop
            MarkRemove(Y) = 1
        End If
    Next Y
Next x


SS = Abs(GetTickCount)


'find homologous sequences in the alignment


'Make translation array
'Ala/A   GCU, GCC, GCA, GCG
'Leu/L   UUA, UUG, CUU, CUC, CUA, CUG
'Arg/R   CGU, CGC, CGA, CGG, AGA, AGG
'Lys/K   AAA, AAG
'Asn/N   AAU, AAC
'Met/M   AUG
'Asp/D   GAU, GAC
'Phe/F   UUU, UUC
'Cys/C   UGU, UGC
'Pro/P   CCU, CCC, CCA, CCG
'Gln/Q   CAA, CAG
'Ser/S   UCU, UCC, UCA, UCG, AGU, AGC
'Glu/E   GAA, GAG
'Thr/T   ACU, ACC, ACA, ACG
'Gly/G   GGU, GGC, GGA, GGG
'Trp/W   UGG
'His/H   CAU, CAC
'Tyr/Y   UAU, UAC
'Ile/I   AUU, AUC, AUA
'Val/V   GUU, GUC, GUA, GUG
'START   AUG
'STOP    UAA, UGA, UAG




'first convert the sequence into 0-4

Dim ZtF() As Byte, PosF As Long, PosR As Long

ReDim ZtF(Len(StrainSeq(0)) * 2, 1)
PosF = 0: PosR = 0
Dim FBacktrack() As Long, RBacktrack() As Long
ReDim FBacktrack(Len(StrainSeq(0)) * 2), RBacktrack(Len(StrainSeq(0)) * 2)

Dim RefSeq As Long
RefSeq = TypeSeqNumber
If RefSeq < 0 Then RefSeq = 0
If RefSeq > NextNo Then RefSeq = 0

For x = 0 To Len(StrainSeq(0)) * 2 '*2 because we are going to dimerise the translation to capture genes that overlap the ends of circular genomes
    If x > Len(StrainSeq(0)) Then
        Z = x - Len(StrainSeq(0))
    Else
        Z = x
    End If
    If SeqNum(Z, RefSeq) > 46 Then
        ZtF(PosF, 0) = Nucs(SeqNum(Z, RefSeq))
        FBacktrack(PosF) = Z
        PosF = PosF + 1
    End If
    If SeqNum(Len(StrainSeq(0)) - Z, RefSeq) > 46 Then
        ZtF(PosR, 1) = RevNucs(SeqNum(Len(StrainSeq(0)) - Z, RefSeq))
        RBacktrack(PosR) = Len(StrainSeq(0)) - Z
        PosR = PosR + 1
    End If
Next x


'get seqspacesb if it hasn't already been done
ReDim SeqspacesB(Len(StrainSeq(0)) + 2, NextNo)

'If SeqSpacesBFlag = 0 Then
    ReDim LenNoGaps(NextNo)
    For x = 0 To NextNo
        Z = 0
        For Y = 0 To Len(StrainSeq(0))
           If SeqNum(Y, x) > 46 Then
                Z = Z + 1
                SeqspacesB(Z, x) = Y
           End If
        Next Y
        
        LenNoGaps(x) = Z
    Next x
    
    
    
'End If

'translate one sequence in all six frames
Dim NucFromAA() As Long
ReDim NucFromAA(5, Len(StrainSeq(0)))
If Translation(0) = "" Then

    'translate forward
    For x = 0 To Len(StrainSeq(0)) * 2 - 4 Step 3
        Translation(0) = Translation(0) + Trans(ZtF(x, 0), ZtF(x + 1, 0), ZtF(x + 2, 0))
        Translation(1) = Translation(1) + Trans(ZtF(x + 1, 0), ZtF(x + 2, 0), ZtF(x + 3, 0))
        Translation(2) = Translation(2) + Trans(ZtF(x + 2, 0), ZtF(x + 3, 0), ZtF(x + 4, 0))
        Translation(3) = Translation(3) + Trans(ZtF(x, 1), ZtF(x + 1, 1), ZtF(x + 2, 1))
        Translation(4) = Translation(4) + Trans(ZtF(x + 1, 1), ZtF(x + 2, 1), ZtF(x + 3, 1))
        Translation(5) = Translation(5) + Trans(ZtF(x + 2, 1), ZtF(x + 3, 1), ZtF(x + 4, 1))
        NucFromAA(0, Len(Translation(0))) = FBacktrack(x)
        NucFromAA(1, Len(Translation(1))) = FBacktrack(x + 1)
        NucFromAA(2, Len(Translation(2))) = FBacktrack(x + 2)
        NucFromAA(3, Len(Translation(3))) = RBacktrack(x)
        NucFromAA(4, Len(Translation(4))) = RBacktrack(x + 1)
        NucFromAA(5, Len(Translation(5))) = RBacktrack(x + 2)
    Next x
    
   
    'For X = 0 To 5
    '    Translation(X) = Translation(X) + Translation(X)
    'Next X
End If

'XX = CurDir
'Open "test.fas" For Output As #1
'For X = 0 To 5
'    Print #1, ">" + Trim(Str(X))
'    Print #1, Translation(X)
'Next X
'Close #1
'XX = CurDir

'Make clustal bat file

Dim OSX As String, FF As Long, WholeFile() As Byte, AlignedSeqs(1) As String, AlignNum() As Byte, AScore As Double, VScore As Double

ReDim Preserve WinScorePDB(CN)
ReDim Preserve WinRange(1, CN)
ReDim Preserve WinFrame(CN)
For x = 0 To CN
    WinFrame(x) = -1
    WinScorePDB(x) = 0
    WinRange(1, x) = 0
    WinRange(0, x) = 0
Next x

FF = FreeFile
If DebuggingFlag < 2 Then On Error Resume Next
On Error Resume Next
KillFile "clustal.bat"

FLen = 0

FLen = FileLen("clustal.bat")



If FLen > 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
    
    FString = "clustal" & Trim(Str(Rnd)) & ".bat"
Else
    FString = "clustal.bat"
    
End If
Rnd (-BSRndNumSeed)
Open FString For Output As #FF
On Error GoTo 0



OSX = "clustalw /infile=IF" + UFTag + ".seq /output=fasta /type=p /gapopen=" + "5" + " /gapext=" + "0.5"


Print #FF, OSX
Print #FF, "del " + FString
Close #FF
Dim Seq2Align() As Long
'Align each of the chains to each of the translations.
On Error Resume Next
UB = 0
UB = UBound(Seq1Align, 1)
On Error GoTo 0
If Len(StrainSeq(0)) * 2 = UB Then
    ReDim Preserve Seq1Align(Len(StrainSeq(0)) * 2, CN)
    ReDim Preserve Seq2Align(Len(StrainSeq(0)) * 2, CN)
    ReDim Preserve TempPDBtoAlign2(Len(StrainSeq(0)), CN)
Else
    ReDim Seq1Align(Len(StrainSeq(0)) * 2, CN)
    ReDim Seq2Align(Len(StrainSeq(0)) * 2, CN)
    ReDim TempPDBtoAlign2(Len(StrainSeq(0)), CN)
End If

Dim STemp As String
For x = TotStructs + 1 To CN
    If MarkRemove(x) = 0 Then
        For Y = 0 To 5
            Form1.SSPanel1.Caption = "Scanning frame " + Trim(Str(Y + 1)) + " of protein " + Trim(Str(x + 1))
            'make the clustalW infile
            STemp = Translation(Y)
            LPos = 1
            Do
                Pos = InStr(LPos, STemp, "*", vbBinaryCompare)
                If Pos = 0 Then Exit Do
                Mid$(STemp, Pos, 1) = "X"
                LPos = Pos + 1
                
            Loop
            
            Open "IF" + UFTag + ".seq" For Output As #FF
            Print #FF, ">S1"
            Print #FF, STemp
            Print #FF, ">S2"
            Print #FF, PDBSeq(x)
            Close #FF
            
            
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "IF" + UFTag + ".fasta"
            On Error GoTo 0
            
            ShellAndClose App.Path + "\" + FString, 0
            
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDrive App.Path
            ChDir App.Path
            On Error GoTo 0
            
            'XX = curdrive
            
            'Loop
            x = x
            FF = FreeFile
            Open "IF" + UFTag + ".fasta" For Binary As #FF
            XX = LOF(FF)
            ReDim WholeFile(LOF(FF))
            Get #FF, , WholeFile()
            Close #FF
            UB = UBound(WholeFile, 1)
            If UB = 0 Then 'this checks whether shellandclose has messed up and uses an alternative approach if it has - I've no idea why shellandclose soemtimes messes up with clustalw
                Call GetCommandOutput(OSX, 0, True, True)
                Open "IF" + UFTag + ".fasta" For Binary As #FF
                ReDim WholeFile(LOF(FF))
                Get #FF, , WholeFile()
                XX = LOF(FF)
                Close #FF
                
            End If
            A = -1
            
            
            Dim RevAlign() As Long
            
            ReDim AlignNum(1, Len(StrainSeq(0)))
            AScore = 0
            VScore = 0
            
            For Z = 0 To UBound(WholeFile)
                
                If WholeFile(Z) = 62 Then
                    A = A + 1
                    b = 0
                    AlignedSeqs(A) = ""
                    Z = Z + 5
                    
                    Do While WholeFile(Z) <> 62 And Z <= UBound(WholeFile)
                        XX = Chr(WholeFile(Z))
                        If WholeFile(Z) > 15 And WholeFile(Z) < 100 Then
                            AlignedSeqs(A) = AlignedSeqs(A) + Chr(WholeFile(Z))
                            AlignNum(A, b) = WholeFile(Z)
                            b = b + 1
                        End If
                        
                        Z = Z + 1
                        If Z > UBound(WholeFile) Then Exit Do
                    Loop
                    Z = Z - 1
                'Else
                '    Do While WholeFile(Z) <> 62 And WholeFile(Z) > 40 And WholeFile(Z) < 100 And Z <= UBound(WholeFile)
                '        AlignedSeqs(A) = AlignedSeqs(A) + Chr(WholeFile(Z))
                '        Z = Z + 1
                '    Loop
                End If
            Next Z
            BE = -1
            EN = -1
            ReDim TempPDBtoAlign(Len(StrainSeq(0)))
            Dim CPosX As Long
            CPosX = 0
            For Z = 0 To Len(StrainSeq(0)) - 1
                If AlignNum(0, Z) > 60 Then
                    CPosX = NucFromAA(Y, Z + 1)
                End If
                If AlignNum(0, Z) > 60 And AlignNum(1, Z) > 60 Then
                    
                    VScore = VScore + 1
                    TempPDBtoAlign(VScore) = CPosX
                    If AlignNum(0, Z) = AlignNum(1, Z) Then
                        If BE = -1 Then
                            BE = Z + 1 '+1 because alignnum starts counting from 0
                        End If
                        EN = Z + 1
                        AScore = AScore + 1
                    End If
                End If
            
            Next Z
            If VScore > 0 Then
                AScore = AScore / VScore
            Else
                AScore = 0
            End If
          If WinScorePDB(x) < AScore And AScore > 0.5 Then
                WinScorePDB(x) = AScore
                WinFrame(x) = Y
                
               
                
                For A = 0 To Len(StrainSeq(0))
                    Seq1Align(A, x) = 0
                    TempPDBtoAlign2(A, x) = TempPDBtoAlign(A)
                Next A
                b = 0
                C = 0
                If Y <= 2 Then
                    
                    WinRange(0, x) = BE * 3 + Y + 1 '535-570,617-650
                    WinRange(1, x) = EN * 3 + Y + 1
                    
                    
                        
                    For A = 0 To Len(StrainSeq(0))
                        If AlignNum(0, A) > 45 Then
                            b = b + 1
                        End If
                        'If C = 36 Then
                        '    X = X
                        'End If
                        If AlignNum(1, A) > 45 Then
                            C = C + 1
                            D = b
                            D = D * 3 + Y - 2
                            If D > LenNoGaps(0) Then
                                D = D - (LenNoGaps(0))
                            End If
                            D = SeqspacesB(D, 0)
                            Seq1Align(D, x) = C
                            Seq2Align(C, x) = D
                        Else
                            x = x
                        End If
                        If BE = b Then
                            WinRange(0, x) = D
                        ElseIf EN = b Then
                            WinRange(1, x) = D
                        End If
                        
                    Next A
                    x = x
                    
                Else
                    WinRange(0, x) = LenNoGaps(0) - (BE * 3 + (Y - 3) + 1) '535-570,617-650
                    WinRange(1, x) = LenNoGaps(0) - (EN * 3 + (Y - 3) + 1)
                    
                    XX = PDBSeq(x)
                    For A = 0 To Len(StrainSeq(0))
                        If AlignNum(0, A) > 45 Then
                            b = b + 1
                        End If
                        
                        If AlignNum(1, A) > 45 Then '83
                            C = C + 1
                            'XX = Len(Translation(0)) '1707
                            'XX = Len(Translation(1)) '1707
                            'XX = Len(Translation(2)) '1706
                            'XX = Len(Translation(3)) '1707
                            'XX = Len(Translation(4)) '1706
                            'XX = Len(Translation(5)) '1706
                            
                            D = b
                            
                            D = D * 3 + (Y - 3) - 2
                            If D > LenNoGaps(0) Then
                                D = D - (LenNoGaps(0) - 1)
                            
                            End If
                            D = ((LenNoGaps(0) + 1) - D) '+ 1
                            D = SeqspacesB(D, 0)
                            
                            Seq1Align(D, x) = -C
                            Seq2Align(C, x) = D
                            
                        End If
                        If BE = b Then
                            WinRange(0, x) = D
                        ElseIf EN = b Then
                            WinRange(1, x) = D
                        End If
                    Next A
                    
                End If
                
            End If
            
            'Open "test2.fas" For Output As #1
            'Print #1, ">s1"
            'Print #1, AlignedSeqs(0)
            'Print #1, ">s2"
            'Print #1, AlignedSeqs(1)
            'Close #1
            x = x
        
        Next Y
    End If
    If CN > 0 Then
        Form1.ProgressBar1 = 60 + (x / CN) * 15
        Call UpdateF2Prog
    End If
Next x

'Make an array to keep track of protein numbers in CN array
Dim TrackingArray() As Long, CurCN As Long, AACountX As Long, AAPos() As Long
ReDim TrackingArray(TotAmino), AAPos(TotAmino)
For x = 1 To TotAmino
    For Y = TotStructs + 1 To CN
        If CNSTart(Y) = x Then
            AACountX = 0
            CurCN = Y
            Exit For
        End If
        
        
    Next Y
    AACountX = AACountX + 1
    AAPos(x) = AACountX
    TrackingArray(x) = CurCN
    
Next x
x = x
'PermSeq1Align (len(strainseq(0)),permpdbno)
'Make a list of the contacts < 20
'ContactMapT (4,permpdbno)
'(0) x aminoacid in protein 1
'(1) y aminoacid in protein 2
'(2) protein 1 number
'(3) protein 2 number
'(4) The distance between them
'(5) x aa position in protein1
'(6) y aminoacidposition in protein 2
'ContactMapB (2,permpdbno)
'(0) x coord
'(1) y coord
'(2) protein number

'PermPDBSeq (permpdbno)

'Protinfo(2,permpdbno)
'(0) ORF start in alignment
'(1) ORF end in alignment
'(2) Frame
'(3) pdbfilenumber

GoOn = 0
For x = TotStructs + 1 To CN
    If WinFrame(x) = -1 Then
        MarkRemove(x) = 1
    Else
        GoOn = 1
    End If
Next x

If GoOn = 0 Then
    If CLine = "" Or CLine = " " Then
        If CN > 1 Then
            MsgBox ("Insufficient amino acid similarity detected between any of the amino acid sequences in the .pdb file and the amino acid sequences potentially expressed by the current reference sequence.  You could try selecting another reference sequence in the 'SCHEMA' options tab")
        Else
            MsgBox ("Insufficient amino acid similarity detected between the amino acid sequence in the .pdb file and the amino acid sequences potentially expressed by the current reference sequence.  You could try selecting another reference sequence in the 'SCHEMA' options tab")
        
        End If
    End If
End If

Dim StartPDBNum As Long, PA As Long, PB As Long
StartPDBNum = PermPDBNo + 1
ReDim Preserve SixFrame(6, Len(StrainSeq(0)))
Dim AdjProtNo() As Long
ReDim AdjProtNo(CN)
Form1.SSPanel1.Caption = "Matching up amino acid and nucleotide positions"
For x = TotStructs + 1 To CN
    If MarkRemove(x) = 0 Then
        PermPDBNo = PermPDBNo + 1
        AdjProtNo(x) = PermPDBNo
       ' For Y = 0 To TotAmino
       '     If Backtrack(TrackingArray(Y)) = PermPDBNo Then
       '         Backtrack(TrackingArray(Y)) = X
       '     ElseIf Backtrack(TrackingArray(Y)) = X Then
       '         Backtrack(TrackingArray(Y)) = PermPDBNo
       '     End If
       ' Next Y
        'If Len(StrainSeq(0)) = UBound(PermSeq1Align, 1) Then
            ReDim Preserve PermSeq1Align(Len(StrainSeq(0)), PermPDBNo)
            ReDim Preserve PermSeq2Align(Len(StrainSeq(0)), PermPDBNo)
            ReDim Preserve PermPDBSeq(PermPDBNo)
            ReDim Preserve ProtInfo(3, PermPDBNo)
        'Else
        '    ReDim PermSeq1Align(Len(StrainSeq(0)), PermPDBNo)
         '   ReDim PermSeq2Align(Len(StrainSeq(0)), PermPDBNo)
         '   ReDim PermPDBSeq(PermPDBNo)
         '   ReDim ProtInfo(2, PermPDBNo)
        'End If
        PermPDBSeq(PermPDBNo) = PDBSeq(x)
        ProtInfo(0, PermPDBNo) = WinRange(0, x) '0:894-1155
        ProtInfo(1, PermPDBNo) = WinRange(1, x)
        ProtInfo(2, PermPDBNo) = WinFrame(x)
        ProtInfo(3, PermPDBNo) = PDBFileNumber
        If WinFrame(x) <= 2 Then
            If WinRange(0, x) < WinRange(1, x) Then
                For A = WinRange(0, x) To WinRange(1, x)
                    If A > Len(StrainSeq(0)) Then
                        b = A - Len(StrainSeq(0))
                    Else
                        b = A
                    End If
                    SixFrame(0, b) = 1
                    SixFrame(WinFrame(x) + 1, b) = 1
                Next A
            Else
                For A = WinRange(0, x) To Len(StrainSeq(0))
                    
                    SixFrame(0, A) = 1
                    SixFrame(WinFrame(x) + 1, A) = 1
                Next A
                For A = 0 To WinRange(1, x)
                    If A > Len(StrainSeq(0)) Then
                        b = A - Len(StrainSeq(0))
                    Else
                        b = A
                    End If
                    SixFrame(0, b) = 1
                    SixFrame(WinFrame(x) + 1, b) = 1
                Next A
            End If
        Else
            If WinRange(1, x) < WinRange(0, x) Then
                For A = WinRange(1, x) To WinRange(0, x)
                    If A > Len(StrainSeq(0)) Then
                        b = A - Len(StrainSeq(0))
                    Else
                        b = A
                    End If
                    SixFrame(0, b) = 1
                    SixFrame(WinFrame(x) + 1, b) = 1
                Next A
            Else
                For A = WinRange(1, x) To Len(StrainSeq(0))
                    
                    SixFrame(0, A) = 1
                    SixFrame(WinFrame(x) + 1, A) = 1
                Next A
                For A = 0 To WinRange(0, x)
                    If A > Len(StrainSeq(0)) Then
                        b = A - Len(StrainSeq(0))
                    Else
                        b = A
                    End If
                    SixFrame(0, b) = 1
                    SixFrame(WinFrame(x) + 1, b) = 1
                Next A
            End If
        End If
        ReDim Preserve PDBtoAlign(Len(StrainSeq(0)), PermPDBNo)
        
        'seq1align = nt sequence coord of seq 1
        'seq2align = aa secuence coord of query from pdb file
        For Y = 0 To Len(StrainSeq(0))
            PermSeq1Align(Y, PermPDBNo) = Seq1Align(Y, x)
            PermSeq2Align(Y, PermPDBNo) = Seq2Align(Y, x)
            PDBtoAlign(Y, PermPDBNo) = TempPDBtoAlign2(Y, x)
        Next Y
        
        ReDim Preserve ContactMapB(4, PermContactNumberB + 100)
        ReDim Preserve ContactMapT(6, PermContactNumberT + 100)
        ReDim Preserve InterProtMap(1, PermInterProtInteracts + 100)
        'now add all the contacts
        For A = 1 To TotAmino
        
            If MarkRemove(TrackingArray(A)) = 0 And TrackingArray(A) = x Then
                For b = A + 1 To TotAmino
                    If MarkRemove(TrackingArray(b)) = 0 Then
                        If MinDist(A, b) < 20 Then
                            
                            PermContactNumberT = PermContactNumberT + 1
                            If PermContactNumberT > UBound(ContactMapT, 2) Then
                                ReDim Preserve ContactMapT(6, PermContactNumberT + 100)
                            End If
                            PA = Backtrack(TrackingArray(A))
                            PB = Backtrack(TrackingArray(b))
                            ContactMapT(0, PermContactNumberT) = AAPos(A)
                            ContactMapT(1, PermContactNumberT) = AAPos(b)
                            If PA <> 1 Then
                                
                            End If
                            ContactMapT(2, PermContactNumberT) = AdjProtNo(PA) ' PA + StartPDBNum
                            ContactMapT(3, PermContactNumberT) = AdjProtNo(PB) 'PB + StartPDBNum
                            
                            
                            ContactMapT(4, PermContactNumberT) = MinDist(A, b)
                            
                            If PA <> PB Then
                                PermInterProtInteracts = PermInterProtInteracts + 1
                                If PermInterProtInteracts > UBound(InterProtMap, 2) Then
                                    ReDim Preserve InterProtMap(1, PermInterProtInteracts + 100)
                                End If
                                InterProtMap(0, PermInterProtInteracts) = AdjProtNo(PA) 'PA + StartPDBNum
                                InterProtMap(1, PermInterProtInteracts) = AdjProtNo(PB) 'PB + StartPDBNum
                            End If
                        End If
                    End If
                Next b
            End If
        Next A
        x = x
    End If
    If CN > 0 Then
        Form1.ProgressBar1 = 75 + (x / CN) * 25
        Call UpdateF2Prog
    End If
    Form1.Refresh
Next x

'XX = PDBSeq(1)
'mark the crude chunk of the alignment corresponding to each new CN





If DebuggingFlag < 2 Then On Error Resume Next
ChDrive oDir
ChDir oDir
On Error GoTo 0


TotStructs = CN

'translate reverse comp

'Individually align each chain to this.

'XX = Len(PDBSeq(0))
'XX = Len(PDBSeq(1))
'XX = Len(PDBSeq(2))
'XX = Len(PDBSeq(3))
x = x
End Sub
Public Sub MrBayesInfile(NumberOfSeqs, SR, TBNGens, TBSampFreq)
Dim Boots() As String
ReDim Boots(NumberOfSeqs + 1)
Open "infile" For Output As #1
        
        Print #1, "#NEXUS"
        Print #1, "begin data;"
        Print #1, "dimensions ntax=" & Trim(Str(NumberOfSeqs + 1)) & " nchar=" & Trim(Str(Len(TempSeq(0)))) & ";"
        Print #1, "format datatype=dna interleave=no gap=- missing=?;"
        Print #1, "matrix"
        If NextNo < 100 Then
            NLen = 2
        ElseIf NextNo < 1000 Then
            NLen = 3
        ElseIf NextNo < 10000 Then
             NLen = 4
        ElseIf NextNo < 100000 Then
             NLen = 5
        ElseIf NextNo < 1000000 Then
             NLen = 6
        End If
        For x = 0 To NumberOfSeqs
            
            TName = Trim$(CStr(x))
            TName = String(NLen - Len(TName), "0") & TName
            TName = "S" & TName
            BootName = TName
            BootName = BootName + String$(10 - (Len(BootName)), " ")
            TString = TempSeq(x)
            Boots(x) = BootName + TString
            Print #1, Boots(x)
        Next 'X
        Print #1, ";"
        Print #1, "end;"
        'Set up the initial infile
        Print #1, "begin mrbayes;"

        Print #1, "set autoclose=yes nowarn=yes;"
        'need to set up code to change the model
        TS = "lset nst="
        If TBModel > 2 Then TBModel = 0
        If TBModel = 0 Then
            TS = TS & "1"
        ElseIf TBModel = 1 Then
            TS = TS & "2"
        ElseIf TBModel = 2 Then
            TS = TS & "6"
        End If
        TS = TS + " rates="
        If TBGamma = 0 Then
             TS = TS + "equal"
        ElseIf TBGamma = 1 Then
            TS = TS + "gamma"
        ElseIf TBGamma = 2 Then
            TS = TS + "adgamma"
        End If
        If TBGamma > 0 Then
            TS = TS + " ngammacat=" + Trim(Str(CLng(TBGammaCats)))
        End If
        
        TS = TS + ";"
        Print #1, TS
        
        
        'clock models:
        'Non-Clock (default):
        '           prset brlenspr=unconstrained:exponential(1) if you want to change from the deafult prior = exp(10)
        'Birth death:
        '           prset speciationpr = X
        '           prset extinctionpr = X
        '           prset sampleprob = X
        
        'Coalescent Model:
        '           prest thetapr = X (prior on thrta)
        '           lset ploidy = Y (1 or 2)
        'Simple clock model:
        '           prset brlenspr=clock:uniform
        '           prset treeheightpr = X (prior on total tree height default=1)
        
        'need to set up code to change the MCMC settings
        TS = "mcmc ngen=" & Trim(Str(TBNGens))
        TS = TS + " samplefreq=" + Trim(Str(TBSampFreq))
        TS = TS + " nchains=" + Trim(Str(TBNChains))
        TS = TS + " temp=" + Trim(Str(TBTemp))
        TS = TS + " swapfreq=" + Trim(Str(TBSwapFreq))
        TS = TS + " nswaps=" + Trim(Str(TBSwapNum))
        'Print #1, "mcmc ngen=10000 samplefreq=10 savebrlens=yes file=outfile;"
        If SR = 1 Then
            TS = TS + " stoprule=yes stopval=0.01 savebrlens=yes file=outfile;"
        Else
            TS = TS + " stoprule=no savebrlens=yes file=outfile;"
        End If
        Print #1, TS
        'get a tree output file - its in fucking nex format!
        bi = ((TBNGens * 0.25) / TBSampFreq)
        
        Print #1, "sumt burnin=" + Trim(Str(bi)) + ";"
        
        Print #1, "end;"
        
        Close #1
        
        PBStart = Form1.ProgressBar1.Value
        PBTarget = 100
        Form1.SSPanel1.Caption = "Drawing Bayesian Tree (With MrBayes)"
        Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
        BatIndex = 25

End Sub
Public Sub UpdateTimeCaps(ET, SAll)
Dim XXY As Variant, XXT As Variant
If DebuggingFlag < 2 Then On Error Resume Next
ET = Abs(ET)
SAll = Abs(SAll)
XXT = Abs(ET - SAll)


Form1.Label50(0).Caption = DoTimeII((XXT * Abs(TimeFract(0))) + MethodTime(0))

Form1.Label50(2).Caption = DoTimeII(XXT * Abs(TimeFract(1)) + MethodTime(1))
Form1.Label50(4).Caption = DoTimeII(XXT * Abs(TimeFract(2)) + MethodTime(2))
Form1.Label50(6).Caption = DoTimeII(XXT * Abs(TimeFract(3)) + MethodTime(3))
Form1.Label50(8).Caption = DoTimeII(XXT * TimeFract(4) + MethodTime(4))
Form1.Label50(10).Caption = DoTimeII(XXT * TimeFract(5) + MethodTime(5))
XXY = XXT * TimeFract(8)
XXY = XXY + MethodTime(8)
Form1.Label50(14).Caption = DoTimeII(XXY)
On Error GoTo 0
End Sub
Public Sub ShrinkSequences()
'Open "test.csv" For Output As #1
'Exit Sub
    Dim StartVal As Double, TargetVal As Double, NF As Long, Temp As String, CurChar As String, NewSeqs() As String, Sublen As Long, TotNucs As Long, ProbNuc As Double, MissChar As Long, MustGo() As Byte, TotGo As Long, x As Long, Y As Long
    ReDim ABCons(Len(StrainSeq(0))), Decompress(Len(StrainSeq(0))), Recompress(Len(StrainSeq(0)))
    ReDim NewSeqs(NextNo)
    ReDim MustGo(Len(StrainSeq(0)))
    Dim SpaceCount As Long
    StartVal = Form1.ProgressBar1.Value
    TargetVal = StartVal + 25
    If TargetVal > 100 Then TargetVal = 100
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    If x = x Then 'faster much more space efficent way of doing this
        Dim MaxS As Long
        'find which sequence has the most spaces
        MaxS = 0
         
        For x = 0 To NextNo
            SS = Abs(GetTickCount)
            SpaceCount = 0
            LPos = 1
            Do
                Y = InStr(LPos, StrainSeq(x), "-", vbBinaryCompare)
                If Y > 0 Then
                    LPos = Y + 1
                    SpaceCount = SpaceCount + 1
                Else
                    Exit Do
                End If
            Loop
            If SpaceCount > MaxS Then MaxS = SpaceCount
            EE = Abs(GetTickCount)
            TT = EE - SS
            x = x
        Next x
        
        
        
        ReDim SeqSpacesTemp(NextNo, MaxS)
        For x = 0 To NextNo
            SS = Abs(GetTickCount)
            Form1.SSPanel1 = "Storing gap locations for sequence " + Trim(Str(x + 1)) + " out of " + Trim(Str(NextNo + 1))
            SpaceCount = 0
            LPos = 1
            Do
                Y = InStr(LPos, StrainSeq(x), "-", vbBinaryCompare)
                If Y > 0 Then
                    LPos = Y + 1
                    SpaceCount = SpaceCount + 1
                    SeqSpacesTemp(x, SpaceCount) = Y
                Else
                    Exit Do
                End If
            Loop
            
             
            EE = Abs(GetTickCount)
            TT = EE - SS
            x = x
        Next x
        SeqSpacesTempFlag = 2
    Else
    
        If Len(StrainSeq(0)) * NextNo < 10000000 Then ' there is enough space to store this in ram
            ReDim SeqSpacesTemp(Len(StrainSeq(0)), NextNo)
            For x = 0 To NextNo
                SpaceCount = 0
                StrainSeq(x) = UCase(StrainSeq(x))
                For Y = 1 To Len(StrainSeq(0))
                    If Mid$(StrainSeq(x), Y, 1) = "-" Then SpaceCount = SpaceCount + 1
                    SeqSpacesTemp(Y, x) = SpaceCount
                Next Y
                
            Next x
            SeqSpacesTempFlag = 1
        Else 'this needs to be written to disk
            
            
            Dim TVF As Long, LSF As Long
            FF = FreeFile
            LSF = Len(StrainSeq(0)) + 1
            Open "SSTF" + UFTag For Binary As #FF
            For x = 0 To NextNo
                Form1.SSPanel1 = "Storing gap locations for sequence " + Trim(Str(x + 1)) + " out of " + Trim(Str(NextNo + 1))
                SpaceCount = 0
                StrainSeq(x) = UCase(StrainSeq(x))
                For Y = 1 To Len(StrainSeq(0))
                    
                    If Mid$(StrainSeq(x), Y, 1) = "-" Then SpaceCount = SpaceCount + 1
                    TVF = SpaceCount
                    Z = LSF * x + Y
                    Put #FF, Z * 4, TVF
                    
                    'SeqSpacesTemp(Y, X) = SpaceCount
                Next Y
                x = x
            Next x
            Close #FF
            SeqSpacesTempFlag = 0
            x = x
        End If
    End If
    
    'Dim SeqSpacesTemp(Len(StrainSeq(0)), Nextno)
    
    
    
    'Save this alignment for use in any RDP files that ensue
    NF = FreeFile
    
    
    
    BIGFilename = "tempSeqx"
    Open BIGFilename For Output As #NF
    ReDim BigFileOffsets(NextNo, 1)
    For x = 0 To NextNo
        Print #NF, ">" + OriginalName(x)
        BigFileOffsets(x, 0) = LOF(NF) + 1
        BigFileOffsets(x, 1) = LOF(NF) + Len(StrainSeq(x)) + 1
        Print #NF, StrainSeq(x)
    Next x
    Close #NF
    'Make a column-by-column version of the sequences in a file
    
    Dim LongSeq As String, PosInString As Long
    NF = FreeFile
    Open "RDP5Longseq" + UFTag For Binary As #NF
    LongSeq = String(1000000, " ")
    PosInString = 0
    SS = Abs(GetTickCount)
    For Y = 1 To Len(StrainSeq(0))
        For x = 0 To NextNo
            PosInString = PosInString + 1
            Mid$(LongSeq, PosInString, 1) = Mid$(StrainSeq(x), Y, 1)
            If PosInString = 1000000 Then
            
                Put #NF, , LongSeq
                LongSeq = String(1000000, " ")
                PosInString = 0
            End If
        Next x
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 1000 Then
            SS = EE
            Form1.SSPanel1.Caption = "Reordering and resaving " + Trim(Str(Y)) + " of " + Trim(Str(Len(StrainSeq(0)))) + " alignment columns"
            Form1.ProgressBar1.Value = StartVal + (Y / Len(StrainSeq(0))) * (TargetVal = StartVal)
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        'If Y / 1000 = CLng(Y / 1000) Then
        '    Form1.SSPanel1 = "Rearranging " + Trim(Str(Y)) + " out of " + Trim(Str(Len(StrainSeq(0)))) + " alignment columns"
        'End If
    Next Y
    
    StartVal = Form1.ProgressBar1.Value
    TargetVal = StartVal + 5
    If TargetVal > 100 Then TargetVal = 100
    
    If PosInString > 0 Then
        Put #NF, , LongSeq
    End If
    LongSeq = String(100000, "X")
    Put #NF, , LongSeq
    Close #NF
    LongSeq = String(1, " ")
    
    
    ChDrive oDir
    ChDir oDir
    
    
    Dim TempByte As Byte, CurCharByte As Byte
    
    'work out the length of the subsequence
    
    'XX = StrainSeq(0)
    For Z = 0 To NextNo
        StrainSeq(Z) = UCase(StrainSeq(Z))
    Next Z
    
    x = 1
    LastPos = 1
    Sublen = 0
    TotGo = 0
    SSX = Abs(GetTickCount)
    Do While x <= Len(StrainSeq(0))
        'XX = right$(StrainSeq(10), 20)
        TempByte = 0
        MissChar = 0
        GoOn = 0
        GoOnX = 0
        For Y = 0 To NextNo
            'CurCharByte = Asc(Mid$(StrainSeq(Y), X, 1)) 'GTTCATAATATTC
            CurChar = Mid$(StrainSeq(Y), x, 1)
            CurCharByte = Asc(CurChar) 'GTTCATAATATTC
            If CurCharByte = 65 Then
                
                GoOn = GoOn + 1
                
                If TempByte = 0 Then
                    TempByte = CurCharByte
                Else
                    If TempByte <> CurCharByte Then
                        If GoOnX = 0 Then
                            Sublen = Sublen + 1
                            GoOnX = GoOnX + 1
                            If GoOn > 3 Then Exit For
                        End If
                    End If
                    
                End If
        
        
                If GoOnX = 1 Then
                    If GoOn > 3 Then
                        Exit For
                    End If
                End If
                
            ElseIf CurCharByte = 67 Then
                
                GoOn = GoOn + 1
                
                If TempByte = 0 Then
                
                    TempByte = CurCharByte
                Else
                
                    If TempByte <> CurCharByte Then
                        If GoOnX = 0 Then
                            Sublen = Sublen + 1
                            GoOnX = GoOnX + 1
                            If GoOn > 3 Then Exit For
                        End If
                    End If
                    
                End If
        
        
                If GoOnX = 1 Then
                    If GoOn > 3 Then
                        Exit For
                    End If
                End If
            ElseIf CurCharByte = 71 Then
                
                GoOn = GoOn + 1
                
                If TempByte = 0 Then
                    TempByte = CurCharByte
                Else
                    If TempByte <> CurCharByte Then
                        If GoOnX = 0 Then
                            Sublen = Sublen + 1
                            GoOnX = GoOnX + 1
                            If GoOn > 3 Then Exit For
                        End If
                    End If
                    
                End If
        
        
                If GoOnX = 1 Then
                    If GoOn > 3 Then
                        Exit For
                    End If
                End If
            ElseIf CurCharByte = 84 Then
                
                GoOn = GoOn + 1
                
                If TempByte = 0 Then
                    TempByte = CurCharByte
                Else
                    If TempByte <> CurCharByte Then
                        If GoOnX = 0 Then
                            Sublen = Sublen + 1
                            GoOnX = GoOnX + 1
                            If GoOn > 3 Then Exit For
                        End If
                    End If
                    
                End If
        
        
                If GoOnX = 1 Then
                    If GoOn > 3 Then
                        Exit For
                    End If
                End If
                  
            Else
                MissChar = MissChar + 1
                
            End If
        Next Y
        
        If Y = NextNo + 1 Then  'i.e. every sequence with a nt is identical and there are no missing nts
            If MissChar = 0 Then
                ABCons(x) = TempByte
            End If
        End If
        
        If NextNo > 3 Then
            If (NextNo + 1) - MissChar < 4 Then
                MustGo(x) = 1 '5550,5551,5552
                TotGo = TotGo + 1
            End If
        ElseIf NextNo = 3 Then
            If (NextNo + 1) - MissChar < 3 Then
                MustGo(x) = 1 '5550,5551,5552
                TotGo = TotGo + 1
            End If
        
        End If
        
        
        
        
        
        
        
        x = x + 1
        SS = Abs(GetTickCount)
        
        If Abs(SS - EE) > 1000 Then
            EE = SS
            Form1.SSPanel1.Caption = "Alignment compression " + Trim(Str(CLng(x / Len(StrainSeq(0)) * 90))) + "% complete"
            Form1.Refresh
        End If
    Loop
    
    eex = Abs(GetTickCount)
    TT = eex - SSX '36.625,31.266,27.297,26.750'26.640, 24.51, 25.469
    
    
    'sublen = 190906 - 189770
    
    'totgo = 1948 - 1948
    
    
    
    Rnd (-BSRndNumSeed)
    'Close #1
    ' work out probability of selecting a nt
    TotNucs = Len(StrainSeq(0)) - Sublen
    If Sublen < 25000 Then
        ProbNuc = (50000 - Sublen) / TotNucs
    ElseIf Sublen < 50000 Then
        ProbNuc = (100000 - Sublen) / TotNucs
    ElseIf Sublen < 100000 Then
        ProbNuc = (200000 - Sublen) / TotNucs
    Else
        ProbNuc = 0 '0
    End If
    x = 1
    'totgo = 365452,
    For x = 0 To NextNo
        NewSeqs(x) = String(Sublen, " ")
    Next x
    x = 1
    Dim CXP As Long
    CXP = 0
    Do While x <= Len(StrainSeq(0))
        
        TempByte = 0
        Recompress(x) = CXP
        If x = 18 Then
            x = x
        End If
        If MustGo(x) = 0 Then
            
            If ABCons(x) = 0 Then
                invalidc = 0
                
                For Y = 0 To NextNo
                    
                    
                    CurCharByte = Asc(Mid$(StrainSeq(Y), x, 1))
                    
                    If CurCharByte = 65 Then
                        
                            'If CurCharByte <> "n" Then
                        
                                If TempByte = 0 Then
                                    TempByte = CurCharByte
                                Else
                                    If TempByte <> CurCharByte Then
                                        CXP = CXP + 1
                                        
                                         If CXP > Len(NewSeqs(0)) Then
                                            For ZZ = 0 To NextNo
                                                   NewSeqs(ZZ) = NewSeqs(ZZ) + String(Sublen, " ")
                                            Next ZZ
                                         End If
                                        
                                        For Z = 0 To NextNo
                                            CurChar = Mid$(StrainSeq(Z), x, 1)
                                            Mid$(NewSeqs(Z), CXP, 1) = CurChar
                                           
                                            
                                        Next Z
                                        Decompress(CXP) = x
                                        Recompress(x) = CXP
                                        Exit For
                                    End If
                                End If
                            'Else
                            '    invalidc = invalidc + 1
                            'End If
                       
                    ElseIf CurCharByte = 67 Then
                        
                            'If CurCharByte <> "n" Then
                        
                                If TempByte = 0 Then
                                    TempByte = CurCharByte
                                Else
                                    If TempByte <> CurCharByte Then
                                        CXP = CXP + 1
                                        If CXP > Len(NewSeqs(0)) Then
                                            For ZZ = 0 To NextNo
                                                   NewSeqs(ZZ) = NewSeqs(ZZ) + String(Sublen, " ")
                                            Next ZZ
                                         End If
                                        For Z = 0 To NextNo
                                            CurChar = Mid$(StrainSeq(Z), x, 1)
                                            Mid$(NewSeqs(Z), CXP, 1) = CurChar
                                        Next Z
                                        Decompress(CXP) = x
                                        Recompress(x) = CXP
                                        Exit For
                                    End If
                                End If
                            'Else
                            '    invalidc = invalidc + 1
                            'End If
                        
                    ElseIf CurCharByte = 71 Then
                        
                            'If CurCharByte <> "n" Then
                        
                                If TempByte = 0 Then
                                    TempByte = CurCharByte
                                Else
                                    If TempByte <> CurCharByte Then
                                        CXP = CXP + 1
                                        If CXP > Len(NewSeqs(0)) Then
                                            For ZZ = 0 To NextNo
                                                   NewSeqs(ZZ) = NewSeqs(ZZ) + String(Sublen, " ")
                                            Next ZZ
                                         End If
                                        For Z = 0 To NextNo
                                            CurChar = Mid$(StrainSeq(Z), x, 1)
                                            Mid$(NewSeqs(Z), CXP, 1) = CurChar
                                        Next Z
                                        Decompress(CXP) = x
                                        Recompress(x) = CXP
                                        Exit For
                                    End If
                                End If
                            'Else
                            '    invalidc = invalidc + 1
                            'End If
                        
                    ElseIf CurCharByte = 84 Then
                        
                            'If CurCharByte <> "n" Then
                        
                                If TempByte = 0 Then
                                    TempByte = CurCharByte
                                Else
                                    If TempByte <> CurCharByte Then
                                        CXP = CXP + 1
                                        If CXP > Len(NewSeqs(0)) Then
                                            For ZZ = 0 To NextNo
                                                   NewSeqs(ZZ) = NewSeqs(ZZ) + String(Sublen, " ")
                                            Next ZZ
                                         End If
                                        For Z = 0 To NextNo
                                            CurChar = Mid$(StrainSeq(Z), x, 1)
                                            Mid$(NewSeqs(Z), CXP, 1) = CurChar
                                        Next Z
                                        Decompress(CXP) = x
                                        Recompress(x) = CXP
                                        Exit For
                                    End If
                                End If
                            'Else
                            '    invalidc = invalidc + 1
                            'End If
                       
                    
                    Else
                        invalidc = invalidc + 1
                    End If
                Next Y
            Else
            
                'i.e. every sequence with a nt is identical and there are no missing nts
                
                    If ProbNuc > 0 Then
                        rndno = Int((32000 * Rnd) + 1)
                        rndno = rndno / 32000
                        If rndno < ProbNuc Then
                            CXP = CXP + 1
                            If CXP > Len(NewSeqs(0)) Then
                               For ZZ = 0 To NextNo
                                      NewSeqs(ZZ) = NewSeqs(ZZ) + String(Sublen, " ")
                               Next ZZ
                            End If
                            For Z = 0 To NextNo
                                CurChar = Mid$(StrainSeq(Z), x, 1)
                                Mid$(NewSeqs(Z), CXP, 1) = CurChar
                                Decompress(CXP) = x
                                Recompress(x) = CXP
                            Next Z
                            ABCons(x) = 0
                        
                        End If
                   
                    End If

            End If
        End If
        x = x + 1
        SS = Abs(GetTickCount)
        If Abs(SS - EE) > 1000 Then
            EE = SS
            Form1.SSPanel1.Caption = "Alignment compression " + Trim(Str(90 + CLng(x / Len(StrainSeq(0)) * 5))) + "% complete"
            Form1.ProgressBar1.Value = StartVal + (x / Len(StrainSeq(0))) * (TargetVal - StartVal)
            Call UpdateF2Prog
            Form1.Refresh
        End If
    Loop
    eex = Abs(GetTickCount)
    TT = eex - SSX '38.61,21.453,25.562, 26.735, 25.610, 24.782, 1.859
    x = x
    'target = 190903
    
    For x = 0 To NextNo
        XX = Len(NewSeqs(x))
        StrainSeq(x) = Trim(NewSeqs(x))
        x = x
    Next x
    Decompress(Len(StrainSeq(0))) = UBound(Decompress, 1)
    'totgo=1948
    '190903
    ReDim Preserve Decompress(Len(StrainSeq(0)))
    
    
    
    
x = x
End Sub


Public Sub ShrinkSequences2()
'Open "test.csv" For Output As #1
'Exit Sub



    Dim FF3 As Long, StartVal As Double, TargetVal As Double, NF As Long, Temp As String, CurChar As String, NewSeqs() As String, Sublen As Long, TotNucs As Long, ProbNuc As Double, MissChar As Long, MustGo() As Byte, TotGo As Long, x As Long, Y As Long
    ReDim ABCons(Len(StrainSeq(0))), Decompress(Len(StrainSeq(0))), Recompress(Len(StrainSeq(0)))
    ReDim NewSeqs(NextNo)
    ReDim MustGo(Len(StrainSeq(0)))
    Dim SpaceCount As Long, oCRF As Long
    
    oCRF = CurrentlyRunningFlag
    CurrentlyRunningFlag = 1
    StartVal = Form1.ProgressBar1.Value
    Form1.SSPanel1.Caption = "Reordering sequences"
    TargetVal = StartVal + 25
    If TargetVal > 100 Then TargetVal = 100
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SequencesForSaving" + UFTag For Binary As #FF '1
    If x = x Then 'faster much more space efficent way of doing this
        Dim MaxS As Long
        'find which sequence has the most spaces and identify sites that differ from seq0
        Dim Identical0() As Byte
        ReDim Identical0(Len(StrainSeq(0)))
        MaxS = 0
        
        Form1.SSPanel1.Caption = "Identifying variable sites"
        
        'Input #FF, StrainSeq(0)
        'XX = Len(StrainSeq(0))
        'ODirX = CurDir
         Dim TempBig As String, CountVSites As Long
        CountVSites = 0
        SSX = Abs(GetTickCount)
        For x = 0 To NextNo
            If x > 0 Then
                TempBig = String(Len(StrainSeq(0)), " ")
                
                Get #FF, , TempBig
                'Close #1
                'If X = X Then
                '@
                    CountVSites = MakeIdentical02(Len(StrainSeq(0)), CountVSites, Identical0(0), StrainSeq(0), TempBig)
                
                    '2810712
                    '522599
                    'X = X
'                Else
'                    For Y = 1 To Len(StrainSeq(0))
'                        'If Identical0(Y) = 0 Then
'                            If Mid$(StrainSeq(0), Y, 1) <> Mid$(TempBig, Y, 1) Then
'                                If Identical0(Y) = 0 Then
'                                    CountVSites = CountVSites + 1
'                                    Identical0(Y) = 1
'                                End If
'
'                            End If
'
'                        'End If
'                    Next Y
'                End If
                x = x
            Else
                TempBig = StrainSeq(0)
                
            End If
            SpaceCount = 0
            LPos = 1
            '@
            Do
                Y = InStr(LPos, TempBig, "-", vbBinaryCompare)
                If Y > 0 Then
                    LPos = Y + 1
                    SpaceCount = SpaceCount + 1
                Else
                    Exit Do
                End If
            Loop
            If SpaceCount > MaxS Then MaxS = SpaceCount
            EE = Abs(GetTickCount)
            If Abs(EE - SS) > 2000 Then
                SS = EE
                Form1.SSPanel1.Caption = Trim(Str(CountVSites)) + " variable sites detected in " + Trim(Str(x)) + " sequences"
                Form1.ProgressBar1.Value = StartVal + (TargetVal - StartVal) * (x / NextNo)
                Call UpdateF2Prog
                Form1.SSPanel1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                DoEvents
            End If
        Next x
        'strip unwanted characters from tempbig
        
'        For Y = 1 To 255
'            If Y <> 45 And Y <> 65 And Y <> 71 And Y <> 84 And Y <> 67 Then
'                Pos = 1
'                Do While Pos > 0
'                    Pos = InStr(Pos, TempBig, Chr(Y), vbBinaryCompare)
'                    If Pos > 0 Then
'                        Mid$(TempBig, Pos, 1) = "-"
'                    Else
'                        Exit Do
'                    End If
'                Loop
'            End If
'        Next
        
        x = x
        
        
'        For X = 0 To Len(StrainSeq(0))
'            If Identical0(X) <> 0 Then
'                X = X
'            End If
'        Next X
        
        eex = Abs(GetTickCount)
        TT = eex - SSX '251.396'252.646 with windowstate updates every second'9.095 seconds with main loop in C++
        
        'store gap locations
        
        SS = Abs(GetTickCount)
        Dim FF4 As Long
        If MaxS > 0 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF3 = FreeFile
            'XX = FF3 '2
            Open "SequencesForSaving" + UFTag For Binary As #FF3
            FF4 = FreeFile
            Open "RDP5GapLocations" + UFTag For Binary As FF4
            Put #FF4, , MaxS
            For x = 0 To NextNo
                ReDim SeqSpacesTemp(MaxS)
                EE = Abs(GetTickCount)
                If Abs(EE - SS) > 1000 Then
                    SS = EE
                    Form1.SSPanel1 = "Storing gap locations for sequence " + Trim(Str(x + 1)) + " out of " + Trim(Str(NextNo + 1))
                    DoEvents
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
                If x > 0 Then
                '@
                    TempBig = String(Len(StrainSeq(0)), " ")
                    Get #FF3, , TempBig
                    
                Else
                    TempBig = StrainSeq(0)
                    
                End If
                SpaceCount = 0
                LPos = 1
                Do
                    '@
                    Y = InStr(LPos, TempBig, "-", vbBinaryCompare)
                    If Y > 0 Then
                        LPos = Y + 1
                        SpaceCount = SpaceCount + 1
                        SeqSpacesTemp(SpaceCount) = Y
                    Else
                        Exit Do
                    End If
                Loop
                
                Put #FF4, , SeqSpacesTemp()
                EE = Abs(GetTickCount)
                TT = EE - SS
                x = x
            Next x
            SeqSpacesTempFlag = 4 'this indicates that the gaplocation info is stored on disk and must be read back using decompressed seq coordinates
            'SeqSpacesInFileFlag = 1
            ChDrive oDirX
            ChDir oDirX
            'XX = FF3'2
            Close #FF3
            Close #FF4
        End If
    
        
    End If
   ' XX = FF'1
    Close #FF
    'Dim SeqSpacesTemp(Len(StrainSeq(0)), Nextno)
    
    
    
    'Save this alignment for use in any RDP files that ensue
    NF = FreeFile
    
    
    FF = FreeFile
    BIGFilename = "tempSeqx"
    Open BIGFilename For Output As #NF '1
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SequencesForSaving" + UFTag For Binary As #FF '2
    
    ReDim BigFileOffsets(NextNo, 1)
    For x = 0 To NextNo
    '@
        If x > 0 Then
            TempBig = String(Len(StrainSeq(0)), " ")
            Get #FF, , TempBig
        Else
            TempBig = StrainSeq(0)
        End If
        Print #NF, ">" + OriginalName(x)
        BigFileOffsets(x, 0) = LOF(NF) + 1
        BigFileOffsets(x, 1) = LOF(NF) + Len(TempBig) + 1
        '@
        Print #NF, TempBig
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 1000 Then
            SS = EE
            Form1.SSPanel1.Caption = "Resaving " + Trim(Str(x + 1)) + " of " + Trim(Str(NextNo + 1)) + " sequences"
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            DoEvents
        End If
    Next x
    
    ChDrive oDirX
    ChDir oDirX
    'XX = NF
    Close #FF '2
    Close #NF '1
    'Make a column-by-column version of the sequences in a file
    
    
    Dim LongSeq As String, PosInString As Long
    NF = FreeFile
    Open "RDP5Longseq" + UFTag For Binary As #NF '1
    LongSeq = String(1000000, " ")
    PosInString = 0
    SS = Abs(GetTickCount)
    
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "SequencesForSaving" + UFTag For Binary As #FF '2
    
    Dim ReadPos As Long, LSeqX As Long
    LSeqX = Len(StrainSeq(0))
    TempBig = " "
    Dim NNum As Long, StringChars(255) As Byte, AddNuc() As String, StrainSeqSub() As String, LenStrainSeqSub As Long
    ReDim StrainSeqSub(NextNo), AddNuc(NextNo)
    
    For x = 0 To NextNo
        StrainSeqSub(x) = String(10000, " ")
    Next x
    
    StartVal = Form1.ProgressBar1.Value
    TargetVal = StartVal + 2
    '@
    Dim TB As String, ZZ As Long
    Dim TSubSeq As String
    SSS = Abs(GetTickCount)
    Dim RecompressX() As Long, RecompressX2() As Long, Z2 As Long
    ReDim RecompressX(Len(StrainSeq(0))), RecompressX2(Len(StrainSeq(0)))
    
    Z = 0
    Z2 = 0
    For Y = 1 To Len(StrainSeq(0))
        RecompressX(Y) = Z
        If Identical0(Y) = 1 Then
             Z = Z + 1
             RecompressX(Y) = Z
        End If
        RecompressX2(Y) = Z2
        If Identical0(Y) = 2 Then
             Z2 = Z2 + 1
             RecompressX2(Y) = Z2
        End If
        
    Next Y
   
    
    TempBig = " "
    SS = Abs(GetTickCount)
    Dim UBSN As Long
    UBSN = Z
    
    FF4 = FreeFile
    Dim SeqNum2() As Byte
    ReDim SeqNum2(Z2, NextNo)
    ReDim SeqNum(UBSN, NextNo)
    
    For x = 1 To NextNo
        
        TB = String(LSeqX, " ")
        ReadPos = 1 + LSeqX * (x - 1)
        Get #FF, ReadPos, TB
        TB = UCase(TB)
        For Y = 1 To Len(StrainSeq(0))
            If Identical0(Y) = 1 Then
                'ReadPos = Y + LSeqX * (X - 1)
                'Get #FF, ReadPos, TempBig
                TempBig = Mid$(TB, Y, 1)
                If TempBig = "A" Then
                    SeqNum(RecompressX(Y), x) = 65
                ElseIf TempBig = "C" Then
                    SeqNum(RecompressX(Y), x) = 67
                ElseIf TempBig = "G" Then
                    SeqNum(RecompressX(Y), x) = 71
                ElseIf TempBig = "T" Then
                    SeqNum(RecompressX(Y), x) = 84
                Else
                    SeqNum(RecompressX(Y), x) = 45
                End If
            ElseIf Identical0(Y) = 2 Then
                TempBig = Mid$(TB, Y, 1)
                If TempBig = "A" Then
                    SeqNum2(RecompressX2(Y), x) = 65
                ElseIf TempBig = "C" Then
                    SeqNum2(RecompressX2(Y), x) = 67
                ElseIf TempBig = "G" Then
                    SeqNum2(RecompressX2(Y), x) = 71
                ElseIf TempBig = "T" Then
                    SeqNum2(RecompressX2(Y), x) = 84
                Else
                    SeqNum2(RecompressX2(Y), x) = 45
                End If
            End If
        Next Y
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 1000 Then
            SS = EE
            Form1.SSPanel1.Caption = "Loading variable sites for " + Trim(Str(x)) + " of " + Trim(Str(NextNo)) + " sequences"
            Form1.ProgressBar1.Value = StartVal + (x / NextNo) * (TargetVal - StartVal)
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            DoEvents
        End If
    Next x
    StartVal = Form1.ProgressBar1.Value
    TargetVal = StartVal + 3
    'ZZ = 0
    StrainSeq(0) = UCase(StrainSeq(0))
    For Y = 1 To Len(StrainSeq(0))
        Recompress(Y) = LenStrainSeqSub
        StringChars(65) = 0: StringChars(67) = 0: StringChars(71) = 0: StringChars(84) = 0
        NNum = 0
        If Identical0(Y) <> 0 Then
            'ZZ = ZZ + 1
            '@
            For x = 0 To NextNo
                
                PosInString = PosInString + 1
                If Identical0(Y) = 1 Then
                    If x > 0 Then
                        
    '                        ReadPos = Y + LSeqX * (X - 1)
    '                        Get #FF, ReadPos, TempBig
                        '@'@'@'@'@'@'@'@'@
                        
                        If SeqNum(RecompressX(Y), x) = 65 Then
                            TempBig = "A"
                        ElseIf SeqNum(RecompressX(Y), x) = 67 Then
                            TempBig = "C"
                        ElseIf SeqNum(RecompressX(Y), x) = 71 Then
                            TempBig = "G"
                        ElseIf SeqNum(RecompressX(Y), x) = 84 Then
                            TempBig = "T"
                        Else
                            TempBig = "-"
                        End If
                    Else
                        TempBig = Mid$(StrainSeq(0), Y, 1)
                    End If
                Else
                    If x > 0 Then
                        
                        If SeqNum2(RecompressX2(Y), x) = 65 Then
                            TempBig = "A"
                        ElseIf SeqNum2(RecompressX2(Y), x) = 67 Then
                            TempBig = "C"
                        ElseIf SeqNum2(RecompressX2(Y), x) = 71 Then
                            TempBig = "G"
                        ElseIf SeqNum2(RecompressX2(Y), x) = 84 Then
                            TempBig = "T"
                        Else
                            TempBig = "-"
                        End If
                    Else
                        TempBig = Mid$(StrainSeq(0), Y, 1)
                    End If
                End If
                '@
                AddNuc(x) = TempBig
                '@'@'@'@'@'@'@'@'@'@'@'@'@
                If AddNuc(x) <> "A" And AddNuc(x) <> "C" And AddNuc(x) <> "G" And AddNuc(x) <> "T" Then
                    AddNuc(x) = "-"
                Else
                    
                    NNum = NNum + 1
                End If
                '@'@'@'@
                StringChars(Asc(AddNuc(x))) = 1
                '@'@'@
                Mid$(LongSeq, PosInString, 1) = AddNuc(x) 'Mid$(StrainSeq(X), Y, 1)
                '@
                If PosInString = 1000000 Then
                
                    Put #NF, , LongSeq
                    LongSeq = String(1000000, " ")
                    PosInString = 0
                End If
                'EE = Abs(GetTickCount)
                
            Next x
        Else
            PosInString = PosInString + 1
            TempBig = Mid$(StrainSeq(0), Y, 1)
            
            AddNuc(0) = TempBig
            StringChars(Asc(AddNuc(0))) = 1
            If AddNuc(0) <> "A" And AddNuc(0) <> "C" And AddNuc(0) <> "G" And AddNuc(0) <> "T" Then
                AddNuc(0) = "-"
            Else
                NNum = NextNo + 1
            End If
            '@
            
            If (PosInString + NextNo + 1) > 1000000 Then
                LongSeq = LongSeq + String(NextNo + 1, " ")
                Mid(LongSeq, PosInString, NextNo + 1) = String(NextNo + 1, AddNuc(0))
                LongSeq = Trim(LongSeq)
                'XX = Len(LongSeq)
            Else
                Mid(LongSeq, PosInString, NextNo + 1) = String(NextNo + 1, AddNuc(0))
            End If
            
            
            
            PosInString = PosInString + NextNo
            If PosInString > 1000000 Then
                '@
                Put #NF, , LongSeq
                LongSeq = String(1000000, " ")
                PosInString = 0
            End If
        End If

    
        
        ABCons(Y) = 0
        
        If StringChars(65) + StringChars(67) + StringChars(71) + StringChars(84) > 1 And (NNum > 3 Or (NextNo = NNum)) And Identical0(Y) = 1 Then
'                If Identical0(Y) <> 1 Then
'                    x = x
'                End If
            LenStrainSeqSub = LenStrainSeqSub + 1
            If LenStrainSeqSub > Len(StrainSeqSub(0)) Then
                '@'@'@
                TSubSeq = String(Len(StrainSeqSub(0)) + 10000, " ")
                '@
                For x = 0 To NextNo
                    Mid(TSubSeq, 1, Len(StrainSeqSub(x))) = StrainSeqSub(x)
                    StrainSeqSub(x) = TSubSeq 'StrainSeqSub(x) + String(10000, " ")
                    
                Next x
            End If
            '@'@
            For x = 0 To NextNo
                Mid(StrainSeqSub(x), LenStrainSeqSub, 1) = AddNuc(x)
            Next x
            Decompress(LenStrainSeqSub) = Y
            Recompress(Y) = LenStrainSeqSub
        ElseIf StringChars(65) + StringChars(67) + StringChars(71) + StringChars(84) = 1 And NNum = NextNo + 1 Then
            XX = Identical0(Y)
            If StringChars(65) = 1 Then
                ABCons(Y) = 65
            ElseIf StringChars(67) = 1 Then
                ABCons(Y) = 67
            ElseIf StringChars(71) = 1 Then
                ABCons(Y) = 71
            ElseIf StringChars(84) = 1 Then
                ABCons(Y) = 84
            End If
            ''Decompress(LenStrainSeqSub) = Y
        Else
        
        End If
        '@
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 1000 Then
            SS = EE
            Form1.SSPanel1.Caption = "Reordering and resaving " + Trim(Str(Y)) + " of " + Trim(Str(LSeqX)) + " alignment columns"
            Form1.ProgressBar1.Value = StartVal + (Y / Len(StrainSeq(0))) * (TargetVal - StartVal)
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            DoEvents
        End If

        'If Y / 1000 = CLng(Y / 1000) Then
        '    Form1.SSPanel1 = "Rearranging " + Trim(Str(Y)) + " out of " + Trim(Str(Len(StrainSeq(0)))) + " alignment columns"
        'End If
    
    Next Y
    
    
    EEE = Abs(GetTickCount)
    ttt = EEE - SSS
    '1785 seconds
    '41
    LongSeq = Trim(LongSeq)
    If Len(LongSeq) > 0 Then
        Put #NF, , LongSeq
        LongSeq = ""
        PosInString = 0
    End If
    
    ChDrive oDirX
    ChDir oDirX
    'XX = FF
    Close #FF '2
    Rnd (-BSRndNumSeed)
    
    'target = 190903
    Close #NF
    For x = 0 To NextNo
        
        StrainSeq(x) = Trim(StrainSeqSub(x))
        
    Next x
'    'pad the ends with 4 nts
'    For X = 0 To Nextno
'        StrainSeq(X) = StrainSeq(X) + "----"
'    Next X
    
    
    Decompress(Len(StrainSeq(0))) = UBound(Decompress, 1)
    'totgo=1948
    '190903
    ReDim Preserve Decompress(Len(StrainSeq(0)))
    
    
    
    
 CurrentlyRunningFlag = oCRF
End Sub
Public Sub ShrinkSequencesB()
'Open "test.csv" For Output As #1
'Exit Sub
    Dim NF As Long, Temp As String, CurChar As String, NewSeqs() As String, Sublen As Long, TotNucs As Long, ProbNuc As Double, MissChar As Long, MustGo() As Byte, TotGo As Long
    ReDim ABCons(Len(StrainSeq(0))), Decompress(Len(StrainSeq(0))), Recompress(Len(StrainSeq(0)))
    ReDim NewSeqs(NextNo)
    ReDim MustGo(Len(StrainSeq(0)))
    Dim SpaceCount As Long
    ReDim SeqSpacesTemp(Len(StrainSeq(0)), NextNo)
    For x = 0 To NextNo
        SpaceCount = 0
        StrainSeq(x) = UCase(StrainSeq(x))
        For Y = 1 To Len(StrainSeq(0))
            If Mid$(StrainSeq(x), Y, 1) = "-" Then SpaceCount = SpaceCount + 1
            SeqSpacesTemp(Y, x) = SpaceCount
        Next Y
        
    Next x
    
    'Dim SeqSpacesTemp(Len(StrainSeq(0)), Nextno)
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    'Save this alignment for use in any RDP files that ensue
    NF = FreeFile
    
    
    
    BIGFilename = "tempSeqx"
    Open BIGFilename For Output As #NF
    For x = 0 To NextNo
        Print #1, ">" + OriginalName(x)
        Print #1, StrainSeq(x)
    Next x
    Close #1
    'Make a column-by-column version of the sequences in a file
    
    Dim LongSeq As String, PosInString As Long
    NF = FreeFile
    Open "RDP5Longseq" + UFTag For Binary As #NF
    LongSeq = String(1000000, " ")
    PosInString = 0
    SS = Abs(GetTickCount)
    For Y = 1 To Len(StrainSeq(0))
        For x = 0 To NextNo
PosInString = PosInString + 1
            Mid$(LongSeq, PosInString, 1) = Mid$(StrainSeq(x), Y, 1)
            If PosInString = 1000000 Then
                Put #NF, , LongSeq
                LongSeq = String(1000000, " ")
                PosInString = 0
            End If
        Next x
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 1000 Then
            SS = EE
            Form1.SSPanel1.Caption = "Reordering and resaving " + Trim(Str(Y)) + " of " + Trim(Str(Len(StrainSeq(0)))) + " alignment columns"
            Form1.ProgressBar1.Value = 50 + (Y / Len(StrainSeq(0))) * 25
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            'DoEvents
        End If
    Next Y
    If PosInString > 0 Then
        Put #NF, , LongSeq
    End If
    LongSeq = String(100000, "X")
    Put #NF, , LongSeq
    Close #NF
    LongSeq = String(1, " ")
    
    
    ChDrive oDir
    ChDir oDir
    
    x = 1
    
    
    SSX = Abs(GetTickCount)
    LastPos = 1
    'work out the length of the subsequence
    Sublen = 0
    TotGo = 0
    XX = StrainSeq(0)
    Do While x <= Len(StrainSeq(0))
        'XX = right$(StrainSeq(10), 20)
        Temp = ""
        MissChar = 0
        GoOn = 0
        GoOnX = 0
        For Y = 0 To NextNo
            CurChar = Mid$(StrainSeq(Y), x, 1) 'GTTCATAATATTC
            If CurChar <> "-" And CurChar <> "n" And CurChar <> "N" Then
                GoOn = GoOn + 1
                If Temp = "" Then
                    Temp = CurChar
                Else
                    If Temp <> CurChar Then
                            If GoOnX = 0 Then
                                Sublen = Sublen + 1
                                GoOnX = GoOnX + 1
                            End If
                    End If
                End If
                
                If GoOn > 3 And GoOnX = 1 Then
                    Exit For
                End If
            Else
                MissChar = MissChar + 1
                
            End If
        Next Y
        
        If ((NextNo + 1) - MissChar < 3 And NextNo = 3) Or ((NextNo + 1) - MissChar < 4 And NextNo > 3) Then
            MustGo(x) = 1 '5550,5551,5552
            TotGo = TotGo + 1
           
        
        End If
        
        x = x + 1
        SS = Abs(GetTickCount)
        If Abs(SS - EE) > 500 Then
            EE = SS
            Form1.SSPanel1.Caption = "Alignment compression " + Trim(Str(CLng(x / Len(StrainSeq(0)) * 50))) + "% complete"
            Form1.Refresh
        End If
    Loop
    'Close #1
    ' work out probability of selecting a nt
    
    
    eex = Abs(GetTickCount)
    TT = eex - SSX
    x = x
    
    SSX = Abs(GetTickCount)
    'sublen = 190906
    'totgo = 1948
    
    TotNucs = Len(StrainSeq(0)) - Sublen
    If Sublen < 25000 Then
        ProbNuc = (50000 - Sublen) / TotNucs
    ElseIf Sublen < 50000 Then
        ProbNuc = (100000 - Sublen) / TotNucs
    ElseIf Sublen < 100000 Then
        ProbNuc = (200000 - Sublen) / TotNucs
    Else
        ProbNuc = 0 '0
    End If
   
    'totgo = 365452,
    For x = 0 To NextNo
        NewSeqs(x) = String(Len(StrainSeq(0)) - TotGo, " ")
    Next x
     x = 1
    Dim CXP As Long
    CXP = 0
    
    Rnd (-BSRndNumSeed)
    Do While x <= Len(StrainSeq(0))
        
        Temp = ""
        Recompress(x) = CXP
        If MustGo(x) = 0 Then
            invalidc = 0
            For Y = 0 To NextNo
                CurChar = Mid$(StrainSeq(Y), x, 1)
                If CurChar <> "-" And CurChar <> "n" And CurChar <> "N" Then
                    If Temp = "" Then
                        Temp = CurChar
                    Else
                        If Temp <> CurChar Then
                            CXP = CXP + 1
                            For Z = 0 To NextNo
                                CurChar = Mid$(StrainSeq(Z), x, 1)
                                Mid$(NewSeqs(Z), CXP, 1) = CurChar
                            Next Z
                            Decompress(CXP) = x
                            Recompress(x) = CXP
                            Exit For
                        End If
                    End If
                Else
                    invalidc = invalidc + 1
                End If
            Next Y
            If Y = NextNo + 1 And invalidc = 0 Then 'i.e. every sequence with a nt is identical and there are no missing nts
                
                If ProbNuc > 0 Then
                    rndno = Int((32000 * Rnd) + 1)
                    rndno = rndno / 32000
                    If rndno < ProbNuc Then
                        CXP = CXP + 1
                        For Z = 0 To NextNo
                            CurChar = Mid$(StrainSeq(Z), x, 1)
                            Mid$(NewSeqs(Z), CXP, 1) = CurChar
                            Decompress(CXP) = x
                            Recompress(x) = CXP
                        Next Z
                        
                    Else
                        ABCons(x) = Asc(Temp)
                    End If
                Else
                    ABCons(x) = Asc(Temp)
                End If
            End If
        End If
        x = x + 1
        SS = Abs(GetTickCount)
        If Abs(SS - EE) > 500 Then
            EE = SS
            Form1.SSPanel1.Caption = "Alignment compression " + Trim(Str(50 + CLng(x / Len(StrainSeq(0)) * 50))) + "% complete"
            Form1.ProgressBar1.Value = 75 + (x / Len(StrainSeq(0))) * 25
            Call UpdateF2Prog
            Form1.Refresh
        End If
    Loop
     eex = Abs(GetTickCount)
    TT = eex - SSX
    x = x
    'XX = TotGo
    'totgo=1948
    SSX = Abs(GetTickCount)
    
    For x = 0 To NextNo
        StrainSeq(x) = Trim(NewSeqs(x))
    Next x
    Decompress(Len(StrainSeq(0))) = UBound(Decompress, 1)
    
    ReDim Preserve Decompress(Len(StrainSeq(0)))
End Sub
    
Public Sub OverlayMatrices()
Dim WeightFactor() As Double, NumFiles As Long, LastSeq As Long, CurSeq As Long, SeqName As String, SpcX As Long, FNum As Long, LoadFile As String, FL As Long, Temp As String, LineString As String, NPos As Long, Mpos As Long, Join As Long, SLen As Long, WorkMat() As Double, SPaceArray() As Long, SpeciesMat() As Double

ReDim WeightFactor(NextNo)




For x = 0 To NextNo
    For Y = 0 To NextNo
        WeightFactor(x) = WeightFactor(x) + (1 - Distance(x, Y))
    Next Y
Next x

If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If

ReDim SPaceArray(Len(StrainSeq(0)), NextNo)
For x = 0 To NextNo
    SpcX = 0
    Pos = 0
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 60 Then
           Pos = Pos + 1
        End If
        SPaceArray(Pos, x) = Y
    Next Y
Next x




LoadFile = SSFoldFile
SSFoldFile = Left$(SSFoldFile, Len(SSFoldFile) - 3)

FNum = 0
'find out how many files there are that need to be overlaid.
ReDim SpeciesMat(Len(StrainSeq(0)), Len(StrainSeq(0)))
LastSeq = -1
Do
    
    FL = 0
    If DebuggingFlag < 2 Then On Error Resume Next
    Open LoadFile For Input As #1
    FL = LOF(1)
    If FL = 0 Then
        Close #1
        Exit Do
    End If
    On Error GoTo 0
    Input #1, Temp
    NPos = InStr(1, Temp, Chr(9), vbBinaryCompare)
    SLen = val(Left(Temp, NPos - 1))
    LPos = InStr(1, Temp, Chr(10), vbBinaryCompare) + 1
    If LPos = 1 Then LPos = Len(Temp) + 1
    
    
    For x = LPos - 1 To 1 Step -1
        If Mid$(Temp, x, 1) = Chr(9) Then
            SeqName = Mid$(Temp, x + 1, LPos - x - 1)
            Exit For
        End If
    Next x
    If Right(SeqName, 1) = Chr(10) Then
        SeqName = Left(SeqName, Len(SeqName) - 1)
    End If
    For x = 0 To NextNo
        If OriginalName(x) = SeqName Then
            CurSeq = x
            Exit For
        End If
    Next x
    
    'if not new sequence then
    If CurSeq = LastSeq Then
        NumFiles = NumFiles + 1
    
    Else
        If NumFiles > 0 Then
            For x = 1 To Len(StrainSeq(0))
                For Y = 1 To Len(StrainSeq(0))
                      SpeciesMat(x, Y) = SpeciesMat(x, Y) + (WorkMat(x, Y) / NumFiles) * WeightFactor(LastSeq)
                Next Y
            Next x
        End If
        ReDim WorkMat(Len(StrainSeq(0)), Len(StrainSeq(0)))
        NumFiles = 1
    End If
    
    LastSeq = CurSeq
    
    For Y = 1 To SLen
        Pos = InStr(LPos, Temp, Chr(10), vbBinaryCompare)
        If Pos = 0 Then
            Input #1, LineString
            If Len(LineString) > Len(StrainSeq(0)) * 10 Then
                Temp = LineString
                LPos = 1
                Pos = InStr(1, Temp, Chr(10), vbBinaryCompare)
                LineString = Mid$(Temp, 1, Pos - LPos - 1)
            End If
        Else
            LineString = Mid$(Temp, LPos, Pos - LPos - 1)
        End If
        NPos = 0
        For x = 1 To 4
            NPos = InStr(NPos + 1, LineString, Chr(9), vbBinaryCompare)
            
        Next x
        Mpos = InStr(NPos + 1, LineString, Chr(9), vbBinaryCompare)
        Join = val(Mid$(LineString, NPos + 1, Mpos - NPos - 1))
        If Join > 0 Then
            A = SPaceArray(Join, CurSeq)
            b = SPaceArray(Y, CurSeq)
            WorkMat(A, b) = WorkMat(A, b) + 1
            WorkMat(A, b) = WorkMat(A, b) + 1
        End If
        LPos = Pos + 1
        
        x = x
    Next Y
    Close #1
    FNum = FNum + 1
    LoadFile = SSFoldFile + "_" + Trim(Str(FNum)) + ".ct"
    XX = Right(LoadFile, 20)
    x = x
Loop

Form6.ScaleMode = 3
Form6.Visible = True

Form6.Picture1.ScaleMode = 3
Form6.Picture1.Width = Len(StrainSeq(0))
Form6.Picture1.Height = Len(StrainSeq(0))
Form6.Picture1.AutoRedraw = True
Dim Max As Double, Pict As Long, ColX As Long
For x = 0 To Len(StrainSeq(0))
    For Y = 0 To Len(StrainSeq(0))
        If SpeciesMat(x, Y) > Max Then Max = SpeciesMat(x, Y)
    Next Y
Next x

For x = 0 To NextNo
    omax = omax + WeightFactor(x)
Next x
Pict = Form6.Picture1.hdc
For x = 1 To Len(StrainSeq(0))
    For Y = 1 To Len(StrainSeq(0))
        ColX = CLng((SpeciesMat(x, Y) / Max) * 1020)
        SetPixelV Pict, x, Y, HeatMap(0, ColX)
    Next Y
Next x

Form6.Picture1.Refresh

SavePicture Form6.Picture1.Image, "ssdna matrix2.bmp"
XX = CurDir
On Error GoTo 0
x = x
End Sub

Public Sub SelectionMod()



Dim NSites As Long, Max As Double, SFactor() As Double, RNum1 As Long, RNum2 As Long, RF As Double, Courseness As Long

Courseness = 1
NSites = (UBound(GPrint, 2) - 2) / 2

ReDim SFactor(NSites)
For x = 0 To 48
    SFactor(x) = GPrint(0, x) * 0
Next x
For x = 49 To 80
    SFactor(x) = GPrint(0, x) * 1
Next x
For x = 81 To 385
    SFactor(x) = GPrint(0, x) * 0.78
Next x
For x = 386 To 588
    SFactor(x) = GPrint(0, x) * 1
Next x
For x = 589 To 771
    SFactor(x) = GPrint(0, x) * 0.52
Next x
For x = 772 To 1073
    SFactor(x) = GPrint(0, x) * 1
Next x
For x = 1074 To 1171
    SFactor(x) = GPrint(0, x) * 0.58
Next x
For x = 1172 To 1518
    SFactor(x) = GPrint(0, x) * 1
Next x
For x = 1519 To 1797
    SFactor(x) = GPrint(0, x) * 0.79
Next x
For x = 1798 To 1963
    SFactor(x) = GPrint(0, x) * 1
Next x
For x = 1964 To 2139
    SFactor(x) = GPrint(0, x) * 0.86
Next x
For x = 2140 To 2164
    SFactor(x) = GPrint(0, x) * 1
Next x
For x = 2165 To 2544
    SFactor(x) = GPrint(0, x) * 0.64
Next x
For x = 2545 To 2570
    SFactor(x) = GPrint(0, x) * 0 '0.64
Next x


For x = 0 To NSites
    If Max < SFactor(x) Then Max = SFactor(x)
Next x

Dim PFactor() As Double
ReDim PFactor(NSites)
For x = 0 To NSites
  PFactor(x) = SFactor(x) / Max
Next x

Dim Perms As Long, PermFreq() As Double, Win As Long, A As Long, NumBreaks As Long

Win = 50
Perms = 100
NumBreaks = 400

ReDim PermFreq(Perms, NSites)
Rnd (-BSRndNumSeed)
For Y = 1 To Perms
    For x = 1 To NumBreaks * Courseness
        RNum1 = Int((Len(StrainSeq(0)) - 100) * Rnd)
        RNum1 = RNum1 + 50
        RNum2 = Int(32000 * Rnd)
        RF = RNum2 / 32000
        If RF < PFactor(APos(RNum1)) Then
            For Z = APos(RNum1) - Win / 2 To APos(RNum1) + Win / 2
                If Z < 0 Then
                    A = NSites + Z
                ElseIf Z > NSites Then
                    A = Z - NSites
                Else
                    A = Z
                End If
                PermFreq(Y, A) = PermFreq(Y, A) + 1
            Next Z
            If Y = 1 Then
                If x = 1 Then
                    Eventnumber = 0
                    ReDim CurrentXOver(NextNo)
                    ReDim XoverList(NextNo, NumBreaks + 10)
                    ReDim MaxXOP(AddNum - 1, NextNo)
                    Call ResetMaxPVCO(NextNo)
                End If
                'store this one
                Eventnumber = Eventnumber + 1
                
                
                AD = 2
                CurrentXOver(AD) = CurrentXOver(AD) + 1
                SIP = CurrentXOver(AD)
                ActualFound = 1
                        NewOneFound = 1
                XoverList(AD, SIP).Beginning = 1
                XoverList(AD, SIP).SBPFlag = 1
                XoverList(AD, SIP).Ending = RNum1
                
                XoverList(AD, SIP).MajorP = 0
                XoverList(AD, SIP).MinorP = 1
                
                XoverList(AD, SIP).Daughter = AD
                XoverList(AD, SIP).ProgramFlag = 0
                XoverList(AD, SIP).DHolder = 0
                XoverList(AD, SIP).Probability = 0.0001
                XoverList(AD, SIP).Eventnumber = Eventnumber
            End If
        Else 'try again to find a site
            x = x - 1
        End If
    Next x
    If Y = 1 Then
        ReDim BestEvent(Eventnumber, 1)
        ReDim SuperEventList(Eventnumber)
        ReDim Confirm(Eventnumber, AddNum)
        For x = 2 To NextNo - 2
            For Z = 1 To CurrentXOver(x)
                BestEvent(XoverList(x, Z).Eventnumber, 0) = x
                BestEvent(XoverList(x, Z).Eventnumber, 1) = Z
            Next Z
        
        Next x
        For x = 1 To Eventnumber
            SuperEventList(x) = x
        Next x
        SEventNumber = Eventnumber
    End If
Next Y

Dim Target As Long, Results() As Double, Tally As Long, Cutoff As Double, Upper As Long, Lower As Long, PermRank() As Long
ReDim Results(NSites, 2), PermRank(Perms, 1)

Cutoff = 0.05
Target = Perms * 0.05 / Courseness
If Target = 0 Then Target = 1
For x = 0 To NSites
    Tally = 0
    ud = 0
    LD = 0
    For Y = 1 To Perms
        PermRank(Y, 0) = 0
        PermRank(Y, 1) = 0
    Next Y
    For Y = 1 To Perms
        Tally = Tally + PermFreq(Y, x)
        Upper = 0
        Lower = 0
        If ud = 0 Or LD = 0 Then
            For Z = 1 To Perms
                If PermFreq(Y, x) <= PermFreq(Z, x) Then
                    Upper = Upper + 1
                ElseIf PermFreq(Y, x) >= PermFreq(Z, x) Then
                    Lower = Lower + 1
                End If
                
            Next Z
            If ud = 0 Then
                If Upper >= Target Then '4=570th'3=1742'2=4315'1=7703th'0=10000
                    For Z = Upper To 0 Step -1
                        If PermRank(Z, 0) = 0 Then
                            PermRank(Z, 0) = Y
                           
                            If PermFreq(Y, x) > 4 Then
                                x = x
                            End If
                            Exit For
                        End If
                    Next Z
                    If Z = Target Then
                        ud = 1
                    End If
                End If
            End If
            If LD = 0 Then
                If Lower <= Target Then
                    For Z = Lower To Perms
                        If PermRank(Z, 1) = 0 Then
                            PermRank(Z, 1) = Y
                            XX = PermFreq(Y, x)
                            Exit For
                        End If
                    Next Z
                    If Z = Target Then
                        LD = 1
                    End If
                End If
            End If
            
            x = x
        End If
        
        
    Next Y
    'For Y = 1 To Perms
    '    If PermRank(Y, 0) = Target Then
    '        Results(1, X) = PermFreq(Y, X)
    '        Exit For
    '    End If
    'Next Y
    'For Y = 1 To Perms
    '    If PermRank(Y, 1) = Target Then
    '        Results(2, X) = PermFreq(Y, X)
    '        Exit For
    '    End If
    'Next Y
    Results(x, 1) = PermFreq(PermRank(Target, 0), x) / Courseness
    Results(x, 2) = PermFreq(PermRank(Target, 1), x) / Courseness
    Results(x, 0) = Tally / Perms / Courseness
    x = x
Next x
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDrive App.Path
ChDir App.Path
On Error GoTo 0
XX = CurDir
Open "test.csv" For Output As #1
For x = 0 To NSites
    Print #1, Str(x + 1) + "," + Str(Results(x, 0)) + "," + Str(Results(x, 1)) + "," + Str(Results(x, 2))
Next x
Close #1
If DebuggingFlag < 2 Then On Error Resume Next

ChDrive App.Path
ChDir oDir
On Error GoTo 0
Exit Sub
End Sub
Public Sub VisRD(PlotF)
Dim EN As Long, Theta() As Single, rScore() As Single, Seq4 As Long, XDist As Long, YDist As Long, WinScoreV() As Single

Form1.Picture10.ScaleMode = 3
YScaleFactor = 0.85
XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
PicHeight = (Form1.Picture7.Height * YScaleFactor)
XDist = CLng(1 + Decompress((Len(StrainSeq(0)))) * XFactor)
'Exit Sub
YDist = PicHeight - 35
EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
ReDim VisRDOccupancyStat(Len(StrainSeq(0)), 2)
ReDim WinScoreV(Len(StrainSeq(0)), 2)
ReDim Theta(Len(StrainSeq(0))), rScore(Len(StrainSeq(0)))
SS = Abs(GetTickCount)
'For Seq1 = 0 To Nextno
'    For Seq2 = Seq1 + 1 To Nextno
'        For Seq3 = Seq2 + 1 To Nextno
            
            'Form1.Picture7.BackColor = RGB(BkG, BkG, BkG)
            If XDist < 0 Or YDist < 0 Then Exit Sub
            ReDim PrintPoints(XDist, YDist), VisRDOccupancyStat(Len(StrainSeq(0)), 2)
            For Seq4 = 1 To NextNo
                
                If Seq4 <> Seq1 And Seq4 <> Seq2 And Seq4 <> Seq3 Then
                    Call VXOver(PlotF, Seq1, Seq2, Seq3, Seq4, WinScoreV(), Theta(), rScore())
                    
                End If
                nt = Abs(GetTickCount)
                If Abs(OT - nt) > 500 Then
                    OT = nt
                    Form1.SSPanel1.Caption = Trim(Str(Seq4)) + " of " + Trim(Str(NextNo)) + " sequence combinations tested"
                    Form1.ProgressBar1.Value = (Seq4 / NextNo) * 90
                    Call UpdateF2Prog
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            
            Next Seq4
            Form1.SSPanel1.Caption = "Drawing plot"
            Call DrawVisRDPlot(PlotF, Seq1, Seq2, Seq3)
            Form1.ProgressBar1 = 100
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Form1.Refresh
            'DoEvents
'        Next Seq3
'    Next Seq2
'Next Seq1
EE = Abs(GetTickCount)
TT = EE - SS
'1.047/0.953
'1.031/0.953 - no redimming in Vxover
SBP = XoverList(RelX, RelY).Beginning
EBP = XoverList(RelX, RelY).Ending
SS = Abs(GetTickCount)
Dim ISeqs() As Long, dMax() As Single
ReDim ISeqs(2), dMax(2)

ISeqs(0) = Seq1
ISeqs(1) = Seq2
ISeqs(2) = Seq3


If DScores(10, 0, EN) = 0 And DScores(10, 1, EN) = 0 And DScores(10, 2, EN) = 0 Then
    Form1.SSPanel1.Caption = "Calculating dMax"
    Call CalcMaxD(ISeqs(), dMax(), SBP, EBP)
    If dMax(0) + dMax(1) + dMax(2) > 0 Then
        DScores(10, 0, EN) = (dMax(2) / (dMax(0) + dMax(1) + dMax(2))) * 20
        DScores(10, 1, EN) = (dMax(1) / (dMax(0) + dMax(1) + dMax(2))) * 20
        DScores(10, 2, EN) = (dMax(0) / (dMax(0) + dMax(1) + dMax(2))) * 20
    End If
    Form1.SSPanel1.Caption = ""
    XX = Seq1
End If
EE = Abs(GetTickCount)
TT = EE - SS
'149109
x = x '83828,82797'57000
'>1 = 7593
'8015 seconds for one read from seqnumx= byte
'7734 seqnumx=integer
'7297 using slen
'6859 -using sbpm and ebpp
'72328
'51859
'50313
'40953 - using identical array

'3.406 with cmaxd, 150.141 without
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub
Public Sub DrawVisRDPlot(PT, Seq1, Seq2, Seq3)
Dim PntAPI As POINTAPI, Pict As Long, PrintPointsCol() As Long, XDist As Long, YDist As Long, DontBother As Long, VT As Double, VO() As Double
ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1
    'first additively add values to an array then print to screen with setpixelv
    
    If PT = 0 Then 'Do occcupancy plot
        GPrintMin(1) = 100: GPrintMin(0) = 0
        
        
        'Get everything into the standard format for printing and saving
        NumLines = 3 'number of lines to print
        ReDim GPrint(NumLines - 1, Len(StrainSeq(0)) + 1), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, Len(StrainSeq(0)) + 1)
    
        ReDim GVarPos(0, 0)
        
        
        ReDim GCritval(10)
        GCritval(0) = 0
        GLegend = "Occupancy (%)"
        GPrintLen = Len(StrainSeq(0)) + 1 'how many points to plot
        GPrintCol(0) = Green  'line is yellow
        GPrintCol(1) = Purple 'line is green
        GPrintCol(2) = Yellow ''line is purple
   '     GPrintCol(3) = LGreen 'line is yellow
 '       GPrintCol(4) = LPurple 'line is green
  '      GPrintCol(5) = LYellow ''line is purple
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, 100, 0, 0, "Occupancy (%)")
        
        ReDim VO(Len(StrainSeq(0)), 2)
        For x = 1 To Len(StrainSeq(0))
            VT = (VisRDOccupancyStat(x, 0) + VisRDOccupancyStat(x, 1) + VisRDOccupancyStat(x, 2))
            If VT > 0 Then
                VO(x, 0) = VisRDOccupancyStat(x, 0) / VT
                VO(x, 1) = VisRDOccupancyStat(x, 1) / VT
                VO(x, 2) = VisRDOccupancyStat(x, 2) / VT
            End If
        Next x
        
        
        
        For x = 1 To Len(StrainSeq(0))
            For Y = 0 To 2
                GPrint(Y, x) = VO(x, Y) * 100
                'GPrint(Y + 3, X) = VO(X, Y) * 100
                GPrintPos(Y, x) = x
                'GPrintPos(Y + 3, X) = X
            Next Y
        Next x
        
        
        For x = 0 To NumLines - 1
            GPrintPos(x, GPrintLen) = Len(StrainSeq(0))
            GPrint(x, GPrintLen) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
            GPrintPos(x, 0) = 1
            GPrint(x, 0) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
        
        
        Form1.Picture7.DrawMode = 13
        Form1.Picture7.DrawWidth = 3
        Dim OX As Long, YP As Long, XP As Long, MaY As Long, MiY As Long
        For Y = 2 To 0 Step -1
'            If Y = 0 Then
'                Form1.Picture7.ForeColor = LGreen 'RGB(BkR, BkG, (255 - BkB / 2) + BkB)
'            ElseIf Y = 1 Then
'                Form1.Picture7.ForeColor = LPurple 'RGB(BkR, (255 - BkG / 2) + BkG, BkB)
'            ElseIf Y = 2 Then
'                Form1.Picture7.ForeColor = mYellow 'RGB((255 - BkR / 2) + BkR, BkG, BkB)
'            End If
'
'            Pict = Form1.Picture7.hDC
'            Dummy = MoveToEx(Pict, 30 + Decompress(1) * xFactor, PicHeight - (15 + (VO(1, Y)) * (PicHeight - 35)), PntAPI)
            OX = 0
            For x = 2 To Len(StrainSeq(0))
                
                XP = 30 + Decompress(x) * XFactor
                YP = PicHeight - (15 + (VO(x, Y)) * (PicHeight - 35))
                If XP <> OX Then
                    MiY = 100000
                    MaY = 0
                End If
'                'MCPrintData(Y, X) = Chivals(X, Y)
'                'If YP < PicHeight Then
'                    If YP > MaY Or YP < MiY Then
'                        Dummy = LineTo(Pict, XP, YP)
'                        If YP > MaY Then MaY = YP
'                        If YP < MiY Then MiY = YP
'                    End If
'                    OX = XP
'                'End If
                
                'Dummy = LineTo(Pict, 30 + X * XFactor, PicHeight - (15 + (VO(X, Y)) * (PicHeight - 35)))
            Next x
        Next Y
        If RelX > 0 Or RelY > 0 Then

            Call Highlight(0)
   
        End If
        Form1.Picture7.DrawWidth = 1
        For Y = 0 To 2
'            If Y = 0 Then
'                Form1.Picture7.ForeColor = Green 'RGB(0, 0, 255)
'            ElseIf Y = 1 Then
'                Form1.Picture7.ForeColor = Purple 'RGB(0, 255, 0)
'            ElseIf Y = 2 Then
'                Form1.Picture7.ForeColor = Yellow 'RGB(255, 0, 0)
'            End If
'
'            Pict = Form1.Picture7.hDC
'            Dummy = MoveToEx(Pict, 30 + Decompress(1) * xFactor, PicHeight - (15 + (VO(1, Y)) * (PicHeight - 35)), PntAPI)
'            OX = 0
            For x = 2 To Len(StrainSeq(0))
                
                XP = 30 + Decompress(x) * XFactor
                YP = PicHeight - (15 + (VO(x, Y)) * (PicHeight - 35))
                If XP <> OX Then
                    MiY = 100000
                    MaY = 0
                End If
'                'MCPrintData(Y, X) = Chivals(X, Y)
'                'If YP < PicHeight Then
'                    If YP > MaY Or YP < MiY Then
'                        Dummy = LineTo(Pict, XP, YP)
'                        If YP > MaY Then MaY = YP
'                        If YP < MiY Then MiY = YP
'                    End If
'                    OX = XP
'                'End If
                
                'Dummy = LineTo(Pict, 30 + X * XFactor, PicHeight - (15 + (VO(X, Y)) * (PicHeight - 35)))
            Next x
        Next Y
        'If RelX > 0 Or RelY > 0 Then'
'
 '           Call Highlight(1)
  '
   '     End If
        x = x
    Else
        
        Form1.Picture7.DrawMode = 13
        GPrintMin(1) = 180: GPrintMin(0) = -180
        GYAxHi(1) = Decompress(Len(StrainSeq(0)))
        
        Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, 180, -180, 0, "Theta")
        
        Form1.Picture7.Line (30, PicHeight - (15 + 0.6666666 * (PicHeight - 35)))-(30 + Decompress(Len(StrainSeq(0))) * XFactor, PicHeight - (15 + (PicHeight - 35))), vLYellow, BF ', RGB(BkR + (255 - BkR) / 2, BkG, BkB), BF
        Form1.Picture7.Line (30, PicHeight - (15 + 0.3333333 * (PicHeight - 35)))-(30 + Decompress(Len(StrainSeq(0))) * XFactor, PicHeight - (15 + 0.66666666 * (PicHeight - 35))), vLGreen, BF ' RGB(BkR, BkG + (255 - BkG) / 2, BkB), BF
        Form1.Picture7.Line (30, PicHeight - 15)-(30 + Decompress(Len(StrainSeq(0))) * XFactor, PicHeight - (15 + 0.3333333 * (PicHeight - 35))), vLPurple, BF ', RGB(BkR, BkG, BkB + (255 - BkB) / 2) BF
        XDist = CLng(1 + (Decompress(Len(StrainSeq(0))) * XFactor))
        YDist = PicHeight - 35
        If XDist > UBound(PrintPoints, 1) Then XDist = UBound(PrintPoints, 1)
        If YDist > UBound(PrintPoints, 2) Then YDist = UBound(PrintPoints, 2)
        
        ReDim PrintPointsCol(XDist, YDist)
        DontBother = RGB(BkR, BkG, BkB)
        MaxR = 0
        For x = 0 To XDist
            For Y = 0 To YDist
                If MaxR < PrintPoints(x, Y) Then MaxR = PrintPoints(x, Y)
                
            Next Y
        Next x
        MaxR = MaxR / 2
        For x = 0 To XDist
            For Y = 0 To YDist
                If PrintPoints(x, Y) <> 0 Then
                    If PrintPoints(x, Y) < MaxR Then
                        
                        If Y < (YDist * 0.3333333) Then 'purple
                            RC = (BkR + (255 - BkR) / 3) - ((PrintPoints(x, Y) / MaxR * (BkR + (255 - BkR) / 3)))
                            GC = BkG - ((PrintPoints(x, Y) / MaxR * BkG))
                            BC = (BkB + (255 - BkB) / 3) - ((PrintPoints(x, Y) / MaxR * (BkB + (255 - BkB) / 3)))
                        ElseIf Y < (YDist * 0.6666666) Then 'green
                            RC = BkR - ((PrintPoints(x, Y) / MaxR * BkR))
                            GC = (BkG + (255 - BkG) / 2) - ((PrintPoints(x, Y) / MaxR * (BkG + (255 - BkG) / 3)))
                            BC = (BkB + (255 - BkB) / 3) - ((PrintPoints(x, Y) / MaxR * (BkB + (255 - BkB) / 3)))
                        Else 'yellow
                            RC = (BkR + (255 - BkR) / 3) - ((PrintPoints(x, Y) / MaxR * (BkR + (255 - BkR) / 3)))
                            GC = (BkG + (255 - BkG) / 2) - ((PrintPoints(x, Y) / MaxR * (BkG + (255 - BkG) / 3)))
                            BC = BkB - ((PrintPoints(x, Y) / MaxR * BkB))
                        End If
                        PrintPointsCol(x, Y) = RGB(RC, GC, BC)
                    Else
                        PrintPointsCol(x, Y) = RGB(0, 0, 0)
                    End If
                End If
                
                
            Next Y
        Next x
        
        Pict = Form1.Picture7.hdc
        
        For x = 0 To XDist
            'XX = (1141 / XFactor)
            'xpos = Decompress(X / XFactor) * XFactor
            For Y = 0 To YDist
                If PrintPoints(x, Y) <> 0 Then
                    
                    Dummy = SetPixelV(Pict, 30 + x, PicHeight - (15 + Y), PrintPointsCol(x, Y))
                End If
            Next Y
        Next x
        If RelX > 0 Or RelY > 0 Then

            Call Highlight(1)
    
        End If
        
    End If
    WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
    WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
            'Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
    Call WriteNamesViSRD(WN1, WN2, WN3)
    
    If PT = 0 Then
        Call RedrawPlotAA(1)
    End If
    
End Sub
Public Function ArcCos(x As Double)

Dim UV As Double
If x <= -1 Or x >= 1 Then
    x = 0.9999999999
End If
UV = Sqr(-x * x + 1)
ArcCos = Atn(-x / UV) + 2 * Atn(1)
End Function
Public Sub VXOver(PlotF, Seq1 As Long, Seq2 As Long, Seq3 As Long, Seq4 As Long, WinScoreV() As Single, Theta() As Single, rScore() As Single)

'Temp Variables
Dim VWin As Long
Dim x As Long, Y As Long, S1 As Byte, s2 As Byte, S3 As Byte, S4 As Byte, D(2) As Single, NX As Long
Dim lP As Long, NP As Long
Dim FS As Single
Dim OD3 As Double, SideRs As Double, SideCs As Double, SideBs As Double, SideB As Double, SideC As Double
Dim DubHold1 As Double, DubHold2 As Double, PF As Double

If VisRDWin < 10 Then VisRDWin = 400
If VisRDWin > Len(StrainSeq(0)) Then VisRDWin = Len(StrainSeq(0)) / 2
VWin = VisRDWin

'Permanant variables

If x = x Then
    Dummy = MakeWinScoreV(Seq1, Seq2, Seq3, Seq4, Len(StrainSeq(0)), VWin, NucMat(0), SeqNum(0, 0), D(0), VScoreMat(0, 0, 0, 0, 0), WinScoreV(0, 0))
Else
    
    D(0) = 0
    D(1) = 0
    D(2) = 0
    SS = Abs(GetTickCount)
    For NX = 1 - (VWin / 2) To VWin / 2
        x = NX
        If x < 1 Then x = Len(StrainSeq(0)) + x
        If x > Len(StrainSeq(0)) Then x = x - Len(StrainSeq(0))
            
       
        S1 = SeqNum(x, Seq1) '85,72,66,68
        s2 = SeqNum(x, Seq2)
        S3 = SeqNum(x, Seq3)
        S4 = SeqNum(x, Seq4)
        S1 = NucMat(S1)
        s2 = NucMat(s2)
        S3 = NucMat(S3)
        S4 = NucMat(S4)
        D(0) = D(0) + VScoreMat(S1, s2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
        D(1) = D(1) + VScoreMat(S1, s2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
        D(2) = D(2) + VScoreMat(S1, s2, S3, S4, 2)
        
    Next NX
    EE = Abs(GetTickCount)
    TT = EE - SS
    
    FS = D(0) + D(1) + D(2)
    If FS > 0 Then
        WinScoreV(1, 0) = D(0) / FS
        WinScoreV(1, 1) = D(1) / FS
        WinScoreV(1, 2) = D(2) / FS
    Else
        WinScoreV(1, 0) = 1 / 3
        WinScoreV(1, 1) = 1 / 3
        WinScoreV(1, 2) = 1 / 3
    End If
    
    For NX = 2 To Len(StrainSeq(0))
        lP = NX - VWin / 2
        NP = NX + VWin / 2
        If lP < 1 Then lP = Len(StrainSeq(0)) + lP
        If NP > Len(StrainSeq(0)) Then NP = NP - Len(StrainSeq(0))
        S1 = SeqNum(lP, Seq1) '85,72,66,68
        s2 = SeqNum(lP, Seq2)
        S3 = SeqNum(lP, Seq3)
        S4 = SeqNum(lP, Seq4)
        S1 = NucMat(S1)
        s2 = NucMat(s2)
        S3 = NucMat(S3)
        S4 = NucMat(S4)
        D(0) = D(0) - VScoreMat(S1, s2, S3, S4, 0)
        D(1) = D(1) - VScoreMat(S1, s2, S3, S4, 1)
        D(2) = D(2) - VScoreMat(S1, s2, S3, S4, 2)
        S1 = SeqNum(NP, Seq1) '85,72,66,68
        s2 = SeqNum(NP, Seq2)
        S3 = SeqNum(NP, Seq3)
        S4 = SeqNum(NP, Seq4)
        S1 = NucMat(S1)
        s2 = NucMat(s2)
        S3 = NucMat(S3)
        S4 = NucMat(S4)
        D(0) = D(0) + VScoreMat(S1, s2, S3, S4, 0)
        D(1) = D(1) + VScoreMat(S1, s2, S3, S4, 1)
        D(2) = D(2) + VScoreMat(S1, s2, S3, S4, 2)
        FS = D(0) + D(1) + D(2)
        If FS > 0 Then
            WinScoreV(NX, 0) = D(0) / FS
            WinScoreV(NX, 1) = D(1) / FS
            WinScoreV(NX, 2) = D(2) / FS
        Else
            WinScoreV(NX, 0) = 1 / 3
            WinScoreV(NX, 1) = 1 / 3
            WinScoreV(NX, 2) = 1 / 3
        End If
    Next NX
End If




OD3 = 1 / 3

SideBs = OD3 ^ 2
SideBs = SideBs + SideBs
SideBs = SideBs + (1 - OD3) ^ 2
SideB = SideBs ^ 0.5


'get data for highway plot

If x = x Then
    Dummy = MakeTheta(PlotF, Len(StrainSeq(0)), SideB, SideBs, OD3, WinScoreV(0, 0), rScore(0), Theta(0), VisRDOccupancyStat(0, 0))
    
Else
    PF = 180 / 3.1415926535897
    For x = 1 To Len(StrainSeq(0))
        SideRs = (WinScoreV(x, 0) - OD3) ^ 2
        SideRs = SideRs + (WinScoreV(x, 1) - OD3) ^ 2
        SideRs = SideRs + (WinScoreV(x, 2) - OD3) ^ 2
        rScore(x) = (SideRs) ^ 0.5
        
        SideCs = (WinScoreV(x, 0)) ^ 2
        SideCs = SideCs + (WinScoreV(x, 1) - 1) ^ 2
        SideCs = SideCs + (WinScoreV(x, 2)) ^ 2
        SideC = (SideCs) ^ 0.5
        
        DubHold1 = (SideBs - SideCs + SideRs) / (2 * rScore(x) * SideB)
        
        Theta(x) = ArcCos(DubHold1) '-0.1715405
        Theta(x) = Theta(x) * PF
        
        If WinScoreV(x, 0) > WinScoreV(x, 2) Then
            Theta(x) = 360 - Theta(x)
        End If
        If rScore(x) > 0 And (WinScoreV(x, 0) > 0 Or WinScoreV(x, 1) > 0 Or WinScoreV(x, 2)) Then
            If Theta(x) > 300 Or Theta(x) < 60 Then
                VisRDOccupancyStat(x, 0) = VisRDOccupancyStat(x, 0) + 1
            ElseIf Theta(x) < 180 And Theta(x) > 60 Then
                VisRDOccupancyStat(x, 1) = VisRDOccupancyStat(x, 1) + 1
            ElseIf Theta(x) > 300 Or Theta(x) > 180 Then
                VisRDOccupancyStat(x, 2) = VisRDOccupancyStat(x, 2) + 1
            ElseIf Theta(x) = 60 Then
                VisRDOccupancyStat(x, 0) = VisRDOccupancyStat(x, 0) + 0.5
                VisRDOccupancyStat(x, 1) = VisRDOccupancyStat(x, 1) + 0.5
            ElseIf Theta(x) = 300 Then
                VisRDOccupancyStat(x, 0) = VisRDOccupancyStat(x, 0) + 0.5
                VisRDOccupancyStat(x, 2) = VisRDOccupancyStat(x, 2) + 0.5
            ElseIf Theta(x) = 180 Then
                VisRDOccupancyStat(x, 1) = VisRDOccupancyStat(x, 1) + 0.5
                VisRDOccupancyStat(x, 2) = VisRDOccupancyStat(x, 2) + 0.5
            End If
        Else
            rScore(x) = 0
        End If
        Theta(x) = Theta(x) + 180
        If Theta(x) > 360 Then Theta(x) = Theta(x) - 360
        
    Next x
End If
  

    
If PlotF = 1 Then
    'first additively add values to an array then print to screen with setpixelv
    If x = x Then
        XDist = CLng(1 + Decompress((Len(StrainSeq(0)))) * XFactor)
        YDist = PicHeight - 35
        Dummy = MakePrintPoints(Len(StrainSeq(0)), XDist, YDist, PicHeight, XFactor, Theta(0), rScore(0), PrintPoints(0, 0), Decompress(0))
    Else

        For x = 1 To Len(StrainSeq(0))
         
            PrintPoints(CLng(Decompress(x) * XFactor), CLng((1 - (Theta(x) / 360)) * (PicHeight - 35))) = PrintPoints(CLng(x * XFactor), CLng((1 - (Theta(x) / 360)) * (PicHeight - 35))) + rScore(x)
        
        Next 'X
        
    End If
    Form1.Picture7.DrawMode = 13
End If




End Sub
Public Sub DumpStatsToFile(FileNameX As String)

Dim x As Long, Y As Long, A As Long, C As Long, ColumnString As String, TempS As String, FN As Long, EvN As Long

FN = FreeFile


ColumnString = "Event, StartBP, EndBP, ISeqs(A),ListCorr(A),SimScoreB(A),SimScore(A),PhPrScore(A),PhPrScore2(A),PhPrScore3(A),SubScore(A),SSDist(A),OUIndexA(A), SubPhPrScore(A),SubScore2(A),SubPhPrScore2(A),SRCompatF(A),SRCompatS(A), RCompat(A),RCompat2(A), RCompat3(A),RCompat4(A),RCompatS(A),RCompatS2(A),RCompatS3(A), RCompatS4(A),RCompatXF(A),RCompatXS(A), RCompatC(A),RCompatD(A),TrpScore(A), BadDists(A), OUList(A),ListCorr2(A),ListCorr3(A), Consensus(A:0), Consensus(A:1),Consensus(A:2),OuCheck(A),SetTot(0:A),SetTot(1:A),RankF(A:0), RankF(A:1),dMax(A)"
Open FileNameX For Output As FN
Print #FN, ColumnString
For x = 1 To SDNum
    If StatsDump(0, 49, x) = 1 Then
        For A = 2 To 0 Step -1
            EN = StatsDump(A, 50, x)
            'XX = StatsDump(A, 51, x)
            TempS = Str(EN) + "," + Str(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Beginning) + "," + Str(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Ending) + ","
            If (ExRecFlag <> 203 And Daught(EN, StatsDump(A, 0, x)) > 0) Or (ExRecFlag = 203 And A = 2) Then
                TempS = TempS + PermOriginalName(StatsDump(A, 0, x))
                For Z = 0 To NextNo
                    If Z <> StatsDump(A, 0, x) Then
                        If Daught(EN, Z) > 0 Then
                            TempS = TempS + "$" + PermOriginalName(Z)
                        End If
                    End If
                Next Z
            ElseIf (ExRecFlag <> 203 And MajorPar(EN, StatsDump(A, 0, x)) > 0) Or (ExRecFlag = 203 And A = 1) Then
                TempS = TempS + PermOriginalName(StatsDump(A, 0, x))
                For Z = 0 To NextNo
                    If Z <> StatsDump(A, 0, x) Then
                        If MajorPar(EN, Z) > 0 Then
                            TempS = TempS + "$" + PermOriginalName(Z)
                        End If
                    End If
                Next Z
            ElseIf (ExRecFlag <> 203 And MinorPar(EN, StatsDump(A, 0, x)) > 0) Or (ExRecFlag = 203 And A = 0) Then
                TempS = TempS + PermOriginalName(StatsDump(A, 0, x))
                For Z = 0 To NextNo
                    If Z <> StatsDump(A, 0, x) Then
                        If MinorPar(EN, Z) > 0 Then
                            TempS = TempS + "$" + PermOriginalName(Z)
                        End If
                    End If
                Next Z
            End If
            TempS = TempS + ","
            
            For Y = 1 To 40
                TempS = TempS + Str(StatsDump(A, Y, x)) + ","
            Next Y
            Print #FN, TempS
        Next A
    End If
Next x

Close FN
x = x
End Sub


Public Sub CalcMaxD(ISeqs() As Long, dMax() As Single, SBP, EBP)

Dim FS As Double, S1 As Long, s2 As Long, S3 As Long, S4 As Long, Y As Long, Dummy As Long, x As Long, NNM1 As Long, NNM2 As Long, NNM3 As Long, SBPM As Long, EBPP As Long, SLen As Long, SeqnumX() As Integer, IncSeq2() As Byte, IncSeq() As Byte, S() As Long, sn As Long, Se1 As Long, Se2 As Long, Se3 As Long, Se4 As Long, Dist As Single, AvDist(2) As Single, MaxDist(2) As Single, TotCount(2) As Long
Dim GoOn As Long, D() As Single, e() As Single, MyValue As Long, Seq1 As Long, Seq2 As Long, Seq3 As Long
On Error GoTo FAI
ReDim S(2), D(2), e(2), IncSeq2(NextNo), IncSeq(NextNo), SeqnumX(Len(StrainSeq(0)), NextNo)
'Exit Sub
Seq1 = ISeqs(0)
Seq2 = ISeqs(1)
Seq3 = ISeqs(2)

IncSeq(Seq1) = 1
IncSeq(Seq2) = 1
IncSeq(Seq3) = 1
IncSeq2(Seq1) = 1
IncSeq2(Seq2) = 1
IncSeq2(Seq3) = 1


Dim StartSize As Long, TargetLen As Variant, ActualLen As Variant
StartSize = 30
TargetLen = (StartSize * (StartSize - 1) * (StartSize - 2)) / 6
TargetLen = TargetLen * 40000

StartSize = NextNo - 3
If StartSize > 33 Then StartSize = 30
Do
    ActualLen = (StartSize * (StartSize - 1) * (StartSize - 2)) / 6
    ActualLen = ActualLen * Len(StrainSeq(0))
    If ActualLen < TargetLen Then Exit Do
    StartSize = StartSize - 1
    If StartSize < 10 Then StartSize = 10: Exit Do
Loop

If StartSize > NextNo - 3 Then StartSize = NextNo - 3
Rnd (-BSRndNumSeed)
If NextNo <= StartSize + 3 Then
    For x = 0 To NextNo
        IncSeq2(x) = 1
    Next x
Else
    
    For x = 0 To StartSize
        Do
            MyValue = Int(((NextNo + 1) * Rnd) + 1)
            MyValue = MyValue - 1
            If IncSeq2(MyValue) = 0 And IncSeq(MyValue) = 0 Then
                IncSeq2(MyValue) = 1
                Exit Do
            End If
        Loop
    Next x

End If
Dim IncSeq3() As Long
ReDim IncSeq3(Len(StrainSeq(0)))
Dim IncNum As Long
IncNum = -1
For x = 0 To NextNo
    If IncSeq2(x) = 1 Then
        IncNum = IncNum + 1
        IncSeq3(IncNum) = x
    End If
Next x

SLen = Len(StrainSeq(0))

S(0) = Seq1
S(1) = Seq2
S(2) = Seq3

'NNM1 = nexno - 1
'NNM2 = nexno - 2
'NNM3 = nexno - 3
'SS = Abs(GetTickCount)

If NextNo < 3 Then

    dMax(0) = 0
    dMax(1) = 0
    dMax(2) = 0
    Exit Sub
End If


'If X = X Then
    
    
    'XX = IdenticalR(1532)
'    If EBP = SLen Then EBP = EBP - 1 'find better solution for this
'    If SBP = SLen Then SBP = SBP - 1
'    If X = 123456 Then
'
'        Dummy = CMaxD(Seq1, Seq2, Seq3, SBP, EBP, Nextno, SLen, SeqNum(0, 0), SeqnumX(0, 0), Identical(0), NucMat(0), IncSeq2(0), IncSeq(0), E(0), D(0), VScoreMat(0, 0, 0, 0, 0), AvDist(0), TotCount(0))
'    Else
        '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
       ' SS = abs(gettickcount)
       ' SS = abs(gettickcount)
        'For x = 1 To 20
        'SS = abs(gettickcount)
        '@'@'@'@'@'@'@'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'@'@
        If NextNo > 20 Then 'CMaxD2P3 will crash if the number of sequences is 5 or fewer
            Dummy = CMaxD2P3(IncNum, Seq1, Seq2, Seq3, SBP, EBP, NextNo, SLen, SeqNum(0, 0), SeqnumX(0, 0), IdenticalR(0), IdenticalF(0), NucMat(0), IncSeq3(0), IncSeq2(0), IncSeq(0), e(0), D(0), VScoreMat(0, 0, 0, 0, 0), AvDist(0), TotCount(0))
        
        Else
            Dummy = CMaxD2P(IncNum, Seq1, Seq2, Seq3, SBP, EBP, NextNo, SLen, SeqNum(0, 0), SeqnumX(0, 0), IdenticalR(0), IdenticalF(0), NucMat(0), IncSeq3(0), IncSeq2(0), IncSeq(0), e(0), D(0), VScoreMat(0, 0, 0, 0, 0), AvDist(0), TotCount(0))
        End If
        'XX = RedoListSize
        'Next x
        'EE = abs(gettickcount)
        'TT = EE - SS
        'x = x
        'Dummy = CMaxD3(IncNum, SBP, EBP, Nextno, SLen, SeqNum(0, 0), SeqnumX(0, 0), IdenticalR(0), IdenticalF(0), NucMat(0), IncSeq3(0), IncSeq2(0), ISeqs(0), E(0), D(0), VScoreMat(0, 0, 0, 0, 0), AvDist(0), TotCount(0))
        'cmaxd2 = 27.39:28(133)
        'cmaxd2p = 27.62:28(133)
        'cmaxd2p with parallelization = 22.58:28(133)
        If CurrentlyRunningFlag = 1 Then
            DoEvents
        End If
'    End If
    'AbortFlag = 1
    x = x
'Else
'
'    SBPM = IdenticalF(SBP - 1)
'    EBPP = IdenticalF(EBP + 1)
'    SBP = IdenticalF(SBP)
'    EBP = IdenticalF(EBP)
'    For X = 0 To Nextno
'        For Y = 0 To Len(StrainSeq(0))
'            S1 = SeqNum(Y, X)
'            SeqnumX(Y, X) = NucMat(S1)
'        Next Y
'    Next X
'
'    For Se1 = 0 To Nextno - 3
'        For Se2 = Se1 + 1 To Nextno - 2
'            For Se3 = Se2 + 1 To Nextno - 1
'                For Se4 = Se3 + 1 To Nextno
'                    GoOn = IncSeq(Se1) + IncSeq(Se2) + IncSeq(Se3) + IncSeq(Se4)
'
'                    If GoOn > 0 Then 'Seq1 = Se1 Or Seq2 = Se1 Or Seq3 = Se1 Or Seq1 = Se2 Or Seq2 = Se2 Or Seq3 = Se2 Or Seq1 = Se3 Or Seq2 = Se3 Or Seq3 = Se3 Or Seq1 = Se4 Or Seq2 = Se4 Or Seq3 = Se4 Then
'                        If SBP < EBP Then
'
'                            E(0) = 0
'                            E(1) = 0
'                            E(2) = 0
'                            For X = 1 To SBPM
'                                'If Identical(X) = 0 Then
'                                    S1 = SeqnumX(IdenticalR(X), Se1) '85,72,66,68
'                                    S2 = SeqnumX(IdenticalR(X), Se2)
'                                    S3 = SeqnumX(IdenticalR(X), Se3)
'
'                                    If S1 <> S2 Or S1 <> S3 Then
'                                        S4 = SeqnumX(IdenticalR(X), Se4)
'                                        'If S1 <> S4 Then
'                                            'S1 = NucMat(S1)
'                                            'S2 = NucMat(S2)
'                                            'S3 = NucMat(S3)
'                                            'S4 = NucMat(S4)
'
'                                            E(0) = E(0) + VScoreMat(S1, S2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
'                                            E(1) = E(1) + VScoreMat(S1, S2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
'                                            E(2) = E(2) + VScoreMat(S1, S2, S3, S4, 2)
'                                        'End If
'                                    End If
'                                'End If
'                            Next X
'                            For X = EBPP To SLen
'                                'If Identical(X) = 0 Then
'                                     S1 = SeqnumX(IdenticalR(X), Se1) '85,72,66,68
'                                     S2 = SeqnumX(IdenticalR(X), Se2)
'                                     S3 = SeqnumX(IdenticalR(X), Se3)
'
'                                     If S1 <> S2 Or S1 <> S3 Then
'                                         S4 = SeqnumX(IdenticalR(X), Se4)
'                                         'If S1 <> S4 Then
'                                             'S1 = NucMat(S1)
'                                             'S2 = NucMat(S2)
'                                             'S3 = NucMat(S3)
'                                             'S4 = NucMat(S4)
'
'                                             E(0) = E(0) + VScoreMat(S1, S2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
'                                             E(1) = E(1) + VScoreMat(S1, S2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
'                                             E(2) = E(2) + VScoreMat(S1, S2, S3, S4, 2)
'                                         'End If
'                                     End If
'                                'End If
'                            Next X
'                            FS = E(0) + E(1) + E(2)
'                            If FS > 0 Then
'                                E(0) = E(0) / FS
'                                E(1) = E(1) / FS
'                                E(2) = E(2) / FS
'                            Else
'                                E(0) = 1 / 3: E(1) = 1 / 3: E(2) = 1 / 3
'                            End If
'
'                            D(0) = 0
'                            D(1) = 0
'                            D(2) = 0
'                            For X = SBP To EBP
'                                'If Identical(X) = 0 Then
'                                     S1 = SeqnumX(IdenticalR(X), Se1) '85,72,66,68
'                                     S2 = SeqnumX(IdenticalR(X), Se2)
'                                     S3 = SeqnumX(IdenticalR(X), Se3)
'
'                                     If S1 <> S2 Or S1 <> S3 Then
'                                         S4 = SeqnumX(IdenticalR(X), Se4)
'                                         'If S1 <> S4 Then
'                                             'S1 = NucMat(S1)
'                                             'S2 = NucMat(S2)
'                                             'S3 = NucMat(S3)
'                                             'S4 = NucMat(S4)
'                                             D(0) = D(0) + VScoreMat(S1, S2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
'                                             D(1) = D(1) + VScoreMat(S1, S2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
'                                             D(2) = D(2) + VScoreMat(S1, S2, S3, S4, 2)
'                                         'End If
'                                     End If
'                                'End If
'                            Next X
'                            FS = D(0) + D(1) + D(2)
'                            If FS > 0 Then
'                                D(0) = D(0) / FS
'                                D(1) = D(1) / FS
'                                D(2) = D(2) / FS
'                            Else
'                                D(0) = 1 / 3: D(1) = 1 / 3: D(2) = 1 / 3
'                            End If
'                        Else
'                            E(0) = 0
'                            E(1) = 0
'                            E(2) = 0
'
'                            For X = EBPP To SBPM
'                                'If Identical(X) = 0 Then
'                                    S1 = SeqnumX(IdenticalR(X), Se1) '85,72,66,68
'                                    S2 = SeqnumX(IdenticalR(X), Se2)
'                                    S3 = SeqnumX(IdenticalR(X), Se3)
'
'                                    If S1 <> S2 Or S1 <> S3 Then
'                                        S4 = SeqnumX(IdenticalR(X), Se4)
'                                        'S1 = NucMat(S1)
'                                        'S2 = NucMat(S2)
'                                        'S3 = NucMat(S3)
'                                        'S4 = NucMat(S4)
'                                        If S1 = 0 Or S2 = 0 Or S3 = 0 Or S4 = 0 Then
'                                                X = X
'                                            End If
'                                        E(0) = E(0) + VScoreMat(S1, S2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
'                                        E(1) = E(1) + VScoreMat(S1, S2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
'                                        E(2) = E(2) + VScoreMat(S1, S2, S3, S4, 2)
'                                    End If
'                                'End If
'                            Next X
'                            FS = E(0) + E(1) + E(2)
'                            If FS > 0 Then
'                                E(0) = E(0) / FS
'                                E(1) = E(1) / FS
'                                E(2) = E(2) / FS
'                            Else
'                                E(0) = 1 / 3: E(1) = 1 / 3: E(2) = 1 / 3
'                            End If
'
'                            D(0) = 0
'                            D(1) = 0
'                            D(2) = 0
'                            For X = 1 To EBP
'                                'If Identical(X) = 0 Then
'                                    S1 = SeqnumX(IdenticalR(X), Se1) '85,72,66,68
'                                    S2 = SeqnumX(IdenticalR(X), Se2)
'                                    S3 = SeqnumX(IdenticalR(X), Se3)
'
'                                    If S1 <> S2 Or S1 <> S3 Then
'                                        S4 = SeqnumX(IdenticalR(X), Se4)
'                                        If S1 = 0 Or S2 = 0 Or S3 = 0 Or S4 = 0 Then
'                                                X = X
'                                            End If
'                                        'S1 = NucMat(S1)
'                                        'S2 = NucMat(S2)
'                                        'S3 = NucMat(S3)
'                                        'S4 = NucMat(S4)
'                                        D(0) = D(0) + VScoreMat(S1, S2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
'                                        D(1) = D(1) + VScoreMat(S1, S2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
'                                        D(2) = D(2) + VScoreMat(S1, S2, S3, S4, 2)
'                                    End If
'                                'End If
'                            Next X
'                            For X = SBP To SLen
'                                'If Identical(X) = 0 Then
'                                     S1 = SeqnumX(IdenticalR(X), Se1) '85,72,66,68
'                                     S2 = SeqnumX(IdenticalR(X), Se2)
'                                     S3 = SeqnumX(IdenticalR(X), Se3)
'
'                                     If S1 <> S2 Or S1 <> S3 Then
'                                         S4 = SeqnumX(IdenticalR(X), Se4)
'
'                                         'S1 = NucMat(S1)
'                                         'S2 = NucMat(S2)
'                                         'S3 = NucMat(S3)
'                                         'S4 = NucMat(S4)
'                                         D(0) = D(0) + VScoreMat(S1, S2, S3, S4, 0) '1=2:3=4 = 1;1=2:3<>4 = 0.5;1<>2:3=4 = 0.5
'                                         D(1) = D(1) + VScoreMat(S1, S2, S3, S4, 1) '1=3:2=4 = 1; 1=3:2<>4 = 0.5
'                                         D(2) = D(2) + VScoreMat(S1, S2, S3, S4, 2)
'                                     End If
'                                'End If
'                            Next X
'                            FS = D(0) + D(1) + D(2)
'                            If FS > 0 Then
'                                D(0) = D(0) / FS
'                                D(1) = D(1) / FS
'                                D(2) = D(2) / FS
'                            Else
'                                D(0) = 1 / 3: D(1) = 1 / 3: D(2) = 1 / 3
'                            End If
'                        End If
'                        'it doesn't matter what the actual distance is - the relative distance is what matters. or does it?
'                        Dist = Abs(D(0) - E(0)) ' ^ 2
'                        Dist = Dist + Abs(D(1) - E(1)) ' ^ 2
'                        Dist = Dist + Abs(D(2) - E(2)) '^ 2
'                        If Se1 = Seq1 Or Se2 = Seq1 Or Se3 = Seq1 Or Se4 = Seq1 Then
'                            AvDist(0) = AvDist(0) + Dist
'                            TotCount(0) = TotCount(0) + 1
'                            If Dist > MaxDist(0) Then
'                                MaxDist(0) = Dist
'                            End If
'                        End If
'                        If Se1 = Seq2 Or Se2 = Seq2 Or Se3 = Seq2 Or Se4 = Seq2 Then
'                            AvDist(1) = AvDist(1) + Dist
'                            TotCount(1) = TotCount(1) + 1
'                            If Dist > MaxDist(1) Then
'                                MaxDist(1) = Dist
'                            End If
'                        End If
'                        If Se1 = Seq3 Or Se2 = Seq3 Or Se3 = Seq3 Or Se4 = Seq3 Then
'                            AvDist(2) = AvDist(2) + Dist
'                            TotCount(2) = TotCount(2) + 1
'                            If Dist > MaxDist(2) Then
'                                MaxDist(2) = Dist
'                            End If
'                        End If
'                    End If
'                Next Se4
'            Next Se3
'        Next Se2
'    Next Se1
'End If
'Exit Sub
'AbortFlag = 1
'DoEvents
'XX = Form1.Picture7.Enabled
If TotCount(0) > 0 And TotCount(1) > 0 And TotCount(2) > 0 Then
    dMax(0) = AvDist(0) / TotCount(0) '0.17,0.29,0.25,0.28
    dMax(1) = AvDist(1) / TotCount(1) '0.16,0.34,0.17,0.36
    dMax(2) = AvDist(2) / TotCount(2) '0.36,0.38,0.18,0.37
Else
    dMax(0) = 0
    dMax(1) = 0
    dMax(2) = 0
    
End If

'EE = Abs(GetTickCount)
'    TT = EE - SS
'    '563063 for 288 sequences
'    X = X
'XX = (AvDist(0) + AvDist(1) + AvDist(2))
'XX = MaxDist(0)
'XX = MaxDist(1)
'XX = MaxDist(2)
'XX = Seq1
'XX = Seq2
'XX = Seq3
'XX = Nextno
'XX = PermNextno
'X = X


Exit Sub
FAI:

End Sub
Public Sub ExRecAnalysis()
Dim LastBreakPos As Long, SP As Long, EP As Long, x As Long, Y As Long, Z As Long, LastMatchPos As Long, LastMatch As Long
Dim RecProfile() As Long, PopList() As Byte, Done() As Byte
ReDim RecProfile(Len(StrainSeq(0)), NextNo), Done(NextNo)
Dim PopMap() As Byte, Test As String
ReDim PopMap(Len(StrainSeq(0)), NextNo, 1), PopList(NextNo)

'find samples from individual plants
Z = 0
ReDim PermPlantNum(NextNo)
For x = 0 To NextNo
    If ParentSeqs(0) <> x And ParentSeqs(1) <> x Then
        If Chimaeraflag = 0 Or RefChimaera(x) <> -1 Then
        
        
            If Done(x) = 0 Then
                Test = Left$(OriginalName(x), 4)
                Z = Z + 1
                PermPlantNum(x) = Z
                For Y = x To NextNo
                    
                    If Done(Y) = 0 Then
                        If Left$(OriginalName(Y), 4) = Test Then
                            PermPlantNum(Y) = Z
                            Done(Y) = 1
                            PopList(Y) = Z
                        End If
                    End If
                Next Y
                
            End If
        End If
    End If
Next x
PermPlantCount = Z

For x = 0 To NextNo
    For Y = 0 To Len(StrainSeq(0))
        RecProfile(Y, x) = -1
    Next Y
Next x
LastMatch = -1
Dim P1 As Long, P2 As Long, NumVS As Long, A As Long

P1 = ParentSeqs(0)
P2 = ParentSeqs(1)

For x = 0 To NextNo

    If x <> ParentSeqs(0) And x <> ParentSeqs(1) Then
        If Chimaeraflag = 1 And RefChimaera(x) > -1 Then
            P1 = ChimaeraSeqs(RefChimaera(x), 0)
            P2 = ChimaeraSeqs(RefChimaera(x), 1)
        ElseIf Chimaeraflag = 1 And RefChimaera(x) = -1 Then
            P1 = ParentSeqs(0)
            P2 = ParentSeqs(1)
        End If
        For Y = 1 To Len(StrainSeq(0))
            
                If SeqNum(Y, P1) <> SeqNum(Y, P2) Or SeqNum(Y, x) <> SeqNum(Y, P1) Then '57=A 1216 1217: 1 = 1214
                    If SeqNum(Y, x) = SeqNum(Y, P1) Then
                        RecProfile(Y, x) = 0
                    ElseIf SeqNum(Y, x) = SeqNum(Y, P2) Then
                        RecProfile(Y, x) = 1
                    Else
                        RecProfile(Y, x) = 2
                    End If
                End If
            
        Next Y
    End If
Next x
'Find xovers and fill in the gaps
Eventnumber = 0

P1 = ParentSeqs(0)
P2 = ParentSeqs(1)

For x = 0 To NextNo
    If x = 197 Then
        x = x
    End If
    If x <> ParentSeqs(0) And x <> ParentSeqs(1) Then
        If Chimaeraflag = 1 And RefChimaera(x) > -1 Then
            P1 = ChimaeraSeqs(RefChimaera(x), 0)
            P2 = ChimaeraSeqs(RefChimaera(x), 1)
        ElseIf Chimaeraflag = 1 And RefChimaera(x) = -1 Then
            P1 = ParentSeqs(0)
            P2 = ParentSeqs(1)
        End If
        
        If InStr(1, OriginalName(x), "sizeref", vbTextCompare) = 0 Then
            LastMatch = -1
            LastMatchPos = 0
            If CircularFlag = 0 Then
                LastBreakPos = 1
                Z = 2
            Else
                LastBreakPos = Len(StrainSeq(0))
                For Y = Len(StrainSeq(0)) To 1 Step -1
                    If RecProfile(Y, x) = 1 Or RecProfile(Y, x) = 0 Then
                        If LastMatch = -1 Then
                            LastMatch = RecProfile(Y, x)
                            LastMatchPos = Y
                            For Z = Y To 1 Step -1
                                If RecProfile(Z, x) = 1 Or RecProfile(Z, x) = 0 Then
                                    If RecProfile(Y, x) <> RecProfile(Z, x) Then
                                        LastBreakPos = Z + CLng((LastBreakPos - Z) / 2)
                                        Y = 1
                                        Exit For
                                    Else
                                        LastBreakPos = Z
                                    End If
                                End If
                            Next Z
                            x = x
                        End If
                    End If
                Next Y
            End If
            If Z > 1 Then
                For Y = 1 To Len(StrainSeq(0))
                    
                    If RecProfile(Y, x) <> -1 Then
                        If RecProfile(Y, x) = 2 Then
                            x = x
                        End If
                        If RecProfile(Y, x) = 0 Then
                            
                            If LastMatch <> 0 Then
                                
                                If LastMatch <> -1 Then
                                    'add the event
                                    
                                    If LastMatchPos > 0 Then
                                        If LastMatchPos < Y Then
                                            If Y - LastMatchPos > 1 Then
                                                SP = LastMatchPos + CLng((Y - LastMatchPos) / 2)
                                            Else
                                                SP = Y
                                            End If
                                        Else
                                            SP = LastMatchPos + CLng(((Len(StrainSeq(0)) - LastMatchPos) + Y) / 2)
                                            If SP > Len(StrainSeq(0)) Then
                                                SP = SP - Len(StrainSeq(0))
                                            End If
                                        End If
                                    Else
                                        SP = 1
                                    End If
                                    Eventnumber = Eventnumber + 1
                                    
                                    CurrentXOver(x) = CurrentXOver(x) + 1
                                    SIP = CurrentXOver(x)
                                    AD = x
                                    If SIP > UBound(XoverList, 2) Then
                                        ReDim Preserve XoverList(NextNo, SIP + 100)
                                    End If
                                    XoverList(AD, SIP).Beginning = LastBreakPos
                                    XoverList(AD, SIP).Ending = SP
                                    NumVS = 0
                                    If LastBreakPos < SP Then
                                        For A = LastBreakPos To SP
                                            If RecProfile(A, x) = 1 Then
                                                NumVS = NumVS + 1
                                            End If
                                        Next
                                    Else
                                        For A = LastBreakPos To Len(StrainSeq(0))
                                            If RecProfile(A, x) = 1 Then
                                                NumVS = NumVS + 1
                                            End If
                                        Next
                                        For A = 1 To SP
                                            If RecProfile(A, x) = 1 Then
                                                NumVS = NumVS + 1
                                            End If
                                        Next
                                    End If
                                    XoverList(AD, SIP).LHolder = NumVS
                                    XoverList(AD, SIP).MajorP = P1
                                    XoverList(AD, SIP).MinorP = P2
                                    XoverList(AD, SIP).Daughter = x
                                    
                                    XoverList(AD, SIP).ProgramFlag = 0
                                    XoverList(AD, SIP).DHolder = 0
                                    XoverList(AD, SIP).Probability = 0.0001
                                    XoverList(AD, SIP).Eventnumber = Eventnumber
                                    If PopMap(LastBreakPos, PopList(x), 0) = 1 Or (Chimaeraflag = 1 And RefChimaera(x) = -1) Then
                                            XoverList(AD, SIP).SBPFlag = 2
                                    End If
                                    If CircularFlag = 0 Then
                                        If XoverList(AD, SIP).Beginning = 1 Then
                                            If XoverList(AD, SIP).SBPFlag = 2 Then
                                                 XoverList(AD, SIP).SBPFlag = 3
                                             Else
                                                XoverList(AD, SIP).SBPFlag = 1
                                             End If
                                        End If
                                    Else
                                        If PopMap(SP, PopList(x), 1) = 1 Or (Chimaeraflag = 1 And RefChimaera(x) = -1) Then
                                             If XoverList(AD, SIP).SBPFlag = 2 Then
                                                 XoverList(AD, SIP).SBPFlag = 3
                                             Else
                                                XoverList(AD, SIP).SBPFlag = 1
                                             End If
                                        End If
                                    End If
                                    PopMap(LastBreakPos, PopList(x), 0) = 1
                                    PopMap(SP, PopList(x), 1) = 1
                                    LastBreakPos = SP
                                End If
                            
                                
                                LastMatch = 0
                            End If
                            LastMatchPos = Y
                        ElseIf RecProfile(Y, x) = 1 Then
                            
                            If LastMatch <> 1 Then
                            
                                If LastMatch <> -1 Then
                                    'add the event
                                    If LastMatchPos > 0 Then
                                        If LastMatchPos < Y Then
                                            If Y - LastMatchPos > 1 Then
                                                SP = LastMatchPos + CLng((Y - LastMatchPos) / 2)
                                            Else
                                                SP = Y
                                            End If
                                        Else
                                            SP = LastMatchPos + CLng(((Len(StrainSeq(0)) - LastMatchPos) + Y) / 2)
                                            If SP > Len(StrainSeq(0)) Then
                                                SP = SP - Len(StrainSeq(0))
                                            End If
                                        End If
                                    Else
                                        SP = 1
                                    End If
                                    Eventnumber = Eventnumber + 1
                                    
                                    CurrentXOver(x) = CurrentXOver(x) + 1
                                    SIP = CurrentXOver(x)
                                    AD = x
                                    If SIP > UBound(XoverList, 2) Then
                                        ReDim Preserve XoverList(NextNo, SIP + 100)
                                    End If
                                    XoverList(AD, SIP).Beginning = LastBreakPos
                                    XoverList(AD, SIP).Ending = SP
                                    NumVS = 0
                                    If LastBreakPos < SP Then
                                        For A = LastBreakPos To SP
                                            If RecProfile(A, x) = 0 Then
                                                NumVS = NumVS + 1
                                            End If
                                        Next
                                    Else
                                        For A = LastBreakPos To Len(StrainSeq(0))
                                            If RecProfile(A, x) = 0 Then
                                                NumVS = NumVS + 1
                                            End If
                                        Next
                                        For A = 1 To SP
                                            If RecProfile(A, x) = 0 Then
                                                NumVS = NumVS + 1
                                            End If
                                        Next
                                    End If
                                    XoverList(AD, SIP).LHolder = NumVS
                                    XoverList(AD, SIP).MajorP = P2
                                    XoverList(AD, SIP).MinorP = P1
                                    XoverList(AD, SIP).Daughter = x
                                    XoverList(AD, SIP).ProgramFlag = 0
                                    XoverList(AD, SIP).DHolder = 0
                                    XoverList(AD, SIP).Probability = 0.0001
                                    XoverList(AD, SIP).Eventnumber = Eventnumber
                                    If PopMap(LastBreakPos, PopList(x), 0) = 1 Or (Chimaeraflag = 1 And RefChimaera(x) = -1) Then
                                            XoverList(AD, SIP).SBPFlag = 2
                                    End If
                                    If CircularFlag = 0 Then
                                        If XoverList(AD, SIP).Beginning = 1 Then
                                            If XoverList(AD, SIP).SBPFlag = 2 Then
                                                 XoverList(AD, SIP).SBPFlag = 3
                                             Else
                                                XoverList(AD, SIP).SBPFlag = 1
                                             End If
                                        End If
                                    Else
                                        If PopMap(SP, PopList(x), 1) = 1 Or (Chimaeraflag = 1 And RefChimaera(x) = -1) Then
                                             If XoverList(AD, SIP).SBPFlag = 2 Then
                                                 XoverList(AD, SIP).SBPFlag = 3
                                             Else
                                                XoverList(AD, SIP).SBPFlag = 1
                                             End If
                                        End If
                                    End If
                                    PopMap(LastBreakPos, PopList(x), 0) = 1
                                    PopMap(SP, PopList(x), 1) = 1
                                    LastBreakPos = SP
                                End If
                            
                                LastMatchPos = Y
                                LastMatch = 1
                            End If
                            LastMatchPos = Y
                        End If
                    End If
                Next Y
            End If
        End If
'    Else
'        If X / 2 = Int(X / 2) Then
'            P1 = X
'        Else
'            P2 = X
'        End If
    End If
Next x

ReDim BestEvent(Eventnumber, 1)

For x = 2 To NextNo
    For Y = 1 To CurrentXOver(x)
        BestEvent(XoverList(x, Y).Eventnumber, 0) = x
        BestEvent(XoverList(x, Y).Eventnumber, 1) = Y
    Next Y

Next x

End Sub
Public Sub Build3SeqTableFromMacFile()
Dim MaxPermDists As Long
If DebuggingFlag < 2 Then On Error Resume Next

ChDir App.Path
ChDrive App.Path
On Error GoTo 0
Dim ArrayX() As Single
Call Build3SeqTable
ReDim ArrayX(350, 350, 350)
Close #1
Open "PVALUE_TABLE_300" For Input As #1
ZZZ = 0

For x = 0 To 300
    For Y = 0 To 300
        For Z = 0 To 301
            
            Input #1, ArrayX(x, Y, Z)
            ZZZ = ZZZ + 1
            x = x
            If ArrayX(x, Y, Z) <> 1 And ArrayX(x, Y, Z) <> 0 Then
                x = x
                
                If x <= UBound(XTable, 1) And Y <= UBound(XTable, 1) And Z <= UBound(XTable, 1) And x = 12345 Then
                    
                    If XTable(x, Y, Z) <> 0 And XTable(x, Y, Z) <> 1 Then
                        x = x
                        For A = 0 To UBound(XTable, 1)
                            For b = 0 To UBound(XTable, 1)
                                For C = 0 To UBound(XTable, 1)
                                    If XTable(A, b, C) = ArrayX(x, Y, Z) Then
                                        x = x
                                    End If
                                Next C
                            Next b
                        Next A
                        x = x
                    End If
                End If
            End If
            
        Next Z
    Next Y
Next x

x = 0
'Do
'
' Input #1, xxx
' X = X + 1
'Loop
MaxPermDists = 300
ReDim XTable(MaxPermDists + 1, MaxPermDists + 1, MaxPermDists + 1)

For x = 0 To MaxPermDists
For Y = 0 To MaxPermDists
For Z = 0 To MaxPermDists
    
    XTable(x, Y, Z) = ArrayX(x, Y, Z)
    
  '  If XTable(X, Y, z) < 0.8 And XTable(X, Y, z) > 0 Then
  '      If (XTable(X, Y, z) <= ArrayX(X, Y, z) * 1.00001) And (XTable(X, Y, z) >= ArrayX(X, Y, z) / 1.00001) Then
  '
  '      Else
  '          X = X
  '      End If
  '  End If
  '  If XTable(X, Y, z) < 0.5 And XTable(X, Y, z) > 0 And X = 12345 Then
  '      For A = 0 To 301
  '          For B = 0 To 300
  '              For C = 0 To 300
  '                  If ArrayX(A, B, C) = XTable(X, Y, z) Then '1,4,4 = 1,5,8; 3,5,4;3,16,24; 12,65,95; 21,68,75; 28,152,221
  '                      X = X                                 '1,5,5 = 1,6,10
  '                                                            '1,7,7 = 1,8,14
  '
  '
  '                  End If
  '              Next C
  '          Next B
  '      Next A
  '      X = X
  '  End If
    
Next Z

Next Y

Next x
Close #1

Open "3seqTable" For Binary As #1
    Put #1, , MaxPermDists
    Put #1, , XTable()
    Close #1

Close #1
End Sub
Public Function SiegmundDiscrete(M As Long, n As Long, k As Long)

Dim h1 As Double, h2 As Double, AN As Double, SD As Variant, MM As Double, b As Double, xi As Double, P1 As Double, P2 As Double, P3 As Variant, NU As Variant
MM = (M + n)
If MM = 0 Then
    SiegmundDiscrete = -1
    Exit Function
End If
b = k - 0.5
xi = n - M
h1 = -2# * b * (b - xi) / MM
'If h1 < -41 Then
'    'h1 = -41
'    X = X
'End If
If h1 > 700 Then h1 = 700


'p1 = Exp(706)
P1 = Exp(h1)
'P2 = (2# * B - xi)
'P2 = P2 * (B - xi)
'P2 = P2 * 2#
'P2 = P2 / MM
'P2 = P2 + 1#
If P1 > 10 ^ 200 Then P1 = 10 ^ 200
'P2 = P2 * P1
P2 = P1 * (2# * (2# * b - xi) * (b - xi) / MM + 1#)

AN = 2# * (2# * b - xi) / MM

If AN <> 0 Then
    NU = ApproxNu(AN)
Else
    SD = 1
End If
P3 = NU * NU * P2
If DebuggingFlag < 2 Then On Error Resume Next
SD = -1
If P3 < 0 Then
    If P3 < -1 Then
        P3 = -1
    End If
Else
'    If P3 > 10 ^ 1 Then
'        P3 = 10 ^ 1
'    End If
End If
SD = Exp(-P3)
SD = 1 - SD
On Error GoTo 0


'SD = Exp(-10)
'SD = 1 / Exp(10)
SiegmundDiscrete = SD


End Function


Public Function ApproxNormPDF(x As Double)
Dim pi As Double
pi = 3.14159265359

ApproxNormPDF = (1# / Sqr(2# * pi)) * Exp(-0.5 * x * x)

End Function

Public Function ApproxNu(x As Double)
If x > 0 Then
    ApproxNu = ((ApproxNormCDF(x / 2#) - 0.5) * 2#) / x / (ApproxNormPDF(x / 2#) + (x * ApproxNormCDF(x / 2#)) / 2#)
Else
    ApproxNu = 0
End If
End Function

Public Function ApproxNormCDF(x As Double)

Dim T As Double

Const b1 = 0.31938153
Const b2 = -0.356563782
Const b3 = 1.781477937
Const b4 = -1.821255978
Const b5 = 1.330274429
Const P = 0.2316419
Const C = 0.39894228

If x > 6 Then
    ApproxNormCDF = 1
ElseIf x < -6 Then
    ApproxNormCDF = 0
End If
If x >= 0# Then

    T = 1# / (1# + P * x)
    ApproxNormCDF = (1# - C * Exp(-x * x / 2#) * T * (T * (T * (T * (T * b5 + b4) + b3) + b2) + b1))

Else

    T = 1# / (1# - P * x)
    ApproxNormCDF (C * Exp(-x * x / 2#) * T * (T * (T * (T * (T * b5 + b4) + b3) + b2) + b1))
End If

End Function
Public Sub WriteRDPFile4(sFName As String)
Open sFName$ For Output As #1

            If SEventNumber = 0 Then
                Print #1, "No recombination detected"
                Close #1
                Exit Sub
            End If
            SaveFlag = 1
            Form1.SSPanel1.Caption = "Saving Sequence Data"
            Form1.ProgressBar1.Value = 20
            DoEvents
            'Print #1, SeqFile
            If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            
                For x = 0 To PermNextno
                    Print #1, ">" & OriginalName(x)
                    Print #1, StrainSeq(x)
                Next 'X
            Else
                Close #1
                Kill sFName$
                On Error Resume Next

                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                
                Name BIGFilename As sFName$
                FileCopy sFName$, BIGFilename
                
                On Error Resume Next

                
                ChDir oDir
                ChDrive oDir
               
                
                Open sFName$ For Append As #1
                
            End If

            If ORFFlag = 1 Then
                Form1.SSPanel1.Caption = "Saving Sequence Data"
                Form1.ProgressBar1.Value = 20
                DoEvents
            End If

            Print #1, "GB Data"
            Print #1, GBFile
            Form1.SSPanel1.Caption = "Saving Recombination Data"
            Form1.ProgressBar1.Value = 40
            DoEvents
            Write #1, "Recombination Data"
            Write #1, "r20"
            Write #1, pSpacerFlag, pCircularFlag, ShowPlotFlag, GPerms, PermTypeFlag, pXOverWindowX, LowestProb, MCFlag
            Write #1, SHWinLen, pGCIndelFlag, SHStep, pGCTripletflag
            Write #1, GCOutfileName
            Write #1, BSTreeStrat, BSupTest, GCSortFlag, GCTractLen, GCLogFlag
            Write #1, pGCMissmatchPen, SCHEMADistCO, SCHEMAPermNo, pGCMinFragLen, pGCMinPolyInFrag
            Write #1, pGCMinPairScore, pGCMaxOverlapFrags, ConservativeGroup, MaxTemperature, ntType
            Write #1, pBSStepWin, pBSStepSize, pBSCutoff, pBSBootReps, BSRndNumSeed, BSSubModelFlag
            Write #1, BSTTRatio, MCMCUpdates, BlockPen, StartRho, MatPermNo
            Write #1, DoScans(1, 2), DoScans(1, 5), FreqCo, MatWinSize, FreqCoMD
            Write #1, AllowConflict, 0, pMCSteplen, pMCWinSize
            Write #1, pDoScans(0, 0), pDoScans(0, 1), pDoScans(0, 2), pDoScans(0, 3), pDoScans(0, 4), pDoScans(0, 5)
            Write #1, FileList(1), FileList(2), FileList(3), FileList(4)
            Write #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
            Write #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
            Write #1, pMCWinFract, pMCProportionFlag, pMCTripletFlag, pMCStripGapsFlag, MCFullOR, MCFullOL
            Write #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
            Write #1, VisRDWin, ModelTestFlag
            Write #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
            Write #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
            Write #1, TOTreeType, TOFreqFlag, TOModel
            Write #1, pBSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
            Write #1, GCFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
            Write #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
            Write #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
            Write #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, pBSPValFlag, SSFastFlag, pSSGapFlag, pSSVarPFlag, pSSOutlyerFlag, pSSRndSeed, pSSWinLen, pSSStep, pSSNumPerms, pSSNumPerms2
            Write #1, ForcePhylE, PolishBPFlag, RealignFlag, ConsensusProg, pCWinFract, pCProportionFlag, pCWinSize, 0, 0
            Write #1, PPWinLen, pPPStripGaps, IncSelf, PPSeed, PPPerms, DoScans(0, 8)
            Write #1, TPTVRat, TPGamma, TPAlpha, TPInvSites, TPModel, TPBPFEstimate
            Write #1, TBModel, TBGamma, TBGammaCats, TBNGens, TBNChains, TBSampFreq, TBTemp, TBSwapFreq, TBSwapNum
            Write #1, MCCorrection

            For x = 0 To PermNextno
                Write #1, pMaskSeq(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno
                Write #1, CurrentXOver(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To CurrentXOver(x)
                    
                    Write #1, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, Decompress(XoverList(x, Y).Beginning), Decompress(XoverList(x, Y).Ending), XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag, XoverList(x, Y).PermPVal, XoverList(x, Y).ProgramFlag, XoverList(x, Y).LHolder, XoverList(x, Y).DHolder, XoverList(x, Y).BeginP, XoverList(x, Y).EndP, XoverList(x, Y).SBPFlag, XoverList(x, Y).Accept, XoverList(x, Y).Eventnumber
                    
                     
'XXXZZZ                      For Z = 0 To 2
'XXXZZZ                          Write #1, XOverlist(X, Y).TreePos(Z)
'XXXZZZ                      Next Z
                    'Write #1, XOverlist(X, Y).Eventnumber
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 40 + (x / PermNextno) * 20
                    Form1.Refresh
                    Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            Write #1, ""
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                ReDim BestXOListMi(PermNextno, UBXOMi)
                
                Open "RDP5BestXOListMi" + UFTag For Binary As #FF
                Get #FF, , BestXOListMi()
                Close #FF
                MiRec = 1
                ChDrive oDirX
                ChDir oDirX
                
            End If
            
            For x = 0 To PermNextno
                Write #1, BCurrentXoverMi(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To BCurrentXoverMi(x)
                    If BestXOListMi(x, Y).Ending > Len(StrainSeq(0)) Then
                        BestXOListMi(x, Y).Ending = Len(StrainSeq(0))
                    End If
                    Write #1, BestXOListMi(x, Y).Daughter, BestXOListMi(x, Y).MajorP, BestXOListMi(x, Y).MinorP, Decompress(BestXOListMi(x, Y).Beginning), Decompress(BestXOListMi(x, Y).Ending), BestXOListMi(x, Y).Probability, BestXOListMi(x, Y).OutsideFlag, BestXOListMi(x, Y).MissIdentifyFlag, BestXOListMi(x, Y).PermPVal, BestXOListMi(x, Y).ProgramFlag, BestXOListMi(x, Y).LHolder, BestXOListMi(x, Y).DHolder, BestXOListMi(x, Y).BeginP, BestXOListMi(x, Y).EndP, BestXOListMi(x, Y).SBPFlag, BestXOListMi(x, Y).Accept, BestXOListMi(x, Y).Eventnumber
                   
                    
                      
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 60 + (x / PermNextno) * 20
                    Form1.Refresh
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
                Erase BestXOListMi
                MiRec = MiRec - 1
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                
                ReDim BestXOListMa(PermNextno, UBXoMa)
                
                
                If MaRec < 1 Then
                    Open "RDP5BestXOListMa" + UFTag For Binary As #FF
                    Get #FF, , BestXOListMa()
                    Close #FF
                    MaRec = 1
                End If
                
                ChDrive oDirX
                ChDir oDirX
                
            End If
            
            Write #1, ""

            
            For x = 0 To PermNextno
                Write #1, BCurrentXoverMa(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To BCurrentXoverMa(x)
                    'XX = Len(StrainSeq(535))
                    If BestXOListMa(x, Y).Ending > Len(StrainSeq(0)) Then
                        BestXOListMa(x, Y).Ending = Len(StrainSeq(0))
                    End If
                    Write #1, BestXOListMa(x, Y).Daughter, BestXOListMa(x, Y).MajorP, BestXOListMa(x, Y).MinorP, Decompress(BestXOListMa(x, Y).Beginning), Decompress(BestXOListMa(x, Y).Ending), BestXOListMa(x, Y).Probability, BestXOListMa(x, Y).OutsideFlag, BestXOListMa(x, Y).MissIdentifyFlag, BestXOListMa(x, Y).PermPVal, BestXOListMa(x, Y).ProgramFlag, BestXOListMa(x, Y).LHolder, BestXOListMa(x, Y).DHolder, BestXOListMa(x, Y).BeginP, BestXOListMa(x, Y).EndP, BestXOListMa(x, Y).SBPFlag, BestXOListMa(x, Y).Accept, BestXOListMa(x, Y).Eventnumber
                    
                    
'XXXZZZ                      For Z = 0 To 2
'XXXZZZ                          Write #1, bestxolistma(X, Y).TreePos(Z)
'XXXZZZ                      Next Z
                    'Write #1, bestxolistma(X, Y).Eventnumber
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 80 + (x / PermNextno) * 20
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
                Erase BestXOListMa
                
                MaRec = MaRec - 1
            End If
            
            Write #1, SEventNumber, Eventnumber
            'SEventNumber = SEventNumber - 1
            For x = 0 To SEventNumber
                For Y = 0 To 2
                    Write #1, NOPINI(Y, x)
                Next Y
            Next x
            
            
            'ReDim Preserve DScores(13, 2, SEventNumber)
            
            For x = 0 To 25
                For Y = 0 To 2
                    For Z = 0 To SEventNumber
                        Write #1, DScores(x, Y, Z)
                    Next Z
                Next Y
            Next x
            'Eventnumber = Eventnumber - 1 'UBound(SuperEventlist, 1)
            
            
            For x = 0 To Eventnumber
                Write #1, SuperEventList(x)
            Next x
            
            
            
            Dim NumD As Long, NumMi As Long, NumMa As Long
            NumD = 0
            NumMi = 0
            NumMa = 0
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If Daught(Y, x) <> 0 Then
                        NumD = NumD + 1
                    End If
                    If MinorPar(Y, x) <> 0 Then
                        NumMi = NumMi + 1
                    End If
                    If MajorPar(Y, x) <> 0 Then
                        NumMa = NumMa + 1
                    End If
                Next x
            Next Y
            Write #1, NumD, NumMi, NumMa
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If Daught(Y, x) <> 0 Then
                        Write #1, Y, x, Daught(Y, x)
                    End If
                    
                Next x
            Next Y
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If MinorPar(Y, x) <> 0 Then
                        Write #1, Y, x, MinorPar(Y, x)
                    End If
                    
                Next x
            Next Y
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If MajorPar(Y, x) <> 0 Then
                        Write #1, Y, x, MajorPar(Y, x)
                    End If
                    
                Next x
            Next Y
            
'            For Y = 1 To SEventNumber
'                For X = 0 To PermNextno
'                    If X <= UBound(Daught, 2) Then
'                        Write #1, Daught(Y, X), MinorPar(Y, X), MajorPar(Y, X)
'                    Else
'                        Write #1, CInt(0), CInt(0), CInt(0)
'                    End If
'                Next X
'            Next Y
            
            'If ShortOutFlag <> 3 Then
                For x = 1 To SEventNumber
                    Write #1, BestEvent(x, 0), BestEvent(x, 1)
                    For Z = 0 To AddNum - 1
                        Write #1, Confirm(x, Z), ConfirmP(x, Z)
                    Next Z
                Next x
                For x = 1 To SEventNumber
                    For Z = 0 To AddNum - 1
                        Write #1, ConfirmMi(x, Z), ConfirmPMi(x, Z)
                    Next Z
                Next x
                For x = 1 To SEventNumber
                    For Z = 0 To AddNum - 1
                        Write #1, ConfirmMa(x, Z), ConfirmPMa(x, Z)
                    Next Z
                Next x
            'End If
            
            Write #1, StepNo
            
            For x = 0 To StepNo
                For Y = 0 To 4
                    Write #1, Steps(Y, x)
                Next Y
                
            Next x
            'If UBound(MultColour, 1) < NextNo Then
                ReDim Preserve MultColour(NextNo)
            'End If
            'If UBound(ColourSeq, 1) < NextNo Then
                ReDim Preserve ColourSeq(NextNo)
            'End If
            For x = 0 To PermNextno
                If x > UBound(MultColour, 1) Then
                    ReDim Preserve MultColour(x + 10)
                    ReDim Preserve ColourSeq(x + 10)
                End If
                Write #1, MultColour(x), ColourSeq(x)
            Next x
            ReDim Preserve TreeTestStats(3, SEventNumber)
            For x = 1 To SEventNumber
                For Y = 0 To 3
                    Write #1, TreeTestStats(Y, x)
                Next Y
            Next x
            
            
            Write #1, GPerms
            If GPerms > 0 Then
                
                For Z = 0 To GPerms
                    For x = 0 To PermNextno
                        For Y = 0 To PermsCurrentXOver(Z, x)
                            Write #1, PermsXOverList(Z, x, Y).Daughter, PermsXOverList(Z, x, Y).MajorP, PermsXOverList(Z, x, Y).MinorP, PermsXOverList(Z, x, Y).Beginning, PermsXOverList(Z, x, Y).Ending
                            Write #1, PermsXOverList(Z, x, Y).Probability, PermsXOverList(Z, x, Y).OutsideFlag, PermsXOverList(Z, x, Y).MissIdentifyFlag
                            Write #1, PermsXOverList(Z, x, Y).PermPVal, PermsXOverList(Z, x, Y).ProgramFlag
                            Write #1, PermsXOverList(Z, x, Y).LHolder, PermsXOverList(Z, x, Y).DHolder
                            Write #1, PermsXOverList(Z, x, Y).BeginP, PermsXOverList(Z, x, Y).EndP
                            Write #1, PermsXOverList(Z, x, Y).SBPFlag, PermsXOverList(Z, x, Y).Accept, PermsXOverList(Z, x, Y).Eventnumber
                        Next Y
                    Next x
                Next Z
            End If
            If FileList(1) <> sFName And sFName <> "LastSave.rdp5" Then

                If FileList(4) <> FileList(3) And FileList(3) <> sFName Then FileList(4) = FileList(3)

                If FileList(3) <> FileList(2) And FileList(2) <> sFName Then FileList(3) = FileList(2)

                If FileList(2) <> FileList(1) And FileList(1) <> sFName Then FileList(2) = FileList(1)
                FileList(1) = sFName
            End If

            If FileList(4) <> "" Then
                Form1.File4Mnu.Caption = FileList(4)
            Else
                Form1.File4Mnu.Caption = "--"
            End If

            If FileList(3) <> "" Then
                Form1.File3Mnu.Caption = FileList(3)
            Else
                Form1.File3Mnu.Caption = "--"
            End If
            
            If FileList(2) <> "" Then
                Form1.File2Mnu.Caption = FileList(2)
            Else
                Form1.File2Mnu.Caption = "--"
            End If

            If FileList(1) <> "" Then
                Form1.File1Mnu.Caption = FileList(1)
            Else
                Form1.File1Mnu.Caption = "--"
            End If
            
            If DebuggingFlag < 2 Then On Error Resume Next
            For x = 1 To SEventNumber
                For Y = 0 To 9
                'ReDim BPCIs(9, 100)
                    If x <= UBound(BPCIs, 2) Then
                        Write #1, BPCIs(Y, x)
                    End If
                Next Y
            Next x
            On Error GoTo 0
            
            'Save group information
            
            If DebuggingFlag < 2 Then On Error Resume Next
            Write #1, SelGrpFlag
            ReDim Preserve GrpMaskSeq(NextNo)
            If SelGrpFlag > 0 Then
                For x = 1 To NextNo
                    Write #1, GrpMaskSeq(x)
                Next x
            End If
            On Error GoTo 0
            'For X = 0 To RBPNum
            '                TBP = RBPPos(X)
            If DebuggingFlag < 2 Then On Error Resume Next
            Write #1, ReassortmentFlag
            If ReassortmentFlag = 1 Then
                Write #1, RBPNum
                For x = 0 To RBPNum
                    Write #1, RBPPos(x)
                Next x
            End If
            
            For x = 0 To AddNum - 1
                Write #1, MethodTime(x)
                
            Next x
            For x = 0 To AddNum - 1
                Write #1, TimeFract(x)
                
            Next x
            
            Write #1, RefNum
            If RefNum > 0 Then
                For x = 0 To PermNextno
                   
                    Write #1, ReferenceList(x)
                    
                
                Next x
                For x = 0 To RefNum
                    Write #1, RefGroupName(x)
                    Write #1, ReferenceCols(x)
                Next x
            End If
            '= MethodTime(X) + Abs(ET - SAll) * TimeFract(X)
            
            
            
            
            For x = 1 To SEventNumber
                Write #1, YannWarn(x)
            Next x
            
            
            
            
            
            On Error GoTo 0
            Close #1
            
            If NextNo > 1000 Then
                Dim SM() As Single
                Call UnModSeqNum(0)
                Call UnModNextno
                ReDim SM(NextNo, NextNo)
                For x = 0 To NextNo
                    For Y = x + 1 To NextNo
                        SM(x, Y) = PermValid(x, Y)
                        SM(Y, x) = PermDIffs(x, Y)
                    Next Y
                Next x
                Open sFName + "SM" For Binary As #1
                Put #1, , SM()
                Close
            End If
            
            Form1.ProgressBar1.Value = 100
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            
End Sub
Public Sub WriteRDPFile2(sFName As String)

Open sFName$ For Output As #1

            If SEventNumber = 0 Then
                Print #1, "No recombination detected"
                Close #1
                Exit Sub
            End If
            SaveFlag = 1
            Form1.SSPanel1.Caption = "Saving Sequence Data"
            Form1.ProgressBar1.Value = 20
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            'DoEvents
            'Print #1, SeqFile
            If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            
                For x = 0 To PermNextno
                    Print #1, ">" & OriginalName(x)
                    Print #1, StrainSeq(x)
                Next 'X
            Else
                Close #1
                Kill sFName$
                If DebuggingFlag < 2 Then On Error Resume Next

                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                
                Name BIGFilename As sFName$
                FileCopy sFName$, BIGFilename
                
                If DebuggingFlag < 2 Then On Error Resume Next

                
                ChDir oDir
                ChDrive oDir
               
                
                Open sFName$ For Append As #1
                
            End If

            If ORFFlag = 1 Then
                Form1.SSPanel1.Caption = "Saving Sequence Data"
                Form1.ProgressBar1.Value = 20
                Call UpdateF2Prog
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If

            Print #1, "GB Data"
            Print #1, GBFile
            Form1.SSPanel1.Caption = "Saving Recombination Data"
            Form1.ProgressBar1.Value = 40
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Write #1, "Recombination Data"
            Write #1, "r21"
            Write #1, pSpacerFlag, pCircularFlag, ShowPlotFlag, GPerms, PermTypeFlag, pXOverWindowX, LowestProb, MCFlag
            Write #1, SHWinLen, pGCIndelFlag, SHStep, pGCTripletflag
            Write #1, GCOutfileName
            Write #1, BSTreeStrat, BSupTest, GCSortFlag, GCTractLen, GCLogFlag
            Write #1, pGCMissmatchPen, SCHEMADistCO, SCHEMAPermNo, pGCMinFragLen, pGCMinPolyInFrag
            Write #1, pGCMinPairScore, pGCMaxOverlapFrags, ConservativeGroup, MaxTemperature, ntType
            Write #1, pBSStepWin, pBSStepSize, pBSCutoff, pBSBootReps, BSRndNumSeed, BSSubModelFlag
            Write #1, BSTTRatio, MCMCUpdates, BlockPen, StartRho, MatPermNo
            Write #1, DoScans(1, 2), DoScans(1, 5), FreqCo, MatWinSize, FreqCoMD
            Write #1, AllowConflict, 0, pMCSteplen, pMCWinSize
            Write #1, pDoScans(0, 0), pDoScans(0, 1), pDoScans(0, 2), pDoScans(0, 3), pDoScans(0, 4), pDoScans(0, 5)
            Write #1, FileList(1), FileList(2), FileList(3), FileList(4)
            Write #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
            Write #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
            Write #1, pMCWinFract, pMCProportionFlag, pMCTripletFlag, pMCStripGapsFlag, MCFullOR, MCFullOL
            Write #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
            Write #1, VisRDWin, ModelTestFlag
            Write #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
            Write #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
            Write #1, TOTreeType, TOFreqFlag, TOModel
            Write #1, pBSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
            Write #1, GCFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
            Write #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
            Write #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
            Write #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, pBSPValFlag, SSFastFlag, pSSGapFlag, pSSVarPFlag, pSSOutlyerFlag, pSSRndSeed, pSSWinLen, pSSStep, pSSNumPerms, pSSNumPerms2
            Write #1, ForcePhylE, PolishBPFlag, RealignFlag, ConsensusProg, pCWinFract, pCProportionFlag, pCWinSize, 0, 0
            Write #1, PPWinLen, pPPStripGaps, IncSelf, PPSeed, PPPerms, DoScans(0, 8)
            Write #1, TPTVRat, TPGamma, TPAlpha, TPInvSites, TPModel, TPBPFEstimate
            Write #1, TBModel, TBGamma, TBGammaCats, TBNGens, TBNChains, TBSampFreq, TBTemp, TBSwapFreq, TBSwapNum
            Write #1, MCCorrection
            
            
            Close #1
            Dim HeaderRDP As RDPHeader
            With HeaderRDP
'            Type RDPHeader
'
'                MaskSeqX As Long
                 .MaskSeqX = UBound(MaskSeq, 1)
'                CurrentXOverX As Long
                 .CurrentXOverX = UBound(CurrentXOver, 1)
'                XoverListX As Long
                 .XoverListX = UBound(XoverList, 1)
'                XOverListY As Long
                 .XOverListY = UBound(XoverList, 2)
'                BCurrentXOverMiX As Long
                 .BCurrentXOverMiX = UBound(BCurrentXoverMi, 1)
'                BestXOListMiX As Long
                 .BestXOListMiX = UBound(BestXOListMi, 1)
'                BestXOListMiY As Long
                 .BestXOListMiY = UBound(BestXOListMi, 2)
'                BCurrentXOverMaX As Long
                 .BCurrentXOverMaX = UBound(BCurrentXoverMa, 1)
'                BestXOListMaX As Long
                 .BestXOListMaX = UBound(BestXOListMa, 1)
'                BestXOListMaY As Long
                 .BestXOListMaY = UBound(BestXOListMa, 2)
'                SEventNumberA As Long
                 .SEventNumberA = SEventNumber
'                EventnumberA As Long
                 .EventnumberA = Eventnumber
'                NoPIniX As Long
'                NoPIniY As Long
'                DScoresX As Long
'                DScoresY As Long
'                DScoresZ As Long
'                SuperEventListX As Long
'                NumDA As Long
'                NumMiA As Long
'                NumMaA As Long
'                DaughtX As Long
'                DaughtY As Long
'                MinorParX As Long
'                MinorParY As Long
'                MajorParX As Long
'                MajorParY As Long
'                BestEventX As Long
'                BestEventY As Long
'                ConfirmX As Long
'                ConfirmY As Long
'                ConfirmPX As Long
'                ConfirmPY As Long
'                ConfirmMiX As Long
'                ConfirmMiY As Long
'                ConfirmPMiX As Long
'                ConfirmPMiY As Long
'                ConfirmMaX As Long
'                ConfirmMaY As Long
'                ConfirmPMaX As Long
'                ConfirmPMaY As Long
'                StepNoA As Long
'                StepSX As Long
'                StepSY As Long
'                MulColourX As Long
'                ColourSeqX As Long
'                TreeTestStatsX As Long
'                TreeTestStatsY As Long
'                GPermsA As Long
'                PermsXOListX As Long
'                PermsXOListY As Long
'                PermsXOListZ As Long
'                BPCIsX As Long
'                BPCIsY As Long
'                SelGrpFlagA As Long
'                GrpMaskSeqX As Long
'                ReassortmentFlagA As Long
'                RBPNumA As Long
'                RBPPosX As Long
'                MethodTimeX As Long
'                TimeFractX As Long
'                RefNumA As Long
'                ReferenceListX As Long
'                RefGroupNameX As Long
'                ReferenceColsX As Long
'                WorthWhileScanX As Long
'                Stuffer1 As Long
'                Stuffer2 As Long
'                Stuffer3 As Long
'                Stuffer4 As Long
'                Stuffer5 As Long
'                Stuffer6 As Long
'                Stuffer7 As Long
'                Stuffer8 As Long
'                Stuffer9 As Long
'                stuffer10 As Long
'                Stuffer11 As Long
'                Stuffer12 As Long
'                Stuffer13 As Long
'                Stuffer14 As Long
'                Stuffer15 As Long
'                Stuffer16 As Long
'                Stuffer17 As Long
'                Stuffer18 As Long
'                Stuffer19 As Long
'                stuffer20 As Long
'                Stuffer21 As Long
'                Stuffer22 As Long
'                Stuffer23 As Long
'                Stuffer24 As Long
'                Stuffer25 As Long
'                Stuffer26 As Long
'                Stuffer27 As Long
'                Stuffer28 As Long
'                Stuffer29 As Long
'
'            End Type
            End With
            For x = 0 To PermNextno
                Write #1, pMaskSeq(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno
                Write #1, CurrentXOver(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To CurrentXOver(x)
                    
                    Write #1, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, Decompress(XoverList(x, Y).Beginning), Decompress(XoverList(x, Y).Ending), XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag, XoverList(x, Y).PermPVal, XoverList(x, Y).ProgramFlag, XoverList(x, Y).LHolder, XoverList(x, Y).DHolder, XoverList(x, Y).BeginP, XoverList(x, Y).EndP, XoverList(x, Y).SBPFlag, XoverList(x, Y).Accept, XoverList(x, Y).Eventnumber
                    
                     
'XXXZZZ                      For Z = 0 To 2
'XXXZZZ                          Write #1, XOverlist(X, Y).TreePos(Z)
'XXXZZZ                      Next Z
                    'Write #1, XOverlist(X, Y).Eventnumber
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 40 + (x / PermNextno) * 20
                    Call UpdateF2Prog
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            Write #1, ""
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                ReDim BestXOListMi(PermNextno, UBXOMi)
                If MiRec < 1 Then
                    Open "RDP5BestXOListMi" + UFTag For Binary As #FF
                    Get #FF, , BestXOListMi()
                    Close #FF
                    MiRec = 1
                End If
                
                
                ChDrive oDirX
                ChDir oDirX
                
            End If
            
            For x = 0 To PermNextno
                Write #1, BCurrentXoverMi(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To BCurrentXoverMi(x)
                    If BestXOListMi(x, Y).Ending > Len(StrainSeq(0)) Then
                        BestXOListMi(x, Y).Ending = Len(StrainSeq(0))
                    End If
                    Write #1, BestXOListMi(x, Y).Daughter, BestXOListMi(x, Y).MajorP, BestXOListMi(x, Y).MinorP, Decompress(BestXOListMi(x, Y).Beginning), Decompress(BestXOListMi(x, Y).Ending), BestXOListMi(x, Y).Probability, BestXOListMi(x, Y).OutsideFlag, BestXOListMi(x, Y).MissIdentifyFlag, BestXOListMi(x, Y).PermPVal, BestXOListMi(x, Y).ProgramFlag, BestXOListMi(x, Y).LHolder, BestXOListMi(x, Y).DHolder, BestXOListMi(x, Y).BeginP, BestXOListMi(x, Y).EndP, BestXOListMi(x, Y).SBPFlag, BestXOListMi(x, Y).Accept, BestXOListMi(x, Y).Eventnumber
                   
                    
                      
                Next 'y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 60 + (x / PermNextno) * 20
                    Call UpdateF2Prog
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
                Erase BestXOListMi
                MiRec = MiRec - 1
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                
                ReDim BestXOListMa(PermNextno, UBXoMa)
                
                
                If MaRec < 1 Then
                    Open "RDP5BestXOListMa" + UFTag For Binary As #FF
                    Get #FF, , BestXOListMa()
                    Close #FF
                    MaRec = 1
                End If
                ChDrive oDirX
                ChDir oDirX
                
            End If
            
            Write #1, ""

            
            For x = 0 To PermNextno
                Write #1, BCurrentXoverMa(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To BCurrentXoverMa(x)
                    If BestXOListMa(x, Y).Ending > Len(StrainSeq(0)) Then
                        BestXOListMa(x, Y).Ending = Len(StrainSeq(0))
                    End If
                    Write #1, BestXOListMa(x, Y).Daughter, BestXOListMa(x, Y).MajorP, BestXOListMa(x, Y).MinorP, Decompress(BestXOListMa(x, Y).Beginning), Decompress(BestXOListMa(x, Y).Ending), BestXOListMa(x, Y).Probability, BestXOListMa(x, Y).OutsideFlag, BestXOListMa(x, Y).MissIdentifyFlag, BestXOListMa(x, Y).PermPVal, BestXOListMa(x, Y).ProgramFlag, BestXOListMa(x, Y).LHolder, BestXOListMa(x, Y).DHolder, BestXOListMa(x, Y).BeginP, BestXOListMa(x, Y).EndP, BestXOListMa(x, Y).SBPFlag, BestXOListMa(x, Y).Accept, BestXOListMa(x, Y).Eventnumber
                   
                    
                      
                Next 'y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 80 + (x / PermNextno) * 20
                    Form1.Refresh
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
                Erase BestXOListMa
                MaRec = MaRec - 1
                
            End If
            
            Write #1, SEventNumber, Eventnumber
            'SEventNumber = SEventNumber - 1
            For x = 0 To SEventNumber
                For Y = 0 To 2
                    Write #1, NOPINI(Y, x)
                Next Y
            Next x
            
            
            'ReDim Preserve DScores(13, 2, SEventNumber)
            
            For x = 0 To 25
                For Y = 0 To 2
                    For Z = 0 To SEventNumber
                        Write #1, DScores(x, Y, Z)
                    Next Z
                Next Y
            Next x
            'Eventnumber = Eventnumber - 1 'UBound(SuperEventlist, 1)
            For x = 0 To Eventnumber
                Write #1, SuperEventList(x)
            Next x
            
            
            
            Dim NumD As Long, NumMi As Long, NumMa As Long
            NumD = 0
            NumMi = 0
            NumMa = 0
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If Daught(Y, x) <> 0 Then
                        NumD = NumD + 1
                    End If
                    If MinorPar(Y, x) <> 0 Then
                        NumMi = NumMi + 1
                    End If
                    If MajorPar(Y, x) <> 0 Then
                        NumMa = NumMa + 1
                    End If
                Next x
            Next Y
            Write #1, NumD, NumMi, NumMa
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If Daught(Y, x) <> 0 Then
                        Write #1, Y, x, Daught(Y, x)
                    End If
                    
                Next x
            Next Y
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If MinorPar(Y, x) <> 0 Then
                        Write #1, Y, x, MinorPar(Y, x)
                    End If
                    
                Next x
            Next Y
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If MajorPar(Y, x) <> 0 Then
                        Write #1, Y, x, MajorPar(Y, x)
                    End If
                    
                Next x
            Next Y
            
'            For Y = 1 To SEventNumber
'                For X = 0 To PermNextno
'                    If X <= UBound(Daught, 2) Then
'                        Write #1, Daught(Y, X), MinorPar(Y, X), MajorPar(Y, X)
'                    Else
'                        Write #1, CInt(0), CInt(0), CInt(0)
'                    End If
'                Next X
'            Next Y
            
            'If ShortOutFlag <> 3 Then
                For x = 1 To SEventNumber
                    Write #1, BestEvent(x, 0), BestEvent(x, 1)
                    For Z = 0 To AddNum - 1
                        Write #1, Confirm(x, Z), ConfirmP(x, Z)
                    Next Z
                Next x
                For x = 1 To SEventNumber
                    For Z = 0 To AddNum - 1
                        Write #1, ConfirmMi(x, Z), ConfirmPMi(x, Z)
                    Next Z
                Next x
                For x = 1 To SEventNumber
                    For Z = 0 To AddNum - 1
                        Write #1, ConfirmMa(x, Z), ConfirmPMa(x, Z)
                    Next Z
                Next x
            'End If
            
            Write #1, StepNo
            
            For x = 0 To StepNo
                For Y = 0 To 4
                    Write #1, Steps(Y, x)
                Next Y
                
            Next x
            'If UBound(MultColour, 1) < NextNo Then
                ReDim Preserve MultColour(NextNo)
            'End If
            'If UBound(ColourSeq, 1) < NextNo Then
                ReDim Preserve ColourSeq(NextNo)
            'End If
            For x = 0 To PermNextno
                If x > UBound(MultColour, 1) Then
                    ReDim Preserve MultColour(x + 10)
                    ReDim Preserve ColourSeq(x + 10)
                End If
                Write #1, MultColour(x), ColourSeq(x)
            Next x
            ReDim Preserve TreeTestStats(3, SEventNumber)
            For x = 1 To SEventNumber
                For Y = 0 To 3
                    Write #1, TreeTestStats(Y, x)
                Next Y
            Next x
            
            
            Write #1, GPerms
            If GPerms > 0 Then
                
                For Z = 0 To GPerms
                    For x = 0 To PermNextno
                        For Y = 0 To PermsCurrentXOver(Z, x)
                            Write #1, PermsXOverList(Z, x, Y).Daughter, PermsXOverList(Z, x, Y).MajorP, PermsXOverList(Z, x, Y).MinorP, PermsXOverList(Z, x, Y).Beginning, PermsXOverList(Z, x, Y).Ending
                            Write #1, PermsXOverList(Z, x, Y).Probability, PermsXOverList(Z, x, Y).OutsideFlag, PermsXOverList(Z, x, Y).MissIdentifyFlag
                            Write #1, PermsXOverList(Z, x, Y).PermPVal, PermsXOverList(Z, x, Y).ProgramFlag
                            Write #1, PermsXOverList(Z, x, Y).LHolder, PermsXOverList(Z, x, Y).DHolder
                            Write #1, PermsXOverList(Z, x, Y).BeginP, PermsXOverList(Z, x, Y).EndP
                            Write #1, PermsXOverList(Z, x, Y).SBPFlag, PermsXOverList(Z, x, Y).Accept, PermsXOverList(Z, x, Y).Eventnumber
                        Next Y
                    Next x
                Next Z
            End If
            If FileList(1) <> sFName And sFName <> "LastSave.rdp5" Then

                If FileList(4) <> FileList(3) And FileList(3) <> sFName Then FileList(4) = FileList(3)

                If FileList(3) <> FileList(2) And FileList(2) <> sFName Then FileList(3) = FileList(2)

                If FileList(2) <> FileList(1) And FileList(1) <> sFName Then FileList(2) = FileList(1)
                FileList(1) = sFName
            End If

            If FileList(4) <> "" Then
                Form1.File4Mnu.Caption = FileList(4)
            Else
                Form1.File4Mnu.Caption = "--"
            End If

            If FileList(3) <> "" Then
                Form1.File3Mnu.Caption = FileList(3)
            Else
                Form1.File3Mnu.Caption = "--"
            End If
            
            If FileList(2) <> "" Then
                Form1.File2Mnu.Caption = FileList(2)
            Else
                Form1.File2Mnu.Caption = "--"
            End If

            If FileList(1) <> "" Then
                Form1.File1Mnu.Caption = FileList(1)
            Else
                Form1.File1Mnu.Caption = "--"
            End If
            
            If DebuggingFlag < 2 Then On Error Resume Next
            For x = 1 To SEventNumber
                For Y = 0 To 9
                'ReDim BPCIs(9, 100)
                    If x <= UBound(BPCIs, 2) Then
                        Write #1, BPCIs(Y, x)
                    End If
                Next Y
            Next x
            On Error GoTo 0
            
            'Save group information
            
            If DebuggingFlag < 2 Then On Error Resume Next
            Write #1, SelGrpFlag
            ReDim Preserve GrpMaskSeq(NextNo)
            If SelGrpFlag > 0 Then
                For x = 1 To NextNo
                    Write #1, GrpMaskSeq(x)
                Next x
            End If
            On Error GoTo 0
            'For X = 0 To RBPNum
            '                TBP = RBPPos(X)
            If DebuggingFlag < 2 Then On Error Resume Next
            Write #1, ReassortmentFlag
            If ReassortmentFlag = 1 Then
                Write #1, RBPNum
                For x = 0 To RBPNum
                    Write #1, RBPPos(x)
                Next x
            End If
            
            For x = 0 To AddNum - 1
                Write #1, MethodTime(x)
                
            Next x
            For x = 0 To AddNum - 1
                Write #1, TimeFract(x)
                
            Next x
            
            Write #1, RefNum
            If RefNum > 0 Then
                For x = 0 To PermNextno
                   
                    Write #1, ReferenceList(x)
                    
                
                Next x
                For x = 0 To RefNum
                    Write #1, RefGroupName(x)
                    Write #1, ReferenceCols(x)
                Next x
            End If
            '= MethodTime(X) + Abs(ET - SAll) * TimeFract(X)
            
            On Error GoTo 0
            Close #1
            
            If NextNo > 1000 Then
                Dim SM() As Single
                Call UnModSeqNum(0)
                Call UnModNextno
                ReDim SM(NextNo, NextNo)
                For x = 0 To NextNo
                    For Y = x + 1 To NextNo
                        SM(x, Y) = PermValid(x, Y)
                        SM(Y, x) = PermDIffs(x, Y)
                    Next Y
                Next x
                Open sFName + "SM" For Binary As #1
                Put #1, , SM()
                Close
            End If
            
            Form1.ProgressBar1.Value = 100
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Call UpdateF2Prog
            
End Sub
Public Sub ReadRDP5FileA()
SSS = Abs(GetTickCount)
'73 megs
Dim FileSeqString As String, oDir As String, x As Long, XX As Variant, FLength As Long, DummyFileList As String, CompressF As Long, FF As Long, FF2 As Long, LSeq As Long, TName As String, LongHold As Long, UB1 As Long, UB2 As Long, UB3 As Long, UB4 As Long, UB5 As Long, UB6 As Long, UB7 As Long
SeqFile = ""
Close #1
DummyFileList = String(1000, " ")

FF = FreeFile
Open FName$ For Binary As #FF
TName = String(17, " ")
Get #FF, , TName
Get #FF, , NextNo
Get #FF, , LSeq
Get #FF, , CompressF

'NextNo = 9
'PermNextno = NextNo
ReDim OriginalName(NextNo)
For x = 0 To NextNo
   OriginalName(x) = String(100, " ")
Next x

Get #FF, , OriginalName()
'
For x = 0 To NextNo
    OriginalName(x) = Trim(OriginalName(x))
    'XX = Len(OriginalName(x))
Next x


ReDim StraiName(NextNo)
For x = 0 To NextNo
   StraiName(x) = String(100, " ")
Next x

Dim CP As Long, ChrTot As Integer, CHRVAL As Long
CP = Seek(FF)
Get #FF, , StraiName(0)
ChrTot = 0
For x = 1 To 100
    CHRVAL = Asc(Mid(StraiName(0), x, 1))
    If CHRVAL >= 32 And CHRVAL <= 126 Then
        ChrTot = ChrTot + 1
    
    End If
    
Next x
If ChrTot > 88 Then
    Get #FF, CP, StraiName()

    For x = 0 To NextNo
    'XX = Len(StraiName(0))
        StraiName(x) = Trim(StraiName(x))
        
    Next x
    'check to see if strainame contains names or sequences
'    Dim ASCCode() As Long, NT As Long, NonNT As Long
'    ReDim ASCCode(255)
'    NT = 0: NonNT = 0
'    For Z = 1 To NextNo
'        For x = 0 To 255
'            Pos = InStr(1, StraiName(Z), Chr(x), vbBinaryCompare)
'            If Pos > 0 Then ASCCode(x) = ASCCode(x) + 1
'        Next x
'    Next Z
'    XX = StraiName(4)
'    For x = 0 To 255
'        If ASCCode(x) <> 0 Then
'            x = x
'        End If
'        If x <> 45 And x <> 64 And x <> 66 And x <> 72 And x <> 82 Then
'            NonNT = NonNT + ASCCode(x)
'        Else
'            NT = NT + ASCCode(x)
'        End If
'    Next x
'    If NT > NextNo And NonNT < NextNo Then
'        x = x
'    End If
    'If CompressF = 0 Or x = x Then
    'XX = NextNo
    Get #FF, , UB1
    
    If UB1 > NextNo * 10 And UB1 > Len(StraiName(0)) * 2 Or UB1 = 0 Then
        Dim CP2 As Long
        CP2 = Seek(FF)
        For x = CP2 - 100 To CP2 + 100
            Get #FF, x, UB1
            If UB1 = NextNo Then
                Exit For
            End If
        Next x
    End If
    x = x
'    Else
'        Get #FF, , UB1
'        ReDim StrainSeq(UB1)
'        Get #FF, , UB2
'        For x = 0 To NextNo
'            StrainSeq(x) = String(UB2, " ")
'        Next x
'        'StrainSeq(0) = String(UB2, " ")
'        Get #FF, , StrainSeq()
'    End If
Else
    'accounts for older versions where strainame wasnt saved
    'XX = CompressF
    For x = 0 To NextNo
        StraiName(x) = OriginalName(x)
    Next x
    'CP = CP - CP / 2
    Get #FF, CP, UB1
    If UB1 = 0 Then
        Close #FF
        Exit Sub
    End If
'    Do
'
'        '5342949
'
'        Get #FF, CP, UB1
'        If UB1 <> 0 Then
'            x = x
'        End If
'        If UB1 = NextNo Then Exit Do
'        CP = CP + 1
'        DoEvents
'    Loop
'    If UB1 = 0 Then
'        Get #FF, , UB1
'    End If
End If


'XX = StraiName(0)

If UB1 > UBound(StraiName, 1) * 2 Then
    Exit Sub
End If
    

ReDim StrainSeq(UB1)

Get #FF, , UB2

If UB2 > 0 Then
    For x = 0 To NextNo
        StrainSeq(x) = String(UB2, " ")
    Next x
End If

Get #FF, , StrainSeq()
'141 Megs urmilla


If CompressF = 1 Then

    'need to save a version of the uncompressed sequences
    FF2 = FreeFile
'    ReadLen = PrintSeqLen * (Nextno + 1)
'    ReadStart = WinLeft * (Nextno + 1) - (Nextno + 1) + 1
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    'XX = StrainSeq(3)
    'XX = Len(StrainSeq(190))
    XX = FF2
    Open "RDP5Longseq" + UFTag For Binary As #FF2
    FLength = LOF(FF)
    Dim FileBin() As Byte, UBFB As Long
    Get #FF, , UBFB
    If UBFB > 200000000 Then BigFileFlag = 1
    ReDim FileBin(20000000)
    'FileSeqString = String(FLength, " ")
    'Get #FF2, , FileSeqString
    
    Dim Numreads As Single
    'Numreads = CLng((UBFB / 10000000) + 1)
    Get #FF, , Numreads
'    AA = Form1.Timer1.Enabled
'    BB = Form1.Timer2.Enabled '1
'    CC = Form1.Timer3.Enabled '2
'    dd = Form1.Timer4.Enabled
'    EE = Form1.Timer6.Enabled
    EE = Abs(GetTickCount)
    For x = 1 To Numreads
        Get #FF, , FileBin()
        Put #FF2, , FileBin()
        SS = Abs(GetTickCount)
        If Abs(SS - EE) > 500 Then
            EE = SS
            Form1.SSPanel1.Caption = "Loaded " + Str(CLng((x / Numreads) * 100)) + "% of nucleotides"
            If DebuggingFlag < 2 Or x = x Then Form1.WindowState = Form1.WindowState
            'Sleep 1
        End If
        
    Next x
    
    'Get #FF, , FileBin()
'    ChDrive oDir
'    ChDir oDir
'    DoEvents
'    ChDrive App.Path
'    ChDir App.Path
    'Put #FF2, , FileBin()
    Erase FileBin
    Close #FF2
   ' X = X
    Dim UBBFO1 As Long, UBBFO2 As Long
    
    Get #FF, , UBBFO1
    Get #FF, , UBBFO2
    ReDim BigFileOffsets(UBBFO1, UBBFO2)
    
    Get #FF, , BigFileOffsets()
    BIGFilename = "tempSeqx"
    
    Open BIGFilename For Binary As #FF2
    Get #FF, , UBFB
    
    ReDim FileBin(10000000)
    Get #FF, , Numreads ' = CLng((UBFB / 1000000) + 1)
    
    'ReDim FileBin(UBFB)
    For x = 1 To Numreads
        Get FF, , FileBin()
        Put #FF2, , FileBin()
        SS = Abs(GetTickCount)
        If Abs(SS - EE) > 500 Then
            EE = SS
            Form1.SSPanel1.Caption = "Compressed and resaved " + Str(CLng((x / Numreads) * 100)) + "% of nucleotides"
            If DebuggingFlag < 2 Or x = x Then Form1.WindowState = Form1.WindowState
        End If
    Next x
    
'    ChDrive oDir
'    ChDir oDir
'    'DoEvents
'    ChDrive App.Path
'    ChDir App.Path
    
    Erase FileBin
    Close #FF2
    Dim UBSS1 As Long
    Dim UBSS2 As Long
    Get #FF, , SeqSpacesInFileFlag
    
    If SeqSpacesInFileFlag = 0 Then
    
        Get #FF, , UBSS1
        Get #FF, , UBSS2
        ReDim SeqSpaces(UBSS1, UBSS2)
        Get #FF, , SeqSpaces()
    Else
        FF2 = FreeFile
                                           
        Open "RDP5SSFile" + UFTag For Binary As #FF2
        XX = Len(StrainSeq(0))
        Get #FF, , UBSS1 '28756
        Get #FF, , UBSS2 '90
        
        ReDim SeqSpaces(UBSS1)
        'need to transfer sequences one at a time (there was probably a good reason that seqspaces info was being stored in a file and not in ram)
        For x = 0 To UBSS2
            Get #FF, , SeqSpaces()
            Put #FF2, , SeqSpaces()
        Next x
        Close #FF2
        
        Erase SeqSpaces()
        
    End If
    SeqSpacesTempFlag = 3
    
    'FileSeqString = ""
    ChDrive oDir
    ChDir oDir
    
End If


'For X = 1 To 10000
Get #FF, , UB1
'If UB1 > 0 Then '1141,1142
'    X = X
'End If
'Next X
'Get #FF, , UB1
ReDim Decompress(UB1)
Get #FF, , Decompress()


Get #FF, , UB1
ReDim Recompress(UB1)
Get #FF, , Recompress()

'UB1 = UBound(ABCons, 1)
Get #FF, , UB1
ReDim ABCons(UB1)
Get #FF, , ABCons()


MidPosRDP = Seek(FF)




Close #FF


'If Nextno > 1000 Then
'    Dim SM() As Single
'    Call UnModSeqNum(0)
'    Call UnModNextno
'    ReDim SM(Nextno, Nextno)
'    For X = 0 To Nextno
'        For Y = X + 1 To Nextno
'            SM(X, Y) = PermValid(X, Y)
'            SM(Y, X) = PermDiffs(X, Y)
'        Next Y
'    Next X
'    Open SFName + "SM" For Binary As #1
'    Get #FF, , SM()
'    Close #FF
'End If
'141 megs Urmilla
x = x
'249 gigs Urmilla
FF = FreeFile
EEE = Abs(GetTickCount)
ttt = EEE - SSS '34094
x = x
End Sub
Public Sub SplitP(Inval As Long, LongOut As Long, ShortOut As Long)
Dim V3 As Variant
LongOut = Int(Inval / 3000)

V3 = Inval - LongOut * 3000
ShortOut = Int(Abs(V3) - 1)
End Sub
Public Function CombineP(LongIn As Long, ShortIn As Long) As Long

CombineP = (ShortIn + 1) + LongIn * 3000

'ValX = (ValX - Int(ValX)) * 1000000



End Function
Public Sub ReadRDP5FileB(MidPosInRDPFile As Long)


Dim FileSeqString As String, oDir As String, x As Long, XX As Variant, FLength As Long, DummyFileList As String, CompressF As Long, FF As Long, FF2 As Long, LSeq As Long, TName As String, LongHold As Long, UB1 As Long, UB2 As Long, UB3 As Long, UB4 As Long, UB5 As Long, UB6 As Long, UB7 As Long

 '480.4 Mags
FF = FreeFile
Open FName$ For Binary As #FF
Get #FF, MidPosInRDPFile, ORFFlag
If ORFFlag = 1 Then
    Get #FF, , GeneNumber
    Get #FF, , UB1
    ReDim GeneList(UB1), ColBump(UB1)
    Get #FF, , GeneList()
    Get #FF, , UB1
    Get #FF, , UB2
    Get #FF, , UB3
    ReDim GeneSEPos(UB1, UB2, UB3)
    Get #FF, , GeneSEPos()
    ReDim ORFWin(3, Len(StrainSeq(0)))
    Call DrawORFs
End If


'482.1 Megs

Get #FF, , pSpacerFlag
Get #FF, , pCircularFlag
Get #FF, , ShowPlotFlag
Get #FF, , GPerms
Get #FF, , PermTypeFlag
Get #FF, , pXOverWindowX
Get #FF, , LowestProb
Get #FF, , MCFlag
Get #FF, , SHWinLen
Get #FF, , pGCIndelFlag
Get #FF, , SHStep
Get #FF, , pGCTripletflag
Get #FF, , GCOutfileName
Get #FF, , BSTreeStrat
Get #FF, , BSupTest
Get #FF, , GCSortFlag
Get #FF, , GCTractLen
Get #FF, , GCLogFlag
Get #FF, , pGCMissmatchPen
Get #FF, , SCHEMADistCO
Get #FF, , SCHEMAPermNo
Get #FF, , pGCMinFragLen
Get #FF, , pGCMinPolyInFrag
Get #FF, , pGCMinPairScore
Get #FF, , pGCMaxOverlapFrags
Get #FF, , ConservativeGroup
Get #FF, , MaxTemperature
Get #FF, , ntType
Get #FF, , pBSStepWin
Get #FF, , pBSStepSize
Get #FF, , pBSCutoff
Get #FF, , pBSBootReps
Get #FF, , BSRndNumSeed
Get #FF, , BSSubModelFlag
Get #FF, , BSTTRatio
Get #FF, , MCMCUpdates
Get #FF, , BlockPen
Get #FF, , StartRho
Get #FF, , MatPermNo
Get #FF, , DoScans(1, 2)
Get #FF, , DoScans(1, 5)
Get #FF, , FreqCo
Get #FF, , MatWinSize
Get #FF, , FreqCoMD
Get #FF, , AllowConflict
Get #FF, , LongHold
Get #FF, , pMCSteplen
Get #FF, , pMCWinSize
Get #FF, , pDoScans(0, 0)
Get #FF, , pDoScans(0, 1)
Get #FF, , pDoScans(0, 2)
Get #FF, , pDoScans(0, 3)
Get #FF, , pDoScans(0, 4)
Get #FF, , pDoScans(0, 5)
'Get #FF, , DummyFileList 'FileList(1) + String(1000 - Len(FileList(1)), " ")
'Get #FF, , DummyFileList 'FileList(2) + String(1000 - Len(FileList(2)), " ")
'Get #FF, , DummyFileList 'FileList(3) + String(1000 - Len(FileList(3)), " ")
'Get #FF, , DummyFileList 'FileList(4) + String(1000 - Len(FileList(4)), " ")
Get #FF, , LRDModel
Get #FF, , LRDCategs
Get #FF, , LRDShape
Get #FF, , LRDTvRat
Get #FF, , LRDACCoeff
Get #FF, , LRDAGCoeff
Get #FF, , LRDATCoeff
Get #FF, , LRDCGCoeff
Get #FF, , LRDCTCoeff
Get #FF, , LRDGTCoeff
Get #FF, , LRDBaseFreqFlag
Get #FF, , LRDAFreq
Get #FF, , LRDCFreq
Get #FF, , LRDGFreq
Get #FF, , LRDTFreq
Get #FF, , LRDCodon1
Get #FF, , LRDCodon2
Get #FF, , LRDCodon3
Get #FF, , LRDStep
Get #FF, , LRDRegion
Get #FF, , pMCWinFract
Get #FF, , pMCProportionFlag
Get #FF, , pMCTripletFlag
Get #FF, , pMCStripGapsFlag
Get #FF, , MCFullOR
Get #FF, , MCFullOL
Get #FF, , DPModelFlag
Get #FF, , DPWindow
Get #FF, , DPStep
Get #FF, , DPTVRatio
Get #FF, , DPBFreqFlag
Get #FF, , DPBFreqA
Get #FF, , DPBFreqC
Get #FF, , DPBFreqG
Get #FF, , DPBFreqT
Get #FF, , VisRDWin
Get #FF, , ModelTestFlag
Get #FF, , TOWinLen
Get #FF, , TOStepSize
Get #FF, , TOSmooth
Get #FF, , TOTvTs
Get #FF, , TOPower
Get #FF, , TORndNum
Get #FF, , TOPerms
Get #FF, , TOPValCOff
Get #FF, , TOFreqA
Get #FF, , TOFreqC
Get #FF, , TOFreqG
Get #FF, , TOFreqT
Get #FF, , TOTreeType
Get #FF, , TOFreqFlag
Get #FF, , TOModel
Get #FF, , pBSTypeFlag
Get #FF, , BSFreqFlag
Get #FF, , BSFreqA
Get #FF, , BSFreqC
Get #FF, , BSFreqG
Get #FF, , BSFreqT
Get #FF, , GCFlag
Get #FF, , BSCoeffVar
Get #FF, , DPCoeffVar
Get #FF, , TOCoeffVar
Get #FF, , TBSReps
Get #FF, , TRndSeed
Get #FF, , TTVRat
Get #FF, , TModel
Get #FF, , TCoeffVar
Get #FF, , TBaseFreqFlag
Get #FF, , TAfreq
Get #FF, , TCFreq
Get #FF, , TGFreq
Get #FF, , TTFreq
Get #FF, , TPower
Get #FF, , TNegBLFlag
Get #FF, , TSubRepsFlag
Get #FF, , TGRFlag
Get #FF, , TRndIOrderFlag
Get #FF, , pBSPValFlag
Get #FF, , SSFastFlag
Get #FF, , pSSGapFlag
Get #FF, , pSSVarPFlag
Get #FF, , pSSOutlyerFlag
Get #FF, , pSSRndSeed
Get #FF, , pSSWinLen
Get #FF, , pSSStep
Get #FF, , pSSNumPerms
Get #FF, , pSSNumPerms2
Get #FF, , ForcePhylE
Get #FF, , PolishBPFlag
Get #FF, , RealignFlag
Get #FF, , ConsensusProg
Get #FF, , pCWinFract
Get #FF, , pCProportionFlag
Get #FF, , pCWinSize
Get #FF, , LongHold
Get #FF, , LongHold
Get #FF, , PPWinLen
Get #FF, , pPPStripGaps
Get #FF, , IncSelf
Get #FF, , PPSeed
Get #FF, , PPPerms
Get #FF, , DoScans(0, 8)
Get #FF, , TPTVRat
Get #FF, , TPGamma
Get #FF, , TPAlpha
Get #FF, , TPInvSites
Get #FF, , TPModel
Get #FF, , TPBPFEstimate
Get #FF, , TBModel
Get #FF, , TBGamma
Get #FF, , TBGammaCats
Get #FF, , TBNGens
Get #FF, , TBNChains
Get #FF, , TBSampFreq
Get #FF, , TBTemp
Get #FF, , TBSwapFreq
Get #FF, , TBSwapNum

'Other settings
Get #FF, , MCCorrection
'482.1

Get #FF, , UB1
ReDim pMaskSeq(UB1)
Get #FF, , pMaskSeq()
ReDim MaskSeq(UB1)
For x = 0 To UB1
    MaskSeq(x) = pMaskSeq(x)
Next x


'save recombinationInfo
ReDim CurrentXOver(NextNo)
Get #FF, , CurrentXOver()
'482.1 Megs
Get #FF, , UB1
Get #FF, , UB2
ReDim XoverList(UB1, UB2)
Get #FF, , XoverList
'483.5 Megs
Get #FF, , XOMiMaInFileFlag
'XOMiMaInFileFlag = 0
ReDim BCurrentXoverMi(NextNo)
Get #FF, , BCurrentXoverMi()
Get #FF, , UB1
Get #FF, , UB2
ReDim BestXOListMi(UB1, UB2)

'@
Get #FF, , BestXOListMi()
MiRec = 1
For x = 0 To NextNo '693,1; 703,1

        If BCurrentXoverMi(x) > 0 Then

            For Y = 1 To BCurrentXoverMi(x)
                If BestXOListMi(x, Y).Eventnumber = 0 Then '709,12

                    x = x
                End If
            Next Y
        End If
    Next x

UBXOMi = UB2

'499.7 Megs

If XOMiMaInFileFlag = 1 Or (PermNextno > MemPoc And x = 1234567 And SEventNumber > 300) Then
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    Open "RDP5BestXOListMi" + UFTag For Binary As #FF2
    Put #FF2, , BestXOListMi()
    Close #FF2
    MiRec = MiRec - 1
    ChDrive oDir
    ChDir oDir
    XOMiMaInFileFlag = 1
    Erase BestXOListMi
End If
'XX = UBound(BestXOListMi, 1)
'483.5 Megs
ReDim BCurrentXoverMa(NextNo)
Get #FF, , BCurrentXoverMa()
Get #FF, , UB1
Get #FF, , UB2

ReDim BestXOListMa(UB1, UB2)
Get #FF, , BestXOListMa()
MaRec = 1

UBXoMa = UB2
'XX = Maskseq(703)
'XX = BCurrentXoverMa(703)
'XX = BestXOListMa(703, 3).MinorP



    For x = 0 To NextNo '693,1; 703,1
        If BCurrentXoverMa(x) > 0 Then

            For Y = 1 To BCurrentXoverMa(x)
                If BestXOListMa(x, Y).Eventnumber = 0 Then '709,12

                    x = x
                End If
            Next Y
        End If
        
    Next x
If XOMiMaInFileFlag = 1 Then
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    Open "RDP5BestXOListMa" + UFTag For Binary As #FF2
    Put #FF2, , BestXOListMa()
    MaRec = MaRec - 1
    Close #FF2
    ChDrive oDir
    ChDir oDir
    Erase BestXOListMa
End If
'483.5 Megs

Get #FF, , UB1
Get #FF, , UB2
If UB1 > -1 And UB2 > -1 Then
    ReDim NOPINI(UB1, UB2)
    Get #FF, , SEventNumber
    Get #FF, , Eventnumber
    Get #FF, , NOPINI()
    If UBound(NOPINI, 1) = 0 Then
        ReDim NOPINI(2, 0)
    End If
End If


'483.5 Megs
Get #FF, , UB1
Get #FF, , UB2
Get #FF, , UB3

ReDim DScores(UB1, UB2, UB3)
Get #FF, , DScores()
If UB1 <> 25 Or UB2 <> 2 Then
    ReDim DScores(25, 2, 0)
End If
'483.5 Megs
Get #FF, , UB1
ReDim SuperEventList(UB1)
Get #FF, , SuperEventList()
'483.5 Megs
Get #FF, , UB1
Get #FF, , UB2
ReDim Daught(UB1, UB2)
Get #FF, , Daught()


Get #FF, , UB1
Get #FF, , UB2
ReDim MinorPar(UB1, UB2)
Get #FF, , MinorPar()


Get #FF, , UB1
Get #FF, , UB2
ReDim MajorPar(UB1, UB2)
Get #FF, , MajorPar()
'486 Megs

Get #FF, , UB1
Get #FF, , UB2
ReDim BestEvent(UB1, UB2)
Get #FF, , BestEvent()


Get #FF, , UB1
Get #FF, , UB2
ReDim Confirm(UB1, UB2)
Get #FF, , Confirm()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmP(UB1, UB2)
Get #FF, , ConfirmP()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmMi(UB1, UB2)
Get #FF, , ConfirmMi()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmPMi(UB1, UB2)
Get #FF, , ConfirmPMi()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmMa(UB1, UB2)
Get #FF, , ConfirmMa()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmPMa(UB1, UB2)
Get #FF, , ConfirmPMa()

'497 Megs

Get #FF, , StepNo

Get #FF, , UB1
Get #FF, , UB2
ReDim Steps(UB1, UB2)
Get #FF, , Steps()

If UBound(Steps, 1) = 0 Then
    ReDim Steps(4, 0)
End If
'497.7 Megs

Get #FF, , UB1
ReDim MultColour(UB1)
Get #FF, , MultColour()


Get #FF, , UB1
If UB1 > -1 Then
    ReDim ColourSeq(UB1)
    Get #FF, , ColourSeq()
End If
'497.7

Get #FF, , UB1
Get #FF, , UB2
ReDim TreeTestStats(UB1, UB2)
Get #FF, , TreeTestStats()

Get #FF, , GPerms

Get #FF, , UB1
Get #FF, , UB2
'497.7 Megs
If UB1 > 0 Then
    ReDim PermsCurrentXOver(UB1, UB2)
    Get #FF, , PermsCurrentXOver()
    
    Get #FF, , UB1
    Get #FF, , UB2
    Get #FF, , UB3
    ReDim PermsXOverList(UB1, UB2, UB3)
    Get #FF, , PermsXOverList()

End If


Get #FF, , UB1
Get #FF, , UB2
ReDim BPCIs(UB1, UB2)
Get #FF, , BPCIs()
''XX = BPCIs(0, 27)
'BB = Abs(BPCIs(A, EN)) '0,27
'497.7
Get #FF, , SelGrpFlag

Get #FF, , UB1
If UB1 > -1 Then
    ReDim GrpMaskSeq(UB1)
    Get #FF, , GrpMaskSeq()
End If

Get #FF, , ReassortmentFlag
Get #FF, , RBPNum

Get #FF, , UB1
If UB1 > -1 Then
    ReDim RBPPos(UB1)
    Get #FF, , RBPPos()
End If
'497.7 Megs

Get #FF, , UB1
If UB1 > -1 Then
    'ReDim MethodTime(UB1)
    Get #FF, , MethodTime()
End If


Get #FF, , UB1
If UB1 > -1 Then
    'ReDim TimeFract(UB1)
    Get #FF, , TimeFract()
End If

Get #FF, , RefNum

Get #FF, , UB1
If UB1 > -1 Then
    ReDim ReferenceList(UB1)
    Get #FF, , ReferenceList()
End If


Get #FF, , UB1
If UB1 > 0 Then
    ReDim RefGroupName(UB1)
    For x = 0 To UB1
        RefGroupName(x) = String(100, " ")
        Get #FF, , RefGroupName(x)
    Next x
    
    For x = 0 To UB1
        RefGroupName(x) = Trim(RefGroupName(x))
    Next x
End If
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Get #FF, , UB1
If UB1 > 0 Then
    ReDim ReferenceCols(UB1)
    Get #FF, , ReferenceCols()
End If
'497.7 Megs

Get #FF, , UB1
If UB1 > -1 Then
    ReDim Worthwhilescan(UB1)
    Get #FF, , Worthwhilescan()
    GoOn = 1
    For x = 1 To UB1
        If Worthwhilescan(x) > 0 Then
            GoOn = 0
            Exit For
        End If
    Next x
    If GoOn = 1 Then
        For x = 1 To UB1
            Worthwhilescan(x) = 127
        Next x
    End If
End If




'497.7 Megs

Get #FF, , UB1
If UB1 > -1 Then
    ReDim YannWarn(UB1)
    Get #FF, , YannWarn()
End If

Get #FF, , RelX '52
Get #FF, , RelY '1
Get #FF, , PermXVal '0
Get #FF, , PermYVal '0
On Error Resume Next
Dim F1C10E As Boolean
Get #FF, , F1C10E 'false
Form1.Command10.Enabled = F1C10E
Get #FF, , AcceptChangeFlag


Get #FF, , UseALFlag

Get #FF, , UB1

If UseALFlag = 1 Then

    If UB1 > -1 Then
        TripListLen = UB1
        ReDim Analysislist(2, TripListLen)
        
        Get #FF, , Analysislist
    Else
        TripListLen = 0
    End If
    
    
End If

Get #FF, , CurWothwhilePos

Get #FF, , UB1
If UB1 > -1 Then
    
    ReDim ExcludeCoords(UB1)
    
    Get #FF, , ExcludeCoords()
End If
Dim HoldFile() As Byte, LenEL As Long
Get #FF, , UB1
If UB1 > -1 Then
    If UB1 > 50000000 Then
        LenEL = UB1
        ReDim HoldFile(50000000)
        Dim tLenEL As Long
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF2 = FreeFile
        Open "RDP5ExcludeList" + UFTag For Binary As FF2
        For x = 1 To CLng((LenEL / 50000001) + 0.499999) - 1
            Get #FF, , HoldFile()
            Put #FF2, , HoldFile()
        Next x
        'do the last bit
        tLenEL = (LenEL - 50000001 * (CLng((LenEL / 50000001) + 0.499999) - 1)) - 1
        If tLenEL >= 0 Then
            ReDim HoldFile(tLenEL)
            Get #FF, , HoldFile()
            Put #FF2, , HoldFile()
        End If
        Close #FF2
        ChDrive oDirX
        ChDir oDirX
    Else
        ReDim HoldFile(UB1)
        Get #FF, , HoldFile()
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF2 = FreeFile
        Open "RDP5ExcludeList" + UFTag For Binary As FF2
        Put #FF2, , HoldFile()
        Close #FF2
        ChDrive oDirX
        ChDir oDirX
    End If
End If

Get #FF, , ExcludedEventNum

NumExcludedEventNum = 0
Get #FF, , UB1
If UB1 > -1 Then
    If ExcludedEventNum = 32000000 Then 'means that eventsinexcludeds will need to be split up
        'UB1 = ExcludedEventNumThresh
        NumExcludedEventNum = UB1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        For j = 0 To NumExcludedEventNum
            NF3 = FreeFile
            
            Get #FF, , ExcludedEventNum
            ReDim EventsInExcludeds(5, ExcludedEventNum)
            Get #FF, , EventsInExcludeds
            
            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
            Put #NF3, , ExcludedEventNum
            Put #NF3, , EventsInExcludeds
            Close #NF3
        Next j
        ChDrive oDirX
        ChDir oDirX
'        Do
'            If ExcludedEventNum > ExcludedEventNumThresh Then
'                ReDim EventsInExcludeds(5, ExcludedEventNumThresh)
'            Else
'                ReDim EventsInExcludeds(5, UB1)
'            End If
'            Get #FF, , EventsInExcludeds()
'            NF3 = FreeFile
'            oDirX = CurDir
'            ChDrive App.Path
'            ChDir App.Path
'            Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
'
'            Put #NF3, 1, UB1
'            Put #NF3, , EventsInExcludeds
'            Close #NF3
'            If ExcludedEventNum > ExcludedEventNumThresh Then
'                ExcludedEventNum = ExcludedEventNum - (ExcludedEventNumThresh + 1)
'                'UB1 = UB1 - (ExcludedEventNumThresh + 1)
'                NumExcludedEventNum = NumExcludedEventNum + 1
'            Else
'
'                Exit Do
'
'            End If
'            ChDrive oDirX
'            ChDir oDirX
'
'        Loop
      
    Else
        
        ReDim EventsInExcludeds(5, UB1)
        Get #FF, , EventsInExcludeds()
        
    End If
End If

Get #FF, , MaxEListLen

Get #FF, , UB1

DatasetName = String(UB1, " ")
Get #FF, , DatasetName

If Trim(DatasetName) <> "" Then
    Form1.Caption = Trim(DatasetName)
    DatasetName = ""
End If

Get #FF, , NextnoBak
Get #FF, , UB1
ReDim OriginalPos(UB1)
Get #FF, , OriginalPos()

CF = Seek(FF)
XX = LOF(FF)
Get #FF, , UB1

If UB1 <= NextnoBak And (UB1 <= NextNo Or NextnoBak > NextNo) Then
    ReDim FullOName(UB1)
    Dim SL As Long
    For x = 0 To UB1
        Get #FF, , SL
        FullOName(x) = String(SL, " ")
        Get #FF, , FullOName(x)
        XX = XX
    Next x
Else
    ReDim FullOName(NextNo)
    For x = 0 To NextNo
        FullOName(x) = OriginalName(x)
    Next x
End If
'UB1 = UBound(WhereIsExclude, 1)
Get #FF, , UB1
ReDim WhereIsExclude(UB1)
Get #FF, , WhereIsExclude()


UB1 = UBound(EventsInExcludedsBP, 2)
Get #FF, , UB1
ReDim EventsInExcludedsBP(1, UB1)
Get #FF, , EventsInExcludedsBP()
UB1 = -1
UB1 = UBound(EventsInExcludedsBP, 2)

If UB1 = -1 Then
    ReDim EventsInExcludedsBP(1, 10)
End If
On Error GoTo 0
Close #FF

If UBound(FullOName, 1) < UBound(OriginalName, 1) Or (NextnoBak <> UBound(FullOName) And UBound(FullOName, 1) <> UBound(OriginalName, 1)) Then
    ReDim FullOName(UBound(OriginalName))
    For x = 0 To UBound(OriginalName, 1)
        FullOName(x) = OriginalName(x)
    Next x
End If
If TripListLen > 1000000 Then
    'ReDim Preserve AnalysisList(2, TripListLen)
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "RDP5AnalysisList" + UFTag For Binary As #FF
    Put #FF, , Analysislist
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
    Erase Analysislist
End If


'497.7 Megs
ReDim ShowAllHits(NextNo)
ReDim SubSetF(NextNo)
ReDim SubSetR(NextNo + 1)
ReDim SubMaskSeq(NextNo + 1)
ReDim XOverSeq(NextNo + 2)
IncludeSeq = 0
LongWindedFlag = 1


On Error Resume Next
Dim UBMS As Long
UBMS = 0
UBMS = UBound(MaskSeq, 1)
If UBMS < NextNo Then
    ReDim MaskSeq(NextNo)
End If
On Error GoTo 0

For x = 0 To NextNo

    If MaskSeq(x) < 2 Then
        SubSetF(x) = IncludeSeq
        SubSetR(IncludeSeq) = x
        SubMaskSeq(IncludeSeq) = x
        IncludeSeq = IncludeSeq + 1
    End If

Next 'X
'497.7 Megs
Form1.Command6(2).Enabled = True
Form1.Command5.Enabled = True
Form1.Command9.Enabled = True
Form1.Label58.Caption = "Unique sequences"
'If Nextno > 1000 Then
'    Dim SM() As Single
'    Call UnModSeqNum(0)
'    Call UnModNextno
'    ReDim SM(Nextno, Nextno)
'    For X = 0 To Nextno
'        For Y = X + 1 To Nextno
'            SM(X, Y) = PermValid(X, Y)
'            SM(Y, X) = PermDiffs(X, Y)
'        Next Y
'    Next X
'    Open SFName + "SM" For Binary As #1
'    Get #FF, , SM()
'    Close #FF
'End If

Call FilterSteps

'497.7


End Sub
Public Sub WriteRDP5File(SName As String)
SSS = Abs(GetTickCount)
If PermNextno = 0 Then Exit Sub

Dim XX As Variant, Y As Long, x As Long, CompressF As Long, FileSeqString As String, oDir As String, FF As Long, FF2 As Long, TNameA() As String, TName As String, LongHold As Long, UB1 As Long, UB2 As Long, UB3 As Long, UB4 As Long, UB5 As Long, UB6 As Long, UB7 As Long
Form1.SSPanel1.Caption = "Saving RDP5 project file"
Screen.MousePointer = 11
FF = FreeFile
Open SName$ For Binary As #FF

Put #FF, , "RDP5 Project File"
Put #FF, , CLng(PermNextno)
Put #FF, , CLng(Len(StrainSeq(0)))

If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
    CompressF = 0
Else
    CompressF = 1
End If

Put #FF, , CompressF


ReDim TNameA(PermNextno)
For x = 0 To PermNextno
    TNameA(x) = PermOriginalName(x)
    If Len(TNameA(x)) > 100 Then
        TNameA(x) = Left(TNameA(x), 100)
    Else
        TNameA(x) = TNameA(x) + String(100 - Len(TNameA(x)), " ")
    End If
    
Next x

Put #FF, , TNameA()


ReDim TNameA(PermNextno)
For x = 0 To PermNextno
    TNameA(x) = StraiName(x)
    If Len(TNameA(x)) > 100 Then
        TNameA(x) = Left(TNameA(x), 100)
    Else
        TNameA(x) = TNameA(x) + String(100 - Len(TNameA(x)), " ")
    End If
    
Next x
Put #FF, , TNameA()
'make sure all the sequence lengths are identical
'For X = 0 To Nextno
'    If Len(StrainSeq(0)) <> Len(StrainSeq(X)) Then
'        X = X
'    End If
'Next X







    UB1 = UBound(StrainSeq, 1)
    Put #FF, , UB1
    UB2 = Len(StrainSeq(0))
    Put #FF, , UB2
    Put #FF, , StrainSeq()

If CompressF = 1 Then
'    UB1 = UBound(StrainSeq, 1)
'    Put #FF, , UB1
'    UB2 = Len(StrainSeq(0))
'    Put #FF, , UB2
'    Put #FF, , StrainSeq()
    'Put #FF, , StrainSeq()
    'need to save a version of the uncompressed sequences
    FF2 = FreeFile
'    ReadLen = PrintSeqLen * (Nextno + 1)
'    ReadStart = WinLeft * (Nextno + 1) - (Nextno + 1) + 1
    
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    
    Open "RDP5Longseq" + UFTag For Binary As #FF2
    Dim UBFB As Long
    UBFB = LOF(FF2) - 1
    Put #FF, , UBFB
    
    Dim FileBin() As Byte
    ReDim FileBin(20000000)
    'FileSeqString = String(LOF(FF2), " ")
    'Get #FF2, , FileSeqString
    Dim Numreads As Single
    'Numreads = CLng((UBFB / 10000000) + 1) '85
    Numreads = NextNo * Decompress(Len(StrainSeq(0)))
    Numreads = CLng((Numreads / 20000000) + 1)
    Put #FF, , Numreads
    For x = 1 To Numreads
        Get #FF2, , FileBin()
        Put #FF, , FileBin()
    Next x
    
    Close #FF2
'    Put #FF, , FileSeqString
'    FileSeqString = ""
    DoEvents 'xxxxxxxxxxxxxxxpotentially dangerous
    Erase FileBin
    
    Dim UBBFO1 As Long, UBBFO2 As Long
    UBBFO1 = UBound(BigFileOffsets, 1)
    UBBFO2 = UBound(BigFileOffsets, 2)
    Put #FF, , UBBFO1
    Put #FF, , UBBFO2
    Put #FF, , BigFileOffsets()
    
    Open BIGFilename For Binary As #FF2
    UBFB = LOF(FF2) - 1
    
    Put #FF, , UBFB
    ReDim FileBin(10000000)
    Numreads = NextNo * Decompress(Len(StrainSeq(0)))
    Numreads = CLng((Numreads / 20000000) + 1)
    Put #FF, , Numreads
    For x = 1 To Numreads
        Get #FF2, , FileBin()
        Put #FF, , FileBin()
    Next x
    Close #FF2
    DoEvents 'xxxxxxxxxxxxxpotentially dangerous
    
    Erase FileBin
    Dim UBSS1 As Long
    Dim UBSS2 As Long
    Put #FF, , SeqSpacesInFileFlag
    If SeqSpacesInFileFlag = 0 Then
    
        UBSS1 = UBound(SeqSpaces, 1)
        UBSS2 = UBound(SeqSpaces, 2)
        Put #FF, , UBSS1
        Put #FF, , UBSS2
        Put #FF, , SeqSpaces()
    Else
        FF2 = FreeFile
        UBSS1 = Len(StrainSeq(0)) + 2
        UBSS2 = PermNextno
        Put #FF, , UBSS1
        Put #FF, , UBSS2
        
        Open "RDP5SSFile" + UFTag For Binary As #FF2
        'transfer over one sequence at a time
        ReDim SeqSpaces(Len(StrainSeq(0)) + 2)
        For x = 0 To PermNextno
            Get #FF2, , SeqSpaces()
            Put #FF, , SeqSpaces()
        Next x
        
        Close #FF2
        Erase SeqSpaces()
    End If
    
    ChDrive oDir
    ChDir oDir
End If


UB1 = UBound(Decompress, 1)
Put #FF, , UB1
Put #FF, , Decompress()

UB1 = UBound(Recompress, 1)
Put #FF, , UB1
Put #FF, , Recompress()
If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(ABCons, 1)
If UB1 = 0 Then
    UB1 = 0
    ReDim ABCons(0)
End If
On Error GoTo 0
Put #FF, , UB1
Put #FF, , ABCons()



Put #FF, , ORFFlag
If ORFFlag = 1 Then
    Put #FF, , GeneNumber
    Put #FF, , UBound(GeneList, 1)
    Put #FF, , GeneList()
    Put #FF, , UBound(GeneSEPos, 1)
    Put #FF, , UBound(GeneSEPos, 2)
    Put #FF, , UBound(GeneSEPos, 3)
    Put #FF, , GeneSEPos()
End If


'check to see if any permutation data is actualy stored.  If there is none then reset gperms to 0
If GPerms > 0 Then
    UB1 = UBound(PermsCurrentXOver, 1)
    UB2 = UBound(PermsCurrentXOver, 2)
    GoOn = 0
    For x = 0 To UB2
        For Y = 0 To UB1
            If PermsCurrentXOver(x, Y) > 0 Then
                GoOn = 1
            End If
        Next Y
    Next x
    If GoOn = 0 Then GPerms = 0
    ReDim PermsCurrentXOver(0, 0)
Else
    ReDim PermsCurrentXOver(0, 0)
End If


Put #FF, , pSpacerFlag
Put #FF, , pCircularFlag
Put #FF, , ShowPlotFlag
Put #FF, , GPerms
Put #FF, , PermTypeFlag
Put #FF, , pXOverWindowX '30
Put #FF, , LowestProb '0.05
Put #FF, , MCFlag
Put #FF, , SHWinLen '400
Put #FF, , pGCIndelFlag '1
Put #FF, , SHStep '100
Put #FF, , pGCTripletflag
Put #FF, , GCOutfileName
Put #FF, , BSTreeStrat
Put #FF, , BSupTest
Put #FF, , GCSortFlag
Put #FF, , GCTractLen
Put #FF, , GCLogFlag
Put #FF, , pGCMissmatchPen
Put #FF, , SCHEMADistCO
Put #FF, , SCHEMAPermNo
Put #FF, , pGCMinFragLen
Put #FF, , pGCMinPolyInFrag
Put #FF, , pGCMinPairScore
Put #FF, , pGCMaxOverlapFrags
Put #FF, , ConservativeGroup
Put #FF, , MaxTemperature
Put #FF, , ntType
Put #FF, , pBSStepWin
Put #FF, , pBSStepSize
Put #FF, , pBSCutoff
Put #FF, , pBSBootReps
Put #FF, , BSRndNumSeed
Put #FF, , BSSubModelFlag
Put #FF, , BSTTRatio
Put #FF, , MCMCUpdates
Put #FF, , BlockPen
Put #FF, , StartRho
Put #FF, , MatPermNo
Put #FF, , DoScans(1, 2)
Put #FF, , DoScans(1, 5)
Put #FF, , FreqCo
Put #FF, , MatWinSize
Put #FF, , FreqCoMD
Put #FF, , AllowConflict
Put #FF, , LongHold
Put #FF, , pMCSteplen
Put #FF, , pMCWinSize
Put #FF, , pDoScans(0, 0)
Put #FF, , pDoScans(0, 1)
Put #FF, , pDoScans(0, 2)
Put #FF, , pDoScans(0, 3)
Put #FF, , pDoScans(0, 4)
Put #FF, , pDoScans(0, 5)
'Put #FF, , FileList(1) + String(1000 - Len(FileList(1)), " ")
'Put #FF, , FileList(2) + String(1000 - Len(FileList(2)), " ")
'Put #FF, , FileList(3) + String(1000 - Len(FileList(3)), " ")
'Put #FF, , FileList(4) + String(1000 - Len(FileList(4)), " ")
Put #FF, , LRDModel
Put #FF, , LRDCategs
Put #FF, , LRDShape
Put #FF, , LRDTvRat
Put #FF, , LRDACCoeff
Put #FF, , LRDAGCoeff
Put #FF, , LRDATCoeff
Put #FF, , LRDCGCoeff
Put #FF, , LRDCTCoeff
Put #FF, , LRDGTCoeff
Put #FF, , LRDBaseFreqFlag
Put #FF, , LRDAFreq
Put #FF, , LRDCFreq
Put #FF, , LRDGFreq
Put #FF, , LRDTFreq
Put #FF, , LRDCodon1
Put #FF, , LRDCodon2
Put #FF, , LRDCodon3
Put #FF, , LRDStep
Put #FF, , LRDRegion
Put #FF, , pMCWinFract
Put #FF, , pMCProportionFlag
Put #FF, , pMCTripletFlag
Put #FF, , pMCStripGapsFlag
Put #FF, , MCFullOR
Put #FF, , MCFullOL
Put #FF, , DPModelFlag
Put #FF, , DPWindow
Put #FF, , DPStep
Put #FF, , DPTVRatio
Put #FF, , DPBFreqFlag
Put #FF, , DPBFreqA
Put #FF, , DPBFreqC
Put #FF, , DPBFreqG
Put #FF, , DPBFreqT
Put #FF, , VisRDWin
Put #FF, , ModelTestFlag
Put #FF, , TOWinLen
Put #FF, , TOStepSize
Put #FF, , TOSmooth
Put #FF, , TOTvTs
Put #FF, , TOPower
Put #FF, , TORndNum
Put #FF, , TOPerms
Put #FF, , TOPValCOff
Put #FF, , TOFreqA
Put #FF, , TOFreqC
Put #FF, , TOFreqG
Put #FF, , TOFreqT
Put #FF, , TOTreeType
Put #FF, , TOFreqFlag
Put #FF, , TOModel
Put #FF, , pBSTypeFlag
Put #FF, , BSFreqFlag
Put #FF, , BSFreqA
Put #FF, , BSFreqC
Put #FF, , BSFreqG
Put #FF, , BSFreqT
Put #FF, , GCFlag
Put #FF, , BSCoeffVar
Put #FF, , DPCoeffVar
Put #FF, , TOCoeffVar
Put #FF, , TBSReps
Put #FF, , TRndSeed
Put #FF, , TTVRat
Put #FF, , TModel
Put #FF, , TCoeffVar
Put #FF, , TBaseFreqFlag
Put #FF, , TAfreq
Put #FF, , TCFreq
Put #FF, , TGFreq
Put #FF, , TTFreq
Put #FF, , TPower
Put #FF, , TNegBLFlag
Put #FF, , TSubRepsFlag
Put #FF, , TGRFlag
Put #FF, , TRndIOrderFlag
Put #FF, , pBSPValFlag
Put #FF, , SSFastFlag
Put #FF, , pSSGapFlag
Put #FF, , pSSVarPFlag
Put #FF, , pSSOutlyerFlag
Put #FF, , pSSRndSeed
Put #FF, , pSSWinLen
Put #FF, , pSSStep
Put #FF, , pSSNumPerms
Put #FF, , pSSNumPerms2
Put #FF, , ForcePhylE
Put #FF, , PolishBPFlag
Put #FF, , RealignFlag
Put #FF, , ConsensusProg
Put #FF, , pCWinFract
Put #FF, , pCProportionFlag
Put #FF, , pCWinSize
Put #FF, , LongHold
Put #FF, , LongHold
Put #FF, , PPWinLen
Put #FF, , pPPStripGaps
Put #FF, , IncSelf
Put #FF, , PPSeed
Put #FF, , PPPerms
Put #FF, , DoScans(0, 8)
Put #FF, , TPTVRat
Put #FF, , TPGamma
Put #FF, , TPAlpha
Put #FF, , TPInvSites
Put #FF, , TPModel
Put #FF, , TPBPFEstimate
Put #FF, , TBModel
Put #FF, , TBGamma
Put #FF, , TBGammaCats
Put #FF, , TBNGens
Put #FF, , TBNChains
Put #FF, , TBSampFreq
Put #FF, , TBTemp
Put #FF, , TBSwapFreq
Put #FF, , TBSwapNum


'Other settings
Put #FF, , MCCorrection

UB1 = UBound(pMaskSeq, 1)
Put #FF, , UB1
Put #FF, , pMaskSeq()

'save recombinationInfo
ReDim Preserve CurrentXOver(PermNextno)
Put #FF, , CurrentXOver()
UB1 = UBound(XoverList, 1)
UB2 = UBound(XoverList, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , XoverList

Put #FF, , XOMiMaInFileFlag
If XOMiMaInFileFlag = 1 Then
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    ReDim BestXOListMi(PermNextno, UBXOMi)
    Open "RDP5BestXOListMi" + UFTag For Binary As #FF2
    Get #FF2, , BestXOListMi()
    Close #FF2
    MiRec = 1
    ChDrive oDir
    ChDir oDir
End If

ReDim Preserve BCurrentXoverMi(PermNextno)
Put #FF, , BCurrentXoverMi()
If DebuggingFlag < 2 Then On Error Resume Next
UB1 = 0
UB2 = 0

UB1 = UBound(BestXOListMi, 1)
UB2 = UBound(BestXOListMi, 2)
On Error GoTo 0

Put #FF, , UB1
Put #FF, , UB2
Put #FF, , BestXOListMi()

If XOMiMaInFileFlag = 1 Then
    Erase BestXOListMi
    MiRec = MiRec - 1
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    ReDim BestXOListMa(PermNextno, UBXoMa)
    If MaRec < 1 Then
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF2
        Get #FF2, , BestXOListMa()
        Close #FF2
        MaRec = 1
    End If
    ChDrive oDir
    ChDir oDir
    
End If

ReDim Preserve BCurrentXoverMa(PermNextno)
Put #FF, , BCurrentXoverMa()
UB1 = 0
UB2 = 0
If DebuggingFlag < 2 Then On Error Resume Next
UB1 = UBound(BestXOListMa, 1)
UB2 = UBound(BestXOListMa, 2)
On Error GoTo 0
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , BestXOListMa()

'For Z = 0 To Nextno '693,1; 703,1
'    If BCurrentXoverMa(Z) > 0 Then
'
'        For Y = 1 To BCurrentXoverMa(Z)
'            If BestXOListMa(Z, Y).Eventnumber = 0 Then '709,12
'
'                X = X
'            End If
'        Next Y
'    End If
'Next Z


If XOMiMaInFileFlag = 1 Then
    Erase BestXOListMa
    MaRec = MaRec - 1
End If

If DebuggingFlag < 2 Then On Error Resume Next
UB2 = -1
UB1 = -1
UB1 = UBound(NOPINI, 1)
UB2 = UBound(NOPINI, 2)
On Error GoTo 0

Put #FF, , UB1
Put #FF, , UB2
If UB2 > -1 Then
    Put #FF, , SEventNumber
    Put #FF, , Eventnumber
    Put #FF, , NOPINI()
End If

UB1 = UBound(DScores, 1)
UB2 = UBound(DScores, 2)
UB3 = UBound(DScores, 3)

Put #FF, , UB1
Put #FF, , UB2
Put #FF, , UB3

Put #FF, , DScores()


UB1 = UBound(SuperEventList, 1)
Put #FF, , UB1
Put #FF, , SuperEventList()

UB1 = UBound(Daught, 1)
UB2 = UBound(Daught, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , Daught()

UB1 = UBound(MinorPar, 1)
UB2 = UBound(MinorPar, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , MinorPar()

UB1 = UBound(MajorPar, 1)
UB2 = UBound(MajorPar, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , MajorPar()

UB1 = UBound(BestEvent, 1)
UB2 = UBound(BestEvent, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , BestEvent()

UB1 = UBound(Confirm, 1)
UB2 = UBound(Confirm, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , Confirm()

UB1 = UBound(ConfirmP, 1)
UB2 = UBound(ConfirmP, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmP()

UB1 = UBound(ConfirmMi, 1)
UB2 = UBound(ConfirmMi, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmMi()

UB1 = UBound(ConfirmPMi, 1)
UB2 = UBound(ConfirmPMi, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmPMi()

UB1 = UBound(ConfirmMa, 1)
UB2 = UBound(ConfirmMa, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmMa()

UB1 = UBound(ConfirmPMa, 1)
UB2 = UBound(ConfirmPMa, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmPMa()

Put #FF, , StepNo
UB1 = UBound(Steps, 1)
UB2 = UBound(Steps, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , Steps()

UB1 = UBound(MultColour, 1)
Put #FF, , UB1
Put #FF, , MultColour()

On Error Resume Next
UB1 = -1
UB1 = UBound(ColourSeq, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    
    Put #FF, , ColourSeq()
End If

UB1 = UBound(TreeTestStats, 1)
UB2 = UBound(TreeTestStats, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , TreeTestStats()

Put #FF, , GPerms
If DebuggingFlag < 2 Then On Error Resume Next


UB1 = UBound(PermsCurrentXOver, 1)
UB2 = UBound(PermsCurrentXOver, 2)
On Error GoTo 0
Put #FF, , UB1
Put #FF, , UB2
If UB1 > 0 Then
    Put #FF, , PermsCurrentXOver()
    UB1 = UBound(PermsXOverList, 1)
    UB2 = UBound(PermsXOverList, 2)
    UB3 = UBound(PermsXOverList, 3)
    Put #FF, , UB1
    Put #FF, , UB2
    Put #FF, , UB3
    Put #FF, , PermsXOverList()

End If

UB1 = UBound(BPCIs, 1)
UB2 = UBound(BPCIs, 2)
Put #FF, , UB1
Put #FF, , UB2

Put #FF, , BPCIs()
'X = BPCIs(0, 27)
Put #FF, , SelGrpFlag
If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(GrpMaskSeq, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , GrpMaskSeq()
End If

Put #FF, , ReassortmentFlag
Put #FF, , RBPNum

If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(RBPPos, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , RBPPos()
Else
    ReDim RBPPos(3)
End If

If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(MethodTime, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , MethodTime()
End If

If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(TimeFract, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , TimeFract()
End If

Put #FF, , RefNum
On Error Resume Next
UB1 = -1
UB1 = UBound(ReferenceList, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , ReferenceList()
End If


If DebuggingFlag < 2 Then On Error Resume Next
UB1 = UBound(RefGroupName, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > 0 Then
    For x = 0 To UB1
        TName = RefGroupName(x)
        If Len(TName) > 100 Then
            TName = Left(TName, 100)
        Else
            TName = TName + String(100 - Len(TName), " ")
        End If
        Put #FF, , TName
    Next x
End If

If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(ReferenceCols, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > 0 Then
    Put #FF, , ReferenceCols()
End If



If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(Worthwhilescan, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , Worthwhilescan()
End If



If DebuggingFlag < 2 Then On Error Resume Next
UB1 = -1
UB1 = UBound(YannWarn, 1)
On Error GoTo 0
Put #FF, , UB1
If UB1 > -1 Then
    Put #FF, , YannWarn()
End If

Put #FF, , RelX '34
Put #FF, , RelY '1
Put #FF, , PermXVal '0
Put #FF, , PermYVal '0
Put #FF, , Form1.Command10.Enabled 'true
Put #FF, , AcceptChangeFlag '0

Put #FF, , UseALFlag
If UseALFlag = 1 Then
    If DebuggingFlag < 3 Then On Error Resume Next
        UB1 = -1
        UB1 = UBound(Analysislist, 2)
    On Error GoTo 0
    If UB1 < TripListLen Then
        'Erase YannWarn
        
        Put #FF, , TripListLen
        otriplistlen = TripListLen
        pTripListLen = TripListLen
        TripListLen = 100000
        oDirXx = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        
        
        
        ReDim Analysislist(2, TripListLen)
        FF2 = FreeFile
        Open "RDP5AnalysisList" + UFTag For Binary As #FF2
        Do
            
        
            Get #FF2, , Analysislist
            Put #FF, , Analysislist
            
            otriplistlen = otriplistlen - TripListLen - 1
            If otriplistlen < TripListLen Then
                If otriplistlen >= 0 Then
                TripListLen = otriplistlen
                ReDim Analysislist(2, TripListLen - 1)
                Get #FF2, , Analysislist
                Put #FF, , Analysislist
                End If
                Exit Do
            End If
        Loop
        Close #FF2
        TripListLen = pTripListLen
        ChDrive oDirXx
        ChDir oDirXx
        Erase Analysislist
    Else
    
    
    
    
    
    
        If DebuggingFlag < 2 Then On Error Resume Next
            UB1 = -1
            UB1 = UBound(Analysislist, 2)
        On Error GoTo 0
        
        
        Put #FF, , UB1 '1285754
        If UB1 > -1 Then
            Put #FF, , Analysislist
        
        End If
    End If
    If TripListLen > 1000000 Then
        Erase Analysislist
    End If
Else
    UB1 = -1
    Put #FF, , UB1
End If

Put #FF, , CurWothwhilePos
UB1 = -1
On Error Resume Next
UB1 = UBound(ExcludeCoords)
On Error GoTo 0
Put #FF, , UB1
If UB1 <> -1 Then
    Put #FF, , ExcludeCoords()
End If

Dim LenEL As Long, HoldFile() As Byte
ReDim HoldFile(0)
LenEL = -1


oDirX = CurDir
ChDrive App.Path
ChDir App.Path
If Dir("RDP5ExcludeList" + UFTag) <> "" Then
    
    FF2 = FreeFile
    
    Open "RDP5ExcludeList" + UFTag For Binary As FF2
    LenEL = LOF(FF2)
    If LenEL > 50000000 Then
        Dim tLenEL As Long
        ReDim HoldFile(50000000)
        Put #FF, , LenEL
        For x = 1 To CLng((LenEL / 50000001) + 0.499999) - 1
            '50000001 get read and written not 50000000
            Get #FF2, , HoldFile()
            Put #FF, , HoldFile()
            'if filelen = 21 then holdile dimmed to 5 will read up to record 6 on first cycle, 12 on second cycle, 18 on third and up to 24 on the last
            'tlenfl would equal 3 if i do 21-18 which means I'd need to dimension the last holdfile to 3-1
            
        Next x
        'need to do the last bit separately
        tLenEL = (LenEL - 50000001 * (CLng((LenEL / 50000001) + 0.499999) - 1)) - 1
        If tLenEL >= 0 Then
            ReDim HoldFile(tLenEL)
            Get #FF2, , HoldFile()
            Put #FF, , HoldFile()
        End If
        Close #FF2
    Else
    ReDim HoldFile(LenEL)
        Get #FF2, , HoldFile()
    
        
        Close #FF2
        Put #FF, , LenEL
        
        If LenEL <> -1 Then
            Put #FF, , HoldFile()
        End If
    End If
Else
    Put #FF, , LenEL
    
    If LenEL <> -1 Then
        Put #FF, , HoldFile()
    End If
End If
ChDrive oDirX
ChDir oDirX







If NumExcludedEventNum > 0 Then
    
    NF3 = FreeFile
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
    Put #NF3, 1, ExcludedEventNum
    Put #NF3, , EventsInExcludeds
    Close #NF3
    ReDim EventsInExcludeds(5, 1000)
    'ExcludedEventNum = 1
    ChDrive oDirX
    ChDir oDirX
    
    Dim TallyEN As Long, GetEN As Long
    NF3 = FreeFile
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    Dim j As Long
'    TallyEN = 0
'    For j = 0 To NumExcludedEventNum
'        Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
'        'EventsInExcludeds(0, 0) = 0
'        'Put #NF3, 1, ExcludedEventNum
'        'Put #NF3, , EventsInExcludeds
'
'        Get #NF3, , GetEN
'        If j > 0 Then GetEN = GetEN + 1
'        TallyEN = TallyEN + GetEN
'        Close #NF3
'        'x = x
'    Next j
    
'    Put #FF, , TallyEN
'    Put #FF, , TallyEN
    Put #FF, , CLng(32000000)
    Put #FF, , NumExcludedEventNum
    For j = 0 To NumExcludedEventNum
        NF3 = FreeFile
        Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
        Get #NF3, , ExcludedEventNum
        ReDim EventsInExcludeds(5, ExcludedEventNum)
        Get #NF3, , EventsInExcludeds
        Close #NF3
        Put #FF, , ExcludedEventNum
        Put #FF, , EventsInExcludeds
    Next j
    ChDrive oDirX
    ChDir oDirX
Else
    Put #FF, , ExcludedEventNum
    'Put #FF, , NumExcludedEventNum
    On Error Resume Next
    UB1 = -1
    UB1 = UBound(EventsInExcludeds, 2)
    On Error GoTo 0
    Put #FF, , UB1
    If UB1 > -1 Then
        Put #FF, , EventsInExcludeds()
    End If
End If
Put #FF, , MaxEListLen

Put #FF, , CLng(Len(Form1.Caption))
Put #FF, , CStr(Form1.Caption)


Put #FF, , NextnoBak
UB1 = UBound(OriginalPos, 1)
Put #FF, , UB1
Put #FF, , OriginalPos()

UB1 = UBound(FullOName, 1)
Put #FF, , UB1
For x = 0 To UB1
    Put #FF, , CLng(Len(FullOName(x)))
    Put #FF, , FullOName(x)
Next x

UB1 = UBound(WhereIsExclude, 1)
Put #FF, , UB1
Put #FF, , WhereIsExclude()

UB1 = 0
On Error Resume Next
UB1 = UBound(EventsInExcludedsBP, 2)
On Error GoTo 0

Put #FF, , UB1
Put #FF, , EventsInExcludedsBP()
x = x
' ReDim ExcludeCoords(MemPoc)
'    For Y = 0 To NextNo
'        If MaskSeq(Y) <> 2 Then
'            ReDim EList(NumToExclude)
'            ElistNum = 0
'            For Z = 0 To NextNo
'               If ClosestRelative(Z) = Y Then
'                    ElistNum = ElistNum + 1
'                    EList(ElistNum) = Z
'               End If
'            Next Z
'
'            If ElistNum > 0 Then
'                Pos = Seek(FF)
'                ExcludeCoords(NewPos(Y)) = Pos '14(8):16(11):22(13):17(20):19(20)
'                Put #FF, , ElistNum
'                For Z = 1 To ElistNum
'                    Put #FF, , CLng(Len(OriginalName(EList(Z))))
'                    Put #FF, , OriginalName(EList(Z))
'                    Put #FF, , CLng(Len(StrainSeq(EList(Z))))
'                    Put #FF, , StrainSeq(EList(Z))
'                Next Z
'            Else
'                ExcludeCoords(NewPos(Y)) = -1
'            End If
'        End If
'    Next Y

Close #FF


If NextNo > 1000 Then
    Dim SM() As Single
    Call UnModSeqNum(0)
    Call UnModNextno
    ReDim SM(NextNo, NextNo)
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            SM(x, Y) = PermValid(x, Y)
            SM(Y, x) = PermDIffs(x, Y)
        Next Y
    Next x
    Open SName + "SM" For Binary As #1
    Put #FF, , SM()
    Close #FF
End If

FF = FreeFile
EEE = Abs(GetTickCount)
ttt = EEE - SSS
Form1.SSPanel1.Caption = "" '18031
Screen.MousePointer = 0

End Sub
Public Sub OutputRecTestCSV(FN As String, Excl() As Byte)
Dim A As Long, Z As Long, EN As Long, FF As Long
FF = FreeFile
XX = CurDir
Open FN For Output As #FF
Dim OS As String
OS = "Event#,Sequence,Designation, Consensus"
For A = 0 To 17

    OS = OS + TestName(A) + ","

Next A

Print #FF, OS


Dim Holder As Long
For EN = 1 To SEventNumber
    If Excl(EN) = 1 Or (XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Accept = 1) Then
        For Z = 0 To 2
            If Z = 0 Then
                OS = Str(EN) + "," + OriginalName(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Daughter) + "," + "Recombinant,"
                Holder = XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Daughter
            ElseIf Z = 1 Then
                OS = Str(EN) + "," + OriginalName(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).MajorP) + "," + "MajorParent,"
                Holder = XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).MajorP
            ElseIf Z = 2 Then
                OS = Str(EN) + "," + OriginalName(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).MinorP) + "," + "MinorParent,"
                Holder = XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).MinorP
            End If
'            If EN = 18 Then
'                x = x
'            End If
'            If Holder <> DScores(25, Z, EN) Then 'ev2 1:5, 12:0, 3:0
'                x = x
'            End If
            For A = 0 To 17
            
                OS = OS + Str(DScores(A, Z, EN)) + ","
                
            Next A
            
            Print #FF, OS
        Next Z
    End If
Next EN

Close #FF
End Sub


Public Sub WriteRDPFile(sFName As String)
Dim x As Long, oDir As String, FF As Long, Y As Long, AA As Long, EE As Long, oDirX As String, UB As Long, Z As Long
'A = BestEvent(2, 0) '11
'b = BestEvent(2, 1) '1
'XX = XOverlist(A, b).Probability '4.5-16

Open sFName$ For Output As #1

            If SEventNumber = 0 Then
                Print #1, "No recombination detected"
                Close #1
                Exit Sub
            End If
            SaveFlag = 1
            Form1.SSPanel1.Caption = "Saving Sequence Data"
            Form1.ProgressBar1.Value = 20
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            'Print #1, SeqFile
            If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            
                For x = 0 To PermNextno
                    Print #1, ">" & OriginalName(x)
                    Print #1, StrainSeq(x)
                Next 'X
            Else
                Close #1
                Kill sFName$
                If DebuggingFlag < 2 Then On Error Resume Next

                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                
                Name BIGFilename As sFName$
                FileCopy sFName$, BIGFilename
                
                If DebuggingFlag < 2 Then On Error Resume Next

                
                
                
                
                ChDir oDir
                ChDrive oDir
               
                
                Open sFName$ For Append As #1
                
            End If

            If ORFFlag = 1 Then
                Form1.SSPanel1.Caption = "Saving Sequence Data"
                Form1.ProgressBar1.Value = 20
                Call UpdateF2Prog
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If

            Print #1, "GB Data"
            Print #1, GBFile
            Form1.SSPanel1.Caption = "Saving Recombination Data"
            Form1.ProgressBar1.Value = 40
            Call UpdateF2Prog
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Write #1, "Recombination Data"
            Write #1, "r20"
            Write #1, pSpacerFlag, pCircularFlag, ShowPlotFlag, GPerms, PermTypeFlag, pXOverWindowX, LowestProb, MCFlag
            Write #1, SHWinLen, pGCIndelFlag, SHStep, pGCTripletflag
            Write #1, GCOutfileName
            Write #1, BSTreeStrat, BSupTest, GCSortFlag, GCTractLen, GCLogFlag
            Write #1, pGCMissmatchPen, SCHEMADistCO, SCHEMAPermNo, pGCMinFragLen, pGCMinPolyInFrag
            Write #1, pGCMinPairScore, pGCMaxOverlapFrags, ConservativeGroup, MaxTemperature, ntType
            Write #1, pBSStepWin, pBSStepSize, pBSCutoff, pBSBootReps, BSRndNumSeed, BSSubModelFlag
            Write #1, BSTTRatio, MCMCUpdates, BlockPen, StartRho, MatPermNo
            Write #1, DoScans(1, 2), DoScans(1, 5), FreqCo, MatWinSize, FreqCoMD
            Write #1, AllowConflict, 0, pMCSteplen, pMCWinSize
            Write #1, pDoScans(0, 0), pDoScans(0, 1), pDoScans(0, 2), pDoScans(0, 3), pDoScans(0, 4), pDoScans(0, 5)
            Write #1, FileList(1), FileList(2), FileList(3), FileList(4)
            Write #1, LRDModel, LRDCategs, LRDShape, LRDTvRat, LRDACCoeff, LRDAGCoeff, LRDATCoeff, LRDCGCoeff, LRDCTCoeff, LRDGTCoeff
            Write #1, LRDBaseFreqFlag, LRDAFreq, LRDCFreq, LRDGFreq, LRDTFreq, LRDCodon1, LRDCodon2, LRDCodon3, LRDStep, LRDRegion
            Write #1, pMCWinFract, pMCProportionFlag, pMCTripletFlag, pMCStripGapsFlag, MCFullOR, MCFullOL
            Write #1, DPModelFlag, DPWindow, DPStep, DPTVRatio, DPBFreqFlag, DPBFreqA, DPBFreqC, DPBFreqG, DPBFreqT
            Write #1, VisRDWin, ModelTestFlag
            Write #1, TOWinLen, TOStepSize, TOSmooth, TOTvTs, TOPower, TORndNum
            Write #1, TOPerms, TOPValCOff, TOFreqA, TOFreqC, TOFreqG, TOFreqT
            Write #1, TOTreeType, TOFreqFlag, TOModel
            Write #1, pBSTypeFlag, BSFreqFlag, BSFreqA, BSFreqC, BSFreqG, BSFreqT
            Write #1, GCFlag, BSCoeffVar, DPCoeffVar, TOCoeffVar
            Write #1, TBSReps, TRndSeed, TTVRat, TModel, TCoeffVar, TBaseFreqFlag
            Write #1, TAfreq, TCFreq, TGFreq, TTFreq, TPower
            Write #1, TNegBLFlag, TSubRepsFlag, TGRFlag, TRndIOrderFlag, pBSPValFlag, SSFastFlag, pSSGapFlag, pSSVarPFlag, pSSOutlyerFlag, pSSRndSeed, pSSWinLen, pSSStep, pSSNumPerms, pSSNumPerms2
            Write #1, ForcePhylE, PolishBPFlag, RealignFlag, ConsensusProg, pCWinFract, pCProportionFlag, pCWinSize, 0, 0
            Write #1, PPWinLen, pPPStripGaps, IncSelf, PPSeed, PPPerms, DoScans(0, 8)
            Write #1, TPTVRat, TPGamma, TPAlpha, TPInvSites, TPModel, TPBPFEstimate
            Write #1, TBModel, TBGamma, TBGammaCats, TBNGens, TBNChains, TBSampFreq, TBTemp, TBSwapFreq, TBSwapNum
            Write #1, MCCorrection

            For x = 0 To PermNextno
                Write #1, pMaskSeq(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno
                Write #1, CurrentXOver(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To CurrentXOver(x)
                    
                    Write #1, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, Decompress(XoverList(x, Y).Beginning), Decompress(XoverList(x, Y).Ending), XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag, XoverList(x, Y).PermPVal, XoverList(x, Y).ProgramFlag, XoverList(x, Y).LHolder, XoverList(x, Y).DHolder, XoverList(x, Y).BeginP, XoverList(x, Y).EndP, XoverList(x, Y).SBPFlag, XoverList(x, Y).Accept, XoverList(x, Y).Eventnumber
                    
                     
'XXXZZZ                      For Z = 0 To 2
'XXXZZZ                          Write #1, XOverlist(X, Y).TreePos(Z)
'XXXZZZ                      Next Z
                    'Write #1, XOverlist(X, Y).Eventnumber
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 40 + (x / PermNextno) * 20
                    Form1.Refresh
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            Write #1, ""
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                ReDim BestXOListMi(PermNextno, UBXOMi)
                
                Open "RDP5BestXOListMi" + UFTag For Binary As #FF
                Get #FF, , BestXOListMi()
                Close #FF
                MiRec = 1
                ChDrive oDirX
                ChDir oDirX
                
            End If
            
            For x = 0 To PermNextno
                Write #1, BCurrentXoverMi(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To BCurrentXoverMi(x)
                    If BestXOListMi(x, Y).Ending > Len(StrainSeq(0)) Then
                        BestXOListMi(x, Y).Ending = Len(StrainSeq(0))
                    End If
                    Write #1, BestXOListMi(x, Y).Daughter, BestXOListMi(x, Y).MajorP, BestXOListMi(x, Y).MinorP, Decompress(BestXOListMi(x, Y).Beginning), Decompress(BestXOListMi(x, Y).Ending), BestXOListMi(x, Y).Probability, BestXOListMi(x, Y).OutsideFlag, BestXOListMi(x, Y).MissIdentifyFlag, BestXOListMi(x, Y).PermPVal, BestXOListMi(x, Y).ProgramFlag, BestXOListMi(x, Y).LHolder, BestXOListMi(x, Y).DHolder, BestXOListMi(x, Y).BeginP, BestXOListMi(x, Y).EndP, BestXOListMi(x, Y).SBPFlag, BestXOListMi(x, Y).Accept, BestXOListMi(x, Y).Eventnumber
                   
                    
                      
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 60 + (x / PermNextno) * 20
                    Form1.Refresh
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
                Erase BestXOListMi
                MiRec = MiRec - 1
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                
                ReDim BestXOListMa(PermNextno, UBXoMa)
                
                
                If MaRec < 1 Then
                    Open "RDP5BestXOListMa" + UFTag For Binary As #FF
                    Get #FF, , BestXOListMa()
                    Close #FF
                    MaRec = 1
                End If
                ChDrive oDirX
                ChDir oDirX
                
            End If
            
            Write #1, ""

            
            For x = 0 To PermNextno
                Write #1, BCurrentXoverMa(x)
            Next 'X

            Write #1, ""

            For x = 0 To PermNextno

                For Y = 1 To BCurrentXoverMa(x)
                    If BestXOListMa(x, Y).Ending > Len(StrainSeq(0)) Then
                        BestXOListMa(x, Y).Ending = Len(StrainSeq(0))
                    End If
                    Write #1, BestXOListMa(x, Y).Daughter, BestXOListMa(x, Y).MajorP, BestXOListMa(x, Y).MinorP, Decompress(BestXOListMa(x, Y).Beginning), Decompress(BestXOListMa(x, Y).Ending), BestXOListMa(x, Y).Probability, BestXOListMa(x, Y).OutsideFlag, BestXOListMa(x, Y).MissIdentifyFlag, BestXOListMa(x, Y).PermPVal, BestXOListMa(x, Y).ProgramFlag, BestXOListMa(x, Y).LHolder, BestXOListMa(x, Y).DHolder, BestXOListMa(x, Y).BeginP, BestXOListMa(x, Y).EndP, BestXOListMa(x, Y).SBPFlag, BestXOListMa(x, Y).Accept, BestXOListMa(x, Y).Eventnumber
                    
                    
'XXXZZZ                      For Z = 0 To 2
'XXXZZZ                          Write #1, bestxolistma(X, Y).TreePos(Z)
'XXXZZZ                      Next Z
                    'Write #1, bestxolistma(X, Y).Eventnumber
                Next 'Y
                AA = Abs(GetTickCount)
                If AA - EE > 500 Then
                    Form1.ProgressBar1 = 80 + (x / PermNextno) * 20
                    Form1.Refresh
                    Call UpdateF2Prog
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                End If
            Next 'X
            
            If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
                Erase BestXOListMa
                
                MaRec = MaRec - 1
            End If
            
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB2 = -1
            UB = UBound(NOPINI, 2)
            UB2 = UBound(NOPINI, 1)
            If UB2 = 2 And UB <> SEventNumber Then
                ReDim Preserve NOPINI(2, SEventNumber)
            ElseIf UB2 <> 2 Then
                ReDim NOPINI(2, SEventNumber)
            End If
            On Error GoTo 0
            
            Write #1, SEventNumber, Eventnumber
            'If UB > -1 Then
                
                'SEventNumber = SEventNumber - 1
                For x = 0 To SEventNumber
                    For Y = 0 To 2
                        Write #1, NOPINI(Y, x)
                    Next Y
                Next x
            'End If
            
            ReDim Preserve DScores(25, 2, SEventNumber)
            
            For x = 0 To 25
                For Y = 0 To 2
                    For Z = 0 To SEventNumber
                        Write #1, DScores(x, Y, Z)
                    Next Z
                Next Y
            Next x
            'Eventnumber = Eventnumber - 1 'UBound(SuperEventlist, 1)
            
            
            For x = 0 To Eventnumber
                Write #1, SuperEventList(x)
            Next x
            
            
            
            Dim NumD As Long, NumMi As Long, NumMa As Long
            NumD = 0
            NumMi = 0
            NumMa = 0
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If Daught(Y, x) <> 0 Then
                        NumD = NumD + 1
                    End If
                    If MinorPar(Y, x) <> 0 Then
                        NumMi = NumMi + 1
                    End If
                    If MajorPar(Y, x) <> 0 Then
                        NumMa = NumMa + 1
                    End If
                Next x
            Next Y
            Write #1, NumD, NumMi, NumMa
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If Daught(Y, x) <> 0 Then
                        Write #1, Y, x, Daught(Y, x)
                    End If
                    
                Next x
            Next Y
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If MinorPar(Y, x) <> 0 Then
                        Write #1, Y, x, MinorPar(Y, x)
                    End If
                    
                Next x
            Next Y
            For Y = 1 To SEventNumber
                For x = 0 To PermNextno
                    If MajorPar(Y, x) <> 0 Then
                        Write #1, Y, x, MajorPar(Y, x)
                    End If
                    
                Next x
            Next Y
            
'            For Y = 1 To SEventNumber
'                For X = 0 To PermNextno
'                    If X <= UBound(Daught, 2) Then
'                        Write #1, Daught(Y, X), MinorPar(Y, X), MajorPar(Y, X)
'                    Else
'                        Write #1, CInt(0), CInt(0), CInt(0)
'                    End If
'                Next X
'            Next Y
            
            'If ShortOutFlag <> 3 Then
                For x = 1 To SEventNumber
                    Write #1, BestEvent(x, 0), BestEvent(x, 1)
                    For Z = 0 To AddNum - 1
                        Write #1, Confirm(x, Z), ConfirmP(x, Z)
                    Next Z
                Next x
                For x = 1 To SEventNumber
                    For Z = 0 To AddNum - 1
                        Write #1, ConfirmMi(x, Z), ConfirmPMi(x, Z)
                    Next Z
                Next x
                For x = 1 To SEventNumber
                    For Z = 0 To AddNum - 1
                        Write #1, ConfirmMa(x, Z), ConfirmPMa(x, Z)
                    Next Z
                Next x
            'End If
            
            Write #1, StepNo
            
            For x = 0 To StepNo
                For Y = 0 To 4
                    Write #1, Steps(Y, x)
                Next Y
                
            Next x
            'If UBound(MultColour, 1) < NextNo Then
                ReDim Preserve MultColour(NextNo)
            'End If
            'If UBound(ColourSeq, 1) < NextNo Then
                ReDim Preserve ColourSeq(NextNo)
            'End If
            For x = 0 To PermNextno
                If x > UBound(MultColour, 1) Then
                    ReDim Preserve MultColour(x + 10)
                    ReDim Preserve ColourSeq(x + 10)
                End If
                Write #1, MultColour(x), ColourSeq(x)
            Next x
            ReDim Preserve TreeTestStats(3, SEventNumber)
            For x = 1 To SEventNumber
                For Y = 0 To 3
                    Write #1, TreeTestStats(Y, x)
                Next Y
            Next x
            
            
            Write #1, GPerms
            If GPerms > 0 Then
                
                For Z = 0 To GPerms
                    For x = 0 To PermNextno
                        For Y = 0 To PermsCurrentXOver(Z, x)
                            Write #1, PermsXOverList(Z, x, Y).Daughter, PermsXOverList(Z, x, Y).MajorP, PermsXOverList(Z, x, Y).MinorP, PermsXOverList(Z, x, Y).Beginning, PermsXOverList(Z, x, Y).Ending
                            Write #1, PermsXOverList(Z, x, Y).Probability, PermsXOverList(Z, x, Y).OutsideFlag, PermsXOverList(Z, x, Y).MissIdentifyFlag
                            Write #1, PermsXOverList(Z, x, Y).PermPVal, PermsXOverList(Z, x, Y).ProgramFlag
                            Write #1, PermsXOverList(Z, x, Y).LHolder, PermsXOverList(Z, x, Y).DHolder
                            Write #1, PermsXOverList(Z, x, Y).BeginP, PermsXOverList(Z, x, Y).EndP
                            Write #1, PermsXOverList(Z, x, Y).SBPFlag, PermsXOverList(Z, x, Y).Accept, PermsXOverList(Z, x, Y).Eventnumber
                        Next Y
                    Next x
                Next Z
            End If
            If FileList(1) <> sFName And sFName <> "LastSave.rdp5" Then

                If FileList(4) <> FileList(3) And FileList(3) <> sFName Then FileList(4) = FileList(3)

                If FileList(3) <> FileList(2) And FileList(2) <> sFName Then FileList(3) = FileList(2)

                If FileList(2) <> FileList(1) And FileList(1) <> sFName Then FileList(2) = FileList(1)
                FileList(1) = sFName
            End If

            If FileList(4) <> "" Then
                Form1.File4Mnu.Caption = FileList(4)
            Else
                Form1.File4Mnu.Caption = "--"
            End If

            If FileList(3) <> "" Then
                Form1.File3Mnu.Caption = FileList(3)
            Else
                Form1.File3Mnu.Caption = "--"
            End If
            
            If FileList(2) <> "" Then
                Form1.File2Mnu.Caption = FileList(2)
            Else
                Form1.File2Mnu.Caption = "--"
            End If

            If FileList(1) <> "" Then
                Form1.File1Mnu.Caption = FileList(1)
            Else
                Form1.File1Mnu.Caption = "--"
            End If
            
            If DebuggingFlag < 2 Then On Error Resume Next
            For x = 1 To SEventNumber
                For Y = 0 To 9
                'ReDim BPCIs(9, 100)
                    If x <= UBound(BPCIs, 2) Then
                        Write #1, BPCIs(Y, x)
                    End If
                Next Y
            Next x
            On Error GoTo 0
            
            'Save group information
            
            If DebuggingFlag < 2 Then On Error Resume Next
            Write #1, SelGrpFlag
            ReDim Preserve GrpMaskSeq(NextNo)
            If SelGrpFlag > 0 Then
                For x = 1 To NextNo
                    Write #1, GrpMaskSeq(x)
                Next x
            End If
            On Error GoTo 0
            'For X = 0 To RBPNum
            '                TBP = RBPPos(X)
            If DebuggingFlag < 2 Then On Error Resume Next
            Write #1, ReassortmentFlag
            If ReassortmentFlag = 1 Then
                Write #1, RBPNum
                For x = 0 To RBPNum
                    Write #1, RBPPos(x)
                Next x
            End If
            
            For x = 0 To AddNum - 1
                Write #1, MethodTime(x)
                
            Next x
            For x = 0 To AddNum - 1
                Write #1, TimeFract(x)
                
            Next x
            
            Write #1, RefNum
            If RefNum > 0 Then
                For x = 0 To PermNextno
                   
                    Write #1, ReferenceList(x)
                    
                
                Next x
                For x = 0 To RefNum
                    Write #1, RefGroupName(x)
                    Write #1, ReferenceCols(x)
                Next x
            End If
            '= MethodTime(X) + Abs(ET - SAll) * TimeFract(X)
            
            
            
            
            For x = 1 To SEventNumber
                Write #1, YannWarn(x)
            Next x
            
            
            
            
            Dim NumEntries As Long
            NumEntries = 0
            For x = 0 To UBound(Worthwhilescan, 1)
                If Worthwhilescan(x) > 0 Then
                    NumEntries = NumEntries + 1
                End If
            
            Next x
            ZZ = 0
            ZZ = 0
            If NumEntries < UBound(Worthwhilescan, 1) Then
                Write #1, UBound(Worthwhilescan, 1) '94 610 454
                Write #1, NumEntries '864 350
                
                For x = 0 To UBound(Worthwhilescan, 1)
'                    If X = 53448 Then
'                        X = X
'                    End If
                    If Worthwhilescan(x) > 0 Then
                        ZZ = ZZ + 1
'                        If ZZ = 53448 Then
'                            X = X
'                        End If
                        Write #1, x, Worthwhilescan(x)
                        
                    End If
                
                Next x
            End If
            
'            For X = 0 To UBound(Worthwhilescan, 1)
'                If Worthwhilescan(X) > 0 Then
'                    NumEntries = NumEntries + 1
'                    lastone = Worthwhilescan(X)
'                End If
'                If Worthwhilescan(X) > 255 Then
'
'                    X = X
'                End If
'            Next X
            
            On Error GoTo 0
            Close #1
            
            If NextNo > 1000 Then
                Dim SM() As Single
                Call UnModSeqNum(0)
                Call UnModNextno
                ReDim SM(NextNo, NextNo)
                For x = 0 To NextNo
                    For Y = x + 1 To NextNo
                        SM(x, Y) = PermValid(x, Y)
                        SM(Y, x) = PermDIffs(x, Y)
                    Next Y
                Next x
                Open sFName + "SM" For Binary As #1
                Put #1, , SM()
                Close #1
            End If
            
            Form1.ProgressBar1.Value = 100
            Form1.SSPanel1.Caption = ""
            Form1.ProgressBar1.Value = 0
            Call UpdateF2Prog

            
End Sub
Public Sub GCXoverDIV(FindallFlag)

Dim lP As Single, Dummy As Variant, Y1 As Long, Y2 As Long, X1 As Long, X2 As Long, Prob As Variant, COff As Variant, Ac As Long, tMi As Long, tMa As Long
Dim SIP As Long, GG As Long, b As Long, ETarget As Long, BTarget As Long, A As Long, Z As Long, BEE As Long, ENN As Long, EWarn As Byte, BWarn As Byte, LastMPV As Double, GoOn As Byte, ZZZXZ As Long, SplitX As Long
Dim PBinFlag As Long

PBinFlag = -1
If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If
If (PermDIffs(Seq1, Seq2) < 3 Or PermDIffs(Seq1, Seq3)) < 3 Or PermDIffs(Seq2, Seq3) < 3 Then
    If CLine = "" Or CLine = " " Then
        Exit Sub
    End If
End If
'this is the auto triplet scanning version of geneconv
Dim Beginning As Long, Ending As Long, DoneRedo As Byte, LTG As Single, Critval(5) As Double, PVM1 As Double, KMTL As Double
Dim LSeq As Long, Y As Long, x As Long, SX As Long, NDiff() As Long, MissPen() As Double, MissPenB() As Single
Dim MaxX As Long, MaxY As Long, MPV As Double
Dim TempScore As Long
Dim ProbabilityXOver As Double
Dim KAScore As Variant, PVal As Double, MaxScore As Double, LKLen As Double
Dim Polys As Long, Diffs As Long
Dim FragSep() As Long, FragCount(6) As Long
Dim MaxDiff As Long
Dim MinDiff As Long
Dim FragMinScore As Long, tPX As Double
Dim LL(5) As Double, KMax(5) As Double, Q As Double, P As Double, mX As Long
Dim DoneThis As Byte, b1 As Long, E1 As Long
Dim PCO As Double
'
LSeq = Len(StrainSeq(0))


'XX = FragScore(121, 0)
'XX = FragScore(121, 1)
'XX = FragScore(121, 2)
'XX = FragScore(0, 3)
'XX = FragScore(106, 4)
'XX = FragScore(106, 5)
' 1.000 5k perms
'2.766 5k perms


ReDim NDiff(5)
'find relevant sites
'this coluld be speeded up with better nesting of if then's

'for some reason only looking at non-identical sites (with FindSubSeqGCA2) is slower

'LenXOverSeq = FindSubSeqGCA(GCIndelFlag, LSeq, Seq1, Seq2, Seq3, SeqNum(0, 0), SubSeq(0, 0), XPosDiff(0), XDiffPos(0), NDiff(0))
''''''''''''''
LenXoverSeq = FindSubSeqGCAP2(GCIndelFlag, LSeq, Seq1, Seq2, Seq3, SeqNum(0, 0), SubSeq(0, 0), XPosDiff(0), XDiffPos(0), NDiff(0), BinArray(0, 0))
'XX = NDiff(2)

If NDiff(0) = LenXoverSeq Or NDiff(1) = LenXoverSeq Or NDiff(2) = LenXoverSeq Then Exit Sub


'2.223
'1.883
'lxo = 349,n0=250,1=39,2=49,3=289,4=299,5=88

'XDiffPos(LenXOverSeq + 1) = LSeq
'
'Y = XDiffPos(LenXOverSeq) + 1
'
'For X = Y To LSeq
'    XPosDiff(X) = LenXOverSeq
'Next

SubSeq(LenXoverSeq + 1, 0) = 0
SubSeq(LenXoverSeq + 1, 1) = 0
SubSeq(LenXoverSeq + 1, 2) = 0
SubSeq(LenXoverSeq + 1, 6) = 0

HiFragScore(0) = 0
HiFragScore(1) = 0
HiFragScore(2) = 0
HiFragScore(3) = 0
HiFragScore(4) = 0
'
HiFragScore(5) = 0

'for outer frags (ie matches instead of differences)
NDiff(3) = NDiff(0) + NDiff(1) 'seq1
NDiff(4) = NDiff(0) + NDiff(2)  'seq2
NDiff(5) = NDiff(1) + NDiff(2)  'seq3


'for inner fargs (ie genuine differences)
NDiff(0) = LenXoverSeq - NDiff(0)
NDiff(1) = LenXoverSeq - NDiff(1)
NDiff(2) = LenXoverSeq - NDiff(2)

LTG = LenXoverSeq * GCMissmatchPen


ReDim MissPen(5)
'ltg=349

MissPen(0) = Int(LTG / NDiff(0)) + 1
MissPen(1) = Int(LTG / NDiff(1)) + 1
MissPen(2) = Int(LTG / NDiff(2)) + 1
'mpen = 4,2,2
MaxDiff = 0
MinDiff = LSeq
'
For x = 0 To 5
    If MinDiff > NDiff(x) Then MinDiff = NDiff(x)
    If MaxDiff < NDiff(x) Then MaxDiff = NDiff(x)
    
Next x

If MinDiff < 3 And MaxDiff > MinDiff * 10 Then Exit Sub


If NDiff(3) = 0 Then NDiff(3) = 1
If NDiff(4) = 0 Then NDiff(4) = 1
If NDiff(5) = 0 Then NDiff(5) = 1

MissPen(3) = Int(LTG / NDiff(3)) + 1

MissPen(4) = Int(LTG / NDiff(4)) + 1
MissPen(5) = Int(LTG / NDiff(5)) + 1

'ReDim MissPenB(5)
'MissPenB(0) = MissPen(0)
'MissPenB(1) = MissPen(1)
'MissPenB(2) = MissPen(2)
'MissPenB(3) = MissPen(3)
'MissPenB(4) = MissPen(4)
'MissPenB(5) = MissPen(5)
'ReDim FragMaxScore(gcdimsize, 5)
'                ReDim MaxScorePos(gcdimsize, 5)
'                ReDim PVals(gcdimsize, 5)
'                ReDim FragSt(gcdimsize, 6)
'                ReDim FragEn(gcdimsize, 6)
'                ReDim FragScore(gcdimsize, 6)

'1.962
'1.563 desktop

'Find Fragments

'GoOn = GetFrags(CircularFlag, LenXOverSeq, Len(StrainSeq(0)), GCDimSize, SubSeq(0, 0), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))
''''''''''

GoOn = GetFragsP(CircularFlag, LenXoverSeq, LSeq, GCDimSize, SubSeq(0, 0), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))



If GoOn = 0 And ShortOutFlag <> 3 Then Exit Sub


'For X = 0 To 6
'    FragSt(FragCount(X), X) = LenXOverSeq
'    FragEn(FragCount(X), X) = LenXOverSeq
'Next X

If x = x Then
    
    
    'GetMaxFragScoreB LenXOverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPenB(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    'getmaxfragscore LenXOverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    '''''''
    GetMaxFragScoreP LenXoverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    '
    x = x
    
Else
        GetMaxFragScoreB LenXoverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)

'    For X = 0 To 5
'
'        'need to change this to just sum fragments from one end of the genome component to the other
'
'        'HiScore(X) = 0
'        'os3 = X*os2;
'        MPen = MissPen(X)
'        For Y = 0 To FragCount(X)
'            FragMaxScore(Y, X) = 0
'            If FragScore(Y, X) > 0 Then
'
'                TempScore = FragScore(Y, X)
'                TS = TempScore
'                Polys = TS
'                Diffs = 0
'                FragMaxScore(Y, X) = TS
'
'                MaxScorePos(Y, X) = Y
'
'                For Z = Y + 1 To FragCount(X)
'                    FS = Abs(FragScore(Z, X))
'                    Polys = Polys + FS
'
'                    If FragScore(Z, X) <= 0 Then
'                        Diffs = Diffs + FS
'                    End If
'
'                    TempScore = (Polys - Diffs) - (Diffs * MPen)
'                    TS = CInt(TempScore)
'
'                    If TS >= FragMaxScore(Y, X) Then
'                        FragMaxScore(Y, X) = TS
'                        MaxScorePos(Y, X) = Z
'
'                    ElseIf TS < 0 Then
'                        Exit For
'                    End If
'
'                Next Z
'            '    If FragMaxScore(Y, X) > HiScore(X) Then
'            '        HiScore(X) = FragMaxScore(Y, X)
'            '    End If
'            End If
'        Next Y
'    Next X
    
End If
''Exit Sub

'11.877,11.827
'11.1126 - using offsets
'11.026,11.036 - using offsets in maxfragscore rather than a holder.

'5.671, 5.656 -desktop

'This could be encorporated into getmaxfragscore - highfragscore could be set to zero if below the cutoff an passed to calkmax - there is also another higenough test later in the code that could be avoided
'highenough used in gccalpval and gcgethipval
For x = 0 To 5
    If HiFragScore(x) > 3 Then
        HighEnough(x) = 1
    Else
        HighEnough(x) = 0
    End If
Next x


'Calc LL and KMax

'GoOn = CalcKMaxP(GCMissmatchPen, LenXOverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), CritVal(0), MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))

'5.688,5.687


'//(log(kmax*lenxoverseq)-log(-log(1-pval)))/ll(x) = score
'calculate critical fragment length



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Maybe port this bit to c++

'Exit Sub
'
'If X = 12345 Then ' this bit has to be uncommented if i need to go back to using calkkmax
    GoOn = CalcKMaxP(GCMissmatchPen, LenXoverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), Critval(0), MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))
'Else
'    GoOn = CalcKMax(GCMissmatchPen, LenXOverSeq, MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))
'    If MCFlag = 0 Then
'        PCO = LowestProb / MCCorrection
'    Else
'        PCO = LowestProb
'    End If
'
'    If PCO > 1 Then
'        Exit Sub
'    End If
'
'
'
'    For X = 0 To 5
'        If KMax(X) > 0 Then
'            KMTL = KMax(X) * LenXOverSeq
'
'            KMTL = Log(KMTL)
'
'            PVM1 = (1 - PCO)
'
'            If PVM1 > 0 Then
'                PVM1 = -Log(PVM1)
'
'                If PVM1 > 0 Then
'                    PVM1 = -Log(PVM1)
'                    CritVal(X) = (KMTL + PVM1) / LL(X)
'                    If CritVal(X) < 4 Then CritVal(X) = 4
'                Else
'                    CritVal(X) = 4
'                End If
'            Else
'                CritVal(X) = 4
'            End If
'        End If
'    Next X
'
'    GoOn = 0
'    For X = 0 To 5
'        HighEnough(X) = 0
'        If HiFragScore(X) > 3 And HiFragScore(X) > CritVal(X) Then
'            HighEnough(X) = 1
'            GoOn = 1
'        End If
'    Next X
'End If
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

If GoOn = 0 Then Exit Sub



'5.813,5.828

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''GCCalcPValP gives a different result to this version - it may be correct but I've gone with the older one
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

MaxScore = GCCalcPVal(GCDimSize, LenXoverSeq, FragMaxScore(0, 0), PVals(0, 0), FragCount(0), KMax(0), LL(0), HighEnough(0), Critval(0))

'5.906,5.844

If ShortOutFlag = 3 Then
    If MaxScore * MCCorrection <= mtP(1) Then
        mtP(1) = MaxScore * MCCorrection
    End If
End If


If MaxScore > PCO Then Exit Sub

Dummy = ClearDeleteArray(LenXoverSeq + 1, DeleteArray(0))

DoneThis = 0
ZZZXZ = 0
'Exit Sub


Do
    
    LastMPV = MPV
    'XX = CSng(MPV)
    'MPV = 0
'    If UBound(PVals, 1) <> GCDimSize Then
'    X = X
'    End If
'    For X = 0 To 6
'        If FragCount(X) > GCDimSize Then
'            X = X
'        End If
'    Next X
'If LenXoverSeq = 1683 Then
'    X = X
'End If
    MPV = GCGetHiPValP(GCDimSize, LenXoverSeq, FragCount(0), PVals(0, 0), MaxY, MaxX, HighEnough(0))
    
    ZZZXZ = ZZZXZ + 1
    
    'The limit was 100 and not 10 - 100 would possibly be better in some cases'but 10 will always be ~30% faster
    If MPV = LastMPV And ZZZXZ > 10 Then
        Exit Sub
    End If
    
    '10.425,10.735
    '9.974
   ' If zzzxz = 1 And Seq1 = 16 And Seq3 = 38 And Seq2 = 24 And SEventNumber = 2 Then
   '     X = X
   ' End If
    
    If MPV > PCO Or MPV = 1 Then Exit Sub
    x = MaxX
    Y = MaxY
    
    
    GoOn = DelPValsP(GCMaxOverlapFrags, Y, x, GCDimSize, PVals(0, 0), FragCount(0), FragSt(0, 0), FragEn(0, 0), MaxScorePos(0, 0), DeleteArray(0))
    
    If GoOn = 1 Then
        
        
        
        'For Y = 0 To FragCount(X)
            'If FragSt(Y, X) > 0 Then
                
                
                'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
                If PVals(Y, x) < PCO Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                    
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 Then
                                
                                    Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 2
                                
                                End If
                                
                            End If
                        End If
                    End If
                    
                    If FragSt(Y, x) > 0 Then
                        If LongWindedFlag = 0 Then
                            Beginning = XDiffPos(FragSt(Y, x) - 1) + 1
                        Else
                             
                            Beginning = XDiffPos(FragSt(Y, x))
                        End If
                    Else
                        Beginning = 1
                    End If
                    If LongWindedFlag = 0 Then
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x) + 1) - 1
                    Else
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x))
                    End If
                    
                    
                    If LongWindedFlag = 1 Then
                        If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                           
                        ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                            
                        ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                           
                            
                        ElseIf StoreLPV(1, Seq1) >= StoreLPV(1, Seq2) And StoreLPV(1, Seq1) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq2) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq2) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq3) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq3) >= StoreLPV(1, Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                        'check to see if an event has been extended accross a tract of
                        'missing data
                         SplitX = 0
                         EWarn = 0
                         BWarn = 0
                        If XPosDiff(Beginning) > 0 Then
                            BEE = XDiffPos(XPosDiff(Beginning) - 1)
                        Else
                            BEE = Beginning
                        End If
                        If XDiffPos(Ending) < LSeq Then
                            ENN = XDiffPos(XPosDiff(Ending) + 1)
                        Else
                            ENN = Ending
                        End If
                        If BEE < 1 Then BEE = LSeq
                        If ENN > LSeq Then ENN = 1
                        If DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                            Z = CheckSplitP(10, LSeq, BEE, ENN, Seq1, Seq2, Seq3, SplitX, MissingData(0, 0))
                        Else
                            Z = Len(StrainSeq(0))
                        End If
                    Else
                        SplitX = 0
                        If x = 0 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 1 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq2
                        ElseIf x = 2 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq1
                        ElseIf x = 3 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 4 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf x = 5 Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq1
                        End If
                    End If
                    'SplitX = 0
                    'If X >= 3 Then SplitX = 0
                    
                    If SplitX = 1 And x < 3 Then
                        For A = 0 To 1
                            If A = 0 Then
                                BTarget = XPosDiff(Beginning)
                                
                                ETarget = XPosDiff(Z) - 1
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                            Else
                                b = FindMissingP(LSeq, Seq1, Seq2, Seq3, Z, Ending, MissingData(0, 0))
                                If XPosDiff(b) <> 0 Then
                                    BTarget = XPosDiff(b) + 1
                                Else
                                    GG = b
                                    
                                    Do While XPosDiff(GG) = 0
                                        GG = GG + 1
                                        
                                        If GG > LSeq Then
                                            GG = 0
                                            
                                        End If
                                    Loop
                                    BTarget = XPosDiff(GG)
                                End If
                                ETarget = XPosDiff(Ending)
                                
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                            End If
                            
                            ProbabilityXOver = MakeSubProbP(x, LSeq, LenXoverSeq, BTarget, ETarget, SubSeq(0, 0), LL(0), KMax(0), MissPen(0), Critval(0))
                            If ProbabilityXOver < PCO Then
                            '3.8621
                                If MCFlag = 0 Then
                                    ProbabilityXOver = ProbabilityXOver * MCCorrection
                                End If
                                If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                
                                
                                    
                                
                                    'Keep track of signal numbers
                                    oRecombNo(100) = oRecombNo(100) + 1
                                    oRecombNo(1) = oRecombNo(1) + 1
                                    If APermFlag = 0 Then
                                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                                    Else
                                        SIP = 1
                                    End If
                                        
                                    If MCFlag = 2 Then
                                        lP = -Log10(ProbabilityXOver) * 2
                                        If lP > 0 And lP < 100 Then
                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                        ElseIf CInt(lP) >= 100 Then
                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                        End If
                                    End If
                                    'if p high eough then add it to list, if not discard then repeat from Z to en.
                                    ActualFound = 1
                                    If SIP > 0 Then
                                        Beginning = XDiffPos(BTarget)
                                        Ending = XDiffPos(ETarget)
                                        If ActiveSeq > UBound(XoverList, 1) Then Exit Sub
                                        XoverList(ActiveSeq, SIP).Beginning = Beginning
                                        XoverList(ActiveSeq, SIP).Ending = Ending
                                        XoverList(ActiveSeq, SIP).DHolder = 0
                                        
                                        
                                        'Make a reminder that one of the berakpoints went undetected
                                        If A = 0 Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                            EWarn = 1
                                        Else
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                            BWarn = 1
                                        End If
                                        
                                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                                        XoverList(ActiveSeq, SIP).ProgramFlag = 1
                                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 1 Then BWarn = 1
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 2 Then EWarn = 1
                                        'If SEventNumber > 0 Or X = X Then
                                            If EWarn = 0 Then Call CheckEndsVB(0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB(0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                        'End If
                                        Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                                        Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                                        If FindallFlag = 1 And X = 12345 Then
'                                            If APermFlag = 0 Then
'                                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                            Else
'                                                SIP = 1
'                                            End If
'                                            If SIP > 0 Then
'                                                XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                                XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                                XOverlist(ActiveSeq, SIP).Beginning = Ending
'
'                                            End If
'                                        End If
'                                        If X = 12345 Then
'                                            If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            Else
'                                                For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            End If
'                                            'XX = ZZZXZ
'                                        End If
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(1) = 1
                                            AbortFlag = 1
                                            Exit Sub
                                        End If
                                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(1) = 1
                                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                                        End If
                                    ElseIf DoneRedo = 0 Then
                                        DoneRedo = 1
                                        Call AddToRedoList(1, Seq1, Seq2, Seq3)
                                        
                                    End If
                                        
                                End If
                                
                            End If
                            
                        Next A
                    ElseIf SplitX = 0 Then
                        If MCFlag = 0 Then
                            ProbabilityXOver = PVals(Y, x) * MCCorrection
                        Else
                            ProbabilityXOver = PVals(Y, x)
                        End If
                        
                        If MCFlag = 2 Then
                            lP = -Log10(ProbabilityXOver) * 2
                            If lP > 0 And lP < 100 Then
                                PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                            ElseIf CInt(lP) >= 100 Then
                                PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                            End If
                        End If
                        
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(1) = oRecombNo(1) + 1
                        
                        If APermFlag = 0 Then
                            Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                        Else
                            SIP = 1
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(1) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                        ActualFound = 1
                        NewOneFound = 1
                        If SIP > 0 Then
                            
                            XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                            XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                            XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                            XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                            XoverList(ActiveSeq, SIP).Beginning = Beginning
                            XoverList(ActiveSeq, SIP).Ending = Ending
                            XoverList(ActiveSeq, SIP).ProgramFlag = 1
                            XoverList(ActiveSeq, SIP).DHolder = 0
                            
                            ''If SEventNumber > 0 Or X = X Then
                                If EWarn = 0 Then Call CheckEndsVB(0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB(0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                            
                           '' End If
                            Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                            If FindallFlag = 1 And X = 12345 Then
'                                If APermFlag = 0 Then
'                                    Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                Else
'                                    SIP = 1
'                                End If
'                                If SIP > 0 Then
'                                    XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                    XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                    XOverlist(ActiveSeq, SIP).Beginning = Ending
'                                End If
'                            End If
                            
                            'If Seq1 = 57 Or Seq2 = 57 Or Seq3 = 57 And XOverList(ActiveSeq, SIP).Beginning = 2301 And XOverList(ActiveSeq, SIP).Ending = 53 Then
                            '                XxX = SEventNumber
                            '            End If
                                        
'                                    If X = 12345 Then
'                                        If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        Else
'                                            For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        End If
'                                       'XX = ZZZXZ
'                                    End If
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                
                                StartPlt(1) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                            End If
                            
                        ElseIf DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(1, Seq1, Seq2, Seq3)
                        End If
                   Else
                        FragMaxScore(MaxY, MaxX) = 0
                   End If
                   tMa = ActiveMajorP
                   tMi = ActiveMinorP
                   Ac = ActiveSeq
                        
                                      
                    ActiveMajorP = tMa
                    ActiveMinorP = tMi
                    ActiveSeq = Ac
                    
                    If ShowPlotFlag = 1 And DoneThis = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call DoAxes(0, 0, Decompress(LSeq), -1, CSng(-Log10(MaxScore)), 0, 1, "-Log(KA P-Val)")
                            
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
                            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
                        End If
                        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                        If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection
                        Form1.Picture2.ForeColor = QBColor(0)
                        COff = -Log10((LowestProb / (MCCorrection)))
                        Y1 = PicHeight - (15 + (COff / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 2
                        Y1 = PicHeight - (15 + (-Log10(LowestProb) / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 0
                        'Form1.Picture7.AutoRedraw = True
                        DoneThis = 1
                        
                        For A = 5 To 0 Step -1
                            
    
                            If A = 0 Then
                                Form1.Picture7.ForeColor = Yellow
                            ElseIf A = 1 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 2 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 3 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 4 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 5 Then
                                Form1.Picture7.ForeColor = Yellow
                            End If
                            
                            
                                For b = 0 To FragCount(A)
                                    If PVals(b, A) < 0.9999 And PVals(b, A) > 0 Then
                                    
                                        Prob = -Log10(PVals(b, A))
                                        
                                        If FragSt(b, A) > 0 Then
                                            b1 = XDiffPos(FragSt(b, A) - 1) + 1
                                        Else
                                            b1 = 1
                                        End If
                                        E1 = XDiffPos(FragEn(MaxScorePos(b, A), A) + 1) - 1
                                        X1 = 30 + Decompress(b1) * XFactor + XFactor
                                        X2 = 30 + Decompress(E1) * XFactor + XFactor
                                        
                                        
                                        Y1 = PicHeight - (15 + (Prob / -Log10(MaxScore)) * (PicHeight - 35))
                                        Y2 = PicHeight - 15
                                        Form1.Picture7.AutoRedraw = True
                                        'Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
                                    End If
                                Next b
                           
                        Next A
                        Form1.Picture7.Refresh
                        Form1.Frame17.Visible = False
                        'X = X
                        'XX = FragMaxScore(MaxY, MaxX)
                        'XX = FragSt(MaxY, MaxX)
                        'XX = FragEn(MaxY, MaxX)
                        'XX = FragCount(MaxX)
                        'XX = LenXOverSeq
                        'XX = KMax(MaxX)
                        'XX = LL(MaxX)
                        'XX = Log(KMax(MaxX) * LenXOverSeq)
                        'XX = (LL(MaxX) * FragMaxScore(MaxY, MaxX))
                    End If
                    
                    If SplitX = 1 And MaxX > 3 Then
                        PVals(MaxY, MaxX) = 100
                    Else
                        
                       
                            Dummy = MakeDeleteArrayP(FragSt(Y, x), FragEn(MaxScorePos(Y, x), x), FragCount(x), DeleteArray(0))
                       
                    End If
                    
                End If
            'Else
            '    Exit For
            'End If
        End If
        
Loop

'124
End Sub


Public Sub GCXoverDV(ElementX As Long, FragSt() As Long, FragEn() As Long, FragScore() As Long, FragCount() As Long, LenXoverSeq As Long, NDiff() As Long, XPosDiff() As Long, XDiffPos() As Long, SubSeq() As Byte, FindallFlag)

Dim lP As Single, Dummy As Variant, Y1 As Long, Y2 As Long, X1 As Long, X2 As Long, Prob As Variant, COff As Variant, Ac As Long, tMi As Long, tMa As Long
Dim SIP As Long, GG As Long, b As Long, ETarget As Long, BTarget As Long, A As Long, Z As Long, BEE As Long, ENN As Long, EWarn As Byte, BWarn As Byte, LastMPV As Double, ZZZXZ As Long, SplitX As Long
Dim PBinFlag As Long

PBinFlag = -1

'this is the auto triplet scanning version of geneconv
Dim Beginning As Long, Ending As Long, DoneRedo As Byte, LTG As Single, Critval(5) As Double, PVM1 As Double, KMTL As Double
Dim LSeq As Long, Y As Long, x As Long, SX As Long, MissPen(5) As Double, MissPenB() As Single
Dim MaxX As Long, MaxY As Long, MPV As Double
Dim TempScore As Long
Dim ProbabilityXOver As Double
Dim KAScore As Variant, PVal As Double, MaxScore As Double, LKLen As Double
Dim Polys As Long, Diffs As Long
Dim FragSep() As Long ' FragCount(6) As Long
Dim MaxDiff As Long
Dim MinDiff As Long
Dim FragMinScore As Long, tPX As Double
Dim LL(5) As Double, KMax(5) As Double, Q As Double, P As Double, mX As Long
Dim DoneThis As Byte, b1 As Long, E1 As Long
Dim PCO As Double
'
LSeq = Len(StrainSeq(0))




'1.266
'GoOn = GetFragsP(CircularFlag, LenXoverSeq, LSeq, GCDimSize, SubSeq(0, 0, ElementX), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))



'For X = 0 To 6
'    FragSt(FragCount(X), X) = LenXOverSeq
'    FragEn(FragCount(X), X) = LenXOverSeq
'Next X

LTG = LenXoverSeq * GCMissmatchPen
MissPen(0) = Int(LTG / NDiff(0, ElementX)) + 1
MissPen(1) = Int(LTG / NDiff(1, ElementX)) + 1
MissPen(2) = Int(LTG / NDiff(2, ElementX)) + 1
MissPen(3) = Int(LTG / NDiff(3, ElementX)) + 1
MissPen(4) = Int(LTG / NDiff(4, ElementX)) + 1
MissPen(5) = Int(LTG / NDiff(5, ElementX)) + 1

HiFragScore(0) = 0
HiFragScore(1) = 0
HiFragScore(2) = 0
HiFragScore(3) = 0
HiFragScore(4) = 0
HiFragScore(5) = 0


'5.281

If x = x Then
    
    
    'GetMaxFragScoreB LenXOverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPenB(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    'getmaxfragscore LenXOverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0), FragCount(0), HiFragScore(0)
    '''''''
    GetMaxFragScoreP LenXoverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0, ElementX), FragCount(0, ElementX), HiFragScore(0)
    '
    x = x
    
Else
        GetMaxFragScoreB LenXoverSeq, GCDimSize, CircularFlag, GCMissmatchPen, MissPen(0), MaxScorePos(0, 0), FragMaxScore(0, 0), FragScore(0, 0, ElementX), FragCount(0, ElementX), HiFragScore(0)


    
End If

Exit Sub


''Exit Sub

'11.877,11.827
'11.1126 - using offsets
'11.026,11.036 - using offsets in maxfragscore rather than a holder.

'5.671, 5.656 -desktop

'This could be encorporated into getmaxfragscore - highfragscore could be set to zero if below the cutoff an passed to calkmax - there is also another higenough test later in the code that could be avoided
'highenough used in gccalpval and gcgethipval
For x = 0 To 5
    If HiFragScore(x) > 3 Then
        HighEnough(x) = 1
    Else
        HighEnough(x) = 0
    End If
Next x


'Calc LL and KMax

'GoOn = CalcKMaxP(GCMissmatchPen, LenXOverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), CritVal(0), MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))

'5.688,5.687


'//(log(kmax*lenxoverseq)-log(-log(1-pval)))/ll(x) = score
'calculate critical fragment length



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Maybe port this bit to c++

'Exit Sub
'
'If X = 12345 Then ' this bit has to be uncommented if i need to go back to using calkkmax
    GoOn = CalcKMaxP(GCMissmatchPen, LenXoverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), Critval(0), MissPen(0), LL(0), KMax(0), NDiff(0, ElementX), HighEnough(0))
    
    
    
    
'    If Seq1 = 1 And Seq2 = 23 And Seq3 = 85 And SEventNumber = 18 Then
'                                            X = X
'                                        End If
    
    
'Else
'    GoOn = CalcKMax(GCMissmatchPen, LenXOverSeq, MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))
'    If MCFlag = 0 Then
'        PCO = LowestProb / MCCorrection
'    Else
'        PCO = LowestProb
'    End If
'
'    If PCO > 1 Then
'        Exit Sub
'    End If
'
'
'
'    For X = 0 To 5
'        If KMax(X) > 0 Then
'            KMTL = KMax(X) * LenXOverSeq
'
'            KMTL = Log(KMTL)
'
'            PVM1 = (1 - PCO)
'
'            If PVM1 > 0 Then
'                PVM1 = -Log(PVM1)
'
'                If PVM1 > 0 Then
'                    PVM1 = -Log(PVM1)
'                    CritVal(X) = (KMTL + PVM1) / LL(X)
'                    If CritVal(X) < 4 Then CritVal(X) = 4
'                Else
'                    CritVal(X) = 4
'                End If
'            Else
'                CritVal(X) = 4
'            End If
'        End If
'    Next X
'
'    GoOn = 0
'    For X = 0 To 5
'        HighEnough(X) = 0
'        If HiFragScore(X) > 3 And HiFragScore(X) > CritVal(X) Then
'            HighEnough(X) = 1
'            GoOn = 1
'        End If
'    Next X
'End If
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

If GoOn = 0 Then Exit Sub



'5.813,5.828

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''GCCalcPValP gives a different result to this version - it may be correct but I've gone with the older one
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

MaxScore = GCCalcPVal(GCDimSize, LenXoverSeq, FragMaxScore(0, 0), PVals(0, 0), FragCount(0, ElementX), KMax(0), LL(0), HighEnough(0), Critval(0))

'5.906,5.844

If ShortOutFlag = 3 Then
    If MaxScore * MCCorrection <= mtP(1) Then
        mtP(1) = MaxScore * MCCorrection
    End If
End If


If MaxScore > PCO Then Exit Sub

Dummy = ClearDeleteArray(LenXoverSeq + 1, DeleteArray(0))

DoneThis = 0
ZZZXZ = 0
'Exit Sub


Do
    
    LastMPV = MPV
    'XX = CSng(MPV)
    'MPV = 0
'    If UBound(PVals, 1) <> GCDimSize Then
'    X = X
'    End If
'    For X = 0 To 6
'        If FragCount(X, ElementX) > GCDimSize Then
'            X = X
'        End If
'    Next X

'If LenXoverSeq = 1683 Then
'    X = X
'    XX = Seq1
'    XX = Seq2
'    XX = Seq3
'
'End If

    MPV = GCGetHiPValP(GCDimSize, LenXoverSeq, FragCount(0, ElementX), PVals(0, 0), MaxY, MaxX, HighEnough(0))
    
    
    
    ZZZXZ = ZZZXZ + 1
    
    'The limit was 100 and not 10 - 100 would possibly be better in some cases'but 10 will always be ~30% faster
    If MPV = LastMPV And ZZZXZ > 10 Then
        Exit Sub
    End If
    
    '10.425,10.735
    '9.974
    If Seq1 = 36 And Seq2 = 52 And Seq3 = 85 And SEventNumber = 17 Then
        x = x
    End If
    
    If MPV > PCO Or MPV = 1 Then Exit Sub
    x = MaxX
    Y = MaxY
    
    
    GoOn = DelPValsP(GCMaxOverlapFrags, Y, x, GCDimSize, PVals(0, 0), FragCount(0, ElementX), FragSt(0, 0, ElementX), FragEn(0, 0, ElementX), MaxScorePos(0, 0), DeleteArray(0))
    
    If GoOn = 1 Then
        
        
        
        'For Y = 0 To FragCount(X)
            'If FragSt(Y, X) > 0 Then
                
                
                'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
                If PVals(Y, x) < PCO Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                    
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 Then
                                
                                    Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 2
                                
                                End If
                                
                            End If
                        End If
                    End If
                    
                    If FragSt(Y, x, ElementX) > 0 Then
                        If LongWindedFlag = 0 Then
                            Beginning = XDiffPos(FragSt(Y, x, ElementX) - 1, ElementX) + 1
                        Else
                             
                            Beginning = XDiffPos(FragSt(Y, x, ElementX), ElementX)
                        End If
                    Else
                        Beginning = 1
                    End If
                    If LongWindedFlag = 0 Then
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x, ElementX) + 1, ElementX) - 1
                    Else
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x), x, ElementX), ElementX)
                    End If
                    
                    
                    If LongWindedFlag = 1 Then
                        If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                           
                        ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                            
                        ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                           
                            
                        ElseIf StoreLPV(1, Seq1) >= StoreLPV(1, Seq2) And StoreLPV(1, Seq1) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq2) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq2) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq3) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq3) >= StoreLPV(1, Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                        'check to see if an event has been extended accross a tract of
                        'missing data
                         SplitX = 0
                         EWarn = 0
                         BWarn = 0
                        If XPosDiff(Beginning, ElementX) > 0 Then
                            BEE = XDiffPos(XPosDiff(Beginning, ElementX) - 1, ElementX)
                        Else
                            BEE = Beginning
                        End If
                        If XDiffPos(Ending, ElementX) < LSeq Then
                            ENN = XDiffPos(XPosDiff(Ending, ElementX) + 1, ElementX)
                        Else
                            ENN = Ending
                        End If
                        If BEE < 1 Then BEE = LSeq
                        If ENN > LSeq Then ENN = 1
                        
'                        If Seq1 = 31 And Seq2 = 37 And Seq3 = 96 And SEventNumber = 20 Then
'                            X = X
'                        End If
                        
                        If DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                            Z = CheckSplitP(10, LSeq, BEE, ENN, Seq1, Seq2, Seq3, SplitX, MissingData(0, 0))
                        Else
                            Z = Len(StrainSeq(0))
                        End If
                    Else
                        SplitX = 0
                        If x = 0 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 1 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq2
                        ElseIf x = 2 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq1
                        ElseIf x = 3 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 4 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf x = 5 Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq1
                        End If
                    End If
                    'SplitX = 0
                    'If X >= 3 Then SplitX = 0
                    
                    If SplitX = 1 And x < 3 Then
                        For A = 0 To 1
                            If A = 0 Then
                                BTarget = XPosDiff(Beginning, ElementX)
                                
                                ETarget = XPosDiff(Z, ElementX) - 1
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                                'If ETarget <= 0 Then ETarget = 1
                            Else
                                b = FindMissingP(LSeq, Seq1, Seq2, Seq3, Z, Ending, MissingData(0, 0))
                                If XPosDiff(b, ElementX) <> 0 Then
                                    BTarget = XPosDiff(b, ElementX) + 1
                                Else
                                    GG = b
                                    
                                    Do While XPosDiff(GG, ElementX) = 0
                                        GG = GG + 1
                                        
                                        If GG > LSeq Then
                                            GG = 0
                                            
                                        End If
                                    Loop
                                    BTarget = XPosDiff(GG, ElementX)
                                End If
                                ETarget = XPosDiff(Ending, ElementX)
                                
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                                'If ETarget <= 0 Then ETarget = 1
                            End If
                            
                            ProbabilityXOver = MakeSubProbP(x, LSeq, LenXoverSeq, BTarget, ETarget, SubSeq(0, 0, ElementX), LL(0), KMax(0), MissPen(0), Critval(0))
                            If ProbabilityXOver < PCO Then
                            '3.8621
                                If MCFlag = 0 Then
                                    ProbabilityXOver = ProbabilityXOver * MCCorrection
                                End If
                                If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                
                                
                                    
                                
                                    'Keep track of signal numbers
                                    oRecombNo(100) = oRecombNo(100) + 1
                                    oRecombNo(1) = oRecombNo(1) + 1
                                    If APermFlag = 0 Then
                                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                                    Else
                                        SIP = 1
                                    End If
                                        
                                    If MCFlag = 2 Then
                                        lP = -Log10(ProbabilityXOver) * 2
                                        If lP > 0 And lP < 100 Then
                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                        ElseIf CInt(lP) >= 100 Then
                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                        End If
                                    End If
                                    'if p high eough then add it to list, if not discard then repeat from Z to en.
                                    ActualFound = 1
                                    NewOneFound = 1
                                    If SIP > 0 Then
                                      
                                        Beginning = XDiffPos(BTarget, ElementX)
                                        Ending = XDiffPos(ETarget, ElementX)
                                        If ActiveSeq > UBound(XoverList, 1) Then Exit Sub
                                        XoverList(ActiveSeq, SIP).Beginning = Beginning
                                        XoverList(ActiveSeq, SIP).Ending = Ending
                                        XoverList(ActiveSeq, SIP).DHolder = 0
                                        
                                        
                                        'Make a reminder that one of the berakpoints went undetected
                                        If A = 0 Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                            EWarn = 1
                                        Else
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                            BWarn = 1
                                        End If
                                        
                                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                                        XoverList(ActiveSeq, SIP).ProgramFlag = 1
                                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 1 Then BWarn = 1
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 2 Then EWarn = 1
                                        'If SEventNumber > 0 Or X = X Then
                                            If EWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                        'End If
                                        Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                                        Call CentreBP2(ElementX, 0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                                        If FindallFlag = 1 And X = 12345 Then
'                                            If APermFlag = 0 Then
'                                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                            Else
'                                                SIP = 1
'                                            End If
'                                            If SIP > 0 Then
'                                                XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                                XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                                XOverlist(ActiveSeq, SIP).Beginning = Ending
'
'                                            End If
'                                        End If
'                                        If X = 12345 Then
'                                            If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            Else
'                                                For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            End If
'                                            'XX = ZZZXZ
'                                        End If
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(1) = 1
                                            AbortFlag = 1
                                            Exit Sub
                                        End If
                                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(1) = 1
                                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                                        End If
                                    ElseIf DoneRedo = 0 Then
                                        DoneRedo = 1
                                        Call AddToRedoList(1, Seq1, Seq2, Seq3)
                                    End If
                                        
                                End If
                                
                            End If
                            
                        Next A
                    ElseIf SplitX = 0 Then
                        If MCFlag = 0 Then
                            ProbabilityXOver = PVals(Y, x) * MCCorrection
                        Else
                            ProbabilityXOver = PVals(Y, x)
                        End If
                        
                        If MCFlag = 2 Then
                            lP = -Log10(ProbabilityXOver) * 2
                            If lP > 0 And lP < 100 Then
                                PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                            ElseIf CInt(lP) >= 100 Then
                                PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                            End If
                        End If
                        
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(1) = oRecombNo(1) + 1
                        
                        If APermFlag = 0 Then
                            Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                        Else
                            SIP = 1
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(1) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                        ActualFound = 1
                        NewOneFound = 1
                        If SIP > 0 Then
                            
                            XoverList(ActiveSeq, SIP).Daughter = ActiveSeq '30
                            XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP '6
                            XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP '0
                            XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver '1.3 10-3
                            XoverList(ActiveSeq, SIP).Beginning = Beginning '5403
                            XoverList(ActiveSeq, SIP).Ending = Ending '5657
                            XoverList(ActiveSeq, SIP).ProgramFlag = 1
                            XoverList(ActiveSeq, SIP).DHolder = 0
                            
                            ''If SEventNumber > 0 Or X = X Then
                                If EWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                            
                           '' End If
                            Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                            Call CentreBP2(ElementX, 0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                            If FindallFlag = 1 And X = 12345 Then
'                                If APermFlag = 0 Then
'                                    Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                Else
'                                    SIP = 1
'                                End If
'                                If SIP > 0 Then
'                                    XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                    XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                    XOverlist(ActiveSeq, SIP).Beginning = Ending
'                                End If
'                            End If
                            
                            'If Seq1 = 57 Or Seq2 = 57 Or Seq3 = 57 And XOverList(ActiveSeq, SIP).Beginning = 2301 And XOverList(ActiveSeq, SIP).Ending = 53 Then
                            '                XxX = SEventNumber
                            '            End If
                                        
'                                    If X = 12345 Then
'                                        If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        Else
'                                            For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        End If
'                                       'XX = ZZZXZ
'                                    End If
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                
                                StartPlt(1) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                            End If
                            
                        ElseIf DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(1, Seq1, Seq2, Seq3)
                        End If
                   Else
                        FragMaxScore(MaxY, MaxX) = 0
                   End If
                   tMa = ActiveMajorP
                   tMi = ActiveMinorP
                   Ac = ActiveSeq
                        
                                      
                    ActiveMajorP = tMa
                    ActiveMinorP = tMi
                    ActiveSeq = Ac
                    
                    If ShowPlotFlag = 1 And DoneThis = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call DoAxes(0, 0, Decompress(LSeq), -1, CSng(-Log10(MaxScore)), 0, 1, "-Log(KA P-Val)")
                            
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
                            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
                        End If
                        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                        If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection
                        Form1.Picture2.ForeColor = QBColor(0)
                        COff = -Log10((LowestProb / (MCCorrection)))
                        Y1 = PicHeight - (15 + (COff / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 2
                        Y1 = PicHeight - (15 + (-Log10(LowestProb) / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 0
                        'Form1.Picture7.AutoRedraw = True
                        DoneThis = 1
                        
                        For A = 5 To 0 Step -1
                            
    
                            If A = 0 Then
                                Form1.Picture7.ForeColor = Yellow
                            ElseIf A = 1 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 2 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 3 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 4 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 5 Then
                                Form1.Picture7.ForeColor = Yellow
                            End If
                            
                            
                                For b = 0 To FragCount(A, ElementX)
                                    If PVals(b, A) < 0.9999 And PVals(b, A) > 0 Then
                                    
                                        Prob = -Log10(PVals(b, A))
                                        
                                        If FragSt(b, A, ElementX) > 0 Then
                                            b1 = XDiffPos(FragSt(b, A, ElementX) - 1, ElementX) + 1
                                        Else
                                            b1 = 1
                                        End If
                                        E1 = XDiffPos(FragEn(MaxScorePos(b, A), A, ElementX) + 1, ElementX) - 1
                                        X1 = 30 + Decompress(b1) * XFactor + XFactor
                                        X2 = 30 + Decompress(E1) * XFactor + XFactor
                                        
                                        
                                        Y1 = PicHeight - (15 + (Prob / -Log10(MaxScore)) * (PicHeight - 35))
                                        Y2 = PicHeight - 15
                                        Form1.Picture7.AutoRedraw = True
                                        'Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
                                    End If
                                Next b
                           
                        Next A
                        Form1.Picture7.Refresh
                        Form1.Frame17.Visible = False
                        'X = X
                        'XX = FragMaxScore(MaxY, MaxX)
                        'XX = FragSt(MaxY, MaxX)
                        'XX = FragEn(MaxY, MaxX)
                        'XX = FragCount(MaxX)
                        'XX = LenXOverSeq
                        'XX = KMax(MaxX)
                        'XX = LL(MaxX)
                        'XX = Log(KMax(MaxX) * LenXOverSeq)
                        'XX = (LL(MaxX) * FragMaxScore(MaxY, MaxX))
                    End If
                    
                    If SplitX = 1 And MaxX > 3 Then
                        PVals(MaxY, MaxX) = 100
                    Else
                        
                       
                            Dummy = MakeDeleteArrayP(FragSt(Y, x, ElementX), FragEn(MaxScorePos(Y, x), x, ElementX), FragCount(x, ElementX), DeleteArray(0))
                       
                    End If
                    
                End If
            'Else
            '    Exit For
            'End If
        End If
        
Loop

'124
End Sub
Public Sub FastRecCheckGC(NextNo As Long, PCO As Double, DP() As Byte, SeqNum() As Integer, TestPairs() As Byte, Mask() As Byte)

'FindVarsites
Dim VarSites() As Long, VSPos As Long, x As Long, Y  As Long, Z  As Long
ReDim VarSites(Len(StrainSeq(0)))

SSS = Abs(GetTickCount)


If x = x Then
    Dummy = FastGC(Len(StrainSeq(0)), NextNo, PCO, UBound(SeqNum, 1), UBound(TestPairs, 1), UBound(DP, 1), SeqNum(0, 0), VarSites(0), Mask(0), TestPairs(0, 0), DP(0, 0))
    x = x
Else

    Dim VSBak() As Long
    ReDim VSBak(Len(StrainSeq(0)))
    VSPos = -1
    If x = 12345 Then
        'to exclude all columns with any gaps
        For Z = 1 To Len(StrainSeq(0))
            GoOn = 1
            
            For x = 0 To NextNo
                If SeqNum(Z, x) < 50 Then
                    GoOn = 0
                    Exit For
                End If
            Next x
            If GoOn = 1 Then
                For x = 0 To NextNo
                    'If SeqNum(Z, X) > 50 Then
                        For Y = x + 1 To NextNo
                        
                            'If SeqNum(Z, Y) > 50 Then
                                If SeqNum(Z, Y) <> SeqNum(Z, x) Then
                                    VSPos = VSPos + 1
                                    VarSites(VSPos) = Z
                                    x = NextNo
                                    Exit For
                                End If
                            'End If
                        Next Y
                    'End If
                Next x
            End If
        Next Z
    Else
        'to pairwise exclude gaps
        For Z = 1 To Len(StrainSeq(0))
            
            For x = 0 To NextNo
                If SeqNum(Z, x) > 50 Then
                    For Y = x + 1 To NextNo
                    
                        If SeqNum(Z, Y) > 50 Then
                            If SeqNum(Z, Y) <> SeqNum(Z, x) Then
                                VSPos = VSPos + 1
                                VarSites(VSPos) = Z
                                x = NextNo
                                Exit For
                            End If
                        End If
                    Next Y
                End If
            Next x
            
        Next Z
    End If
    Dim FC6 As Long, SS() As Byte, SP As Long, NDiff As Long, A As Long, b As Long
    Dim InSt() As Long, OutSt() As Long, InEn() As Long, OutEn() As Long, InC As Long, OutC As Long, InSc() As Single, OutSc() As Single
    Dim MergeSt() As Long, MergeEn() As Long, MergeSc() As Single, MergeC As Long
    ReDim SS(VSPos)
    FC6 = 0
    For x = 0 To NextNo
        If Mask(x) = 0 Then
            For Y = x + 1 To NextNo
                If Mask(Y) = 0 Then
                    If TestPairs(x, Y) = 1 Then
                        SP = -1
                        NDiff = 0
                        FC6 = 0
                        For Z = 0 To VSPos
                            
                            If SeqNum(VarSites(Z), x) > 50 Then
                                If SeqNum(VarSites(Z), Y) > 50 Then
                                    SP = SP + 1
                                    VSBak(SP) = VarSites(Z)
                                    If SeqNum(VarSites(Z), x) <> SeqNum(VarSites(Z), Y) Then
                                        SS(SP) = 1
                                        NDiff = NDiff + 1
                                    Else
                                        SS(SP) = 0
                                    End If
                                End If
                            End If
                        Next Z
                        If NDiff > 2 And SP > 1 Then
                            Dim NSame As Long, LTG As Single, MissPen As Single, MissPen2 As Single
                            NSame = SP - NDiff
                            LTG = SP * GCMissmatchPen
                            MissPen = Int(LTG / NDiff) + 1
                            MissPen2 = Int(LTG / NSame) + 1
                            ReDim InSt(VSPos), OutSt(VSPos), InEn(VSPos), OutEn(VSPos), InSc(VSPos), OutSc(VSPos), MergeSt(VSPos), MergeEn(VSPos), MergeSc(VSPos)
                            InC = -1
                            OutC = -1
                            MergeC = -1
                            
                            For Z = 0 To SP
                                If SS(Z) = 0 Then 'do innerfrag
                '                    If VSBak(Z) > 9600 Then
                '                        X = X '9649,9779
                '                    End If
                                    InC = InC + 1
                                    InSt(InC) = Z
                                    If InC = 1086 Then
                                        x = x
                                        XX = VSBak(Z)
                                    End If
                                    For A = Z + 1 To SP * 2
                                        If A > SP Then
                                            b = A - SP - 1
                                        Else
                                            b = A
                                        End If
                                        If SS(b) = 1 Then Exit For
                                    Next A
                                    Z = A - 1
                                    InEn(InC) = A - 1
                                    InSc(InC) = (InEn(InC) - InSt(InC) + 1)
                                    
                                    OutC = OutC + 1
                                    OutSt(OutC) = InSt(InC)
                                    OutEn(OutC) = InEn(InC)
                                    OutSc(OutC) = -InSc(InC)
                                    
                '                    If MergeC > -1 Then
                '                        If MergeSc(MergeC) > 0 Then
                '                            MergeSc(MergeC) = MergeSc(MergeC) + InSc(InC)
                '                        Else
                '                            MergeC = MergeC + 1
                '                            MergeSt(MergeC) = InSt(InC)
                '                            MergeEn(MergeC) = InEn(InC)
                '                            MergeSc(MergeC) = InSc(InC)
                '                        End If
                '                    Else
                '                        MergeC = MergeC + 1
                '                        MergeSt(MergeC) = InSt(InC)
                '                        MergeEn(MergeC) = InEn(InC)
                '                        MergeSc(MergeC) = InSc(InC)
                '                    End If
                                Else 'do outerfrag
                                    
                                    OutC = OutC + 1
                                    OutSt(OutC) = Z
                                    For A = Z + 1 To SP * 2
                                        If A > SP Then
                                            b = A - SP - 1
                                        Else
                                            b = A
                                        End If
                                        If SS(b) = 0 Then Exit For
                                    Next A
                                    Z = A - 1
                                    OutEn(OutC) = A - 1
                                    OutSc(OutC) = OutEn(OutC) - OutSt(OutC) + 1
                                    
                                    InC = InC + 1
                                    InSt(InC) = OutSt(OutC)
                                    InEn(InC) = OutEn(OutC)
                                    InSc(InC) = -OutSc(OutC)
                '                    MergeC = MergeC + 1
                '                    MergeSt(MergeC) = OutSt(OutC)
                '                    MergeEn(MergeC) = OutEn(OutC)
                '                    MergeSc(MergeC) = -OutSc(OutC)
                '
                '                    If MergeC > -1 Then
                '                        If MergeSc(MergeC) > 0 Then
                '                            MergeEn(MergeC) = OutEn(OutC)
                '                            MergeSc(MergeC) = MergeSc(MergeC) + OutSc(OutC)
                '                        Else
                '                            MergeC = MergeC + 1
                '                            MergeSt(MergeC) = OutSt(OutC)
                '                            MergeEn(MergeC) = OutEn(OutC)
                '                            MergeSc(MergeC) = OutSc(OutC)
                '                        End If
                '                    Else
                '                        MergeC = MergeC + 1
                '                        MergeSt(MergeC) = OutSt(OutC)
                '                        MergeEn(MergeC) = OutEn(OutC)
                '                        MergeSc(MergeC) = OutSc(OutC)
                '                    End If
                                    'OutC = OutC - 1
                                End If
                                FC6 = FC6 + 1
                                If OutC >= SP - 1 Then Exit For
                                If MergeC >= SP - 1 Then Exit For
                                If InC >= SP - 1 Then Exit For
                                
                                
                                
                            Next Z
                            'OutC = MergeC
                        
                            Dim InHS As Single, OutHS As Single, HSX As Single, FMS As Single, OutMSP() As Long, OutMS() As Single, InMSP() As Long, InMS() As Single, Polys As Single, Diffs As Single, MSP As Long, FS As Long
                            ReDim InMS(VSPos), InMSP(VSPos), OutMS(VSPos), OutMSP(VSPos)
                            HSX = 0
                            For Z = 0 To InC
                    '            If Z > InC - 50 Then
                    '                X = X
                    '            End If
                                
                                If InSc(Z) > 0 Then
                    '                If VSBak(InSt(Z)) = 9468 Then
                    '                    XX = VSBak(Z)
                    '                    X = X
                    '                End If
                                    Polys = InSc(Z)
                                    FMS = Polys
                                    Diffs = 0
                                    MSP = Z
                    '                If Z = 1068 Then
                    '                    X = X
                    '                End If
                                    For b = Z + 1 To InC * 2
                                        If b > InC Then
                                            A = b - InC - 1
                                        Else
                                            A = b
                                        End If
                    '                    If A = InC Then
                    '                        X = X
                    '                    End If
                                        FS = InSc(A)
                                        If FS <= 0 Then
                                            FS = -FS
                                            Diffs = Diffs + FS
                                        End If
                                        Polys = Polys + FS
                    '                    If Polys = 447 And Diffs = 67 Then
                    '                        X = X
                    '                    End If
                                        TS = CLng((Polys - Diffs) - (Diffs * MissPen))
                                        If TS < 0 Then
                                            Exit For
                                        ElseIf TS >= FMS Then
                                            FMS = TS
                                            MSP = A
                    '                        WPX = Polys
                    '                        wdx = Diffs
                                        End If
                                    Next b
                                    InMSP(Z) = MSP
                                    InMS(Z) = FMS
                                    
                                    If FMS > HSX Then
                                        HSX = FMS
                    '                    XX = Z
                    '                    winpoly = WPX 'Polys
                    '                    windiffs = wdx 'Diffs
                    '                    winst = VSBak(InSt(Z))
                    '                    winend = VSBak(InSt(MSP))
                                        'XX = InSt(A)
                                    End If
                                Else
                                    InMS(Z) = 0
                                End If
                            Next Z
                            InHS = HSX
                            
                            Dim OutKMax As Double, InKMax As Double, D1 As Double, D2 As Double, D3 As Double, ZM As Double, ZDel As Double, Yy As Double, LZ As Double, LL0 As Double, mP As Double, mX As Double, InLL As Double, OutLL As Double, P As Double, Q As Double
                            InLL = 0
                            
                            If InHS > 3 Then
                                P = NDiff / SP
                                Q = 1 - P
                                mP = MissPen * P
                                mX = MissPen
                                LL0 = Log(mP / Q)
                                LL0 = LL0 / (mX + 1)
                                LZ = Exp(2 * LL0)
                                ZDel = 1
                                Yy = 1
                                Do While Abs(ZDel) > 0.000001 Or Abs(Yy) > 0.000001
                                    ZM = LZ ^ -mX
                                    Yy = Q * LZ + P * ZM - 1
                                    ZDel = Yy / (Q - mP * ZM / Z)
                                    LZ = LZ - ZDel
                                    
                                
                                Loop
                                InLL = Log(LZ)
                                D1 = Exp(InLL)
                                D1 = D1 - 1
                                D2 = -(mX + 1) * InLL
                                D3 = Exp(D2)
                                InKMax = D1 * (Q - (mP * D3))
                                Dim KMTL As Double, Critval As Double, PVM1 As Double
                                If InKMax > 0 Then
                                    KMTL = InKMax * SP
                                    KMTL = Log(KMTL)
                                    PVM1 = (1 - PCO)
                                    If PVM1 > 0 Then
                                        PVM1 = -Log(PVM1)
                                        Critval = (KMTL + PVM1) / InLL
                                        If Critval < 4 Then Critval = 4
                                    Else
                                        Critval = 4
                                    End If
                                    
                                Else
                                    Critval = 4
                                End If
                                If InHS > Critval Then
                                    Dim Warn As Double, InKAScore As Double, tHLD As Double, InPV As Double
                                    InKAScore = InLL * InHS - KMTL
                                    If InKAScore >= 30 Then InKAScore = 30
                                    If InKAScore > 0 And InKAScore <= 30 Then
                                        tHLD = Exp(-InKAScore)
                                        InPV = 1 - Exp(-tHLD)
                                    
                                    End If
                                    If InPV <= PCO Then
                                        DP(x, Y) = 1 '1,6
                                        DP(Y, x) = 1
                                    End If
                                Else
                                    x = x
                                End If
                            End If
                            
                            If DP(x, Y) = 0 And x = 123456789 Then
                                OutLL = 0
                                HSX = 0
                                For Z = 0 To OutC
                                    If OutSc(Z) > 0 Then
                                        Polys = OutSc(Z)
                                        FMS = Polys
                                        Diffs = 0
                                        MSP = Z
                                        For b = Z + 1 To OutC * 2
                                            If b > OutC Then
                                                A = b - OutC - 1
                                            Else
                                                A = b
                                            End If
                                            FS = OutSc(A)
                                            If FS <= 0 Then
                                                FS = -FS
                                                Diffs = Diffs + FS
                                            End If
                                            Polys = Polys + FS
                                            TS = CLng((Polys - Diffs) - (Diffs * MissPen2))
                                            If TS < 0 Then
                                                Exit For
                                            ElseIf TS >= FMS Then
                                                FMS = TS
                                                MSP = A
                                            End If
                                        Next b
                                        OutMSP(Z) = MSP
                                        OutMS(Z) = FMS
                                        If FMS > HSX Then
                                            HSX = FMS
                                        End If
                                    Else
                                        OutMS(Z) = 0
                                    End If
                                Next Z
                                OutHS = HSX
                            
                                If OutHS > 3 Then
                                    P = NSame / SP
                                    Q = 1 - P
                                    mP = MissPen2 * P
                                    mX = MissPen2
                                    LL0 = Log(mP / Q)
                                    LL0 = LL0 / (mX + 1)
                                    LZ = Exp(2 * LL0)
                                    ZDel = 1
                                    Yy = 1
                                    Do While Abs(ZDel) > 0.000001 Or Abs(Yy) > 0.000001
                                        ZM = LZ ^ -mX
                                        Yy = Q * LZ + P * ZM - 1
                                        ZDel = Yy / (Q - mP * ZM / Z)
                                        LZ = LZ - ZDel
                                    Loop
                                    OutLL = Log(LZ)
                                    
                                    D1 = Exp(OutLL)
                                    D1 = D1 - 1
                                    D2 = -(mX + 1) * OutLL
                                    D3 = Exp(D2)
                                    OutKMax = D1 * (Q - (mP * D3))
                                    If OutKMax > 0 Then
                                        KMTL = OutKMax * SP
                                        KMTL = Log(KMTL)
                                        PVM1 = (1 - PCO)
                                        If PVM1 > 0 Then
                                            PVM1 = -Log(PVM1)
                                            Critval = (KMTL + PVM1) / OutLL
                                            If Critval < 4 Then Critval = 4
                                        Else
                                            Critval = 4
                                        End If
                                        
                                    Else
                                        Critval = 4
                                    End If
                                    If OutHS > Critval Then
                                        Dim OutKAScore As Double, OutPV As Double
                                        OutKAScore = OutLL * OutHS - KMTL
                                        If OutKAScore >= 30 Then OutKAScore = 30
                                        If OutKAScore > 0 And OutKAScore <= 30 Then
                                            tHLD = Exp(-OutKAScore)
                                            OutPV = 1 - Exp(-tHLD)
                                        
                                        End If
                                        If OutPV <= PCO Then
                                            DP(x, Y) = 1
                                            DP(Y, x) = 1
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Next Y
        End If
    Next x
End If
'EE = abs(gettickcount)
'TT = EE - SSS
'TotFGCT = TotFGCT + TT
'Form1.Caption = TotFGCT





End Sub
Public Sub FastRecCheckGC2(NextNo As Long, PCO As Double, DP() As Byte, SeqNum() As Integer, TestPairs() As Byte, Mask() As Byte)

'FindVarsites' This version used treedistance to make pair-specific variable site positions
Dim VarSites() As Long, VSPos() As Long, x As Long, Y  As Long, Z  As Long
ReDim VarSites(Len(StrainSeq(0)))

SSS = Abs(GetTickCount)


If x = 123455 Then
    Dummy = FastGC(Len(StrainSeq(0)), NextNo, PCO, UBound(SeqNum, 1), UBound(TestPairs, 1), UBound(DP, 1), SeqNum(0, 0), VarSites(0), Mask(0), TestPairs(0, 0), DP(0, 0))
    x = x
Else

    Dim VSBak() As Long
    ReDim VSBak(Len(StrainSeq(0)))
   
    
    Dim CurNode As Long, PairNode() As Integer, NodeDist() As Single, DoneNode() As Byte, ThisCount As Long, SDist As Single, RefS As Long, NumSeqsInNode() As Integer, NodeSeq() As Integer
    ReDim DoneNode(NextNo * 2, NextNo * 2), PairNode(NextNo * 2, NextNo * 2), NodeDist(NextNo * 2), VarSeqList(NextNo * 2), NumSeqsInNode(NextNo * 2), NodeSeq(NextNo * 2, NextNo * 2)
    CurNode = 0
    Dim XSide() As Long, YSide() As Long, XC As Long, YC As Long
    ReDim XSide(NextNo * 2), YSide(NextNo * 2)
    Dim A As Long, b As Long, C As Long, D As Long
    For x = 0 To NextNo
        DoEvents
        For Y = x + 1 To NextNo
            If DoneNode(x, Y) = 0 Then
'                If PairNode(x, Y) <> 0 Then
'                    x = x
'                End If
                DoneNode(x, Y) = 1
                DoneNode(Y, x) = 1
                CurNode = CurNode + 1
'                If CurNode = 2 Then
'                    x = x
'                End If
'Exit Sub
                NumSeqsInNode(CurNode) = 0
                
                NodeDist(CurNode) = TreeDistance(x, Y)
                ThisCount = 2
                SDist = -10
                'find the node immediately below the MRCA of this pair - all the sequences branching from this lower node are
                'used to make the varsite positions for all the sequences branching from the x,y MRCA node
                'they will be stored in nodeseq
                For Z = 0 To NextNo
                    If TreeDistance(x, Z) < TreeDistance(x, Y) Then
                        If TreeDistance(x, Z) > SDist Then
                            SDist = TreeDistance(x, Z)
                            RefS = Z
                        End If
                    End If
                Next Z
                YC = 0
                XC = 0
                If SDist = -10 Then
                    'do the root node
                    For Z = 0 To NextNo
                         If TreeDistance(x, Z) > TreeDistance(x, Y) Then
'                            If PairNode(Z, Y) <> CurNode And PairNode(Z, Y) <> 0 Then
'                                x = x
'                            End If
                            YC = YC + 1
                            YSide(YC) = Z
'                            PairNode(Z, Y) = CurNode
'                            PairNode(Y, Z) = CurNode
'                            DoneNode(Z, Y) = 1
'                            DoneNode(Y, Z) = 1
                         Else
                            XC = XC + 1
                            XSide(XC) = Z
'                            If PairNode(Z, x) <> CurNode And PairNode(Z, x) <> 0 Then
'                                x = x
'                            End If
'                            PairNode(Z, x) = CurNode
'                            PairNode(x, Z) = CurNode
'                            DoneNode(Z, x) = 1
'                            DoneNode(x, Z) = 1
                         End If
                         NumSeqsInNode(CurNode) = NextNo + 1
                         NodeSeq(CurNode, Z + 1) = Z
                    Next Z
                    
                Else
                    NumSeqsInNode(CurNode) = 0
                    For Z = 0 To NextNo
                        If TreeDistance(Z, RefS) = SDist Or TreeDistance(Z, Y) = SDist Then
                            NumSeqsInNode(CurNode) = NumSeqsInNode(CurNode) + 1
                            NodeSeq(CurNode, NumSeqsInNode(CurNode)) = Z
                        End If
                    Next Z
                    'now find all the sequences above the MRCA Node and point to pairnode
                    'PairNode(x, Y) = CurNode
                    'PairNode(Y, x) = CurNode
                    
                    For Z = 0 To NextNo
                        If TreeDistance(x, Z) = TreeDistance(x, Y) Then
                            YC = YC + 1
                            YSide(YC) = Z
'                            If PairNode(Z, x) <> 0 Then
'                                x = x
'                            End If
'                            PairNode(x, Z) = CurNode
'                            PairNode(Z, x) = CurNode
'                            DoneNode(Z, x) = 1
'                            DoneNode(x, Z) = 1
                        ElseIf TreeDistance(Y, Z) = TreeDistance(x, Y) Then
                            XC = XC + 1
                            XSide(XC) = Z
'                            If PairNode(Z, Y) <> 0 Then
'                                x = x
'                            End If
'                            PairNode(Y, Z) = CurNode
'                            PairNode(Z, Y) = CurNode
'                            DoneNode(Y, Z) = 1
'                            DoneNode(Z, Y) = 1
                        End If
                    Next Z
                End If
                For A = 1 To XC
                    C = XSide(A)
                    For b = 1 To YC
                        D = YSide(b)
                        PairNode(C, D) = CurNode '0,1:0,5:0,6:0,7:2,1:2,5:2,6:2,7:
                        PairNode(D, C) = CurNode
                        DoneNode(C, D) = 1
                        DoneNode(D, C) = 1
                    Next b
                Next A
                x = x
            End If
        Next Y
    Next x
    
    'to pairwise exclude gaps
    XX = NextNo
    ReDim VarSites(Len(StrainSeq(0)), CurNode)
    ReDim VSPos(CurNode)
    For A = 1 To CurNode
        DoEvents
        VSPos(A) = -1
        For Z = 1 To Len(StrainSeq(0))
            
            For b = 1 To NumSeqsInNode(A)
                x = NodeSeq(A, b)
                If SeqNum(Z, x) > 50 Then
                    For C = b + 1 To NumSeqsInNode(A)
                        Y = NodeSeq(A, C)
                        If SeqNum(Z, Y) > 50 Then
                            If SeqNum(Z, Y) <> SeqNum(Z, x) Then
                                VSPos(A) = VSPos(A) + 1
                                VarSites(VSPos(A), A) = Z
                                b = NumSeqsInNode(A)
                                Exit For
                            End If
                        End If
                    Next C
                End If
            Next b
            
        Next Z
        x = x
    Next A
    Dim FC6 As Long, SS() As Byte, SP As Long, NDiff As Long
    Dim InSt() As Long, OutSt() As Long, InEn() As Long, OutEn() As Long, InC As Long, OutC As Long, InSc() As Single, OutSc() As Single
    Dim MergeSt() As Long, MergeEn() As Long, MergeSc() As Single, MergeC As Long
    
    FC6 = 0
    Dim CN As Long
    For x = 0 To NextNo
        DoEvents
        If Mask(x) = 0 Then
            For Y = x + 1 To NextNo
                If Mask(Y) = 0 Then
                    If TestPairs(x, Y) = 1 Then
                        CN = PairNode(x, Y)
                        If VSPos(CN) > -1 Then
                        ReDim SS(VSPos(CN))
                        SP = -1
                        NDiff = 0
                        FC6 = 0
                        For Z = 0 To VSPos(CN)
                            
                            If SeqNum(VarSites(Z, CN), x) > 50 Then
                                If SeqNum(VarSites(Z, CN), Y) > 50 Then
                                    SP = SP + 1
                                    VSBak(SP) = VarSites(Z, CN)
                                    If SeqNum(VarSites(Z, CN), x) <> SeqNum(VarSites(Z, CN), Y) Then
                                        SS(SP) = 1
                                        NDiff = NDiff + 1
                                    Else
                                        SS(SP) = 0
                                    End If
                                End If
                            End If
                        Next Z
                        If NDiff > 2 And SP > 1 Then
                            Dim NSame As Long, LTG As Single, MissPen As Single, MissPen2 As Single
                            NSame = SP - NDiff
                            LTG = SP * GCMissmatchPen
                            MissPen = Int(LTG / NDiff) + 1
                            MissPen2 = Int(LTG / NSame) + 1
                            ReDim InSt(VSPos(CN)), OutSt(VSPos(CN)), InEn(VSPos(CN)), OutEn(VSPos(CN)), InSc(VSPos(CN)), OutSc(VSPos(CN)), MergeSt(VSPos(CN)), MergeEn(VSPos(CN)), MergeSc(VSPos(CN))
                            InC = -1
                            OutC = -1
                            MergeC = -1
                            
                            For Z = 0 To SP
                                If SS(Z) = 0 Then 'do innerfrag
                '                    If VSBak(Z) > 9600 Then
                '                        X = X '9649,9779
                '                    End If
                                    InC = InC + 1
                                    InSt(InC) = Z
                                    
                                    For A = Z + 1 To SP * 2
                                        If A > SP Then
                                            b = A - SP - 1
                                        Else
                                            b = A
                                        End If
                                        If SS(b) = 1 Then Exit For
                                    Next A
                                    Z = A - 1
                                    InEn(InC) = A - 1
                                    InSc(InC) = (InEn(InC) - InSt(InC) + 1)
                                    
                                    OutC = OutC + 1
                                    OutSt(OutC) = InSt(InC)
                                    OutEn(OutC) = InEn(InC)
                                    OutSc(OutC) = -InSc(InC)
                                    
                '                    If MergeC > -1 Then
                '                        If MergeSc(MergeC) > 0 Then
                '                            MergeSc(MergeC) = MergeSc(MergeC) + InSc(InC)
                '                        Else
                '                            MergeC = MergeC + 1
                '                            MergeSt(MergeC) = InSt(InC)
                '                            MergeEn(MergeC) = InEn(InC)
                '                            MergeSc(MergeC) = InSc(InC)
                '                        End If
                '                    Else
                '                        MergeC = MergeC + 1
                '                        MergeSt(MergeC) = InSt(InC)
                '                        MergeEn(MergeC) = InEn(InC)
                '                        MergeSc(MergeC) = InSc(InC)
                '                    End If
                                Else 'do outerfrag
                                    
                                    OutC = OutC + 1
                                    OutSt(OutC) = Z
                                    For A = Z + 1 To SP * 2
                                        If A > SP Then
                                            b = A - SP - 1
                                        Else
                                            b = A
                                        End If
                                        If SS(b) = 0 Then Exit For
                                    Next A
                                    Z = A - 1
                                    OutEn(OutC) = A - 1
                                    OutSc(OutC) = OutEn(OutC) - OutSt(OutC) + 1
                                    
                                    InC = InC + 1
                                    InSt(InC) = OutSt(OutC)
                                    InEn(InC) = OutEn(OutC)
                                    InSc(InC) = -OutSc(OutC)
                '                    MergeC = MergeC + 1
                '                    MergeSt(MergeC) = OutSt(OutC)
                '                    MergeEn(MergeC) = OutEn(OutC)
                '                    MergeSc(MergeC) = -OutSc(OutC)
                '
                '                    If MergeC > -1 Then
                '                        If MergeSc(MergeC) > 0 Then
                '                            MergeEn(MergeC) = OutEn(OutC)
                '                            MergeSc(MergeC) = MergeSc(MergeC) + OutSc(OutC)
                '                        Else
                '                            MergeC = MergeC + 1
                '                            MergeSt(MergeC) = OutSt(OutC)
                '                            MergeEn(MergeC) = OutEn(OutC)
                '                            MergeSc(MergeC) = OutSc(OutC)
                '                        End If
                '                    Else
                '                        MergeC = MergeC + 1
                '                        MergeSt(MergeC) = OutSt(OutC)
                '                        MergeEn(MergeC) = OutEn(OutC)
                '                        MergeSc(MergeC) = OutSc(OutC)
                '                    End If
                                    'OutC = OutC - 1
                                End If
                                FC6 = FC6 + 1
                                If OutC >= SP - 1 Then Exit For
                                If MergeC >= SP - 1 Then Exit For
                                If InC >= SP - 1 Then Exit For
                                
                                
                                
                            Next Z
                            'OutC = MergeC
                        
                            Dim InHS As Single, OutHS As Single, HSX As Single, FMS As Single, OutMSP() As Long, OutMS() As Single, InMSP() As Long, InMS() As Single, Polys As Single, Diffs As Single, MSP As Long, FS As Long
                            ReDim InMS(VSPos(CN)), InMSP(VSPos(CN)), OutMS(VSPos(CN)), OutMSP(VSPos(CN))
                            HSX = 0
                            For Z = 0 To InC
                    '            If Z > InC - 50 Then
                    '                X = X
                    '            End If
                                
                                If InSc(Z) > 0 Then
                    '                If VSBak(InSt(Z)) = 9468 Then
                    '                    XX = VSBak(Z)
                    '                    X = X
                    '                End If
                                    Polys = InSc(Z)
                                    FMS = Polys
                                    Diffs = 0
                                    MSP = Z
                    '                If Z = 1068 Then
                    '                    X = X
                    '                End If
                                    For b = Z + 1 To InC * 2
                                        If b > InC Then
                                            A = b - InC - 1
                                        Else
                                            A = b
                                        End If
                    '                    If A = InC Then
                    '                        X = X
                    '                    End If
                                        FS = InSc(A)
                                        If FS <= 0 Then
                                            FS = -FS
                                            Diffs = Diffs + FS
                                        End If
                                        Polys = Polys + FS
                    '                    If Polys = 447 And Diffs = 67 Then
                    '                        X = X
                    '                    End If
                                        TS = CLng((Polys - Diffs) - (Diffs * MissPen))
                                        If TS < 0 Then
                                            Exit For
                                        ElseIf TS >= FMS Then
                                            FMS = TS
                                            MSP = A
                    '                        WPX = Polys
                    '                        wdx = Diffs
                                        End If
                                    Next b
                                    InMSP(Z) = MSP
                                    InMS(Z) = FMS
                                    
                                    If FMS > HSX Then
                                        HSX = FMS
                    '                    XX = Z
                    '                    winpoly = WPX 'Polys
                    '                    windiffs = wdx 'Diffs
                    '                    winst = VSBak(InSt(Z))
                    '                    winend = VSBak(InSt(MSP))
                                        'XX = InSt(A)
                                    End If
                                Else
                                    InMS(Z) = 0
                                End If
                            Next Z
                            InHS = HSX
                            
                            Dim OutKMax As Double, InKMax As Double, D1 As Double, D2 As Double, D3 As Double, ZM As Double, ZDel As Double, Yy As Double, LZ As Double, LL0 As Double, mP As Double, mX As Double, InLL As Double, OutLL As Double, P As Double, Q As Double
                            InLL = 0
                            
                            If InHS > 3 Then
                                P = NDiff / SP
                                Q = 1 - P
                                mP = MissPen * P
                                mX = MissPen
                                LL0 = Log(mP / Q)
                                LL0 = LL0 / (mX + 1)
                                LZ = Exp(2 * LL0)
                                ZDel = 1
                                Yy = 1
                                Do While Abs(ZDel) > 0.000001 Or Abs(Yy) > 0.000001
                                    ZM = LZ ^ -mX
                                    Yy = Q * LZ + P * ZM - 1
                                    ZDel = Yy / (Q - mP * ZM / Z)
                                    LZ = LZ - ZDel
                                    
                                
                                Loop
                                InLL = Log(LZ)
                                D1 = Exp(InLL)
                                D1 = D1 - 1
                                D2 = -(mX + 1) * InLL
                                D3 = Exp(D2)
                                InKMax = D1 * (Q - (mP * D3))
                                Dim KMTL As Double, Critval As Double, PVM1 As Double
                                If InKMax > 0 Then
                                    KMTL = InKMax * SP
                                    KMTL = Log(KMTL)
                                    PVM1 = (1 - PCO)
                                    If PVM1 > 0 Then
                                        PVM1 = -Log(PVM1)
                                        Critval = (KMTL + PVM1) / InLL
                                        If Critval < 4 Then Critval = 4
                                    Else
                                        Critval = 4
                                    End If
                                    
                                Else
                                    Critval = 4
                                End If
                                If InHS > Critval Then
                                    Dim Warn As Double, InKAScore As Double, tHLD As Double, InPV As Double
                                    InKAScore = InLL * InHS - KMTL
                                    If InKAScore >= 30 Then InKAScore = 30
                                    If InKAScore > 0 And InKAScore <= 30 Then
                                        tHLD = Exp(-InKAScore)
                                        InPV = 1 - Exp(-tHLD)
                                    
                                    End If
                                    If InPV <= PCO Then
                                        DP(x, Y) = 1 '0,3:0,5:5,3
                                        DP(Y, x) = 1
                                    End If
                                Else
                                    x = x
                                End If
                            End If
                            
                            If DP(x, Y) = 0 And x = 123456789 Then
                                OutLL = 0
                                HSX = 0
                                For Z = 0 To OutC
                                    If OutSc(Z) > 0 Then
                                        Polys = OutSc(Z)
                                        FMS = Polys
                                        Diffs = 0
                                        MSP = Z
                                        For b = Z + 1 To OutC * 2
                                            If b > OutC Then
                                                A = b - OutC - 1
                                            Else
                                                A = b
                                            End If
                                            FS = OutSc(A)
                                            If FS <= 0 Then
                                                FS = -FS
                                                Diffs = Diffs + FS
                                            End If
                                            Polys = Polys + FS
                                            TS = CLng((Polys - Diffs) - (Diffs * MissPen2))
                                            If TS < 0 Then
                                                Exit For
                                            ElseIf TS >= FMS Then
                                                FMS = TS
                                                MSP = A
                                            End If
                                        Next b
                                        OutMSP(Z) = MSP
                                        OutMS(Z) = FMS
                                        If FMS > HSX Then
                                            HSX = FMS
                                        End If
                                    Else
                                        OutMS(Z) = 0
                                    End If
                                Next Z
                                OutHS = HSX
                            
                                If OutHS > 3 Then
                                    P = NSame / SP
                                    Q = 1 - P
                                    mP = MissPen2 * P
                                    mX = MissPen2
                                    LL0 = Log(mP / Q)
                                    LL0 = LL0 / (mX + 1)
                                    LZ = Exp(2 * LL0)
                                    ZDel = 1
                                    Yy = 1
                                    Do While Abs(ZDel) > 0.000001 Or Abs(Yy) > 0.000001
                                        ZM = LZ ^ -mX
                                        Yy = Q * LZ + P * ZM - 1
                                        ZDel = Yy / (Q - mP * ZM / Z)
                                        LZ = LZ - ZDel
                                    Loop
                                    OutLL = Log(LZ)
                                    
                                    D1 = Exp(OutLL)
                                    D1 = D1 - 1
                                    D2 = -(mX + 1) * OutLL
                                    D3 = Exp(D2)
                                    OutKMax = D1 * (Q - (mP * D3))
                                    If OutKMax > 0 Then
                                        KMTL = OutKMax * SP
                                        KMTL = Log(KMTL)
                                        PVM1 = (1 - PCO)
                                        If PVM1 > 0 Then
                                            PVM1 = -Log(PVM1)
                                            Critval = (KMTL + PVM1) / OutLL
                                            If Critval < 4 Then Critval = 4
                                        Else
                                            Critval = 4
                                        End If
                                        
                                    Else
                                        Critval = 4
                                    End If
                                    If OutHS > Critval Then
                                        Dim OutKAScore As Double, OutPV As Double
                                        OutKAScore = OutLL * OutHS - KMTL
                                        If OutKAScore >= 30 Then OutKAScore = 30
                                        If OutKAScore > 0 And OutKAScore <= 30 Then
                                            tHLD = Exp(-OutKAScore)
                                            OutPV = 1 - Exp(-tHLD)
                                        
                                        End If
                                        If OutPV <= PCO Then
                                            DP(x, Y) = 1
                                            DP(Y, x) = 1
                                        End If
                                    End If
                                End If
                            End If
                        End If
                        End If
                    End If
                End If
            Next Y
        End If
    Next x
End If
'EE = abs(gettickcount)
'TT = EE - SSS
'TotFGCT = TotFGCT + TT
'Form1.Caption = TotFGCT





End Sub
Public Sub GCXoverDVI(HiFragScore() As Long, FragMaxScore() As Long, MaxScorePos() As Long, MissPen() As Double, ElementX As Long, FragSt() As Long, FragEn() As Long, FragCount() As Long, LenXoverSeq As Long, NDiff() As Long, XPosDiff() As Long, XDiffPos() As Long, SubSeq() As Byte, FindallFlag)

Dim NumInList As Long, GoOn As Long, lP As Single, Dummy As Variant, Y1 As Long, Y2 As Long, X1 As Long, X2 As Long, Prob As Variant, COff As Variant, Ac As Long, tMi As Long, tMa As Long
Dim SIP As Long, GG As Long, b As Long, ETarget As Long, BTarget As Long, A As Long, Z As Long, BEE As Long, ENN As Long, EWarn As Byte, BWarn As Byte, LastMPV As Double, ZZZXZ As Long, SplitX As Long
Dim PBinFlag As Long

PBinFlag = -1

'this is the auto triplet scanning version of geneconv
Dim Beginning As Long, Ending As Long, DoneRedo As Byte, LTG As Single, Critval(5) As Double, PVM1 As Double, KMTL As Double
Dim LSeq As Long, Y As Long, x As Long, SX As Long, MissPenB() As Single
Dim MaxX As Long, MaxY As Long, MPV As Double
Dim TempScore As Long
Dim ProbabilityXOver As Double
Dim KAScore As Variant, PVal As Double, MaxScore As Double, LKLen As Double
Dim Polys As Long, Diffs As Long
Dim FragSep() As Long ' FragCount(6) As Long
Dim MaxDiff As Long
Dim MinDiff As Long
Dim FragMinScore As Long, tPX As Double
Dim LL(5) As Double, KMax(5) As Double, Q As Double, P As Double, mX As Long
Dim DoneThis As Byte, b1 As Long, E1 As Long
Dim PCO As Double
'
LSeq = Len(StrainSeq(0))




'1.266
'GoOn = GetFragsP(CircularFlag, LenXoverSeq, LSeq, GCDimSize, SubSeq(0, 0, ElementX), FragSt(0, 0), FragEn(0, 0), FragScore(0, 0), FragCount(0))



'For X = 0 To 6
'    FragSt(FragCount(X), X) = LenXOverSeq
'    FragEn(FragCount(X), X) = LenXOverSeq
'Next X




'5.281

'Exit Sub


''Exit Sub

'11.877,11.827
'11.1126 - using offsets
'11.026,11.036 - using offsets in maxfragscore rather than a holder.

'5.671, 5.656 -desktop

'This could be encorporated into getmaxfragscore - highfragscore could be set to zero if below the cutoff an passed to calkmax - there is also another higenough test later in the code that could be avoided
'highenough used in gccalpval and gcgethipval
For x = 0 To 5
    If HiFragScore(x, ElementX) > 3 Then
        HighEnough(x) = 1
    Else
        HighEnough(x) = 0
    End If
Next x


'Calc LL and KMax

'GoOn = CalcKMaxP(GCMissmatchPen, LenXOverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0), CritVal(0), MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))

'5.688,5.687


'//(log(kmax*lenxoverseq)-log(-log(1-pval)))/ll(x) = score
'calculate critical fragment length



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Maybe port this bit to c++

'Exit Sub
'
'If X = 12345 Then ' this bit has to be uncommented if i need to go back to using calkkmax
    GoOn = CalcKMaxP(GCMissmatchPen, LenXoverSeq, MCFlag, MCCorrection, LowestProb, PCO, HiFragScore(0, ElementX), Critval(0), MissPen(0, ElementX), LL(0), KMax(0), NDiff(0, ElementX), HighEnough(0))
    
    
    
    
'    If Seq1 = 1 And Seq2 = 23 And Seq3 = 85 And SEventNumber = 18 Then
'                                            X = X
'                                        End If
    
    
'Else
'    GoOn = CalcKMax(GCMissmatchPen, LenXOverSeq, MissPen(0), LL(0), KMax(0), NDiff(0), HighEnough(0))
'    If MCFlag = 0 Then
'        PCO = LowestProb / MCCorrection
'    Else
'        PCO = LowestProb
'    End If
'
'    If PCO > 1 Then
'        Exit Sub
'    End If
'
'
'
'    For X = 0 To 5
'        If KMax(X) > 0 Then
'            KMTL = KMax(X) * LenXOverSeq
'
'            KMTL = Log(KMTL)
'
'            PVM1 = (1 - PCO)
'
'            If PVM1 > 0 Then
'                PVM1 = -Log(PVM1)
'
'                If PVM1 > 0 Then
'                    PVM1 = -Log(PVM1)
'                    CritVal(X) = (KMTL + PVM1) / LL(X)
'                    If CritVal(X) < 4 Then CritVal(X) = 4
'                Else
'                    CritVal(X) = 4
'                End If
'            Else
'                CritVal(X) = 4
'            End If
'        End If
'    Next X
'
'    GoOn = 0
'    For X = 0 To 5
'        HighEnough(X) = 0
'        If HiFragScore(X) > 3 And HiFragScore(X) > CritVal(X) Then
'            HighEnough(X) = 1
'            GoOn = 1
'        End If
'    Next X
'End If
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'XX = UBound(FragCount, 2)
'XX = FragCount(5, 4)
If GoOn = 0 Then Exit Sub



'5.813,5.828

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''GCCalcPValP gives a different result to this version - it may be correct but I've gone with the older one
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

MaxScore = GCCalcPVal(GCDimSize, LenXoverSeq, FragMaxScore(0, 0, ElementX), PVals(0, 0), FragCount(0, ElementX), KMax(0), LL(0), HighEnough(0), Critval(0))

'5.906,5.844

If ShortOutFlag = 3 Then
    If MaxScore * MCCorrection <= mtP(1) Then
        mtP(1) = MaxScore * MCCorrection
    End If
End If


If MaxScore > PCO Then Exit Sub

Dummy = ClearDeleteArray(LenXoverSeq + 1, DeleteArray(0))

DoneThis = 0
ZZZXZ = 0
'Exit Sub


Do
    
    LastMPV = MPV
    'XX = CSng(MPV)
    'MPV = 0
'    If UBound(PVals, 1) <> GCDimSize Then
'    X = X
'    End If
'    For X = 0 To 6
'        If FragCount(X, ElementX) > GCDimSize Then
'            X = X
'        End If
'    Next X

'If LenXoverSeq = 1683 Then
'    X = X
'    XX = Seq1
'    XX = Seq2
'    XX = Seq3
'
'End If

    MPV = GCGetHiPValP(GCDimSize, LenXoverSeq, FragCount(0, ElementX), PVals(0, 0), MaxY, MaxX, HighEnough(0))
    
    
    
    ZZZXZ = ZZZXZ + 1
    
    'The limit was 100 and not 10 - 100 would possibly be better in some cases'but 10 will always be ~30% faster
    If MPV = LastMPV And ZZZXZ > 10 Then
        Exit Sub
    End If
    
    '10.425,10.735
    '9.974
'    If Seq1 = 36 And Seq2 = 52 And Seq3 = 85 And SEventNumber = 17 Then
'        x = x
'    End If
    
    If MPV > PCO Or MPV = 1 Then Exit Sub
    x = MaxX
    Y = MaxY
    
    
    GoOn = DelPValsP(GCMaxOverlapFrags, Y, x, GCDimSize, PVals(0, 0), FragCount(0, ElementX), FragSt(0, 0, ElementX), FragEn(0, 0, ElementX), MaxScorePos(0, 0, ElementX), DeleteArray(0))
    
    If GoOn = 1 Then
        
        
        
        'For Y = 0 To FragCount(X)
            'If FragSt(Y, X) > 0 Then
                
                
                'GCMinFragLen As Integer, GCMinPolyInFrag As Integer, GCMinPairScore As Integer,
                If PVals(Y, x) < PCO Then 'And FragEn(Y, X) - FragSt(Y, X) + 1 >= GCMinFragLen And MaxScorePos(Y, X) >= GCMinPairScore Then
                    
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If ProgBinRead(1, Worthwhilescan(NumInList)) = 0 Then
                                
                                    Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 2
                                
                                End If
                                
                            End If
                        End If
                    End If
                    
                    If FragSt(Y, x, ElementX) > 0 Then
                        If LongWindedFlag = 0 Then
                            Beginning = XDiffPos(FragSt(Y, x, ElementX) - 1, ElementX) + 1
                        Else
                             
                            Beginning = XDiffPos(FragSt(Y, x, ElementX), ElementX)
                        End If
                    Else
                        Beginning = 1
                    End If
                    If LongWindedFlag = 0 Then
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x, ElementX), x, ElementX) + 1, ElementX) - 1
                    Else
                        Ending = XDiffPos(FragEn(MaxScorePos(Y, x, ElementX), x, ElementX), ElementX)
                    End If
                    
                    
                    If LongWindedFlag = 1 Then
                        If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                           
                        ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                            
                        ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                           
                            
                        ElseIf StoreLPV(1, Seq1) >= StoreLPV(1, Seq2) And StoreLPV(1, Seq1) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq2) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq2) >= StoreLPV(1, Seq3) Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf StoreLPV(1, Seq3) >= StoreLPV(1, Seq1) And StoreLPV(1, Seq3) >= StoreLPV(1, Seq2) Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq2
                        End If
                        'check to see if an event has been extended accross a tract of
                        'missing data
                         SplitX = 0
                         EWarn = 0
                         BWarn = 0
                        If XPosDiff(Beginning, ElementX) > 0 Then
                            BEE = XDiffPos(XPosDiff(Beginning, ElementX) - 1, ElementX)
                        Else
                            BEE = Beginning
                        End If
                        If XDiffPos(Ending, ElementX) < LSeq Then
                            ENN = XDiffPos(XPosDiff(Ending, ElementX) + 1, ElementX)
                        Else
                            ENN = Ending
                        End If
                        If BEE < 1 Then BEE = LSeq
                        If ENN > LSeq Then ENN = 1
                        
'                        If Seq1 = 31 And Seq2 = 37 And Seq3 = 96 And SEventNumber = 20 Then
'                            X = X
'                        End If
                        
                        If DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                            Z = CheckSplitP(10, LSeq, BEE, ENN, Seq1, Seq2, Seq3, SplitX, MissingData(0, 0))
                        Else
                            Z = Len(StrainSeq(0))
                        End If
                    Else
                        SplitX = 0
                        If x = 0 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 1 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq2
                        ElseIf x = 2 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq3
                            ActiveMajorP = Seq1
                        ElseIf x = 3 Then
                            ActiveSeq = Seq1
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq3
                        ElseIf x = 4 Then
                            ActiveSeq = Seq2
                            ActiveMinorP = Seq1
                            ActiveMajorP = Seq3
                        ElseIf x = 5 Then
                            ActiveSeq = Seq3
                            ActiveMinorP = Seq2
                            ActiveMajorP = Seq1
                        End If
                    End If
                    'SplitX = 0
                    'If X >= 3 Then SplitX = 0
                    
                    If SplitX = 1 And x < 3 Then
                        For A = 0 To 1
                            If A = 0 Then
                                BTarget = XPosDiff(Beginning, ElementX)
                                
                                ETarget = XPosDiff(Z, ElementX) - 1
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                                'If ETarget <= 0 Then ETarget = 1
                            Else
                                b = FindMissingP(LSeq, Seq1, Seq2, Seq3, Z, Ending, MissingData(0, 0))
                                If XPosDiff(b, ElementX) <> 0 Then
                                    BTarget = XPosDiff(b, ElementX) + 1
                                Else
                                    GG = b
                                    
                                    Do While XPosDiff(GG, ElementX) = 0
                                        GG = GG + 1
                                        
                                        If GG > LSeq Then
                                            GG = 0
                                            
                                        End If
                                    Loop
                                    BTarget = XPosDiff(GG, ElementX)
                                End If
                                ETarget = XPosDiff(Ending, ElementX)
                                
                                If ETarget = BTarget - 1 Then BTarget = ETarget
                                'If ETarget <= 0 Then ETarget = 1
                            End If
                            
                            ProbabilityXOver = MakeSubProbP(x, LSeq, LenXoverSeq, BTarget, ETarget, SubSeq(0, 0, ElementX), LL(0), KMax(0), MissPen(0, ElementX), Critval(0))
                            If ProbabilityXOver < PCO Then
                            '3.8621
                                If MCFlag = 0 Then
                                    ProbabilityXOver = ProbabilityXOver * MCCorrection
                                End If
                                If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                
                                
                                    
                                
                                    'Keep track of signal numbers
                                    oRecombNo(100) = oRecombNo(100) + 1
                                    oRecombNo(1) = oRecombNo(1) + 1
                                    If APermFlag = 0 Then
                                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                                    Else
                                        SIP = 1
                                    End If
                                        
                                    If MCFlag = 2 Then
                                        lP = -Log10(ProbabilityXOver) * 2
                                        If lP > 0 And lP < 100 Then
                                            PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                        ElseIf CInt(lP) >= 100 Then
                                            PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                        End If
                                    End If
                                    'if p high eough then add it to list, if not discard then repeat from Z to en.
                                    ActualFound = 1
                                    NewOneFound = 1
                                    If SIP > 0 Then
                                      
                                        Beginning = XDiffPos(BTarget, ElementX)
                                        Ending = XDiffPos(ETarget, ElementX)
                                        If ActiveSeq > UBound(XoverList, 1) Then Exit Sub
                                        XoverList(ActiveSeq, SIP).Beginning = Beginning
                                        XoverList(ActiveSeq, SIP).Ending = Ending
                                        XoverList(ActiveSeq, SIP).DHolder = 0
                                        
                                        
                                        'Make a reminder that one of the berakpoints went undetected
                                        If A = 0 Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                            EWarn = 1
                                        Else
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                            BWarn = 1
                                        End If
                                        
                                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                                        XoverList(ActiveSeq, SIP).ProgramFlag = 1
                                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 1 Then BWarn = 1
                                        If XoverList(ActiveSeq, SIP).SBPFlag = 2 Then EWarn = 1
                                        'If SEventNumber > 0 Or X = X Then
                                            If EWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                        'End If
                                        Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                                        Call CentreBP2(ElementX, 0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                                        If FindallFlag = 1 And X = 12345 Then
'                                            If APermFlag = 0 Then
'                                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                            Else
'                                                SIP = 1
'                                            End If
'                                            If SIP > 0 Then
'                                                XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                                XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                                XOverlist(ActiveSeq, SIP).Beginning = Ending
'
'                                            End If
'                                        End If
'                                        If X = 12345 Then
'                                            If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            Else
'                                                For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                                For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                        X = X
'                                                    End If
'                                                Next Z
'                                            End If
'                                            'XX = ZZZXZ
'                                        End If
                                        If ShortOutFlag = 1 Then
                                            ShortOutput(1) = 1
                                            AbortFlag = 1
                                            Exit Sub
                                        End If
                                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                            StartPlt(1) = 1
                                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                                        End If
                                    ElseIf DoneRedo = 0 Then
                                        DoneRedo = 1
                                        Call AddToRedoList(1, Seq1, Seq2, Seq3)
                                    End If
                                        
                                End If
                                
                            End If
                            
                        Next A
                    ElseIf SplitX = 0 Then
                        If MCFlag = 0 Then
                            ProbabilityXOver = PVals(Y, x) * MCCorrection
                        Else
                            ProbabilityXOver = PVals(Y, x)
                        End If
                        
                        If MCFlag = 2 Then
                            lP = -Log10(ProbabilityXOver) * 2
                            If lP > 0 And lP < 100 Then
                                PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                            ElseIf CInt(lP) >= 100 Then
                                PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                            End If
                        End If
                        
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(1) = oRecombNo(1) + 1
                        
                        If APermFlag = 0 Then
                            Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 1, ProbabilityXOver, SIP)
                        Else
                            SIP = 1
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(1) = 1
                            AbortFlag = 1
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(1) = 1
                        ActualFound = 1
                        NewOneFound = 1
                        If SIP > 0 Then
                            
                            XoverList(ActiveSeq, SIP).Daughter = ActiveSeq '30
                            XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP '6
                            XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP '0
                            XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver '1.3 10-3
                            XoverList(ActiveSeq, SIP).Beginning = Beginning '5403
                            XoverList(ActiveSeq, SIP).Ending = Ending '5657
                            XoverList(ActiveSeq, SIP).ProgramFlag = 1
                            XoverList(ActiveSeq, SIP).DHolder = 0
                            
                            ''If SEventNumber > 0 Or X = X Then
                                If EWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, Beginning, Ending, SeqNum(), XPosDiff(), XDiffPos())
                            
                           '' End If
                            Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                            Call CentreBP2(ElementX, 0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
'                            If FindallFlag = 1 And X = 12345 Then
'                                If APermFlag = 0 Then
'                                    Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverlist(), 1, ProbabilityXOver, SIP)
'                                Else
'                                    SIP = 1
'                                End If
'                                If SIP > 0 Then
'                                    XOverlist(ActiveSeq, SIP) = XOverlist(ActiveSeq, SIP - 1)
'                                    XOverlist(ActiveSeq, SIP).Ending = Beginning
'                                    XOverlist(ActiveSeq, SIP).Beginning = Ending
'                                End If
'                            End If
                            
                            'If Seq1 = 57 Or Seq2 = 57 Or Seq3 = 57 And XOverList(ActiveSeq, SIP).Beginning = 2301 And XOverList(ActiveSeq, SIP).Ending = 53 Then
                            '                XxX = SEventNumber
                            '            End If
                                        
'                                    If X = 12345 Then
'                                        If XOverlist(ActiveSeq, SIP).Beginning < XOverlist(ActiveSeq, SIP).Ending Then
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        Else
'                                            For Z = 1 To XOverlist(ActiveSeq, SIP).Ending
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                            For Z = XOverlist(ActiveSeq, SIP).Beginning To Len(StrainSeq(0))
'                                                If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
'                                                    X = X
'                                                End If
'                                            Next Z
'                                        End If
'                                       'XX = ZZZXZ
'                                    End If
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                
                                StartPlt(1) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                            
                            End If
                            
                        ElseIf DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(1, Seq1, Seq2, Seq3)
                        End If
                   Else
                        FragMaxScore(MaxY, MaxX, ElementX) = 0
                   End If
                   tMa = ActiveMajorP
                   tMi = ActiveMinorP
                   Ac = ActiveSeq
                        
                                      
                    ActiveMajorP = tMa
                    ActiveMinorP = tMi
                    ActiveSeq = Ac
                    
                    If ShowPlotFlag = 1 And DoneThis = 0 Then
                        If DontRedrawPlotsFlag = 0 Then
                            Call DoAxes(0, 0, Decompress(LSeq), -1, CSng(-Log10(MaxScore)), 0, 1, "-Log(KA P-Val)")
                            
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
                            Call WriteNames(WN1, WN2, WN3, Yellow, Green, Purple)
                        End If
                        'Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                        If MaxScore > LowestProb / MCCorrection Then MaxScore = LowestProb / MCCorrection
                        Form1.Picture2.ForeColor = QBColor(0)
                        COff = -Log10((LowestProb / (MCCorrection)))
                        Y1 = PicHeight - (15 + (COff / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 2
                        Y1 = PicHeight - (15 + (-Log10(LowestProb) / -Log10(MaxScore)) * (PicHeight - 35))
                        Form1.Picture7.DrawStyle = 0
                        'Form1.Picture7.AutoRedraw = True
                        DoneThis = 1
                        
                        For A = 5 To 0 Step -1
                            
    
                            If A = 0 Then
                                Form1.Picture7.ForeColor = Yellow
                            ElseIf A = 1 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 2 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 3 Then
                                Form1.Picture7.ForeColor = Purple
                            ElseIf A = 4 Then
                                Form1.Picture7.ForeColor = Green
                            ElseIf A = 5 Then
                                Form1.Picture7.ForeColor = Yellow
                            End If
                            
                            
                                For b = 0 To FragCount(A, ElementX)
                                    If PVals(b, A) < 0.9999 And PVals(b, A) > 0 Then
                                    
                                        Prob = -Log10(PVals(b, A))
                                        
                                        If FragSt(b, A, ElementX) > 0 Then
                                            b1 = XDiffPos(FragSt(b, A, ElementX) - 1, ElementX) + 1
                                        Else
                                            b1 = 1
                                        End If
                                        E1 = XDiffPos(FragEn(MaxScorePos(b, A, ElementX), A, ElementX) + 1, ElementX) - 1
                                        X1 = 30 + Decompress(b1) * XFactor + XFactor
                                        X2 = 30 + Decompress(E1) * XFactor + XFactor
                                        
                                        
                                        Y1 = PicHeight - (15 + (Prob / -Log10(MaxScore)) * (PicHeight - 35))
                                        Y2 = PicHeight - 15
                                        Form1.Picture7.AutoRedraw = True
                                        'Form1.Picture7.Line (X1, Y1)-(X2, Y2), , B
                                    End If
                                Next b
                           
                        Next A
                        Form1.Picture7.Refresh
                        Form1.Frame17.Visible = False
                        'X = X
                        'XX = FragMaxScore(MaxY, MaxX)
                        'XX = FragSt(MaxY, MaxX)
                        'XX = FragEn(MaxY, MaxX)
                        'XX = FragCount(MaxX)
                        'XX = LenXOverSeq
                        'XX = KMax(MaxX)
                        'XX = LL(MaxX)
                        'XX = Log(KMax(MaxX) * LenXOverSeq)
                        'XX = (LL(MaxX) * FragMaxScore(MaxY, MaxX))
                    End If
                    
                    If SplitX = 1 And MaxX > 3 Then
                        PVals(MaxY, MaxX) = 100
                    Else
                        
                       
                            Dummy = MakeDeleteArrayP(FragSt(Y, x, ElementX), FragEn(MaxScorePos(Y, x, ElementX), x, ElementX), FragCount(x, ElementX), DeleteArray(0))
                       
                    End If
                    
                End If
            'Else
            '    Exit For
            'End If
        End If
        
Loop

'124
End Sub
Public Sub TestArrays(ISeqs() As Long)

    For x = 0 To 2
        For Y = 0 To NextNo
            If PermValidSmall(0, Y) <> PermValid(ISeqs(0), Y) Or PermValidSmall(0, Y) <> PermValid(Y, ISeqs(0)) Then
                x = x
            End If
            If PermDiffsSmall(0, Y) <> PermDIffs(ISeqs(0), Y) Or PermDiffsSmall(0, Y) <> PermDIffs(Y, ISeqs(0)) Then
                x = x
            End If
            If SMatSmall(0, Y) <> SMat(ISeqs(0), Y) Or SMatSmall(0, Y) <> SMat(Y, ISeqs(0)) Then
                x = x
            End If
            If FMatSmall(0, Y) <> FMat(ISeqs(0), Y) Or FMatSmall(0, Y) <> FMat(Y, ISeqs(0)) Then
                x = x
            End If
            If FAMatSmall(0, Y) <> FAMat(ISeqs(0), Y) Or FAMatSmall(0, Y) <> FAMat(Y, ISeqs(0)) Then
                x = x
            End If
            If SAMatSmall(0, Y) <> SAMat(ISeqs(0), Y) Or SAMatSmall(0, Y) <> SAMat(Y, ISeqs(0)) Then
                x = x
            End If
            If SCMatSmall(0, Y) <> SCMat(ISeqs(0), Y) Or SCMatSmall(0, Y) <> SCMat(Y, ISeqs(0)) Then
                x = x
            End If
            If FCMatSmall(0, Y) <> FCMat(ISeqs(0), Y) Or FCMatSmall(0, Y) <> FCMat(Y, ISeqs(0)) Then
                x = x
            End If


        Next Y
    Next x



End Sub
Public Sub NewScanGC2()
Dim ZZZ As Long, b As Long, Y As Long, GrpTest As Long, GoOn As Long, GroupSize As Long, x As Long, ElementNum As Long, ElementSeq() As Long, XDiffPosG() As Long, XPosDiffG() As Long, NDiffG() As Long, SubSeqG() As Byte, LenXOverSeqG() As Long
Dim FragStG() As Long, FragEnG() As Long, FragScoreG() As Long, FragCountG() As Long, GoOnG() As Byte
Dim oRec As Long, LT As Long, ExitDoFlag As Long, HiFragScoreG() As Long, FragMaxScoreG() As Long, MaxScorePosG() As Long, MissPenG() As Double, LTGG() As Single, Dummy As Long

ReDim BinArray(Len(StrainSeq(0)), NextNo)

GroupSize = 31
If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
    GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
End If
ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize), LenXOverSeqG(GroupSize), ElementSeq(GroupSize)
ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize)
ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize)
ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize), GoOnG(GroupSize)
ReDim HiFragScoreG(5, GroupSize), FragMaxScoreG(GCDimSize, 5, GroupSize), MaxScorePosG(GCDimSize, 5, GroupSize), MissPenG(5, GroupSize), LTGG(GroupSize)
'ReDim FragMaxScore(GCDimSize, 5)
'ReDim MaxScorePos(GCDimSize, 5)
'ReDim PVals(GCDimSize, 5)
'ReDim FragSt(GCDimSize, 6)
'ReDim FragEn(GCDimSize, 6)
'ReDim FragScore(GCDimSize, 6)
'ReDim DeleteArray(Len(StrainSeq(0)) + 1)


For Seq1 = 0 To NextNo
            
    If MaskSeq(Seq1) = 0 Then
        Dummy = MakeBinArrayP(Seq1, Len(StrainSeq(0)), NextNo, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0))
        For Seq2 = Seq1 + 1 To NextNo
            If x = x Then
                If MaskSeq(Seq2) = 0 Then
                    Seq3 = Seq2
                    'Need to refill xdiffposG, xposdiffG, ahG, xoverseqnumwG
                    ExitDoFlag = 0
                    Do
                        ElementNum = -1
                        
                        Do
                            
                            Seq3 = Seq3 + 1
                            If Seq3 > NextNo Then
                                ExitDoFlag = 1
                                Exit Do
                            End If
                            'If ExitDoFLag = 0 Then
                            If MaskSeq(Seq3) = 0 Then
                            
                                GoOn = 1
                                If SelGrpFlag > 0 Then
                                    GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                    If GrpTest > 2 Then
                                        GoOn = 0
                                    End If
                                End If
                                If GoOn = 1 Then
                                    ElementNum = ElementNum + 1
                                    ElementSeq(ElementNum) = Seq3
                                End If
                            End If
                        'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                            'For Seq3 = Seq2 + 1 To Nextno
                            If ElementNum = GroupSize Then Exit Do
                        Loop
                        'Do the xdiffpos calcs etc in parallel
                        
                        
                        If ElementNum > -1 Then
                            
                             'ReDim NDiffG(6, GroupSize)
                            
                            'ReDim GoOnG(ElementNum)
                            
                            '@'@
                            'Dummy = FindSubSeqP7(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXoverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
                            Dummy = FindSubSeqGCAP3(UBound(NDiffG, 1), UBound(XPosDiffG, 1), UBound(SubSeqG, 1), UBound(SubSeqG, 2), ElementNum, LenXOverSeqG(0), GCIndelFlag, Len(StrainSeq(0)), Seq1, Seq2, ElementSeq(0), SeqNum(0, 0), SubSeqG(0, 0, 0), XPosDiffG(0, 0), XDiffPosG(0, 0), NDiffG(0, 0), BinArray(0, 0))
'                            Open "Test GCAP3.csv" For Output As #1
'                            For X = 0 To ElementNum
'                               ' For Y = 0 To 6
'                                    Print #1, " "
'                                    'For Z = 0 To LenXOverSeqG(X)
'                                    For Z = 0 To Len(StrainSeq(0))
'                                        'Print #1, SubSeqG(Z, Y, X)
'                                        Print #1, XPosDiffG(Z, X)
'                                    Next Z
'                               ' Next Y
'
'                            Next X
'
'                            Close #1
                            'ReDim GoOnG(GroupSize)
                            If x = x Then
                            '@'@'@'@'@'@'@'@'@
                            Dummy = GetFragsP2(GoOnG(0), ElementNum, UBound(FragCountG, 1), UBound(FragScoreG, 1), UBound(FragScoreG, 2), UBound(SubSeq, 1), UBound(SubSeq, 2), CircularFlag, LenXOverSeqG(0), Len(StrainSeq(0)), GCDimSize, SubSeqG(0, 0, 0), FragStG(0, 0, 0), FragEnG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0))
                            
                            For x = 0 To ElementNum
                                For Y = 0 To 6
                                    If FragCountG(Y, x) > MaxRequiredFraglen Then
                                        MaxRequiredFraglen = FragCountG(Y, x)
                                    End If
                                Next Y
                            Next x
                            
                            
                           
                            
                            '5.281
                            '@'@
                            GetMaxFragScoreP2 ElementNum, LenXOverSeqG(0), GCDimSize, CircularFlag, GCMissmatchPen, MissPenG(0, 0), MaxScorePosG(0, 0, 0), FragMaxScoreG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0), HiFragScoreG(0, 0), NDiffG(0, 0)
                            
                            
                            If x = x Then
                            For x = 0 To ElementNum
                                If LenXOverSeqG(x) > 0 And GoOnG(x) = 1 Then
                                Seq3 = ElementSeq(x)
                                
                                'If Maskseq(Seq3) = 0 Then
                                    
                                    LastY3 = -1
                                    b = b + 1
                                    ZZZ = ZZZ + 1
                                    'aaa = Abs(GetTickCount)
                                    'For X = 1 To 20                                            '
                                    
          
                                        'Call GCXoverDV(0, X, LenXoverSeqG(X), SpacerNoG(X), AHG(), XOverSeqnumWG(), SpacerSeqsG(), XDiffPosG(), XPosDiffG(), ValidSpacerG(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                         Call GCXoverDVI(HiFragScoreG(), FragMaxScoreG(), MaxScorePosG(), MissPenG(), x, FragStG(), FragEnG(), FragCountG(), LenXOverSeqG(x), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
                                        x = x
                                    
                                    If AbortFlag = 1 And NextNo * Len(StrainSeq(0)) > 50000 Then
                                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                        Form1.SSPanel1.Caption = ""
                                        Form1.ProgressBar1.Value = 0
                                        Call UpdateF2Prog
                                        Seq1 = NextNo
                                        Seq2 = NextNo
                                        Seq3 = NextNo
                                    End If
            
                                End If
                
                                'Next 'Seq3
                            Next x
                            End If
                            
                            End If
    
                        End If
                        If ExitDoFlag = 1 Then Exit Do
                    Loop
                    'DoEvents 'covered by currentlyrunning
                    Form1.WindowState = Form1.WindowState
    
    
    
                    If AbortFlag = 1 Then
                        Form1.SSPanel1.Caption = ""
                        Form1.ProgressBar1.Value = 0
                        Call UpdateF2Prog
                        Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
                    End If
    
                    ET = Abs(GetTickCount)
                    
                    
                End If
                
            Else
            
            
                If MaskSeq(Seq2) = 0 Then
                    LastY3 = -1
    
                    For Seq3 = Seq2 + 1 To NextNo
    
                        If MaskSeq(Seq3) = 0 Then
                            
                            LastY3 = -1
    '                                                aaa = Abs(GetTickCount)
    '                                                For ZZ = 1 To 10
                            Call GCXoverDIV(0)
    '                                                Next ZZ
    '                                                bbb = Abs(GetTickCount)
    '                                                ttt = bbb - aaa 'getfrags: 4.563,4.453,4.469
                            x = x
                                            'getfragsp no parallel:4.391,4.281, 4.297
                                            'getmaxfragscore:4.375,4.375, 4.328
                                            'getmaxfragscoreP no parallel:3.938,3.859, 3.860
                                            'FindSubSeqGCA:3.875,3.860,3.859
                                            'FindSubSeqGCAP no parallel:3.812,3.750, 3.750
                                            'gcgethipval:3.766,3.672,3.687
                                            'gcgethipvalp novector:3.735,3.687,3.703
                                            'gcgethipvalp parallel:3.719,3.687,3.672
                                            'getfragsp 3.828, 3.703, 3.703 with unparallel array void
                                            '4.000, 3.968, 3.922
                                            
                                            '4.234
                                            '4.203 with flush
                                            '3.875 unparallelised getmaxfrag
                                            'parallelised getmaxfrag 3.672,3.625, 3.625
                            b = b + 1
                            
                            
                            
    
                        End If
    
                        RunFlag = 1
                    Next 'Seq3
                    
                End If
            End If
            ET = Abs(GetTickCount)
                            
                            
    
            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                If (b + 1) < (MCCorrection + 1) Then
                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
                    Call UpdateF2Prog
                End If
                ET = Abs(ET)
                ST = Abs(ST)
                GCST = Abs(GCST)
                Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
                Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
                UpdateRecNums (SEventNumber)
                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    StartPlt(1) = 1
                    oRec = oRecombNo(100)
                    Call UpdatePlotC
                    ET = Abs(GetTickCount)
                End If
                LT = ET
                If Form1.ProgressBar1.Value > 0 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - GCST)) * (100 / Form1.ProgressBar1.Value) - (ET - GCST)) & " remaining"
                End If
                Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
                
                
                If (CLine <> "" And CLine <> " ") Then
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole vbClearLine
                    
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole "Running GENECONV scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                End If
                Form1.WindowState = Form1.WindowState
                'DoEvents 'covered by currentlyrunning

                If AbortFlag = 1 Then
                    Form1.SSPanel1.Caption = ""
                    Form1.ProgressBar1.Value = 0
                    Call UpdateF2Prog
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
                DoEvents
            End If
        Next 'Seq2

    End If

Next 'Seq1


If (CLine <> "" And CLine <> " ") Then
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole vbClearLine
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole "Running GENECONV scan: 100% complete"
End If


End Sub
Public Sub NewScanGC()
Dim GroupSize As Long, x As Long, ElementNum As Long, ElementSeq() As Long, XDiffPosG() As Long, XPosDiffG() As Long, NDiffG() As Long, SubSeqG() As Byte, LenXOverSeqG() As Long
Dim FragStG() As Long, FragEnG() As Long, FragScoreG() As Long, FragCountG() As Long, GoOnG() As Byte

ReDim BinArray(Len(StrainSeq(0)), NextNo)

GroupSize = 31
If (((Len(StrainSeq(0)) + 200) * GroupSize) > 5000000) Then
    GroupSize = CLng(GroupSize / (((Len(StrainSeq(0)) + 200) * GroupSize) / 5000000))
End If
ReDim SubSeqG(Len(StrainSeq(0)), 6, GroupSize), NDiffG(6, GroupSize), LenXOverSeqG(GroupSize), ElementSeq(GroupSize)
ReDim XDiffPosG(Len(StrainSeq(0)) + 200, GroupSize)
ReDim XPosDiffG(Len(StrainSeq(0)) + 200, GroupSize)
ReDim FragStG(GCDimSize, 6, GroupSize), FragEnG(GCDimSize, 6, GroupSize), FragScoreG(GCDimSize, 6, GroupSize), FragCountG(6, GroupSize), GoOnG(GroupSize)
'ReDim FragMaxScore(GCDimSize, 5)
'ReDim MaxScorePos(GCDimSize, 5)
'ReDim PVals(GCDimSize, 5)
'ReDim FragSt(GCDimSize, 6)
'ReDim FragEn(GCDimSize, 6)
'ReDim FragScore(GCDimSize, 6)
'ReDim DeleteArray(Len(StrainSeq(0)) + 1)


For Seq1 = 0 To NextNo
            
    If MaskSeq(Seq1) = 0 Then
        Dummy = MakeBinArrayP(Seq1, Len(StrainSeq(0)), NextNo, MaskSeq(0), SeqNum(0, 0), BinArray(0, 0))
        For Seq2 = Seq1 + 1 To NextNo
            If x = x Then
                If MaskSeq(Seq2) = 0 Then
                    Seq3 = Seq2
                    'Need to refill xdiffposG, xposdiffG, ahG, xoverseqnumwG
                    ExitDoFlag = 0
                    Do
                        ElementNum = -1
                        
                        Do
                            
                            Seq3 = Seq3 + 1
                            If Seq3 > NextNo Then
                                ExitDoFlag = 1
                                Exit Do
                            End If
                            'If ExitDoFLag = 0 Then
                            If MaskSeq(Seq3) = 0 Then
                            
                                GoOn = 1
                                If SelGrpFlag > 0 Then
                                    GrpTest = GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3)
                                    If GrpTest >= 2 Then
                                        GoOn = 0
                                    End If
                                End If
                                If GoOn = 1 Then
                                    ElementNum = ElementNum + 1
                                    ElementSeq(ElementNum) = Seq3
                                End If
                            End If
                        'Dummy = MakeBinArrayP(Seq2, Len(StrainSeq(0)), Nextno, Maskseq(0), SeqNum(0, 0), BinArray2(0, 0))
                            'For Seq3 = Seq2 + 1 To Nextno
                            If ElementNum = GroupSize Then Exit Do
                        Loop
                        'Do the xdiffpos calcs etc in parallel
                        
                        
                        If ElementNum > -1 Then
                            
                             'ReDim NDiffG(6, GroupSize)
                            
                            'ReDim GoOnG(ElementNum)
                            
                            
                            'Dummy = FindSubSeqP7(UBound(XOverSeqnumWG, 1), UBound(XOverSeqnumWG, 2), UBound(XOverSeqnumWG, 3), LenXoverSeqG(0), ElementNum, GoOnG(0), AHG(0, 0), SpacerFlag, Outlyer, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, ElementSeq(0), SpacerNoG(0), SeqNum(0, 0), XOverSeqnumWG(0, 0, 0), SpacerSeqsG(0, 0), XDiffPosG(0, 0), XPosDiffG(0, 0), ValidSpacerG(0, 0), BinArray(0, 0))
                            Dummy = FindSubSeqGCAP3(UBound(NDiffG, 1), UBound(XPosDiffG, 1), UBound(SubSeqG, 1), UBound(SubSeqG, 2), ElementNum, LenXOverSeqG(0), GCIndelFlag, Len(StrainSeq(0)), Seq1, Seq2, ElementSeq(0), SeqNum(0, 0), SubSeqG(0, 0, 0), XPosDiffG(0, 0), XDiffPosG(0, 0), NDiffG(0, 0), BinArray(0, 0))
'                            Open "Test GCAP3.csv" For Output As #1
'                            For X = 0 To ElementNum
'                               ' For Y = 0 To 6
'                                    Print #1, " "
'                                    'For Z = 0 To LenXOverSeqG(X)
'                                    For Z = 0 To Len(StrainSeq(0))
'                                        'Print #1, SubSeqG(Z, Y, X)
'                                        Print #1, XPosDiffG(Z, X)
'                                    Next Z
'                               ' Next Y
'
'                            Next X
'
'                            Close #1
                            'ReDim GoOnG(GroupSize)
                            If x = x Then
                            Dummy = GetFragsP2(GoOnG(0), ElementNum, UBound(FragCountG, 1), UBound(FragScoreG, 1), UBound(FragScoreG, 2), UBound(SubSeq, 1), UBound(SubSeq, 2), CircularFlag, LenXOverSeqG(0), Len(StrainSeq(0)), GCDimSize, SubSeqG(0, 0, 0), FragStG(0, 0, 0), FragEnG(0, 0, 0), FragScoreG(0, 0, 0), FragCountG(0, 0))
                            
                            For x = 0 To ElementNum
                                For Y = 0 To 6
                                    If FragCountG(Y, x) > MaxRequiredFraglen Then
                                        MaxRequiredFraglen = FragCountG(Y, x)
                                    End If
                                Next Y
                            Next x
                            If x = x Then
                            For x = 0 To ElementNum
                                If LenXOverSeqG(x) > 0 And GoOnG(x) = 1 Then
                                Seq3 = ElementSeq(x)
                                
                                'If Maskseq(Seq3) = 0 Then
                                    
                                    LastY3 = -1
                                    b = b + 1
                                    ZZZ = ZZZ + 1
                                    'aaa = Abs(GetTickCount)
                                    'For X = 1 To 20                                            '
                                    
          
                                        'Call GCXoverDV(0, X, LenXoverSeqG(X), SpacerNoG(X), AHG(), XOverSeqnumWG(), SpacerSeqsG(), XDiffPosG(), XPosDiffG(), ValidSpacerG(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                         Call GCXoverDV(x, FragStG(), FragEnG(), FragScoreG(), FragCountG(), LenXOverSeqG(x), NDiffG(), XPosDiffG(), XDiffPosG(), SubSeqG(), 0)
                                        x = x
                                    
                                    If AbortFlag = 1 And NextNo * Len(StrainSeq(0)) > 50000 Then
                                        DoEvents 'covered by currentlyrunning
                                        SSPanel1.Caption = ""
                                        ProgressBar1.Value = 0
                                        Call UpdateF2Prog
                                        Seq1 = NextNo
                                        Seq2 = NextNo
                                        Seq3 = NextNo
                                    End If
            
                                End If
                
                                'Next 'Seq3
                            Next x
                            End If
                            
                            End If
    
                        End If
                        If ExitDoFlag = 1 Then Exit Do
                    Loop
                    DoEvents 'covered by currentlyrunning
    
    
    
    
                    If AbortFlag = 1 Then
                        Form1.SSPanel1.Caption = ""
                        Form1.ProgressBar1.Value = 0
                        Call UpdateF2Prog
                        Seq1 = NextNo: Seq2 = NextNo: Seq3 = NextNo
                    End If
    
                    ET = Abs(GetTickCount)
                    
                    
                End If
                
            Else
            
            
                If MaskSeq(Seq2) = 0 Then
                    LastY3 = -1
    
                    For Seq3 = Seq2 + 1 To NextNo
    
                        If MaskSeq(Seq3) = 0 Then
                            
                            LastY3 = -1
    '                                                aaa = Abs(GetTickCount)
    '                                                For ZZ = 1 To 10
                            Call GCXoverDIV(0)
    '                                                Next ZZ
    '                                                bbb = Abs(GetTickCount)
    '                                                ttt = bbb - aaa 'getfrags: 4.563,4.453,4.469
                            x = x
                                            'getfragsp no parallel:4.391,4.281, 4.297
                                            'getmaxfragscore:4.375,4.375, 4.328
                                            'getmaxfragscoreP no parallel:3.938,3.859, 3.860
                                            'FindSubSeqGCA:3.875,3.860,3.859
                                            'FindSubSeqGCAP no parallel:3.812,3.750, 3.750
                                            'gcgethipval:3.766,3.672,3.687
                                            'gcgethipvalp novector:3.735,3.687,3.703
                                            'gcgethipvalp parallel:3.719,3.687,3.672
                                            'getfragsp 3.828, 3.703, 3.703 with unparallel array void
                                            '4.000, 3.968, 3.922
                                            
                                            '4.234
                                            '4.203 with flush
                                            '3.875 unparallelised getmaxfrag
                                            'parallelised getmaxfrag 3.672,3.625, 3.625
                            b = b + 1
                            
                            
                            
    
                        End If
    
                        RunFlag = 1
                    Next 'Seq3
                    
                End If
            End If
            ET = Abs(GetTickCount)
                            
                            
    
            If Abs(ET - LT) > 500 Or AbortFlag = 1 Then
                If (b + 1) < (MCCorrection + 1) Then
                    Form1.ProgressBar1.Value = (b + 1) / (MCCorrection + 1) * 100
                    Call UpdateF2Prog
                End If
                ET = Abs(ET)
                ST = Abs(ST)
                GCST = Abs(GCST)
                Form1.Label50(2).Caption = DoTimeII(Abs(ET - GCST))
                Form1.Label50(12).Caption = DoTimeII(Abs(Abs(ET - ST)))
                UpdateRecNums (SEventNumber)
                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                    StartPlt(1) = 1
                    oRec = oRecombNo(100)
                    Call UpdatePlotC
                    ET = Abs(GetTickCount)
                End If
                LT = ET
                If Form1.ProgressBar1.Value > 0 Then
                    Form1.SSPanel13.Caption = "Approximately " & DoTime((Abs(ET - GCST)) * (100 / Form1.ProgressBar1.Value) - (ET - GCST)) & " remaining"
                End If
                Form1.SSPanel1.Caption = Str(b) & " of" & Str(MCCorrection) & " triplets examined"
                DoEvents 'covered by currentlyrunning
                If (CLine <> "" And CLine <> " ") Then
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole vbClearLine
                    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
                    GetConsoleScreenBufferInfo hOutput, scrbuf
                    WriteToConsole "Running GENECONV scan: " & Trim(Str(CLng(Form1.ProgressBar1.Value))) & "% complete"
                End If
                If AbortFlag = 1 Then
                    Form1.SSPanel1.Caption = ""
                    Form1.ProgressBar1.Value = 0
                    Call UpdateF2Prog
                    Seq1 = NextNo
                    Seq2 = NextNo
                    Seq3 = NextNo
                End If
            End If
        Next 'Seq2

    End If

Next 'Seq1


End Sub
Public Sub NameCheckX()
'Dim red() As Long
'ReDim red(Nextno, Nextno)
Form1.SSPanel1.Caption = "Checking sequence names"
Form1.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Dim GoOn As Byte, x As Long, Y As Long, Pos As Long, NL() As Integer


ReDim NL(NextNo)
For x = 0 To NextNo
    NL(x) = Len(StraiName(x))
Next x
GoOn = 0
Rnd (-BSRndNumSeed)

SS = Abs(GetTickCount)
Do While GoOn = 0
    GoOn = 1
    If NextNo > MemPoc Then
        For x = 0 To NextNo
            StraiName(x) = StraiName(x) + Trim(Str(x))
        Next x
    End If
    For x = 0 To NextNo
        For Y = 0 To NextNo
            If x <> Y Then
'                If StraiName(X) = StraiName(Y) Then
'                    StraiName(Y) = StraiName(Y) + Trim(Str(CLng((32000 * Rnd) + 1)))
'                    NL(Y) = Len(StraiName(Y))
'                    GoOn = 0
'                    Y = Y - 1
'                    If Y = 0 Then
'                        X = X - 1
'                    End If
'                Else
                    If NL(x) > NL(Y) Then
                        Pos = InStr(1, StraiName(x), StraiName(Y), vbBinaryCompare)
                        If Pos > 0 Then
                            StraiName(Y) = StraiName(Y) + Trim(Str(CLng((32000 * Rnd) + 1)))
                            NL(Y) = Len(StraiName(Y))
                            GoOn = 0
                        
                        End If
                    ElseIf NL(x) = NL(Y) Then
                        If StraiName(x) = StraiName(Y) Then
                            StraiName(Y) = StraiName(Y) + Trim(Str(CLng((32000 * Rnd) + 1)))
                            NL(Y) = Len(StraiName(Y))
                            GoOn = 0
                        End If
                    End If
                'End If
            End If
        Next Y
    Next x
Loop
EE = Abs(GetTickCount)
TT = EE - SS '5.289 seconds for nextno = 4715
''1.968 for freds 3800 alignment
Form1.Refresh
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState

End Sub
Public Sub Renamer(InName() As String, OutName() As String, InS As String, OutS As String)
Dim L As String, M As String, r As String, FxName As String
'Make a list of redundant/identical names

OutS = InS
For x = 0 To UBound(InName, 1)
    
    For Y = 0 To UBound(OutName, 1)
        If Y = 44 Then
            x = x
        End If
        Pos = InStr(1, OutName(Y), InName(x), vbBinaryCompare)
        If Pos > 0 Then
            
            Pos = InStr(1, OutS, InName(x), vbBinaryCompare)
            InName(x) = InName(x) + "!@#$%"
            OutS = Left(OutS, Pos) + "!@#$%" + Right(OutS, Len(OutS) - Pos)
            'XX = Mid(OutS, Pos - 10, 20)
            x = x
        End If
    Next Y
Next x

'First check whether in and out have any conflicts



For x = 0 To UBound(OutName, 1)
    If x = 44 Then
        x = x
    End If
    Pos = InStr(1, OutS, InName(x), vbBinaryCompare)
    If Pos > 0 Then
        
        L = Left(OutS, Pos - 1)
        r = Right(OutS, Len(OutS) - (Pos + Len(InName(x)) - 1))
        M = OutName(x)
        OutS = L + M + r
        x = x
    Else
        'make sure we're not dealing with a fixedname
        FxName = InName(x)
        Call FixName(FxName)
        Pos = InStr(1, OutS, FxName, vbBinaryCompare)
        If Pos > 0 Then
            InName(x) = FxName
            L = Left(OutS, Pos - 1)
            r = Right(OutS, Len(OutS) - (Pos + Len(InName(x)) - 1))
            M = OutName(x)
            OutS = L + M + r
        End If
    End If
Next x



Pos = InStr(1, OutS, "E-", vbTextCompare)
Dim Xpos As Long, lP As Long, RP As Long, repVal As Double
If Pos > 0 Then
    Do
        Xpos = Pos
        Do
            Xpos = Xpos - 1
            If Xpos = 0 Then Exit Do
            If Mid$(OutS, Xpos, 1) = "." Then
                lP = Xpos - 1
                Exit Do
            End If
            
            
        Loop
        If Xpos = 0 Then 'this is in case we're looking at a european version of windows where commas are used instead of dots as decimal separators
            Xpos = Pos
            Do
                Xpos = Xpos - 1
                If Xpos = 0 Then Exit Do
                If Mid$(OutS, Xpos, 1) = "," Then
                    lP = Xpos - 1
                    Exit Do
                End If
                
                
            Loop
        
        End If
        Xpos = Pos
        Do
            Xpos = Xpos + 1
            If Xpos > Len(OutS) Then Exit Do
            If Mid$(OutS, Xpos, 1) = ")" Or Mid$(OutS, Xpos, 1) = "," Then
                RP = Xpos - 1
                Exit Do
            End If
        Loop
        If lP > 0 Then
            L = Left(OutS, lP - 1)
        End If
        
        r = Right(OutS, Len(OutS) - RP)
        'M = OutName(X)
        ssssx = Mid$(OutS, lP, RP - (lP - 1))
        If DebuggingFlag < 2 Then On Error Resume Next
        repVal = val(Mid$(OutS, lP, RP - (lP - 1)))
        On Error GoTo 0
        repVal = repVal * 10000
        repVal = CLng(repVal)
        repVal = repVal / 1000
        M = Trim(Str(repVal))
        If Left(M, 1) = "." Or Left(M, 1) = "," Then M = "0" + M
        OutS = L + M + r
           
        Pos = InStr(1, OutS, "E-", vbTextCompare)
        If Pos = 0 Then Exit Do
    Loop
    
End If
'Open "test.txt" For Output As #10'
'
'Print #10, OutS
'Close #10

x = x
End Sub
Public Sub GetNodeNumX(TargetName() As String, NodenumX, SeqArray() As Long, NSeq() As Long, NHFlag, NodeNum, OutTree As String)
Dim Hipos As Long, LoPos As Long, Hipos2 As Long, LoPos2 As Long, NO As Long, NC As Long

'REMEMBER:  this does not give the "correct" node number for one of the two basal nodes if the tree is unrooted -ie both will be
'ID'd as node 2

Hipos = 0
LoPos = Len(OutTree)
ZZZ = 0
For x = 0 To NSeq(NodeNum)
    Pos = InStr(1, OutTree, TargetName(SeqArray(NodeNum, x)), vbBinaryCompare)
    If Pos > 0 Then
        If Pos < LoPos Then LoPos = Pos
        If Pos > Hipos Then Hipos = Pos
        
    End If
Next x

NO = 0: NC = 0
For x = LoPos To Hipos ' find ")" or "S" immediately befor the first seq name
    If Mid$(OutTree, x, 1) = ")" Then
        NC = NC + 1
    End If
    If Mid$(OutTree, x, 1) = "(" Then 'count the "("s
       NO = NO + 1
    End If
Next x

For x = LoPos - 1 To 1 Step -1 ' find ")" or "S" immediately befor the first seq name
    If Mid$(OutTree, x, 1) = ")" Or Mid$(OutTree, x, 1) = "S" Then
        Exit For
    End If
     If Mid$(OutTree, x, 1) = "(" Then 'count the "("s
        NO = NO + 1
     End If
Next x


LoPos2 = x
If LoPos2 = 0 Then LoPos2 = 1

For x = Hipos + 1 To Len(OutTree) ' find "(" or "S" immediately after the last seq name
    If Mid$(OutTree, x, 1) = "(" Or Mid$(OutTree, x, 1) = "S" Then
        Exit For
    End If
    If Mid$(OutTree, x, 1) = ")" Then 'count the ")"s
        NC = NC + 1
     End If
Next x
Hipos2 = x

If NO > NC Then
    Hipos = Hipos2 - 1
    'go forward from lopos2 until the number of open brackets = the number of closebrackets
    For x = LoPos2 To Len(OutTree)
        If Mid$(OutTree, x, 1) = "(" Then
            NO = NO - 1
            If NO = NC Then
                Exit For
            End If
        End If
    
    Next x
    LoPos = x + 1
Else
    For x = LoPos2 To Len(OutTree)
        If Mid$(OutTree, x, 1) = "(" Then
            LoPos = x
           ' XX = Mid$(OutTree, X, 20)
            
            Exit For
        End If
    Next x

End If

'count the number of "(" brackets up until lopos
NodenumX = 0
'XX = Mid$(OutTree, LoPos, 20)
For x = 1 To LoPos
    If Mid$(OutTree, x, 1) = "(" Then
        NodenumX = NodenumX + 1
    End If

Next x
x = x

End Sub
Public Sub AncParsML(ARQ, Recfree, NHFlag, NodeNum As Long, SeqArray() As Long, NSeq() As Long, BannedList() As Byte)
Dim TAnc  As String, Target As String, TString As String, TempSeq() As String, TS As String, OutTree As String, NameLen As Long, FF As Long, RenameString() As String
ReDim TempSeq(NextNo), RenameString(NextNo)
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0
'RecFree = 1
ReDim Parts(1, 10)
PartNo = 0
'Do infile
Dim SPart() As Long
If Recfree = 1 Then 'take out recombinant tracts
    
    Call MakeRecFreeSeqs(PartNo, Parts(), ARQ, 0, TempSeq(), BannedList(), SPart())
Else
    For x = 0 To NextNo
        TempSeq(x) = StrainSeq(x)
    Next x
End If

NameLen = Log10(NextNo + 1) + 1
'XX = Log10(100)
FF = FreeFile
Open "infile" For Output As #FF
TS = Str(NextNo + 1) & Str(Len(StrainSeq(0)))
Print #FF, TS
UnModNextno
For x = 0 To NextNo
    TS = Trim(Str(x))
    TS = String(NameLen - Len(TS), "0") + TS
    TS = "S" + TS
    RenameString(x) = TS
    TS = TS + String(10 - Len(TS), " ")
    TS = TS + TempSeq(x)
    Print #FF, TS
Next x
Close #FF

'Do treefile
Call Renamer(OriginalName(), RenameString(), NHString(NHFlag), OutTree)
Call GetNodeNumX(RenameString(), NodenumX, SeqArray(), NSeq(), NHFlag, NodeNum, OutTree)
NodeNum = NodeNum

'replace commas with dots
Dim TargetX As String, ReplaceT As String
XX = OutTree
For x = 0 To 9
    For Y = 0 To 9
        TargetX = Trim(Str(x)) + "," + Trim(Str(Y))
        ReplaceT = Trim(Str(x)) + "." + Trim(Str(Y))
        Do
            Pos = InStr(1, OutTree, TargetX, vbBinaryCompare)
            If Pos = 0 Then Exit Do
            Mid$(OutTree, Pos, 3) = ReplaceT
        Loop
    Next Y
Next x
Open "intree" For Output As #FF
Print #FF, "1"
Print #FF, OutTree
Close #FF

'Do Bat file for dnapars
If DebuggingFlag < 2 Then On Error Resume Next

Randomize
KillFile "dnapars.bat"
FLen = 0

'FLen = FileLen("dnapars.bat")

If Dir("dnapars.bat") <> "" Then 'this means that for some reason the file did not get deleted - we need to use another name for it
    
    FString = "dnapars" & Trim(Str(Rnd)) & ".bat"
Else
    FString = "dnapars.bat"
End If
Rnd (-BSRndNumSeed)
Open FString For Output As #FF
Print #FF, "dnapars <optfile"

Print #FF, "del dnapars.bat"
'Print #FF, "rename outfile outfilex"
Close #FF


'do bat file for fastml
Open "fastml.bat" For Output As #FF
Print #FF, "fastml.exe -s infile -t intree -mn -qf"

Close #FF
On Error GoTo 0

'Do Optionfile
'dnapars option file - used during anc seq calculations.
Open "optfile" For Output As #FF
Print #FF, "u" 'don't search for best tree - use supplied tree
Print #FF, "2" 'don't show run progress
'Print #FF, "3" 'don't print out tree
Print #FF, "5" 'give ancestral states
Print #FF, "." 'don't use dot differencing
Print #FF, "y"
Print #FF, ""
Close #FF

BatIndex = 27

'have to get rid of outfile
If DebuggingFlag < 2 Then On Error Resume Next
KillFile "outfile"
KillFile "outfilex"
KillFile "outtree"
On Error GoTo 0

XX = CurDir
'run dnapars
Form1.SSPanel1.Caption = "Using DNAPARS to infer ancestral sequence"
Form2.SSPanel3.Caption = "Using DNAPARS to infer ancestral sequence"
Call ShellAndClose(FString, 0)

Form1.SSPanel1.Caption = "Using RAxML to infer ancestral sequence"
Form1.SSPanel3.Caption = "Using RAxML to infer ancestral sequence"
'Call ShellAndClose("fastml.bat", 1)
Name "outfile" As "outfilex"
Open "outfilex" For Input As #FF

'get to the start of the data
Do While Not EOF(FF)
    Line Input #FF, TString
    If Left(TString, 4) = "From" Then Exit Do
Loop

'read through the dnapars outfile and extract the relevant sequence (nodenumx)
Target = " " + Trim(Str(NodenumX)) + " "
TAnc = ""
Do While Not EOF(FF)
    Line Input #FF, TString
    Pos = InStr(1, TString, Target, vbBinaryCompare)
    If Pos > 6 Then 'on the right line
       For x = Pos + 5 To Len(TString)
            target2 = Mid$(TString, x, 1)
            If target2 <> "m" Then
            If target2 <> "a" Then
            If target2 <> "y" Then
            If target2 <> "b" Then
            If target2 <> "e" Then
            If target2 <> "n" Then
            If target2 <> "o" Then
            If target2 <> "y" Then
            If target2 <> "s" Then
            If target2 <> " " Then
                TAnc = TAnc + target2
            End If
            End If
            End If
            End If
            End If
            End If
            End If
            End If
            End If
            End If
            
        Next x
    End If
Loop
XX = Len(TAnc)
Close #FF

ParsAncSeq = TAnc
ReDim PAncPVals(5, Len(ParsAncSeq))
For x = 1 To Len(ParsAncSeq)
    
    If UCase(Mid(ParsAncSeq, x, 1)) = "A" Then
        PAncPVals(0, x) = 1
        PAncPVals(1, x) = 1
        PAncPVals(5, x) = 0
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "C" Then
        PAncPVals(0, x) = 1
        PAncPVals(2, x) = 1
        PAncPVals(5, x) = 1
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "G" Then
        PAncPVals(0, x) = 1
        PAncPVals(3, x) = 1
        PAncPVals(5, x) = 2
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "T" Then
        PAncPVals(0, x) = 1
        PAncPVals(4, x) = 1
        PAncPVals(5, x) = 3
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "?" Then
        PAncPVals(0, x) = 0.2
        PAncPVals(1, x) = 0.2
        PAncPVals(2, x) = 0.2
        PAncPVals(3, x) = 0.2
        PAncPVals(4, x) = 0.2
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "-" Then
        PAncPVals(0, x) = 1
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "W" Then
        PAncPVals(0, x) = 1
        PAncPVals(1, x) = 0.5
        PAncPVals(4, x) = 0.5
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "S" Then
        PAncPVals(0, x) = 0.5
        PAncPVals(2, x) = 0.5
        PAncPVals(3, x) = 0.5
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "M" Then
        PAncPVals(0, x) = 0.5
        PAncPVals(1, x) = 0.5
        PAncPVals(2, x) = 0.5
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "K" Then
        PAncPVals(0, x) = 0.5
        PAncPVals(3, x) = 0.5
        PAncPVals(4, x) = 0.5
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "R" Then
        PAncPVals(0, x) = 0.5
        PAncPVals(1, x) = 0.5
        PAncPVals(3, x) = 0.5
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "Y" Then
        PAncPVals(0, x) = 0.5
        PAncPVals(2, x) = 0.5
        PAncPVals(4, x) = 0.5
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "B" Then
        PAncPVals(0, x) = 0.3333
        PAncPVals(2, x) = 0.3333
        PAncPVals(3, x) = 0.3333
        PAncPVals(4, x) = 0.3333
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "D" Then
        PAncPVals(0, x) = 0.3333
        PAncPVals(1, x) = 0.3333
        PAncPVals(3, x) = 0.3333
        PAncPVals(4, x) = 0.3333
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "H" Then
        PAncPVals(0, x) = 0.3333
        PAncPVals(1, x) = 0.3333
        PAncPVals(2, x) = 0.3333
        PAncPVals(4, x) = 0.3333
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "V" Then
        PAncPVals(0, x) = 0.3333
        PAncPVals(1, x) = 0.3333
        PAncPVals(2, x) = 0.3333
        PAncPVals(3, x) = 0.3333
        PAncPVals(5, x) = 5
    ElseIf UCase(Mid(ParsAncSeq, x, 1)) = "N" Then
        PAncPVals(0, x) = 0.25
        PAncPVals(1, x) = 0.25
        PAncPVals(2, x) = 0.25
        PAncPVals(3, x) = 0.25
        PAncPVals(4, x) = 0.25
        PAncPVals(5, x) = 5
    Else
        XX = UCase(Mid(ParsAncSeq, x, 1))
        x = x
    End If
'W   Weak    A/T
'S   Strong  C/G
'M   Amino   A/C
'K   Keto    G/T
'R   Purine  A/G
'Y   Pyrimidine  C/T
'B   Not A   C/G/T
'D   Not C   A/G/T
'H   Not G   A/C/T
'V   Not T   A/C/G
'N   Any A/C/G/T

Next x



MLAncSeq = ParsAncSeq

If DebuggingFlag < 2 Then On Error Resume Next
    If Dir(FString) <> "" Then
        Kill FString
    End If
    If Dir("fastml.bat") <> "" Then
        KillFile "fastml.bat"
    End If
'ODir = CurDir
ChDrive oDir
ChDir oDir
On Error GoTo 0
End Sub
Public Sub CheckAncSeq()
Dim AncSeq() As Double, NumRuns As Long, PVal As Double, WinNuc As Long

ReDim AncSeq(1, Len(StrainSeq(0)), 4)
NumRuns = 0

Call ReadPFile("outfile.run1.p", AncSeq(), 0)
'Call ReadPFile("outfile.run2.p", AncSeq(), 1)
ReDim Preserve AncPVals(5, Len(StrainSeq(0)))
ReDim Preserve AncPValsBayes(5, Len(StrainSeq(0)))
SumAncSeq = String(Len(StrainSeq(0)), " ")

For x = 0 To Len(StrainSeq(0))
    AncPVals(0, x) = 1
    For Y = 0 To 5
        AncPVals(Y, x) = AncPValsBayes(Y, x)
    Next Y
Next x
Dim DivNum As Double
For x = 1 To LTmpSeq
    
    WinNuc = -1
    PVal = 0
    For Y = 0 To NumRuns
        
        For Z = 0 To 3
            'For Y = 0 To NumRuns
                If AncSeq(Y, x, Z) > PVal Then
                    WinNuc = Z
                    PVal = AncSeq(Y, x, Z)
                End If
            'Next Y
            AncPVals(Z + 1, ReMapR(x)) = AncPVals(Z + 1, ReMapR(x)) + AncSeq(Y, x, Z)
            x = x
        Next Z
        
    Next Y
    DivNum = (AncPVals(1, ReMapR(x)) + AncPVals(2, ReMapR(x)) + AncPVals(3, ReMapR(x)) + AncPVals(4, ReMapR(x)))
    
    AncPVals(0, ReMapR(x)) = AncPVals(WinNuc + 1, ReMapR(x)) / DivNum
    AncPValsBayes(0, ReMapR(x)) = AncPVals(0, ReMapR(x))
    For Z = 0 To 3
        AncPVals(Z + 1, ReMapR(x)) = AncPVals(Z + 1, ReMapR(x)) / DivNum '(NumRuns + 1)
        AncPValsBayes(Z + 1, ReMapR(x)) = AncPVals(Z + 1, ReMapR(x))
    Next Z
    AncPVals(5, ReMapR(x)) = WinNuc
    AncPValsBayes(5, ReMapR(x)) = AncPVals(5, ReMapR(x))
Next x

For x = 1 To Len(StrainSeq(0))
    
    If AncPVals(0, x) > 0.4 Then
        If AncPVals(5, x) = 0 Then
            Mid$(SumAncSeq, x, 1) = "A"
        ElseIf AncPVals(5, x) = 1 Then
            Mid$(SumAncSeq, x, 1) = "C"
        ElseIf AncPVals(5, x) = 2 Then
            Mid$(SumAncSeq, x, 1) = "G"
        ElseIf AncPVals(5, x) = 3 Then
            Mid$(SumAncSeq, x, 1) = "T"
        Else
            Mid$(SumAncSeq, x, 1) = "-"
        End If
    Else
        Mid$(SumAncSeq, x, 1) = "-"
    End If
Next x

If Len(Trim(MLAncSeq)) > 0 Then
    For x = 1 To Len(SumAncSeq)
        If Mid$(MLAncSeq, x, 1) = "-" Then
            Mid$(SumAncSeq, x, 1) = "-"
        End If
    Next x
End If


AncSeqFlag = 1

'Set stuff up so that the ancestral sequence can be displayed
If Form1.Picture22.Visible = False Then
    Form1.VScroll3.Height = (Form1.HScroll1.Top - Form1.VScroll3.Top - 4 * Screen.TwipsPerPixelX) / 2
    Form1.Picture8.Height = Form1.VScroll3.Height
    Form1.Picture9.Height = Form1.VScroll3.Height
    'Form1.Picture1.Height = Form1.Picture9.Height
    Form1.Picture22.Top = Form1.VScroll3.Top + Form1.VScroll3.Height + 50
    Form1.Picture22.Left = Form1.Picture9.Left
    Form1.Picture22.Height = Form1.Picture9.Height - 50
    Form1.Picture22.Width = Form1.Picture8.Left + Form1.Picture8.Width - Form1.Picture22.Left
    Form1.Picture22.Visible = True
    'If Form1.command33(0).Enabled = True Then Call Command33_Click(0) Else Call Command33_Click(1)
End If
'Form1.HScroll1.Value = Form1.HScroll1.Value + 0.1
If Form1.WindowState = 2 Or Form1.WindowState = 0 Then
    Form1.Command1.SetFocus
    Form1.Command3.SetFocus
End If
'If Form1.HScroll1.Value = 0 Then
'
'Else
'    Form1.HScroll1.Value = 0 'Form1.HScroll1.Value - 1
'    'Form1.HScroll1.Value = Form1.HScroll1.Value + 1
'End If
End Sub
Public Sub ReadPFile(Infile As String, AncSeq() As Double, SeqN As Long)
Dim LastPos As Long, oDir As String, FF As Long, FL As Long, InString As String, BlockLen As Long, StartPos As Long, TabNum As Long
x = x
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0
FF = FreeFile

BlockLen = 50 * LTmpSeq * 2


'find the number of tabs to the data



FL = FileLen(Infile)
XX = Len(InString)

Dim RL As Long
RL = BlockLen

If FL >= 0 Then
    If FL < RL Then RL = FL
    InString = String(RL, " ")
    Open Infile For Binary As #FF
    Get #FF, 1, InString
    Close #FF
Else
    ErrorFlag = 1
    Exit Sub
    
End If

'Open "xx.x" For Output As #1
'Print #1, InString
'Close #1
Pos = InStr(1, InString, "p(", vbBinaryCompare)
InString = Left(InString, Pos)
Pos = 0
TabNum = 0
Do
    Pos = InStr(Pos + 1, InString, Chr(9), vbBinaryCompare)
    If Pos = 0 Then Exit Do
    TabNum = TabNum + 1
Loop

InString = String(BlockLen, " ")
    'FL = FileLen(#FF)


'ReDim AncSeq(1, Len(StrainSeq(0)), 4)

FL = FileLen(Infile)
Targetstr = Chr(9) & "-"
If (BlockLen * 20) < FL Then
    Dim INumber As Long
    INumber = CLng(((FL / BlockLen) / 2) - 1)
    If INumber > 100 Then INumber = 100
    For Z = 1 To INumber
        InString = String(BlockLen, " ")
        Open Infile For Binary As #FF
        If BlockLen < FL Then
            Get #FF, FL - BlockLen * Z, InString
        
        End If
        Close #FF
        StartPos = 0
        'TargetX = Chr(9) & "-"
        Do
            StartPos = InStr(StartPos + 1, InString, Targetstr, vbBinaryCompare)
            'XX = Mid$(InString, StartPos - 10, 20)
            If StartPos = 0 Then Exit Sub
            If Mid$(InString, StartPos + 1, 9) <> "-1.#IND00" Then Exit Do
            
        Loop
        XX = Mid$(InString, StartPos + 1, 9)
        'Skip the first 12 tabs
        StartPos = StartPos + 1
        Pos = StartPos
        'Open Infile For Input As #1
        '    Line Input #1, XX
        '    XX = XX
        Close #1
        'Open "XX.X" For Output As #1
        'Print #1, XX
        'Close #1
        For x = 0 To TabNum - 2
            Pos = InStr(Pos + 1, InString, Chr(9), vbBinaryCompare)
            'XX = Mid$(InString, Pos - 10, 20)
            
        Next x
        
        'Open "testout.x" For Output As #3
        'Print #3, InString
        'Close #3
        'xxp = InStr(1, InString, "938", vbBinaryCompare)
        'xxxx = Mid$(InString, xxp, 20)
        lastpos22 = 1
        For x = 1 To LTmpSeq
           ' If X = 938 Then
           '     X = X
           ' End If
            For Y = 0 To 3
                'Pos = LastPos
                'Pos = LastPos
                LastPos = Pos
                'Pos = InStr(Pos + 1, InString, Chr(9), vbBinaryCompare)
                'xxx = Mid$(InString, LastPos + 1, Pos - LastPos - 1)
                '
                Pos1 = InStr(Pos + 1, InString, Chr(9), vbBinaryCompare)
                If lastpos22 < Pos1 And lastpos22 > 0 Then
                    Pos22 = InStr(Pos + 1, InString, Chr(13), vbBinaryCompare)
                    lastpos22 = Pos22
                'Else
                '    Pos22 = InStr(Pos + 1, InString, Chr(13), vbBinaryCompare)
                '    lastpos22 = Pos22
                End If
                If Pos1 = 0 Then
                    Pos = Pos22
                Else
                    If Pos22 > 0 Then
                        If Pos1 < Pos22 Then
                            Pos = Pos1
                        Else
                            Pos = Pos22
                        End If
                    Else
                        Pos = Pos1
                    End If
                
                End If
                If Pos > 0 Then
                   
                    'XX = Mid$(InString, LastPos + 1, Pos - LastPos - 1)
                    AncSeq(SeqN, x, Y) = AncSeq(SeqN, x, Y) + val(Trim(Mid$(InString, LastPos + 1, Pos - LastPos - 1)))
                 
                End If
                x = x
            Next Y
        Next x
    Next Z
    For x = 1 To LTmpSeq
       ' If X = 938 Then
       '     X = X
       ' End If
       
        For Y = 0 To 3
            
            AncSeq(SeqN, x, Y) = AncSeq(SeqN, x, Y) / INumber
            
        Next Y
    Next x
Else
    Open Infile For Binary As #FF
    If BlockLen < FL Then
        Get #FF, FL - BlockLen, InString
    
    End If
    Close #FF
    StartPos = 0
    Do
        StartPos = InStr(StartPos + 1, InString, Targetstr, vbBinaryCompare)
        If StartPos = 0 Then Exit Sub
        If Mid$(InString, StartPos + 1, 9) <> "-1.#IND00" Then Exit Do
        
    Loop
    
    StartPos = StartPos + 1
    'Skip the first 12 tabs
    Pos = StartPos
    For x = 0 To 12
        Pos = InStr(Pos + 1, InString, Chr(9), vbBinaryCompare)
       
    Next x
    
    
    'xxp = InStr(1, InString, "938", vbBinaryCompare)
    'xxxx = Mid$(InString, xxp, 20)
    For x = 1 To LTmpSeq
       ' If X = 938 Then
       '     X = X
       ' End If
        For Y = 0 To 3
            'Pos = LastPos
            LastPos = Pos
            Pos1 = InStr(Pos + 1, InString, Chr(9), vbBinaryCompare)
            Pos22 = InStr(Pos + 1, InString, Chr(13), vbBinaryCompare)
            If Pos1 = 0 Then
                Pos = Pos22
            Else
                If Pos22 > 0 Then
                    If Pos1 < Pos22 Then
                        Pos = Pos1
                    Else
                        Pos = Pos22
                    End If
                Else
                    Pos = Pos1
                End If
            
            End If
            
            'xxx = Mid$(InString, LastPos + 1, Pos - LastPos - 1)
            'XX = Len(InString)
            If LastPos + 1 <= Len(InString) Then
                'XX = Mid$(InString, LastPos + 1, (Pos - LastPos - 1))
            
                AncSeq(SeqN, x, Y) = val(Trim(Mid$(InString, LastPos + 1, (Pos - LastPos - 1))))
            End If
        Next Y
    Next x
End If


If DebuggingFlag < 2 Then On Error Resume Next

ChDrive oDir
ChDir oDir
On Error GoTo 0
AncSeqFlag = 1
End Sub

Public Sub MakeNodeFind(NodeFind() As Byte, TreeNum)

Dim FF As Byte, FN As String


oDir = CurDir
ChDir App.Path
ChDrive App.Path


Dim UB As Long
FF = FreeFile
FN = "NF" + UFTag + Trim(Str(TreeNum))

Open FN For Binary As FF
Get #FF, , UB
ReDim NodeFind(UB, UB)
Get #FF, , NodeFind()

Close FF
'nodefind(
ChDir oDir
ChDrive oDir

End Sub
Public Sub MakeSNodePath(NodePath() As Integer, TreeNum)

Dim FF As Byte, FN As String

'ReDim NodeFind(PermNextno + 2, PermNextno + 2)

oDir = CurDir
ChDir App.Path
ChDrive App.Path



FF = FreeFile
FN = "NP" + Trim(Str(TreeNum))

Open FN For Binary As FF

Get #FF, , NodePath()

Close FF

ChDir oDir
ChDrive oDir

End Sub
Public Sub WriteNodeFind(NodeFind() As Byte, TreeNum)

Dim oDir As String, FF As Byte, FN As String


oDir = CurDir
ChDir App.Path
ChDrive App.Path



FF = FreeFile
FN = "NF" + UFTag + Trim(Str(TreeNum))

If DebuggingFlag < 2 Then On Error Resume Next
KillFile FN
''
Sleep 50
On Error GoTo 0

Open FN For Binary As FF
Put #FF, , CLng(UBound(NodeFind, 1))
Put #FF, , NodeFind()

Close #FF

'FN = "NMR" + Trim(Str(TreeNum))
'
'If DebuggingFlag < 2 Then On Error Resume Next
'Kill FN
'On Error GoTo 0
'
'Open FN For Binary As FF
'
'Put #FF, , NodeFind()
'
'Close FN

ChDir oDir
ChDrive oDir

End Sub
Public Sub WritesNodePath(NodePath() As Integer, TreeNum)

Dim FF As Byte, FN As String


oDir = CurDir
ChDir App.Path
ChDrive App.Path



FF = FreeFile
FN = "NP" + Trim(Str(TreeNum))

If DebuggingFlag < 2 Then On Error Resume Next
KillFile FN
Sleep 100
On Error GoTo 0

Open FN For Binary As FF

Put #FF, , NodePath()

Close FF

'FN = "NMR" + Trim(Str(TreeNum))
'
'If DebuggingFlag < 2 Then On Error Resume Next
'Kill FN
'On Error GoTo 0
'
'Open FN For Binary As FF
'
'Put #FF, , NodeFind()
'
'Close FN

ChDir oDir
ChDrive oDir

End Sub
Public Sub MakeRecFreeSeqs(PartNo As Long, Parts() As Long, ARQ, RF, TempSeq() As String, BannedList() As Byte, SPart() As Long)
Dim SeqSave() As Byte, ReplaceVal, AccptableE As Long
ReDim SPart(Len(StrainSeq(0)))
If RF = 0 Then
    ReplaceVal = 46
ElseIf RF = 1 Then
    ReplaceVal = 64
Else
    ReplaceVal = 79
End If


If ARQ = 1 Then
    
End If

ReDim TempSeq(PermNextno)
Dim NodeFind() As Byte
Call MakeNodeFind(NodeFind(), SelectNode(3))
'XX = NodeFind(SelectNode(0), 37)
    If PermSeqNumInFile = 1 Then
        ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
        ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , SeqSave
        Close #FF
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , PermSeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        ReDim Preserve SeqSave(Len(StrainSeq(0)), PermNextno)
    Else
        ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
        For x = 0 To PermNextno
            For Y = 1 To Len(StrainSeq(0))
                SeqSave(Y, x) = PermSeqNum(Y, x)
            Next Y
        Next x
    End If
    'PartNo = 0
    For Z = 1 To SEventNumber '2,5
        If XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).Accept = 1 Or (XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).Accept = 2 And (XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).MissIdentifyFlag = 3 Or XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).MissIdentifyFlag = 13)) Or (ARQ = 1 And XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).Accept = 0) Then
            BE = XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).Beginning
            EN = XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).Ending
            Ma = XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).MajorP
            Mi = XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).MinorP
            D = XoverList(BestEvent(Z, 0), BestEvent(Z, 1)).Daughter
            
            GoOnX = 0
            If BannedList(Ma, D) = 1 Or BannedList(Mi, D) = 1 Or BannedList(Mi, Ma) = 1 Then
                
                For A = 0 To PermNextno
                    If NodeFind(PermSelectNode(0), A) = 1 And Daught(Z, A) = 0 Then
                        GoOnX = 1
                        Exit For
                    End If
                    
                Next A
                
            End If
            If GoOnX = 1 Then
                For x = 0 To PermNextno
                    For Y = 1 To CurrentXOver(x)
                        If SuperEventList(XoverList(x, Y).Eventnumber) = Z Then
                            
                            
                            If BE < EN Then
                                For A = BE To EN
                                    SeqSave(A, x) = ReplaceVal
                                Next A
                            Else
                                For A = BE To Len(StrainSeq(0))
                                    SeqSave(A, x) = ReplaceVal
                                Next A
                                For A = 1 To EN
                                    SeqSave(A, x) = ReplaceVal
                                Next A
                            End If
                            Exit For
                        End If
                        
                    Next Y
                
                Next x
            Else
                x = x
                'check to see if this is a recombination event in the ancetsral sequence
                GoOnX = 1
                For A = 0 To PermNextno
                    If NodeFind(PermSelectNode(0), A) = 1 And Daught(Z, A) = 0 Then
                        GoOnX = 0
                        Exit For
                    End If
                    
                Next A
                If GoOnX = 1 Then
                    'add a partition if this recombination event is in the ancestral sequence
                    PartNo = PartNo + 1
                    If PartNo + 2 > UBound(Parts, 2) Then
                        ReDim Preserve Parts(1, PartNo + 10)
                    End If
                    If BE < EN Then
                        For A = BE To EN
                            SPart(A) = PartNo
                        Next A
                    Else
                        For A = BE To Len(StrainSeq(0))
                            SPart(A) = PartNo
                        Next A
                        For A = 1 To EN
                            SPart(A) = PartNo
                        Next A
                    End If
                End If
            End If
        End If
    Next Z
    If PartNo > 0 Then
        Dim tPart As Long
        tPart = 0
        For A = 1 To Len(StrainSeq(0)) - 1
            If SPart(A) <> SPart(A - 1) Or A = 1 Then
                tPart = tPart + 1
                Parts(0, tPart) = A
                For b = A + 1 To Len(StrainSeq(0)) - 1
                    If SPart(b) <> SPart(b + 1) Or b = Len(StrainSeq(0)) - 1 Then
                        If b = Len(StrainSeq(0)) - 1 Then b = b + 1
                        Parts(1, tPart) = b
                        
                        A = b
                        Exit For
                    End If
                Next b
            End If
        Next A
         For x = 1 To UBound(Parts, 2)
            If Parts(1, x) = 0 And Parts(0, x) = 0 Then
                PartNo = x - 1
                Exit For
            End If
        Next x
    End If
    'XX = Parts(2, 1)
    If RF = 0 Then
        For x = 0 To PermNextno
            TempSeq(x) = StrainSeq(x)
            
            For Y = 1 To Len(StrainSeq(0))
                
                If SeqSave(Y, x) <> PermSeqNum(Y, x) Then
                    Mid$(TempSeq(x), Y, 1) = "-"
                End If
            Next Y
        Next x
    ElseIf RF = 1 Then
        For x = 0 To PermNextno
            TempSeq(x) = StrainSeq(x)
            
            For Y = 1 To Len(StrainSeq(0))
                
                If SeqSave(Y, x) <> PermSeqNum(Y, x) Then
                    Mid$(TempSeq(x), Y, 1) = "?"
                End If
            Next Y
        Next x
    Else
        For x = 0 To PermNextno
            TempSeq(x) = StrainSeq(x)
            
            For Y = 1 To Len(StrainSeq(0))
                
                If SeqSave(Y, x) <> PermSeqNum(Y, x) Then
                    If PermSeqNum(Y, x) <> 46 Then
                        Mid$(TempSeq(x), Y, 1) = "N"
                    Else
                        Mid$(TempSeq(x), Y, 1) = "?"
                    End If
                End If
            Next Y
        Next x
    End If
    
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    End If
End Sub
Public Sub MakeAncestralState(ARQ, Recfree, NSeq() As Long, SeqArray() As Long, SelectNodeX As Long, OL, BannedList() As Byte)

Dim oDir As String, TempSeq() As String, TempSeqName() As String, CNum As Long, TS As String, TS2 As String
Dim BootName As String, Boots() As String



If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0
ReDim Boots(NextNo), TempSeq(NextNo), TempSeqName(NextNo)
ReDim Parts(1, 10)
Dim FullConstrain As Byte

FullConstrain = 0

If x = 12345 Then
    Dim GapSeq() As String
    ReDim GapSeq(NextNo)
    
    'ENCODE GAPS AS g'S AND EVERYTHING ELSE AS A's
    For x = 0 To NextNo
        For Y = 1 To Len(StrainSeq(0))
            If SeqNum(Y, x) = 46 Then
                GapSeq(x) = GapSeq(x) + "G"
            Else
                GapSeq(x) = GapSeq(x) + "A"
            End If
        Next Y
    Next x
End If



'Put sequences that will be used to infer ancestral sequences into tempseq

Dim SPart() As Long
If Recfree = 1 Then 'take out recombinant tracts
    
    PartNo = 0
    Call MakeRecFreeSeqs(PartNo, Parts(), ARQ, 1, TempSeq(), BannedList(), SPart())
    'PartNo = PartNo + 1
Else
    For x = 0 To NextNo
        TempSeq(x) = StrainSeq(x)
    Next x
End If





Dim FasterFlag As Byte, CounterX As Long, TempSeq2() As String
ReDim ReMapF(Len(StrainSeq(0))), ReMapR(Len(StrainSeq(0))) ', PAncPVals(5, Len(StrainSeq(0)))
'get rid of absolutely conserved sites
FasterFlag = 1
AbortFlag = 0
ReDim AncPValsBayes(5, Len(StrainSeq(0)))
If FasterFlag = 1 Then
    ReDim TempSeq2(NextNo)
    'For X = 0 To Nextno
    '    TempSeq2(X) = String(Len(StrainSeq(0)), " ")
    'Next X
    'ReDim TempSeq(Nextno)
    CounterX = 0
    For x = 1 To Len(StrainSeq(0))
        ReMapF(x) = CounterX
        If x = x Then 'this way looks at all varable sites
            If Identical(x) = 0 Then
            
                CounterX = CounterX + 1
                ReMapF(x) = CounterX
                ReMapR(CounterX) = x
                For Y = 0 To NextNo
                    TempSeq2(Y) = TempSeq2(Y) + Mid$(TempSeq(Y), x, 1)
                Next Y
            
            Else
                AncPValsBayes(0, x) = 1
                If SeqNum(x, SeqArray(SelectNodeX, 0)) = 66 Then
                    AncPValsBayes(1, x) = 1
                    AncPValsBayes(5, x) = 0
                ElseIf SeqNum(x, SeqArray(SelectNodeX, 0)) = 68 Then
                    AncPValsBayes(2, x) = 1
                    AncPValsBayes(5, x) = 1
                ElseIf SeqNum(x, SeqArray(SelectNodeX, 0)) = 72 Then
                    AncPValsBayes(3, x) = 1
                    AncPValsBayes(5, x) = 2
                ElseIf SeqNum(x, SeqArray(SelectNodeX, 0)) = 85 Then
                    AncPValsBayes(4, x) = 1
                    AncPValsBayes(5, x) = 3
                Else
                    AncPValsBayes(5, x) = 4
                    
                End If
                For Y = 0 To 5
                    AncPVals(Y, x) = AncPValsBayes(Y, x)
                Next Y
            End If
                
            
        Else 'this way only looks at variable sites between sequences in the selected node
            For Y = 1 To NSeq(SelectNodeX)
            
                If SeqNum(x, SeqArray(SelectNodeX, Y)) <> SeqNum(x, SeqArray(SelectNodeX, 0)) Then
                    CounterX = CounterX + 1
                    ReMapF(x) = CounterX
                    ReMapR(CounterX) = x
                    Exit For
                End If
                
            Next Y
        
            If Y <= NSeq(SelectNodeX) Then
                For Y = 0 To NextNo
                    TempSeq2(Y) = TempSeq2(Y) + Mid$(TempSeq(Y), x, 1)
                    
                Next Y
            Else
                AncPValsBayes(0, x) = 1
                If SeqNum(x, SeqArray(SelectNodeX, 0)) = 66 Then
                    AncPValsBayes(1, x) = 1
                    AncPValsBayes(5, x) = 0
                ElseIf SeqNum(x, SeqArray(SelectNodeX, 0)) = 68 Then
                    AncPValsBayes(2, x) = 1
                    AncPValsBayes(5, x) = 1
                ElseIf SeqNum(x, SeqArray(SelectNodeX, 0)) = 72 Then
                    AncPValsBayes(3, x) = 1
                    AncPValsBayes(5, x) = 2
                ElseIf SeqNum(x, SeqArray(SelectNodeX, 0)) = 85 Then
                    AncPValsBayes(4, x) = 1
                    AncPValsBayes(5, x) = 3
                Else
                    AncPValsBayes(5, x) = 4
                    
                End If
                For Y = 0 To 5
                    AncPVals(Y, x) = AncPValsBayes(Y, x)
                Next Y
            End If
            x = x
        End If
    Next x
    For x = 0 To NextNo
        TempSeq(x) = TempSeq2(x)
    Next x
    
Else
    For x = 0 To Len(StrainSeq(0))
        ReMapF(x) = x
        ReMapR(x) = x
        
    Next x
End If

'write mrbayes options file
        Open "bopt" For Output As #1
        
        Print #1, "execute infile;"
        
        Print #1, "quit;"
        Close #1
        'Do Mr Bayes sequence file
        If Len(TempSeq(0)) > 32000 Then

            For x = 0 To NextNo
                TempSeq(x) = Left$(TempSeq(x), 32000)
            Next 'X

        End If
        
        LTmpSeq = Len(TempSeq(0))
        
        'write nexus data file
        Open "basein" For Output As #1
        
        Print #1, "#NEXUS"
        Print #1, "begin data;"
        Print #1, "dimensions ntax=" & Trim(Str(NextNo + 1)) & " nchar=" & Trim(Str(Len(TempSeq(0)))) & ";"
        'datatype=mixed(Standard:1-166,DNA:167-3246)
        If PartNo > 1 Then
            Dim TSX As String
            TSX = "format datatype=mixed("
            For x = 1 To PartNo
                TSX = TSX + "DNA:" + Trim(Str(ReMapF(Parts(0, x)) + 1)) + "-" + Trim(Str(ReMapF(Parts(1, x)))) + ","
            Next
            TSX = Left(TSX, Len(TSX) - 1) + ")"
            TSX = TSX + " interleave=no gap=- missing=?;"
            Print #1, TSX
        Else
            Print #1, "format datatype=dna interleave=no gap=- missing=?;"
        End If
        Print #1, "matrix"
        If NextNo < 100 Then
            NLen = 2
        ElseIf NextNo < 1000 Then
            NLen = 3
        ElseIf NextNo < 10000 Then
             NLen = 4
        ElseIf NextNo < 100000 Then
             NLen = 5
        ElseIf NextNo < 1000000 Then
             NLen = 6
        End If
        For x = 0 To NextNo
            
            TName = Trim$(CStr(x))
            TName = String(NLen - Len(TName), "0") & TName
            TName = "S" & TName
            BootName = TName
            BootName = BootName + String$(10 - (Len(BootName)), " ")
            TString = TempSeq(x)
            Boots(x) = BootName + TString
            Print #1, Boots(x)
        Next 'X
        Print #1, ";"
        Print #1, "end;"
        'set up starting tree blocks
        
        
        If PartNo > 1 Then
            
'            For x = 1 To PartNo - 1
'                Print #1, "tree mystarttree" + Trim(Str(x)) + " = " + " " + MLTreeSet(x)
'            Next x
        Else
            Print #1, "begin trees;"
            Print #1, "tree mystarttree1 = " + MLTreeSet(1)
            Print #1, "end;"
        End If
        
        
'        begin mrbayes;
'           startvals
'              tau = mystarttree
'              V = mystarttree
'           ;
'        end;
        
        
        
        'Set up the initial infile
        Print #1, "begin mrbayes;"
        If PartNo > 1 Then
            For x = 1 To PartNo
                TSX = "charset " + "A" + Trim(Str(x)) + " = " + Trim(Str(ReMapF(Parts(0, x)) + 1)) + "-" + Trim(Str(ReMapF(Parts(1, x)))) + ";"
                Print #1, TSX
            Next x
            TSX = "partition favored = " + Trim(Str(PartNo)) + ": "
            For x = 1 To PartNo
                TSX = TSX + "A" + Trim(Str(x)) + ", "
            Next x
            TSX = Left(TSX, Len(TSX) - 2)
            TSX = TSX + ";"
            Print #1, TSX
            Print #1, "set partition = favored;"
            Print #1, "unlink topology=(all) brlens=(all);"
            'check to see if some tomologies must be relinked
            For x = 1 To PartNo - 1
                x = x
                For Y = x + 1 To PartNo
                    If SPart(Parts(1, x)) = SPart(Parts(1, Y)) Then
                        Print #1, "link topology = (" + Trim(Str(x)) + ", " + Trim(Str(Y)) + ");"
                        Print #1, "link brlens = (" + Trim(Str(x)) + ", " + Trim(Str(Y)) + ");"
                    End If
                    
                Next Y
            Next x
            
            
            'partition favored = 5: morphology, COI, EF1a, LWRh, 28S;
        End If
        Print #1, "set autoclose=yes nowarn=yes;"
        'need to set up code to change the model
        TS = "lset nst="
        If TBModel > 2 Then TBModel = 0
        If TBModel = 0 Then
            TS = TS & "1"
        ElseIf TBModel = 1 Then
            TS = TS & "2"
        ElseIf TBModel = 2 Then
            TS = TS & "6"
        End If
        TS = TS + " rates="
        If TBGamma = 0 Then
             TS = TS + "equal"
        ElseIf TBGamma = 1 Then
            TS = TS + "gamma"
        ElseIf TBGamma = 2 Then
            TS = TS + "adgamma"
        End If
        If TBGamma > 0 Then
            TS = TS + " ngammacat=" + Trim(Str(CLng(TBGammaCats)))
        End If
        
        TS = TS + ";"
        Print #1, TS
        
        
        
        'Set up Node constraints - can be either fully constrained (1) or only constrained on the node where
        'an ancestral sequence needs to be determined (0).
        
        If FullConstrain = 1 Then 'this doesn't work for some reason
            TS2 = ""
            CNum = 0
            For x = 0 To NextNo
                If NSeq(x) > 0 Then
                    CNum = CNum + 1
                    TS = "constraint "
                    TS = TS + "C" + Trim(Str(x)) + " -1 = "
                    If CNum > 1 Then
                        TS2 = TS2 + ","
                    End If
                    TS2 = TS2 + "C" + Trim(Str(x))
                    For Y = 0 To NSeq(x)
                        TS = TS + Trim(Str(SeqArray(x, Y) + 1)) + " "
                    Next Y
                    TS = TS + ";"
                    Print #1, TS
                End If
            Next x
            Print #1, "prset topologypr = constraints(" + TS2 + ");"
        Else
            TS2 = ""
            TS = "constraint "
            TS = TS + "C" + Trim(Str(SelectNodeX)) + " 100 = "
            
            If CNum > 1 Then
                TS2 = TS2 + ","
            End If
            TS2 = TS2 + "C" + Trim(Str(SelectNodeX))
            For Y = 0 To NSeq(SelectNodeX)
                TS = TS + Trim(Str(SeqArray(SelectNodeX, Y) + 1)) + " "
            Next Y
            TS = TS + ";"
            Print #1, TS
            Print #1, "prset topologypr = constraints(" + TS2 + ");"
        End If
        Print #1, "outgroup " + Trim(Str(OL + 1)) + ";"
        Print #1, "report ancstates = yes;"
        
        
        'clock models:
        'Non-Clock (default):
        '           prset brlenspr=unconstrained:exponential(1) if you want to change from the deafult prior = exp(10)
        'Birth death:
        '           prset speciationpr = X
        '           prset extinctionpr = X
        '           prset sampleprob = X
        
        'Coalescent Model:
        '           prest thetapr = X (prior on thrta)
        '           lset ploidy = Y (1 or 2)
        'Simple clock model:
        '           prset brlenspr=clock:uniform
        '           prset treeheightpr = X (prior on total tree height default=1)
        
        'need to set up code to change the MCMC settings
        Dim TDx As Double
        
        TDx = TBNGens / TBSampFreq
        TDx = (TDx * 5 * 10 * Len(StrainSeq(0)))
        If TDx > 1000000000 Then
            TBSampFreq = TBSampFreq / (1000000000 / TDx)
            
        End If
        If TBSampFreq > 500 Then
            TDx = CLng(TBSampFreq / 500)
            TBNGens = CLng(TBNGens / TDx)
            TBSampFreq = 500
        End If
        
        
        
        
        
        Close #1
        
        FileCopy "basein", "infile"
       
        oTBNGens = TBNGens
        Open "infile" For Append As #1
        Dim StartGens As Long, IncGens As Long
        StartGens = 100000
        IncGens = 50000
        TBNGens = StartGens
        TS = "mcmcp ngen=" + Trim(Str(StartGens)) '101000" 'ngen=" & Trim(Str(TBNGens))
        TS = TS + " samplefreq=500" '+ Trim(Str(TBSampFreq))
        TS = TS + " nchains=1" ' + Trim(Str(TBNChains))
        TS = TS + " temp=" + Trim(Str(TBTemp))
        TS = TS + " swapfreq=" + Trim(Str(TBSwapFreq))
        TS = TS + " nswaps=" + Trim(Str(TBSwapNum))
        
        'Print #1, "mcmc ngen=10000 samplefreq=10 savebrlens=yes file=outfile;"
        'TS = TS + " stoprule = yes stopval = 0.001 savebrlens = yes file = outfile;"
        TS = TS + " savebrlens = yes file = outfile"
        If PartNo < 2 Then
            TS = TS + " starttree=current;"
        Else
            TS = TS + " starttree=random;"
        End If
        Print #1, TS
        'get a tree output file - its in fucking nex format!
        bi = CLng((TBNGens * 0.25) / TBSampFreq)  'if using samplefreq in normal tree draw
        'bi = ((TBNGens * 0.25) / 10)
        'Print #1, "sumt relburnin = No" '+ Trim(Str(bi)) + ";"
        
        
        
        If PartNo < 2 Then ' And x = 123456789 Then ' i need to find out a way to link tree topologies to different partitions
            
            Print #1, "startvals tau=mystarttree1;" ' V=mystarttree1;"

        End If
        Print #1, "mcmc;"
        Print #1, "sump;"
        Print #1, "end;"
        
        Close #1
        
        
        
        
          'On Error GoTo MRBayesError 'mr Bayes still running
          If DebuggingFlag < 2 Then On Error Resume Next
            If Dir(App.Path + "\boptout") <> "" Then
                KillFile "boptout"
                If Dir(App.Path + "\boptout") <> "" Then
                    GoTo MRBayesError
                End If
            End If
          On Error GoTo 0
          
            Randomize
            
            
            FLen = 0
            If DebuggingFlag < 2 Then On Error Resume Next
            'XX = (App.Path + "\dnadist.bat")
            If Dir(App.Path + "\dnadist.bat") <> "" Then
                KillFile "dnadist.bat"
                
            End If
            
            
            
            
            If Dir("dnadist.bat") <> "" Then '> 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
                
                FString = "dnadist" & Trim(Str(Rnd)) & ".bat"
            Else
                FString = "dnadist.bat"
            End If
            Rnd (-BSRndNumSeed)
          'On Error GoTo 0
          Open FString For Output As #1
          'write commandline
          
          Print #1, "mrbayes.exe <bopt >boptout"
          'Print #1, "del treefile"
          'Print #1, "rename outfile.con treefile "
          'Print #1, "del " + FString
          Close #1
          On Error GoTo 0
        BatIndex = 26
        'Do
        'XX = CurDir
        SS = Abs(GetTickCount)
        
        ShellAndClose FString, 0
        EE = Abs(GetTickCount)
        TT = EE - SS
        x = x
        '650.109 sampling every 100
        '184.031 sampling every 500
        If x = 123456789 Then
        
ResumeFromCheckpoint:
            Kill "infile"
            FileCopy "basein", "infile"
        
            Open "infile" For Append As #1
            StartGens = StartGens + IncGens
            TBNGens = StartGens
        'IncGens = 10000
            TS = "mcmcp ngen=" + Trim(Str(StartGens))
            'TS = "mcmcp ngen=101000" 'ngen=" & Trim(Str(TBNGens))
            TS = TS + " samplefreq=500" ' + Trim(Str(TBSampFreq))
            TS = TS + " nchains=1" ' + Trim(Str(TBNChains))
            TS = TS + " temp=" + Trim(Str(TBTemp))
            TS = TS + " swapfreq=" + Trim(Str(TBSwapFreq))
            TS = TS + " nswaps=" + Trim(Str(TBSwapNum))
            
            'Print #1, "mcmc ngen=10000 samplefreq=10 savebrlens=yes file=outfile;"
            'TS = TS + " stoprule = yes stopval = 0.001 savebrlens = yes file = outfile;"
            TS = TS + " savebrlens = yes file = outfile"
            If PartNo < 2 Then
                TS = TS + " starttree=current;"
            Else
                TS = TS + " starttree=random;"
            End If
            Print #1, TS
            'get a tree output file - its in fucking nex format!
            bi = CLng((TBNGens * 0.25) / TBSampFreq)  'if using samplefreq in normal tree draw
            'bi = ((TBNGens * 0.25) / 10)
            'Print #1, "sumt relburnin = No" '+ Trim(Str(bi)) + ";"
            
            
            
            If PartNo < 2 Then ' And x = 123456789 Then ' i need to find out a way to link tree topologies to different partitions
                
                Print #1, "startvals tau=mystarttree1;" ' V=mystarttree1;"
    
            End If
            
            Print #1, "mcmc append=yes;"
            Print #1, "sump;"
            Print #1, "end;"
            Close #1
             BatIndex = 26
            ShellAndClose "dnadist.bat", 0
            x = x
        End If
        
        'older mrbayes
        '1565.063 with startvals=usertree tau): last 5 SDs 0.005,0.001,0.006,0.009,0.009
        '1540.421 second run with with startvals=usertree tau): last 5 SDs  0.017,0.018, 0.019, 0.018, 0.009
        '1692.203 with startvals=usertree tau and V:0.012, 0.016,0.014,0.06,0.06
        '1533.219 (with no input tree): last 5 SDs  0.019,0.012, 0.014, 0.011, 0.009
        
        'newer mrbayes
        '1007.281 with startvals=usertree tau and V:0.041, 0.031,0.025,0.22,0.18
        '999.422 :0.021, 0.015, 0.010, 0.010, 0.011
        '983.203 no startvals: 0.005, 0.002, 0.001, 0.003, 0.007
        '994.344 20, 15, 8, 12, 14
        
        'Only looking at variable sites
        '127.203 no startvals 1,2,2,4,4
        '126.782 4, 2, 1, 2, 2
        '129.375 with startvals=usertree tau and V: 7, 9, 9, 8, 7
        '127.796 5, 5, 6, 3, 2
        
        
        'using identical
        'no startvals 35,24,22, 18, 15
        '460.859 14 7 9 3 6
        '489.625 with startvals=usertree tau and V: 21 20 20 14 18
        '467.328 18 14 10 10 7
        '467.875  with startvals=usertree tau 7 14 6 5 10
        '413.953 15 11 10 10 14
        '421.125 2 4 1 4 6
        '388.922 11 15 12 11 11
        '405.657 using "starttree + startvals: 13 14 14 11 11
        '400.750 15 12 8 11 13
        
        '397.969 Random starttree:12 8 8 7 9
        'Exit Sub
        
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        'Need to update the probs and load ess data here:
        'get this from the file infile.pstat - the psoterior probs are the final values I need to use.
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        Open "outfile.pstat" For Input As #1
            Do While Not EOF(1)
                Input #1, Temp
                If Left(Temp, 4) = "p(A)" Then Exit Do
                x = x
            Loop
            x = x
            x = 1
            XX = CurDir
            ReDim AncSeqESS(3, Len(StrainSeq(0)))
            Do While Not EOF(1) And x <= Len(StrainSeq(0))
                Pos = InStr(1, Temp, "}", vbBinaryCompare) + 1
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                'XX = Mid(Temp, Pos + 1, Pos2 - Pos - 1)
                Y = ReMapR(x)
                
                AncPValsBayes(1, Y) = CDbl(val(Mid(Temp, Pos + 1, Pos2 - Pos - 1)))
                
                Pos = InStr(Pos2 + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                'XX = Mid$(Temp, Pos + 1, Pos2 - Pos - 1)
                AncSeqESS(0, Y) = CLng(Mid$(Temp, Pos + 1, Pos2 - Pos - 1))

                
                
                Input #1, Temp
                Pos = InStr(1, Temp, "}", vbBinaryCompare) + 1
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                AncPValsBayes(2, Y) = CDbl(val(Mid(Temp, Pos + 1, Pos2 - Pos - 1)))
                Pos = InStr(Pos2 + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                'XX = Mid$(Temp, Pos + 1, Pos2 - Pos - 1)
                AncSeqESS(1, Y) = CLng(Mid$(Temp, Pos + 1, Pos2 - Pos - 1))

                Input #1, Temp
                Pos = InStr(1, Temp, "}", vbBinaryCompare) + 1
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                AncPValsBayes(3, Y) = CDbl(val(Mid(Temp, Pos + 1, Pos2 - Pos - 1)))
                Pos = InStr(Pos2 + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                'XX = Mid$(Temp, Pos + 1, Pos2 - Pos - 1)
                AncSeqESS(2, Y) = CLng(Mid$(Temp, Pos + 1, Pos2 - Pos - 1))


                Input #1, Temp
                Pos = InStr(1, Temp, "}", vbBinaryCompare) + 1
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                AncPValsBayes(4, Y) = CDbl(val(Mid(Temp, Pos + 1, Pos2 - Pos - 1)))
                Pos = InStr(Pos2 + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                Pos2 = InStr(Pos + 2, Temp, Chr(9), vbBinaryCompare)
                'XX = Mid$(Temp, Pos + 1, Pos2 - Pos - 1)
                AncSeqESS(3, Y) = CLng(Mid$(Temp, Pos + 1, Pos2 - Pos - 1))
                If AncPValsBayes(1, Y) >= AncPValsBayes(2, Y) And AncPValsBayes(1, Y) >= AncPValsBayes(3, Y) And AncPValsBayes(1, Y) >= AncPValsBayes(4, Y) Then
                    AncPValsBayes(0, Y) = AncPValsBayes(1, Y)
                    AncPValsBayes(5, Y) = 0
                ElseIf AncPValsBayes(2, Y) >= AncPValsBayes(1, Y) And AncPValsBayes(2, Y) >= AncPValsBayes(3, Y) And AncPValsBayes(2, Y) >= AncPValsBayes(4, Y) Then
                    AncPValsBayes(0, Y) = AncPValsBayes(2, Y)
                    AncPValsBayes(5, Y) = 1
                ElseIf AncPValsBayes(3, Y) >= AncPValsBayes(1, Y) And AncPValsBayes(3, Y) >= AncPValsBayes(2, Y) And AncPValsBayes(3, Y) >= AncPValsBayes(4, Y) Then
                    AncPValsBayes(0, Y) = AncPValsBayes(3, Y)
                    AncPValsBayes(5, Y) = 2
                ElseIf AncPValsBayes(4, Y) >= AncPValsBayes(1, Y) And AncPValsBayes(4, Y) >= AncPValsBayes(2, Y) And AncPValsBayes(4, Y) >= AncPValsBayes(3, Y) Then
                    AncPValsBayes(0, Y) = AncPValsBayes(4, Y)
                    AncPValsBayes(5, Y) = 3
                End If
                x = x + 1
                If x >= Len(StrainSeq(0)) Then Exit Do
                On Error Resume Next
                Input #1, Temp
                On Error GoTo 0
            Loop
            
            
        Close #1
        
        SumAncSeq = String(Len(StrainSeq(0)), " ")
        For x = 1 To Len(StrainSeq(0))
            For Y = 0 To 5
                AncPVals(Y, x) = AncPValsBayes(Y, x)
            Next Y
            If AncPValsBayes(0, x) > 0.4 Then
                If AncPValsBayes(5, x) = 0 Then
                    Mid$(SumAncSeq, x, 1) = "A"
                ElseIf AncPValsBayes(5, x) = 1 Then
                    Mid$(SumAncSeq, x, 1) = "C"
                ElseIf AncPValsBayes(5, x) = 2 Then
                    Mid$(SumAncSeq, x, 1) = "G"
                ElseIf AncPValsBayes(5, x) = 3 Then
                    Mid$(SumAncSeq, x, 1) = "T"
                Else
                    Mid$(SumAncSeq, x, 1) = "-"
                End If
            Else
                Mid$(SumAncSeq, x, 1) = "?"
            End If
        Next x
        
        If Len(Trim(MLAncSeq)) > 0 Then
            For x = 1 To Len(SumAncSeq)
                If Mid$(MLAncSeq, x, 1) = "-" Then
                    Mid$(SumAncSeq, x, 1) = "-"
                End If
            
            Next x
        End If
        Dim SitesRemain As Long
        SitesRemain = 0
        For x = 1 To Len(StrainSeq(0))
            If Mid(SumAncSeq, x, 1) <> "-" Then
                For Y = 0 To 3
                    If AncSeqESS(Y, x) < 100 And AncSeqESS(Y, x) > 0 And AncPValsBayes(Y + 1, x) > 0.05 Then
                        SitesRemain = SitesRemain + 1
                        Exit For
                    End If
                
                Next Y
            End If
        Next x
        
        If SitesRemain > 0 Then
            If SitesRemain = 1 Then
                Form1.SSPanel1.Caption = "Still one site with ESS < 100 so adding " + Trim(Str(IncGens)) + " generations"
            Else
                Form1.SSPanel1.Caption = "Still " + Trim(Str(SitesRemain)) + " sites with ESS < 100 so adding " + Trim(Str(IncGens)) + " generations"
            End If
'            Response = MsgBox("There are still " + Trim(Str(SitesRemain)) + " sites where nucleotide state probability estimates have not converged (i.e. they have associated ESS values <100). Would you like to continue running MrBayes for a little longer?", vbYesNo)
'            If Response = 6 Then
                GoTo ResumeFromCheckpoint
'            End If
        Else
            x = x
        End If
        
        TBNGens = oTBNGens
        If DebuggingFlag < 2 Then On Error Resume Next
        If Dir(App.Path + "\treefile") <> "" Then
            KillFile "treefile"
        End If
        
        On Error GoTo 0
        'Loop
        If AbortFlag = 1 Then
            AbortFlag = 0
            Exit Sub
        End If
        x = x
        If DebuggingFlag < 2 Then On Error Resume Next

        ChDir oDir
        ChDrive oDir
        On Error GoTo 0
   Exit Sub
MRBayesError:
 
     MsgBox ("I have detected a conflict between multiple instances of MrBayes running on your computer.  You can possibly resolve this problem by pressing the 'ctrl', 'alt', and 'del' buttons at the same time, in the Task Manager program that pops up selecting the 'task list' option, in the 'processes' tab selecting 'MrBayes' from the list, and pressing the 'end process' button. When you have done this re-select the node at which you would like an ancestral sequence inferred.")
     Exit Sub
     
End Sub
Public Sub MakeAncestralStateML(ARQ, Recfree, NSeq() As Long, SeqArray() As Long, SelectNodeX As Long, OL, BannedList() As Byte, NodeFind() As Byte)




Dim oDir As String, TempSeq() As String, TempSeqName() As String, CNum As Long, TS As String, TS2 As String, NLen As Long
Dim BootName As String, Boots() As String, OutString As String, XDiffPos() As Long



'this is used for naming sequences in the raxml infiles
If PermNextno < 100 Then
    NLen = 2
ElseIf PermNextno < 1000 Then
    NLen = 3
ElseIf PermNextno < 10000 Then
     NLen = 4
ElseIf PermNextno < 100000 Then
     NLen = 5
ElseIf PermNextno < 1000000 Then
     NLen = 6
End If




'make a tree topology constraint file (based on the tree that the node was selected from)
TS = "("
For x = 0 To PermNextno
    If NodeFind(SelectNode(0), x) = 1 Then
        TS2 = Trim(Str(x))
        TS2 = String(NLen - Len(TS2), "0") & TS2
        TS2 = "S" & TS2
        TS = TS + TS2 + ","
    End If
Next x

TS = Left(TS, Len(TS) - 1)
TS = TS + "),"
For x = 0 To PermNextno
    If NodeFind(SelectNode(0), x) = 0 Then
        TS2 = Trim(Str(x))
        TS2 = String(NLen - Len(TS2), "0") & TS2
        TS2 = "S" & TS2
        TS = TS + TS2 + ","
    End If
Next x
TS = Left(TS, Len(TS) - 1)

TS = "(" + TS + ");'"
FNum = FreeFile
Open "tconstraint" For Output As #FNum
Print #FNum, TS
Close #FNum


If DebuggingFlag < 2 Then On Error Resume Next




oDir = CurDir
ChDir App.Path
ChDrive App.Path











FNum = FreeFile
Open "dnadist.bat" For Output As #FNum ' this is the .bat file for inferring the ancestral sequences
'Print #FNum, "del RAxML_info.treefile"
'Print #FNum, "del RAxML_parsimonyTree.treefile"
'Print #FNum, "del RAxML_log.treefile"
'Print #FNum, "del RAxML_result.treefile"
'Print #FNum, "del RAxML_bestTree.treefile"
'Print #FNum, "del RAxML_bootstrap.treefile"
'Print #FNum, "del RAxML_perSiteLLs.treefile"
'Print #FNum, "del RAxML_perSiteLLs.treefile"
'Print #FNum, "del RAxML_info.Rooted"
'Print #FNum, "del RAxML_parsimonyTree.Rooted"
'Print #FNum, "del RAxML_log.Rooted"
'Print #FNum, "del RAxML_result.Rooted"
'Print #FNum, "del RAxML_bestTree.Rooted"
'Print #FNum, "del RAxML_bootstrap.Rooted"
'Print #FNum, "del RAxML_perSiteLLs.Rooted"
'Print #FNum, "del RAxML_perSiteLLs.Rooted"
Print #FNum, "raxmlHPC -s testData -p 123 -n treefile -g tconstraint -m GTRCAT" 'makes an unrooted tree
'Print #FNum, "raxmlHPC f I m GTRCAT t RAxML_bestTree.treefile n Rooted" 'Roots the tree
Print #FNum, "raxmlHPC -f I -m GTRCAT -t RAxML_bestTree.treefile -n Rooted"
Close #FNum




Open "dnadist2.bat" For Output As #FNum ' this is the .bat file for inferring  ancestral states from the rroted version of the inferred tree
'Print #FNum, "del RAxML_info.Ancestral"
'Print #FNum, "del RAxML_parsimonyTree.Ancestral"
'Print #FNum, "del RAxML_log.Ancestral"
'Print #FNum, "del RAxML_result.Ancestral"
'Print #FNum, "del RAxML_bestTree.Ancestral"
'Print #FNum, "del RAxML_bootstrap.Ancestral"
'Print #FNum, "del RAxML_perSiteLLs.Ancestral"
'Print #FNum, "del RAxML_perSiteLLs.Ancestral"
Print #FNum, "raxmlHPC -f A -t RAxML_rootedTree.Rooted -s testData -m GTRGAMMA -n Ancestral"
Close #FNum





On Error GoTo 0
ReDim Boots(PermNextno), TempSeq(PermNextno), TempSeqName(PermNextno)
ReDim Parts(1, 10)




'raxmlHPC f A t testTree s testData m GTRGAMMA n TEST




'Make testdata
'Put sequences that will be used to infer ancestral sequences into tempseq




Dim SPart() As Long
If Recfree = 1 Then 'take out recombinant tracts
    
    PartNo = 0
    Call MakeRecFreeSeqs(PartNo, Parts(), ARQ, 0, TempSeq(), BannedList(), SPart())
    PartNo = PartNo + 1
'Exit Sub


Else
    For x = 0 To NextNo
        TempSeq(x) = StrainSeq(x)
    Next x
End If


'XX = SelectNode

If PartNo < 2 Then
    ReDim SPart(Len(StrainSeq(0)))
    For x = 1 To Len(StrainSeq(0))
        SPart(x) = 0
    Next x
    PartNo = 2
End If




Dim SLen As Long
Dim SeqSet() As String, NumAbove As Long, AncestralSeq As String, TName() As String, AncestralProbs() As Single




ReDim SeqSet(NextNo)




SLen = Len(StrainSeq(0))
AncestralSeq = String(SLen, " ")
ReDim TName(PermNextno)
ReDim AncestralProbs(3, SLen)
Dim Pos1 As Long, Pos2 As Long, Pos3 As Long, Pos4 As Long
'Close #FF
If PartNo > 0 Then
    Dim CurPart As Long, FF As Long, Header As String, TotL As Long
    Dim outSeq As String, CharPos As Long
    ReDim MLTreeSet(PartNo) 'need these as strating trees for mrbayes
    For CurPart = 1 To PartNo - 1
        
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "RAxML_info.treefile"
        KillFile "RAxML_parsimonyTree.treefile"
        KillFile "RAxML_log.treefile"
        KillFile "RAxML_result.treefile"
        KillFile "RAxML_bestTree.treefile"
        'killfile "RAxML_bootstrap.treefile"
        'killfile "RAxML_perSiteLLs.treefile"
        'killfile "RAxML_perSiteLLs.treefile"
        KillFile "RAxML_info.Rooted"
        'killfile "RAxML_parsimonyTree.Rooted"
        'killfile "RAxML_log.Rooted"
        'killfile "RAxML_result.Rooted"
        'killfile "RAxML_bestTree.Rooted"
        'killfile "RAxML_bootstrap.Rooted"
        'killfile "RAxML_perSiteLLs.Rooted"
        'killfile "RAxML_perSiteLLs.Rooted"
        KillFile "RAxML_rootedTree.Rooted"
        KillFile "RAxML_info.Ancestral"
        'killfile "RAxML_parsimonyTree.Ancestral"
        'killfile "RAxML_log.Ancestral"
        'killfile "RAxML_result.Ancestral"
        'killfile "RAxML_bestTree.Ancestral"
        'killfile "RAxML_bootstrap.Ancestral"
        'killfile "RAxML_perSiteLLs.Ancestral"
        'killfile "RAxML_perSiteLLs.Ancestral"
        KillFile "RAxML_marginalAncestralProbabilities.Ancestral"
        KillFile "RAxML_marginalAncestralStates.Ancestral"
        KillFile "RAxML_nodeLabelledRootedTree.Ancestral"
        On Error GoTo 0
        
        FF = FreeFile
        Open "testData" For Output As #FF
        NumAbove = 0
        
        ReDim XDiffPos(SLen)
        GoOnX = 0
        For x = 0 To PermNextno
            outSeq = String(SLen, " ")
            CharPos = 0
            'XX = SPart(1790)
            If x = 0 Then
                For Y = 1 To SLen
                    If SPart(Y) = CurPart - 1 Then
                        CharPos = CharPos + 1
                        Mid$(outSeq, CharPos, 1) = Mid$(TempSeq(x), Y, 1)
                        XDiffPos(CharPos) = Y
                    End If
                Next Y
            Else
                For Y = 1 To SLen
                    If SPart(Y) = CurPart - 1 Then
                        CharPos = CharPos + 1
                        Mid$(outSeq, CharPos, 1) = Mid$(TempSeq(x), Y, 1)
                    End If
                Next Y
            End If
            
            
            
            outSeq = Trim(outSeq)
            Pos1 = 0
            Pos2 = 0
            Pos3 = 0
            Pos4 = 0
            If Len(outSeq) > 0 Then
                Pos1 = InStr(1, outSeq, "A", vbBinaryCompare)
                Pos2 = InStr(1, outSeq, "C", vbBinaryCompare)
                Pos3 = InStr(1, outSeq, "G", vbBinaryCompare)
                Pos4 = InStr(1, outSeq, "T", vbBinaryCompare)
                
            End If
            GoOn = 0
            If Pos1 + Pos2 + Pos3 + Pos4 = 0 Then 'the sequence is empty
                If x = x Then
                
                Else
                    GoOn = 1
                    outSeq = String(SLen, " ")
                    CharPos = 0
                    
                    For Y = 1 To SLen ' grab the missing characters from the original sequence file.
                        If SPart(Y) = CurPart - 1 Then
                            CharPos = CharPos + 1
                            Mid$(outSeq, CharPos, 1) = Mid$(StrainSeq(x), Y, 1)
                        End If
                    Next Y
                End If
            Else
                GoOn = 1
            End If
            
            
            
        
            
            If GoOn = 1 Then
                TName(x) = Trim$(CStr(x))
                TName(x) = String(NLen - Len(TName(x)), "0") & TName(x)
                TName(x) = "S" & TName(x)
                Print #FF, ">" + TName(x)
                'BootName = TName(X)
                If NodeFind(SelectNode(0), x) = 1 Then
                    
                    SeqSet(NumAbove) = TName(x)
                    NumAbove = NumAbove + 1
                End If
                'BootName = BootName + String$(10 - (Len(BootName)), " ")
                
                'OutSeq = BootName + OutSeq
                XX = Len(outSeq)
                Print #FF, outSeq
                GoOnX = 1
                
            
            End If
            
        Next x
        XX = Len(outSeq)
        
        Close #FF
        If GoOnX = 1 Then
            BatIndex = 53
            If PartNo > 2 Then
                Form1.SSPanel1.Caption = "Inferreing ML tree for partition " + Trim(Str(CurPart)) + " (of " + Trim(CStr(PartNo - 1)) + ") with RAxML"
                Form2.SSPanel3.Caption = "Inferreing ML tree for partition " + Trim(Str(CurPart)) + " (of " + Trim(CStr(PartNo - 1)) + ") with RAxML"
            Else
                Form1.SSPanel1.Caption = "Inferreing ML tree with RAxML"
                Form2.SSPanel3.Caption = "Inferreing ML tree with RAxML"
            End If
            'make the unrooted tree first and then a rooted version of that trree
            ShellAndClose "dnadist.bat", 0
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'letting raxml midpoint root the tre may become a problem
            'would be better to force a root outside the selected subtree
            'if root is within the selected subtree the wrong ancestral sequence will be inferred (probably the sequence at the root node will be inferred)
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            If PartNo > 2 Then
                Form1.SSPanel1.Caption = "Inferreing ancestral sequence for partition " + Trim(Str(CurPart)) + " (of " + Trim(CStr(PartNo - 1)) + ") with RAxML"
                Form2.SSPanel3.Caption = "Inferreing ancestral sequence for partition " + Trim(Str(CurPart)) + " (of " + Trim(CStr(PartNo - 1)) + ") with RAxML"
            Else
                Form1.SSPanel1.Caption = "Inferreing ancestral sequence with RAxML"
                Form2.SSPanel3.Caption = "Inferreing ancestral sequence with RAxML"
            End If
            'infer ancestral states from the rooted version of the tree
            ShellAndClose "dnadist2.bat", 0
            
            
            'find node of interest in RAxML_nodeLabelledRootedTree.Ancestral
            Dim FileString As String, LOFileString As Long, PosSeq() As Long, PosS As Long, LeftPos As Long, RightPos As Long
    '        killfile "RAxML_info.Ancestral"
    '        'killfile "RAxML_parsimonyTree.Ancestral"
    '        'killfile "RAxML_log.Ancestral"
    '        'killfile "RAxML_result.Ancestral"
    '        'killfile "RAxML_bestTree.Ancestral"
    '        'killfile "RAxML_bootstrap.Ancestral"
    '        'killfile "RAxML_perSiteLLs.Ancestral"
    '        'killfile "RAxML_perSiteLLs.Ancestral"
    '        killfile "RAxML_marginalAncestralProbabilities.Ancestral"
    '        killfile "RAxML_marginalAncestralStates.Ancestral"
    '        killfile "RAxML_nodeLabelledRootedTree.Ancestral"
            If SaveForMrBayes = 1 Then
                Open "RAxML_bestTree.treefile" For Binary As #FF
                    MLTreeSet(CurPart) = String(LOF(FF), " ")
                    Get #FF, , MLTreeSet(CurPart)
                Close #FF
            End If
            Pos = Len(MLTreeSet(CurPart)) - 10
            Pos1 = Pos
            Do
                Pos1 = InStr(Pos1 + 1, MLTreeSet(CurPart), ")", vbBinaryCompare)
                If Pos1 > 0 Then
                    Pos2 = Pos1 + 1
                Else
                    Exit Do
                End If
                
            Loop
            'strip off all stuff after the last bracket (mrbayes doesnt like that stuff)
            XX = Right(MLTreeSet(CurPart), 20)
            If MLTreeSet(CurPart) <> "" Then
                MLTreeSet(CurPart) = Left(MLTreeSet(CurPart), Pos2 - 1) + ";"
                
            End If
            Yy = Right(MLTreeSet(CurPart), 20)
            Open "RAxML_nodeLabelledRootedTree.Ancestral" For Binary As #FF
            LOFileString = LOF(FF)
            FileString = String(LOFileString, " ")
            Get #FF, , FileString
            Close #FF
            
            'find positions of all the sequence names  descended from the selected MRCA in the treefile
            RightPos = 0
            LeftPos = LOFileString
            ReDim PosSeq(PermNextno)
            For x = 0 To NumAbove - 1
                PosSeq(x) = InStr(1, FileString, SeqSet(x), vbBinaryCompare)
                If PosSeq(x) > RightPos Then RightPos = PosSeq(x)
                If PosSeq(x) < LeftPos Then LeftPos = PosSeq(x)
            Next x
            'XX = NodeFind(SelectNode(0), 37)
            
            'Find matching bracket pairs - left to right
            Dim BracketPair() As Long, BracketCount As Long, TargetChar As String, BPos As Long, BTally As Long
            ReDim BracketPair(PermNextno, 1)
            BracketCount = 0
            TargetChar = "("
            BPos = 1
            Do
                BPos = InStr(BPos, FileString, TargetChar, vbBinaryCompare)
                If BPos > 0 Then
                    BracketCount = BracketCount + 1
                    BracketPair(BracketCount, 0) = BPos
                    'find position of matching bracket
                    BTally = 1
                    For x = BPos + 1 To LOFileString
                        If Mid$(FileString, x, 1) = "(" Then
                            BTally = BTally + 1
                        ElseIf Mid$(FileString, x, 1) = ")" Then
                            BTally = BTally - 1
                            If BTally = 0 Then
                                BracketPair(BracketCount, 1) = x
                                Exit For
                            End If
                        End If
                        
                    Next x
                Else
                    Exit Do
                End If
                BPos = BPos + 1
                If BPos > LOFileString Then Exit Do
            Loop
            
            
            
            
            'find the bracketpair that most tightly bounds leftpos and rightpos
            Dim BestFit As Long, BracketDist As Long, WinPair As Long
            BestFit = LOFileString
            For x = 1 To BracketCount
                If BracketPair(x, 0) <= LeftPos Then
                    If BracketPair(x, 1) >= RightPos Then
                        BracketDist = BracketPair(x, 1) - BracketPair(x, 0)
                        If BracketDist < BestFit Then
                            BestFit = BracketDist
                            WinPair = x
                        End If
                    End If
                    
                End If
                
            Next x
            
            'find the number beside the right winpair bracket
            Dim TargetNode As String, PosC As Long
            PosC = InStr(BracketPair(WinPair, 1) + 1, FileString, ",", vbBinaryCompare)
            PosB = InStr(BracketPair(WinPair, 1) + 1, FileString, ")", vbBinaryCompare)
            If PosB > 0 And PosC > 0 Then
                If PosB < PosC Then PosC = PosB
            ElseIf PosC = 0 And PosB > 0 Then
                PosC = PosB
            ElseIf PosC = 0 And PosB = 0 Then 'it must be the root node
                PosC = InStr(BracketPair(WinPair, 1) + 1, FileString, ";", vbBinaryCompare)
                If PosC = 0 Then
                    Exit Sub
                End If
                PosB = PosC
            End If
            
            'XX = Mid$(FileString, BracketPair(WinPair, 1) + 1, PosC - (BracketPair(WinPair, 1) + 1))
            'XX = Mid$(FileString, BracketPair(WinPair, 1) + 1, PosC - (BracketPair(WinPair, 1) + 1))
            TargetNode = (Mid$(FileString, BracketPair(WinPair, 1) + 1, PosC - (BracketPair(WinPair, 1) + 1)))
            
            
            'Get the sequence of interest from RAxML_marginalAncestralStates.Ancestral
            
            Open "RAxML_marginalAncestralStates.Ancestral" For Binary As #FF
            LOFileString = LOF(FF)
            FileString = String(LOFileString, " ")
            Get #FF, , FileString
            Close #FF
            
            Dim TString As String, PosA As Long
            TString = Trim(CStr(TargetNode))
            PosC = InStr(1, FileString, TString, vbBinaryCompare)
            PosC = PosC + Len(TString)
            
            Do While Mid(FileString, PosC, 1) = " "
                PosC = PosC + 1
            Loop
            'XX = Mid(FileString, PosC, 1)
            PosB = InStr(PosC, FileString, Chr(10), vbBinaryCompare)
            PosA = InStr(PosC, FileString, Chr(13), vbBinaryCompare)
            If PosA < PosB Then
                PosB = PosA
            End If
            x = x
            TString = Mid$(FileString, PosC, PosB - PosC)
            
            'XX = Right(TString, 5)
            
            For x = 1 To Len(TString)
                Mid$(AncestralSeq, XDiffPos(x), 1) = Mid$(TString, x, 1)
            Next x
            'Get marginal probabilities from RAxML_marginalAncestralProbabilities.Ancestral
            
            Open "RAxML_marginalAncestralProbabilities.Ancestral" For Binary As #FF
            LOFileString = LOF(FF)
            FileString = String(LOFileString, " ")
            Get #FF, , FileString
            Close #FF
            
            TString = Trim(CStr(TargetNode))
            
            PosA = InStr(1, FileString, Chr(10), vbBinaryCompare)
            PosB = InStr(1, FileString, Chr(13), vbBinaryCompare)
            
            If PosA > 0 Then
                If PosB > 0 Then
                    If PosA < PosB Then
                        TString = TString + Chr(10) + Chr(13)
                        TS = Chr(10) + Chr(13)
                    Else
                        TString = TString + Chr(13) + Chr(10)
                        TS = Chr(13) + Chr(10)
                    End If
                Else
                    TString = TString + Chr(10)
                     TS = Chr(10)
                End If
            Else
                If PosB > 0 Then
                    TString = TString + Chr(13)
                    TS = Chr(13)
                End If
            End If
            
            
            
            PosC = InStr(1, FileString, TString, vbBinaryCompare)
            PosC = PosC + Len(TString)
            
            
            
            For x = 1 To CharPos
                x = x
                PosB = InStr(PosC, FileString, " ", vbBinaryCompare)
                XX = Mid$(FileString, PosC, PosB - PosC)
                XX = Len(FileString)
                AncestralProbs(0, XDiffPos(x)) = val(Mid$(FileString, PosC, (PosB - PosC)))
                PosC = PosB + 1
                
                PosB = InStr(PosC, FileString, " ", vbBinaryCompare)
                'XX = Mid$(FileString, PosC, PosB - PosC)
                AncestralProbs(1, XDiffPos(x)) = val(Mid$(FileString, PosC, PosB - PosC))
                PosC = PosB + 1
                
                PosB = InStr(PosC, FileString, " ", vbBinaryCompare)
                'XX = Mid$(FileString, PosC, PosB - PosC)
                AncestralProbs(2, XDiffPos(x)) = val(Mid$(FileString, PosC, PosB - PosC))
                PosC = PosB + 1
                
                PosB = InStr(PosC, FileString, TS, vbBinaryCompare)
                'XX = Mid$(FileString, PosC, PosB - PosC)
                AncestralProbs(3, XDiffPos(x)) = val(Mid$(FileString, PosC, PosB - PosC))
                PosC = PosB + Len(TS)
                
                
            Next x
            'Exit Sub
            
        '           For X = 1 To PartNo - 1
        '                X = X
        '                For Y = X + 1 To PartNo
        '                    If SPart(Parts(1, X)) = SPart(Parts(1, Y)) Then
        '                        Print #1, "link topology = (" + Trim(Str(X)) + ", " + Trim(Str(Y)) + ");"
        '                        Print #1, "link brlens = (" + Trim(Str(X)) + ", " + Trim(Str(Y)) + ");"
        '                    End If
        '
        '                Next Y
        '            Next X
        
            'Make testtree(s) - it(they) must be rooted
            'Need to make one tree per part
        Else
            PartNo = CurPart
            Exit For
        End If
    
    
    Next CurPart
Else





End If





ReDim AncPVals(5, SLen), AncPValsML(5, SLen)




Dim BetsP As Single
For x = 1 To SLen
    BestP = 0
    For Y = 0 To 3
        If BestP < AncestralProbs(Y, x) Then BestP = AncestralProbs(Y, x)
        AncPVals(Y + 1, x) = AncestralProbs(Y, x)
        AncPValsML(Y + 1, x) = AncestralProbs(Y, x)
    Next Y
    AncPVals(0, x) = BestP
    AncPValsML(0, x) = BestP
Next x

MLAncSeq = AncestralSeq

For x = 1 To Len(StrainSeq(0))
    If Mid$(MLAncSeq, x, 1) = "?" Then
        Mid$(MLAncSeq, x, 1) = "-"
    End If
Next x



AncSeqFlag = 1

'Set stuff up so that the ancestral sequence can be displayed
If Form1.Picture22.Visible = False Then
    Form1.VScroll3.Height = (Form1.HScroll1.Top - Form1.VScroll3.Top - 4 * Screen.TwipsPerPixelX) / 2
    Form1.Picture8.Height = Form1.VScroll3.Height
    Form1.Picture9.Height = Form1.VScroll3.Height
    'Form1.Picture1.Height = Form1.Picture9.Height
    Form1.Picture22.Top = Form1.VScroll3.Top + Form1.VScroll3.Height + 50
    Form1.Picture22.Left = Form1.Picture9.Left
    Form1.Picture22.Height = Form1.Picture9.Height - 50
    Form1.Picture22.Width = Form1.Picture8.Left + Form1.Picture8.Width - Form1.Picture22.Left
    Form1.Picture22.Visible = True
    'If Form1.command33(0).Enabled = True Then Call Command33_Click(0) Else Call Command33_Click(1)
End If



F1MDF = 1
Call ResizeForm1
F1MDF = 0
Form1.Picture22.Visible = True
If Form1.HScroll1 > 1 Then
    H1C = 1
    Form1.HScroll1 = Form1.HScroll1 - 1
    Form1.HScroll1 = Form1.HScroll1 + 1
Else
    If Form1.HScroll1.Max > 0 Then
        H1C = 1
        Form1.HScroll1 = Form1.HScroll1 + 1
        Form1.HScroll1 = Form1.HScroll1 - 1
    Else
        Form1.HScroll1.Max = 1
        H1C = 1
        Form1.HScroll1 = Form1.HScroll1 + 1
        Form1.HScroll1 = Form1.HScroll1 - 1
        Form1.HScroll1.Max = 0
    End If
End If




If DebuggingFlag < 2 Then On Error Resume Next




ChDir oDir
ChDrive oDir
On Error GoTo 0
'   Exit Sub
'MRBayesError:
'
'     MsgBox ("I have detected a conflict between multiple instances of MrBayes running on your computer.  You can possibly resolve this problem by pressing the 'ctrl', 'alt', and 'del' buttons at the same time, in the Task Manager program that pops up selecting the 'task list' option, in the 'processes' tab selecting 'MrBayes' from the list, and pressing the 'end process' button. When you have done this re-select the node at which you would like an ancestral sequence inferred.")
'     Exit Sub
'
End Sub
Public Sub GetNHFlag(F2TreeIndex, NJF, NHFlag)
    NHFlag = F2TreeIndex
    If F2TreeIndex = 0 Then
        If NJF = 1 Then
            NHFlag = 4
'            tTF = 1
        ElseIf NJF = 2 Then
            NHFlag = 5
        ElseIf NJF = 3 Then
            NHFlag = 6
        ElseIf NJF = 4 Then
            NHFlag = 13
        End If

    ElseIf F2TreeIndex = 2 Then

        If NJF = 1 Then
            NHFlag = 7
        ElseIf NJF = 2 Then
            NHFlag = 8
        ElseIf NJF = 3 Then
            NHFlag = 9
        ElseIf NJF = 4 Then
            NHFlag = 14
        End If
    ElseIf F2TreeIndex = 1 Then

        If NJF = 1 Then
            NHFlag = 10
        ElseIf NJF = 2 Then
            NHFlag = 11
        ElseIf NJF = 3 Then
            NHFlag = 12
        ElseIf NJF = 4 Then
            NHFlag = 15
        End If
    ElseIf F2TreeIndex = 3 And NJF = 1 Then
        NHFlag = 16
    ElseIf F2TreeIndex = 3 And NJF = 0 Then
        NHFlag = 17
    ElseIf F2TreeIndex = 3 And NJF = 2 Then
            NHFlag = 33
        
    ElseIf F2TreeIndex = 3 And NJF = 3 Then
            NHFlag = 34
    ElseIf F2TreeIndex = 3 And NJF = 4 Then
            'NHFlag = F2TreeIndex
            NHFlag = 34
        
    End If
End Sub
Public Sub GetModelString(TMX As String)

If BSTreeStrat <> 4 And BSTreeStrat <> 5 Then
    If TPModel = 0 Then
        TMX = "(JC"
    ElseIf TPModel = 1 Then
        TMX = "(K2P"
    ElseIf TPModel = 2 Then
        TMX = "(F81"
    ElseIf TPModel = 3 Then
        TMX = "(F84"
    ElseIf TPModel = 4 Then
        TMX = "(TN93"
    ElseIf TPModel = 5 Then
        TMX = "(GTR"
    ElseIf TPModel = 6 Then
        TMX = "(HKY"
    End If
    
    If TPInvSites > 0 Then
        TMX = TMX + "+I"
    End If
    
    If TPGamma > 1 Then
        TMX = TMX + "+G" + Trim(Str(TPGamma))
    End If
    
    TMX = TMX + ")"
Else
    TMX = "(GTRCAT)"
End If

End Sub
Public Sub ModelTestPHYML()

    'make sure that files are written to rdp home directory
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    On Error GoTo 0
    
    
    NumberOfSeqs = NextNo
   
    Dim ModelData(100, 5) As Double, Boots() As String, MN() As String, FFile As Long
    ReDim Boots(NumberOfSeqs), MN(100)
    
    'This is for testing only
'    Dim TempSeq() As String
'    ReDim TempSeq(NumberOfSeqs)
'    For X = 0 To NumberOfSeqs
'        TempSeq(X) = StrainSeq(X)
'    Next X
    
    'Free parameters
    ModelData(0, 0) = 0: MN(0) = "JC"
    ModelData(1, 0) = 1: MN(1) = "JC+I"
    ModelData(2, 0) = 1: MN(2) = "JC+G"
    ModelData(3, 0) = 2: MN(3) = "JC+I+G"
    ModelData(4, 0) = 1: MN(4) = "K2P"
    ModelData(5, 0) = 2: MN(5) = "K2P+I"
    ModelData(6, 0) = 2: MN(6) = "K2P+G"
    ModelData(7, 0) = 3: MN(7) = "K2P+I+G"
    ModelData(8, 0) = 4: MN(8) = "HKY"
    ModelData(9, 0) = 5: MN(9) = "HKY+I"
    ModelData(10, 0) = 5: MN(10) = "HKY+G"
    ModelData(11, 0) = 6: MN(11) = "HKY+I+G"
    ModelData(12, 0) = 4: MN(12) = "F84"
    ModelData(13, 0) = 5: MN(13) = "F84+I"
    ModelData(14, 0) = 5: MN(14) = "F84+G"
    ModelData(15, 0) = 6: MN(15) = "F84+I+G"
    ModelData(16, 0) = 5: MN(16) = "TN93"
    ModelData(17, 0) = 6: MN(17) = "TN93+I"
    ModelData(18, 0) = 6: MN(18) = "TN93+G"
    ModelData(19, 0) = 7: MN(19) = "TN93+I+G"
    ModelData(20, 0) = 3: MN(20) = "F81"
    ModelData(21, 0) = 4: MN(21) = "F81+I"
    ModelData(22, 0) = 4: MN(22) = "F81+G"
    ModelData(23, 0) = 5: MN(23) = "F81+I+G"
    ModelData(24, 0) = 8: MN(24) = "GTR"
    ModelData(25, 0) = 9: MN(25) = "GTR+I"
    ModelData(26, 0) = 9: MN(26) = "GTR+G"
    ModelData(27, 0) = 10: MN(27) = "GTR+I+G"
    
    
    'Make the infilex
    
    If Len(TempSeq(0)) > 100000 Then

        Dim TS2() As String, MyVa As Long
           ReDim TS2(NextNo)
           For x = 0 To NextNo
                TS2(x) = TempSeq(x)
                TempSeq(x) = String(100000, " ")
           Next x
            Rnd (-BSRndNumSeed)
            
            For x = 1 To 100000
                MyVa = CLng(((Len(StrainSeq(0)) - 1) * Rnd) + 0.5) + 1 '
                For Y = 0 To NextNo
                    Mid(TempSeq(Y), x, 1) = Mid$(TS2(Y), MyVa, 1)
                    x = x
                Next Y
            Next 'X
            Erase TS2
            XX = Len(TempSeq(0))

    End If
    If DebuggingFlag < 2 Then On Error Resume Next
        
        KillFile "infilex"
        
    On Error GoTo 0
    FFile = FreeFile
    Open "infilex" For Output As #FFile
    Header = " " + Trim$(CStr((NumberOfSeqs + 1))) + "   " + Trim$(CStr(Len(TempSeq(0))))
    
    
    Print #FFile, Header
    BatIndex = 0
    
    NLen = Len(Trim(Str(NumberOfSeqs)))
    If NLen = 1 Then NLen = 2
    For x = 0 To NumberOfSeqs
        
        TName = Trim$(CStr(x))
        TName = String(NLen - Len(TName), "0") & TName
        TName = "S" & TName
        BootName = TName
        BootName = BootName + String$(10 - (Len(BootName)), " ")
        TString = TempSeq(x)
        Boots(x) = BootName + TString
        Print #FFile, Boots(x)
    Next 'X

    
    Close #FFile
    
    'Make the command line
    
    'phyml seqs1 0 i 2 0 HKY 4.0 e 1 1.0 BIONJ y y
    'sequences file, data type, sequence format, nb data sets, nb bootstrapped data sets,
    'substitution model, ts/tv ratio , prop. invariable sites, nb categories gamma parameter, starting tree,
    'optimise topology, optimise branch lengths and rate parameters
    
    For M = 0 To 27
        Form1.SSPanel1.Caption = "Testing model" + Str(M + 1) + " (" + MN(M) + ") of 28"
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "outfile"
        KillFile "outfilex"
        KillFile "infilex_phyml_lk.txt"
        KillFile "infilex_phyml_boot_trees.txt"
        If DebuggingFlag < 2 Then On Error Resume Next
        Randomize
        KillFile "dnadistx.bat"
        FLen = 0
        
        FLen = FileLen("dnadistx.bat")
        
        If FLen > 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
            
            FString = "dnadistx" & Trim(Str(Rnd)) & ".bat"
        Else
            FString = "dnadistx.bat"
        End If
        Rnd (-BSRndNumSeed)
        On Error GoTo 0
        
        Open FString For Output As #FFile
        
        If M = 0 Then 'JC
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P 1.0 0 1 2 BIONJ y y"
            
        ElseIf M = 1 Then 'JC + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P 1.0 e 1 2 BIONJ y y"
        ElseIf M = 2 Then 'JC + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P 1.0 0 4 e BIONJ y y"
        ElseIf M = 3 Then 'JC + I + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P 1.0 e 4 e BIONJ y y"
       
        ElseIf M = 4 Then 'K2P
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P e 0 1 2 BIONJ y y"
        ElseIf M = 5 Then 'K2P + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P e e 1 2 BIONJ y y"
        ElseIf M = 6 Then 'K2P + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P e 0 4 e BIONJ y y"
        ElseIf M = 7 Then 'K2P + G + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 K2P e e 4 e BIONJ y y"
        ElseIf M = 8 Then 'HKY
            OutString = "phyml_win32.exe infilex 0 s 1 0 HKY e 0 1 2 BIONJ y y"
        ElseIf M = 9 Then 'HKY + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 HKY e e 1 2 BIONJ y y"
        ElseIf M = 10 Then 'HKY + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 HKY e 0 4 e BIONJ y y"
        ElseIf M = 11 Then 'HKY + G + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 HKY e e 4 e BIONJ y y"
        ElseIf M = 12 Then 'F84
            OutString = "phyml_win32.exe infilex 0 s 1 0 F84 e 0 1 2 BIONJ y y"
        ElseIf M = 13 Then 'F84 + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 F84 e e 1 2 BIONJ y y"
        ElseIf M = 14 Then 'F84 + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 F84 e 0 4 e BIONJ y y"
        ElseIf M = 15 Then 'F84 + G + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 F84 e e 4 e BIONJ y y"
        ElseIf M = 16 Then 'TN93
            OutString = "phyml_win32.exe infilex 0 s 1 0 TN93 e 0 1 2 BIONJ y y"
        ElseIf M = 17 Then 'TN93 + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 TN93 e e 1 2 BIONJ y y"
        ElseIf M = 18 Then 'TN93 + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 TN93 e 0 4 e BIONJ y y"
        ElseIf M = 19 Then 'TN93 + G + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 TN93 e e 4 e BIONJ y y"
        ElseIf M = 20 Then 'f81
            OutString = "phyml_win32.exe infilex 0 s 1 0 F81 1.0 0 1 2 BIONJ y y"
        ElseIf M = 21 Then 'f81 + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 F81 1.0 e 1 2 BIONJ y y"
        ElseIf M = 22 Then 'f81 + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 F81 1.0 0 4 e BIONJ y y"
        ElseIf M = 23 Then 'f81 + G + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 F81 1.0 e 4 e BIONJ y y"
        ElseIf M = 24 Then 'GTR
            OutString = "phyml_win32.exe infilex 0 s 1 0 GTR 1.0 0 1 2 BIONJ y y"
        ElseIf M = 25 Then 'GTR + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 GTR 1.0 e 1 2 BIONJ y y"
        ElseIf M = 26 Then 'GTR + G
            OutString = "phyml_win32.exe infilex 0 s 1 0 GTR 1.0 0 4 e BIONJ y y"
        ElseIf M = 27 Then 'GTR + G + I
            OutString = "phyml_win32.exe infilex 0 s 1 0 GTR 1.0 e 4 e BIONJ y y"
        End If
        
        
      
      
      
    
        Print #FFile, OutString
        Print #FFile, "del treefile"
            
        Print #FFile, "rename infilex_phyml_tree.txt treefile "
        
        Close #FFile
        On Error GoTo 0
        'Do
        ShellAndClose FString, 0
        'Loop
        Open "infilex_phyml_lk.txt" For Input As #FFile
            Input #FFile, ModelData(M, 1) '-66057.051,-62468.473
        Close #FFile
        x = x
        
        If AbortFlag = 1 Then
            Form2.Picture2(0).Enabled = True
            Form2.Picture2(1).Enabled = True
            Form2.Picture2(2).Enabled = True
            Form2.Picture2(3).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            Exit Sub
        End If
        
        Form1.ProgressBar1 = ((M + 1) / 28) * 100
        Call UpdateF2Prog
        x = x
    Next M
x = x

'calculate AIC's
For x = 0 To 27
    'AIC = -2lnL + 2n
    ModelData(x, 2) = 2 * (-ModelData(x, 1)) + 2 * ModelData(x, 0)
    x = x
Next x

'Find Min
Dim Min As Double, WinTest As Long
Min = 10 ^ 100

For x = 0 To 27
    If Min > ModelData(x, 2) Then
        Min = ModelData(x, 2)
        WinTest = x
    End If
Next x

If WinTest = 0 Then
    TPModel = 0
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 1 Then
    TPModel = 0
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 2 Then
    TPModel = 0
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 3 Then
    TPModel = 0
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 4 Then
    TPModel = 1
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 5 Then
    TPModel = 1
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 6 Then
    TPModel = 1
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 7 Then
    TPModel = 1
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 8 Then
    TPModel = 6
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 9 Then
    TPModel = 6
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 10 Then
    TPModel = 6
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 11 Then
    TPModel = 6
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 12 Then
    TPModel = 3
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 13 Then
    TPModel = 3
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 14 Then
    TPModel = 3
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 15 Then
    TPModel = 3
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 16 Then
    TPModel = 4
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 17 Then
    TPModel = 4
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 18 Then
    TPModel = 4
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 19 Then
    TPModel = 4
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 20 Then
    TPModel = 2
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 21 Then
    TPModel = 2
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 22 Then
    TPModel = 2
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 23 Then
    TPModel = 2
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 24 Then
    TPModel = 5
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 25 Then
    TPModel = 5
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 26 Then
    TPModel = 5
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 27 Then
    TPModel = 5
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
End If

If DebuggingFlag < 2 Then On Error Resume Next
KillFile "infilex"
Kill FString
KillFile "treefile"
KillFile "infile_phyml_stat.txt"
On Error GoTo 0

End Sub
Public Sub ModelTestPHYML3()

    'make sure that files are written to rdp home directory
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    On Error GoTo 0
    
    
    NumberOfSeqs = NextNo
   
    Dim ModelData(100, 5) As Double, Boots() As String, MN() As String, FFile As Long
    ReDim Boots(NumberOfSeqs), MN(100)
    
    'This is for testing only
'    Dim TempSeq() As String
'    ReDim TempSeq(NumberOfSeqs)
'    For X = 0 To NumberOfSeqs
'        TempSeq(X) = StrainSeq(X)
'    Next X
    
    'Free parameters
    ModelData(0, 0) = 0: MN(0) = "JC"
    ModelData(1, 0) = 1: MN(1) = "JC+I"
    ModelData(2, 0) = 1: MN(2) = "JC+G"
    ModelData(3, 0) = 2: MN(3) = "JC+I+G"
    ModelData(4, 0) = 1: MN(4) = "K2P"
    ModelData(5, 0) = 2: MN(5) = "K2P+I"
    ModelData(6, 0) = 2: MN(6) = "K2P+G"
    ModelData(7, 0) = 3: MN(7) = "K2P+I+G"
    ModelData(8, 0) = 4: MN(8) = "HKY"
    ModelData(9, 0) = 5: MN(9) = "HKY+I"
    ModelData(10, 0) = 5: MN(10) = "HKY+G"
    ModelData(11, 0) = 6: MN(11) = "HKY+I+G"
    ModelData(12, 0) = 4: MN(12) = "F84"
    ModelData(13, 0) = 5: MN(13) = "F84+I"
    ModelData(14, 0) = 5: MN(14) = "F84+G"
    ModelData(15, 0) = 6: MN(15) = "F84+I+G"
    ModelData(16, 0) = 5: MN(16) = "TN93"
    ModelData(17, 0) = 6: MN(17) = "TN93+I"
    ModelData(18, 0) = 6: MN(18) = "TN93+G"
    ModelData(19, 0) = 7: MN(19) = "TN93+I+G"
    ModelData(20, 0) = 3: MN(20) = "F81"
    ModelData(21, 0) = 4: MN(21) = "F81+I"
    ModelData(22, 0) = 4: MN(22) = "F81+G"
    ModelData(23, 0) = 5: MN(23) = "F81+I+G"
    ModelData(24, 0) = 8: MN(24) = "GTR"
    ModelData(25, 0) = 9: MN(25) = "GTR+I"
    ModelData(26, 0) = 9: MN(26) = "GTR+G"
    ModelData(27, 0) = 10: MN(27) = "GTR+I+G"
    
    
    'Make the infilex
    
    If Len(TempSeq(0)) > 100000 Then

        Dim TS2() As String, MyVa As Long
           ReDim TS2(NextNo)
           For x = 0 To NextNo
                TS2(x) = TempSeq(x)
                TempSeq(x) = String(100000, " ")
           Next x
            Rnd (-BSRndNumSeed)
            
            For x = 1 To 100000
                MyVa = CLng(((Len(StrainSeq(0)) - 1) * Rnd) + 0.5) + 1 '
                For Y = 0 To NextNo
                    Mid(TempSeq(Y), x, 1) = Mid$(TS2(Y), MyVa, 1)
                    x = x
                Next Y
            Next 'X
            Erase TS2
            XX = Len(TempSeq(0))

    End If
    If DebuggingFlag < 2 Then On Error Resume Next
        
        KillFile "infilex"
        
    On Error GoTo 0
    FFile = FreeFile
    Open "infilex" For Output As #FFile
    Header = " " + Trim$(CStr((NumberOfSeqs + 1))) + "   " + Trim$(CStr(Len(TempSeq(0))))
    
    
    Print #FFile, Header
    BatIndex = 0
    
    NLen = Len(Trim(Str(NumberOfSeqs)))
    If NLen = 1 Then NLen = 2
    For x = 0 To NumberOfSeqs
        
        TName = Trim$(CStr(x))
        TName = String(NLen - Len(TName), "0") & TName
        TName = "S" & TName
        BootName = TName
        BootName = BootName + String$(10 - (Len(BootName)), " ")
        TString = TempSeq(x)
        Boots(x) = BootName + TString
        Print #FFile, Boots(x)
    Next 'X

    
    Close #FFile
    
    'Make the command line
    
    'phyml seqs1 0 i 2 0 HKY 4.0 e 1 1.0 BIONJ y y
    'sequences file, data type, sequence format, nb data sets, nb bootstrapped data sets,
    'substitution model, ts/tv ratio , prop. invariable sites, nb categories gamma parameter, starting tree,
    'optimise topology, optimise branch lengths and rate parameters
    
    For M = 0 To 27
        Form1.SSPanel1.Caption = "Testing model" + Str(M + 1) + " (" + MN(M) + ") of 28"
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "outfile"
        KillFile "outfilex"
        KillFile "infilex_phyml_stats.txt"
        KillFile "infilex_phyml_boot_trees.txt"
        
        Open "dnadistx.bat" For Output As #FFile
        'OutString = "PhyML_3.0_win32.exe -i infilex "
        'phyml seqs1 0 i 2 0 HKY 4.0 e 1 1.0 BIONJ y y
        'sequences file, data type, sequence format, nb data sets, nb bootstrapped data sets,
        'substitution model, ts/tv ratio , prop. invariable sites, nb categories gamma parameter, starting tree,
        'optimise topology, optimise branch lengths and rate parameters
        
        Dim SSString As String
        If BSTreeStrat = 0 Then
            SSString = SSString + "-s NNI "
        ElseIf BSTreeStrat = 1 Then
            SSString = SSString + "-s SPR "
        ElseIf BSTreeStrat = 2 Then
            SSString = SSString + "-s BEST "
        End If
        
        If M = 0 Then 'JC
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t 1.0 -v 0 -c 1 "
            
        ElseIf M = 1 Then 'JC + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t 1.0 -v e -c 1 "
        ElseIf M = 2 Then 'JC + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t 1.0 -v 0 -c 4 "
        ElseIf M = 3 Then 'JC + I + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t 1.0 -v e -c 4 "
       
        ElseIf M = 4 Then 'K80
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t e -v 0 -c 1 "
        ElseIf M = 5 Then 'K80 + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t e -v e -c 1 "
        ElseIf M = 6 Then 'K80 + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t e -v 0 -c 4 "
        ElseIf M = 7 Then 'K80 + G + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m K80 -t e -v e -c 4 "
        ElseIf M = 8 Then 'HKY
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m HKY85 -t e -v 0 -c 1 "
        ElseIf M = 9 Then 'HKY + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m HKY85 -t e -v e -c 1 "
        ElseIf M = 10 Then 'HKY + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m HKY85 -t e -v 0 -c 4 "
        ElseIf M = 11 Then 'HKY + G + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m HKY85 -t e -v e -c 4 "
        ElseIf M = 12 Then 'F84
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F84 -t e -v 0 -c 1 "
        ElseIf M = 13 Then 'F84 + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F84 -t e -v e -c 1 "
        ElseIf M = 14 Then 'F84 + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F84 -t e -v 0 -c 4 "
        ElseIf M = 15 Then 'F84 + G + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F84 -t e -v e -c 4 "
        ElseIf M = 16 Then 'TN93
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m TN93 -t e -v 0 -c 1 "
        ElseIf M = 17 Then 'TN93 + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m TN93 -t e -v e -c 1 "
        ElseIf M = 18 Then 'TN93 + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m TN93 -t e -v 0 -c 4 "
        ElseIf M = 19 Then 'TN93 + G + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m TN93 -t e -v e -c 4 "
        ElseIf M = 20 Then 'f81
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F81 -t 1.0 -v 0 -c 1 "
        ElseIf M = 21 Then 'f81 + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F81 -t 1.0 -v e -c 1 "
        ElseIf M = 22 Then 'f81 + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F81 -t 1.0 -v 0 -c 4 "
        ElseIf M = 23 Then 'f81 + G + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m F81 -t 1.0 -v e -c 4 "
        ElseIf M = 24 Then 'GTR
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m GTR -t 1.0 -v 0 -c 1 "
        ElseIf M = 25 Then 'GTR + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m GTR -t 1.0 -v e -c 1 "
        ElseIf M = 26 Then 'GTR + G
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m GTR -t 1.0 -v 0 -c 4 "
        ElseIf M = 27 Then 'GTR + G + I
            OutString = "PhyML_3.0_win32.exe -i infilex -b 0 -m GTR -t 1.0 -v e -c 4 "
        End If
        
        
        OutString = OutString + SSString
      
        OutString = OutString + " --no_memory_check"
    
        Print #FFile, OutString
        Print #FFile, "del treefile"
            
        Print #FFile, "rename infilex_phyml_tree.txt treefile "
        
        Close #FFile
        On Error GoTo 0
        'Do
        ShellAndClose "dnadistx.bat", 0
        'Loop
        Dim Crap As String, CrapX As String
        Open "infilex_phyml_stats.txt" For Input As #FFile
            Do
                Input #FFile, Crap
                If Left(Crap, 7) = ". Log-l" Then Exit Do
            Loop
            Pos = InStr(1, Crap, ":", vbBinaryCompare)
            
            If Pos >= 0 Then
                CrapX = Right(Crap, Len(Crap) - (Pos + 4))
                'Input #FFile, ModelData(M, 1) '-66057.051,-62468.473
                ModelData(M, 1) = val(CrapX) '-62964.97539
                x = x
            End If
        Close #FFile
        x = x
        
        If AbortFlag = 1 Then
            Form2.Picture2(0).Enabled = True
            Form2.Picture2(1).Enabled = True
            Form2.Picture2(2).Enabled = True
            Form2.Picture2(3).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next

            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
            Exit Sub
        End If
        
        Form1.ProgressBar1 = ((M + 1) / 28) * 100
        Call UpdateF2Prog
        x = x
    Next M
x = x

'calculate AIC's
For x = 0 To 27
    'AIC = -2lnL + 2n
    ModelData(x, 2) = 2 * (-ModelData(x, 1)) + 2 * ModelData(x, 0)
    x = x
Next x

'Find Min
Dim Min As Double, WinTest As Long
Min = 10 ^ 100

For x = 0 To 27
    If Min > ModelData(x, 2) Then
        Min = ModelData(x, 2)
        WinTest = x
    End If
Next x

If WinTest = 0 Then
    TPModel = 0
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 1 Then
    TPModel = 0
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 2 Then
    TPModel = 0
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 3 Then
    TPModel = 0
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 4 Then
    TPModel = 1
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 5 Then
    TPModel = 1
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 6 Then
    TPModel = 1
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 7 Then
    TPModel = 1
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 8 Then
    TPModel = 6
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 9 Then
    TPModel = 6
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 10 Then
    TPModel = 6
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 11 Then
    TPModel = 6
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 12 Then
    TPModel = 3
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 13 Then
    TPModel = 3
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 14 Then
    TPModel = 3
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 15 Then
    TPModel = 3
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 16 Then
    TPModel = 4
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 17 Then
    TPModel = 4
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 18 Then
    TPModel = 4
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 19 Then
    TPModel = 4
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 20 Then
    TPModel = 2
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 21 Then
    TPModel = 2
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 22 Then
    TPModel = 2
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 23 Then
    TPModel = 2
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 24 Then
    TPModel = 5
    TPInvSites = 0
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 25 Then
    TPModel = 5
    TPInvSites = 1
    TPGamma = 1
    TPAlpha = 2
ElseIf WinTest = 26 Then
    TPModel = 5
    TPInvSites = 0
    TPGamma = 4
    TPAlpha = 0
ElseIf WinTest = 27 Then
    TPModel = 5
    TPInvSites = 1
    TPGamma = 4
    TPAlpha = 0
End If





If DebuggingFlag < 2 Then On Error Resume Next
KillFile "infilex"
KillFile "dnadistx.bat"
KillFile "treefile"
KillFile "infile_phyml_stat.txt"
On Error GoTo 0

    
        
        
    'Make the tree
    

End Sub

Public Sub TreeCluster()

Dim Getstring As String, Treebyte() As Byte, oGS As String, oTB() As Byte
'XX = NHString(6)
Call ReadTreeFile(NextNo, 6, 0, "", Getstring, Treebyte())
'strip bootstrap values from getstring and treebyte after reading into dlen
oGS = Getstring
ReDim oTB(Len(Getstring))
For x = 0 To Len(Getstring)
    oTB(x) = Treebyte(x)
Next x
Pos = 1
Do While Pos > 0
    Pos = InStr(Pos + 1, Getstring, ")", vbBinaryCompare)
    If Pos > 0 Then
        NPos = InStr(Pos + 1, Getstring, ":", vbBinaryCompare)
        If NPos > 0 Then
            Getstring = Left(Getstring, Pos) & Right(Getstring, Len(Getstring) - NPos + 1)
        Else
            Exit Do
        End If
    Else
        Exit Do
    End If
Loop
ReDim Treebyte(Len(Getstring))
For x = 1 To Len(Getstring)
    Treebyte(x - 1) = Asc(Mid(Getstring, x, 1))
Next x
If NextNo < 100 Then
    NLen = 2
ElseIf NextNo < 1000 Then
    NLen = 3
ElseIf NextNo < 10000 Then
    NLen = 4
ElseIf NextNo < 100000 Then
    NLen = 5
ElseIf NextNo < 1000000 Then
    NLen = 6
End If
NameLen = NLen

Dim TDMat() As Single
ReDim TDMat(NextNo, NextNo)
Call Tree2Array(0, NameLen, NextNo, (Len(Getstring)), Treebyte(), TDMat())
Dim MinDist As Double



Dim MH(1) As Long

Rnd (-BSRndNumSeed)
Dim tMaskseq() As Long, RS(1) As Long, PVal(1) As Double, NoPerms As Long, Score(1) As Double
ReDim tMaskseq(NextNo)

For x = 0 To NextNo
    tMaskseq(x) = MaskSeq(x)
Next x
NoPerms = 10000

Dim SDist(), MinX, ProbX() As Byte
ReDim SDist(NextNo)
For x = 0 To NextNo
    MinD = NextNo
    For Y = 0 To NextNo
    
        If MinD > TDMat(x, Y) And Y <> x Then
            MinD = TDMat(x, Y)
            MinX = Y
        End If
    Next Y
    SDist(MinX) = SDist(MinX) + 1
Next x

ReDim ProbX(NextNo)
For x = 0 To NextNo
    If SDist(x) > 5 Then
        x = x
        ProbX(x) = 1
        
    End If
Next x

PVal(0) = 0
PVal(1) = 0
Rnd (-BSRndNumSeed)
For Z = 0 To NoPerms
    
    
    For A = 0 To 1
        Score(A) = 0
        
        For x = 0 To NextNo
            If tMaskseq(x) = 0 Then
                tMaskseq(x) = 1
            Else
                tMaskseq(x) = 0
            End If
        Next x
        
        For x = 0 To NextNo
        '16,
            If tMaskseq(x) = 1 Then
            '50,85
            If x = 29 Then
                x = x
            End If
                MinDist = NextNo
                For Y = 0 To NextNo
                
                    If Y <> x And ProbX(Y) = 0 Then
                        If TDMat(x, Y) < MinDist Then MinDist = TDMat(x, Y)
                    End If
                Next Y
                MH(0) = 0: MH(1) = 0
                For Y = 0 To NextNo
                    If TDMat(x, Y) = MinDist And ProbX(Y) = 0 Then
                        If tMaskseq(Y) = 1 Then
                            MH(0) = MH(0) + 1
                        Else
                            MH(1) = MH(1) + 1 '32
                        End If
                    End If
                Next Y
                If MH(0) > MH(1) Then Score(A) = Score(A) + 1
            End If
            x = x
            
        Next x
        
    Next A
    If Z = 0 Then
        RS(0) = Score(0)
        RS(1) = Score(1)
    Else
        If RS(1) <= Score(1) Then PVal(1) = PVal(1) + 1
        If RS(0) <= Score(0) Then PVal(0) = PVal(0) + 1
    End If
    'shuffle masks
    
    For x = 0 To NextNo
        rndn = Int((NextNo + 1) * Rnd)
        
        Temp = tMaskseq(rndn)
        tMaskseq(rndn) = tMaskseq(x)
        tMaskseq(x) = Temp
    Next x
Next Z
PVal(0) = PVal(0) / NoPerms '0.103,0.0273
PVal(1) = PVal(1) / NoPerms '0.0302- nj norec nomut'0.0157 - ml-norec-nomut

'146 - 0.1411
'163 - 0.0831
'242 - 0.4382

'Cap seqs only - 0.8736
V = V
'AIC = -lnL + 2n (smaller is better and n= the number of free parameters in the model)
End Sub
Function poz(Z As Double)
'----------------------------------------------------------------------
'POZ  --  probability of normal z value

'Adapted from a polynomial approximation in:
'Ibbetson D, Algorithm 209
'Collected Algorithms of the CACM 1963 p. 616

'Note:
'This routine has six digit accuracy, so it is only useful for absolute
'z values < 6.  For z values >=  6.0, poz() returns 0.0.
'----------------------------------------------------------------------
Dim Y, x, W As Double
     ZMax = 6#
    If Z = 0# Then
      x = 0#
    Else
      Y = 0.5 * Abs(Z)
      If Y >= ZMax * 0.5 Then
        x = 1#
      ElseIf Y < 1# Then
        W = Y * Y
        x = ((((((((0.000124818987 * W - 0.001075204047) * W + 0.005198775019) * W - 0.019198292004) * W + 0.059054035642) * W - 0.151968751364) * W + 0.319152932694) * W - 0.5319230073) * W + 0.797884560593) * Y * 2
      Else
        Y = Y - 2
        x = (((((((((((((-0.000045255659 * Y + 0.00015252929) * Y - 0.000019538132) * Y - 0.000676904986) * Y + 0.001390604284) * Y - 0.00079462082) * Y - 0.002034254874) * Y + 0.006549791214) * Y - 0.010557625006) * Y + 0.011630447319) * Y - _
 0.009279453341) * Y + 0.005353579108) * Y - 0.002141268741) * Y + 0.000535310849) * Y + 0.999936657524
      End If
    End If
    If Z > 0# Then
        poz = ((x + 1) * 0.5)
    Else
        poz = ((1 - x) * 0.5)
    End If
    bigx = 20
    
End Function

Public Function chi2(x As Double, DF As Integer)
' Adapted From:
'Hill, I. D. and Pike, M. C. Algorithm 299
'Collected Algorithms for the CACM 1967 p. 243
'Updated for rounding errors based on remark in
'ACM TOMS June 1985, page 185
x = x

Dim even As Integer  'parity of df
Dim Tru As Integer
Dim Fals As Integer
Dim lnpi As Double
Dim ipi As Double
Dim pi As Double
    pi = 3.14159265359
    bigx = 200#
    Tru = 1: Fals = 0
    lnpi = Log(pi ^ 0.5)
    ipi = 1# / Log(pi)
    If x <= 0# Or DF < 1 Then
      chi2 = 1#
      Exit Function
    End If
    A = 0.5 * x
    If Int(DF / 2) = DF / 2 Then
      even = Tru
    Else
      even = Fals
    End If
    If DF > 1 Then
        Y = Exp(-A)
    End If
    If even = Tru Then
      S = Y
    Else
      S = 2 * poz(-(x ^ 0.5))
    End If
    If DF > 2 Then
        x = 0.5 * (DF - 1)
        If even = Tru Then
            Z = 1#
        Else
            Z = 0.5
        End If
        If (A > bigx) Then
            If even = Tru Then
                e = 0#
            Else
                e = lnpi
            End If
            C = Log(A)
            Do While (Z <= x)
                e = Log(Z) + e
                S = S + Exp(C * Z - A - e)
                Z = Z + 1
            Loop
            chi2 = S
        Else
            If even = Tru Then
                e = 1#
            Else
                e = ipi / (A ^ 0.5)
            End If
            C = 0#
            Do While (Z <= x)
                e = e * (A / Z)
                C = C + e
                Z = Z + 1
            Loop
            chi2 = C * Y + S
        End If
    Else
        chi2 = S
    End If

End Function

Public Sub DrawCTBlocks()

If RIMode = 1 Then
        RIMode = 0
        VS4Max2 = Form1.VScroll4.Max
        VS4CV = Form1.VScroll4.Value
        Form1.VScroll4.Value = 0
        Form1.VScroll4.Max = VS4Max
        If SEventNumber > 0 Then
            Form1.Command13(2).Enabled = True
            Form1.Command13(2).Caption = "Overview"
            Form1.Command13(2).ToolTipText = "Press for summarized information on recombination events 1 through " + Trim(Str(SEventNumber))
            'Picture2.Height = 2500
        Else
            Form1.Command13(2).Caption = "Overview"
            Form1.Command13(2).Enabled = False
        End If
    End If

Dim XAdj As Double, YOff As Long
Dim BlocKFract As Single

Form1.SSPanel16.BackColor = HalfColour
Form1.SSPanel16.Caption = "Breakpoint clustering tests"

YOff = 0

Form1.Picture2.ScaleMode = 3
BlocKFract = 2.5
'Form1.Picture2.ScaleHeight = (GeneNUmber + 5) * 30
'P2DHeight = Form1.Picture2.ScaleHeight
'Form1.VScroll4.Max = (GeneNUmber + 5) * 30 'P2DHeight - (Form1.Picture32.ScaleHeight) ' / Screen.TwipsPerPixelY)
XAdj = (Form1.Picture2.ScaleWidth / BlocKFract) / Len(StrainSeq(0))
YAdj = Form1.Picture2.TextHeight("O") + 4
Form1.VScroll4.Max = ((GeneNumber + 6) * 2 - ((Form1.Picture2.Height / Screen.TwipsPerPixelY) / YAdj)) * YAdj '* YAdj-

Form1.Picture2.AutoRedraw = True
Form1.Picture2.Top = 0
Form1.Picture2.Height = Form1.Picture32.Height
Form1.Picture2.BackColor = Form1.Picture1.BackColor

Dim P2H As Single, YMin As Single, yMax As Single, ClearedX As Byte, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, Pict As Long, Pnt As POINTAPI
P2H = Form1.Picture2.Height / Screen.TwipsPerPixelY
YMin = -25 'Form1.VScroll4.Value
yMax = P2H + 25 'Form1.VScroll4.Value + Form1.Picture32.Height)
'YMin = Form1.VScroll4.Value
ClearedX = 0
SS = Abs(GetTickCount)
YOff = Form1.VScroll4.Value ' / YAdj

If x = x Then
    Dim CTMap() As Single, PWid As Long, CTMapC As Single, StartPos As Long, EndPos As Long, MaxX As Long, MinX As Long
    PWid = Form1.Picture2.ScaleWidth '/ BlocKFract
    ClearedX = 0
    Pict = Form1.Picture2.hdc
    StartPos = 100000000
    EndPos = 0
    MinX = 100000000
    MaxX = 0
    For x = CTBlockNum To 0 Step -1
        Y1 = (CTBlocks(1, x) * YAdj) - YOff
        Y2 = (CTBlocks(3, x) * YAdj) - YOff
        If x = 15 Then
            x = x
        End If
        If Y1 >= YMin Or Y2 >= YMin Then
            
            If Y1 <= yMax Or Y2 <= yMax Then
                If MaxX < x Then MaxX = x
                If MinX > x Then MinX = x
                If CTBlocks(1, x) > EndPos Then
                    EndPos = CTBlocks(1, x)
                    
                End If
                If CTBlocks(1, x) < StartPos Then
                    StartPos = CTBlocks(1, x)
                End If
                
            ElseIf ClearedX = 0 Then
                'X = X - GeneNumber * 2 'Exit For
                ClearedX = 1
            End If
        Else
            
        End If
    Next x
    If EndPos > StartPos Then
        Dim BCol As Long, RC As Byte, BC As Byte, GC As Byte
        BCol = Form1.Picture2.BackColor
        ReDim CTMap(EndPos - StartPos, PWid, 5)
        For x = MinX To CTBlockNum
            Y1 = (CTBlocks(1, x) * YAdj) - YOff
            Y2 = (CTBlocks(3, x) * YAdj) - YOff
            If Y1 >= YMin Or Y2 >= YMin Then
                If Y1 <= yMax Or Y2 <= yMax Then
                    X1 = (5 + CTBlocks(0, x) * XAdj)
                    X2 = (5 + CTBlocks(2, x) * XAdj)
                    If CTBlocks(4, x) = 16744448 Then
                        RC = 0
                        GC = 128
                        BC = 255
                    ElseIf CTBlocks(4, x) = 33023 Then
                        RC = 255
                        GC = 128
                        BC = 0
                    Else
                        RC = 180
                        GC = 180
                        BC = 180
                    End If
                    If x = x Then 'CTBlocks(4, X) <> 11250603 Then 'And CTBlocks(4, X) <> 16744448 Then 'And CTBlocks(4, X) <> 33023 Then '33023 = orange; 11250603,= grey16744448 = blue
                        
    '                    If X1 <> X2 Then
    '                        Form1.Picture2.Line (X1, Y1)-(X2, Y2), CTBlocks(4, X), BF
    '                        ClearedX = 0
    '
    '                    Else
                        UBX = UBound(CTMap, 1)
                        For Y = X1 To X2
                            If CTBlocks(1, x) - StartPos <= UBX Then
                                CTMap(CTBlocks(1, x) - StartPos, Y, 0) = Y1
                                CTMap(CTBlocks(1, x) - StartPos, Y, 1) = Y2
                                CTMap(CTBlocks(1, x) - StartPos, Y, 2) = CTMap(CTBlocks(1, x) - StartPos, Y, 2) + RC
                                CTMap(CTBlocks(1, x) - StartPos, Y, 4) = CTMap(CTBlocks(1, x) - StartPos, Y, 4) + GC
                                CTMap(CTBlocks(1, x) - StartPos, Y, 5) = CTMap(CTBlocks(1, x) - StartPos, Y, 5) + BC
                                CTMap(CTBlocks(1, x) - StartPos, Y, 3) = CTMap(CTBlocks(1, x) - StartPos, Y, 3) + 1
                            End If
                            
                        Next Y
                    Else
                        UBX = UBound(CTMap, 1)
                        For Y = X1 To X2
                            If CTBlocks(1, x) - StartPos <= UBX Then
                                CTMap(CTBlocks(1, x) - StartPos, Y, 0) = Y1
                                CTMap(CTBlocks(1, x) - StartPos, Y, 1) = Y2
                                CTMap(CTBlocks(1, x) - StartPos, Y, 2) = CTMap(CTBlocks(1, x) - StartPos, Y, 2) + BCol
                                CTMap(CTBlocks(1, x) - StartPos, Y, 3) = CTMap(CTBlocks(1, x) - StartPos, Y, 3) + 1
                            End If
                        Next Y
                    End If
                ElseIf ClearedX = 0 Then
                    x = x - GeneNumber * 2 'Exit For
                    ClearedX = 1
                End If
            
            End If
        Next x
        For Y = 0 To EndPos - StartPos
            For x = 5 To PWid
                If CTMap(Y, x, 3) <> 0 Then 'Exit For
                    Form1.Picture2.ForeColor = RGB(CTMap(Y, x, 2) / CTMap(Y, x, 3), CTMap(Y, x, 4) / CTMap(Y, x, 3), CTMap(Y, x, 5) / CTMap(Y, x, 3))
                    Dummy = MoveToEx(Pict, x, CTMap(Y, x, 0), Pnt)
                    Dummy = LineTo(Pict, x, CTMap(Y, x, 1))
                End If
            Next x
            
        Next Y
        
    End If
    x = x
Else
    Pict = Form1.Picture2.hdc
    For x = CTBlockNum To 0 Step -1
        Y1 = (CTBlocks(1, x) * YAdj) - YOff
        Y2 = (CTBlocks(3, x) * YAdj) - YOff
        If Y1 >= YMin Or Y2 >= YMin Then
            If Y1 <= yMax Or Y2 <= yMax Then
                X1 = 5 + CTBlocks(0, x) * XAdj
                X2 = 5 + CTBlocks(2, x) * XAdj
                If X1 <> X2 Then
                    Form1.Picture2.Line (X1, Y1)-(X2, Y2), CTBlocks(4, x), BF
                    ClearedX = 0
                        
                Else
                    
                    Form1.Picture2.ForeColor = CTBlocks(4, x)
                    Dummy = MoveToEx(Pict, X1, Y1, Pnt)
                    Dummy = LineTo(Pict, X1, Y2)
                End If
            ElseIf ClearedX = 0 Then
                x = x - GeneNumber * 2 'Exit For
                ClearedX = 1
            End If
        Else
            
        End If
    Next x
    
End If
EE = Abs(GetTickCount)
TT = EE - SS
x = x




Dim Xpos(10, 1) As Single, CellWidth As Long, RL As Long, PV As Single, XC As Long, YC As Long 'stores start and end x positions of the table cells - things will be printed centred between these positions


CellWidth = (Form1.Picture2.ScaleWidth - (Form1.Picture2.ScaleWidth / BlocKFract)) / 6
Xpos(0, 0) = 5

Xpos(1, 0) = (Form1.Picture2.ScaleWidth / BlocKFract + 1)
Xpos(1, 1) = Xpos(1, 0) + CellWidth

Xpos(2, 0) = Xpos(1, 0)
Xpos(2, 1) = Xpos(2, 0) + CellWidth * 2

Xpos(3, 0) = Xpos(1, 1)
Xpos(3, 1) = Xpos(3, 0) + CellWidth

Xpos(4, 0) = Xpos(3, 1)
Xpos(4, 1) = Xpos(4, 0) + CellWidth

Xpos(5, 0) = Xpos(4, 0)
Xpos(5, 1) = Xpos(5, 0) + CellWidth * 2

Xpos(6, 0) = Xpos(4, 1)
Xpos(6, 1) = Xpos(6, 0) + CellWidth

Xpos(7, 0) = Xpos(6, 1)
Xpos(7, 1) = Xpos(7, 0) + CellWidth

Xpos(8, 0) = Xpos(7, 0)
Xpos(8, 1) = Xpos(8, 0) + CellWidth * 2

Xpos(9, 0) = Xpos(7, 1)
Xpos(9, 1) = Xpos(9, 0) + CellWidth


Form1.Picture2.ForeColor = 0
Y = (2 * YAdj) - YOff + 4

Form1.Picture2.Line (Xpos(1, 0) + 5, Y)-(Xpos(4, 0) - 5, Y), RGB(0, 0, 0), BF '
Form1.Picture2.Line (Xpos(4, 0) + 5, Y)-(Xpos(7, 0) - 5, Y), RGB(0, 0, 0), BF
Form1.Picture2.Line (Xpos(7, 0) + 5, Y)-(Xpos(9, 1) - 5, Y), RGB(0, 0, 0), BF




'XX = CTText(3, 45)
For x = 0 To CTTextNum
    YC = (val(CTText(1, x)) * YAdj) - YOff + 4
    If YC >= YMin And YC <= yMax Then
    

        Form1.Picture2.ForeColor = CTText(2, x)
        RL = Len(Str(MatPermNo)) + 1
        
        PV = 0
        PV = val(CTText(3, x))
        GoOn = 1
        For Y = 65 To 90 'scan for letters of alphabet
            If Y <> 69 Then ' exclude "e"
                If InStr(1, CTText(3, x), Chr(Y), vbTextCompare) > 0 Then
                    GoOn = 0
                    Exit For
                End If
            End If
        Next Y
        
        If (PV > 0 Or CTText(3, x) = "0") And PV <> 1 And GoOn = 1 Then
            PV = CLng(PV * (10 ^ (RL - 2))) / (10 ^ (RL - 2)) + 0.000000000001
            
            CTText(3, x) = Trim(Str(PV))
            If Left(CTText(3, x), 1) = "." Or Left(CTText(3, x), 1) = "," Then
                CTText(3, x) = "0" + Left(CTText(3, x), RL - 1)
            Else
                CTText(3, x) = Left(CTText(3, x), RL)
            End If
        End If
        If CTText(0, x) > 0 Then
            XC = Xpos(CTText(0, x), 0) + ((Xpos(CTText(0, x), 1) - Xpos(CTText(0, x), 0)) - (Form1.Picture2.TextWidth(CTText(3, x)))) / 2
            
            XX = Form1.Picture2.TextWidth(CTText(3, x))
            
        Else
            
            
            XC = 5
        End If
        Form1.Picture2.CurrentX = XC
        Form1.Picture2.CurrentY = YC
        Form1.Picture2.Print (CTText(3, x))
        
        x = x
        
    End If
    
Next x

Form1.Picture2.Refresh
End Sub

Public Sub DrawORFs()
    Dim LSeq As Long
    Dim StartExon As Long, EndExon As Long
    x = x
    'XX = GeneList(5).StartInAlign
    
    'check for only one frame
    Dim Frames(3) As Byte, OneFrameFlag As Byte
    For x = 1 To GeneNumber
        Frames(GeneList(x).Frame) = 1
        
    Next x
    
    'If there is only 1 frame make it the middle frame
    If Frames(1) + Frames(2) + Frames(3) = 1 Then
        For x = 1 To GeneNumber
            GeneList(x).Frame = 2
        Next x
        OneFrameFlag = 1
        FatGeneFlag = 1
    Else
        OneFrameFlag = 0
        FatGeneFlag = 0
    End If
    
    LSeq = Len(StrainSeq(0))
    Form1.Picture4.ScaleMode = 3
    Form1.Picture19.Picture = LoadPicture()
    'Form1.Picture20.Picture = LoadPicture()
    Form1.Picture11.ScaleMode = 3
    UnitLength = Form1.Picture4.ScaleWidth / LSeq
    
    UnitHeight = Int(Form1.Picture4.ScaleHeight / 6)
    
    UnitLengthII = Form1.Picture20.ScaleWidth / LSeq
    Form1.Picture4.AutoRedraw = True
        Form1.Picture4.ForeColor = 0
        Form1.Picture4.DrawMode = 13
        Form1.Picture4.DrawWidth = 1
        Form1.Picture11.AutoRedraw = True
        Form1.Picture11.ForeColor = RGB(0, 96, 96)
        Form1.Picture11.DrawMode = 12
        Form1.Picture11.DrawWidth = 1
        Form1.Picture19.AutoRedraw = True
        Form1.Picture19.ForeColor = 0
        Form1.Picture19.DrawMode = 13
        Form1.Picture19.DrawWidth = 1
        Form1.Picture19.ScaleMode = 3
        OMode = Form1.Picture10.ScaleMode
        Form1.Picture10.ScaleMode = 3
        Form1.Picture19.Height = Form1.Picture4.ScaleHeight + 3
        Form1.Picture20.Height = Form1.Picture4.ScaleHeight + 3
        Form1.Picture10.ScaleMode = OMode
    Dim PermUnitheight As Single
    PermUnitheight = UnitHeight
    ReDim SeqFeatureMap(-2 To Len(StrainSeq(0)) * 2)
    ReDim SeqFeatureTrace(-2 To Len(StrainSeq(0)) * 2)
    Dim SIL As Long, EIL As Long, GOri As Long
    
    Dim OBOW As Long
    UBOW = UBound(ORFWin, 2)
    
    Dim RNX As Long
    For Z = 1 To GeneNumber
        SIL = GeneList(Z).StartInAlign
        EIL = GeneList(Z).EndInAlign
        GOri = GeneList(Z).Orientation
        If EIL = SIL Then
            GeneList(Z).StartInAlign = -1
            GeneList(Z).EndInAlign = -1
            
        End If
        If GeneList(Z).StartInAlign > -1 Then '2
            
            If GeneList(Z).Frame = 3 Then
                ORFHeight = PermUnitheight
                FrameRef = 0
            ElseIf GeneList(Z).Frame = 2 Then
                ORFHeight = PermUnitheight * 3
                FrameRef = 1
            Else
                FrameRef = 2
                ORFHeight = PermUnitheight * 5
            End If
    
            If OneFrameFlag = 1 Then
                UnitHeight = PermUnitheight * 2
            End If
            
            If GeneList(Z).Orientation = 1 Then
               SeqFeatureMap(SIL) = 1 'genestart in +orientation ist nt
               SeqFeatureMap(SIL + 1) = 2 'genestart in +orientation 2nd nt
               SeqFeatureMap(SIL + 2) = 3 'genestart in +orientation 3rd nt
               SeqFeatureMap(EIL) = 4 'geneend in +orientation ist nt
               SeqFeatureMap(EIL - 1) = 5 'geneend in +orientation 2nd nt
               SeqFeatureMap(EIL - 2) = 6 'geneend in +orientation 3rd nt
               If GeneList(Z).IntronFlag = 1 Then
                    Call GetExonStats(CLng(Z), StartExon, EndExon)
                    If Z > StartExon Then
                        SeqFeatureMap(SIL - 1) = 20 '1st acceptor/donor site in intron + ori
                        SeqFeatureMap(SIL - 2) = 21 '2nd acceptor/donor site in intron + ori
                        SeqFeatureTrace(SIL - 1) = Z
                        SeqFeatureTrace(SIL - 2) = Z
                    End If
                    If Z < EndExon Then
                        SeqFeatureMap(EIL + 1) = 22 '1st acceptor/donor site in intron + ori
                        SeqFeatureMap(EIL + 2) = 23 '2nd acceptor/donor site in intron + ori
                        SeqFeatureTrace(EIL + 1) = Z
                        SeqFeatureTrace(EIL + 2) = Z
                    End If
                    
               End If
               
               SeqFeatureTrace(SIL) = Z
               SeqFeatureTrace(SIL + 1) = Z
               SeqFeatureTrace(SIL + 2) = Z
               SeqFeatureTrace(EIL) = Z
               SeqFeatureTrace(EIL - 1) = Z
               SeqFeatureTrace(EIL - 2) = Z
               
               If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1) Then
    
                    If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then '2178-2276,2348-2644
    
                        For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                        'Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight)
    
                        For A = 1 To Int(UnitHeight - 1)
                            Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 96, 96)
                            Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 96, 96)
                            Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A)
                        '    Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A)
                        Next 'A
    
                        Form1.Picture4.DrawWidth = 1
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Else
    
                        For F = 1 To GeneList(Z).EndInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                            
                        Next 'F
                        For F = GeneList(Z).StartInAlign To LSeq
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        'Form1.Picture4.Line (UnitLength * (GeneList(z).StartInAlign - 10), ORFHeight - UnitHeight + 1)-(UnitLength * (GeneList(z).StartInAlign - 100), ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        'Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                        'Form1.Picture19.Line (UnitLengthII * 1, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
    
                        For A = 0 To Int(UnitHeight - 1)
                            Form1.Picture11.Line (UnitLength * 1, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 96, 96)
                            Form1.Picture11.Line (UnitLength * 1, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 96, 96)
                            Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight - A), RGB(0, 0, 0)
                            Form1.Picture19.Line (UnitLengthII * 1, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign - A, ORFHeight + A), RGB(0, 0, 0)
                        Next 'A
    
                        Form1.Picture4.DrawWidth = 1
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign - UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    End If
                    
               Else
    
                    If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then
                        
                        For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        '        If GeneList(z + 1).Frame = 3 Then
                        '            ORFHeightII = UnitHeight
                        '        ElseIf GeneList(z + 1).Frame = 2 Then
                        '            ORFHeightII = UnitHeight * 3
                        '        Else
                        '            ORFHeightII = UnitHeight * 5
                        '        End If
                        'Form1.Picture4.Line (UnitLength * GeneList(z).EndInAlign, ORFHeight)-(UnitLength * GeneList(z + 1).StartInAlign, ORFHeightII)
                    Else
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * 1, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        Form1.Picture11.Line (UnitLength * 1, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
    
                        For F = GeneList(Z).StartInAlign To LSeq
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        For F = 1 To GeneList(Z).EndInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * LSeq, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture19.Line (UnitLengthII * 1, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    End If
    
               End If
                If Right(GeneList(Z).Product, 1) = "*" Or Right(GeneList(Z).Name, 1) = "*" Then
                    Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight), RGB(0, 0, 0)
                End If
                Form1.Picture4.DrawWidth = 1
            Else
                SeqFeatureMap(SIL) = 7 'genestart in -orientation ist nt
                SeqFeatureMap(SIL - 1) = 8 'genestart in -orientation 2nd nt
                SeqFeatureMap(SIL - 2) = 9 'genestart in -orientation 3rd nt
                SeqFeatureMap(EIL) = 10 'geneend in -orientation ist nt
                SeqFeatureMap(EIL + 1) = 11 'geneend in -orientation 2nd nt
                SeqFeatureMap(EIL + 2) = 12 'geneend in -orientation 3rd nt
                If GeneList(Z).IntronFlag = 1 Then
                    Call GetExonStats(CLng(Z), StartExon, EndExon)
                    If Z < EndExon Then
                        SeqFeatureMap(SIL + 1) = 24 '1st acceptor/donor site in intron - ori
                        SeqFeatureMap(SIL + 2) = 25 '2nd acceptor/donor site in intron - ori
                        SeqFeatureTrace(SIL + 1) = Z
                        SeqFeatureTrace(SIL + 2) = Z
                    End If
                    If Z > StartExon Then
                        SeqFeatureMap(EIL - 1) = 26 '1st acceptor/donor site in intron - ori
                        SeqFeatureMap(EIL - 2) = 27 '2nd acceptor/donor site in intron - ori
                        SeqFeatureTrace(EIL - 1) = Z
                        SeqFeatureTrace(EIL - 2) = Z
                    End If
                    
               End If
                SeqFeatureTrace(SIL) = Z
                SeqFeatureTrace(SIL - 1) = Z
                SeqFeatureTrace(SIL - 2) = Z
                SeqFeatureTrace(EIL) = Z
                SeqFeatureTrace(EIL + 1) = Z
                SeqFeatureTrace(EIL + 2) = Z
                
                If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = 1) Then
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then
                        'XX = UBound(ORFWin, 2)
                        
                        For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.DrawWidth = 1
                        'Form1.Picture11.Line (UnitLength * GeneList(z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1),RGB(0, 32, 32), BF
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
    
                        For A = 1 To Int(UnitHeight - 1)
                            Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 96, 96)
                            Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 96, 96)
                            Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                            Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                        Next 'A
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight)
                    Else
                        Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.DrawWidth = 1
                        'Form1.Picture11.Line (UnitLength * lseq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1),RGB(0, 32, 32), BF
    
                        For F = GeneList(Z).EndInAlign To LSeq
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        For F = 1 To GeneList(Z).StartInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 96, 96)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1 + UnitHeight * 2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
    
                        For A = 0 To Int(UnitHeight - 1)
                            Form1.Picture11.Line (UnitLength * LSeq, ORFHeight + A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 96, 96)
                            Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - A)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 96, 96)
                            Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight + A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight + A), RGB(0, 0, 0)
                            Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - A)-(UnitLengthII * GeneList(Z).EndInAlign + A, ORFHeight - A), RGB(0, 0, 0)
                        Next 'A
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign + A, ORFHeight)
                    End If
    
                Else
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then
    
                        For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        '   If GeneList(z + 1).Frame = 3 Then
                        '       ORFHeightII = UnitHeight
                        '   ElseIf GeneList(z + 1).Frame = 2 Then
                        '       ORFHeightII = UnitHeight * 3
                        '   Else
                        '       ORFHeightII = UnitHeight * 5
                        '   End If
                        'Form1.Picture4.Line (UnitLength * GeneList(z).EndInAlign, ORFHeight)-(UnitLength * GeneList(z + 1).StartInAlign, ORFHeightII)
                    Else
    
                        For F = 1 To GeneList(Z).StartInAlign
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        For F = GeneList(Z).EndInAlign To LSeq
                            If UBOW >= F Then
                                If ORFWin(FrameRef, F) = 0 Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    RNX = Rnd * 10
                                    If RNX <= 5 Then
                                            ORFWin(FrameRef, F) = Z
                                    End If
                                End If
                            Else
                                ORFWin(FrameRef, UBound(ORFWin, 2)) = Z
                            End If
                        Next 'F
    
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)
                        Form1.Picture4.Line (UnitLength * LSeq, ORFHeight + UnitHeight - 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture4.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).StartInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * 1, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        Form1.Picture11.Line (UnitLength * LSeq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 96, 96), BF
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * 1, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture19.Line (UnitLengthII * LSeq, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                        Form1.Picture19.Line (UnitLengthII * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight + UnitHeight - 1)
                    End If
    
                End If
    
                Form1.Picture4.DrawWidth = 1
                If Right(GeneList(Z).Product, 1) = "*" Or Right(GeneList(Z).Name, 1) = "*" Then
                    Form1.Picture4.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight)
                    Form1.Picture11.Line (UnitLength * GeneList(Z).EndInAlign, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(Z).EndInAlign, ORFHeight + UnitHeight), RGB(0, 0, 0)
                End If
            End If
        End If
        'Form1.Picture4.Line (UnitLength * GeneList(z).End - 5, ORFHeight - 3)-(UnitLength * GeneList(z).End, ORFHeight)
        'Form1.Picture4.Line (UnitLength * GeneList(z).End - 5, ORFHeight + 3)-(UnitLength * GeneList(z).End, ORFHeight)
    Next Z
    x = x
    'Form1.Picture20.Picture = Form1.Picture19.Image
    'Call DrawORFsP20
End Sub
Public Sub DrawORFsP20()
Dim Z As Long ', UBOW As Long
    
    Form1.Picture20.Picture = LoadPicture()
    Form1.Picture20.BackColor = Form1.Picture7.BackColor
    LSeq = Decompress(Len(StrainSeq(0)))
    UnitLength = Form1.Picture4.ScaleWidth / LSeq
    UnitHeight = Int(Form1.Picture4.ScaleHeight / 6)
    UnitLengthII = Form1.Picture20.ScaleWidth / LSeq
    Form1.Picture20.AutoRedraw = True
    Form1.Picture20.ForeColor = 0
    Form1.Picture20.DrawMode = 13
    Form1.Picture20.DrawWidth = 1
    Form1.Picture20.ScaleMode = 3
    
    Form1.Picture20.ScaleHeight = Form1.Picture4.ScaleHeight + 3

Form1.Picture20.AutoRedraw = True
Dim UBOW As Long
If GeneNumber > 0 Then
    UBOW = UBound(ORFWin, 2)
End If
For Z = 1 To GeneNumber
    If GeneList(Z).StartInAlign > -1 And GeneList(Z).StartInAlign <> GeneList(Z).EndInAlign Then
        'XX = GeneList(Z).EndInAlign
            If GeneList(Z).Frame = 3 Then
                ORFHeight = UnitHeight
                FrameRef = 0
            ElseIf GeneList(Z).Frame = 2 Then
                ORFHeight = UnitHeight * 3
                FrameRef = 1
            Else
                FrameRef = 2
                ORFHeight = UnitHeight * 5
            End If
    
            
            If GeneList(Z).Orientation = 1 Then
    
                If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = GeneList(Z).IntronFlag + 1) Then
    
                    If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then
                        '@'@
                        
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).StartInAlign, GeneList(Z).EndInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                                '@'@'@'@
                                If UBOW >= F Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    ORFWin(FrameRef, UBOW) = Z
                                End If
                            Next 'F
                        End If
                        XPos1 = UnitLengthII * (GeneList(Z).StartInAlign)
                        If GeneList(Z).StartInAlign > UBound(CurveArray, 1) Then
                            'GeneList(Z).StartInAlign = UBound(CurveArray, 1) - 1
                            ReDim Preserve CurveArray(GeneList(Z).StartInAlign + 1)
                        End If
                        If GeneList(Z).EndInAlign > UBound(CurveArray, 1) Then
                            'GeneList(Z).EndInAlign = UBound(CurveArray, 1)
                            ReDim Preserve CurveArray(GeneList(Z).EndInAlign + 1)
                        End If
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        If XPos1 > Form1.Picture20.Width Then
                            XPos1 = Form1.Picture20.Width
                        End If
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        If XPos2 > Form1.Picture20.Width Then
                            XPos2 = Form1.Picture20.Width
                        End If
                        '@'@
                        Form1.Picture20.Line (XPos1, ORFHeight)-(XPos2, ORFHeight)
    
                        For A = 1 To Int(UnitHeight - 1)
                            '@'@
                            Form1.Picture20.Line (XPos1, ORFHeight - A)-(XPos2 - A, ORFHeight - A)
                            Form1.Picture20.Line (XPos1, ORFHeight + A)-(XPos2 - A, ORFHeight + A)
                        Next 'A
                        x = x
    '                    If Z = 3 Then
    '            X = X
    '        End If
    
                    Else
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, 1, GeneList(Z).EndInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = 1 To GeneList(Z).EndInAlign
                                If UBOW >= F Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    ORFWin(FrameRef, UBOW) = Z
                                End If
                            Next 'F
                        End If
                        XX = UBound(CurveArray)
                        If GeneList(Z).StartInAlign <= UBound(CurveArray) Then
                            XPos1 = CLng(UnitLengthII * GeneList(Z).StartInAlign)
                            XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        Else
                            XPos1 = CLng(UnitLengthII * UBound(CurveArray))
                            If UBound(CurveArray) < GeneList(Z).StartInAlign Then
                                ReDim Preserve CurveArray(GeneList(Z).StartInAlign)
                            End If
                            XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        End If
                        If XPos1 > Form1.Picture20.Width Then
                            XPos1 = Form1.Picture20.Width
                        End If
                        XPos2 = UnitLengthII * LSeq
                        If LSeq <= UBound(CurveArray) Then
                            XPos2 = XPos2 * CurveArray(LSeq)
                        End If
                        If XPos2 > Form1.Picture20.Width Then
                            XPos2 = Form1.Picture20.Width
                        End If
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        XPos1 = UnitLengthII
                        Form1.Picture20.Line (XPos1, ORFHeight)-(XPos2, ORFHeight), RGB(0, 0, 0)
    
                        For A = 0 To Int(UnitHeight - 1)
                            Form1.Picture20.Line (XPos1, ORFHeight - A)-(XPos2 - A, ORFHeight - A), RGB(0, 0, 0)
                            Form1.Picture20.Line (XPos1, ORFHeight + A)-(XPos2 - A, ORFHeight + A), RGB(0, 0, 0)
                        Next 'A
                        x = x
                    End If
    
                Else
    
                    If GeneList(Z).StartInAlign < GeneList(Z).EndInAlign Then
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).StartInAlign, GeneList(Z).EndInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = GeneList(Z).StartInAlign To GeneList(Z).EndInAlign
                                ORFWin(FrameRef, F) = Z
                            Next 'F
                        End If
                        
                        XPos1 = UnitLengthII * GeneList(Z).StartInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture20.Line (XPos2, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1)
                        '        If GeneList(z + 1).Frame = 3 Then
                        '            ORFHeightII = UnitHeight
                        '        ElseIf GeneList(z + 1).Frame = 2 Then
                        '            ORFHeightII = UnitHeight * 3
                        '        Else
                        '            ORFHeightII = UnitHeight * 5
                        '        End If
                        'Form1.Picture4.Line (UnitLength * GeneList(z).EndInAlign, ORFHeight)-(UnitLength * GeneList(z + 1).StartInAlign, ORFHeightII)
                        x = x
                    Else
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).StartInAlign, LSeq, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                            Dummy = FillORFWin(Z, FrameRef, 1, GeneList(Z).EndInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = GeneList(Z).StartInAlign To LSeq
                                ORFWin(FrameRef, F) = Z
                            Next 'F
        
                            For F = 1 To GeneList(Z).EndInAlign
                                ORFWin(FrameRef, F) = Z
                            Next 'F
                        End If
                        XPos1 = UnitLengthII * GeneList(Z).StartInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        
                        XPos1 = UnitLengthII * LSeq
                        XPos1 = XPos1 * CurveArray(LSeq)
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        
                        XPos1 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).EndInAlign)
                        
                        
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos1, ORFHeight + UnitHeight - 1)
                        x = x
                    End If
    
                End If
    
                Form1.Picture4.DrawWidth = 1
            Else
    
                If GeneList(Z).IntronFlag = 0 Or (GeneList(Z).IntronFlag > 0 And GeneList(Z).ExonNumber = GeneList(Z).IntronFlag) Then
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then '1876-1514,2616-2055,2616-1877
                        '@'@'@'@
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).EndInAlign, GeneList(Z).StartInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                                
                                If UBOW >= F Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    ORFWin(FrameRef, UBOW) = Z
                                End If
                            Next 'F
                        End If
                        XPos1 = UnitLengthII * (GeneList(Z).StartInAlign)
                        If GeneList(Z).StartInAlign > UBound(CurveArray, 1) Then
                            'GeneList(Z).StartInAlign = UBound(CurveArray, 1) - 1
                            ReDim Preserve CurveArray(GeneList(Z).StartInAlign + 1)
                        End If
                        If GeneList(Z).EndInAlign > UBound(CurveArray, 1) Then
                            'GeneList(Z).EndInAlign = UBound(CurveArray, 1)
                            ReDim Preserve CurveArray(GeneList(Z).EndInAlign + 1)
                        End If
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        If XPos1 > Form1.Picture20.Width Then
                            XPos1 = Form1.Picture20.Width
                        End If
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        If XPos2 > Form1.Picture20.Width Then
                            XPos2 = Form1.Picture20.Width
                        End If
                        '@
                        Form1.Picture20.Line (XPos1, ORFHeight)-(XPos2, ORFHeight)
                        
                        'Form1.Picture20.Line (UnitLengthII * GeneList(Z).StartInAlign, ORFHeight)-(UnitLengthII * GeneList(Z).EndInAlign, ORFHeight), RGB(0, 0, 0)
    
                        For A = 1 To Int(UnitHeight - 1)
                            Form1.Picture20.Line (XPos1, ORFHeight - A)-(XPos2 + A, ORFHeight - A)
                            Form1.Picture20.Line (XPos1, ORFHeight + A)-(XPos2 + A, ORFHeight + A)
                        Next 'A
                        x = x
                    Else
                        'Form1.Picture11.Line (UnitLength * lseq, ORFHeight - UnitHeight + 1)-(UnitLength * GeneList(z).EndInAlign + UnitHeight * 2, ORFHeight + UnitHeight - 1),RGB(0, 32, 32), BF
                        
                        
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).EndInAlign, LSeq, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                            Dummy = FillORFWin(Z, FrameRef, 1, GeneList(Z).StartInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                        
                            For F = GeneList(Z).EndInAlign To LSeq
                                If UBOW >= F Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    ORFWin(FrameRef, UBOW) = Z
                                End If
                            Next 'F
                            For F = 1 To GeneList(Z).StartInAlign
                                If UBOW >= F Then
                                    ORFWin(FrameRef, F) = Z
                                Else
                                    ORFWin(FrameRef, UBOW) = Z
                                End If
                            Next 'F
                        End If
                        XPos1 = UnitLengthII * GeneList(Z).StartInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        XPos2 = UnitLengthII * LSeq
                        If LSeq <= UBound(CurveArray) Then
                            XPos2 = XPos2 * CurveArray(LSeq)
                        End If
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        XPos1 = UnitLengthII
                        Form1.Picture20.Line (XPos1, ORFHeight)-(XPos2, ORFHeight), RGB(0, 0, 0)
                        
                        For A = 0 To Int(UnitHeight - 1)
                            Form1.Picture20.Line (XPos1, ORFHeight - A)-(XPos2 + A, ORFHeight - A), RGB(0, 0, 0)
                            Form1.Picture20.Line (XPos1, ORFHeight + A)-(XPos2 + A, ORFHeight + A), RGB(0, 0, 0)
                        Next 'A
                        x = x
                    End If
    
                Else
    
                    If GeneList(Z).StartInAlign > GeneList(Z).EndInAlign Then '1876-1514
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).EndInAlign, GeneList(Z).StartInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = GeneList(Z).EndInAlign To GeneList(Z).StartInAlign
                                ORFWin(FrameRef, F) = Z
                            Next 'F
                        End If
                        XPos1 = UnitLengthII * GeneList(Z).StartInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        If XPos1 > Form1.Picture20.Width Then
                            XPos1 = Form1.Picture20.Width
                        End If
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        If XPos2 > Form1.Picture20.Width Then
                            XPos2 = Form1.Picture20.Width
                        End If
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        Form1.Picture20.Line (XPos2, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1)
                        
                       
                        '   If GeneList(z + 1).Frame = 3 Then
                        '       ORFHeightII = UnitHeight
                        '   ElseIf GeneList(z + 1).Frame = 2 Then
                        '       ORFHeightII = UnitHeight * 3
                        '   Else
                        '       ORFHeightII = UnitHeight * 5
                        '   End If
                        'Form1.Picture4.Line (UnitLength * GeneList(z).EndInAlign, ORFHeight)-(UnitLength * GeneList(z + 1).StartInAlign, ORFHeightII)
                        x = x
                    Else
                        If x = x Then
                            Dummy = FillORFWin(Z, FrameRef, 1, GeneList(Z).StartInAlign, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                            Dummy = FillORFWin(Z, FrameRef, GeneList(Z).EndInAlign, LSeq, UBound(ORFWin, 1), UBound(ORFWin, 2), ORFWin(0, 0))
                        Else
                            For F = 1 To GeneList(Z).StartInAlign
                                ORFWin(FrameRef, F) = Z
                            Next 'F
        
                            For F = GeneList(Z).EndInAlign To LSeq
                                ORFWin(FrameRef, F) = Z
                            Next 'F
                        End If
                        XPos1 = UnitLengthII * GeneList(Z).StartInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).StartInAlign)
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        
                        XPos1 = UnitLengthII * LSeq
                        XPos1 = XPos1 * CurveArray(LSeq)
                        XPos2 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos2 = XPos2 * CurveArray(GeneList(Z).EndInAlign)
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos2, ORFHeight + UnitHeight - 1), RGB(0, 0, 0), BF
                        
                        XPos1 = UnitLengthII * GeneList(Z).EndInAlign
                        XPos1 = XPos1 * CurveArray(GeneList(Z).EndInAlign)
                        
                        
                        
                        Form1.Picture20.Line (XPos1, ORFHeight - UnitHeight + 1)-(XPos1, ORFHeight + UnitHeight - 1)
                        x = x
                    End If
    
                End If
    
            End If
        End If
        'Form1.Picture4.Line (UnitLength * GeneList(z).End - 5, ORFHeight - 3)-(UnitLength * GeneList(z).End, ORFHeight)
        'Form1.Picture4.Line (UnitLength * GeneList(z).End - 5, ORFHeight + 3)-(UnitLength * GeneList(z).End, ORFHeight)
    Next Z
    
    
    
    Dim P20XFactor As Double
    
    If ManFlag = -1 Then
        If RecStart > UBound(CurveArray, 1) Then RecStart = UBound(CurveArray, 1)
        If RecEnd > UBound(CurveArray, 1) Then RecEnd = UBound(CurveArray, 1)
        
        P20XFactor = Form1.Picture20.ScaleWidth / Decompress(Len(StrainSeq(0)))
        LineStart = CLng(P20XFactor * RecStart * CurveArray(RecStart)) - 1
        LineEnd = CLng(P20XFactor * RecEnd * CurveArray(RecEnd)) + 1
    
        If LineEnd > LineStart Then
            Form1.Picture20.DrawMode = 5
            Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF 'RGB(255 - BkR, 255 - BkG, 255 - BkB), BF
            Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
            Form1.Picture20.DrawMode = 13
        Else
            Form1.Picture20.DrawMode = 5
            Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF
            Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF
            Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
            Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
            Form1.Picture20.DrawMode = 13
        End If
    End If
    
  x = x
End Sub
Public Sub DoSeqZoom(Index As Integer)
Dim tTYF As Double, TYFM As Integer, OSM As Long, DiffY As Long
    Dim OM As Long, TS(3) As Double, OV As Long, OFS As Double, otTYF As Double, IndexX As Byte, CurrentSeq As Long, OFS2 As Single
Dim OI As Long, oD As Long
        
        
        If P1FontSize <> 0 Then
            Form1.Picture1.FontSize = P1FontSize * TYF
        End If
         
        Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
        Dim Tw1 As Single, GoPosX As Single, GoPosY As Single
        Tw1 = CSng(Form1.Picture1.TextWidth("ACGTAAAAAAAAAAAAAAAA") / 20)
        'Tw1 = (Form1.Picture9.Width / Screen.TwipsPerPixelX) / Tw1 / 2
        Tw1 = (Form1.Picture9.ScaleWidth / Tw1) / 2
        Dim oMidNt As Long
        oMidNt = -1
        If P1NT = -1 Then
            GoPosX = (WinLeft + Tw1)
            
        Else
            GoPosX = P1NT
            'F1P1Y = F1P1Y - VScroll3.Value
            F1P1Y = F1P1Y
            oMidNt = (WinLeft + Tw1) - GoPosX
            'P1NT = -1
        End If
    
    
        VSV = Form1.VScroll3.Value / ScrollSF
        OSM = Form1.Picture8.ScaleMode
        
        Form1.Picture8.ScaleMode = 3
        Form1.Picture3.ScaleMode = 3
        Form1.Picture3.Height = Form1.Picture8.ScaleHeight
        p3h = Form1.Picture3.Height
        
        If P1Seq = -1 Then
            'find the middle sequence
            Y = CLng(Form1.Picture3.Height / 2 + VSV)
            Form1.Picture8.ScaleMode = OSM
            
            CurrentSeq = CLng(Y / 13 / (tTYF * ttyfAdjust))
            'XX = StraiName(CurrentSeq)
            x = x
        Else
            CurrentSeq = P1Seq
            Y = P1Seq * 13 * tTYF * ttyfAdjust
            DiffY = F1P1Y - Form1.VScroll3.Value
        End If
        
        
        If Index = 0 Then 'Zoom out button for the sequence display
            
            
            Form1.Command33(1).Enabled = True
            Do
                TYF = TYF - 0.075
                TS(0) = Form1.Picture1.TextWidth("A")
                If TYF < 0.2 Then TYF = 0.2
                Form1.Picture1.AutoRedraw = True
                Form1.Picture1.FontSize = P1FontSize * TYF
                Form1.Picture3.FontSize = 7 * TYF
                TS(1) = Form1.Picture1.TextWidth("A")
                If TS(0) <> TS(1) Then Exit Do ' = 18 Or Picture1.FontSize = 16.5 Or Picture1.FontSize = 14.25 Or Picture1.FontSize = 10.5 Or Picture1.FontSize = 2.25 Or Picture1.FontSize = 6 Or Picture1.FontSize = 8.25 Or Picture1.FontSize = 4.5 Then
                If TYF = 0.2 Then Exit Do
            Loop
            Form1.Picture1.AutoRedraw = True
            Form1.Picture3.AutoRedraw = True
            'Form1.Picture1.Picture = LoadPicture()
            'Form1.Picture3.Picture = LoadPicture()
            Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
            
            Call CalcttyfAdjust(TYFM, tTYF, 0, 0)
            
            P1OH = (((NextNo + 2) * 13) - TYFM) * tTYF * ttyfAdjust
            P3OH = P1OH
            
            If TYF <= 0.28 Then Form1.Command33(0).Enabled = False
        ElseIf Index = 1 Then 'zoom in button
            
            Form1.Command33(0).Enabled = True
             
            Do
                
                TYF = TYF + 0.075
                TS(0) = Form1.Picture1.TextWidth("A")
                If TYF > 2 Then TYF = 2
                Form1.Picture1.AutoRedraw = True
                Form1.Picture1.FontSize = P1FontSize * TYF
                Form1.Picture3.FontSize = 7 * TYF
                If TYF = 2 Then Exit Do
                TS(1) = Form1.Picture1.TextWidth("A")
                If TS(0) <> TS(1) Then Exit Do 'Picture1.FontSize = 18 Or Picture1.FontSize = 16.5 Or Picture1.FontSize = 14.25 Or Picture1.FontSize = 10.5 Or Picture1.FontSize = 2.25 Or Picture1.FontSize = 6 Or Picture1.FontSize = 8.25 Or Picture1.FontSize = 4.5 Then
            Loop
            Form1.Picture1.AutoRedraw = True
            Form1.Picture3.AutoRedraw = True
            'Form1.Picture1.Picture = LoadPicture()
            'Form1.Picture3.Picture = LoadPicture()
            Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
            Call CalcttyfAdjust(TYFM, tTYF, 0, 0)
            P1OH = (((NextNo + 2) * 13) - TYFM) * tTYF * ttyfAdjust
            P3OH = P1OH
            
            If TYF >= 2 Then Form1.Command33(1).Enabled = False
        
        End If
        
        
        
        'get the middle sequence
        
        If oMidNt = -1 Then
            Y = CLng(CurrentSeq * tTYF * ttyfAdjust * 13)
            VSV = CLng((Y - p3h / 2) * ScrollSF)
        Else
            mody = (F1P1Y / p3h)
            Y = CLng((CurrentSeq + 0.5) * 13 * tTYF * ttyfAdjust)
            'CLng(Y / 13 / tTYF)
            VSV = CLng((Y - p3h * mody) * ScrollSF)
        
        End If
        H1C = 1
        With Form1.VScroll3
            
            .Visible = False
            
            If -Form1.Picture9.ScaleHeight + P1OH < 32000 Then
                .Max = (-Form1.Picture9.ScaleHeight + P1OH)
                ScrollSF = 1
            Else
                ScrollSF = 32000 / (-Form1.Picture9.ScaleHeight + P1OH)
                .Max = 32000
            End If
    
            If .Max <= 0 Then
                .Max = 0
                .Enabled = False
            Else
                .LargeChange = Form1.Picture9.ScaleHeight
                .Enabled = True
            End If
            If ShowSeqFlag = 0 Then
                If VSV < 0 Then VSV = 0
                If VSV > .Max Then VSV = .Max
            Else
                VSV = 0
            End If
            .Value = VSV
            .Visible = True
            
            
           
            Dim H1V As Long
            
            
            
            'Call HScroll1_Change
            
            If ColDistInFile = 1 Then
                
                ReDim ColDist2(0)
                Form1.Timer7(1).Enabled = False
            End If
            
        End With
        
        
        'Now do Hscroll1
        
        H1C = 1
        PrintSeqLen = MakePrintSeqLen
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            If Len(StrainSeq(0)) - (PrintSeqLen - 5) > 32000 Then
                HScroll1Mod = CLng(Len(StrainSeq(0)) / 32000) + 1
                Form1.HScroll1.Max = (Len(StrainSeq(0)) - (PrintSeqLen - 5)) / HScroll1Mod
            Else
                HScroll1Mod = 1
                Form1.HScroll1.Max = Len(StrainSeq(0)) - (PrintSeqLen - 5)
            End If
        Else
            HScroll1Mod = CLng(UBound(Recompress, 1) / 32000) + 1
            Form1.HScroll1.Max = (UBound(Recompress, 1) - (PrintSeqLen - 5)) / HScroll1Mod
        End If
        Tw1 = Form1.Picture1.TextWidth("A")
        Tw1 = Form1.Picture9.ScaleWidth / Tw1 / 2
        H1V = Form1.HScroll1.Value
        lH1V = H1V
        H1C = 1 'need this to stop a alignment display screen update wen changing hscroll1 value
        If oMidNt = -1 Then 'zoom to the middle nt
            If Len(StrainSeq(0)) - Tw1 > 0 And Len(StrainSeq(0)) - Tw1 < UBound(Decompress, 1) Then
                If GoPosX > Tw1 And GoPosX < Decompress(Len(StrainSeq(0)) - Tw1) Then
                    H1V = CLng(((GoPosX - Tw1))) / HScroll1Mod 'CLng(((GoPosX - Tw1) / (Decompress(Len(StrainSeq(0))) - Tw1 * 2)) * HScroll1.Max)
                    If H1V = 0 Then H1V = 1
                    If H1V >= 0 And H1V <= Form1.HScroll1.Max Then
                        Form1.HScroll1.Value = H1V
                    End If
                    
                ElseIf GoPosX <= Tw1 Then
                    
                    Form1.HScroll1.Value = Form1.HScroll1.Min
                Else
                    Form1.HScroll1.Value = Form1.HScroll1.Max
                End If
            Else
               
'                OI = Form1.Timer3.Interval
'                OD = Form1.Timer3.Enabled
'                Form1.Timer3.Interval = 27
'                Form1.Timer3.Enabled = True
                'Sleep 30
                'DoEvents
                'Form1.Timer3.Enabled = OD
                'Form1.Timer3.Interval = OI
                
            End If
        Else ' zoom to the nt under the mouse pointer
            'where in the horizontal plane is the mousepointer relative to the left hand side
            Tw1 = CSng(Form1.Picture1.TextWidth("ACGTAAAAAAAAAAAAAAAA") / 20)
            'Tw1 = CLng(F1P1X / Tw1)
            GoPosX = CLng((P1NT - Int((F1P1X / Tw1))) / HScroll1Mod)  '+ 1
'            If Index = 0 Then 'up arrow zoom out
'                GoPosX = P1NT - Int((F1P1X / Tw1) - 0.5) '+ 1
'            ElseIf Index = 1 Then 'down arrow zoom in
'                GoPosX = P1NT - Int((F1P1X / Tw1) - 0.5) '+ 1
'            End If
            
            If GoPosX > Tw1 And GoPosX < Decompress(Len(StrainSeq(0)) - Tw1) Then
                H1V = GoPosX 'CLng(((GoPosX - Tw1))) 'CLng(((GoPosX - Tw1) / (Decompress(Len(StrainSeq(0))) - Tw1 * 2)) * HScroll1.Max)
                If H1V >= 0 And H1V <= Form1.HScroll1.Max Then
                    Form1.HScroll1.Value = H1V
                End If
                
            ElseIf GoPosX <= Tw1 Then
                
                Form1.HScroll1.Value = Form1.HScroll1.Min
            Else
                Form1.HScroll1.Value = Form1.HScroll1.Max
            End If
        End If
        'If lH1V = HScroll1.Value Then Call HScroll1_Change
        H1C = 0
'        If H1V <> GoPosX Or HScroll1.Value <> GoPosX Then
'            X = X
'        End If
        DontDoH1Inc = 1
'        If Form1.HScroll1.Max < Decompress(Len(StrainSeq(0))) Then
'            H1C = 1
'            If Index = 0 Then
'               ' Form1.HScroll1.Value = Form1.HScroll1.Value + 1
'            Else
'                'Form1.HScroll1.Value = Form1.HScroll1.Value + 2
'            End If
'        End If
        
        
        H1C = 1
        If Form1.HScroll1.Enabled = True And Form1.HScroll1.Max > 0 Then
            If Form1.HScroll1.Value > Form1.HScroll1.Min Then
                Form1.HScroll1.Value = Form1.HScroll1.Value - 1
                H1C = 0
                Form1.HScroll1.Value = Form1.HScroll1.Value + 1
            Else
                If Form1.HScroll1.Value < Form1.HScroll1.Max Then
                    Form1.HScroll1.Value = Form1.HScroll1.Value + 1
                    H1C = 0
                    Form1.HScroll1.Value = Form1.HScroll1.Value - 1
                End If
            End If
        Else
            OI = Form1.Timer3.Interval
            oD = Form1.Timer3.Enabled
            Form1.Timer3.Enabled = False
            Form1.Timer3.Interval = 27
            Form1.Timer3.Enabled = True
            Sleep 30
            DoEvents 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxpotentially dangerous
            Form1.Timer3.Enabled = oD
            Form1.Timer3.Interval = OI
        End If
        
        If ShowSeqFlag = 0 Then
            Call PrintNames
        Else
            Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
        End If
        
        'Call HScroll1_Change
        DontDoH1Inc = 0
'        If H1V <> GoPosX Or HScroll1.Value <> GoPosX Then
'            X = X
'        End If
        'Form1.Refresh
        On Error Resume Next
        Form1.Picture1.SetFocus
        On Error GoTo 0
End Sub
Public Sub DoSeqDisplay()

Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
Dim LBrush As LOGBRUSH, LoFnt As Long, OldFont As Long
Dim AdjVSVModY As Single

Dim Dummy As Long, x As Long, ZZ As Long, Y As Long, UB As Long, Pict As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, OS As String, tTYF As Double, TYFM As Integer, VSV As Long, P9H As Long
Dim P1fs As Single, XCOnAx As Single
If H1C = 1 Then
    H1C = 0
    Exit Sub
End If
If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
   UB = UBound(SeqLines, 2)
   If UB = -1 Then Exit Sub
On Error GoTo 0





'Set Form1.Picture1.Picture = Nothing
'Form1.Picture1.BackColor = BackColours


Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
P1fs = Form1.Picture1.FontSize

Pict = Form1.Picture1.hdc
Form1.Picture1.FillColor = BackColours
'@
Form1.Picture1.ForeColor = BackColours




'
Dummy = Rectangle(Pict, 0, 0, Form1.Picture9.ScaleWidth, Form1.Picture9.ScaleHeight)


Dim TW As Single, TH As Single, ModYV As Long
TH = Form1.Picture1.TextHeight("A")
TW = Form1.Picture1.TextWidth("A")
If TH = 15 And TW = 7 Then
  
    If TYFM = 2 Then
        ModYV = 0
    ElseIf TYFM = 3 Then
        ModYV = 1
    Else
        ModYV = 3
    End If
ElseIf TH = 29 And TW = 16 Then
    If TYFM = 1 Then
        If tTYF = 2 Then
            ModYV = -2
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 33 And TW = 18 Then
    If TYFM = 1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 30 And TW = 16 Then
    If TYFM = 1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 29 And TW = 15 Then
    If TYFM = 1 Then
        If tTYF = 1.875 Then
            ModYV = 0
        Else
            ModYV = 1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 18 And TW = 10 Then
    If TYFM = 2 Then
        ModYV = -1
    ElseIf TYFM = 0 Then
        If tTYF = 1 Then
            ModYV = 2
        Else
            ModYV = -1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 14 And TW = 7 Then
    If TYFM = 2 Then
        ModYV = 0
    Else
        ModYV = 1
    End If
ElseIf TH = 27 And TW = 14 Then
    If TYFM = 1 Then
        If tTYF > 1.37 And tTYF < 1.38 Then
           ModYV = 2
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 2
    End If
ElseIf TH = 25 And TW = 14 Then
   
    
    If TYFM = 1 Then
        If tTYF > 1.749 And tTYF < 1.75 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 3
    End If
   
ElseIf TH = 24 And TW = 13 Then
    If TYFM = 1 Then
        If tTYF > 1.624 And tTYF < 1.625 Then
            ModYV = -1
        Else
            ModYV = 1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 23 And TW = 13 Then
    If TYFM = 1 Then
        If tTYF > 1.623 And tTYF < 1.624 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 36 And TW = 19 Then
    ModYV = 3
ElseIf TH = 20 And TW = 10 Then
    If TYFM = 2 Then
        If tTYF > 1.249 And tTYF < 1.25 Then
           ModYV = -1
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 16 And TW = 8 Then
    If TYFM = 0 Then
        If tTYF = 1 Then
           ModYV = 1
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 17 And TW = 9 Then
    If TYFM = 2 Then
        If tTYF > 1.124 And tTYF < 1.126 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 17 And TW = 8 Then
    If TYFM = 3 Then
        If tTYF > 1# And tTYF < 1.001 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 12 And TW = 6 Then
   If TYFM = 1 Then
        ModYV = 0
    ElseIf TYFM = -1 Then
        ModYV = 2
    Else
        ModYV = 3
    End If
ElseIf TH = 8 And TW = 4 Then
    If TYFM = 1 Then
        ModYV = 0
    ElseIf TYFM = -1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 12 And TW = 5 Then
    If TYFM = 3 Then
        ModYV = 0
    ElseIf TYFM = 1 Then
        ModYV = 2
    Else
        ModYV = 2
    End If
   
ElseIf TH = 6 And TW = 3 Then
    If TYFM = 0 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 3 And TW = 2 Then
    If TYFM = -1 Then
        ModYV = 0
    Else
        ModYV = 0
    End If
Else
    ModYV = 0
End If

'(X * 13 - TYFM) * tTYF)
'Form1.Picture1.Cls
'Picture1.FillColor = RGB(64, 64, 255)
'Picture1.ForeColor = RGB(64, 64, 255)
'Dummy = Rectangle(Pict, ((Y * 8) - 8) * tTYF, 0, (Y * 8) * tTYF, ((NextNo) * 13 + 12) * tTYF)
'XX = Form1.Picture1.AutoRedraw
If UBound(SeqLines, 2) < NumSeqLines Then
    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
End If
SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
SeqLines(1, NumSeqLines) = RGB(64, 64, 255) 'colour of thing to draw
SeqLines(2, NumSeqLines) = Y * 8 - 8 'X1
SeqLines(3, NumSeqLines) = 0 'Y1
SeqLines(4, NumSeqLines) = Y * 8 'X2
SeqLines(5, NumSeqLines) = (NextNo) * 13 + 12 'Y2
NumSeqLines = NumSeqLines + 1

VSV = Form1.VScroll3.Value / ScrollSF
P9H = Form1.Picture9.ScaleHeight
'XX = Form1.Picture1.AutoRedraw

'ZZ = -1000000
'For x = 0 To NumSeqLines - 1
'    If ZZ < SeqLines(3, x) * tTYF - VSV Then 'vsv=35856, ttyf=0.75'min=-4851
'        ZZ = SeqLines(3, x) * tTYF - VSV
'    End If
'Next x

Dim Targ As Long
Targ = P9H + 300

'Pict = Form1.Picture1.hDC


LBrush.lbColor = BackColours
'Form1.Picture1.ForeColor = BackColours
LPen.lopnColor = BackColours
Dim StartX As Long, FirstSeq As Long
Call CalcttyfAdjust(TYFM, tTYF, FirstSeq, SeqSpaceIncrement)
Dim TCA As Single
TCA = tTYF * XConA

If x = x Then
    '@
    StartX = SeqColBlocks(Pict, UBound(SeqLines, 1), CDbl(tTYF * ttyfAdjust), TCA, XConA, NumSeqLines, Targ, VSV, SeqLines(0, 0))
x = x
Else
    PEN = CreatePenIndirect(LPen)
    oldpen = SelectObject(Pict, PEN)
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    
    
    For x = 0 To NumSeqLines - 1
        If SeqLines(0, x) = 0 Then 'rectangle
            
            Y1 = SeqLines(3, x) * tTYF - VSV  'Y1
            Y2 = SeqLines(5, x) * tTYF - VSV  'Y2
            If (Y1 >= 0 And Y2 <= Targ) Or (Y1 <= 0 And Y2 >= Targ) Or (Y1 >= 0 And Y1 <= Targ) Or (Y2 >= 0 And Y2 <= Targ) Then
                '@
               LBrush.lbColor = SeqLines(1, x)
                LPen.lopnColor = SeqLines(1, x)
                
                PEN = CreatePenIndirect(LPen)
                Pen2 = SelectObject(Pict, PEN)
                Brush = CreateBrushIndirect(LBrush)
                Brush2 = SelectObject(Pict, Brush)
    '            Form1.Picture1.FillColor = SeqLines(1, x)
    '            Form1.Picture1.ForeColor = SeqLines(1, x)
                X1 = SeqLines(2, x) * TCA 'X1
                X2 = SeqLines(4, x) * TCA 'X2
                
                DeleteObject (Pen2)
                DeleteObject (Brush2)
                
                Dummy = Rectangle(Pict, X1, Y1, X2, Y2)
                x = x
            End If
        Else
            Exit For
        End If
    Next x
    StartX = x
    Brush = SelectObject(Pict, OldBrush)
    DeleteObject (Brush)
    PEN = SelectObject(Pict, oldpen)
    DeleteObject (PEN)
End If
'@
Form1.Picture1.ForeColor = 0
'Form1.Picture1.DrawMode = 6


'now do the text
'XX = Form1.HScroll1.Value
Dim LOS As Long
For x = StartX To NumSeqLines - 1
    If SeqLines(0, x) <> 0 Then
        Y1 = (SeqLines(3, x) - TYFM) * tTYF - VSV - ModYV 'yposition
        If Y1 > -30 And Y1 < Targ Then
            LOS = Len(SeqText(SeqLines(1, x)))
            Exit For
        End If
    End If
   
Next x



AdjVSVModY = VSV + ModYV

'Form1.Picture1.FontBold = False


'Dim OldFont As Long
'LoFnt = CreateFont(Form1.Picture1.TextHeight("O"), Form1.Picture1.TextWidth("O"), 0, 0, 0, 0, 0, 0, 0, OUT_DEVICE_PRECIS, 0, CLEARTYPE_QUALITY, 0, Form1.Picture1.Font.Name)
'OldFont = SelectObject(Pict, LoFnt)

'Dim FirstSeq As Long


Dim LastY1 As Long
'Form1.Picture1.ForeColor = RGB(90, 90, 90)

For x = StartX To NumSeqLines - 1
    If SeqLines(0, x) <> 0 Then
'        Y1 = (SeqLines(3, x) - TYFM) * tTYF - AdjVSVModY 'VSV - ModYV 'yposition
        Y1 = (SeqLines(3, FirstSeq) - TYFM) * tTYF - AdjVSVModY 'VSV - ModYV 'yposition
        Y1 = Y1 + (x - FirstSeq) * SeqSpaceIncrement
        If Y1 > -30 And Y1 < Targ Then
            
            'OS = SeqText(SeqLines(1, x)) 'position of string in seqtext
            'X1 = SeqLines(2, x) * tTYF 'xposition

            
            'TextOut Pict, X1, Y1, OS, LOS
            '@
            TextOut Pict, 0, Y1, SeqText(SeqLines(1, x)), LOS
            'XX = InStr(1, OS, "---AAAGCAACT", vbBinaryCompare)
            'Y = Y + 1
            x = x
        End If
    End If
   
Next x


'LoFnt = SelectObject(Pict, OldFont)
'DeleteObject LoFnt

'@
'Form1.Picture1.DrawMode = 13
'@
'Form1.Picture1.Refresh
x = x
End Sub
Public Sub DoSeqDisplayDIB(dibHDC As Long)

Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
Dim LBrush As LOGBRUSH, LoFnt As Long, OldFont As Long
Dim StartX As Long
Dim Dummy As Long, x As Long, ZZ As Long, Y As Long, UB As Long, Pict As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, OS As String, tTYF As Double, TYFM As Integer, VSV As Long, P9H
Dim P1fs As Single, XCOnAx As Single
If H1C = 1 Then
    H1C = 0
    Exit Sub
End If
If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
   UB = UBound(SeqLines, 2)
   If UB = -1 Then Exit Sub
On Error GoTo 0

Pict = dibHDC



'Pict = Form1.Picture1.hdc



'

'Set Form1.Picture1.Picture = Nothing
'Form1.Picture1.BackColor = BackColours


Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
P1fs = Form1.Picture1.FontSize




Dim TW As Single, TH As Single, ModYV As Long
Form1.Picture1.ScaleMode = 3
TH = Form1.Picture1.TextHeight("A")
TW = Form1.Picture1.TextWidth("A")
If TH = 15 And TW = 7 Then
  
    If TYFM = 2 Then
        ModYV = 0
    ElseIf TYFM = 3 Then
        ModYV = 1
    Else
        ModYV = 3
    End If
ElseIf TH = 29 And TW = 16 Then
    If TYFM = 1 Then
        If tTYF = 2 Then
            ModYV = -2
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 33 And TW = 18 Then
    If TYFM = 1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 30 And TW = 16 Then
    If TYFM = 1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 29 And TW = 15 Then
    If TYFM = 1 Then
        If tTYF = 1.875 Then
            ModYV = 0
        Else
            ModYV = 1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 18 And TW = 10 Then
    If TYFM = 2 Then
        ModYV = -1
    ElseIf TYFM = 0 Then
        If tTYF = 1 Then
            ModYV = 2
        Else
            ModYV = -1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 14 And TW = 7 Then
    If TYFM = 2 Then
        ModYV = 0
    Else
        ModYV = 1
    End If
ElseIf TH = 27 And TW = 14 Then
    If TYFM = 1 Then
        If tTYF > 1.37 And tTYF < 1.38 Then
           ModYV = 2
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 2
    End If
ElseIf TH = 25 And TW = 14 Then
   
    
    If TYFM = 1 Then
        If tTYF > 1.749 And tTYF < 1.75 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 3
    End If
   
ElseIf TH = 24 And TW = 13 Then
    If TYFM = 1 Then
        If tTYF > 1.624 And tTYF < 1.625 Then
            ModYV = -1
        Else
            ModYV = 1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 23 And TW = 13 Then
    If TYFM = 1 Then
        If tTYF > 1.623 And tTYF < 1.624 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 36 And TW = 19 Then
    ModYV = 3
ElseIf TH = 20 And TW = 10 Then
    If TYFM = 2 Then
        If tTYF > 1.249 And tTYF < 1.25 Then
           ModYV = -1
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 16 And TW = 8 Then
    If TYFM = 0 Then
        If tTYF = 1 Then
           ModYV = 1
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 17 And TW = 9 Then
    If TYFM = 2 Then
        If tTYF > 1.124 And tTYF < 1.126 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 17 And TW = 8 Then
    If TYFM = 3 Then
        If tTYF > 1# And tTYF < 1.001 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 12 And TW = 6 Then
   If TYFM = 1 Then
        ModYV = 0
    ElseIf TYFM = -1 Then
        ModYV = 2
    Else
        ModYV = 3
    End If
ElseIf TH = 8 And TW = 4 Then
    If TYFM = 1 Then
        ModYV = 0
    ElseIf TYFM = -1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 12 And TW = 5 Then
    If TYFM = 3 Then
        ModYV = 0
    ElseIf TYFM = 1 Then
        ModYV = 2
    Else
        ModYV = 2
    End If
   
ElseIf TH = 6 And TW = 3 Then
    If TYFM = 0 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 3 And TW = 2 Then
    If TYFM = -1 Then
        ModYV = 0
    Else
        ModYV = 0
    End If
Else
    ModYV = 0
End If







'(X * 13 - TYFM) * tTYF)
'Form1.Picture1.Cls
'Picture1.FillColor = RGB(64, 64, 255)
'Picture1.ForeColor = RGB(64, 64, 255)
'Dummy = Rectangle(Pict, ((Y * 8) - 8) * tTYF, 0, (Y * 8) * tTYF, ((NextNo) * 13 + 12) * tTYF)
'XX = Form1.Picture1.AutoRedraw
If UBound(SeqLines, 2) < NumSeqLines Then
    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
End If
SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
SeqLines(1, NumSeqLines) = RGB(64, 64, 255) 'colour of thing to draw
SeqLines(2, NumSeqLines) = Y * 8 - 8 'X1
SeqLines(3, NumSeqLines) = 0 'Y1
SeqLines(4, NumSeqLines) = Y * 8 'X2
SeqLines(5, NumSeqLines) = (NextNo) * 13 + 12 'Y2
NumSeqLines = NumSeqLines + 1

VSV = Form1.VScroll3.Value / ScrollSF
P9H = Form1.Picture9.ScaleHeight
'XX = Form1.Picture1.AutoRedraw

'ZZ = -1000000
'For x = 0 To NumSeqLines - 1
'    If ZZ < SeqLines(3, x) * tTYF - VSV Then 'vsv=35856, ttyf=0.75'min=-4851
'        ZZ = SeqLines(3, x) * tTYF - VSV
'    End If
'Next x

Dim Targ As Long
Targ = P9H + 20

'Pict = Form1.Picture1.hDC




Dim FirstSeq As Long
Call CalcttyfAdjust(TYFM, tTYF, FirstSeq, SeqSpaceIncrement)
Dim TCA As Single

TCA = tTYF * XConA
'Form1.Picture1.FillColor = BackColours
LBrush.lbColor = BackColours
'Form1.Picture1.ForeColor = BackColours
LPen.lopnColor = BackColours


PEN = CreatePenIndirect(LPen)
oldpen = SelectObject(Pict, PEN)
Brush = CreateBrushIndirect(LBrush)
OldBrush = SelectObject(Pict, Brush)
oB = LBrush
OP = LPen
Dummy = Rectangle(Pict, 0, 0, Form1.Picture9.ScaleWidth + 24 * TCA, Form1.Picture9.ScaleHeight)


LBrush.lbColor = BackColours
'Form1.Picture1.ForeColor = BackColours
LPen.lopnColor = BackColours

If x = x Then
    '@
    StartX = SeqColBlocks(Pict, UBound(SeqLines, 1), CDbl(tTYF * ttyfAdjust), TCA, XConA, NumSeqLines, Targ, VSV, SeqLines(0, 0))
x = x
Else
    PEN = CreatePenIndirect(LPen)
    oldpen = SelectObject(Pict, PEN)
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    
    
    For x = 0 To NumSeqLines - 1
        If SeqLines(0, x) = 0 Then 'rectangle
            
            Y1 = SeqLines(3, x) * tTYF - VSV  'Y1
            Y2 = SeqLines(5, x) * tTYF - VSV  'Y2
            If (Y1 >= 0 And Y2 <= Targ) Or (Y1 <= 0 And Y2 >= Targ) Or (Y1 >= 0 And Y1 <= Targ) Or (Y2 >= 0 And Y2 <= Targ) Then
                '@
               LBrush.lbColor = SeqLines(1, x)
                LPen.lopnColor = SeqLines(1, x)
                
                PEN = CreatePenIndirect(LPen)
                Pen2 = SelectObject(Pict, PEN)
                Brush = CreateBrushIndirect(LBrush)
                Brush2 = SelectObject(Pict, Brush)
    '            Form1.Picture1.FillColor = SeqLines(1, x)
    '            Form1.Picture1.ForeColor = SeqLines(1, x)
                X1 = SeqLines(2, x) * TCA 'X1
                X2 = SeqLines(4, x) * TCA 'X2
                
                DeleteObject (Pen2)
                DeleteObject (Brush2)
                
                Dummy = Rectangle(Pict, X1, Y1, X2, Y2)
                x = x
            End If
        Else
            Exit For
        End If
    Next x
    StartX = x
    Brush = SelectObject(Pict, OldBrush)
    DeleteObject (Brush)
    PEN = SelectObject(Pict, oldpen)
    DeleteObject (PEN)
End If
'@
Form1.Picture1.ForeColor = 0


'now do the text
'XX = Form1.HScroll1.Value



'Form1.Picture1.ForeColor = 0
LPen.lopnColor = 0

SetTextColor Pict, RGB(0, 0, 0)
'Dummy = SetBkColor(Pict, TRANSPARENT)
Dummy = SetBkMode(Pict, TRANSPARENT)
'Form1.Picture1.DrawMode = 6

'now do the text
'XX = Form1.HScroll1.Value


Dim LOS As Long
For x = StartX To NumSeqLines - 1
    If SeqLines(0, x) <> 0 Then
        Y1 = (SeqLines(3, x) - TYFM) * tTYF - VSV - ModYV 'yposition
        If Y1 > -30 And Y1 < Targ Then
            LOS = Len(SeqText(SeqLines(1, x)))
            Exit For
        End If
    End If
   
Next x

Y = 0

'LoFnt = CreateFont(-MulDiv(Form1.Picture1.FontSize, GetDeviceCaps(hdc, LOGPIXELSY), 72), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture1.Font.Name)
'-MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
'Form1.Picture1.ScaleMode = 1
'varXX = Form1.Picture1.TextWidth("O") / Screen.TwipsPerPixelX
'varYY = Form1.Picture1.TextHeight("O") / Screen.TwipsPerPixelY
Dim THAdj As Single, TWAdj As Single
If TW = 4 And TH = 8 Then
    THAdj = -1: TWAdj = 0
ElseIf TW = 6 And TH = 12 Then
    THAdj = 0: TWAdj = 1
ElseIf TW = 9 And TH = 17 Then
    THAdj = 0: TWAdj = 1
End If
'XX = TYFM
'XX = tTYF
'XX = XConA
'If THAdj <> 0 Or TWAdj <> 0 Then
'    x = x
'End If
LoFnt = CreateFont(TH + THAdj, TW + TWAdj, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 48, Form1.Picture1.Font.Name)

'OUT_RASTER_PRECIS = 6 -no effect, 5 -no effect, 4,3,2-noeffect

'FF_MODERN=48 noeffect

'DRAFT_QUALITY=1
'ANTIALIASED_QUALITY = 4
'NONANTIALIASED_QUALITY  = 3
'PROOF_QUALITY = 2
OldFont = SelectObject(Pict, LoFnt)

AdjVSVModY = VSV + ModYV
Dim SLFS As Long
SLFS = SeqLines(3, FirstSeq)
SLFS = SLFS - TYFM
SLFS = SLFS * tTYF - AdjVSVModY
Dim Holder2 As Long
If x = x Then
    Dummy = PrintSeqs(0, Pict, UBound(SeqText, 1), LOS, Targ, UBound(SeqLines, 1), NumSeqLines, StartX, VSV, SLFS, SeqSpaceIncrement, FirstSeq, SeqLines(0, 0), SeqText2)
    x = x
Else
    For x = StartX To NumSeqLines - 1
        If SeqLines(0, x) <> 0 Then
    '        Y1 = (SeqLines(3, x) - TYFM) * tTYF - AdjVSVModY 'VSV - ModYV 'yposition
            
            Y1 = SLFS + (x - FirstSeq) * SeqSpaceIncrement
            If Y1 > -30 And Y1 < Targ Then
                
                'OS = SeqText(SeqLines(1, x)) 'position of string in seqtext
                'X1 = SeqLines(2, x) * tTYF 'xposition
    
                Holder2 = SeqLines(1, x)
                'TextOut Pict, X1, Y1, OS, LOS
                '@
                
                TextOut Pict, 0, Y1, SeqText(Holder2), LOS
                'XX = InStr(1, OS, "---AAAGCAACT", vbBinaryCompare)
                'Y = Y + 1
                x = x
            End If
        End If
       
    Next x
End If
'Form1.Picture1.DrawMode = 13
'@
'Form1.Picture1.Refresh

Brush = SelectObject(Pict, OldBrush)
DeleteObject (Brush)
PEN = SelectObject(Pict, oldpen)
DeleteObject (PEN)
LoFnt = SelectObject(Pict, OldFont)
DeleteObject LoFnt

x = x
End Sub
Public Sub DoSeqDisplayDIB2(dibHDC As Long)

Dim Brush As Long, OldBrush As Long, PEN As Long, oldpen As Long, LPen As LOGPEN, oB As LOGBRUSH, OP As LOGPEN, Pen2 As Long, Brush2 As Long
Dim LBrush As LOGBRUSH, LoFnt As Long, OldFont As Long
Dim StartX As Long
Dim Dummy As Long, x As Long, ZZ As Long, Y As Long, UB As Long, Pict As Long, X1 As Long, X2 As Long, Y1 As Long, Y2 As Long, OS As String, tTYF As Double, TYFM As Integer, VSV As Long, P9H
Dim P1fs As Single, XCOnAx As Single
If H1C = 1 Then
    H1C = 0
    Exit Sub
End If
If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
   UB = UBound(SeqLines, 2)
   If UB = -1 Then Exit Sub
On Error GoTo 0

Pict = dibHDC

'CallHS1 = CallHS1 + 1
'Pict = Form1.Picture1.hdc

'Form1.Picture1.FillColor = BackColours
'

'Set Form1.Picture1.Picture = Nothing
'Form1.Picture1.BackColor = BackColours


Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
P1fs = Form1.Picture1.FontSize




Dim TW As Single, TH As Single, ModYV As Long
Form1.Picture1.ScaleMode = 3
TH = Form1.Picture1.TextHeight("A")
TW = Form1.Picture1.TextWidth("A")
If TH = 15 And TW = 7 Then
  
    If TYFM = 2 Then
        ModYV = 0
    ElseIf TYFM = 3 Then
        ModYV = 1
    Else
        ModYV = 3
    End If
ElseIf TH = 29 And TW = 16 Then
    If TYFM = 1 Then
        If tTYF = 2 Then
            ModYV = -2
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 33 And TW = 18 Then
    If TYFM = 1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 30 And TW = 16 Then
    If TYFM = 1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 29 And TW = 15 Then
    If TYFM = 1 Then
        If tTYF = 1.875 Then
            ModYV = 0
        Else
            ModYV = 1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 18 And TW = 10 Then
    If TYFM = 2 Then
        ModYV = -1
    ElseIf TYFM = 0 Then
        If tTYF = 1 Then
            ModYV = 2
        Else
            ModYV = -1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 14 And TW = 7 Then
    If TYFM = 2 Then
        ModYV = 0
    Else
        ModYV = 1
    End If
ElseIf TH = 27 And TW = 14 Then
    If TYFM = 1 Then
        If tTYF > 1.37 And tTYF < 1.38 Then
           ModYV = 2
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 2
    End If
ElseIf TH = 25 And TW = 14 Then
   
    
    If TYFM = 1 Then
        If tTYF > 1.749 And tTYF < 1.75 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 3
    End If
   
ElseIf TH = 24 And TW = 13 Then
    If TYFM = 1 Then
        If tTYF > 1.624 And tTYF < 1.625 Then
            ModYV = -1
        Else
            ModYV = 1
        End If
    Else
        ModYV = 1
    End If
ElseIf TH = 23 And TW = 13 Then
    If TYFM = 1 Then
        If tTYF > 1.623 And tTYF < 1.624 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 36 And TW = 19 Then
    ModYV = 3
ElseIf TH = 20 And TW = 10 Then
    If TYFM = 2 Then
        If tTYF > 1.249 And tTYF < 1.25 Then
           ModYV = -1
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 16 And TW = 8 Then
    If TYFM = 0 Then
        If tTYF = 1 Then
           ModYV = 1
        Else
            ModYV = 0
       
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 17 And TW = 9 Then
    If TYFM = 2 Then
        If tTYF > 1.124 And tTYF < 1.126 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 17 And TW = 8 Then
    If TYFM = 3 Then
        If tTYF > 1# And tTYF < 1.001 Then
            ModYV = -1
        Else
            ModYV = 0
        End If
    Else
        ModYV = 0
    End If
ElseIf TH = 12 And TW = 6 Then
   If TYFM = 1 Then
        ModYV = 0
    ElseIf TYFM = -1 Then
        ModYV = 2
    Else
        ModYV = 3
    End If
ElseIf TH = 8 And TW = 4 Then
    If TYFM = 1 Then
        ModYV = 0
    ElseIf TYFM = -1 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 12 And TW = 5 Then
    If TYFM = 3 Then
        ModYV = 0
    ElseIf TYFM = 1 Then
        ModYV = 2
    Else
        ModYV = 2
    End If
   
ElseIf TH = 6 And TW = 3 Then
    If TYFM = 0 Then
        ModYV = 1
    Else
        ModYV = 1
    End If
ElseIf TH = 3 And TW = 2 Then
    If TYFM = -1 Then
        ModYV = 0
    Else
        ModYV = 0
    End If
Else
    ModYV = 0
End If

'(X * 13 - TYFM) * tTYF)
'Form1.Picture1.Cls
'Picture1.FillColor = RGB(64, 64, 255)
'Picture1.ForeColor = RGB(64, 64, 255)
'Dummy = Rectangle(Pict, ((Y * 8) - 8) * tTYF, 0, (Y * 8) * tTYF, ((NextNo) * 13 + 12) * tTYF)
'XX = Form1.Picture1.AutoRedraw
If UBound(SeqLines, 2) < NumSeqLines Then
    ReDim Preserve SeqLines(5, NumSeqLines + 1000)
End If
SeqLines(0, NumSeqLines) = 0 ' thing to draw is a rectangle
SeqLines(1, NumSeqLines) = RGB(64, 64, 255) 'colour of thing to draw
SeqLines(2, NumSeqLines) = Y * 8 - 8 'X1
SeqLines(3, NumSeqLines) = 0 'Y1
SeqLines(4, NumSeqLines) = Y * 8 'X2
SeqLines(5, NumSeqLines) = (NextNo) * 13 + 12 'Y2
NumSeqLines = NumSeqLines + 1

VSV = Form1.VScroll3.Value / ScrollSF
P9H = Form1.Picture9.ScaleHeight
'XX = Form1.Picture1.AutoRedraw

'ZZ = -1000000
'For x = 0 To NumSeqLines - 1
'    If ZZ < SeqLines(3, x) * tTYF - VSV Then 'vsv=35856, ttyf=0.75'min=-4851
'        ZZ = SeqLines(3, x) * tTYF - VSV
'    End If
'Next x

Dim Targ As Long
Targ = P9H + 20

'Pict = Form1.Picture1.hDC




Dim FirstSeq As Long
Call CalcttyfAdjust(TYFM, tTYF, FirstSeq, SeqSpaceIncrement)
Dim TCA As Single

TCA = tTYF * XConA


LBrush.lbColor = BackColours
'Form1.Picture1.ForeColor = BackColours
LPen.lopnColor = BackColours


PEN = CreatePenIndirect(LPen)
oldpen = SelectObject(Pict, PEN)
Brush = CreateBrushIndirect(LBrush)
OldBrush = SelectObject(Pict, Brush)
oB = LBrush
OP = LPen
'@

XX = Form1.Picture9.ScaleWidth

'Dummy = Rectangle(Pict, 0, 0, Form1.Picture9.ScaleWidth + (24 * TCA), Form1.Picture9.ScaleHeight)
'If OnlyDoFlash = 0 Then
'@
    Dummy = Rectangle(Pict, 0, 0, CLng(PrintSeqLen * TCA * 8), Form1.Picture9.ScaleHeight)
'End If
LBrush.lbColor = BackColours
'Form1.Picture1.ForeColor = BackColours
LPen.lopnColor = BackColours

'TopPosY = VSV / tTYF
'BottomPosY = (Targ + VSV) / tTYF

XLenPerColumn = TCA

If x = x Then
    '@'@'@'@'@'@'@'@'@'@'@'@'@
    StartX = SeqColBlocks(Pict, UBound(SeqLines, 1), CDbl(tTYF * ttyfAdjust), TCA, XConA, NumSeqLines, Targ, VSV, SeqLines(0, 0))
x = x
Else
    PEN = CreatePenIndirect(LPen)
    oldpen = SelectObject(Pict, PEN)
    Brush = CreateBrushIndirect(LBrush)
    OldBrush = SelectObject(Pict, Brush)
    
    
    For x = 0 To NumSeqLines - 1
        If SeqLines(0, x) = 0 Then 'rectangle
            
            Y1 = SeqLines(3, x) * tTYF - VSV  'Y1
            Y2 = SeqLines(5, x) * tTYF - VSV  'Y2
            If (Y1 >= 0 And Y2 <= Targ) Or (Y1 <= 0 And Y2 >= Targ) Or (Y1 >= 0 And Y1 <= Targ) Or (Y2 >= 0 And Y2 <= Targ) Then
                '@
               LBrush.lbColor = SeqLines(1, x)
                LPen.lopnColor = SeqLines(1, x)
                
                PEN = CreatePenIndirect(LPen)
                Pen2 = SelectObject(Pict, PEN)
                Brush = CreateBrushIndirect(LBrush)
                Brush2 = SelectObject(Pict, Brush)
    '            Form1.Picture1.FillColor = SeqLines(1, x)
    '            Form1.Picture1.ForeColor = SeqLines(1, x)
                X1 = SeqLines(2, x) * TCA 'X1
                X2 = SeqLines(4, x) * TCA 'X2
                'XX = Form1.Picture9.ScaleWidth
                DeleteObject (Pen2)
                DeleteObject (Brush2)
                
                Dummy = Rectangle(Pict, X1, Y1, X2, Y2)
                x = x
            End If
        Else
            Exit For
        End If
    Next x
    StartX = x
    Brush = SelectObject(Pict, OldBrush)
    DeleteObject (Brush)
    PEN = SelectObject(Pict, oldpen)
    DeleteObject (PEN)
End If
'@
Form1.Picture1.ForeColor = 0


'now do the text
'XX = Form1.HScroll1.Value



'Form1.Picture1.ForeColor = 0
LPen.lopnColor = 0

SetTextColor Pict, RGB(0, 0, 0)
'Dummy = SetBkColor(Pict, TRANSPARENT)
Dummy = SetBkMode(Pict, TRANSPARENT)
'Form1.Picture1.DrawMode = 6

'now do the text
'XX = Form1.HScroll1.Value


Dim THAdj As Single, TWAdj As Single
If TW = 4 And TH = 8 Then
    THAdj = -1: TWAdj = 0
ElseIf TW = 6 And TH = 12 Then
    THAdj = 0: TWAdj = 1
ElseIf TW = 9 And TH = 17 Then
    THAdj = 0: TWAdj = 1
End If




Y = 0

'LoFnt = CreateFont(-MulDiv(Form1.Picture1.FontSize, GetDeviceCaps(hdc, LOGPIXELSY), 72), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Form1.Picture1.Font.Name)
'-MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
'Form1.Picture1.ScaleMode = 1
'varXX = Form1.Picture1.TextWidth("O") / Screen.TwipsPerPixelX
'varYY = Form1.Picture1.TextHeight("O") / Screen.TwipsPerPixelY

'XX = TYFM
'XX = tTYF
'XX = XConA
'If THAdj <> 0 Or TWAdj <> 0 Then
'    x = x
'End If
LoFnt = CreateFont(TH + THAdj, TW + TWAdj, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 48, Form1.Picture1.Font.Name)


X1 = (PrintStartY - 1) * (TW)
'OUT_RASTER_PRECIS = 6 -no effect, 5 -no effect, 4,3,2-noeffect

'FF_MODERN=48 noeffect

'DRAFT_QUALITY=1
'ANTIALIASED_QUALITY = 4
'NONANTIALIASED_QUALITY  = 3
'PROOF_QUALITY = 2
OldFont = SelectObject(Pict, LoFnt)

AdjVSVModY = VSV + ModYV
Dim SLFS As Long
SLFS = SeqLines(3, FirstSeq)
SLFS = SLFS - TYFM
SLFS = SLFS * tTYF - AdjVSVModY
Dim Holder2 As Long


Dim LOS As Long
For x = StartX To NumSeqLines - 1
    If SeqLines(0, x) <> 0 Then
        Y1 = SLFS + (x - FirstSeq) * SeqSpaceIncrement
        If Y1 > -30 And Y1 < Targ Then
            LOS = Len(SeqText(SeqLines(1, x)))
            Exit For
        End If
    End If
   
Next x



If x = 12345 Then
    '@
    Dummy = PrintSeqs(X1, Pict, UBound(SeqText, 1), LOS, Targ, UBound(SeqLines, 1), NumSeqLines, StartX, VSV, SLFS, SeqSpaceIncrement, FirstSeq, SeqLines(0, 0), SeqText2)
    x = x
Else
    For x = StartX To NumSeqLines - 1
        If SeqLines(0, x) <> 0 Then
    '        Y1 = (SeqLines(3, x) - TYFM) * tTYF - AdjVSVModY 'VSV - ModYV 'yposition
            
            Y1 = SLFS + (x - FirstSeq) * SeqSpaceIncrement
            If Y1 > -30 And Y1 < Targ Then
                
                'OS = SeqText(SeqLines(1, x)) 'position of string in seqtext
                'X1 = SeqLines(2, x) * tTYF 'xposition
    
                Holder2 = SeqLines(1, x)
                'TextOut Pict, X1, Y1, OS, LOS
                '@'@'@'@'@
                
                TextOut Pict, X1, Y1, SeqText(Holder2), LOS
                'XX = InStr(1, OS, "---AAAGCAACT", vbBinaryCompare)
                'Y = Y + 1
                x = x
            End If
        End If
       
    Next x
End If
'Form1.Picture1.DrawMode = 13
'@
'Form1.Picture1.Refresh

Brush = SelectObject(Pict, OldBrush)
DeleteObject (Brush)
PEN = SelectObject(Pict, oldpen)
DeleteObject (PEN)
LoFnt = SelectObject(Pict, OldFont)
DeleteObject LoFnt

x = x
End Sub
Public Sub MakeRange(BEP, WinPP, RNum() As Long, RList() As Long, WinnerPos() As Long, CollectEvents As XOverDefine, StartPos, EndPos)

End Sub
Public Sub CBrother(NextNo As Long, SeqNum() As Integer, StrainSeq() As String, ISeqs() As Long, FMat() As Single, SMat() As Single, FAMat() As Single, SAMat() As Single, TraceSub() As Long, NumSeqs, StartPos, EndPos)


Dim WS As Long, TD As Double, MD As Double, Seqs() As Long, TempSeq() As String, FF As Long, x As Long, OS As String, Burnin As Long, CycleNo As Long
ReDim TempSeq(3)
If SEventNumber = 19 Then
x = x
End If
Exit Sub
CycleNo = 1000000

'iseqs
'Find Sequence 3 (ie outlyer)
x = -1
MD = 10
WS = -1
Dim MaxFA As Double, MaxSA As Double
MaxFA = 0
MaxSA = 0
XX = ISeqs(0)
XX = ISeqs(1)
XX = ISeqs(2)
For x = 0 To NextNo
    If SMat(ISeqs(0), x) <> 3 And SMat(ISeqs(1), x) <> 3 And SMat(ISeqs(2), x) <> 3 And SMat(ISeqs(0), x) <> 10 And SMat(ISeqs(1), x) <> 10 And SMat(ISeqs(2), x) <> 10 Then
        If FMat(ISeqs(0), x) <> 3 And FMat(ISeqs(1), x) <> 3 And FMat(ISeqs(2), x) <> 3 And FMat(ISeqs(0), x) <> 10 And FMat(ISeqs(1), x) <> 10 And FMat(ISeqs(2), x) <> 10 Then
            If FAMat(ISeqs(0), x) > FAMat(ISeqs(0), ISeqs(1)) And FAMat(ISeqs(0), x) > FAMat(ISeqs(0), ISeqs(2)) And FAMat(ISeqs(0), x) > FAMat(ISeqs(2), ISeqs(1)) Then
                If FAMat(ISeqs(0), x) < MD Then
                    MD = FAMat(ISeqs(0), x)
                    WS = x
                ElseIf FAMat(ISeqs(0), x) = MD Then
                    
                    If FMat(ISeqs(0), x) + FMat(ISeqs(1), x) + FMat(ISeqs(2), x) < FMat(ISeqs(0), WS) + FMat(ISeqs(1), WS) + FMat(ISeqs(2), WS) Then
                        WS = x
                    End If
                End If
            End If
            
        Else
            x = x
        End If
    End If
    
Next x
If x = -1 Then
    MD = 0
    For x = 0 To NextNo
        TD = FMat(ISeqs(0), x) + FMat(ISeqs(1), x) + FMat(ISeqs(2), x)
        If TD > MD Then
            WS = x
            MD = TD
        End If
    Next x
End If
ReDim Seqs(NumSeqs)
Winner = -1
If WS = -1 Then
    'the recombinant sequence is an outlyer in the recombinant region
    For x = 0 To NextNo
        If SMat(ISeqs(0), x) <> 3 And SMat(ISeqs(1), x) <> 3 And SMat(ISeqs(2), x) <> 3 And SMat(ISeqs(0), x) <> 10 And SMat(ISeqs(1), x) <> 10 And SMat(ISeqs(2), x) <> 10 Then
            If FMat(ISeqs(0), x) <> 3 And FMat(ISeqs(1), x) <> 3 And FMat(ISeqs(2), x) <> 3 And FMat(ISeqs(0), x) <> 10 And FMat(ISeqs(1), x) <> 10 And FMat(ISeqs(2), x) <> 10 Then
                If SAMat(ISeqs(0), x) > SAMat(ISeqs(0), ISeqs(1)) And SAMat(ISeqs(0), x) > SAMat(ISeqs(0), ISeqs(2)) And SAMat(ISeqs(0), x) > SAMat(ISeqs(2), ISeqs(1)) Then
                    If SAMat(ISeqs(0), x) < MD Then
                        MD = SAMat(ISeqs(0), x)
                        WS = x
                    ElseIf SAMat(ISeqs(0), x) = MD Then
                        
                        If SMat(ISeqs(0), x) + SMat(ISeqs(1), x) + SMat(ISeqs(2), x) < SMat(ISeqs(0), WS) + SMat(ISeqs(1), WS) + SMat(ISeqs(2), WS) Then
                            WS = x
                        End If
                    End If
                End If
            End If
        Else
            x = x
        End If
    Next x
    If WS = -1 Then
        Dim MinF As Double, MaxF As Double, MinS As Double, MaxS As Double, LowF As Long, LowS As Long, BestScore As Double
        MinF = 10
        MaxF = 10
        Winner = -1
        
        If FAMat(ISeqs(0), ISeqs(1)) <> FAMat(ISeqs(0), ISeqs(2)) Then
            If FAMat(ISeqs(0), ISeqs(1)) > FAMat(ISeqs(0), ISeqs(2)) Then
                MaxF = FAMat(ISeqs(0), ISeqs(1))
                MinF = FAMat(ISeqs(0), ISeqs(2))
                
            Else
                MaxF = FAMat(ISeqs(0), ISeqs(2))
                MinF = FAMat(ISeqs(0), ISeqs(1))
                
            End If
            LowF = 0
            
        Else
            LowF = 1
            If FAMat(ISeqs(0), ISeqs(1)) > FAMat(ISeqs(1), ISeqs(2)) Then
                MaxF = FAMat(ISeqs(0), ISeqs(1))
                MinF = FAMat(ISeqs(1), ISeqs(2))
            Else
                MaxF = FAMat(ISeqs(1), ISeqs(2))
                MinF = FAMat(ISeqs(0), ISeqs(1))
            End If
        End If
        If SAMat(ISeqs(0), ISeqs(1)) <> SAMat(ISeqs(0), ISeqs(2)) Then
            LowS = 0
            If SAMat(ISeqs(0), ISeqs(1)) > SAMat(ISeqs(0), ISeqs(2)) Then
                'this may seem a bit odd but think about it.
                'we're going to call the recombinant the parent,  the unknown parent the outlyer, and the outlyer the recombinant
                MaxS = SAMat(ISeqs(0), ISeqs(1))
                MinS = SAMat(ISeqs(0), ISeqs(2))
                Seqs(1) = ISeqs(1)
                Seqs(2) = ISeqs(2)
            Else
                MaxS = SAMat(ISeqs(0), ISeqs(2))
                MinS = SAMat(ISeqs(0), ISeqs(1))
                Seqs(1) = ISeqs(2)
                Seqs(2) = ISeqs(1)
            End If
            Seqs(0) = ISeqs(0)
        Else
            LowS = 1
            Seqs(0) = ISeqs(1)
            If SAMat(ISeqs(0), ISeqs(1)) > SAMat(ISeqs(1), ISeqs(2)) Then
                MaxS = SAMat(ISeqs(1), ISeqs(0))
                MinS = SAMat(ISeqs(1), ISeqs(2))
                Seqs(1) = ISeqs(0)
                Seqs(2) = ISeqs(2)
            Else
                MaxS = SAMat(ISeqs(1), ISeqs(2))
                MinS = SAMat(ISeqs(0), ISeqs(1))
                Seqs(1) = ISeqs(2)
                Seqs(2) = ISeqs(0)
            End If
        End If
        BestScore = 0
        For x = 0 To NextNo
            
            If SMat(ISeqs(0), x) <> 3 And SMat(ISeqs(1), x) <> 3 And SMat(ISeqs(2), x) <> 3 And SMat(ISeqs(0), x) <> 10 And SMat(ISeqs(1), x) <> 10 And SMat(ISeqs(2), x) <> 10 Then
                If FMat(ISeqs(0), x) <> 3 And FMat(ISeqs(1), x) <> 3 And FMat(ISeqs(2), x) <> 3 And FMat(ISeqs(0), x) <> 10 And FMat(ISeqs(1), x) <> 10 And FMat(ISeqs(2), x) <> 10 Then
                    If FAMat(x, ISeqs(LowF)) > MinF And FAMat(x, ISeqs(LowF)) < MaxF Then
                        If SAMat(x, ISeqs(LowS)) < MaxS Then
                            If BestScore < FMat(x, Seqs(0)) + FMat(x, Seqs(2)) Then
                                BestScore = FMat(x, Seqs(0)) + FMat(x, Seqs(2))
                                Winner = x
                            End If
                            x = x
                        End If
                    End If
                End If
            End If
        Next x
    End If
    If Winner = -1 Then Exit Sub
    WS = Winner
    Seqs(3) = WS 'this looks wrong but is right.
    x = x
End If

If Winner = -1 Then

    Seqs(2) = WS
    If FAMat(ISeqs(0), ISeqs(1)) < FAMat(ISeqs(0), ISeqs(2)) And FAMat(ISeqs(0), ISeqs(1)) < FAMat(ISeqs(1), ISeqs(2)) Then
        
        If SAMat(ISeqs(0), ISeqs(2)) <= SAMat(ISeqs(1), ISeqs(2)) Then 'iseqs(0) is the "recombinant" - ie the one that shifts tree position
            Seqs(3) = ISeqs(0)
            Seqs(0) = ISeqs(1)
            Seqs(1) = ISeqs(2)
        Else 'iseqs(1) is the "recombinant" - ie the one that shifts tree position
            Seqs(3) = ISeqs(1)
            Seqs(0) = ISeqs(0)
            Seqs(1) = ISeqs(2)
        End If
    ElseIf FAMat(ISeqs(0), ISeqs(2)) < FAMat(ISeqs(0), ISeqs(1)) And FAMat(ISeqs(0), ISeqs(2)) < FAMat(ISeqs(1), ISeqs(2)) Then
        If SAMat(ISeqs(0), ISeqs(1)) <= SAMat(ISeqs(1), ISeqs(2)) Then 'iseqs(0) is the "recombinant" - ie the one that shifts tree position
            Seqs(3) = ISeqs(0)
            Seqs(0) = ISeqs(1)
            Seqs(1) = ISeqs(2)
        Else 'iseqs(2) is the "recombinant" - ie the one that shifts tree position
            Seqs(3) = ISeqs(2)
            Seqs(0) = ISeqs(0)
            Seqs(1) = ISeqs(1)
        End If
    ElseIf FAMat(ISeqs(1), ISeqs(2)) < FAMat(ISeqs(0), ISeqs(2)) And FAMat(ISeqs(1), ISeqs(2)) < FAMat(ISeqs(0), ISeqs(1)) Then
        If SAMat(ISeqs(0), ISeqs(2)) <= SAMat(ISeqs(0), ISeqs(1)) Then 'iseqs(2) is the "recombinant" - ie the one that shifts tree position
            Seqs(3) = ISeqs(2)
            Seqs(0) = ISeqs(1)
            Seqs(1) = ISeqs(0)
        Else 'iseqs(1) is the "recombinant" - ie the one that shifts tree position
            Seqs(3) = ISeqs(1)
            Seqs(0) = ISeqs(0)
            Seqs(1) = ISeqs(2)
        End If
    End If
Else

End If
Dim EPS As Long
Dim SPS As Long, LFrag As Long
'12,21,15,1


EPS = EndPos
SPS = StartPos

If SPS < EPS Then
    LFrag = EPS - SPS
Else
    LFrag = Len(StrainSeq(0)) - SPS + EPS
End If

If LFrag > CLng(Len(StrainSeq(0)) / 2) Then
    LFrag = Len(StrainSeq(0)) - LFrag
    
End If
If LFrag > 300 Then
    LFrag = CLng(LFrag * 0.6666)
    SPS = EPS - LFrag
    EPS = EPS + LFrag
End If

If SPS < 1 Then SPS = SPS + Len(StrainSeq(0))
If EPS < 1 Then EPS = EPS + Len(StrainSeq(0))
If EPS > Len(StrainSeq(0)) Then EPS = EPS - Len(StrainSeq(0))
If SPS > Len(StrainSeq(0)) Then SPS = SPS - Len(StrainSeq(0))


If SPS < EPS Then
    For x = 0 To NumSeqs
        TempSeq(x) = ""
        TempSeq(x) = Mid(StrainSeq(TraceSub(Seqs(x))), SPS, (EPS - SPS))
        x = x
    Next x
Else
    For x = 0 To NumSeqs
        TempSeq(x) = ""
        TempSeq(x) = Mid(StrainSeq(TraceSub(Seqs(x))), SPS, Len(StrainSeq(0)) - SPS)
        TempSeq(x) = TempSeq(x) + Mid(StrainSeq(TraceSub(Seqs(x))), 1, EPS)
    Next x
End If



Burnin = 200
If DebuggingFlag < 2 Then On Error Resume Next

oDir = CurDir
ChDir App.Path
ChDrive App.Path
On Error GoTo 0
FF = FreeFile
Open "infile" For Output As #FF
Print #FF, Trim(Str(NumSeqs + 1)) + Str(Len(TempSeq(0)))
For x = 0 To NumSeqs
    OS = Trim(Str(x))
    OS = OS + String(10 - Len(OS), " ")
    OS = OS + TempSeq(x)
    Print #FF, OS
Next x
Close #FF

Open "cmdfile" For Output As #FF
Print #FF, "length:" + Str(CycleNo)
Print #FF, "decorate_output: true"
Print #FF, "parent_tree: ((0,1),2)"

Close #FF

OS = "cbrother 100 cmdfile infile outfile"
Call ShellAndClose(OS, 0)

Dim BPos() As Long, Pos As Long, LPos As Long, BP As Long, Max As Long, Tot As Long, WinPos As Long, Lims(1) As Double, CI(3) As Long
ReDim BPos(Len(TempSeq(0)))
FF = FreeFile
Open "outfile" For Binary As FF
OS = String(LOF(FF), " ")
Get #FF, , OS
Close #FF
Pos = InStr(1, OS, "T!", vbBinaryCompare)
x = 0
Do While Pos > 0
    'XX = Mid$(OS, Pos - 5, 4)
    x = x + 1
    If x > Burnin Then
        BP = val(Mid$(OS, Pos - 5, 4))
        BPos(BP) = BPos(BP) + 1
    End If
    LPos = Pos + 5
    Pos = InStr(LPos, OS, "T!", vbBinaryCompare)
    
Loop
Tot = 0: Max = 0: WinPos = -1
For x = 0 To Len(TempSeq(0))
    Tot = Tot + BPos(x)
    If BPos(x) > Max Then
        Max = BPos(x)
        WinPos = x
    End If
Next x

Lims(0) = (Tot - Tot * 0.95) / 2
Lims(1) = (Tot - Tot * 0.99) / 2
For x = 0 To Len(TempSeq(0))
    CI(0) = CI(0) + BPos(x)
    If CI(0) > Lims(0) Then
        CI(0) = x - 1
        Exit For
    End If
Next x
For x = 0 To Len(TempSeq(0))
    CI(2) = CI(2) + BPos(x)
    If CI(2) > Lims(1) Then
        CI(2) = x - 1
        Exit For
    End If
Next x

For x = Len(TempSeq(0)) To 0 Step -1
    CI(1) = CI(1) + BPos(x)
    If CI(1) > Lims(0) Then
        CI(1) = x + 1
        Exit For
    End If
Next x
For x = Len(TempSeq(0)) To 0 Step -1
    CI(3) = CI(3) + BPos(x)
    If CI(3) > Lims(1) Then
        CI(3) = x + 1
        Exit For
    End If
Next x
XX = SPS '4 mill -?,5705
XX = EPS '4 mill -?,6235



CI(2) = CI(2) + SPS '4 mill -2211,5711
CI(0) = CI(0) + SPS '4 mill -2232,5715
WinPos = WinPos + SPS '4 mill -2242(2239),5977(5970)
CI(1) = CI(1) + SPS '4 mill -2261,6072
CI(3) = CI(3) + SPS '4 mill -3675,6076

If WinPos > Len(StrainSeq(0)) Then WinPos = WinPos - Len(StrainSeq(0))
For x = 0 To 3
    If CI(x) > Len(StrainSeq(0)) Then CI(x) = CI(x) - Len(StrainSeq(0))
Next x

Open "testResult.csv" For Append As #1
'1254 - 1289 - 1336
'1231 - 1289 - 1349
XX = CurDir

Print #1, Str(SEventNumber) + "," + Str(CycleNo) + "," + Str(CI(2)) + "," + Str(CI(0)) + "," + Str(WinPos) + "," + Str(CI(1)) + "," + Str(CI(3)) + ","
Close #1
If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive App.Path
On Error GoTo 0
End Sub

Public Sub MakeBiomialTable()

Dim A, Y As Variant, x As Variant, Z As Variant, Fact3() As Variant, Hold As Variant
Dim XOL As Long, NIC As Long, IndProb As Double, ProbabilityXOver As Double
Dim g As Long, H As Long, i As Long, j As Long, FF As Long
'ReDim ChiTable(90, 90, 90)
    
    MaxABWin = 150
'    For G = 0 To 90
'        For H = 0 To G
'            For i = 0 To G
'                ChiTable(H, i, G) = CalcChivalue(H, i, G)
'            Next i
'        Next H
'    Next G
    
    
    ReDim Chimap(MaxABWin)
    For g = 0 To 4
        Chimap(g) = -1
    Next g
    ChiTableSize = 0
    'work out chitablesize
    For g = 5 To MaxABWin
        ChiTableSize = ChiTableSize + (g + 1) ^ 2
    Next g
    
    ReDim ChiTable2(ChiTableSize)
    
    j = -1
    
    
    For g = 5 To MaxABWin
        Chimap(g) = j + 1
        For H = 0 To g
            For i = 0 To g
                j = j + 1
                ChiTable2(j) = CalcChivalue(H, i, g)
            Next i
        Next H
    Next g
    'XX = ChiMap(9)
    
    UBFact3x3 = 97
    ReDim Fact(171), Fact3(UBFact3x3)
    Y = 1
    Fact(0) = 1
    For x = 1 To 170
       Y = Y * x
       Fact(x) = Y
    Next x
    
    Y = 1
    Fact3(0) = 1
    For x = 1 To UBFact3x3
       Y = Y * x
       Fact3(x) = Y
    Next x
    
    ReDim Fact3X3(UBFact3x3, UBFact3x3, UBFact3x3)
    For x = 0 To UBFact3x3
        For Y = 0 To UBFact3x3
            For Z = 0 To UBFact3x3
                Hold = (Fact3(Y) * Fact3(Z))
                Hold = Fact3(x) / Hold
                Fact3X3(x, Y, Z) = Hold
            Next Z
        Next Y
    Next x
    
    
    ReDim ProbEstimate(171, 171, 50)
    Dim oDirX As String
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    'XX = App.Path
    FF = FreeFile
    Open "BinProbs" For Binary As #FF
    'XX = LOF(FF)
    If LOF(FF) < 10 Then
    
        For x = 1 To 171
            For Y = 0 To 171
                For Z = 0 To 50
                    ProbEstimate(x, Y, Z) = 100
                    
                Next Z
            Next Y
        Next x
        
        
        
        
        For x = 1 To 170
            For Y = 3 To x
                For Z = 2 To 50
                    ProbEstimate(x, Y, Z) = ProbCalc(Fact(0), x, Y, Z / 50, x * 2)
    '                If ProbEstimate(X, Y, Z) < 0.05 Then
    '                    X = X
    '                End If
    '                X = X
                Next Z
            Next Y
        Next x
    
    
        Put #FF, , ProbEstimate()
    
    Else
        Get #FF, , ProbEstimate()
    End If
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    
End Sub
Public Sub AddBlock(X1 As Long, Y1 As Long, X2 As Long, Y2 As Long, Colour() As Long, SBL As Long, SB() As Long)
Dim sn As Byte
SBL = SBL + 1
If SBL > UBound(SB, 3) Then
    ReDim Preserve SB(3, 4, SBL + 100)
End If
For sn = 0 To 3
    SB(sn, 0, SBL) = X1
    SB(sn, 1, SBL) = Y1
    SB(sn, 2, SBL) = X2
    SB(sn, 3, SBL) = Y2
    SB(sn, 4, SBL) = Colour(sn)
Next sn
End Sub
Public Sub AddToMapVB(A, S, Win, MaP() As Integer)

Dim b As Long, C As Long, OS3 As Long, SX As Long, EX As Long

SX = (S - CLng((Win) / 2))
EX = (S + CLng((Win) / 2))
            
If SX > 0 Then
    SX = Recompress(SX)
Else
    SX = Decompress(Len(StrainSeq(0))) + SX 'remember that sx will be minus or 0
    SX = Recompress(SX) - Len(StrainSeq(0))
End If
            
If EX <= Decompress(Len(StrainSeq(0))) Then
    EX = Recompress(EX)
Else
    EX = EX - Decompress(Len(StrainSeq(0)))
    EX = Recompress(EX) + Len(StrainSeq(0))
End If
            
            
For b = SX To EX
    If b < 1 Then
        C = (Len(StrainSeq(0))) + b
    ElseIf b > (Len(StrainSeq(0))) Then
        C = b - (Len(StrainSeq(0)))
    Else
        C = b
    End If
    'Z = Recompress(C)
    'If Z <> lastz Then
    MaP(C, A) = MaP(C, A) + 1
    '    lastz = Z
    'End If
Next b

End Sub
Public Sub AddString(X1 As Long, Y1 As Long, SNum, Colour() As Long, SBL As Long, SB() As Long)
Dim sn As Byte
SBL = SBL + 1
If SBL > UBound(SB, 3) Then
    ReDim Preserve SB(3, 3, SBL + 100)
End If

For sn = 0 To 3
    
    SB(sn, 0, SBL) = X1
    SB(sn, 1, SBL) = Y1
    SB(sn, 2, SBL) = SNum
    SB(sn, 3, SBL) = Colour(sn)
    
Next sn
End Sub



Public Sub MakeCSV(FName As String, Res)
Dim PValCon As Double, DoneSup() As Long, Order() As Long, AddString As String, OutString As String, DoneSeq() As Byte, WinProb As Double, WinE(1) As Long, ENumb As Long

If SEventNumber = 0 Then
    Open FName For Output As #1
    Print #1, "no recombination detected"
    Close #1
    Exit Sub
End If

'Find MaxUnique events

Hi = SuperEventList(Eventnumber)
'order the superevents

ReDim Order(Hi)
ReDim DoneSup(Hi)
ENumb = 0
Dim BPV() As Double
ReDim BPV(SEventNumber, AddNum)
For x = 1 To SEventNumber
    For Y = 0 To AddNum
        BPV(x, Y) = LowestProb
    Next Y
Next x

For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
'            If XoverList(x, Y).Eventnumber > 0 Then
'                x = x
'            End If
            If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                    BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                End If
            End If
        Next Y
Next x

If CLine <> "" And CLine <> " " Then 'Or x = x Then
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
End If
Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
    If CLine = "" Or CLine = " " Then
        For x = 0 To NextNo
            For Y = 1 To CurrentXOver(x)
                Enu = SuperEventList(XoverList(x, Y).Eventnumber)
                
                NC = 0
                
                For Z = 0 To AddNum - 1
                    If Confirm(Enu, Z) > 0 Then
                        If Confirm(Enu, Z) = 1 Then
                            PValCon = ConfirmP(Enu, Z)
                            PValCon = 10 ^ (-PValCon)
                            
                            If PValCon < LowestProb Then
                                NC = NC + 1
                            End If
                        Else
                            NC = NC + 1
                        End If
                    End If
                Next Z
                
                If XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 Then
                    Excl(Enu) = 1
                    
                End If
            Next Y
        Next x
    Else
        For x = 1 To SEventNumber
            Excl(x) = 1
        Next x
    End If
    'If MCFlag > 0 And CLine <> "" And CLine <> " " Then




If DebuggingFlag < 2 Then On Error Resume Next
Open FName For Output As #1
x = FreeFile
If CLine = "" Or CLine = " " Then
    If x = 1 Then
        MsgBox ("A file with the same name as that which you have specified (" + FName + ") is already open.  Close the file and try resaving again")
        Exit Sub
    End If
Else
    
    If x = 1 Then
        FName = FName + Str(GetTickCount)
    End If
End If
If CLine = "" Or CLine = " " Then
    If Res <> 6 Then
        For x = 0 To SEventNumber
            If Excl(x) = 0 Then
                Response = MsgBox("Would you like to exclude potential false positives? If you press 'no' all evidence of recombination (including signals potentially attributable to sequence misalignment or processes other than recombination) will also be saved", vbYesNo)
        
                If Response = 7 Then
                    For Y = 0 To SEventNumber
                        Excl(Y) = 1
                    Next Y
                End If
                Exit For
            End If
        Next x
    Else
        For x = 1 To SEventNumber
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Then
                Excl(x) = 1
            Else
                Excl(x) = 0
            End If
        Next x
    
    End If

Else
    For x = 1 To SEventNumber
        Excl(x) = 1
    Next x
End If



On Error GoTo 0
ENumb = 0
TypeSeq = TypeSeqNumber
If TypeSeq > NextNo Then
    TypeSeq = NextNo
ElseIf TypeSeq = -1 Then
    TypeSeq = 0
End If

Print #1, "Table key:"
Print #1, "~            = It is possible that this apparent recombination signal could have been caused by an evolutionary"
Print #1, "               process other than recombination."
Print #1, "*            = The actual breakpoint position is undetermined (it was most likely either overprinted by a subsequent "
Print #1, "               recombination event or off the edges of the analysed sequence fragments)."
Print #1, "$            = This might not be breakpoint - it is likey the edge of a genome segment (possibly exchanged during reassortment)"
Print #1, "^            = The recombinant sequence may have been misidentified (one of the identified parents might be the recombinant)"
Print #1, "Minor Parent = Parent contributing the smaller fraction of sequence."
Print #1, "Major Parent = Parent contributing the larger fraction of sequence."
Print #1, "Unknown      = Only one parent and a recombinant need be in the alignment for a recombination event to be detectable."
Print #1, "               The sequence listed as unknown was used to infer the existance of a missing parental sequence."
Print #1, "NS           = No significant P-value was recorded for this recombination event using the particular method in question."
Print #1, ""


Print #1, ",,,Breakpoint Positions"
Print #1, ",,In Alignment, ,In Recombinant Sequence, ,Relative to " + OriginalName(TypeSeq) + ",,, , , , , , Detection Methods"
Print #1, "Recombination Event Number, Number In .RDP File, Begin, End,Begin, End,Begin, End, Recombinant Sequence(s), Minor Parental Sequence(s), Major Parental Sequence(s), RDP, GENECONV, Bootscan, Maxchi, Chimaera, SiSscan,PhylPro, LARD, 3Seq"

ENumb = 0

Dim NHolder() As String
ReDim NHolder(3, NextNo)
NUCO = 0


Dim Segbound() As Byte
ReDim Segbound(Len(StrainSeq(0)))
For x = 0 To RBPNum
    Segbound(RBPPos(x)) = 1
Next x
'EN = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
'If EN > 0 Then
'    If Segbound(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(EN, 0), BestEvent(EN, 1)).Beginning) = 1 Then

Dim SegSymbol As String
For x = 1 To SEventNumber
        OutString = Str(ENumb)
        
        If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
            SegSymbol = "$"
        Else
            SegSymbol = ""
        End If
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
            
            ENumb = ENumb + 1
            If ExRecFlag <> 1 Then
                If YannWarn(x) = 0 Then NUCO = NUCO + 1
            Else
                NUCO = NUCO + 1
            End If
            OutString = Str(ENumb)
            
            OutString = OutString + " ," + Trim(Str(x))
            If ExRecFlag <> 1 Then
                If YannWarn(x) = 1 Then
                    OutString = OutString + "~"
                End If
            End If
            XP = BestEvent(x, 0)
            YP = BestEvent(x, 1)
            BE = XoverList(XP, YP).Beginning
            EN = XoverList(XP, YP).Ending
            D = XoverList(XP, YP).Daughter
            P1 = XoverList(XP, YP).MinorP
            P2 = XoverList(XP, YP).MajorP
            OutString = OutString + "," + Str(Decompress(BE))
            If XoverList(XP, YP).SBPFlag = 1 Or XoverList(XP, YP).SBPFlag = 3 Then
                 OutString = OutString + "*"
            End If
            OutString = OutString + SegSymbol
            OutString = OutString + ","
            If EN > Len(StrainSeq(0)) Then EN = Len(StrainSeq(0))
            If EN < 1 Then EN = 1
            OutString = OutString + Str(Decompress(EN))
            If XoverList(XP, YP).SBPFlag = 2 Or XoverList(XP, YP).SBPFlag = 3 Then
                 OutString = OutString + "*"
            End If
            OutString = OutString + SegSymbol
            OutString = OutString + ","
            Dim OS1 As Long, SSB As Long, SSE As Long
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = D * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                Get #FF, (((BE + OS1) - 1) * 4) + 1, SSB
                Get #FF, (((EN + OS1) - 1) * 4) + 1, SSE
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(BE, D)
                SSE = SeqSpaces(EN, D)
                'SSE = SeqSpaces(osbc, CSeq)
            End If
            OutString = OutString + Str(Decompress(BE) - SSB)
            If XoverList(XP, YP).SBPFlag = 1 Or XoverList(XP, YP).SBPFlag = 3 Then
                 OutString = OutString + "*"
            End If
            OutString = OutString + SegSymbol
            OutString = OutString + ","
            OutString = OutString + Str(Decompress(EN) - SSE)
            If XoverList(XP, YP).SBPFlag = 2 Or XoverList(XP, YP).SBPFlag = 3 Then
                 OutString = OutString + "*"
            End If
            OutString = OutString + SegSymbol
            OutString = OutString + ","
            If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                Get #FF, (((BE + OS1) - 1) * 4) + 1, SSB
                Get #FF, (((EN + OS1) - 1) * 4) + 1, SSE
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(BE, TypeSeq)
                SSE = SeqSpaces(EN, TypeSeq)
                'SSE = SeqSpaces(osbc, CSeq)
            End If
            OutString = OutString + Str(Decompress(BE) - SSB)
            If XoverList(XP, YP).SBPFlag = 1 Or XoverList(XP, YP).SBPFlag = 3 Then
                 OutString = OutString + "*"
            End If
            OutString = OutString + SegSymbol
            OutString = OutString + ","
            OutString = OutString + Str(Decompress(EN) - SSE)
            If XoverList(XP, YP).SBPFlag = 2 Or XoverList(XP, YP).SBPFlag = 3 Then
                 OutString = OutString + "*"
            End If
            OutString = OutString + SegSymbol
            OutString = OutString + ","
            
            'Sequences
            If XoverList(XP, YP).MissIdentifyFlag > 0 Or DScores(10, 0, x) < DScores(10, 1, x) Or DScores(10, 0, x) < DScores(10, 2, x) Then
                If XoverList(XP, YP).MissIdentifyFlag >= 10 Or DScores(10, 0, x) < DScores(10, 1, x) Or DScores(10, 0, x) < DScores(10, 2, x) Then
                    OutString = OutString + "^"
                End If
            End If
            If XoverList(XP, YP).BeginP < 0 Then
                Dim DV1 As Long, DV2 As Long, DV3 As Long, DV4 As Long
                Call SplitP(-XoverList(XP, YP).BeginP, DV1, DV2)
                If XoverList(XP, YP).EndP < 0 Then
                    Call SplitP(-XoverList(XP, YP).EndP, DV3, DV4)
                End If
                
                If D > PermNextno Then
                    If D1 = DV2 Then
                        OutString = OutString + FullOName(DV1)
                    ElseIf D1 = DV4 Then
                        OutString = OutString + FullOName(DV3)
                    End If
                Else
                    OutString = OutString + OriginalName(D)
                End If
                
                
                OutString = OutString + ","
                
                If P1 > PermNextno Then
                    If P1 = DV2 Then
                        If XoverList(XP, YP).OutsideFlag = 2 Then
                            OutString = OutString + "Unknown (" + FullOName(DV1) + ")"
                        Else
                            OutString = OutString + FullOName(DV1)
                        End If
                    ElseIf P1 = DV4 Then
                        If XoverList(XP, YP).OutsideFlag = 2 Then
                            OutString = OutString + "Unknown (" + FullOName(DV3) + ")"
                        Else
                            OutString = OutString + FullOName(DV3)
                        End If
                    End If
                
                Else
                    If XoverList(XP, YP).OutsideFlag = 2 Then
                        OutString = OutString + "Unknown (" + OriginalName(P1) + ")"
                    Else
                         OutString = OutString + OriginalName(P1)
                    End If
                End If
                
                OutString = OutString + ","
                If P2 > PermNextno Then
                    If P2 = DV2 Then
                        If XoverList(XP, YP).OutsideFlag = 2 Then
                            OutString = OutString + "Unknown (" + FullOName(DV1) + ")"
                        Else
                            OutString = OutString + FullOName(DV1)
                        End If
                    ElseIf P2 = DV4 Then
                        If XoverList(XP, YP).OutsideFlag = 2 Then
                            OutString = OutString + "Unknown (" + FullOName(DV3) + ")"
                        Else
                            OutString = OutString + FullOName(DV3)
                        End If
                    End If
                
                Else
                    If XoverList(XP, YP).OutsideFlag = 2 Then
                        OutString = OutString + "Unknown (" + OriginalName(P2) + ")"
                    Else
                         OutString = OutString + OriginalName(P2)
                    End If
                End If
            Else
                OutString = OutString + OriginalName(D)
                OutString = OutString + ","
                
                If XoverList(XP, YP).OutsideFlag = 2 Then
                    OutString = OutString + "Unknown (" + OriginalName(P1) + ")"
                Else
                     OutString = OutString + OriginalName(P1)
                End If
                OutString = OutString + ","
                If XoverList(XP, YP).OutsideFlag = 1 Then
                    OutString = OutString + "Unknown (" + OriginalName(P2) + ")"
                Else
                     OutString = OutString + OriginalName(P2)
                End If
            End If
            OutString = OutString + ","
            For Z = 0 To AddNum - 1
                If BPV(x, Z) < LowestProb Then
                    OutString = OutString + Str(BPV(x, Z))
                Else
                    OutString = OutString + "NS"
                End If
                OutString = OutString + ","
            Next Z
            Print #1, OutString
            
            ReDim NHolder(3, NextNo)
            Cnt = 0
            For Z = 0 To NextNo
                If Z <> D Then
                    If Daught(x, Z) > 0 Then
                        NHolder(0, Cnt) = OriginalName(Z)
                        If Daught(x, Z) > 1 And Daught(x, Z) < 4 Then
                            NHolder(0, Cnt) = NHolder(0, Cnt) + "[P]"
                        ElseIf Daught(x, Z) = 5 Then
                            NHolder(0, Cnt) = NHolder(0, Cnt) + "[T]"
                        End If
                        Cnt = Cnt + 1
                    End If
                End If
            Next Z
            Cnt = 0
            For Z = 0 To NextNo
                If Z <> P1 Then
                    If MinorPar(x, Z) = 1 Then
                        If XoverList(XP, YP).OutsideFlag <> 2 Then
                            NHolder(1, Cnt) = OriginalName(Z)
                        Else
                            NHolder(1, Cnt) = "Unknown(" + OriginalName(Z) + ")"
                        End If
                        Cnt = Cnt + 1
                    End If
                End If
            Next Z
            Cnt = 0
            For Z = 0 To NextNo
                If Z <> P2 Then
                    If MajorPar(x, Z) = 1 Then
                        If XoverList(XP, YP).OutsideFlag <> 1 Then
                            NHolder(2, Cnt) = OriginalName(Z)
                        Else
                            NHolder(2, Cnt) = "Unknown(" + OriginalName(Z) + ")"
                        End If
                        Cnt = Cnt + 1
                    End If
                End If
            Next Z
            
            For Z = 0 To NextNo
                If NHolder(0, Z) = "" And NHolder(1, Z) = "" And NHolder(2, Z) = "" Then Exit For
                OutString = Str(ENumb) + ",,,,,,,,"
                OutString = OutString + NHolder(0, Z) + "," + NHolder(1, Z) + "," + NHolder(2, Z)
                Print #1, OutString
            Next Z
            Print #1, ""
        End If
Next x
Print #1, "~            = It is possible that this apparent recombination signal could have been caused by an evolutionary"
Print #1, "               process other than recombination."
Print #1, "*            = The actual breakpoint position is undetermined (it was most likely either overprinted by a subsequent "
Print #1, "               recombination event or off the edges of the analysed sequence fragments)."
Print #1, "$            = This might not be breakpoint - it is likey the edge of a genome segment (possibly exchanged during reassortment)"

Print #1, "^            = The recombinant sequence may have been misidentified (one of the identified parents might be the recombinant)"

Print #1, "Minor Parent = Parent contributing the smaller fraction of sequence."
Print #1, "Major Parent = Parent contributing the larger fraction of sequence."
Print #1, "Unknown      = Only one parent and a recombinant need be in the alignment for a recombination event to be detectable."
Print #1, "               The sequence listed as unknown was used to infer the existance of a missing parental sequence."
Print #1, "NS           = No significant P-value was recorded for this recombination event using the particular method in question."
NumEventsAboveCO = ENumb

Close #1
Call OutputRecTestCSV(Left(FName$, Len(FName$) - 4) + "RecIDTests" + ".csv", Excl())

End Sub
Public Sub MakeSeqCoverage(SF, SubValid() As Single)

    Dim Dummy As Long, oDir As String, FF As Long, UB As Long, NextnoX As Long, MaxCoverage As Long, x As Long, Y As Long, A As Long, b As Long
    If NextNo < PermNextno Then
        ReDim SeqCoverage(PermNextno)
    Else
        ReDim SeqCoverage(NextNo)
    End If
    If UBound(SeqCoverage) < UBound(TreeTraceSeqs, 2) Then
        ReDim SeqCoverage(UBound(TreeTraceSeqs, 2))
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = 0
    UB = UBound(SubValid, 1)
    On Error GoTo 0
    
    If UB = 0 Then ' > LowMemThreshold Then
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        FF = FreeFile
        If UBSubValid > 0 Then
            ReDim SubValid(UBSubValid, UBSubValid)
        Else
            ReDim SubValid(PermNextno, PermNextno)
        End If
        Open "RDP5SubValid" + UFTag For Binary As #FF
        Get #FF, , SubValid()
        Close #FF
            
        ChDir oDir
        ChDrive oDir
    End If
    'XX = SubValid(20, 5)
'    XX = UBound(SubValid, 1)
'    XX = TreeTraceSeqs(1, NextNo)
    'XX = SubValid(NextNo, 4)
    If x = x Then
        Dummy = MakeSeqCoverageC(SF, NextNo, UBound(SubValid, 1), UBound(TreeTraceSeqs, 2), UBound(SeqCoverage, 1), SubValid(0, 0), SeqCoverage(0), TreeTraceSeqs(0, 0), TreeTrace(0))
        x = x
        
    Else
        MaxCoverage = 0
        If SF = 0 Then
            NextnoX = UBound(SeqCoverage, 1)
            If NextnoX < UBound(TreeTraceSeqs, 2) Then NextnoX = UBound(TreeTraceSeqs, 2)
        Else
            NextnoX = NextNo
        End If
        Dim C As Long, D As Long
        
        
        For A = 0 To NextNo
            For b = A + 1 To NextNo
                If SF = 0 Then
                    x = TreeTraceSeqs(1, A)
                    Y = TreeTraceSeqs(1, b)
                    
                Else
                    x = A
                    Y = b
                End If
               ' If X = 13 Then
               '     X = X
               ' End If
               ' If TreeTrace(X) = 19 Or TreeTrace(Y) = 19 Then
               '     X = X
               ' End If
                If x <> Y Then
                    If SubValid(x, Y) > SeqCoverage(A) Then
                        SeqCoverage(A) = SubValid(x, Y)
                        If SubValid(x, Y) > MaxCoverage Then
                            MaxCoverage = SubValid(x, Y)
                        End If
                    End If
                    If SubValid(x, Y) > SeqCoverage(b) Then
                        SeqCoverage(b) = SubValid(x, Y)
                    End If
                End If
            Next b
        Next A
        For x = 0 To UBound(SeqCoverage, 1)
            If x = 388 Then
                x = x
            End If
            If MaxCoverage > 0 Then
                SeqCoverage(x) = (SeqCoverage(x) / MaxCoverage)
                If SeqCoverage(x) > 1 Then
                    SeqCoverage(x) = 1
                End If
                'If SeqCoverage(X) < 0.8 Then SeqCoverage(X) = 0.1
            Else
                SeqCoverage(x) = 0
            End If
        Next x
    End If
    
   


End Sub
Public Sub UPGMADraw(TreeTrace() As Long, TreeTraceSeqs() As Long, PermNextno, NodeFind() As Byte, NodeXY() As Long, TNum, TType As Byte, NextNo As Long, NodeLengthB() As Double, TreeRX() As Integer, TreeRY() As Integer)
    Dim ScaleSize As Long, g As Long, U As Long, SFactX As Single, A As Long, b As Long, Y As Long, Dummy As Long, NodeMaxRep() As Single, Xpos() As Double, YPos() As Double, x As Long, TRegion As Double, NodeAdjust As Double, FormerXPos As Double, FirstPos As Double
    Dim FPX As Double, NAX As Double, ThisSeq As Long, ScaleVal As String, ScaleValD As Double, YAdjD As Integer
    Dim UBX As Long
    UBX = UBound(NodeFind, 2)
    
    If UBound(TreeDraw, 5) < NextNo * 4 Then
        ReDim Preserve TreeDraw(3, 4, 1, 4, NextNo * 4)
    End If
    ReDim Xpos(NextNo), YPos(NextNo)
    'ReDim NodeMaxRep(PermNextno + 10, 1)
    If PermNextno > NextNo Then
        ReDim NodeMaxRep(PermNextno + 10 + MaxEListLen, 1)
    Else
        ReDim NodeMaxRep(NextNo + 10 + MaxEListLen, 1)
    End If
    
    YAdjD = 14
    TRegion = 0.8 * Form1.Picture16.ScaleWidth: NAX = 0.8 * Form2.Picture2(0).ScaleWidth
    TRegion = 0.8 * Form2.Picture2(0).ScaleWidth
'XX = UBound(TreeRX, 1)
'    SS = Abs(GetTickCount)
    FirstPos = CLng(TRegion) - 5
    FPX = CLng(NAX) - 5
'    SS = Abs(GetTickCount)
    If NextNo <= PermNextno Or x = x Then
        
'        SS = Abs(GetTickCount)
        'If X = X Then
            Dummy = ClearNodeArrays(PermNextno, TType, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), UBound(NodeXY, 1), UBound(NodeXY, 2), NodeMaxRep(0, 0), NodeFind(0, 0), NodeXY(0, 0, 0))
'        Else
'            For X = 0 To PermNextno
'                For Y = 0 To PermNextno
'                    NodeFind(X, Y) = 0
'                Next Y
'                NodeMaxRep(X, 0) = 0
'                NodeMaxRep(X, 1) = 0
'                NodeXY(TType, X, 0) = -1
'                NodeXY(TType, X, 1) = -1
'            Next X
'        End If
'        EE = Abs(GetTickCount)
'        TT = EE - SS '0.4
'        X = X
    Else
        
        If UBound(NodeFind, 2) >= NextNo Then
            If x = x Then
                Dummy = EmptyNodeFind(NextNo, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
                For x = 0 To NextNo
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            Else
                For x = 0 To NextNo
                    For Y = 0 To NextNo
                        NodeFind(x, Y) = 0
                    Next Y
                    NodeMaxRep(x, 0) = 0
                    NodeMaxRep(x, 1) = 0
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            End If
        Else
            UBX = UBound(NodeFind, 2)
            If x = x Then
                Dummy = EmptyNodeFind(UBX, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
                For x = 0 To UBX
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            Else
                
                For x = 0 To UBX
                    For Y = 0 To UBX
                        NodeFind(x, Y) = 0
                    Next Y
                    NodeMaxRep(x, 0) = 0
                    NodeMaxRep(x, 1) = 0
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            End If
        End If
        
    End If
    A = -1: b = -1
'    EE = Abs(GetTickCount)
'    TT = EE - SS '0.047 for 1300 seqs
    '0.505 for 1700 seqs
    'If (Nextno * YAdjD + 3) > 32000 Then
    '    sfactx = 32000 / (Nextno * YAdjD + 3)
    'Else
        SFactX = 1
    'End If
    
    'UnModNextno
    
    
    
    For x = 0 To NextNo
    
        If UBound(TreeRX, 1) >= NextNo - 1 Then
        
            ThisSeq = TreeRX(NextNo - 1, x)
            
            If ThisSeq > UBound(XCord, 3) Then
                ReDim Preserve XCord(4, 3, ThisSeq + 10)
                ReDim Preserve YCord(4, 3, ThisSeq + 10)
                ReDim Preserve RYCord(4, 3, ThisSeq + 10)
            End If
            If ThisSeq > -1 Then
                XCord(TNum, TType, ThisSeq) = TRegion
                YCord(TNum, TType, ThisSeq) = (x * YAdjD + 3) * SFactX
                RYCord(TNum, TType, x) = ThisSeq
                Xpos(ThisSeq) = FirstPos
                YPos(ThisSeq) = (10 + x * YAdjD) * SFactX
                b = b + 1
                TreeDraw(TType, TNum, 0, 0, b) = TRegion
                TreeDraw(TType, TNum, 0, 1, b) = YCord(TNum, TType, ThisSeq)
                TreeDraw(TType, TNum, 0, 2, b) = ThisSeq
                TreeDraw(TType, TNum, 0, 3, b) = -1
            Else
                Exit For
            End If
        End If
    Next 'X

    
    If NodeLengthB(NextNo - 1) > 0 Then
        NodeAdjust = (TRegion - 10) / NodeLengthB(NextNo - 1)
        NAX = (NAX - 10) / NodeLengthB(NextNo - 1)
    Else
         NodeAdjust = (TRegion - 10)
         NAX = (NAX - 10)
    End If
    
    'Work out sequence coverage
    'Dim SeqCoverage() As Double
    
    
   
    'This is used to track nodes in the tree
    Dim UBTTS As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    UBTTS = -1
    UBTTS = UBound(TreeTraceSeqs, 2)
    On Error GoTo 0
    If MaxEListLen > 0 Then
        For x = 0 To UBound(SeqCoverage)
            If SeqCoverage(x) = 0 Then
                SeqCoverage(x) = 1
            End If
        Next x
    End If
    If NextNo <= PermNextno Then
'        SS = Abs(GetTickCount)
'
        If TType <> 0 Then 'And Nextno <= PermNextno Then
            
            
            If UBTTS > 0 Then
            'XX = SeqCoverage(100)
            'XX = NodeMaxRep(100, 1)
            '''''
            '@
                Dummy = FillNodeMaxRep(TType, UBound(NodeMaxRep, 1), NextNo, UBound(NodeFind, 1), UBound(TreeRX, 1), UBound(TreeRY, 1), UBTTS, UBound(TreeTrace, 1), UBound(SeqCoverage, 1), NodeMaxRep(0, 0), NodeFind(0, 0), TreeRY(0), TreeRX(0, 0), SeqCoverage(0), TreeTraceSeqs(0, 0), TreeTrace(0))
                
               
            End If
        Else
            SS = Abs(GetTickCount)
            XX = UBound(TreeRX, 2)
            If x = x Then
                Dummy = EmptyNodeFind(PermNextno, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
            Else
                For x = 0 To PermNextno
                    For Y = 0 To PermNextno
                        NodeFind(x, Y) = 0
                    Next Y
                    NodeMaxRep(x, 0) = 0
                    NodeMaxRep(x, 1) = 0
                Next x
            End If
             EE = Abs(GetTickCount)
             TT = EE - SS
            ' 0.687 nextno =4715

            SS = Abs(GetTickCount)
             'This code should be ported to c++
             '@
             SS = Abs(GetTickCount)
             Dim UBSC1 As Long, UBNF2 As Long
             UBSC1 = UBound(SeqCoverage, 1)
             UBNF2 = UBound(NodeFind, 2)
             For x = 0 To NextNo
                 For Y = 0 To NextNo
                     If TreeRX(x, Y) > -1 Then
                         If TType = 0 Then
                             If x = x Then
                                If TreeRX(x, Y) <= UBNF2 Then
                                    NodeFind(x, TreeRX(x, Y)) = 1
                                    'find out whether "y" is on the upper or lower branch
                                    U = 0
                                    For g = 0 To Y
                                        If TreeRX(x, g) = TreeRY(x) Then
                                            U = 1
                                            Exit For
                                        End If
                                    Next g
                                    
                                    If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                        If x <= UBX Then
                                            If TreeRX(x, Y) <= UBSC1 Then
                                                
                                                
                                                If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                            End If
                                        End If
                                    Else
                                        If x <= UBX Then
                                            
                                            If TreeRX(x, Y) <= UBSC1 Then
                                                
                                                If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                            End If
                                        End If
                                    End If
                                End If
                                
                             End If
                         Else
                             If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBTTS Then
                                If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBNF2 Then
                                    NodeFind(x, TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y)))) = 1
                                    'find out whether "y" is on the upper or lower branch
                                    U = 0
                                    For g = 0 To Y
                                        If TreeRX(x, g) = TreeRY(x) Then
                                            U = 1
                                            Exit For
                                        End If
                                    Next g
                                    If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                        If x <= UBX Then
                                                If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    Else
                                        If x <= UBX Then
                                            If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    End If
                                End If
                                
                             End If
                         End If
                     Else
                         Exit For
                     End If
                 Next Y
             Next x
             EE = Abs(GetTickCount)
             TT = EE - SS
             x = x
        End If
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS '0.296 for 1300 seqs
'
        '3.573 for nextno = 4715
        '1.250 for nextno = 3800 (Freds sequences)
        x = x
    Else
       
        'need to make sure that we dont read/write outside array bounds - nextno>opermnextno is unusual
        SS = Abs(GetTickCount)
        XX = UBound(TreeRX, 2)
        If x = x Then
            Dummy = EmptyNodeFind(PermNextno, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
        Else
            For x = 0 To PermNextno
                For Y = 0 To PermNextno
                    NodeFind(x, Y) = 0
                Next Y
                NodeMaxRep(x, 0) = 0
                NodeMaxRep(x, 1) = 0
            Next x
        End If
         EE = Abs(GetTickCount)
         TT = EE - SS
        ' 0.687 nextno =4715

        SS = Abs(GetTickCount)
         'This code should be ported to c++
         '@
         Dim UBNF1 As Long, UBNF As Long, UBSC As Long
         UBNF = UBound(NodeFind, 2)
         UBNF1 = UBound(NodeFind, 1)
         UBSC = UBound(SeqCoverage, 1)
         Dim UBTTS2 As Long
         x = x
         UBTTS2 = UBound(TreeTraceSeqs, 2)
         SS = Abs(GetTickCount)
         'XX = PermNextno
         
         
         
'         XX = UBound(TreeRX, 1)
'         XX = UBound(TreeRX, 2)
         For x = 0 To NextNo
             For Y = 0 To NextNo
                 If TreeRX(x, Y) > -1 Then
                     If TType = 0 Then
                         If x = x Then
                            If TreeRX(x, Y) <= UBNF Then
                                XX = UBound(NodeFind, 1)
                                If UBNF1 >= x Then
                                    NodeFind(x, TreeRX(x, Y)) = 1
                                End If
                                'find out whether "y" is on the upper or lower branch
                                U = 0
                                For g = 0 To Y
                                    If TreeRX(x, g) = TreeRY(x) Then
                                        U = 1
                                        Exit For
                                    End If
                                Next g
                                
                                If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                    If x <= UBX Then
                                        If TreeRX(x, Y) <= UBSC Then
                                            
                                            
                                            If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    End If
                                Else
                                    If x <= UBX Then
                                        
                                        If TreeRX(x, Y) <= UBSC Then
                                            
                                            If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    End If
                                End If
                            End If
                            
                         End If
                     Else
                         If TreeRX(x, Y) <= UBTTS2 Then
                            If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBTTS2 Then
                               If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBNF Then
                                   If UBNF1 >= x Then
                                        NodeFind(x, TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y)))) = 1
                                    End If
                                   'find out whether "y" is on the upper or lower branch
                                   U = 0
                                   For g = 0 To Y
                                       If TreeRX(x, g) = TreeRY(x) Then
                                           U = 1
                                           Exit For
                                       End If
                                   Next g
                                   If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                       If x <= UBX Then
                                           If TreeRX(x, Y) <= UBSC Then
                                               If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                           End If
                                       End If
                                   Else
                                       If x <= UBX Then
                                           If TreeRX(x, Y) <= UBSC Then
                                               If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                           End If
                                       End If
                                   End If
                               End If
                               
                            End If
                        End If
                     End If
                 Else
                     Exit For
                 End If
             Next Y
         Next x
         EE = Abs(GetTickCount)
         TT = EE - SS
         x = x
       
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS '0.296 for 1300 seqs
'
        '3.573 for nextno = 4715
        '1.250 for nextno = 3800 (Freds sequences)
        x = x
    End If
    
    Call WriteNodeFind(NodeFind(), TType)
    
    Dim BackNode() As Long
    ReDim BackNode(NextNo)
    
    
    Dim BkRx As Double, BkGx As Double, BkBx As Double
    
    BkRx = BkR - 10
    BkGx = BkG - 10
    BkBx = BkB - 10
    
    For x = 0 To NextNo - 1 '- 1
        
        If Xpos(TreeRX(x, 0)) <= Xpos(TreeRY(x)) Then
            'Form1.Picture16.Line (XPos(TreeRX(X, 0)), YPos(TreeRX(X, 0)))-(XPos(TreeRX(X, 0)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRX(X, 0)))), YPos(TreeRX(X, 0)))
            
            
            '@
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRX(x, 0)) - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - Xpos(TreeRX(x, 0))))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
            End If
            
            
            FormerXPos = Xpos(TreeRY(x))
            Xpos(TreeRY(x)) = Xpos(TreeRX(x, 0))
            'Form1.Picture16.Line (FormerXPos, YPos(TreeRY(X)))-(FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YPos(TreeRY(X)))
            
            A = A + 1
            
            TreeDraw(TType, TNum, 1, 0, A) = FormerXPos
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 2, A) = FormerXPos - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - FormerXPos))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
            End If
            
            
        ElseIf Xpos(TreeRY(x)) <= Xpos(TreeRX(x, 0)) Then
            'Form1.Picture16.Line (XPos(TreeRY(X)), YPos(TreeRY(X)))-(XPos(TreeRY(X)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRY(X)))), YPos(TreeRY(X)))
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRY(x)) 'XXXXXXXXXXXXXXXXXXXXXXXX
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRY(x)) - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - Xpos(TreeRY(x))))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
            End If
            FormerXPos = Xpos(TreeRX(x, 0))
            Xpos(TreeRX(x, 0)) = Xpos(TreeRY(x))
            'Form1.Picture16.Line (FormerXPos, YPos(TreeRX(X, 0)))-(FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YPos(TreeRX(X, 0)))
            
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = FormerXPos 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 2, A) = FormerXPos - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - FormerXPos))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
            End If
        Else
            'Form1.Picture16.Line (XPos(TreeRX(X, 0)), YPos(TreeRX(X, 0)))-(XPos(TreeRX(X, 0)) - NodeLengthB(X) * NodeAdjust, YPos(TreeRX(X, 0)))
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRX(x, 0)) - CLng(NodeLengthB(x) * NodeAdjust)
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
            End If
            'Form1.Picture16.Line (XPos(TreeRY(X)), YPos(TreeRY(X)))-(XPos(TreeRY(X)) - NodeLengthB(X) * NodeAdjust, YPos(TreeRY(X)))
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRY(x)) - CLng(NodeLengthB(x) * NodeAdjust)
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
            End If
        End If

        'base line
        'Form1.Picture16.Line (FirstPos - NodeLengthB(X) * NodeAdjust, YPos(TreeRX(X, 0)))-(FirstPos - NodeLengthB(X) * NodeAdjust, YPos(TreeRY(X)) + 1)
        A = A + 1
        TreeDraw(TType, TNum, 1, 0, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
        TreeDraw(TType, TNum, 1, 2, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x)) + (YPos(TreeRX(x, 0)) - YPos(TreeRY(x))) / 2
        If x <= UBX Then
            TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
        End If
        A = A + 1
        TreeDraw(TType, TNum, 1, 0, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        
        '
        TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
        TreeDraw(TType, TNum, 1, 2, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0)) - (YPos(TreeRX(x, 0)) - YPos(TreeRY(x))) / 2
        If x <= UBX Then
            TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
        End If
        'This stores the x and Y coords of all the nodes
        If (NextNo <= PermNextno Or MaxEListLen > 0) And x <= UBound(NodeXY, 2) Then
            NodeXY(TType, x, 0) = FPX - CLng(NodeLengthB(x) * NAX)
            NodeXY(TType, x, 1) = YPos(TreeRX(x, 0)) + (YPos(TreeRY(x)) - YPos(TreeRX(x, 0))) / 2
        End If
        
        
        YPos(TreeRX(x, 0)) = YPos(TreeRX(x, 0)) + (YPos(TreeRY(x)) - YPos(TreeRX(x, 0))) / 2
        YPos(TreeRY(x)) = YPos(TreeRY(x)) + (YPos(TreeRY(x)) - YPos(TreeRX(x, 0))) / 2
        Xpos(TreeRX(x, 0)) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        Xpos(TreeRY(x)) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        
    Next 'X
    
    
    
    
    
    ScaleValD = 0.1

    If ScaleValD * NodeAdjust > Form2.Picture2(0).ScaleWidth / 2 Then

        Do While ScaleValD * NodeAdjust > Form2.Picture2(0).ScaleWidth / 2
            ScaleValD = ScaleValD / 2
        Loop

    End If
    
    
    
    
    
    
    
    'Form1.Picture16.Line (5, (Nextno + 2) * YAdjD)-(5 + ScaleValD * NodeAdjust, (Nextno + 2) * YAdjD), QBColor(0)
    A = A + 1
    TreeDraw(TType, TNum, 1, 0, A) = 5
    TreeDraw(TType, TNum, 1, 1, A) = (NextNo + 2) * YAdjD
    TreeDraw(TType, TNum, 1, 2, A) = 5 + ScaleValD * NodeAdjust
    TreeDraw(TType, TNum, 1, 3, A) = (NextNo + 2) * YAdjD
    
    
    ScaleVal = ScaleValD
    ScaleSize = Form2.Picture2(0).TextWidth(ScaleVal)
    
    'Form1.Picture16.CurrentX = 5 + ((ScaleValD * NodeAdjust) - ScaleSize) / 2 '(5 + (100 + NodeAdjust * 0.1) / 2.5)
    'Form1.Picture16.CurrentY = (Nextno + 2.5) * YAdjD
    'Form1.Picture16.Print ScaleVal
    b = b + 1
    TreeDraw(TType, TNum, 0, 0, b) = 5 + ((ScaleValD * NodeAdjust) - ScaleSize) / 2
    TreeDraw(TType, TNum, 0, 1, b) = (NextNo + 2.5) * YAdjD
    TreeDraw(TType, TNum, 0, 2, b) = -1
    TreeDraw(TType, TNum, 0, 3, b) = -ScaleValD * 10000
    
    Call MakeTreeDrawB(TreeDraw(), TreeDrawB())
    
    TDLen(TType, TNum, 1) = A
    TDLen(TType, TNum, 0) = b
    TDLen(TType, TNum, 2) = Form2.Picture2(0).ScaleWidth
End Sub
Public Sub UPGMADrawMessedup(TreeTrace() As Long, TreeTraceSeqs() As Long, PermNextno, NodeFind() As Byte, NodeXY() As Long, TNum, TType As Byte, NextNo As Long, NodeLengthB() As Double, TreeRX() As Integer, TreeRY() As Integer)
    Dim ScaleSize As Long, g As Long, U As Long, SFactX As Single, A As Long, b As Long, Y As Long, Dummy As Long, NodeMaxRep() As Single, Xpos() As Double, YPos() As Double, x As Long, TRegion As Double, NodeAdjust As Double, FormerXPos As Double, FirstPos As Double
    Dim FPX As Double, NAX As Double, ThisSeq As Long, ScaleVal As String, ScaleValD As Double, YAdjD As Integer
    Dim UBX As Long
    UBX = UBound(NodeFind, 2)
    
    If UBound(TreeDraw, 5) < NextNo * 4 Then
        ReDim Preserve TreeDraw(3, 4, 1, 4, NextNo * 4)
    End If
    ReDim Xpos(NextNo), YPos(NextNo)
    ReDim NodeMaxRep(PermNextno + 10 + MaxEListLen, 1)
    
    YAdjD = 14
    TRegion = 0.8 * Form1.Picture16.ScaleWidth: NAX = 0.8 * Form2.Picture2(0).ScaleWidth
    TRegion = 0.8 * Form2.Picture2(0).ScaleWidth
'XX = UBound(TreeRX, 1)
'    SS = Abs(GetTickCount)
    FirstPos = CLng(TRegion) - 5
    FPX = CLng(NAX) - 5
'    SS = Abs(GetTickCount)
    If NextNo <= PermNextno Then
        
'        SS = Abs(GetTickCount)
        'If X = X Then
            Dummy = ClearNodeArrays(PermNextno, TType, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), UBound(NodeXY, 1), UBound(NodeXY, 2), NodeMaxRep(0, 0), NodeFind(0, 0), NodeXY(0, 0, 0))
'        Else
'            For X = 0 To PermNextno
'                For Y = 0 To PermNextno
'                    NodeFind(X, Y) = 0
'                Next Y
'                NodeMaxRep(X, 0) = 0
'                NodeMaxRep(X, 1) = 0
'                NodeXY(TType, X, 0) = -1
'                NodeXY(TType, X, 1) = -1
'            Next X
'        End If
'        EE = Abs(GetTickCount)
'        TT = EE - SS '0.4
'        X = X
    Else
        
        If UBound(NodeFind, 2) >= NextNo Then
            If x = x Then
                Dummy = EmptyNodeFind(NextNo, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
                For x = 0 To NextNo
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            Else
                For x = 0 To NextNo
                    For Y = 0 To NextNo
                        NodeFind(x, Y) = 0
                    Next Y
                    NodeMaxRep(x, 0) = 0
                    NodeMaxRep(x, 1) = 0
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            End If
        Else
            UBX = UBound(NodeFind, 2)
            If x = x Then
                Dummy = EmptyNodeFind(UBX, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
                For x = 0 To UBX
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            Else
                
                For x = 0 To UBX
                    For Y = 0 To UBX
                        NodeFind(x, Y) = 0
                    Next Y
                    NodeMaxRep(x, 0) = 0
                    NodeMaxRep(x, 1) = 0
                    NodeXY(TType, x, 0) = -1
                    NodeXY(TType, x, 1) = -1
                Next x
            End If
        End If
        
    End If
    A = -1: b = -1
'    EE = Abs(GetTickCount)
'    TT = EE - SS '0.047 for 1300 seqs
    '0.505 for 1700 seqs
    'If (Nextno * YAdjD + 3) > 32000 Then
    '    sfactx = 32000 / (Nextno * YAdjD + 3)
    'Else
        SFactX = 1
    'End If
    
    'UnModNextno
    
    
    
    For x = 0 To NextNo
    
        If UBound(TreeRX, 1) >= NextNo - 1 Then
        
            ThisSeq = TreeRX(NextNo - 1, x)
            
            If ThisSeq > UBound(XCord, 3) Then
                ReDim Preserve XCord(4, 3, ThisSeq + 10)
                ReDim Preserve YCord(4, 3, ThisSeq + 10)
                ReDim Preserve RYCord(4, 3, ThisSeq + 10)
            End If
            If ThisSeq > -1 Then
                XCord(TNum, TType, ThisSeq) = TRegion
                YCord(TNum, TType, ThisSeq) = (x * YAdjD + 3) * SFactX
                RYCord(TNum, TType, x) = ThisSeq
                Xpos(ThisSeq) = FirstPos
                YPos(ThisSeq) = (10 + x * YAdjD) * SFactX
                b = b + 1
                TreeDraw(TType, TNum, 0, 0, b) = TRegion
                TreeDraw(TType, TNum, 0, 1, b) = YCord(TNum, TType, ThisSeq)
                TreeDraw(TType, TNum, 0, 2, b) = ThisSeq
                TreeDraw(TType, TNum, 0, 3, b) = -1
            Else
                Exit For
            End If
        End If
    Next 'X

    
    If NodeLengthB(NextNo - 1) > 0 Then
        NodeAdjust = (TRegion - 10) / NodeLengthB(NextNo - 1)
        NAX = (NAX - 10) / NodeLengthB(NextNo - 1)
    Else
         NodeAdjust = (TRegion - 10)
         NAX = (NAX - 10)
    End If
    
    'Work out sequence coverage
    'Dim SeqCoverage() As Double
    
    
   
    'This is used to track nodes in the tree
    Dim UBTTS As Long
    If DebuggingFlag < 2 Then On Error Resume Next
    UBTTS = -1
    UBTTS = UBound(TreeTraceSeqs, 2)
    On Error GoTo 0
    If NextNo <= PermNextno Then
'        SS = Abs(GetTickCount)
'
        If TType <> 0 Then 'And Nextno <= PermNextno Then
            
            
            If UBTTS > 0 Then
            'XX = SeqCoverage(100)
            'XX = NodeMaxRep(100, 1)
            '''''
            '@
                Dummy = FillNodeMaxRep(TType, PermNextno, NextNo, UBound(NodeFind, 1), UBound(TreeRX, 1), UBound(TreeRY, 1), UBTTS, UBound(TreeTrace, 1), UBound(SeqCoverage, 1), NodeMaxRep(0, 0), NodeFind(0, 0), TreeRY(0), TreeRX(0, 0), SeqCoverage(0), TreeTraceSeqs(0, 0), TreeTrace(0))
                
               
            End If
        Else
            SS = Abs(GetTickCount)
            XX = UBound(TreeRX, 2)
            If x = x Then
                Dummy = EmptyNodeFind(PermNextno, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
            Else
                For x = 0 To PermNextno
                    For Y = 0 To PermNextno
                        NodeFind(x, Y) = 0
                    Next Y
                    NodeMaxRep(x, 0) = 0
                    NodeMaxRep(x, 1) = 0
                Next x
            End If
             EE = Abs(GetTickCount)
             TT = EE - SS
            ' 0.687 nextno =4715

            SS = Abs(GetTickCount)
             'This code should be ported to c++
             '@
             SS = Abs(GetTickCount)
             Dim UBSC1 As Long, UBNF2 As Long
             UBSC1 = UBound(SeqCoverage, 1)
             UBNF2 = UBound(NodeFind, 2)
             For x = 0 To NextNo
                 For Y = 0 To NextNo
                     If TreeRX(x, Y) > -1 Then
                         If TType = 0 Then
                             If x = x Then
                                If TreeRX(x, Y) <= UBNF2 Then
                                    NodeFind(x, TreeRX(x, Y)) = 1
                                    'find out whether "y" is on the upper or lower branch
                                    U = 0
                                    For g = 0 To Y
                                        If TreeRX(x, g) = TreeRY(x) Then
                                            U = 1
                                            Exit For
                                        End If
                                    Next g
                                    
                                    If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                        If x <= UBX Then
                                            If TreeRX(x, Y) <= UBSC1 Then
                                                
                                                
                                                If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                            End If
                                        End If
                                    Else
                                        If x <= UBX Then
                                            
                                            If TreeRX(x, Y) <= UBSC1 Then
                                                
                                                If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                            End If
                                        End If
                                    End If
                                End If
                                
                             End If
                         Else
                             If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBTTS Then
                                If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBNF2 Then
                                    NodeFind(x, TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y)))) = 1
                                    'find out whether "y" is on the upper or lower branch
                                    U = 0
                                    For g = 0 To Y
                                        If TreeRX(x, g) = TreeRY(x) Then
                                            U = 1
                                            Exit For
                                        End If
                                    Next g
                                    If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                        If x <= UBX Then
                                                If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    Else
                                        If x <= UBX Then
                                            If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    End If
                                End If
                                
                             End If
                         End If
                     Else
                         Exit For
                     End If
                 Next Y
             Next x
             EE = Abs(GetTickCount)
             TT = EE - SS
             x = x
        End If
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS '0.296 for 1300 seqs
'
        '3.573 for nextno = 4715
        '1.250 for nextno = 3800 (Freds sequences)
        x = x
    Else
       
        'need to make sure that we dont read/write outside array bounds - nextno>opermnextno is unusual
        SS = Abs(GetTickCount)
        XX = UBound(TreeRX, 2)
        If x = x Then
            Dummy = EmptyNodeFind(PermNextno, UBound(NodeFind, 1), UBound(NodeMaxRep, 1), NodeFind(0, 0), NodeMaxRep(0, 0))
        Else
            For x = 0 To PermNextno
                For Y = 0 To PermNextno
                    NodeFind(x, Y) = 0
                Next Y
                NodeMaxRep(x, 0) = 0
                NodeMaxRep(x, 1) = 0
            Next x
        End If
         EE = Abs(GetTickCount)
         TT = EE - SS
        ' 0.687 nextno =4715

        SS = Abs(GetTickCount)
         'This code should be ported to c++
         '@
         Dim UBNF1 As Long, UBNF As Long, UBSC As Long
         UBNF = UBound(NodeFind, 2)
         UBNF1 = UBound(NodeFind, 1)
         UBSC = UBound(SeqCoverage, 1)
         Dim UBTTS2 As Long
         x = x
         UBTTS2 = UBound(TreeTraceSeqs, 2)
         SS = Abs(GetTickCount)
         'XX = PermNextno
         
         
         
'         XX = UBound(TreeRX, 1)
'         XX = UBound(TreeRX, 2)
         For x = 0 To NextNo
             For Y = 0 To NextNo
                 If TreeRX(x, Y) > -1 Then
                     If TType = 0 Then
                         If x = x Then
                            If TreeRX(x, Y) <= UBNF Then
                                XX = UBound(NodeFind, 1)
                                If UBNF1 >= x Then
                                    NodeFind(x, TreeRX(x, Y)) = 1
                                End If
                                'find out whether "y" is on the upper or lower branch
                                U = 0
                                For g = 0 To Y
                                    If TreeRX(x, g) = TreeRY(x) Then
                                        U = 1
                                        Exit For
                                    End If
                                Next g
                                
                                If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                    If x <= UBX Then
                                        If TreeRX(x, Y) <= UBSC Then
                                            
                                            
                                            If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    End If
                                Else
                                    If x <= UBX Then
                                        
                                        If TreeRX(x, Y) <= UBSC Then
                                            
                                            If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                        End If
                                    End If
                                End If
                            End If
                            
                         End If
                     Else
                         If TreeRX(x, Y) <= UBTTS2 Then
                            If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBTTS2 Then
                               If TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y))) <= UBNF Then
                                   If UBNF1 >= x Then
                                        NodeFind(x, TreeTrace(TreeTraceSeqs(1, TreeRX(x, Y)))) = 1
                                    End If
                                   'find out whether "y" is on the upper or lower branch
                                   U = 0
                                   For g = 0 To Y
                                       If TreeRX(x, g) = TreeRY(x) Then
                                           U = 1
                                           Exit For
                                       End If
                                   Next g
                                   If U = 0 Then 'XPos(TreeRX(X, 0)) <= mxp Then
                                       If x <= UBX Then
                                           If TreeRX(x, Y) <= UBSC Then
                                               If NodeMaxRep(x, 0) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 0) = SeqCoverage(TreeRX(x, Y))
                                           End If
                                       End If
                                   Else
                                       If x <= UBX Then
                                           If TreeRX(x, Y) <= UBSC Then
                                               If NodeMaxRep(x, 1) < SeqCoverage(TreeRX(x, Y)) Then NodeMaxRep(x, 1) = SeqCoverage(TreeRX(x, Y))
                                           End If
                                       End If
                                   End If
                               End If
                               
                            End If
                        End If
                     End If
                 Else
                     Exit For
                 End If
             Next Y
         Next x
         EE = Abs(GetTickCount)
         TT = EE - SS
         x = x
       
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS '0.296 for 1300 seqs
'
        '3.573 for nextno = 4715
        '1.250 for nextno = 3800 (Freds sequences)
        x = x
    End If
    
    Call WriteNodeFind(NodeFind(), TType)
    
    Dim BackNode() As Long
    ReDim BackNode(NextNo)
    
    
    Dim BkRx As Double, BkGx As Double, BkBx As Double
    
    BkRx = BkR - 10
    BkGx = BkG - 10
    BkBx = BkB - 10
    
'    For x = 0 To NextNo
'        If NodeMaxRep(x, 0) = 0 Or NodeMaxRep(x, 1) = 0 Then
'            x = x
'        End If
'    Next x
    
    For x = 0 To NextNo - 1 '- 1
        
        If Xpos(TreeRX(x, 0)) <= Xpos(TreeRY(x)) Then
            'Form1.Picture16.Line (XPos(TreeRX(X, 0)), YPos(TreeRX(X, 0)))-(XPos(TreeRX(X, 0)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRX(X, 0)))), YPos(TreeRX(X, 0)))
            
            
            '@
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRX(x, 0)) - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - Xpos(TreeRX(x, 0))))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
            End If
            
            
            FormerXPos = Xpos(TreeRY(x))
            Xpos(TreeRY(x)) = Xpos(TreeRX(x, 0))
            'Form1.Picture16.Line (FormerXPos, YPos(TreeRY(X)))-(FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YPos(TreeRY(X)))
            
            A = A + 1
            
            TreeDraw(TType, TNum, 1, 0, A) = FormerXPos
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 2, A) = FormerXPos - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - FormerXPos))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
            End If
            
            
        ElseIf Xpos(TreeRY(x)) <= Xpos(TreeRX(x, 0)) Then
            'Form1.Picture16.Line (XPos(TreeRY(X)), YPos(TreeRY(X)))-(XPos(TreeRY(X)) - (NodeLengthB(X) * NodeAdjust - (FirstPos - XPos(TreeRY(X)))), YPos(TreeRY(X)))
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRY(x)) 'XXXXXXXXXXXXXXXXXXXXXXXX
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRY(x)) - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - Xpos(TreeRY(x))))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
            End If
            FormerXPos = Xpos(TreeRX(x, 0))
            Xpos(TreeRX(x, 0)) = Xpos(TreeRY(x))
            'Form1.Picture16.Line (FormerXPos, YPos(TreeRX(X, 0)))-(FormerXPos - (NodeLengthB(X) * NodeAdjust - (FirstPos - FormerXPos)), YPos(TreeRX(X, 0)))
            
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = FormerXPos 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 2, A) = FormerXPos - CLng(NodeLengthB(x) * NodeAdjust - (FirstPos - FormerXPos))
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
            End If
        Else
            'Form1.Picture16.Line (XPos(TreeRX(X, 0)), YPos(TreeRX(X, 0)))-(XPos(TreeRX(X, 0)) - NodeLengthB(X) * NodeAdjust, YPos(TreeRX(X, 0)))
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRX(x, 0)) - CLng(NodeLengthB(x) * NodeAdjust)
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
            End If
            'Form1.Picture16.Line (XPos(TreeRY(X)), YPos(TreeRY(X)))-(XPos(TreeRY(X)) - NodeLengthB(X) * NodeAdjust, YPos(TreeRY(X)))
            A = A + 1
            TreeDraw(TType, TNum, 1, 0, A) = Xpos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
            TreeDraw(TType, TNum, 1, 2, A) = Xpos(TreeRY(x)) - CLng(NodeLengthB(x) * NodeAdjust)
            TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x))
            If x <= UBX Then
                TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
            End If
        End If

        'base line
        'Form1.Picture16.Line (FirstPos - NodeLengthB(X) * NodeAdjust, YPos(TreeRX(X, 0)))-(FirstPos - NodeLengthB(X) * NodeAdjust, YPos(TreeRY(X)) + 1)
        A = A + 1
        TreeDraw(TType, TNum, 1, 0, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRX(x, 0))
        TreeDraw(TType, TNum, 1, 2, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRY(x)) + (YPos(TreeRX(x, 0)) - YPos(TreeRY(x))) / 2
        If x <= UBX Then
            TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 0), BkGx - BkGx * NodeMaxRep(x, 0), BkBx - BkBx * NodeMaxRep(x, 0))
        End If
        A = A + 1
        TreeDraw(TType, TNum, 1, 0, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        
        '
        TreeDraw(TType, TNum, 1, 1, A) = YPos(TreeRY(x))
        TreeDraw(TType, TNum, 1, 2, A) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        TreeDraw(TType, TNum, 1, 3, A) = YPos(TreeRX(x, 0)) - (YPos(TreeRX(x, 0)) - YPos(TreeRY(x))) / 2
        If x <= UBX Then
            TreeDraw(TType, TNum, 1, 4, A) = RGB(BkRx - BkRx * NodeMaxRep(x, 1), BkGx - BkGx * NodeMaxRep(x, 1), BkBx - BkBx * NodeMaxRep(x, 1))
        End If
        'This stores the x and Y coords of all the nodes
        If NextNo <= PermNextno Or MaxEListLen > 0 Then
            NodeXY(TType, x, 0) = FPX - CLng(NodeLengthB(x) * NAX)
            NodeXY(TType, x, 1) = YPos(TreeRX(x, 0)) + (YPos(TreeRY(x)) - YPos(TreeRX(x, 0))) / 2
        End If
        
        
        YPos(TreeRX(x, 0)) = YPos(TreeRX(x, 0)) + (YPos(TreeRY(x)) - YPos(TreeRX(x, 0))) / 2
        YPos(TreeRY(x)) = YPos(TreeRY(x)) + (YPos(TreeRY(x)) - YPos(TreeRX(x, 0))) / 2
        Xpos(TreeRX(x, 0)) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        Xpos(TreeRY(x)) = FirstPos - CLng(NodeLengthB(x) * NodeAdjust)
        
    Next 'X
    
    
    
    
    
    ScaleValD = 0.1

    If ScaleValD * NodeAdjust > Form2.Picture2(0).ScaleWidth / 2 Then

        Do While ScaleValD * NodeAdjust > Form2.Picture2(0).ScaleWidth / 2
            ScaleValD = ScaleValD / 2
        Loop

    End If
    
    
    
    
    
    
    
    'Form1.Picture16.Line (5, (Nextno + 2) * YAdjD)-(5 + ScaleValD * NodeAdjust, (Nextno + 2) * YAdjD), QBColor(0)
    A = A + 1
    TreeDraw(TType, TNum, 1, 0, A) = 5
    TreeDraw(TType, TNum, 1, 1, A) = (NextNo + 2) * YAdjD
    TreeDraw(TType, TNum, 1, 2, A) = 5 + ScaleValD * NodeAdjust
    TreeDraw(TType, TNum, 1, 3, A) = (NextNo + 2) * YAdjD
    
    
    ScaleVal = ScaleValD
    ScaleSize = Form2.Picture2(0).TextWidth(ScaleVal)
    
    'Form1.Picture16.CurrentX = 5 + ((ScaleValD * NodeAdjust) - ScaleSize) / 2 '(5 + (100 + NodeAdjust * 0.1) / 2.5)
    'Form1.Picture16.CurrentY = (Nextno + 2.5) * YAdjD
    'Form1.Picture16.Print ScaleVal
    b = b + 1
    TreeDraw(TType, TNum, 0, 0, b) = 5 + ((ScaleValD * NodeAdjust) - ScaleSize) / 2
    TreeDraw(TType, TNum, 0, 1, b) = (NextNo + 2.5) * YAdjD
    TreeDraw(TType, TNum, 0, 2, b) = -1
    TreeDraw(TType, TNum, 0, 3, b) = -ScaleValD * 10000
    
    Call MakeTreeDrawB(TreeDraw(), TreeDrawB())
    
    TDLen(TType, TNum, 1) = A
    TDLen(TType, TNum, 0) = b
    TDLen(TType, TNum, 2) = Form2.Picture2(0).ScaleWidth
End Sub
Public Sub MakeAncMod()

Dim NSeq() As Long, SeqArray() As Long, SelectNodeX As Long, HiD As Double
Dim TotD() As Double, OL As Long

'need to disable the picture so that a new node doesnt get selected during the run
For x = 0 To 3
    Form2.Picture2(x).Enabled = False
    
Next x

Form1.Picture16.Enabled = False

Screen.MousePointer = 11

UnModNextno
'First find an outlyer that is not in the selected group.
ReDim TotD(NextNo)


For x = 0 To NextNo
    For Y = 0 To NextNo
        TotD(x) = TotD(x) + (1 - Distance(x, Y))
        TotD(Y) = TotD(Y) + (1 - Distance(x, Y))
    Next Y
Next x
If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If


HiD = 0
ZZZ = 0
Dim NodeFind() As Byte
Call MakeNodeFind(NodeFind(), SelectNode(3))

For x = 0 To NextNo
    
    If NodeFind(SelectNode(0), x) = 0 Then  'exclude seqs above selected node
        If TotD(x) > HiD Then
            HiD = TotD(x)
            OL = x
            
        End If
        ZZZ = ZZZ + 1
    End If
    
Next x
 
'XX = NodeFind(0, 4, 20) '0,1=2,7; 0,2 =0,3,5; 0,3 =2,6,7; 0,4 = 4,13


'SelectNode(0) = zx 'the selected node
'SelectNode(1) = NodeXY(NHFlag, zx, 0) 'x coordinate of node
'SelectNode(2) = YPX 'adjusted y-coordinate of node
'SelectNode(3) = NHFlag 'the current tree nhfile
'SelectNode(4) = Index 'the pciturebox in the picturebox array
'Exit Sub

Dim BannedList() As Byte

ReDim BannedList(NextNo, NextNo) 'this will contain all the parental sequence pairs for which recombination must be accounted for
For x = 0 To NextNo 'the sequences
    For Y = 0 To NextNo 'the sequences
        If NodeFind(SelectNode(0), Y) <> NodeFind(SelectNode(0), x) Then  'gets rid of parental sequences that cross the selected node
            BannedList(x, Y) = 1
            BannedList(Y, x) = 1
        Else
            For Z = 0 To NextNo 'find a sequence in the selected clade
                If NodeFind(SelectNode(0), Z) = 1 Then
                    'now determine whether sequences x and y group before either groups with z -if they do not then they are considered to be a banned parent pair.
                    For A = 0 To NextNo
                        If (NodeFind(A, x) = 1 And NodeFind(A, Z) = 1) Or (NodeFind(A, Y) = 1 And NodeFind(A, Z) = 1) Then
                            If NodeFind(A, Z) = NodeFind(A, x) And NodeFind(A, Z) <> NodeFind(A, Y) Then
                                BannedList(x, Y) = 1
                                BannedList(Y, x) = 1
                                Exit For
                            ElseIf NodeFind(A, Z) = NodeFind(A, Y) And NodeFind(A, Z) <> NodeFind(A, x) Then
                                BannedList(x, Y) = 1
                                BannedList(Y, x) = 1
                                Exit For
                            End If
                        End If
                    Next A
                    Exit For
                End If
                
            Next Z
        End If
    Next Y
Next x



ReDim SeqArray(NextNo, NextNo), NSeq(NextNo)
ZZZ = 0
For Y = 0 To NextNo
    NSeq(Y) = -1
    If NodeFind(Y, OL) = 0 Then
        For x = 0 To NextNo
            If NodeFind(Y, x) = 1 Then
                NSeq(Y) = NSeq(Y) + 1
                SeqArray(Y, NSeq(Y)) = x
            End If
        Next x
        
    Else
        For x = 0 To NextNo
            If NodeFind(Y, x) = 0 Then
                NSeq(Y) = NSeq(Y) + 1
                SeqArray(Y, NSeq(Y)) = x
            End If
        Next x
    End If
Next Y

'XX = NSeq(0)
'XX = NSeq(1)
'XX = NSeq(3)
'XX = NSeq(10)
'XX = SelectNode(0)
Dim SL0 As Long, SL3 As Long
SL0 = SelectNode(0)
SL3 = SelectNode(3)
Dim oSA() As Long, oNS() As Long
ReDim oSA(UBound(SeqArray, 1), UBound(SeqArray, 2)), oNS(UBound(NSeq, 1))

SumAncSeq = ""
MLAncSeq = ""
ParsAncSeq = ""
    
'if recombination is to be taken into account then
' find recombination events that "cross" the branch between sl3 and slo - i.e. events with a minor parent that is (a) outside the group above sl3 and that (b) does not involve the entire group
' do this by deconstructing the recombination events


For x = 0 To UBound(SeqArray, 1)
    oNS(x) = NSeq(x)
    For Y = 0 To UBound(SeqArray, 2)
        oSA(x, Y) = SeqArray(x, Y)
    Next Y
Next x
Dim Recfree As Byte

Response = MsgBox("Would you like to take recombination into account when determining the ancestral sequence represented by this node?", vbYesNo)




If Response = 6 Then
    Recfree = 1
    GoOn = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).Accept = 1 Then
                GoOn = 1
                Exit For
            End If
        Next Y
        If GoOn = 1 Then Exit For
    Next x
    
    If GoOn = 1 Then
    
        Response = MsgBox("Would you like to only account for 'accepted' recombination events (those depicted with a coloured square with a red border in the bottom right panel of the program)?.  Pressing 'No' will take into consideration all of the recombination events depicted in the bottom right panel of the program.", vbYesNo)
        If Response = 6 Then
            ARQ = 0
        Else
            ARQ = 1
        End If
    Else
        ARQ = 1
    End If
Else
  
    Recfree = 0
    ARQ = 1
End If

Response = MsgBox("Would you like to use a Maximum Likelihood approach to inferring this ancestral sequence (it will be fast but does not account for phylogenetic uncertainty)? Pressing 'No' will result in the use of a maximum likelihood and a Bayesian approach (which will account for phylognetic uncertainty but could take a very long time - maybe even a few weeks).", vbYesNo)


Call AncParsML(ARQ, Recfree, SL3, SL0, SeqArray(), NSeq(), BannedList())
If ParsAncSeq = "" Then
    Call AncParsML(ARQ, Recfree, SL3, SL0, SeqArray(), NSeq(), BannedList())
End If
'SelectNode(0) = SL0

SelectNode(0) = SL0
If SelectNode(0) = -1 Then
    For x = 0 To 3
        Form2.Picture2(x).Enabled = True
        
    Next x
    Exit Sub
End If
Screen.MousePointer = 1
If Response = 6 Then
    'ARQ = 0
    Form1.SSPanel1.Caption = "Using RAxML to infer ancestral sequence"
    Form1.ProgressBar1.Value = 10
    Call UpdateF2Prog
    DoMLAncsFlag = 1
    SaveForMrBayes = 0
    Call MakeAncestralStateML(ARQ, Recfree, NSeq(), SeqArray(), SL0, OL, BannedList(), NodeFind())
    'Call MakeAncestralState(ARQ, Recfree, NSeq(), SeqArray(), SL0, OL, BannedList())
Else
    'ARQ = 1
    Form1.SSPanel1.Caption = "Using RAxML to infer ancestral sequence"
    Form1.ProgressBar1.Value = 10
    Call UpdateF2Prog
    'DoMLAncsFlag = 0
    DoMLAncsFlag = 1
    SaveForMrBayes = 1
  
    Call MakeAncestralStateML(ARQ, Recfree, NSeq(), SeqArray(), SL0, OL, BannedList(), NodeFind())
    
    Form1.ProgressBar1.Value = 0
     
    Form1.SSPanel1.Caption = "Using MrBayes to infer ancestral sequence"
    Form1.ProgressBar1.Value = 15
    Call UpdateF2Prog
    
    Call MakeAncestralState(ARQ, Recfree, NSeq(), SeqArray(), SL0, OL, BannedList())
    SaveForMrBayes = 0
    
    x = x
End If

For x = 0 To 3
    Form2.Picture2(x).Enabled = True
Next x
Form1.Picture16.Enabled = True


'OL is the outlyer

Form1.ProgressBar1.Value = 0
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
Screen.MousePointer = 0
End Sub
Public Sub MarkEventForRemoval(SEN As Long, RX As Long, RY As Long)
Dim x As Long, Y As Long
For x = 0 To PermNextno
    If Daught(SEN, x) > 0 Then
        For Y = 0 To CurrentXOver(x)
            If RX <> x Or RY <> Y Then
                If SuperEventList(XoverList(x, Y).Eventnumber) = SEN Then
                    
                    XoverList(x, Y).Probability = -1
                
                End If
            End If
        Next Y
    End If
    If MinorPar(SEN, x) > 0 Then
        For Y = 0 To BCurrentXoverMi(x)
            If SuperEventList(BestXOListMi(x, Y).Eventnumber) = SEN Then
                BestXOListMi(x, Y).Probability = -1
            End If
        Next Y
    End If
    If MajorPar(SEN, x) > 0 Then
        For Y = 0 To BCurrentXoverMa(x)
            If SuperEventList(BestXOListMa(x, Y).Eventnumber) = SEN Then
                BestXOListMa(x, Y).Probability = -1
            End If
        Next Y
    End If
Next x

End Sub
Public Sub LHWinsize(SEN As Long, MW As Long, CW As Long)

Dim x As Long, Y As Long, mTotV As Long, mTotN As Long, cTotV As Long, cTotN As Long, PR As Long

For x = 0 To PermNextno
    If Daught(SEN, x) = 1 Then
        For Y = 1 To CurrentXOver(x)
            If SuperEventList(XoverList(x, Y).Eventnumber) = SEN Then
                PR = XoverList(x, Y).ProgramFlag
                If PR > AddNum - 1 Then PR = PR - AddNum
                If PR = 3 Then 'maxchi
                    mTotN = mTotN + 1
                    mTotV = mTotV + XoverList(x, Y).LHolder
                ElseIf PR = 4 Then 'chimaera
                    cTotN = cTotN + 1
                    cTotV = cTotV + XoverList(x, Y).LHolder
                End If
            End If
        Next Y
    End If
Next x
If mTotN > 0 Then
    MW = mTotV / mTotN
Else
    MW = 60
End If
If cTotN > 0 Then
    CW = cTotV / cTotN
Else
    CW = 60
End If


End Sub
Public Sub PutPerms()
oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    Open "RDP5PermDistance" + UFTag For Binary As #FF
    '@
    Put #FF, , Distance()
    Close #FF
    
    Open "RDP5PermTreeDistance" + UFTag For Binary As #FF
    
    Put #FF, , TreeDistance()
    Close #FF
    
    
   
    
    UBPermValid = UBound(PermValid, 1)
    Open "RDP5PPermValid" + UFTag For Binary As #FF
    Put #FF, , PermValid()
    Close #FF
    UBPermDiffs = UBound(PermDIffs, 1)
    Open "RDP5PPermDiffs" + UFTag For Binary As #FF
    Put #FF, , PermDIffs()
    Close #FF
    
    
    ChDir oDir
    ChDrive oDir
End Sub
Public Sub GetDatasetPerms(x As Long)
Dim UB1 As Long, UB2 As Long, FF As Long
        
        
        FF = FreeFile + 100
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        Dim Pos As Long
        Open "RDP5Dataset" + UFTag For Binary As FF
        
        Get #FF, SeqnumCoords(x, 0), UB1
        Get #FF, , UB2
        ReDim SeqNum(UB1, UB2)
        Get #FF, , SeqNum()
        'SeqnumCoords(X, 1) = Seek(FF)
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim Distance(UB1, UB2)
        Get #FF, , Distance()
        
        'SeqnumCoords(X, 2) = Seek(FF)
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim PermValid(UB1, UB2)
        Get #FF, , PermValid()
        
        
        'SeqnumCoords(X, 3) = Seek(FF)
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim PermDIffs(UB1, UB2)
        Get #FF, , PermDIffs()
        
        'SeqnumCoords(X, 4) = Seek(FF)
        Get #FF, , UB1
        Get #FF, , UB2
        ReDim TreeDistance(UB1, UB2)
        Get #FF, , TreeDistance()
        
        
        
        
        'SeqnumCoords(X, 5) = Seek(FF)
        Get #FF, , UB1
        ReDim MaskSeq(UB1)
        Get #FF, , MaskSeq()
        ReDim pMaskSeq(UB1)
        For Z = 0 To UB1
            pMaskSeq(Z) = MaskSeq(Z)
        Next Z
        
        Close #FF
        ChDrive oDirX
        ChDir oDirX
End Sub
Public Sub GetDatasetNum()
Dim x As Long

'TraceDatasetNo(0, X) = Y
'TraceDatasetNo(1, X) = NumInDataset(Y)
x = TraceDatasetNo(0, RelX)

Call GetDatasetPerms(x)

Dim oD As Long, oMi As Long, oMa As Long, oNextno As Long, oPermNextno As Long
oD = XoverList(RelX, RelY).Daughter
oMi = XoverList(RelX, RelY).MinorP
oMa = XoverList(RelX, RelY).MajorP

oNextno = NextNo
oPermNextno = PermNextno
XX = UBound(Distance, 1)
NextNo = NumInDataset(x)
PermNextno = NextNo
XoverList(RelX, RelY).Daughter = TraceDatasetNo(1, oD)
XoverList(RelX, RelY).MinorP = TraceDatasetNo(1, oMi)
XoverList(RelX, RelY).MajorP = TraceDatasetNo(1, oMa)
JumpInFlag = 1
Call SchemDown(1)
JumpInFlag = 0
XoverList(RelX, RelY).Daughter = oD
XoverList(RelX, RelY).MinorP = oMi
XoverList(RelX, RelY).MajorP = oMa
NextNo = oNextno
PermNextno = oPermNextno

End Sub
Public Function FastRecCheck(NextNo As Long, SeqNum() As Integer, Seq1 As Long, Seq2 As Long, Seq3 As Long, LenStrainSeq As Long, XoverWindow As Long, XOverWindowX As Integer, XoverSeqNum() As Integer, XoverSeqNumW() As Byte)
Dim GoOn As Long, NumSame As Long
Dim XOverLen As Long, A As Long, Dummy As Variant, OldX As Long

Dim AFact As Double, b As Long, BE As Long, EN As Long, NCommon As Long, StartPosX As Long
Dim NextPosX As Long
Dim oProbXOver As Double
Dim FindCycle As Integer, SeqDaughter As Long, SeqMinorP As Long, Temp As Integer, EndFlag As Long, HighHomol As Long, MedHomol As Long, LowHomol As Long
Dim x As Long, NumDifferent As Long

Dim SLen As Long
Dim AH(2) As Long
    

    
    'SSSS = abs(gettickcount)
    'For x = 1 To 100000
'    If UBound(CompressSeq, 2) = Nextno Then
        '@'@'@'@'@'@'@
        'LenXoverSeq = FindSubSeqPB(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), Nextno, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), XDiffPos(0), XPosDiff(0), FSSRDP(0, 0, 0, 0))
        LenXoverSeq = FindSubSeqPB3(AH(0), UBound(FSSRDP, 2), XoverWindow, UBound(CompressSeq, 1), Len(StrainSeq(0)), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0), FSSRDP(0, 0, 0, 0))
'    Else
'        LenXoverSeq = FindSubSeqP(AH(0), 0, 2, XoverWindow, LenStrainSeq, Nextno, Seq1, Seq2, Seq3, 0, SeqNum(0, 0), XoverSeqNum(0, 0), XoverSeqNumW(0, 0), SpacerSeqs(0), XDiffPos(0), XPosDiff(0), ValidSpacer(0))
'    End If
'    Next x
'    eeee = abs(gettickcount)
'    TT = eeee - SSSS
    
    If LenXoverSeq < XoverWindow * 2 Then
        Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        FastRecCheck = 0
        Exit Function
    ElseIf AH(0) < XoverWindow / 3 Or AH(1) < XoverWindow / 3 Or AH(2) < XoverWindow / 3 Then
        Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        FastRecCheck = 0
        Exit Function
    ElseIf AH(0) = 0 Or AH(1) = 0 Or AH(2) = 0 Then
        Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        FastRecCheck = 0
        Exit Function
    End If
    
    AvHomol(1) = (AH(0) / LenXoverSeq)
    AvHomol(2) = (AH(1) / LenXoverSeq)
    AvHomol(3) = (AH(2) / LenXoverSeq)
    
    AvHomol(3) = (CLng(AvHomol(3) * 10000)) / 10000 '0.3088
    AvHomol(1) = (CLng(AvHomol(1) * 10000)) / 10000 '0.4847
    AvHomol(2) = (CLng(AvHomol(2) * 10000)) / 10000 '0.2065
    
    LenXoverSeq = Abs(LenXoverSeq) - 1 '875
    
    'HighHomol = 1
    'MedHomol = 2
    'LowHomol = 3
    
'  If x = 123456789 Then
    
        HighHomol = 1 'we know this is teh case because seq1 and seq2 are the most closely related remaining relative pair

        If AvHomol(2) >= AvHomol(3) Then
            MedHomol = 2: LowHomol = 3
            SeqDaughter = 0: SeqMinorP = 2
        
        Else 'If AvHomol(3) > AvHomol(2) Then
            MedHomol = 3: LowHomol = 2
            SeqDaughter = 1: SeqMinorP = 2
        'Else
        '    Exit Sub
        End If

'   Else
'
'    If UBound(TreeDistance, 1) > 0 Then
'        If TreeDistance(Seq1, Seq2) >= TreeDistance(Seq1, Seq3) And TreeDistance(Seq1, Seq2) >= TreeDistance(Seq2, Seq3) Then
'            HighHomol = 1
'        ElseIf TreeDistance(Seq1, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq1, Seq3) >= TreeDistance(Seq2, Seq3) Then
'            HighHomol = 2
'        ElseIf TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq2) And TreeDistance(Seq2, Seq3) >= TreeDistance(Seq1, Seq3) Then
'            HighHomol = 3
'        End If
'    Else
'       If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
'            HighHomol = 1
'        ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
'            HighHomol = 2
'        ElseIf Distance(Seq2, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq2, Seq3) >= Distance(Seq1, Seq3) Then
'            HighHomol = 3
'        End If
'    End If
'
'   End If
    
    
    'ReDim XOverHomologyNum(LenXOverSeq + XoverWindow * 2, 2)
    
    'C Routine to work out moving identity averages between the three sequences.  It
    'does the same thing as the VB routine XOHomologyX.
    
    '
    StartPosX = XOHomologyP(HighHomol, LenStrainSeq, LenXoverSeq, XoverWindow, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))


    If StartPosX = 0 And ShortOutFlag <> 3 Then
        Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
        FastRecCheck = 0
        Exit Function
    End If


'    If x = x Then
'        If Seq1 <= UBound(Distance, 1) And Seq2 <= UBound(Distance, 1) And Seq3 <= UBound(Distance, 1) Then
'            If AvHomol(1) = AvHomol(2) And AvHomol(1) = AvHomol(3) Then
'                If Distance(Seq1, Seq2) >= Distance(Seq1, Seq3) And Distance(Seq1, Seq2) >= Distance(Seq2, Seq3) Then
'                    If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
'                        AvHomol(2) = AvHomol(2) - 0.00001
'                        AvHomol(3) = AvHomol(3) - 0.00002
'                    Else
'                        AvHomol(2) = AvHomol(2) - 0.00002
'                        AvHomol(3) = AvHomol(3) - 0.00001
'                    End If
'                ElseIf Distance(Seq1, Seq3) >= Distance(Seq1, Seq2) And Distance(Seq1, Seq3) >= Distance(Seq2, Seq3) Then
'                    If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
'                        AvHomol(1) = AvHomol(1) - 0.00001
'                        AvHomol(3) = AvHomol(3) - 0.00002
'                    Else
'                        AvHomol(1) = AvHomol(1) - 0.00002
'                        AvHomol(3) = AvHomol(3) - 0.00001
'                    End If
'                Else
'                    If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
'                        AvHomol(1) = AvHomol(1) - 0.00001
'                        AvHomol(2) = AvHomol(2) - 0.00002
'                    Else
'                        AvHomol(1) = AvHomol(1) - 0.00002
'                        AvHomol(2) = AvHomol(2) - 0.00001
'                    End If
'                End If
'            ElseIf AvHomol(1) = AvHomol(2) Then
'                If Distance(Seq1, Seq2) > Distance(Seq1, Seq3) Then
'                    AvHomol(2) = AvHomol(2) - 0.00001
'                Else
'                    AvHomol(1) = AvHomol(1) - 0.00001
'                End If
'            ElseIf AvHomol(1) = AvHomol(3) Then
'                If Distance(Seq1, Seq2) > Distance(Seq2, Seq3) Then
'                    AvHomol(3) = AvHomol(3) - 0.00001
'                Else
'                    AvHomol(1) = AvHomol(1) - 0.00001
'                End If
'            ElseIf AvHomol(2) = AvHomol(3) Then
'                If Distance(Seq1, Seq3) > Distance(Seq2, Seq3) Then
'                    AvHomol(3) = AvHomol(3) - 0.00001
'                Else
'                    AvHomol(2) = AvHomol(2) - 0.00001
'                End If
'            End If
'
'        End If
'        'If PermNextno > LowMemThreshold Then
'        '    Erase Distance
'        'End If
'
'
'        '2.142
'
'
'        '@'@
'        If AvHomol(1) >= AvHomol(2) And AvHomol(1) >= AvHomol(3) Then
'            HighHomol = 1
'
'            If AvHomol(2) >= AvHomol(3) Then
'                MedHomol = 2: LowHomol = 3
'                ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
'                SeqDaughter = 0: SeqMinorP = 2
'
'            Else 'If AvHomol(3) > AvHomol(2) Then
'                MedHomol = 3: LowHomol = 2
'                ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
'                SeqDaughter = 1: SeqMinorP = 2
'            'Else
'            '    Exit Sub
'            End If
'
'        ElseIf AvHomol(2) >= AvHomol(1) And AvHomol(2) >= AvHomol(3) Then
'            HighHomol = 2
'
'            If AvHomol(1) >= AvHomol(3) Then
'                MedHomol = 1: LowHomol = 3
'                ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
'                SeqDaughter = 0: SeqMinorP = 1
'            Else 'If AvHomol(3) > AvHomol(1) Then
'                MedHomol = 3: LowHomol = 1
'                ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
'                SeqDaughter = 2: SeqMinorP = 1
'            'Else
'            '    Exit Sub
'            End If
'
'        ElseIf AvHomol(3) >= AvHomol(1) And AvHomol(3) >= AvHomol(2) Then
'            HighHomol = 3
'
'            If AvHomol(1) >= AvHomol(2) Then
'                MedHomol = 1: LowHomol = 2
'                ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
'                SeqDaughter = 1: SeqMinorP = 0
'            Else 'If AvHomol(2) > AvHomol(1) Then
'                MedHomol = 2: LowHomol = 1
'                ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
'                SeqDaughter = 2: SeqMinorP = 0
'            'Else
'            '    Exit Sub
'            End If
'
'        End If
'
'
'    End If
   
    FindCycle = 0
    
    
    OldX = -1
    Dim AVal As Long, TC As Long
    AVal = 1
    Dim UBXOHN As Long
    UBXOHN = UBound(XOverHomologyNum, 1)
    
    Do
        '
        NextPosX = 1 'StartPosX
        
        
        Do
            
            
            'This could be speeded up a bit
            
            x = FindNextP(UBXOHN, NextPosX, HighHomol, MedHomol, LowHomol, LenXoverSeq, XoverWindow, XOverHomologyNum(0, 0))
                
                
            '
            If x > -1 And x <> OldX Then
                OldX = x
                '5.078 - 1K perms
                
                If CircularFlag = 1 And XOverHomologyNum(x, MedHomol - 1) > XOverHomologyNum(x, HighHomol - 1) And x = 1 Then 'And ReassortmentFlag = 0 Then
                    
                    x = FindFirstCOP(x, MedHomol, HighHomol, LenXoverSeq, UBXOHN, XOverHomologyNum(0, 0))
                    
                Else
                    
                    NCommon = 0
                    XOverLength = 0
                    
                    x = DefineEventP2(UBXOHN, ShortOutFlag, LongWindedFlag, MedHomol, HighHomol, LowHomol, TargetX, CircularFlag, x, XoverWindow, SLen, LenXoverSeq, SeqMinorP, SeqDaughter, EndFlag, BE, EN, NCommon, XOverLength, XoverSeqNumW(0, 0), XOverHomologyNum(0, 0))
                    
                    If XOverLength > 2 And EN <> BE And (EN > BE Or CircularFlag = 1) Then ' And GoOnXX = 1 Then ' And BinTable((Int(XOverLength / 5) + 1), (Int(NCommon / 5) + 1), ip) < 0.5 Then
                        
                        NumDifferent = XOverLength - NCommon
                        
                        If NCommon > NumDifferent * 0.8 Then
                    
                        
                            If XOverLength >= 170 Then
                                AFact = XOverLength / 169
                                NumDifferent = CLng(NumDifferent * 169 / XOverLength)
                                XOverLength = 169
                                NumSame = XOverLength - NumDifferent
                            Else
                                '
                                AFact = 1
                                NumSame = NCommon
                            End If
                        
                        
                            IndProb = AvHomol(MedHomol)
                            GoOn = 0
                            If ProbEstimateInFileFlag = 0 Then
                                If ProbEstimate(XOverLength, NumSame, Int(IndProb * 50)) < LowestProb Then
                                    GoOn = 1
                                End If
                            Else
                                GoOn = 1
                            End If
                            If GoOn = 1 Then '169,169-6,16, lenxoverseq =1644
                                '
                                'if i put the worthwhile scan filter here it skips ~2399 trips and gets the right answer - on;y ~5% time reduction though
                                
                                If XOverLength <= UBFact3x3 Then
                                    '
                                    ProbabilityXOver = ProbCalcP2(Fact3X3(0, 0, 0), UBFact3x3, XOverLength, NumSame, IndProb, LenXoverSeq)
                                Else
                                    
                                    ProbabilityXOver = ProbCalcP(Fact(0), XOverLength, XOverLength - NumDifferent, IndProb, LenXoverSeq)
                                End If
                           
                        
                        
                            
                                If AFact <> 1 Then
                                    If ProbabilityXOver > 0 Then
                                        ProbabilityXOver = ProbabilityXOver ^ AFact
                                    Else
                                        ProbabilityXOver = 0.05
                                    End If
                                End If
                                If ProbabilityXOver < UCThresh Then
                                    'if i put the worthwhile scan filter here it skips ~3000 trips and gets the right answer - only ~5% time reduction though
'                                    BQPV = ProbabilityXOver
'                                    FastRecCheck = 1 * MCCorrection
'                                    Exit Function
                                    If EarlyBale = 1 Then
                                        Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
                                        FastRecCheck = 1
                                        Exit Function
                                    End If
                                    
                                    If MCFlag = 0 Then
                                        ProbabilityXOver = ProbabilityXOver * MCCorrection
                                    End If
                                    '
                                    
                                    If ProbabilityXOver < LowestProb And ProbabilityXOver > 0 Then
                                        BQPV = ProbabilityXOver
                                        Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
                                        FastRecCheck = 1
                                        Exit Function
                                    
                                    End If
                                
                                End If
                            '''''''4
                            End If
                            
                            
                        End If
                        ''''''
                    
                    End If
                    ''''''''''
                End If
                
                '1.923
                '
                If EndFlag = 1 Then
                    EndFlag = 0
                    x = LenXoverSeq
                End If
                
                If (x < LenXoverSeq + 1 And x > NextPosX) Then 'Or ReassortmentFlag = 1 Then
                    NextPosX = x + 1
                    
                Else
                    Exit Do
                End If
                
                '5.719 1K perms
                
            Else
                Exit Do
            End If
        Loop
        '3.895
        
        
        
        If FindCycle = 0 Then
            Temp = MedHomol
            MedHomol = LowHomol
            LowHomol = Temp
        ElseIf FindCycle = 1 Then
            'Exit Sub
            '5.027
            
            If AvHomol(HighHomol) < 0.7 Or DoAllFlag = 1 Then
                Temp = HighHomol
                HighHomol = LowHomol
                LowHomol = MedHomol
                MedHomol = Temp
            Else
                Exit Do
            End If

        Else
            Exit Do
        End If
'        If x = 12345678 Then
            If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
                
                SeqDaughter = 0: SeqMinorP = 2
            ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
                
                SeqDaughter = 1: SeqMinorP = 2
            ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
               
                SeqDaughter = 0: SeqMinorP = 1
            ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
                
                SeqDaughter = 2: SeqMinorP = 1
            ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
                
                SeqDaughter = 1: SeqMinorP = 0
            ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
                
                SeqDaughter = 2: SeqMinorP = 0
            End If
'        Else
'            If HighHomol = 1 And MedHomol = 2 And LowHomol = 3 Then
'                ActiveSeq = Seq1: ActiveMajorP = Seq2: ActiveMinorP = Seq3
'                SeqDaughter = 0: SeqMinorP = 2
'            ElseIf HighHomol = 1 And MedHomol = 3 And LowHomol = 2 Then
'                ActiveSeq = Seq2: ActiveMajorP = Seq1: ActiveMinorP = Seq3
'                SeqDaughter = 1: SeqMinorP = 2
'            ElseIf HighHomol = 2 And MedHomol = 1 And LowHomol = 3 Then
'                ActiveSeq = Seq1: ActiveMajorP = Seq3: ActiveMinorP = Seq2
'                SeqDaughter = 0: SeqMinorP = 1
'            ElseIf HighHomol = 2 And MedHomol = 3 And LowHomol = 1 Then
'                ActiveSeq = Seq3: ActiveMajorP = Seq1: ActiveMinorP = Seq2
'                SeqDaughter = 2: SeqMinorP = 1
'            ElseIf HighHomol = 3 And MedHomol = 1 And LowHomol = 2 Then
'                ActiveSeq = Seq2: ActiveMajorP = Seq3: ActiveMinorP = Seq1
'                SeqDaughter = 1: SeqMinorP = 0
'            ElseIf HighHomol = 3 And MedHomol = 2 And LowHomol = 1 Then
'                ActiveSeq = Seq3: ActiveMajorP = Seq2: ActiveMinorP = Seq1
'                SeqDaughter = 2: SeqMinorP = 0
'            End If
'
'        End If
        FindCycle = FindCycle + 1
        
        'Exit Sub
    Loop
    Dummy = CleanXOSNW(LenXoverSeq + XoverWindow, XoverWindow, UBound(XoverSeqNumW, 1), XoverSeqNumW(0, 0))
    FastRecCheck = 0
End Function
Public Sub SchemDown(Button As Integer)
'    sttime = Abs(GetTickCount)

If Seq1 = -1 Or Seq2 = -1 Or Seq3 = -1 Then Exit Sub

'If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) <= 1 Then '36, 62, 55
'
'    XX = GrpMaskSeq(Seq2)
'    XX = GrpMaskSeq(Seq3)
'End If

    If JumpInFlag = 0 And DatasetNumber > 0 Then
        Call GetDatasetNum
        Exit Sub
    End If
    SchemDownFlag = 1
    'GoTo Cleanup
    Dim oUD As Long, Index As Long, CB As Long, IndexX As Long, TNum As Long, TType As Long, ExtraDX As Long, NHFlag As Long, UB As Long, Y As Long, Dummy As Long, ENxx As Long, FF As Long, oDir As String, EN As Long, tSeqnum() As Integer
    Dim SEN As Long, Crap As String
    Dim x As Long, Tmp As Long
    Dim ZYFactor As Double, BRP As Long
    Dim oPointer As Long, xGCMissmatchPen As Long, xGCIndelFlag As Long, xGCMinFragLen As Long, xGCMinPolyInFrag As Long, xGCMinPairScore As Long, xGCMaxOverlapFrags As Long, xGCTripletFlag As Long
    BRP = ButtonRepress
    Dim LineStart As Integer, LineEnd As Integer, Z As Long
    
    
    
    oPointer = Screen.MousePointer
    With Form1
        .SSPanel3.Visible = True
        .SSPanel8.Visible = True
        .SSPanel5.Visible = True
        .SSPanel7.Visible = True
        .SSPanel4.Visible = True
    End With
    
   
    
    
    Form1.Command18.Enabled = True
    
    SelectedSeqNumber = -1
    AbortFlag = 0
'    ssxx = Abs(GetTickCount)
'   XX = Seq2
    Form1.Picture2.Refresh
    'Store variable states at start of analysis
    'If opxv = RelX And opyv = RelY Then Exit Sub
    'GoTo Cleanup
    If Button = 1 Then
        'DoEvents
        If ButtonRepress <> BRP Then
            'ButtonRepress = ButtonRepress - 1
            
            'Exit Sub
        End If
        If RIMode = 1 Then
            Call MakeSummary
        End If
        xMCTripletFlag = MCTripletFlag
        xMCProportionFlag = MCProportionFlag
        
        
        xMCStart = MCStart
        xMCEnd = MCEnd
        xMCMaxP = MCMaxP
        xMCSteplen = MCSteplen
        xMCWinSize = MCWinSize
        xMCWinFract = MCWinFract
        xMCStripGapsFlag = MCStripGapsFlag
        xMCFlag = MCFlag
        xXOverWindowX = XOverWindowX
        xCircularFlag = CircularFlag
        xSpacerFlag = SpacerFlag
        xLowestProb = LowestProb
        xBSTypeFlag = BSTypeFlag
        xBSStepSize = BSStepSize
        xBSStepWin = BSStepWin
        xBSBootReps = BSBootReps
        xBSCutoff = BSCutOff
        xBSPValFlag = BSPValFlag
        xSSGapFlag = SSGapFlag
        xSSVarPFlag = SSVarPFlag
        xSSOutlyerFlag = SSOutlyerFlag
        xSSRndSeed = SSRndSeed
        xSSWinLen = SSWinLen
        xSSStep = SSStep
        xSSNumPerms = SSNumPerms
        xGCMissmatchPen = GCMissmatchPen
        xGCIndelFlag = GCIndelFlag
        xGCMinFragLen = GCMinFragLen
        xGCMinPolyInFrag = GCMinPolyInFrag
        xGCMinPairScore = GCMinPairScore
        xGCMaxOverlapFrags = GCMaxOverlapFrags
        xGCTripletFlag = GCtripletflag
        xPPStripGaps = PPStripGaps
        Dim A As Integer
        If UBound(MaskSeq, 1) < PermNextno Then ReDim Preserve MaskSeq(PermNextno)
        If UBound(pMaskSeq) >= PermNextno Then
            For A = 0 To PermNextno
                MaskSeq(A) = pMaskSeq(A)
            Next 'A
        End If
        'Exit Sub
        MCTripletFlag = pMCTripletFlag
        MCProportionFlag = pMCProportionFlag
        
        
        MCStart = pMCStart
        MCEnd = pMCEnd
        MCMaxP = pMCMaxP
        MCSteplen = pMCSteplen
        MCWinSize = pMCWinSize
        MCWinFract = pMCWinFract
        MCStripGapsFlag = pMCStripGapsFlag
        MCFlag = pMCFlag
        XOverWindowX = pXOverWindowX
        CircularFlag = pCircularFlag
        SpacerFlag = pSpacerFlag
        LowestProb = pLowestProb
        BSTypeFlag = pBSTypeFlag
        BSStepSize = pBSStepSize
        BSStepWin = pBSStepWin
        BSBootReps = pBSBootReps
        BSCutOff = pBSCutoff
        BSPValFlag = pBSPValFlag
        
        SSGapFlag = pSSGapFlag
        SSVarPFlag = pSSVarPFlag
        SSOutlyerFlag = pSSOutlyerFlag
        SSRndSeed = pSSRndSeed
        SSWinLen = pSSWinLen
        SSStep = pSSStep
        SSNumPerms = pSSNumPerms
        PPStripGaps = pPPStripGaps

        If pGCTripletflag = 1 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) Then
            GCtripletflag = pGCTripletflag
            GCMissmatchPen = GCMissmatchPen
            GCIndelFlag = pGCIndelFlag
            GCMinFragLen = pGCMinFragLen
            GCMinPolyInFrag = pGCMinPolyInFrag
            GCMinPairScore = pGCMinPairScore
            GCMaxOverlapFrags = pGCMaxOverlapFrags
        End If
        
        If Form2.Visible = True Then
            Form1.Refresh
            'Form2.WindowState = 1
        End If
        For x = 7 To 12
            NHString(x) = ""
        Next x
        NHString(14) = ""
        NHString(15) = ""
        
        If Screen.MousePointer <> 11 Then
            Screen.MousePointer = 11
        End If
        Form1.SSPanel1.Caption = "Drawing Tree"
        'If ShowPlotFlag = 0 Then
            Form1.Frame17.Visible = False
        'End If
        If UpdateProgressBar = 0 Then
            Form1.ProgressBar1.Value = 1
            Call UpdateF2Prog
        End If
        Form1.Command6(3).Enabled = True
        Form1.Command33(2).Enabled = True
        Form1.Command33(3).Enabled = True
        Form1.Command17.Enabled = True
        
        
        
        Form1.Command6(0).Enabled = True
        
        TreeImage(1) = 0
        TreeImage(2) = 0
        'TreeImage(3) = 0
        'Set Flags
        RunFlag = 1
        RecombineFlag = 1
        ExeCheckFlag = 0
        OptFlag = -1
        CurrentCheck = -1
        'Retrive info on which recombinant region is neing studied
        'RelY = 0
        RecStart = XoverList(RelX, RelY).Beginning
        RecEnd = XoverList(RelX, RelY).Ending
        RecProb = XoverList(RelX, RelY).Probability
        
        Seq1 = XoverList(RelX, RelY).MajorP
        Seq2 = XoverList(RelX, RelY).MinorP
        Seq3 = XoverList(RelX, RelY).Daughter
        x = x
        'XX = StraiName(Seq3)
        'XX = OriginalName(Seq3)
        'Early start geneconv in the background

        Dim reshuffle As Integer
        'DoEvents
        'GoTo Cleanup
        If LongWindedFlag = 1 Then
                GDPCFlag = 0
                '701
                ReDim tSeqnum(Len(StrainSeq(0)), 2)
                '701
                EN = XoverList(RelX, RelY).Eventnumber
                'For X = 1 To Len(StrainSeq(0))
                
                
                
                    If ColDistInFile = 1 Then
                        ReDim ColDist2(0)
                        
                    End If
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 10
                        
                    End If
                    Form1.SSPanel1.Caption = "Removing recombinant regions"
                    Call UpdateF2Prog
                    'NJFlag = 0
                    EditSeqFlag = 0
'                    SS = Abs(GetTickCount)
                    DontDoTimer4Flag = 1
                    DontDoTimer1Flag = 1
                    '652
                    
                    Call UnModSeqNum(0)
                    '652
                    'Call UnModNextno
                    NextNo = PermNextno
                    
                    If PermNextno * (Len(StrainSeq(0))) > 10000000 Then
                        oDir = CurDir
                        ChDir App.Path
                        ChDrive App.Path
                        
                        'Erase SBlockBak
                        'redim permarray(0,0)
                        Dim UBSB1 As Long, UBSB2 As Long, UBPA1 As Long, UBPA2 As Long
                        UBSB1 = UBound(SBlockBak, 1)
                        UBSB2 = UBound(SBlockBak, 2)
                        FF = FreeFile
                        Open "SBlockBak" + UFTag For Binary As #FF
                        Put #FF, , SBlockBak()
                        Close #FF
                        
                        UBPA1 = UBound(PermArray, 1)
                        UBPA2 = UBound(PermArray, 2)
                        FF = FreeFile
                        Open "PermArray" + UFTag For Binary As #FF
                        Put #FF, , PermArray()
                        Close #FF
                        
                        If StrainSeqOnDisk = 0 Then
                            Open "RDP5Strainseq" + UFTag For Binary As #FF
                            Put #FF, , StrainSeq()
                            Close #FF
                            StrainSeqOnDisk = 1
                        
                        End If
                        ReDim Preserve StrainSeq(0)
                        Erase SBlockBak
                        ReDim PermArray(0, 0)
                            
                        ChDir oDir
                        ChDrive oDir
                    
                    End If
                    
                    'EditSeqFlag = 1
                    ScDME = XoverList(RelX, RelY).Ending: ScDMB = XoverList(RelX, RelY).Beginning
                    '652
                    'XX = Seq3
                    Call ModSeqNum(ScDMB, ScDME, 0)
                    
                    
                    
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    '1113
                    
                    If UpdateIDFlag = 1 Then
                        XX = RelX
                        XX = RelY
                        'ModNextno
                        Call UpdateIDScores
                        
                        'XX = SuperEventList(XOverlist(RelX, RelY).Eventnumber)
                        Seq1 = XoverList(RelX, RelY).MajorP
                        Seq2 = XoverList(RelX, RelY).MinorP
                        Seq3 = XoverList(RelX, RelY).Daughter
                        'ScDME = XOverlist(RelX, RelY).Ending: ScDMB = XOverlist(RelX, RelY).Beginning
                        
                        'need to cancel out the limits imposed during uodateidscore before redoing modseqnum
                        For x = 0 To NextNo
                            FMat(x, x) = 0
                            SMat(x, x) = 0
                        Next x
                        
                        
                        Call ModSeqNum(ScDMB, ScDME, 0)
                        
                    End If
                    '1113
                    'DoEvents

                    
                    
'                    EE = Abs(GetTickCount)
'                    TT = EE - SS '27.5/47.9
                    'Seq1 = TreeTrace(Seq1)
                    'Seq2 = TreeTrace(Seq2)
                    'Seq3 = TreeTrace(Seq3)
                    '9.719
                    '5.656
                    '15.413
                    BTSeq1 = Seq1
                    BTSeq2 = Seq2
                    BTSeq3 = Seq3
                    
'                     SS = Abs(GetTickCount)
                    Form1.SSPanel1.Caption = "Removing zero length sequences"
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 45
                        
                    End If
                    Call UpdateF2Prog
                    '1113,1049
                    
                    'GoTo Cleanup
                    
                    Call MakeTreeSeqs(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending)
                    '1041,1045
                    
                    'GoTo Cleanup
'                    EE = Abs(GetTickCount)
'                    TT = EE - SS
                    '6.042
                    '1.891  -without recalculating distances yet again
                    '0.780
                    GCSeq1 = Seq1
                    GCSeq2 = Seq2
                    GCSeq3 = Seq3
                    
                    If PermNextno * (Len(StrainSeq(0))) > 10000000 Then
                        oDir = CurDir
                        ChDir App.Path
                        ChDrive App.Path
                        
                        'Erase SBlockBak
                        'redim permarray(0,0)
                        'Dim UBSB1 As Long, UBSB2 As Long, UBPA1 As Long, UBPA2 As Long
                        'UBSB1 = UBound(SBlockBak, 1)
                        'UBSB2 = UBound(SBlockBak, 2)
                        ReDim SBlockBak(UBSB1, UBSB2)
                        
                        FF = FreeFile
                        If StrainSeqOnDisk = 1 Then
                            ReDim Preserve StrainSeq(NextNo + 1)
                            
                            For x = 1 To NextNo
                                StrainSeq(x) = String(Len(StrainSeq(0)), " ")
                            Next x
                            
                            
                            '@
                            Open "RDP5Strainseq" + UFTag For Binary As #FF
                            '
                            Get #FF, , StrainSeq()
                            Close #FF
                        End If
                        
                        Open "SBlockBak" + UFTag For Binary As #FF
                        Get #FF, , SBlockBak()
                        Close #FF
                        
                        'UBPA1 = UBound(PermArray, 1)
                        'UBPA2 = UBound(PermArray, 2)
                        FF = FreeFile
                        ReDim PermArray(UBPA1, UBPA2)
                        Open "PermArray" + UFTag For Binary As #FF
                        Get #FF, , PermArray()
                        Close #FF
                        KillFile "PermArray" + UFTag
                        KillFile "SBlockBak" + UFTag
                        
                        ChDir oDir
                        ChDrive oDir
                    
                    End If
                    
                    
                    'Seq1 = XX
                    'XX = TreeTrace(33)
        End If
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        
        'clear matrix lists that need to be cleared
        
        If exRelX <> RelX Or exRely <> RelY Then
            If CurMatrixFlag = 8 Then
                DoVS5 = 1
                Form1.VScroll5.Value = Form1.VScroll5.Max / 2
                Form1.HScroll4.Value = Form1.HScroll4.Max / 2
                DoVS5 = 0
                DoneMatX(8) = 0
                Call MCXoverK(0)
                x = x
            Else
                For x = 8 To 11
                    DoneMatX(x) = 0
                    If CurMatrixFlag = x Then
                        Call ClearMatrix
                        x = x
                    End If
                Next x
            End If
        Else
            If CurMatrixFlag = 8 Then 'Or (CurMatrixFlag = 255 And DoneMatX(8) = 0) Then
                'curmatrixflag=
                DoneMatX(8) = 0
                DoVS5 = 1
                Form1.VScroll5.Value = Form1.VScroll5.Max / 2
                Form1.HScroll4.Value = Form1.HScroll4.Max / 2
                DoVS5 = 0
                Call MCXoverK(0)
                x = x
            ElseIf CurMatrixFlag = 11 Then
                DoVS5 = 1
                Form1.VScroll5.Value = Form1.VScroll5.Max / 2
                Form1.HScroll4.Value = Form1.HScroll4.Max / 2
                DoVS5 = 0
                Call DrawLRDMat
                x = x
            End If
        End If
         
        If Len(StrainSeq(0)) < 30000 Then
            If XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
    
                
                If XoverList(RelX, RelY).ProgramFlag = 3 And MCTripletFlag = 1 Then
                
                Else
                    '1158
                    
                    Call GCCompare
                    '1158
                    x = x
                End If
            End If
        End If
        'No idea what this does.
        
        If XoverList(RelX, RelY).ProgramFlag <> 0 And XoverList(RelX, RelY).ProgramFlag <> AddNum Then

            If Seq1 > Seq2 Then
                reshuffle = 1
                Tmp = Seq1
                Seq1 = Seq2
                Seq2 = Tmp
            End If

            If reshuffle = 1 Then
                reshuffle = 0
                Tmp = Seq1
                Seq1 = Seq2
                Seq2 = Tmp
            End If
            
            Form2.SSPanel1(1).Visible = True
                
            If CurTree(3) = 0 Then Form2.SSPanel1(2).ZOrder
           
        ElseIf XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Then
            Form2.SSPanel1(1).Visible = True
            If CurTree(3) = 0 Then Form2.SSPanel1(2).ZOrder
            OutsideFlagX = XoverList(RelX, RelY).OutsideFlag

            If XoverList(RelX, RelY).OutsideFlag = 1 Then
                Outlyer = Seq3
                InlyerB = Seq1
                InlyerA = Seq2
            ElseIf XoverList(RelX, RelY).OutsideFlag = 2 Then
                InlyerA = Seq3
                InlyerB = Seq1
                Outlyer = Seq2
            Else
                InlyerA = Seq3
                InlyerB = Seq1
                Outlyer = Seq2
            End If

        End If

        If Seq1 = NextNo + 1 Then Seq1 = Seq2

        If Seq2 = NextNo + 1 Then Seq2 = Seq1
        PPAVal = PAVal
        PRecSeq = RecSeq
    End If
   
    If Button = 2 Then
        MenuUpFlag = 1
        
        
        Form1.RCheckMnu.Caption = "Re-Check this recombination event with all methods"
        Form1.SwapMajorMinorMnu.Enabled = True
        If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) Then
            Form1.ReassignMajorMnu.Caption = "Make the major parent (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ") the recombinant"
        End If
        If XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.ReassignMinorMnu.Caption = "Make the minor parent (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ") the recombinant"
        End If
        If XoverList(RecSeq, PAVal).MajorP <= UBound(OriginalName) And XoverList(RecSeq, PAVal).MinorP <= UBound(OriginalName) Then
            Form1.SwapMajorMinorMnu.Caption = "Swap major (" & OriginalName(XoverList(RecSeq, PAVal).MajorP) & ") and minor parent (" & OriginalName(XoverList(RecSeq, PAVal).MinorP) & ")"
        End If
        SERecSeq = RecSeq
        SEPAVal = PAVal
        
        Form1.RejectMnu.Visible = True
        Form1.RejectSMnu.Visible = True
        Form1.AcceptMnu.Visible = True
        Form1.AcceptSMnu.Visible = True
        
        If XoverList(RecSeq, PAVal).Accept = 1 Then
            Form1.AcceptMnu.Enabled = False
            Form1.AcceptSMnu.Enabled = False
        Else
            Form1.AcceptMnu.Enabled = True
            Form1.AcceptSMnu.Enabled = True
        End If
        
        If XoverList(RecSeq, PAVal).Accept = 2 Then
            Form1.RejectMnu.Enabled = False
            Form1.RejectSMnu.Enabled = False
        Else
            Form1.RejectMnu.Enabled = True
            Form1.RejectSMnu.Enabled = True
        End If
        
        
        ENxx = SuperEventList(XoverList(RecSeq, PAVal).Eventnumber)
        A = 0
        If Form1.RejectSMnu.Enabled = True Or Form1.AcceptSMnu.Enabled = True Then
            
            If ExcludedEventNum > 0 Then
                A = SumEventCount(ENxx)
            Else
                A = 0
                For Z = 0 To NextNo
                    If Daught(ENxx, Z) > 0 Then
                        A = A + 1
                        
                    End If
                Next Z
            End If
            If A = 1 Then
                Form1.RejectSMnu.Enabled = False
                Form1.AcceptSMnu.Enabled = False
                Form1.RejectSMnu.Caption = "Reject this event in all sequences where it is found"
                Form1.AcceptSMnu.Caption = "Accept this event in all sequences where it is found"
            Else
                Form1.RejectSMnu.Caption = "Reject this event in all " + Trim(Str(A)) + " sequences where it is found"
                Form1.AcceptSMnu.Caption = "Accept this event in all " + Trim(Str(A)) + " sequences where it is found"
            End If
        End If
            
        If XoverList(RecSeq, PAVal).MajorP = XoverList(RecSeq, PAVal).Daughter Or XoverList(RecSeq, PAVal).MajorP = NextNo + 1 Or ((XoverList(RecSeq, PAVal).ProgramFlag = 1 Or XoverList(RecSeq, PAVal).ProgramFlag = 1 + AddNum) And pGCTripletflag = 0) Then
            Form1.ReassignMajorMnu.Enabled = False
            Form1.SwapMajorMinorMnu.Enabled = False

            If (XoverList(RecSeq, PAVal).ProgramFlag = 1 Or XoverList(RecSeq, PAVal).ProgramFlag = 1 + AddNum) And pGCTripletflag = 0 Then
                
                If XoverList(RecSeq, PAVal).OutsideFlag = 1 Then
                    Form1.ReassignMinorMnu.Enabled = False
                    Form1.ReassignMajorMnu.Enabled = True
                    Form1.SwapMajorMinorMnu.Enabled = True
                ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 2 Or XoverList(RecSeq, PAVal).OutsideFlag = 0 Then
                    Form1.ReassignMinorMnu.Enabled = True
                    Form1.ReassignMajorMnu.Enabled = False
                    Form1.SwapMajorMinorMnu.Enabled = True
                ElseIf XoverList(RecSeq, PAVal).OutsideFlag = 3 Then
                    Form1.ReassignMinorMnu.Enabled = True

                    If XoverList(RecSeq, PAVal).ProgramFlag <> 1 Then
                        Form1.ReassignMajorMnu.Enabled = False
                    Else
                        Form1.ReassignMajorMnu.Enabled = True
                    End If

                    Form1.SwapMajorMinorMnu.Enabled = False
                End If

            End If

        Else
            Form1.ReassignMajorMnu.Enabled = True
        End If

        If XoverList(RecSeq, PAVal).MinorP = XoverList(RecSeq, PAVal).Daughter Or XoverList(RecSeq, PAVal).MinorP = NextNo + 1 Then
            Form1.ReassignMinorMnu.Enabled = False
            Form1.SwapMajorMinorMnu.Enabled = False
        Else
            Form1.ReassignMinorMnu.Enabled = True
        End If

        Form1.PopupMenu Form1.SchemEditMnu
        
    ElseIf Button = 1 Then
    
        If DebuggingFlag < 2 Then On Error Resume Next
        LowestProb = pLowestProb
        On Error GoTo 0
        ManFlag = -1
        TManFlag = -1
        TimerVal = 0
        
        Form1.SSPanel3.Enabled = False
        Form1.SSPanel4.Enabled = False
        Form1.SSPanel5.Enabled = False
        Form1.SSPanel6(0).Enabled = False
        Form1.SSPanel6(1).Enabled = False
        Form1.SSPanel6(2).Enabled = False
        
        Form1.Timer1.Enabled = True
        
        
         
        For Z = 1 To 2
            For A = 0 To UBound(DoneTree, 1)
                DoneTree(A, Z) = 0
            Next A
        Next 'Z

        'This draws all of the plts display panel stuff
        OutsideFlagX = XoverList(RelX, RelY).OutsideFlag
        
        GLVS = -1
       
        If (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum)) Or OVS = 0 Then
            Form1.SSPanel1.Caption = "Drawing identity plots"
            
            

            'XX = TreeTrace(25)
            'Call RTSpacerFind
            '1158
            oUD = UpdateIDFlag
            UpdateIDFlag = 0
            
            
            Call XOverIII(0)
            UpdateIDFlag = oUD
            '1158
            Call DoCombo(0)
            '1158
            
            
            x = x
        ElseIf XoverList(RelX, RelY).ProgramFlag = 7 Or XoverList(RelX, RelY).ProgramFlag = 7 + AddNum Then
            'Form1.SSPanel1.Caption = "Drawing Identity Plots"
            
            

            'XX = TreeTrace(25)
            'Call RTSpacerFind
            oUD = UpdateIDFlag
            UpdateIDFlag = 0
            
            
            Call LXoverB(0, 1)
            UpdateIDFlag = oUD
            Call DoCombo(0)
            x = x
        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum)) Or OVS = 6 Then
            Form1.SSPanel1.Caption = "Executing PhylPro"
            oUD = UpdateIDFlag
            UpdateIDFlag = 0
            
            Call PXoverE
            UpdateIDFlag = oUD
            Call DoCombo(0)
            x = x
        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum)) Or OVS = 1 Then
            If pGCTripletflag = 1 Then
                oUD = UpdateIDFlag
                UpdateIDFlag = 0
                
                
                Call GCCompare
                
                
                Call GCCheck(0)
                
                UpdateIDFlag = oUD
                Call DoCombo(0)
                x = x
            Else
                oUD = UpdateIDFlag
                UpdateIDFlag = 0
               
                
                Call GCDraw
                
                UpdateIDFlag = oUD
                
                Call DoCombo(1)
    
                SpacerNo = 0
                AllowExtraSeqsFlag = 0
                ReDim SpacerSeqs(NextNo)
    
                For x = 0 To NextNo
    
                    If x <> Seq1 And x <> Seq2 And MaskSeq(x) < 2 Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = x
                    End If
    
                Next 'X
            End If
        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum)) Or OVS = 2 Then
            
            
            
            
            
            
            If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then
                oUD = UpdateIDFlag
                UpdateIDFlag = 0
                
                
                Call BSXoverl(0)
                UpdateIDFlag = oUD
                x = x
            Else
                Call FindSubSeqBS
                x = x
                Dim WeightMod() As Long, Scratch() As Integer
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                oUD = UpdateIDFlag
                UpdateIDFlag = 0
                
                
                Call BSXoverM(0, 0, WeightMod())
                UpdateIDFlag = oUD
                
                
            End If

            Call MakeXOverSeq
            x = x
            'Call MakeXOverSeq
             
            Call DoCombo(0)
            x = x

        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum)) Or OVS = 3 Then
            Form1.SSPanel1.Caption = "Executing MaxChi"
            'XX = PermNextno
            If XoverList(RelX, RelY).Daughter <> XoverList(RelX, RelY).MajorP And XoverList(RelX, RelY).Daughter <> XoverList(RelX, RelY).MinorP And XoverList(RelX, RelY).MajorP <> XoverList(RelX, RelY).MinorP Then
                oUD = UpdateIDFlag
                UpdateIDFlag = 0
                Call MCXoverG(0)
                UpdateIDFlag = oUD
                Call DoCombo(0)
                Call MakeXOverSeq
               x = x
            Else
                oUD = UpdateIDFlag
                UpdateIDFlag = 0
                
                
                Call MCXoverI
                UpdateIDFlag = oUD
                Call DoCombo(1)
                x = x
                SpacerNo = 0
                AllowExtraSeqsFlag = 0
                ReDim SpacerSeqs(NextNo)

                For x = 0 To NextNo

                    If x <> Seq1 And x <> Seq2 And MaskSeq(x) < 2 Then
                        SpacerNo = SpacerNo + 1
                        SpacerSeqs(SpacerNo) = x
                        
                    End If

                Next 'X

            End If
        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum)) Or OVS = 4 Then
            Form1.SSPanel1.Caption = "Executing Chimaera"

            
                'If BSFileName = "RDP5bsfile2" Then
                    oUD = UpdateIDFlag
                    UpdateIDFlag = 0
                    
                    Call CXoverB
                    UpdateIDFlag = oUD
                    x = x
                    'Call CXoverC(0)
                'Else
                '    Call CXoverC(0)
                'End If
                
                Call DoCombo(0)
                x = x
        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum)) Or OVS = 8 Then
            Form1.SSPanel1.Caption = "3Seq"
            oUD = UpdateIDFlag
            UpdateIDFlag = 0
            
            Call TSXOverB
            UpdateIDFlag = oUD
            Call DoCombo(0)
            x = x
        ElseIf (OVS = -1 And (XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum)) Or OVS = 5 Then
            oUD = UpdateIDFlag
            UpdateIDFlag = 0
                
            Call SSXoverB(0)
            UpdateIDFlag = oUD
            Call DoCombo(0)
            x = x
            If Form1.Picture12.Visible = True Then
                Form1.Picture12.AutoRedraw = True
                Form1.Picture12.Picture = LoadPicture()
                For x = 1 To 15
                    Form1.Picture12.Line (50, 50 + 200 * (x - 1))-(200, 50 + (200 * (x - 1) + 150)), PltCol(x), BF
                Next x
                Form1.Picture12.ForeColor = RGB(150, 150, 150)
                For x = 1 To 15
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 250 + 14
                    Form1.Picture12.CurrentY = 50 + (x - 1) * 200 + 14
                    Form1.Picture12.Print "P" & Trim$(CStr(x))
                Next x
                
                
                Form1.Picture12.ForeColor = 0
                
                For x = 1 To 15
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 250
                    Form1.Picture12.CurrentY = 50 + (x - 1) * 200
                    Form1.Picture12.Print "P" & Trim$(CStr(x))
                Next x
                
                For x = 1 To 9
                    Form1.Picture12.Line (750, 50 + 200 * (x - 1))-(900, 50 + (200 * (x - 1) + 150)), PltCol2(x), BF
                Next x
                Form1.Picture12.ForeColor = RGB(150, 150, 150)
                For x = 1 To 9
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 950 + 14
                    Form1.Picture12.CurrentY = 50 + (x - 1) * 200 + 14
                    Form1.Picture12.Print "S" & Trim$(CStr(x))
                Next x
                
                
                Form1.Picture12.ForeColor = 0
                
                For x = 1 To 9
                    'Picture12.Line (50, 50 + 200 * (X - 1))-(200, 50 + (200 * (X - 1) + 150)), PltCol(X), BF
                    Form1.Picture12.CurrentX = 950
                    Form1.Picture12.CurrentY = 50 + (x - 1) * 200
                    Form1.Picture12.Print "S" & Trim$(CStr(x))
                Next x
                
                Form1.Picture12.Refresh
            End If
        End If
        
        OVS = -1
        If RelX > 0 Or RelY > 0 Then
            ReDim RememberBPs(2, 100)
            Dim CEv As Long
            SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
            NumberBPs = 1
            RememberBPs(0, 0) = XoverList(RelX, RelY).Beginning
            RememberBPs(1, 0) = XoverList(RelX, RelY).ProgramFlag
            RememberBPs(0, 1) = XoverList(RelX, RelY).Ending
            RememberBPs(1, 1) = XoverList(RelX, RelY).ProgramFlag
            '@
            For x = 0 To NextNo
                
                For Y = 1 To CurrentXOver(x)
                    If XoverList(x, Y).Eventnumber <= Eventnumber Then
                        If SuperEventList(XoverList(x, Y).Eventnumber) = SEN Then
                            NumberBPs = NumberBPs + 1
                            If NumberBPs > UBound(RememberBPs, 2) Then ReDim Preserve RememberBPs(2, NumberBPs + 100)
                            RememberBPs(0, NumberBPs) = XoverList(x, Y).Beginning
                            RememberBPs(1, NumberBPs) = XoverList(x, Y).ProgramFlag
                            NumberBPs = NumberBPs + 1
                            If NumberBPs > UBound(RememberBPs, 2) Then ReDim Preserve RememberBPs(2, NumberBPs + 100)
                            RememberBPs(0, NumberBPs) = XoverList(x, Y).Ending
                            RememberBPs(1, NumberBPs) = XoverList(x, Y).ProgramFlag
                        End If
                    End If
                Next Y
            Next x
        End If
        
        
        
        'XX = MissingData(BPos, Seq2)
        'Seq1 = TreeTraceSeqs(1, Seq1)
        'Seq2 = TreeTraceSeqs(1, Seq2)
        'Seq3 = TreeTraceSeqs(1, Seq3)
        
       ' KPFlag = 0
       ' ST = Abs(GetTickCount)
       ' Do While ET - ST < 2000
       '     DoEvents
       '     ET = Abs(GetTickCount)
       '
       ' Loop
        If DebuggingFlag < 2 Then On Error Resume Next
        UB = -1
        UB = UBound(YannWarn, 1)
        
        
        On Error GoTo 0
        If UB < SEventNumber Then
            ReDim Preserve YannWarn(SEventNumber)
        
        End If
        SS = Abs(GetTickCount)
        If x = x Then
            If Form2.Visible = False Then
                Form2.WindowState = 1
                Form2.Visible = True
                
            End If
            SEN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
            Form2.Caption = "Trees: Recombination event number " + Trim(Str(SEN))
            If YannWarn(SEN) = 1 Then
                Form2.Label5(0).Visible = True
                Form2.Label5(1).Visible = True
                Form2.Label5(2).Visible = True
                Form2.Label5(3).Visible = True
            Else
                Form2.Label5(0).Visible = False
                Form2.Label5(1).Visible = False
                Form2.Label5(2).Visible = False
                Form2.Label5(3).Visible = False
            End If
            If SEN <= UBound(TreeTestStats, 2) Then
                If TreeTestStats(0, SEN) > 0.00001 Then
                    If TreeTestStats(2, SEN) = 0.00001 Then
                        Crap = "<0.0001"
                    Else
                        Crap = TreeTestStats(2, SEN)
                        If Left(Crap, 1) = "." Then Crap = "0" + Crap
                    End If
                    Form2.Label3(0) = "Shimodaira-Hasegawa p-value: " + Crap
                    If TreeTestStats(0, SEN) = 0.00001 Then
                        Crap = "<0.0001"
                    Else
                        Crap = TreeTestStats(0, SEN)
                        If Left(Crap, 1) = "." Then Crap = "0" + Crap
                    End If
                    Form2.Label3(1) = "Shimodaira-Hasegawa p-value: " + Crap
                    If TreeTestStats(3, SEN) = 0.00001 Then
                        Crap = "<0.0001"
                    Else
                        Crap = TreeTestStats(3, SEN)
                        If Left(Crap, 1) = "." Then Crap = "0" + Crap
                    End If
                    Form2.Label4(0) = "Approximately unbiased p-value: " + Crap
                    If TreeTestStats(1, SEN) = 0.00001 Then
                        Crap = "<0.0001"
                    Else
                        Crap = TreeTestStats(1, SEN)
                        If Left(Crap, 1) = "." Then Crap = "0" + Crap
                    End If
                    Form2.Label4(1) = "Approximately unbiased p-value: " + Crap
                Else
                    Form2.Label3(0) = "Shimodaira-Hasegawa p-value: Undetermined"
                    Form2.Label3(1) = "Shimodaira-Hasegawa p-value: Undetermined"
                    Form2.Label4(0) = "Approximately unbiased p-value: Undetermined"
                    Form2.Label4(1) = "Approximately unbiased p-value: Undetermined"
                End If
            Else
                Form2.Label3(0) = "Shimodaira-Hasegawa p-value: Undetermined"
                Form2.Label3(1) = "Shimodaira-Hasegawa p-value: Undetermined"
                Form2.Label4(0) = "Approximately unbiased p-value: Undetermined"
                Form2.Label4(1) = "Approximately unbiased p-value: Undetermined"
            
            End If
            
            
            
            Form1.SSPanel1.Caption = "Making trees"
            If UpdateProgressBar = 0 Then
                Form1.ProgressBar1.Value = 65
                
            End If
            Call UpdateF2Prog
                    

            'Do the trees
            PartFlag = 2
'            XX = Nextno
            'Call UnModNextno
            '1158
            
            Call ModNextno
            '1158
            x = x
            'Dim SeqNumBak() As Integer
            'ReDim SeqNumBak(Len(StrainSeq(0)), Nextno)
            

            If FastNJFlag = 0 Then
'                SS = Abs(GetTickCount)
                If TreeTypeFlag <> 3 Then
                    CTF = 0
                    TreeTypeFlag = 2
                End If
                If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
                    Form1.Label14 = "UPGMA of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
                Else
                    If Decompress(XoverList(RelX, RelY).Beginning) <> Decompress(Len(StrainSeq(0))) Then
                        Form1.Label14 = "UPGMA of regions derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                    Else
                        Form1.Label14 = "UPGMA of region derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + ")"
                    End If
                End If
'                SS = Abs(GetTickCount)
                
                
                
                '1041,1045
                Call RecUPGMAII
                '1050,1046
                
                
'                EE = Abs(GetTickCount)
'                TT = EE - SS '2.657 for 1300'2.625'1.844 with addseqtoupgma
'
'
                TreeImage(2) = 1
                    
                DoneTree(0, 2) = 1
                
                
'                XX = SuperEventList(XOverlist(RelX, RelY).Eventnumber)
                
                Dim CurrentState As Integer
        
                CurrentState = TreeTypeFlag
                
                'Sort out the multiple tree display if it is visible
        
                If Form2.Visible = True Then
        
                    For Z = 1 To 3
                        Form2.Picture2(Z).Visible = True
                    Next 'Z
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 70
                    End If
                    Call UpdateF2Prog
'                    SS = Abs(GetTickCount)
                    '1049,1046
                    
                    Call MultTreeWin
                    'XX = Form2.Picture2(1).FontSize
                    '992,988
                    Form1.SSPanel1.Caption = "Drawing trees"
                    Form1.Refresh
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    
'                    EE = Abs(GetTickCount)
'                    TT = EE - SS
                   
                    TreeTypeFlag = CurrentState
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 90
                        
                    End If
                    Call UpdateF2Prog
                Else
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 90
                    End If
                    Call UpdateF2Prog
                End If
            Else
'                SS = Abs(GetTickCount)
                If TreeTypeFlag <> 3 Then
                    CTF = 0
                    TreeTypeFlag = 2
                End If
                F2TreeIndex = 2
                'Form1.Label14 = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XOverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XOverList(RelX, RelY).Ending))) + ")" '  Recombinant Region"
                
                If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then '7792-8216,8217-7791
                    Form1.Label14 = "FastNJ tree of region derived from minor parent (" + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + ")"
                Else
                    Form1.Label14 = "FastNJ tree of region derived from minor parent (1 - " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Ending))) + " and " + Trim$(CStr(Decompress(XoverList(RelX, RelY).Beginning))) + " - " + Trim$(CStr(Decompress(Len(StrainSeq(0))))) + ")"
                End If
               
                
                CurTree(2) = 0
                CTF = 0
                NHFlag = 2
                TreeImage(2) = 1
                    
                DoneTree(0, 2) = 1
                ReDim TempSeq(NextNo + 2)
                If NextNo = -1 Then
                    SchemDownFlag = 0
                    Screen.MousePointer = oPointer
                    Exit Sub
                End If
                ReDim tStrainseq(NextNo)
                For x = 0 To NextNo
                    tStrainseq(x) = String(Len(StrainSeq(0)), " ")
                Next x
                For x = 0 To NextNo '24
                    For Y = 1 To Len(StrainSeq(0))
                        Mid(tStrainseq(x), Y, 1) = Chr(TreeSeqNum(Y, x) - 1)
                    Next Y
                Next x
                BTree = XoverList(RelX, RelY).Beginning
                ETree = XoverList(RelX, RelY).Ending '7792-8216
                If (BTree > 0 Or ETree > 0) And BTree <> ETree Then
                    For x = 0 To NextNo
                        If BTree < ETree Then
                            TempSeq(x) = Mid$(tStrainseq(x), BTree, ETree - BTree)
                        Else
                            TempSeq(x) = Mid$(tStrainseq(x), BTree, Len(StrainSeq(0)) - BTree)
                            TempSeq(x) = TempSeq(x) + Mid$(tStrainseq(x), 1, ETree)
                        End If
                    Next x
               
                
                If Form2.Visible = True Then BusyWithTreeFlag = 1
                Call NJTree2(0)
                
                
                ExtraDX = DoTreeColour(Form2.Picture2(2), 0, 2)
                Dim AdjYD As Integer
                AdjYD = 14
                For TNum = 0 To 2
                    For TType = 0 To 5
                        DoTreeLegend TNum, TType, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
                    Next TType
                Next TNum
                DoTreeLegend 3, 0, TreeBlocksL(), TBLLen, Form1.Picture16, ExtraDX, AdjYD
        
                CurrentState = TreeTypeFlag
                
                'Sort out the multiple tree display if it is visible
        
                If Form2.Visible = True Then
        
                    For Z = 1 To 3
                        Form2.Picture2(Z).Visible = True
                    Next 'Z
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 80
                    End If
                    Call UpdateF2Prog
                    'SS = Abs(GetTickCount)
                    Call MultTreeWin
'                    EE = Abs(GetTickCount)
                    'TT = EE - SS
                    TreeTypeFlag = CurrentState
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 90
                        
                    End If
                    Call UpdateF2Prog
                Else
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 90
                        
                    End If
                    Call UpdateF2Prog
                End If
                Else
                    If UpdateProgressBar = 0 Then
                        Form1.ProgressBar1.Value = 90
                        
                    End If
                    Call UpdateF2Prog
                End If
            End If
            
'            EEE = Abs(GetTickCount)
'            ttt = EEE - SSS
'            X = X '3.156, 3.3
            
        Else
            KPFlag = 0
        End If
       
        EE = Abs(GetTickCount)
        TT = EE - SS '2203 with old fasttree
                    '4420 new one with no opt
                    '4485 with openmp
                    '2171 with speed optimization 02 switch
                    '2188 02+omp+sse
                    '20578 2K old version
                    '19266 2k new version
        If LongWindedFlag = 1 Then
            '1109
            Call UnModSeqNum(0)
            '1109
            XX = UBound(OriginalName)
            Call UnModNextno
            '1109
            x = x
        End If
        
        
        'Retrieve variable states saved before analysis began
        MCTripletFlag = xMCTripletFlag
        MCProportionFlag = xMCProportionFlag
        
        MCPermMaxP = xMCPermMaxP
        MCStart = xMCStart
        MCEnd = xMCEnd
        MCMaxP = xMCMaxP
        MCSteplen = xMCSteplen
        MCWinSize = xMCWinSize
        MCWinFract = xMCWinFract
        MCStripGapsFlag = xMCStripGapsFlag
        MCFlag = xMCFlag
        XOverWindowX = xXOverWindowX
        CircularFlag = xCircularFlag
        SpacerFlag = xSpacerFlag
        LowestProb = xLowestProb
        If LowestProb > 10 Then
            LowestProb = pLowestProb
        End If
        SpacerNo = SpacerNo
        BSTypeFlag = xBSTypeFlag
        BSStepSize = xBSStepSize
        BSStepWin = xBSStepWin
        BSBootReps = xBSBootReps
        BSCutOff = xBSCutoff
        BSPValFlag = xBSPValFlag
        SSGapFlag = xSSGapFlag
        SSVarPFlag = xSSVarPFlag
        SSOutlyerFlag = xSSOutlyerFlag
        SSRndSeed = xSSRndSeed
        SSWinLen = xSSWinLen
        SSStep = xSSStep
        SSNumPerms = xSSNumPerms
        GCMissmatchPen = xGCMissmatchPen
        GCIndelFlag = xGCIndelFlag
        GCMinFragLen = xGCMinFragLen
        GCMinPolyInFrag = xGCMinPolyInFrag
        GCMinPairScore = xGCMinPairScore
        GCMaxOverlapFrags = xGCMaxOverlapFrags
        GCtripletflag = xGCTripletFlag
        PPStripGaps = xPPStripGaps
        
        
         'clear old flashing lines abd update schematic seq display
         '1109
        ReDim Preserve SchemBlocks(3, 4, SBlocksLen)
        '1109
        
        Call SchemDrawing(SchemBlocks(), SBlocksLen, SchemString(), SStringLen, SchemFlag, OriginalName(), -Form1.VScroll2.Value, Form1.Picture6)
        '1109
        
       
       If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        
        'If ORF info has been loaded, shade the orfmap appropriately

        If ORFFlag = 1 Then
            'Form1.Picture20.Picture = Form1.Picture19.Image
            Call DrawORFsP20
            Form1.Picture20.Visible = True
            Form1.Picture20.BorderStyle = 0

            Dim P20XFactor As Double

            P20XFactor = Form1.Picture20.ScaleWidth / Decompress(Len(StrainSeq(0)))
            LineStart = CInt(P20XFactor * RecStart) - 1
            LineEnd = CInt(P20XFactor * RecEnd) + 1

            If LineEnd > LineStart Then
                Form1.Picture20.DrawMode = 5
                Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF 'RGB(255 - BkR, 255 - BkG, 255 - BkB), BF
                Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
            Else
                Form1.Picture20.DrawMode = 5
                Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF
                Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(0, 160, 160), BF
                Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(BkR, BkG, BkB), BF
                Form1.Picture20.DrawMode = 13
            End If

        End If

        Form1.Picture20.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        If ((XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Or XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then SpacerNo = 0
        AllowExtraSeqsFlag = 0
        If (XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And Seq1 = Seq2 Then
            ShowSeqFlag = 0
            Form1.HScroll1.SmallChange = 1
            Form1.Picture3.Enabled = True
            Form1.Label21 = "Show All Sequences"
            Form1.Picture3.Picture = LoadPicture()
            Form1.Picture3.CurrentX = 0
            Form1.Picture3.CurrentY = 0
            Form1.Command6(0).Enabled = False
            
        End If
        
        If ShowSeqFlag = 1 Or ShowSeqFlag = 2 Then
            Form1.Picture3.Picture = LoadPicture()
            Form1.Picture3.AutoRedraw = True
            Call PrintNames3(Form1.Picture3, XoverList(RelX, RelY).ProgramFlag, NumberOfSeqs, RevSeq(), SSOLSeqName)
            LastY3 = -1
            'Form1.Picture3.Enabled = False
            If Form1.VScroll3.Value <> 0 Then
                Form1.VScroll3.Value = 0
            Else
                If DebuggingFlag < 3 Then On Error Resume Next
                Form1.VScroll3.Value = 1
                Form1.VScroll3.Value = 0
                On Error GoTo 0
            End If
        End If
        
        'Disable the"STOP" button
        Form1.Command25.Enabled = False
        Form1.Command25.ToolTipText = ""
        If UpdateProgressBar = 0 Then
            Form1.ProgressBar1.Value = 100
            
        End If
        Call UpdateF2Prog
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        
        'If DebuggingFlag < 2 Then On Error Resume Next
        Dim otTYF As Double, TYFM As Integer
        '1109
        'Call ModOffsets(8.25, Form2.Picture2(1), otTYF, TYFM)
        'If PersistantP2tTYF = 0 Then
            Call ModOffsets(8.25, Form2.Picture2(1), otTYF, TYFM)
'            PersistantP2tTYF = otTYF
'            PersistantP2TYFM = TYFM
'        Else
'            otTYF = PersistantP2tTYF
'            TYFM = PersistantP2TYFM
'        End If

 

        x = x
        '1109
'        If X = 123456 Then
'        For Index = 0 To 3
'
'            With Form2.VScroll1(Index)
'                VSMax = .Max
'                If VSMax <= 0 Then .Value = 0
'
'                OVx = (.Value / .Max)
'                If OVx < 0 Then OVx = 0
'
'                OV = .Value
'                OM = VSMax
'                If TDLen(Index, CurTree(Index), 1) > 0 And TDLen(Index, CurTree(Index), 1) <= UBound(TreeDraw, 5) Then
'                    VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(Index, CurTree(Index), 1)) + 1) * otTYF) + 200
'                Else
'                    VSMax = -Form2.Picture2(Index).ScaleHeight + ((TreeDraw(Index, CurTree(Index), 1, 1, TDLen(0, 1, 1)) + 1) * otTYF) + 200
'                End If
'                If OM = 0 Then OM = 1
'                If VSMax > 32000 Then
'                    F2VSScaleFactor(Index) = VSMax / 32000
'                    VSMax = 32000
'                Else
'                    F2VSScaleFactor(Index) = 1
'                End If
'
'
'                If VSMax > 0 Then
'                    .Max = VSMax
'                    If OVx * VSMax < VSMax Then
'                        .Value = (OVx * (VSMax)) '0.168, 12967 ' - 200)) '(.Value / (OM / VSMax))
'
'                    ElseIf VSMax > 0 Then
'                        .Value = VSMax
'                    End If
'
'                    If .Value > VSMax Then .Value = VSMax
'
'                    If VSMax <= 0 Then
'                        .Enabled = False
'                    Else
'                        .LargeChange = Form2.Picture2(Index).ScaleHeight
'                        .Enabled = True
'                    End If
'                End If
'
'            End With
'            If Index = 1 Then
'                Call ModNextno
'            ElseIf Index = 3 And CurTree(3) = 0 Then
'                Call UnModNextno
'            End If
'            If OV = Form2.VScroll1(Index).Value Then
'                Call treedrawing(0,0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(Index).Value, Index, CurTree(Index), treedrawb(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(Index))
'
'            End If
'        Next Index
'        End If
        'On Error GoTo 0
        
        
        
        
        
        'centre the trees on the recombinant
        Dim Offset As Long, OVY1 As Single, NV1 As Single, OVY2 As Single, NV2 As Single, Targetpos1 As Single, Targetpos2 As Single, tTYF As Double
        'Call ModOffsets(8.25, Form2.Picture2(2), tTYF, TYFM)
        tTYF = otTYF
        'Dim otTYF As Double, TYFM As Integer
        'Call ModOffsets(8.25, Form2.Picture2(1), otTYF, TYFM)
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Dim ScrollInc As Single
        If Form2.Visible = True And Form2.WindowState <> 1 Then
            Form2.WindowState = 0
            If Form2.WindowState = 0 Then
                Form2.ZOrder
            End If
        
            ScrollInc = 5 / (NextNo / 1600)
            If ScrollInc > 5 Then ScrollInc = 5
'            XX = Form2.VScroll1(1)
'            YY = Form2.VScroll1(2)
            DontUpdateVS1ValFlag = 1
            '1109
            
            
            
            Call ResizeForm2
            
            
            
            '1109
            DontUpdateVS1ValFlag = 0
'            XX = Form2.VScroll1(1)
'            YY = Form2.VScroll1(2)
            'For Index = 1 To 2
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                
                
            If Form2.VScroll1(1).Enabled = True And Form2.VScroll1(2).Enabled = True Then
                    Form2.ZOrder
                  Offset = (Form2.Picture2(1).ScaleHeight / 2) - 7
                  'Targetpos = MiddlePos(CurTree(Index), Index) - Offset
                  OVY1 = 0
                  NV1 = -1
                  OVY2 = 0
                  NV2 = -1
                  Index = 1
                  If (MiddlePos(CurTree(Index), Index) * tTYF - Offset) > Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                      Targetpos1 = (Form2.VScroll1(Index).Max * F2VSScaleFactor(Index))
                  ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset < 0 Then
                      Targetpos1 = 0
                  ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset <= Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                      Targetpos1 = MiddlePos(CurTree(Index), Index) * tTYF - Offset
                  End If
                  Index = 2
                  If (MiddlePos(CurTree(Index), Index) * tTYF - Offset) > Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                      Targetpos2 = (Form2.VScroll1(Index).Max * F2VSScaleFactor(Index))
                  ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset < 0 Then
                      Targetpos2 = 0
                  ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset <= Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                      Targetpos2 = MiddlePos(CurTree(Index), Index) * tTYF - Offset
                  End If
                    Dim AddV As Single
                    
                    'Form2.Enabled = True
                    
                    If Form2.VScroll1(1).Value <> CLng(Targetpos1 / F2VSScaleFactor(Index)) Or Form2.VScroll1(2).Value <> CLng(Targetpos2 / F2VSScaleFactor(Index)) Then
                          If ButtonRepress = BRP Then
                            
                              NV1 = Form2.VScroll1(1).Value * F2VSScaleFactor(Index)
                              NV2 = Form2.VScroll1(2).Value * F2VSScaleFactor(Index)
                              OVY1 = -1
                              OVY2 = -1
                              Do While (OVY1 <> NV1 Or OVY2 <> NV2)
                              'XX = Form2.VScroll1(1)
                              'YY = Form2.VScroll1(2)
                              
                              'XX = Form2.Picture2(Index).ScaleHeight
                                  If Form2.VScroll1(1).Value <> Targetpos1 Then
                                        
                                        OVY1 = NV1
                                        If Abs(Targetpos1 - OVY1) > 3 Then
                                            AddV = ((Targetpos1 - OVY1) / ScrollInc)
                                        Else
                                            AddV = ((Targetpos1 - OVY1))
                                        End If
                                        NV1 = OVY1 + AddV
                                        If NV1 < 0 Then NV1 = 0
                                        If NV1 > Form2.VScroll1(1).Max * F2VSScaleFactor(1) Then NV1 = Form2.VScroll1(1).Max * F2VSScaleFactor(1)
                                        Form2.VScroll1(1).Value = NV1 / F2VSScaleFactor(1)
                                        Form2.Picture2(1).Refresh
                                    Else
                                        OVY1 = NV1
                                    End If
                                    If Form2.VScroll1(2).Value <> Targetpos2 Then
                                        OVY2 = NV2
                                        If Abs(Targetpos2 - OVY2) > 3 Then
                                            AddV = ((Targetpos2 - OVY2) / ScrollInc)
                                        Else
                                            AddV = ((Targetpos2 - OVY2))
                                        End If
                                        
                                        NV2 = OVY2 + AddV
                                        If NV2 < 0 Then NV2 = 0
                                        If NV2 > Form2.VScroll1(2).Max * F2VSScaleFactor(2) Then NV1 = Form2.VScroll1(2).Max * F2VSScaleFactor(2)
                                        If NV2 / F2VSScaleFactor(2) <= Form2.VScroll1(2).Max Then
                                            Form2.VScroll1(2).Value = NV2 / F2VSScaleFactor(2)
                                        End If
                                        Form2.Picture2(2).Refresh
                                    Else
                                        OVY2 = NV2
                                    End If
                                    If OVY1 = NV1 And OVY2 = NV2 Then
                                        Exit Do
                                    End If
                                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                    'DoEvents
                                    
                              Loop
                              
                              If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                              'tp1 = 31170
                              'TP2 = 38497
                              'sf1 = 1.203
                              XX = Form2.VScroll1(1).Value '25910
                              Yy = Form2.VScroll1(2).Value '32000
                              
                              AA = Form2.VScroll1(1).Max
                              BB = Form2.VScroll1(2).Max
                              
                              
                              x = x
'                              Form2.VScroll1(1).Value = (Targetpos1 / F2VSScaleFactor(Index))
'                              Form2.VScroll1(2).Value = Targetpos2 / F2VSScaleFactor(Index)
                          Else
                              ModNextno
                                For IndexX = 1 To 2
                                    Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(IndexX).Value, IndexX, CurTree(IndexX), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(IndexX))
                                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                                Next IndexX
                              Form2.VScroll1(1).Value = Targetpos1 / F2VSScaleFactor(Index)
                              Form2.VScroll1(2).Value = Targetpos2 / F2VSScaleFactor(Index)
                          End If
                    End If
                Else
                    
                    
                    
                    ModNextno
                    For IndexX = 1 To 2
                        Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(IndexX).Value, IndexX, CurTree(IndexX), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(IndexX))
                        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    Next IndexX
                    Form2.VScroll1(1).Value = Targetpos1 / F2VSScaleFactor(Index)
                    Form2.VScroll1(2).Value = Targetpos2 / F2VSScaleFactor(Index)
                    UnModNextno
                End If
            'Next Index
        Else
            Offset = (Form2.Picture2(1).ScaleHeight / 2) - 7
            
            For x = 1 To 2
                VSMax = -Form2.Picture2(x).ScaleHeight + ((TreeDraw(x, CurTree(x), 1, 1, TDLen(x, CurTree(x), 1)) + 1) * tTYF) + 200
                If VSMax > 32000 Then
                    F2VSScaleFactor(x) = VSMax / 32000
                    'F2VSScaleFactor(2) = F2VSScaleFactor(1)
                    VSMax = 32000
                Else
                    F2VSScaleFactor(x) = 1
                    
                End If
                Form2.VScroll1(x).Max = VSMax
                'Form2.VScroll1(2).MaX = VSMax
            Next x
            Index = 1
            If (MiddlePos(CurTree(Index), Index) * tTYF - Offset) > Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                Targetpos1 = (Form2.VScroll1(Index).Max * F2VSScaleFactor(Index))
            ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset < 0 Then
                Targetpos1 = 0
            ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset <= Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                Targetpos1 = MiddlePos(CurTree(Index), Index) * tTYF - Offset
            End If
            Index = 2
            If (MiddlePos(CurTree(Index), Index) * tTYF - Offset) > Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                Targetpos2 = (Form2.VScroll1(Index).Max * F2VSScaleFactor(Index))
            ElseIf MiddlePos(CurTree(Index), Index) * tTYF - Offset < 0 Then
                Targetpos2 = 0
            ElseIf (MiddlePos(CurTree(Index), Index) * tTYF - Offset) <= Form2.VScroll1(Index).Max * F2VSScaleFactor(Index) Then
                Targetpos2 = MiddlePos(CurTree(Index), Index) * tTYF - Offset '40239,1,403
            End If
            
            
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            ModNextno
            
            For IndexX = 1 To 2
                Call TreeDrawing(0, 0, TreeBlocksL(), TBLLen, 1, PermOriginalName(), -Form2.VScroll1(IndexX).Value, IndexX, CurTree(IndexX), TreeDrawB(), TDLen(), TreeBlocks(), TBLen(), Form2.Picture2(IndexX))
                
            Next IndexX
            IndexX = 1
            If CLng(Targetpos1 / F2VSScaleFactor(IndexX)) > 0 And CLng(Targetpos1 / F2VSScaleFactor(IndexX)) <= Form2.VScroll1(IndexX).Max Then
                Form2.VScroll1(IndexX).Value = CLng(Targetpos1 / F2VSScaleFactor(IndexX)) '22562
            ElseIf CLng(Targetpos1 / F2VSScaleFactor(IndexX)) < 0 Then
                Form2.VScroll1(IndexX).Value = 0
            ElseIf CLng(Targetpos1 / F2VSScaleFactor(IndexX)) > Form2.VScroll1(IndexX).Max Then
                Form2.VScroll1(IndexX).Value = Form2.VScroll1(IndexX).Max
            End If
            IndexX = 2
            If CLng(Targetpos2 / F2VSScaleFactor(IndexX)) > 0 And CLng(Targetpos2 / F2VSScaleFactor(IndexX)) <= Form2.VScroll1(IndexX).Max Then
                Form2.VScroll1(IndexX).Value = CLng(Targetpos2 / F2VSScaleFactor(IndexX)) '22562
            ElseIf CLng(Targetpos2 / F2VSScaleFactor(IndexX)) < 0 Then
                Form2.VScroll1(IndexX).Value = 0
            ElseIf CLng(Targetpos2 / F2VSScaleFactor(IndexX)) > Form2.VScroll1(IndexX).Max Then
                Form2.VScroll1(IndexX).Value = Form2.VScroll1(IndexX).Max
            End If
            
            UnModNextno
        End If
        
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        Form1.Refresh
        Form1.SSPanel3.Enabled = True
        Form1.SSPanel4.Enabled = True
        Form1.SSPanel5.Enabled = True
        Form1.SSPanel6(0).Enabled = True
        Form1.SSPanel6(1).Enabled = True
        Form1.SSPanel6(2).Enabled = True
        Form1.Picture2.Enabled = True
    End If
    
    
    
    
    If RelY <= UBound(XoverList, 2) Then
        If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or CurrentCheck = 5 Then
        
        Else
            Form1.Picture12.Visible = False
        End If
    Else: RelY = 0
    End If
    
    If RelX > 0 Or RelY > 0 Then
        If Form1.VScroll1.Enabled = False Then
            Form1.VScroll1.Enabled = True
            Form1.VScroll1.Max = 1
            CB = 1
        End If
        
        If Form1.VScroll1.Max < 1 Then Form1.VScroll1.Max = 1
        DontResetFocus = 1
         
        If Form1.VScroll1.Value <> 0 Then
            Form1.VScroll1.Value = 0
        Else
             If Form1.VScroll1.Max > 0 Then
                Form1.VScroll1.Value = 1
            
            
            End If
        End If
       DontResetFocus = 0
          
        If CB = 1 Then
            'Form1.VScroll1.Max = 0
            Form1.VScroll1.Enabled = False
            
        End If
    End If
    
     If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    If ShowSeqFlag = 0 Then
        '1109
        Call PrintNames
        '1109
    End If
    
    
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    Form1.Picture6.Refresh
    Form1.Command13(2).Enabled = True
    Form1.SSPanel3.Enabled = True
    Form1.Picture1.Enabled = True
    
    If UpdateProgressBar = 0 Then
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
    End If
    If Form2.Visible = True Then
        Form2.Enabled = True
        Form2.SSPanel1(0).Enabled = True
        Form2.SSPanel1(1).Enabled = True
        Form2.SSPanel1(2).Enabled = True
        Form2.SSPanel1(3).Enabled = True
        If Form2.WindowState <> 1 Or JustOpened = 1 Then
            Form2.WindowState = 0
        End If
        Call ResizeForm2
        If Button = 1 Or Pic2MD = 2 Then
            Form2.ZOrder
            Form2.Refresh
        End If
        JustOpened = 0
    End If
    
    
    
Cleanup:
    'DoEvents
    
    
    DontDoTimer4Flag = 0
    DontDoTimer1Flag = 0
    Screen.MousePointer = oPointer
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'
'    eexx = Abs(GetTickCount)
'    TT = eexx - sttime '
    '0.484 for poty
    '6.910 for 1200'31.496 for 1200 with bp shift,
    '26.645 for 3800
    '25.459 (with makevaltots)

    Form1.SSPanel2.Enabled = True
    Form1.SSPanel8.Enabled = True
    SchemDownFlag = 0
End Sub
Public Function WatThet()
Dim FP As Double, S As Long

For x = 0 To NextNo - 1
   FP = FP + 1 / (x + 1)
Next x
FP = FP ^ -1



S = 0
For x = 1 To Len(StrainSeq(0))
    If Identical(x) = 0 Then S = S + 1
Next x

FP = FP * Log(Len(StrainSeq(0)) / (Len(StrainSeq(0)) - S))

WatThet = FP

End Function
Public Sub CentreMatrix()

If CurMatrixFlag = 2 Then
        UB = (UBound(MatrixM, 1) - 1)
    ElseIf CurMatrixFlag = 1 Then
            UB = (UBound(MatrixR, 1) - 1)
    ElseIf CurMatrixFlag = 0 Then
            UB = (UBound(MatrixC, 1) - 1)
    ElseIf CurMatrixFlag = 14 Then
            UB = (UBound(MatrixTB, 1) - 1)
    ElseIf CurMatrixFlag = 3 Then
            UB = (UBound(MatrixRR, 1) - 1)
    ElseIf CurMatrixFlag = 4 Then
            UB = (UBound(MatrixBP, 1) - 1)
    ElseIf CurMatrixFlag = 5 Then
        UB = UBound(MatrixLD, 1) - 1
    ElseIf CurMatrixFlag = 6 Then
        UB = UBound(MatrixRMin, 1) - 1
    ElseIf CurMatrixFlag = 7 Then
        UB = UBound(MatrixRMinD, 1) - 1
    ElseIf CurMatrixFlag = 8 Then
        UB = UBound(MatrixMC, 1) - 1
    ElseIf CurMatrixFlag = 11 Then
        UB = UBound(MatrixL, 1) - 1
    ElseIf CurMatrixFlag = 12 Then
    
        UB = UBound(MatrixSH, 1) - 1
    ElseIf CurMatrixFlag = 13 Then
    
        UB = UBound(MatrixRF, 1) - 1
    End If
    DoVS5 = 1
    If (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 32000 And (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight > 0 Then
        Form1.VScroll5.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        Form1.HScroll4.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        
       ' Form1.VScroll5.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
       ' Form1.HScroll4.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
    ElseIf (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 1 Then
        Form1.HScroll4.Max = 0: Form1.HScroll4.Enabled = False
        Form1.VScroll5.Max = 0: Form1.VScroll5.Enabled = False
    Else
        Form1.VScroll5.Max = 32000
        Form1.HScroll4.Max = 32000
        MatZoom(CurMatrixFlag) = (Form1.HScroll4.Max + Form1.Picture26.ScaleHeight) / (Form1.Picture26.ScaleHeight * 2)
    End If
    If Form1.VScroll5.Max < 1 Then
        Form1.VScroll5.Max = 0
    End If
    If Form1.HScroll4.Max < 1 Then
        Form1.HScroll4.Max = 0
    End If
    Form1.HScroll4.LargeChange = Form1.HScroll4.Max / MatZoom(CurMatrixFlag)
    Form1.VScroll5.LargeChange = Form1.VScroll5.Max / MatZoom(CurMatrixFlag)
    Form1.HScroll4.SmallChange = CLng(MatZoom(CurMatrixFlag) * 4)
    Form1.VScroll5.SmallChange = CLng(MatZoom(CurMatrixFlag) * 4)
    
    
     ' / Sqr(MatZoom(CurMatrixFlag))
    Form1.HScroll4.Value = Form1.HScroll4.Max / 2
    DoVS5 = 0
    'If VScroll5.Value + (P26MDY - Y) * Addj >= 0 And VScroll5.Value + (P26MDY - Y) * Addj <= VScroll5.Max Then
    Form1.VScroll5.Value = Form1.VScroll5.Max / 2
    
End Sub

    'End If

Public Sub MCXoverF(FindallFlag As Byte, BEP, ENP)

Dim HWindowWidth As Long, UB As Long, Dummy As Long, Redox As Long, CurWinPos As Long, NumInList As Long, EWarn As Long, BWarn As Long, SIP As Long
Dim ENX As Long, BEX As Long, ZZ As Long, oActive As Long, oMajP As Long, oMinP As Long, CF As Long, YScaleFactor As Single
Dim Y As Long
If AbortFlag = 1 Then Exit Sub

If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If

Dim FullMC As Double, xMPV As Variant, GoOn As Byte, XB As Long, XE As Long, XBP As Double, XEP As Double, DoneRedo As Byte, LOT(1) As Double, BPP As Double, EPP As Double, BPV As Double, EPV As Double, PPVal As Double, BE As Long, EN As Long, DoneThis As Byte
Dim maxz As Long, MaxX As Long, WinWin As Long
Dim Failcount As Long
Dim MPV As Double, HMChi As Double
Dim HiLeft As Double, HiRight As Double
Dim pMaxX As Long, TopR As Long, TopL As Long
Dim mPrbL As Double, ZP As Double

Dim WasteOfTime As Long, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, A As Long, b As Long, C As Long, D As Long, LSeq As Long, WindowWidth As Long, NumBreakpoints As Long
Dim mPrb As Double, MChi As Double, Randum As Long
Dim TopLO As Long, TopRO As Long, LenR As Long, MCPScore() As Byte, ChiP As Double, Curnt As Long, Tempnt As Long, pmChi
Dim EraseAll As Byte
Dim ProbabilityXOver As Double
Dim Pict As Long
Dim PntAPI As POINTAPI
Dim PV As Double, MaxFailCount As Long, PBinFlag As Long


HWindowWidth = CLng(MCWinSize / 2)

'If Seq1 = 0 Or Seq1 = 1 Or Seq1 = 12 Then
'If Seq2 = 0 Or Seq2 = 1 Or Seq2 = 12 Then
'If Seq3 = 0 Or Seq3 = 1 Or Seq3 = 12 Then
'X = X
'End If
'End If
'End If


'13,17
'15,18
PBinFlag = -1


'XX = UBound(PermDiffs, 1)
If (PermDIffs(Seq1, Seq2) < 3 Or PermDIffs(Seq1, Seq3)) < 3 Or PermDIffs(Seq2, Seq3) < 3 Then
    If CLine = "" Or CLine = " " Then
    
       ' Dummy = CleanChiVals(LenXoverSeq, LenStrainSeq(0), Chivals(0, 0))
   
        Exit Sub
    End If
End If


UB = 0
 On Error Resume Next
UB = UBound(Chivals, 1)
On Error GoTo 0
If UB = 0 Then
    ReDim Scores(Len(StrainSeq(0)), 2)
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
    'XX = UBound(Winscores, 1)
    ReDim Chivals(Len(StrainSeq(0)), 2)
    ReDim SmoothChi(Len(StrainSeq(0)), 2)
    ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
End If
'XX = UBound(MDMap)
'Erase Scores
'Erase Winscores
'Erase Chivals
'Erase SmoothChi
'Erase ScoresX
'Erase WinScoresX
'Erase ChiValsX
'Erase SmoothChiX


'1.641,1.562
'This could be speeded up with better nesting
 If UBound(CompressSeq, 2) = NextNo And SEventNumber = 0 Then
    LenXoverSeq = FindSubSeqMCPB(UBound(FSSMC, 2), UBound(CompressSeq, 1), NextNo, Seq1, Seq2, Seq3, CompressSeq(0, 0), XDiffPos(0), XPosDiff(0), FSSMC(0, 0, 0, 0))
 Else
    LenXoverSeq = FindSubSeqCP(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), XDiffPos(0), XPosDiff(0))
 End If

'3.015,3.078



'I must calculate a more severe critical diff for the mccorrection - ie 2 diffs
'must be calculated - one for here and one for later on in calcchivals.
'XX = PermSeqNumInFile

If LenXoverSeq < CriticalDiff * 2 Then
    'Dummy = CleanChiVals(LenXoverSeq, LenStrainSeq(0), Chivals(0, 0))
    Exit Sub
End If
If LenXoverSeq < 7 Then
     'Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
    Exit Sub
End If

'
'If LenXoverSeq < MCWinSize Then
'    x = x
'End If
Call MakeWindowSize(BEP, ENP, CriticalDiff, LenXoverSeq, MCWinFract, MCWinSize, HWindowWidth, lHWindowWidth, GoOn, FindallFlag, MCProportionFlag, XPosDiff())

'3.375,3.281



If GoOn = 0 Then
     'Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
    Exit Sub
End If
'If HWindowWidth <> lHWindowWidth Then
'    '
'    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
'
'    lHWindowWidth = HWindowWidth
'End If


'3.312
'@
Dummy = WinScoreCalcP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), XDiffPos(0), SeqNum(0, 0), Winscores(0, 0))

'4.656,4.750

'Exit Sub
'This could be speeded up with better nesting

 

If FindallFlag = 0 And ((LongWindedFlag = 1 And SEventNumber > 0) Or CircularFlag = 0) Then
    If SEventNumber > 0 Then
       ' Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        If SEventNumber = 1 Then
            

            Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
            Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
            'ReDim BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
            
            


        End If
        'SS = Abs(GetTickCount)
        'For X = 0 To 200000
        '
        
        Dummy = MakeBanWinP(UBound(BanWin, 1), Seq1, Seq2, Seq3, HWindowWidth, Len(StrainSeq(0)), LenXoverSeq, BanWin(0), MDMap(0), MissingData(0, 0), XPosDiff(0), XDiffPos(0))
        'Next X
        'EE = Abs(GetTickCount)
        'TT = EE - SS
        'X = X '3837'3541'3339
        
        
        x = x
    Else
        'ReDim MDMap(LenXOverSeq), BanWin(LenXOverSeq + HWindowWidth * 2)
        
        Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
        Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
        'BanWin(1) = 1
        'BanWin(Len(StrainSeq(0))) = 1
    End If
    If CircularFlag = 0 Then
        'Ban windows spanning the ends of the alignment
        MDMap(1) = 1
        MDMap(LenXoverSeq) = 1
        '
        For x = (LenXoverSeq - HWindowWidth + 2) To LenXoverSeq
            BanWin(x) = 1
        Next x
        
    End If

    '10.605
    '10.465 using offsets
    '
    'XX = MaxEListLen
'    For x = 0 To Len(StrainSeq(0))
'        If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
'            x = x
'        End If
'    Next x
'    For x = 0 To LenXoverSeq
'        If MDMap(x) = 1 Then
'            x = x
'        End If
'    Next x
'    For x = 0 To LenXoverSeq
'        If BanWin(x) = 0 Then
'            x = x
'        End If
'    Next x
    'MChi = CalcChiVals4P2(UBound(ChiTable, 1), UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable(0, 0, 0))
    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
        '
        MChi = CalcChiVals4P3(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0), ChiTable2(Chimap(HWindowWidth)))
    Else
        MChi = CalcChiVals4P(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
    End If
    'MChi = CalcChiVals4(CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), BanWin(0))
Else
    If SEventNumber = 1 Then
        Dummy = ClearDeleteArrayB(UBound(MDMap, 1), MDMap(0))
        Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
    'ElseIf UBound(BanWin, 1) <> Len(StrainSeq(0)) + HWindowWidth * 2 Then
        'Dummy = ClearDeleteArray(UBound(BanWin, 1), BanWin(0))
    End If
'    If HWindowWidth > 4 And HWindowWidth <= MaxABWin Then
'        MChi = CalcChiValsP2(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXOverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0), ChiTable2(ChiMap(HWindowWidth)))
'    Else
        MChi = CalcChiValsP(UBound(Winscores, 1), CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)), Winscores(0, 0), Chivals(0, 0))
'    End If
   
End If





'8.203
'If ChiPVal2(MChi) * (LenXOverSeq / HWindowWidth) * 3 > LowestProb Then Exit Sub
If MCProportionFlag = 0 Then
        If (ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            Exit Sub
        End If
    Else
        If ((ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            Exit Sub
        End If
    End If
'8.313

If ShortOutFlag = 3 Then
    Call AddPVal(MCFlag, MChi, MCCorrection, LenXoverSeq, HWindowWidth, mtP(), 3)
End If


'Smooth to find peaks (uses a window of positions)


'test if this p version is quicker
'SmoothChiValsP LenXOverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'The p - varsion is slower
'@
SmoothChiValsP LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0), SmoothChi(0, 0)

'9.125,9.172


'Exit Sub


MChi = 0
'
DoneThis = 0 'Keeps track of whether plot drawn or not
WasteOfTime = 0 'Keeps track of how many cycles have been wasted looking for insinficant hit

'Now find recombination events


'XX = SEventNumber
Redox = 0
If MCFlag = 0 Then
    FullMC = 3 * LenXoverSeq / HWindowWidth
    FullMC = FullMC * MCCorrection
Else
    FullMC = 3 * LenXoverSeq / HWindowWidth
End If
Do
    Redox = Redox + 1
    '@
    FindMChiP Len(StrainSeq(0)), LenXoverSeq, MaxX, MaxY, MChi, Chivals(0, 0)
    
    '8.828,8.844
    
    If MaxX = -1 Or MaxY = -1 Or Redox > 100 Then
        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
        Exit Sub
    End If
    
    'The p-version of this seems slower than the old one
    mPrb = ChiPVal2(MChi)
    If MCProportionFlag = 0 Then
    '
        If (mPrb * (LenXoverSeq / HWindowWidth) * 3) > LowestProb Or mPrb = 1 Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
            Exit Sub
        End If
    Else
        If ((mPrb * (LenXoverSeq / HWindowWidth) * 6) * MCCorrection) > LowestProb Or mPrb = 1 Then
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
            Exit Sub
        End If
    End If
    '8.907
    'Exit Sub
    'XX = XPosDiff(2688)
    '10.000
    'Exit Sub
    
    If mPrb < LowestProb Then
        '
        maxz = MaxX
        
        If MaxX = 0 Then MaxX = 1
       
        Call MakeTWin(FindallFlag, HWindowWidth, TWin, LenXoverSeq)
        
        
        MaxFailCount = HWindowWidth * 2
        If MaxFailCount > Int((LenXoverSeq - TWin * 2) / 2) Then
            MaxFailCount = Int((LenXoverSeq - TWin * 2) / 2)
        End If
        If MaxFailCount = 0 Then MaxFailCount = 1
        '
        Failcount = 0: WinWin = HWindowWidth: A = 0: C = 0
        ''
        Dummy = GetAC(LenXoverSeq, Len(StrainSeq(0)), MaxY, MaxX, TWin, A, C, Scores(0, 0))
        
        
        'Now find the other breakpoint.
        pMaxX = MaxX
        If MaxX < 1 Then
            If CircularFlag = 1 Then
                MaxX = LenXoverSeq + MaxX
            Else
                MaxX = 1
            End If
        ElseIf MaxX > LenXoverSeq Then
            If CircularFlag = 1 Then
                MaxX = MaxX - LenXoverSeq
            Else
                MaxX = LenXoverSeq - 1
            End If
        End If
        
        If TWin >= HWindowWidth Then
            TopL = A: TopR = C
        Else
            TopL = 0: TopR = 0
        End If
        
        TWin = TWin + 1
        
        'Store best values from the initial screen
        
        MPV = mPrb * (LenXoverSeq / HWindowWidth)
        WinWin = HWindowWidth
        TopLO = MaxX - HWindowWidth + 1
        TopRO = MaxX + HWindowWidth
        
        LO = (MaxX - TWin + 1)
        If LO < 0 Then LO = LenXoverSeq + LO
        '
        RO = (MaxX + TWin)
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO >= LenXoverSeq Then
            If MDMap(LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                TWin = TWin - 1
                RO = LenXoverSeq
                LO = (MaxX - TWin + 1)
                If LO < 0 Then LO = LenXoverSeq + LO
                        
            End If
        End If
        'XX = MDMap(1)
        'Find the recombinant region starting at the peak and then expanding the window on
        'either side
        '28,336:34,362
        '
        If FindallFlag = 0 Then
            
            
            If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                'better use of floats might help here - also the p-version gives a slightly different result to the non-p version
                'These routines give slightly different results to the vc5 versions
                
                'compilerdiffs
                '
                'If X = X Then
                    ''
                    'lo=147, ro=166, lenxover = 240, A=5, C=7, topl=46, topr = 84; toplo 63, topro 10
                    'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                    Dummy = GrowMChiWin2P2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0), ChiTable2(0), Chimap(0))
'                    If WinWin > 1000 Then
'                        WinWin = 1000
'                    End If
'XX = CircularFlag
                    If WinWin < HWindowWidth Then
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                        'MPV = MPV
                    Else
                        MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                        'MPV = MPV
                    End If
                    'MPV = MPV * MCCorrection
                    '5.6988-4,3.118, 1912, 4755, 35, 4655
                    x = x
'                Else
'                    '20.9878
'                    '6.8674 x 10-4
'                    Dummy = GrowMChiWin2(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
'                    X = X
'                End If
                'Dummy = GrowMChiWin2P(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), MDMap(0))
                x = x
            Else
                'compilerdiffs
                'Dummy = GrowMChiWinP(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                
                
                If x = x Then
                    If x = x Then
                        Dummy = GrowMChiWinP2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), ChiTable2(0), Chimap(0))
'                        If WinWin > 1000 Then
'                            WinWin = 1000
'                        End If
                        If WinWin < HWindowWidth Then
                            If MChi < 20000 Then
                                MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            Else
                                MPV = 10 ^ -200
                            End If
                            'MPV = MPV
                        Else
                            If MChi < 20000 Then
                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            Else
'                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                                XX = ChiPVal2(20000)
                                MPV = 10 ^ -200
                            End If
                            'MPV = MPV
                        End If
                    Else
                        Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
'                        If WinWin > 1000 Then
'                            WinWin = 1000
'                        End If
                        If WinWin < HWindowWidth Then
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                            'MPV = MPV
                        Else
                            MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                            'MPV = MPV
                        End If
                        'Dummy = GrowMChiWin(LO, RO, LenXOverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
                    End If
                
                End If
                x = x
            End If
        Else
'            Dummy = GrowMChiWinP(LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0))
'            If WinWin < HWindowWidth Then
'                MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
'                'MPV = MPV
'            Else
'                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                'MPV = MPV
'            End If
            Dummy = GrowMChiWinP2(MaxABWin, LO, RO, LenXoverSeq, HWindowWidth, TWin, MaxY, Len(StrainSeq(0)), A, C, MaxFailCount, MPV, WinWin, MChi, TopL, TopR, TopLO, TopRO, Scores(0, 0), ChiTable2(0), Chimap(0))
'            If WinWin > 1000 Then
'                WinWin = 1000
'            End If
            If WinWin < HWindowWidth Then '35,35,57
                MPV = ChiPVal2(MChi) * (LenXoverSeq / WinWin)
                'MPV = MPV
            Else
                If MChi < 20000 Then
                    MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
                Else
'                                MPV = ChiPVal2(MChi) * (LenXoverSeq / HWindowWidth)
'                                XX = ChiPVal2(20000)
                    MPV = 10 ^ -200
                End If
                'MPV = MPV
            End If
           
        End If
        'xMPV
       
        
        If DebuggingFlag < 2 Then If DebuggingFlag < 2 Then On Error Resume Next
        xMPV = MPV 'MCCorrection * 3
        '
        If MCProportionFlag = 0 Then
            xMPV = xMPV * 3
        Else
            xMPV = xMPV * 3
        End If
        
        If BQPV > xMPV Then
            BQPV = xMPV
        End If
        
        If MCFlag = 0 Then
            
            xMPV = xMPV * MCCorrection
        
        End If
        MPV = xMPV
        '
        On Error GoTo 0
        
        If ShortOutFlag = 3 Then
            If MPV <= mtP(3) Then
                mtP(3) = MPV
            End If
        End If
        
        LO = MaxX - WinWin
        RO = MaxX + WinWin - 1
        If RO >= LenXoverSeq * 2 Then
            RO = RO - LenXoverSeq * 2
        End If
        If RO > LenXoverSeq Then
            
            If MDMap(RO - LenXoverSeq) = 0 Then
                RO = RO - LenXoverSeq
            Else
                RO = LenXoverSeq
            End If
        End If
        If LO < 1 Then
            LO = LO + LenXoverSeq
        End If
        '34.42
        
        
        '
        If MPV < LowestProb Then
            
            
            PPVal = -1
            
            
            If x = x Then
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) - 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) - 1
                    End If
                End If
                
                ProbabilityXOver = 0
                
                'So.....Which side of the window is the recombinant region?
                'Calculate windows on the other side of the region bounds
                'and find the the highest chi value.
                
                If (LO - WinWin + LenXoverSeq) < 0 Then
                     LO = (-LenXoverSeq + WinWin)
                End If
                ''
                
                Dummy = FindSide(TopL, TopR, Len(StrainSeq(0)), LO, RO, WinWin, LenXoverSeq, MaxY, Scores(0, 0), HiLeft, HiRight)
                If HiLeft < 0 Or HiRight < 0 Then
                    x = x
                End If
                If HiLeft >= HiRight Then
                    '                    'Find "best" matching breakpoint position.
                    CurWinPos = OptLeftBPMC(LO, HiLeft, TopL, MaxX, MaxY, WinWin, LenXoverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                    LO = CurWinPos '325,226,233,308,308
                    
                    If LO > LenXoverSeq Then LO = 1
                    If FindallFlag = 1 Then
                        XB = XDiffPos(MaxX)
                        XE = XDiffPos(RO)
                        
                        XEP = ChiPVal(Chivals(RO, MaxY)) * FullMC
                        XBP = mPrb * FullMC
                        
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    End If
                    
                    If LO < 1 Then
                        LO = LO + LenXoverSeq
                    End If
                    
                    If MaxX < 1 Then
                        RO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        RO = MaxX - LenXoverSeq
                    ElseIf MaxX = 1 Then
                        If MDMap(1) = 0 And BanWin(1) = 0 Then
                            RO = MaxX
                        Else
                            RO = LenXoverSeq
                        End If
                    Else
                        RO = MaxX
                    End If
                    
                    If RO > 0 Then
                        RO = RO - 1
                    End If
                    Do While MDMap(RO) <> 0
                        RO = RO - 1
                        If RO < 1 Then RO = LenXoverSeq
                    Loop
                    RO = RO + 1
                    If RO > LenXoverSeq Then RO = LenXoverSeq
                    
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO)
                    Else
                        BE = XDiffPos(LO + 1)
                    End If
                    EN = XDiffPos(RO)
                    
                        
                    BPV = ChiPVal(Chivals(LO, MaxY)) * FullMC
                    EPV = mPrb * FullMC
                    
                    
                Else
                    'Find "best" matching breakpoint position.
                    '1:55 with this, 1:20 without it - I need to get a working port of this finished
                    
                    CurWinPos = OptRightBPMC(RO, HiRight, TopR, MaxX, MaxY, WinWin, LenXoverSeq, Len(StrainSeq(0)), Scores(0, 0), MDMap(0))
                        
                    'CurWinPos = Dummy '45
                    RO = CurWinPos '115,106,90,103,111,142,101,111
                    
                    If RO < 1 Then RO = LenXoverSeq
                    If FindallFlag > 0 Then
                        XB = XDiffPos(LO)
                        XE = XDiffPos(MaxX)
                        
                        XBP = ChiPVal(Chivals(LO, MaxY)) * FullMC
                        XEP = mPrb * FullMC
                        
                    End If
                    If TopR > TopL Then
                        LoHiFlag = 1 ' ie in the recombinant region
                                    'the sequences share unusually high identity
                        MCMaxY = MaxY
                    Else
                        LoHiFlag = 0 ' ie in the recombinant region
                                    'the sequences share unusually low identity
                        MCMaxY = MaxY
                    End If
                    
                    If RO >= LenXoverSeq * 2 Then
                        RO = RO - LenXoverSeq * 2
                    End If
                    If RO > LenXoverSeq Then
                        RO = RO - LenXoverSeq
                    End If
                    
                    If MaxX < 0 Then
                        LO = LenXoverSeq + MaxX
                    ElseIf MaxX > LenXoverSeq Then
                        LO = MaxX - LenXoverSeq
                    Else
                        LO = MaxX
                    End If
                    
                    If LO < LenXoverSeq Then
                        LO = LO + 1
                    End If
                    Do While MDMap(LO) <> 0
                        LO = LO + 1
                        If LO > LenXoverSeq Then LO = 1
                    Loop
                    LO = LO - 1
                    If LO < 1 Then LO = 1
                    If LO + 1 > LenXoverSeq Then
                        BE = XDiffPos(LO)
                    Else
                        BE = XDiffPos(LO + 1)
                    End If
                    EN = XDiffPos(RO)
                    
                    BPV = mPrb * FullMC
                    EPV = ChiPVal(Chivals(RO, MaxY)) * FullMC
                    
                    
                End If
                
                MaxX = pMaxX
                
                'Destroy the completed peaks
                If LO < RO Then
                    If MaxX >= LO And MaxX <= RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                Else
                    If MaxX > LO Or MaxX < RO Then
                    Else
                        If Abs(MaxX - LO) > Abs(MaxX - RO) Then
                            RO = MaxX
                        Else
                            LO = MaxX
                        End If
                    End If
                End If
                'Destroy the completed peaks
                Dummy = DestroyPeaks(MaxY, LenXoverSeq, Len(StrainSeq(0)), LO, RO, SmoothChi(0, 0), Chivals(0, 0))
                Chivals(maxz, MaxY) = 0
                
                ProbabilityXOver = MPV
                If MCFlag = 2 Then
                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                    End If
                End If
                If MPV < LowestProb Then   'it is necessary to destroy the region if it is not accepted
                    
                                            'thats why this cut must be remade here
                    'store the event
                    If SEventNumber = 0 Then
                        If FastestFlag = 1 Then
                            If PBinFlag = -1 Then
                                If UseALFlag = 0 Then
                                    NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                Else
                                    NumInList = CurrentTripListNum
                                End If
                                PBinFlag = 1
                                If NumInList <= TripListLen Then
                                
                                    If ProgBinRead(3, Worthwhilescan(NumInList)) = 0 Then
                                    
                                        Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 8
                                    End If
                                End If
                            End If
                        End If
                    End If
                    
                    
                    EWarn = 0: BWarn = 0
                        If LongWindedFlag = 1 Then
                            If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                               
                            ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                                
                            ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                               
                                
                            ElseIf StoreLPV(3, Seq1) >= StoreLPV(3, Seq2) And StoreLPV(3, Seq1) >= StoreLPV(3, Seq3) Then
                                ActiveSeq = Seq1
                                ActiveMinorP = Seq2
                                ActiveMajorP = Seq3
                            ElseIf StoreLPV(3, Seq2) >= StoreLPV(3, Seq1) And StoreLPV(3, Seq2) >= StoreLPV(3, Seq3) Then
                                ActiveSeq = Seq2
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq3
                            ElseIf StoreLPV(3, Seq3) >= StoreLPV(3, Seq1) And StoreLPV(3, Seq3) >= StoreLPV(3, Seq2) Then
                                ActiveSeq = Seq3
                                ActiveMinorP = Seq1
                                ActiveMajorP = Seq2
                            End If
                        End If
                        'Keep track of signal numbers
                        oRecombNo(100) = oRecombNo(100) + 1
                        oRecombNo(3) = oRecombNo(3) + 1
                    
'                    If Seq1 = 2 And Seq2 = 24 And Seq3 = 44 Then
'                        x = x
'                    End If
                    If APermFlag = 0 Then
                        '
                        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 3, ProbabilityXOver, SIP)
                        
                    Else
                        SIP = 1
                    End If
                    
                    ActualFound = 1
                    NewOneFound = 1
                    If SIP < 0 Then
                        
                        If DoneRedo = 0 Then
                            DoneRedo = 1
                            Call AddToRedoList(3, Seq1, Seq2, Seq3)
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                            Exit Sub
                        End If
                    Else
                        '
                        If ActiveSeq > UBound(XoverList, 1) Then
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                            Exit Sub
                        End If
                        XoverList(ActiveSeq, SIP).Daughter = ActiveSeq '19,3
                        XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                        XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                        XoverList(ActiveSeq, SIP).SBPFlag = 0
                        XoverList(ActiveSeq, SIP).ProgramFlag = 3
                        
                        Call CentreBP(0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                        XoverList(ActiveSeq, SIP).Beginning = BE
                        XoverList(ActiveSeq, SIP).Ending = EN
                        XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                        If PPVal >= 0 Then
                            XoverList(ActiveSeq, SIP).PermPVal = PPVal
                        End If
                        XoverList(ActiveSeq, SIP).BeginP = 0 'BPV
                        XoverList(ActiveSeq, SIP).EndP = 0 'EPV
                        XoverList(ActiveSeq, SIP).DHolder = 0
                        'Store the window size used to detect this event
                        XoverList(ActiveSeq, SIP).LHolder = WinWin * 2
                        
                        'XX = XOverList(29, 76).Ending
                        If LongWindedFlag = 1 And (SEventNumber > 1 Or CircularFlag = 0) Then
                            If XPosDiff(EN) > LenXoverSeq Then XPosDiff(EN) = LenXoverSeq
                            If XPosDiff(EN) = LenXoverSeq Then
                                ENX = 1
                            Else
                                ENX = XPosDiff(EN) + 1
                            End If
                            If ENX > LenXoverSeq Then ENX = ENX - LenXoverSeq
                            
                            If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                                BEX = LenXoverSeq
                            Else
                                BEX = XPosDiff(BE) - 1
                            End If
                            If BEX < 1 Then BEX = LenXoverSeq + BEX
                            If SEventNumber > 0 Then
                                If EWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                                If BWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                            End If
                            If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 3
                            ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1 Or (EWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 2
                            ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1 Or (BWarn = 1) Then
                                XoverList(ActiveSeq, SIP).SBPFlag = 1
                            End If
                        End If
                        GoOn = 1
                        XB = BE
                        XE = EN
                        If FindallFlag = 1 Then
                            
                            If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                If x = x Then
                                    '
                                    GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                                
                                Else
                                
                                    If XB < XE Then
                                        For ZZ = XB To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    Else
                                        For ZZ = 1 To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                        For ZZ = XB To Len(StrainSeq(0))
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    End If
                                End If
                            End If
                        End If
                        
                        
                        If GoOn = 0 And FindallFlag = 1 Then 'erase it if it contained missingdata but only if findall=1
                            CurrentXOver(ActiveSeq) = CurrentXOver(ActiveSeq) - 1
                        Else
                            
                            'For some reason this is REALLY slow -I've disabled it
                            oActive = ActiveSeq
                            oMajP = ActiveMajorP
                            oMinP = ActiveMinorP
                            '@
                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                            x = x
                        End If
                        
                        If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                            StartPlt(3) = 1
                            Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                        End If
                        
                        If FindallFlag = 1 Then
                            GoOn = 1
                            XE = XoverList(ActiveSeq, SIP).Beginning
                            XB = XoverList(ActiveSeq, SIP).Ending
                            
                            If SEventNumber > 0 And DontWorryAboutSplitsFlag = 0 And ReassortmentFlag = 0 Then
                                If x = x Then
                                    GoOn = CheckMissingData(Seq1, Seq2, Seq3, XB, XE, Len(StrainSeq(0)), MissingData(0, 0))
                                Else
                                    If XB < XE Then
                                        For ZZ = XB To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    Else
                                        For ZZ = 1 To XE
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                        For ZZ = XB To Len(StrainSeq(0))
                                            If MissingData(ZZ, Seq1) = 1 Or MissingData(ZZ, Seq2) = 1 Or MissingData(ZZ, Seq3) = 1 Then
                                                GoOn = 0
                                            End If
                                        Next ZZ
                                    End If
                                End If
                            End If
                            If GoOn = 1 Then
                                
                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 3, ProbabilityXOver, SIP)
                                'If SIP < 1 Then
                                '    SIP = 0 'this "throws" the result away
                                'End If
                                If SIP > 0 Then
                                    If ActiveSeq > UBound(XoverList, 1) Then
                                        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                                        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                                        Exit Sub
                                    End If
                                    XoverList(ActiveSeq, SIP) = XoverList(ActiveSeq, SIP - 1)
                                    XoverList(ActiveSeq, SIP).SBPFlag = 0
                                    
                                    Call CentreBP(0, 0, Seq1, Seq2, Seq3, XB, XE, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                                    XoverList(ActiveSeq, SIP).Beginning = XB
                                    XoverList(ActiveSeq, SIP).Ending = XE '19,4
                                    XoverList(ActiveSeq, SIP).Probability = ProbabilityXOver
                                    If PPVal >= 0 Then
                                        XoverList(ActiveSeq, SIP).PermPVal = PPVal
                                    End If
                                    XoverList(ActiveSeq, SIP).BeginP = 0 'XBP
                                    XoverList(ActiveSeq, SIP).EndP = 0 'XEP
                                    XoverList(ActiveSeq, SIP).DHolder = 0
                                    'Store the window size used to detect this event
                                    If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                                        If XPosDiff(EN) = LenXoverSeq Then
                                            ENX = 1
                                        Else
                                            ENX = XPosDiff(EN) + 1
                                        End If
                                        If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                                            BEX = LenXoverSeq
                                        Else
                                            BEX = XPosDiff(BE) - 1
                                        End If
                                        
                                        If SEventNumber > 0 Then
                                            If EWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                            If BWarn = 0 Then Call CheckEndsVB(0, 0, MCWinSize / 2, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, XB, XE, SeqNum(), XPosDiff(), XDiffPos())
                                        End If
                                        If (MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1) And (MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1) Or (EWarn = 1 And BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 3
                                        ElseIf MDMap(ENX) = 1 Or MDMap(XPosDiff(EN)) = 1 Or (EWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                                        ElseIf MDMap(BEX) = 1 Or MDMap(XPosDiff(BE)) = 1 Or (BWarn = 1) Then
                                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                                        End If
                                        
                                        If LoHiFlag = 0 Then
                                            LoHiFlag = 1
                                        Else
                                            LoHiFlag = 0
                                        End If
                                        If MCMaxX = 0 Then
                                            MCMaxX = 1
                                        Else
                                            MCMaxX = 0
                                        End If
                                        If FindallFlag = 0 Then
                                            oActive = ActiveSeq
                                            oMajP = ActiveMajorP
                                            oMinP = ActiveMinorP
                                            
                                            Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 3, SIP)
                                            Call CentreBP(0, 0, Seq1, Seq2, Seq3, XoverList(ActiveSeq, SIP).Beginning, XoverList(ActiveSeq, SIP).Ending, XPosDiff(), XDiffPos(), BWarn, EWarn, MCWinSize / 2, LenXoverSeq)
                                        End If
                                    End If
                                End If
                            End If
                            
                            If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                StartPlt(3) = 1
                                Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                            End If
                        End If
                        
                        If ShortOutFlag = 1 Then
                            ShortOutput(3) = 1
                            AbortFlag = 1
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                            Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                            Exit Sub
                        End If
                        If ShortOutFlag = 50 Then ShortOutput(3) = 1
                        
                        
                        
                        ActiveSeq = oActive
                        ActiveMajorP = oMajP
                        ActiveMinorP = oMinP
                        WasteOfTime = 0
                        
                        'Draw the plot if necessary
                        If DoneThis = 0 And ShowPlotFlag = 1 Then
                        
                            DoneThis = 1
                            If MCFlag = 0 Then
                                CF = MCCorrection
                            Else
                                CF = 1
                            End If
                            CF = CF * Int((LenXoverSeq / HWindowWidth) + 0.49) * 3
                            mPrbL = -Log10(mPrb * CF)
                            
                            ZP = -Log10(LowestProb / MCCorrection)
                            
                            If mPrbL < ZP Then mPrbL = ZP
                            
                            Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(mPrbL), 0, 1, "-Log[P(Chi2)]")
                            YScaleFactor = 0.85
                            PicHeight = (Form1.Picture7.Height * YScaleFactor)
                            Form1.Picture7.DrawStyle = 2
                            
                            ZP = -Log10(LowestProb)
                            
                            Form1.Picture7.DrawStyle = 0
                            Form1.Picture7.DrawWidth = 1
                            WN1 = Seq1: WN2 = Seq2: WN3 = Seq3
                            WNStr(1) = OriginalName(Seq1): WNStr(2) = OriginalName(Seq2): WNStr(3) = OriginalName(Seq3)
                            Call WriteNames(Seq1, Seq2, Seq3, Yellow, Green, Purple)
                            For Y = 0 To 2
                                If Y = 0 Then
                                    Form1.Picture7.ForeColor = Yellow
                                ElseIf Y = 1 Then
                                    Form1.Picture7.ForeColor = Green
                                ElseIf Y = 2 Then
                                    Form1.Picture7.ForeColor = Purple
                                End If
                                Pict = Form1.Picture7.hdc
                                If -Log10(ChiPVal(Chivals(1, Y)) * CF) > 0 Then
                                    Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1)) * XFactor), -15 + PicHeight - (-Log10(ChiPVal(Chivals(1, Y)) * CF) / (mPrbL)) * (PicHeight - 35), PntAPI)
                                Else
                                    Dummy = MoveToEx(Pict, (30 + Decompress(XDiffPos(1)) * XFactor), -15 + PicHeight, PntAPI)
                                End If
                                For x = 2 To LenXoverSeq - 1
                                    If -Log10(ChiPVal(Chivals(x, Y)) * CF) > 0 Then
                                        Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x)) * XFactor, -15 + PicHeight - (-Log10(ChiPVal(Chivals(x, Y)) * CF) / mPrbL) * (PicHeight - 35))
                                    Else
                                        Dummy = LineTo(Pict, 30 + Decompress(XDiffPos(x)) * XFactor, -15 + PicHeight)
                                    End If
                                Next '
                            Next '
                            Form1.Picture7.Refresh
                        End If
                    
                        
                    End If
                Else
                    WasteOfTime = WasteOfTime + 1
                    If WasteOfTime = 3 Then
                        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                        Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                        Exit Sub
                    End If
                End If
            Else
                WasteOfTime = WasteOfTime + 1
                If WasteOfTime = 3 Then
                    Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                    Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                    Exit Sub
                End If
            End If
        Else
            WasteOfTime = WasteOfTime + 1
            If WasteOfTime = 3 Then
                Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                Exit Sub
            End If
            
            RO = pMaxX
            LO = pMaxX
            'XX = Chivals(420, 2)
            'destroy the maxx peak
            Dummy = DestroyPeakP(MaxY, Len(StrainSeq(0)), RO, LO, LenXoverSeq, LOT(0), SmoothChi(0, 0), Chivals(0, 0))
            '
            If maxz = -1 Or MaxY = -1 Then
                Dummy2 = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                Dummy2 = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                Exit Sub
            End If
            Chivals(maxz, MaxY) = 0
            If Dummy = 0 Then
                Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
                Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
                Exit Sub
            End If
        End If
    Else
        Exit Do
    End If
    'XOverList(7, 1).Beginning = XOverList(7, 1).Beginning
    'XOverList(7, 1).Ending = XOverList(7, 1).Ending
Loop
Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), Chivals(0, 0))
Dummy = CleanChiVals(LenXoverSeq, Len(StrainSeq(0)), SmoothChi(0, 0))
End Sub
