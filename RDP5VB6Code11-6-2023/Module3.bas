Attribute VB_Name = "Module3"
Public Sub Distance10()

Dim SeqBin() As Byte
ReDim SeqBin(Len(StrainSeq(0)), NextNo)


End Sub

Public Sub WriteSequences(NumSeqs As Long, AName As String, TempName() As String, TempSeq() As String, ProgressFlag As Long)

Dim FF As Long, NameString() As String, Addj As Long, x As Long, Y As Long, Addon As Long, MaxNS As Long, TString As String, MaxNLen As Long
    FF = FreeFile
    If AName = "" Or AName = " " Then Exit Sub
    'Close #FF
    Open AName For Output As #FF
    If Right$(AName, 4) = ".msd" Or Right$(AName, 4) = ".MSD" Then
        'Save DNAMAN file
        Print #FF, "FILE: Multiple_Sequence_Alignment"
        Print #FF, "PROJECT:"
        Print #FF, "NUMBER:" + CStr(NumSeqs + 1)
        Print #FF, "MAXLENGTH:" + CStr(Len(TempSeq(0)))
        Addj = 65

        For x = 0 To NumSeqs

            If Len(TempName(x)) > 9 Then
                TempName(x) = Mid$(TempName(x), 1, 8) + Str$(Addj)
                Addj = Addj + 1
            End If

        Next 'X

        ReDim NameString(Int((NumSeqs + 1) / 6) + 1)
        NameString(0) = "NAMES:"

        For x = 1 To Int((NumSeqs + 1) / 6)
            NameString(x) = "      "
        Next 'X

        For x = 0 To Int((NumSeqs + 1) / 6)
            Y = 0

            Do Until Y = 6 Or (x * 6 + Y) > NumSeqs
                NameString(x) = NameString(x) + " " + TempName(x * 6 + Y)
                Y = Y + 1
            Loop

        Next 'X

        For x = 0 To Int((NumSeqs + 1) / 6)
            Print #FF, NameString(x)
        Next 'X

        Print #FF, ""
        Print #FF, "ORIGIN"

        For x = 0 To NumSeqs
            Addon = 10 - Len(TempName(x))
            If Addon >= 0 Then
                TempName(x) = TempName(x) + String$(Addon, 32)
            End If
        Next 'X

        For x = 1 To Int(Len(TempSeq(0)) / 60)

            For Y = 0 To NumSeqs
                Print #FF, TempName(Y) + Mid$(TempSeq(Y), x * 60 - 59, 60)
            Next 'Y

            Print #FF, ""
        Next 'X

        For Y = 0 To NumSeqs
            Print #FF, TempName(Y) + Mid$(TempSeq(Y), x * 60 - 59, Len(TempSeq(0)) - (x * 60 - 60))
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next 'Y

    ElseIf Right$(AName, 4) = ".aln" Or Right$(AName, 4) = ".ALN" Then
        Addj = 0

        For x = 0 To NumSeqs

            If Len(TempName(x)) > 15 Then
                TempName(x) = Mid$(TempName(x), 1, 13) + Trim(Str(Addj))
                Addj = Addj + 1
            End If

            Addon = 16 - Len(TempName(x))
            If Addon >= 0 Then
                TempName(x) = TempName(x) + String$(Addon, 32)
            End If
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next 'X

        Print #FF, "CLUSTAL multiple sequence alignment"
        Print #FF, ""
        Print #FF, ""

        For Y = 1 To Len(TempSeq(0)) Step 60

            For x = 0 To NumSeqs
                Print #FF, TempName(x) + Mid$(TempSeq(x), Y, 60)
            Next 'X

            Print #FF, ""
            Print #FF, ""
        Next 'Y

    ElseIf Right$(AName, 4) = ".phy" Or Right$(AName, 4) = ".PHY" Then
        'Save alignment in phylip Format
        Addj = 65
        MaxNS = 0
        For x = 0 To NumSeqs
            If MaxNS < Len(TempName(x)) Then
                MaxNS = Len(TempName(x))
            End If
        Next x
        MaxNS = MaxNS + 1
        If MaxNS < 10 Then
            MaxNS = 10
        End If
        If x = x Then
            Print #FF, Trim$(CStr(NumSeqs + 1)) & " " & Trim$(CStr(Len(TempSeq(0)))) '& " 1"
            For x = 0 To NumSeqs
                If Len(TempName(x)) < MaxNS Then
                    Print #FF, TempName(x) + String(MaxNS - Len(TempName(x)), " ") + TempSeq(x)
                Else
                    Print #FF, Left(TempName(x), MaxNS) + TempSeq(x)
                End If
                If ProgressFlag = 1 Then
                    Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                    Call UpdateF2Prog
                End If
            Next 'X
            Close #FF
            'Exit Sub
        Else
            For x = 0 To NumSeqs
    
                If Len(TempName(x)) > 10 Then
                    TempName(x) = Mid$(TempName(x), 1, 8) + Chr$(Addj)
                    Addj = Addj + 1
                End If
    
                Addon = 10 - Len(TempName(x))
                TempName(x) = TempName(x) + String$(Addon, 32)
            Next 'X
        
        
        
        
            Print #FF, "    " & Trim$(CStr(NumSeqs + 1)) & "   " & Trim$(CStr(Len(TempSeq(0))))
    
            For Y = 1 To Len(TempSeq(0)) Step 50
    
                For x = 0 To NumSeqs
                    TString = ""
    
                    For Z = 0 To 49 Step 10
                        TString = TString + " " + Mid$(TempSeq(x), Y + Z, 10)
                    Next 'Z
    
                    Print #FF, TempName(x) + TString
    
                    If Y = 1 Then
                        TempName(x) = String$(10, " ")
                    End If
    
                Next 'X
    
                Print #FF, ""
            Next 'Y
        End If
    ElseIf Right$(AName, 4) = ".gde" Or Right$(AName, 4) = ".GDE" Then
        'Save alignment in GDE Format

        For x = 0 To NumSeqs
            Print #FF, "#" & TempName(x)

            For Y = 1 To Len(TempSeq(0)) + 60 Step 60
                Print #FF, Mid$(TempSeq(x), Y, 60)
            Next 'Y
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next 'X
    ElseIf Right$(AName, 4) = ".nex" Or Right$(AName, 4) = ".NEX" Then
        
        Print #FF, "#NEXUS"
        Print #FF, ""
        Print #FF, "BEGIN DATA;"
        Print #FF, "DIMENSIONS NTAX=" & Trim(Str(NumSeqs + 1)) & " NCHAR=" & Trim(Str(Len(StrainSeq(0)))) & ";"
        Print #FF, "FORMAT MISSING=? GAP=- DATATYPE=DNA;"
        Print #FF, "MATRIX"
         
        MaxNLen = 0
        For x = 0 To NumSeqs
            If Len(OriginalName(x)) > MaxNLen Then MaxNLen = Len(OriginalName(x))
        Next x
        MaxNLen = MaxNLen + 2
        For x = 0 To NumSeqs
            Print #FF, OriginalName(x) + String(MaxNLen - Len(OriginalName(x)), " ") + StrainSeq(x)
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next x
        Print #FF, ";"
        Close #FF
    Else
        'Save alignment in FASTA format

        For x = 0 To NumSeqs
            Print #FF, ">" & TempName(x)

            For Y = 1 To Len(TempSeq(x)) + 70 Step 70
                Print #FF, Mid$(TempSeq(x), Y, 70)
            Next 'Y
            If NumSeqs > 0 Then
                If ProgressFlag = 1 Then
                    Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                    Call UpdateF2Prog
                End If
            End If
        Next 'X

    End If
    
    Close #FF

End Sub
Public Sub WriteSequences2(NumSeqs As Long, AName As String, TempName() As String, TempSeq() As String, ProgressFlag As Long, WritePos() As Long)

Dim oDirX As String, TSX As String, FF As Long, FF2 As Long, NameString() As String, Addj As Long, x As Long, Y As Long, Addon As Long, MaxNS As Long, TString As String, MaxNLen As Long
    'Close #1
    FF = FreeFile
    If AName = "" Or AName = " " Then Exit Sub
    Open AName For Output As #FF
    FF2 = FreeFile
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    Open "TF" + UFTag For Binary As #FF2
    'oDirX = CurDir
    ChDrive oDirX
    ChDir oDirX
    If Right$(AName, 4) = ".msd" Or Right$(AName, 4) = ".MSD" Then
        'Save DNAMAN file
        Print #FF, "FILE: Multiple_Sequence_Alignment"
        Print #FF, "PROJECT:"
        Print #FF, "NUMBER:" + CStr(NumSeqs + 1)
        Print #FF, "MAXLENGTH:" + CStr((Len(TempSeq(0))))
        Addj = 65

        For x = 0 To NumSeqs

            If Len(TempName(x)) > 9 Then
                TempName(x) = Mid$(TempName(x), 1, 8) + Str$(Addj)
                Addj = Addj + 1
            End If

        Next 'X

        ReDim NameString(Int((NumSeqs + 1) / 6) + 1)
        NameString(0) = "NAMES:"

        For x = 1 To Int((NumSeqs + 1) / 6)
            NameString(x) = "      "
        Next 'X

        For x = 0 To Int((NumSeqs + 1) / 6)
            Y = 0

            Do Until Y = 6 Or (x * 6 + Y) > NumSeqs
                NameString(x) = NameString(x) + " " + TempName(x * 6 + Y)
                Y = Y + 1
            Loop

        Next 'X

        For x = 0 To Int((NumSeqs + 1) / 6)
            Print #FF, NameString(x)
        Next 'X

        Print #FF, ""
        Print #FF, "ORIGIN"

        For x = 0 To NumSeqs
            Addon = 10 - Len(TempName(x))
            If Addon >= 0 Then
                TempName(x) = TempName(x) + String$(Addon, 32)
            End If
        Next 'X

        For x = 1 To CLng((Len(TempSeq(0))) / 60)

            For Y = 0 To NumSeqs
                TSX = String(60, " ")
                Get #FF2, WritePos(Y) + x * 60 - 60, TSX
                Print #FF, TempName(Y) + TSX
                'Print #FF, TempName(Y) + Mid$(TempSeq(Y), x * 60 - 59, 60)
            Next 'Y

            Print #FF, ""
        Next 'X

        For Y = 0 To NumSeqs
            TSX = String((Len(TempSeq(0))) - (x * 60 - 60), " ")
            Get #FF2, WritePos(Y) + x * 60 - 60, TSX
            Print #FF, TempName(Y) + TSX
            'Print #FF, TempName(Y) + Mid$(TempSeq(Y), x * 60 - 59, Len(TempSeq(0)) - (x * 60 - 60))
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next 'Y

    ElseIf Right$(AName, 4) = ".aln" Or Right$(AName, 4) = ".ALN" Then
        Addj = 0

        For x = 0 To NumSeqs

            If Len(TempName(x)) > 15 Then
                TempName(x) = Mid$(TempName(x), 1, 13) + Trim(Str(Addj))
                Addj = Addj + 1
            End If

            Addon = 16 - Len(TempName(x))
            If Addon >= 0 Then
                TempName(x) = TempName(x) + String$(Addon, 32)
            End If
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next 'X

        Print #FF, "CLUSTAL multiple sequence alignment"
        Print #FF, ""
        Print #FF, ""

        For Y = 1 To Len((TempSeq(0))) Step 60

            For x = 0 To NumSeqs
                TSX = String(60, " ")
                Get #FF2, WritePos(Y) + x * 60 - 60, TSX
                Print #FF, TempName(x) + TSX
                'Print #FF, TempName(x) + Mid$(TempSeq(x), Y, 60)
            Next 'X

            Print #FF, ""
            Print #FF, ""
        Next 'Y

    ElseIf Right$(AName, 4) = ".phy" Or Right$(AName, 4) = ".PHY" Then
        'Save alignment in phylip Format
        Addj = 65
        MaxNS = 0
        For x = 0 To NumSeqs
            If MaxNS < Len(TempName(x)) Then
                MaxNS = Len(TempName(x))
            End If
        Next x
        MaxNS = MaxNS + 1
        If MaxNS < 10 Then
            MaxNS = 10
        End If
        If x = x Then
            
            Print #FF, Trim$(CStr(NumSeqs + 1)) & " " & Trim$(CStr((Len(TempSeq(0))))) '& " 1"
            For x = 0 To NumSeqs
                TSX = String(Len((TempSeq(0))), " ")
                Get #FF2, WritePos(x), TSX
                If Len(TempName(x)) < MaxNS Then
                    Print #FF, TempName(x) + String(MaxNS - Len(TempName(x)), " ") + TSX
                    'Print #FF, TempName(x) + String(MaxNS - Len(TempName(x)), " ") + TempSeq(x)
                Else
                    Print #FF, Left(TempName(x), MaxNS) + TSX
                    'Print #FF, Left(TempName(x), MaxNS) + TempSeq(x)
                End If
                If ProgressFlag = 1 Then
                    Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                    Call UpdateF2Prog
                End If
            Next 'X
            Close #FF
            'Exit Sub
        Else
            For x = 0 To NumSeqs
    
                If Len(TempName(x)) > 10 Then
                    TempName(x) = Mid$(TempName(x), 1, 8) + Chr$(Addj)
                    Addj = Addj + 1
                End If
    
                Addon = 10 - Len(TempName(x))
                TempName(x) = TempName(x) + String$(Addon, 32)
            Next 'X
        
        
        
        
            Print #FF, "    " & Trim$(CStr(NumSeqs + 1)) & "   " & Trim$(CStr((Len(TempSeq(0)))))
    
            For Y = 1 To Len(TempSeq(0)) Step 50
    
                For x = 0 To NumSeqs
                    TString = ""
    
                    For Z = 0 To 49 Step 10
                        TSX = String(10, " ")
                        Get #FF2, WritePos(x) + Y + Z - 1, TSX
                        
                        TString = TString + " " + Mid$(TempSeq(x), Y + Z, 10)
                    Next 'Z
    
                    Print #FF, TempName(x) + TString
    
                    If Y = 1 Then
                        TempName(x) = String$(10, " ")
                    End If
    
                Next 'X
    
                Print #FF, ""
            Next 'Y
        End If
    ElseIf Right$(AName, 4) = ".gde" Or Right$(AName, 4) = ".GDE" Then
        'Save alignment in GDE Format

        For x = 0 To NumSeqs
            Print #FF, "#" & TempName(x)

            For Y = 1 To Len(TempSeq(0)) + 60 Step 60
                TSX = String(60, " ")
                Get #FF2, WritePos(Y) + Y - 1, TSX
                Print #FF, TSX
                'Print #FF, Mid$(TempSeq(x), Y, 60)
            Next 'Y
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next 'X
    ElseIf Right$(AName, 4) = ".nex" Or Right$(AName, 4) = ".NEX" Then
        
        Print #FF, "#NEXUS"
        Print #FF, ""
        Print #FF, "BEGIN DATA;"
        Print #FF, "DIMENSIONS NTAX=" & Trim(Str(NumSeqs + 1)) & " NCHAR=" & Trim(Str(Len(StrainSeq(0)))) & ";"
        Print #FF, "FORMAT MISSING=? GAP=- DATATYPE=DNA;"
        Print #FF, "MATRIX"
         
        MaxNLen = 0
        For x = 0 To NumSeqs
            If Len(TempName(x)) > MaxNLen Then MaxNLen = Len(TempName(x))
        Next x
        MaxNLen = MaxNLen + 2
        For x = 0 To NumSeqs
            TSX = String(Len(TempSeq(0)), " ")
            Get #FF2, WritePos(x), TSX
            Print #FF, OriginalName(x) + String(MaxNLen - Len(OriginalName(x)), " ") + TSX
            If ProgressFlag = 1 Then
                Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                Call UpdateF2Prog
            End If
        Next x
        Print #FF, ";"
        Close #FF
    Else
        'Save alignment in FASTA format
'XX = FF2
        For x = 0 To NumSeqs
            Print #FF, ">" & TempName(x)
            TSX = String((Len(TempSeq(0))), " ")
            XX = LOF(FF2)
            Get #FF2, WritePos(x), TSX
            'XX = Mid$(TSX, 65, 10)
            Print #FF, TSX
'            For Y = 1 To Len(TempSeq(0)) + 70 Step 70
'                Print #FF, Mid$(TSX, Y, 70)
'                'XX = Right(Mid$(TSX, Y, 71), 10)
'                x = x
'                'XX = Mid$(TSX, Y - 5, 10)
'            Next 'Y
            If NumSeqs > 0 Then
                If ProgressFlag = 1 Then
                    Form1.ProgressBar1.Value = 60 + x / NumSeqs * 40
                    Call UpdateF2Prog
                End If
            End If
        Next 'X

    End If
    
    Close #FF
    Close #FF2
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    Kill "TF" + UFTag
    'oDirX = CurDir
    ChDrive oDirX
    ChDir oDirX
End Sub

Public Sub SaveGeneAlignment(AName As String, CurGeneNo, StripOLFlag, RealignFlag, StripPartFlag, AccountREcombFlag, CutShort, StripDuplicates)
Dim GeneSeq() As Integer, BasesToSave() As Byte, Y As Long, x As Long, Z As Long, SP As Long, EP As Long, LenSave As Long, MapToAlign() As Long, MapBack() As Long, WrapFlag As Long, oRelX As Long, oRelY As Long
'GeneSEPos(Y, X, z)'y=seq number, x = genenumber, z = position - 0,1 = bounds of start codon, 2,3 = bounds of stop codon
ReDim BasesToSave(Len(StrainSeq(0)))
Form1.SSPanel1.Caption = "Saving coding region alignment"
Form1.ProgressBar1 = 5


Call UnModNextno
Call UnModSeqNum(0)
oRelX = RelX
oRelY = RelY


ReDim TreeTrace(NextNo)
For x = 0 To NextNo
    TreeTrace(x) = x
Next x

If GeneList(CurGeneNo).Orientation = 1 Then
    
    For Y = 0 To NextNo
        SP = GeneSEPos(TreeTrace(Y), CurGeneNo, 0)
        EP = GeneSEPos(TreeTrace(Y), CurGeneNo, 3)
        If SP = 0 And EP = 0 Then
            SP = GeneList(CurGeneNo).StartInAlign
            EP = GeneList(CurGeneNo).EndInAlign
        End If
        If SP > 0 Or EP > 0 Then
            
        
            If SP < EP Then
                For Z = SP To EP
                    BasesToSave(Z) = 1
                Next Z
            Else
                For Z = SP To Len(StrainSeq(0))
                    BasesToSave(Z) = 1
                Next Z
                For Z = 1 To EP
                    BasesToSave(Z) = 1
                Next Z
            End If
        End If
        'XX = BasesToSave(1)
    Next Y
   
Else
    For Y = 0 To NextNo
        SP = GeneSEPos(TreeTrace(Y), CurGeneNo, 1)
        EP = GeneSEPos(TreeTrace(Y), CurGeneNo, 2)
        If SP = 0 And EP = 0 Then
            SP = GeneList(CurGeneNo).StartInAlign
            EP = GeneList(CurGeneNo).EndInAlign
        End If
        If EP < SP Then
            For Z = EP To SP
                BasesToSave(Z) = 1
            Next Z
        Else
            For Z = EP To Len(StrainSeq(0))
                BasesToSave(Z) = 1
            Next Z
            For Z = 1 To SP
                BasesToSave(Z) = 1
            Next Z
        End If
    Next Y
End If


' cant rely on modeseqmum for this - I have to split the sequences up myself

SS = Abs(GetTickCount)
Dim Changed() As Long
Call UnModNextno
Call UnModSeqNum(0)
Dim ACF As Byte
If AccountREcombFlag = 1 Then
    For x = 1 To SEventNumber
        ReDim Changed(NextNo + 20)
        RelX = BestEvent(x, 0)
        RelY = BestEvent(x, 1)
        ACF = XoverList(RelX, RelY).Accept
        BE = XoverList(RelX, RelY).Beginning
        EN = XoverList(RelX, RelY).Ending
        If BasesToSave(BE) = 1 Or BasesToSave(EN) = 1 Then
            For Y = 0 To NextNo
                If Daught(x, TreeTrace(Y)) > 0 Then
                    
                    
                    If ACF < 2 Then
                        NextNo = NextNo + 1
                        If NextNo > UBound(TreeTrace, 1) Then
                            ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + 20)
                            ReDim Preserve OriginalName(NextNo + 20)
                            ReDim Preserve TreeTrace(NextNo + 20)
                        End If
                        If UBound(Changed, 1) < NextNo Then
                            ReDim Preserve Changed(NextNo + 20)
                        End If
                        Changed(NextNo) = 1
                    End If
                    Changed(Y) = 1
                    
                    
                    If BE < EN Then
                        If ACF < 2 Then
                            For Z = 1 To BE - 1
                                If SeqNum(Z, Y) > 46 Then
                                    SeqNum(Z, NextNo) = 79
                                Else
                                    SeqNum(Z, NextNo) = 46
                                End If
                            Next Z
                        End If
                        For Z = BE To EN
                            If ACF < 2 Then
                                SeqNum(Z, NextNo) = SeqNum(Z, Y)
                            End If
                            If SeqNum(Z, Y) > 46 Then
                                SeqNum(Z, Y) = 79
                            Else
                                SeqNum(Z, Y) = 46
                            End If
                        Next Z
                        For Z = EN + 1 To Len(StrainSeq(0))
                            If SeqNum(Z, Y) > 46 Then
                                SeqNum(Z, NextNo) = 79
                            Else
                                SeqNum(Z, NextNo) = 46
                            End If
                        Next Z
                    Else
                        If ACF < 2 Then
                            For Z = EN + 1 To BE - 1
                                If SeqNum(Z, Y) > 46 Then
                                    SeqNum(Z, NextNo) = 79
                                Else
                                    SeqNum(Z, NextNo) = 46
                                End If
                            Next Z
                        End If
                        For Z = BE To Len(StrainSeq(0))
                            If ACF < 2 Then
                                SeqNum(Z, NextNo) = SeqNum(Z, Y)
                            End If
                            If SeqNum(Z, Y) > 46 Then
                                SeqNum(Z, Y) = 79
                            Else
                                SeqNum(Z, Y) = 46
                            End If
                        Next Z
                        For Z = 1 To EN
                            If ACF < 2 Then
                                SeqNum(Z, NextNo) = SeqNum(Z, Y)
                            End If
                            If SeqNum(Z, Y) > 46 Then
                                SeqNum(Z, Y) = 79
                            Else
                                SeqNum(Z, Y) = 46
                            End If
                        Next Z
                        
                    End If
                    OriginalName(NextNo) = OriginalName(Y)
                    TreeTrace(NextNo) = TreeTrace(Y)
                End If
            Next Y
            'wipe empty sequences
        End If
        Z = PermNextno + 1
        Do While Z <= NextNo
            If Changed(Z) = 1 Then
                GoOn = 0
                For Y = 1 To Len(StrainSeq(0))
                    If SeqNum(Y, Z) <> 46 And SeqNum(Y, Z) <> 79 Then GoOn = 1: Exit For
                Next Y
                If GoOn = 0 Then
                    If Z < NextNo Then
                        For Y = 1 To Len(StrainSeq(0))
                            SeqNum(Y, Z) = SeqNum(Y, NextNo)
                            
                        Next Y
                        TreeTrace(Z) = TreeTrace(NextNo)
                        OriginalName(Z) = OriginalName(NextNo)
                        Z = Z - 1
                    End If
                    NextNo = NextNo - 1
                    
                End If
            End If
            Z = Z + 1
        Loop
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 500 Then
            EE = SS
            Form1.ProgressBar1 = 5 + (x / SEventNumber) * 42
        End If
    Next x

End If
'XX = PermNextno
'EE = abs(gettickcount)
'TT = EE - SS '1938
'SS = abs(gettickcount)
Form1.ProgressBar1 = 47
ReDim MapToAlign(Len(StrainSeq(0))), MapBack(Len(StrainSeq(0)))
LenSave = 0

Dim ZeroFlag As Long
ZeroFlag = 0
For x = 1 To Len(StrainSeq(0))
    If BasesToSave(x) = 0 Then
        
        ZeroFlag = 1
        Exit For
    ElseIf x = 1 Then
        ZeroFlag = 0
        Exit For
    
    End If
    
Next x
For x = 1 To Len(StrainSeq(0))
    MapBack(x) = LenSave
    If BasesToSave(x) = 0 Or ZeroFlag = 0 Then
        
        If x = 1 Then
            WrapFlag = 0
        ElseIf ZeroFlag = 1 Then
            WrapFlag = 1
        Else
            WrapFlag = 0
        End If
        For Y = x To Len(StrainSeq(0))
            MapBack(Y) = LenSave
            If BasesToSave(Y) = 1 Then
                For Z = Y To Len(StrainSeq(0))
                    If BasesToSave(Z) = 1 Then
                        LenSave = LenSave + 1
                        MapToAlign(LenSave) = Z
                        
                   
                    End If
                    MapBack(Z) = LenSave
                Next Z
                If WrapFlag = 1 Then
                    For Z = 1 To Len(StrainSeq(0))
                        If BasesToSave(Z) = 1 Then
                            LenSave = LenSave + 1
                            MapToAlign(LenSave) = Z
                            MapBack(Z) = LenSave
                        Else
                            Exit For
                        End If
                    
                    Next Z
                
                End If
                Exit For
                
            End If
        Next Y
        'LenSave = LenSave + BasesToSave(X)
        Exit For
    End If
Next x



ReDim GeneSeq(LenSave, NextNo)

If GeneList(CurGeneNo).Orientation = 1 Then
    For Y = 0 To NextNo
        SP = GeneSEPos(TreeTrace(Y), CurGeneNo, 0)
        EP = GeneSEPos(TreeTrace(Y), CurGeneNo, 3)
        If SP < EP Then
            For Z = SP To EP
                GeneSeq(MapBack(Z), Y) = SeqNum(Z, Y)
            Next Z
        Else
            For Z = SP To Len(StrainSeq(0))
                GeneSeq(MapBack(Z), Y) = SeqNum(Z, Y)
            Next Z
            For Z = 1 To EP
                GeneSeq(MapBack(Z), Y) = SeqNum(Z, Y)
            Next Z
        End If
    Next Y
Else
    For Y = 0 To NextNo
        SP = GeneSEPos(TreeTrace(Y), CurGeneNo, 1)
        EP = GeneSEPos(TreeTrace(Y), CurGeneNo, 2)
        If EP < SP Then
            For Z = EP To SP
                GeneSeq(MapBack(Z), Y) = SeqNum(Z, Y)
            Next Z
        Else
            For Z = EP To Len(StrainSeq(0))
                GeneSeq(MapBack(Z), Y) = SeqNum(Z, Y)
            Next Z
            For Z = 1 To SP
                GeneSeq(MapBack(Z), Y) = SeqNum(Z, Y)
            Next Z
        End If
    Next Y
    
End If



'Sort out overlaps
If StripOLFlag = 1 Then
'OverlapList
    For Y = 1 To Len(StrainSeq(0))
        If OverlapList(Y) = -1 Then
            CP = MapBack(Y)
            If CP > 0 Then
                For x = 0 To NextNo
                    If GeneSeq(CP, x) > 47 Then
                        GeneSeq(CP, x) = 79
                    Else
                        GeneSeq(CP, x) = 46
                    End If
                Next x
            End If
        End If
    Next Y
End If



Dim NucNum() As Long
ReDim NucNum(NextNo)





Dim TempSeq() As String, TempName() As String
XX = PermNextno
ReDim TempName(NextNo)
For x = 0 To NextNo
    TempName(x) = OriginalName(TreeTrace(x))
Next x





ReDim TempSeq(NextNo)

For x = 0 To NextNo
    TempSeq(x) = String(LenSave, " ")
    For Y = 1 To LenSave
        CP = GeneSeq(Y, x)
        If CP > 47 Then
            Mid(TempSeq(x), Y, 1) = Chr(CP - 1)
'            XX = Chr(CP - 1)
'            X = X
        Else
            Mid(TempSeq(x), Y, 1) = "-"
        End If
    Next Y
Next x




'trim empties if necessery

For x = 0 To NextNo
    For Y = 1 To LenSave
        If GeneSeq(Y, x) > 46 And GeneSeq(Y, x) <> 79 Then
            NucNum(x) = NucNum(x) + 1
        End If
    Next Y
Next x

'remove empty sequences


'EE = abs(gettickcount)
'TT = EE - SS '692
Form1.ProgressBar1 = 60
'use bit with the most nts
If StripDuplicates = 1 Then
    For x = 0 To NextNo - 1
        For Y = x + 1 To NextNo
            If TreeTrace(x) = TreeTrace(Y) Then
                
                If NucNum(x) < NucNum(Y) Then
                    NucNum(x) = NucNum(Y)
                    TempSeq(x) = TempSeq(Y)
                    
                End If
                NucNum(Y) = 0
                TempSeq(Y) = ""
            End If
        Next Y
    Next x


End If




x = 0

Do
    
    If NucNum(x) = 0 Then
        If x < NextNo Then
            TempSeq(x) = TempSeq(NextNo)
            TempName(x) = TempName(NextNo)
            NucNum(x) = NucNum(NextNo)
            TreeTrace(x) = TreeTrace(NextNo)
            x = x - 1
        End If
        NextNo = NextNo - 1
    End If
    
    x = x + 1
    If x > NextNo Then
        Exit Do
    End If
Loop




Dim Maxnt As Long
XX = PermNextno
If CutShort = 1 Then
    x = 0
    Maxnt = 0
    For x = 0 To NextNo
        If Maxnt < NucNum(x) Then
            Maxnt = NucNum(x)
        End If
        
    Next x
    Do
        
        If NucNum(x) < Maxnt / 3 Then
            If x < NextNo Then
                TempSeq(x) = TempSeq(NextNo)
                TempName(x) = TempName(NextNo)
                NucNum(x) = NucNum(NextNo)
                TreeTrace(x) = TreeTrace(NextNo)
                x = x - 1
            End If
            NextNo = NextNo - 1
        End If
        
        x = x + 1
        If x > NextNo Then
            Exit Do
        End If
    Loop

End If
Dim NameGene As String, ProtName As String


'If Right$(GeneList(Curgene).Product, 1) = "*" Then 'means its a component of a polyprotein
'    Pos = InStr(1, GeneList(Curgene).Product, ":", vbBinaryCompare)
'    If Pos > 1 Then
'       ProtName = Left(GeneList(Curgene).Product, Pos - 1)
'       TTText = "Approximate first codon position of " + ProtName + " cleavage product in " + GeneList(Curgene).Name
'    Else
'        TTText = "Approximate first codon position of " + GeneList(Curgene).Product + " cleavage product"
'    End If
'Else
'    TTText = "Approximate position of " + GeneList(Curgene).Name + " start codon"
'End If

If Right$(GeneList(CurGeneNo).Product, 1) = "*" Then
    NameGene = GeneList(CurGeneNo).Product
    Pos = InStr(1, NameGene, ":", vbBinaryCompare)
    
    'Protname = Left(GeneList(CurGeneNo).Product, Pos - 1)
    If Pos > 0 Then
        ProtName = Left(GeneList(CurGeneNo).Product, Pos - 1)
        NameGene = ProtName + " cleavage product in " + GeneList(CurGeneNo).Name
    Else
        NameGene = ProtName + " cleavage product"
    End If
Else
    If GeneList(CurGeneNo).Name <> "" And GeneList(CurGeneNo).Name <> "" Then
        NameGene = GeneList(CurGeneNo).Name
    ElseIf GeneList(CurGeneNo).Product <> "" And GeneList(CurGeneNo).Product <> " " Then
        NameGene = GeneList(CurGeneNo).Product
        Pos = InStr(1, NameGene, ":", vbBinaryCompare)
        
        'Protname = Left(GeneList(CurGeneNo).Product, Pos - 1)
        If Pos > 0 Then
            ProtName = Left(GeneList(CurGeneNo).Product, Pos - 1)
            NameGene = ProtName + " cleavage product in " + GeneList(CurGeneNo).Name
        Else
            NameGene = ProtName + " cleavage product"
        End If
    Else
        
        NameGene = "gene " + Trim(Str(CurGeneNo))
    End If
End If
If NextNo = -1 Then
    If StripOLFlag = 1 And StripPartFlag = 1 Then
        MsgBox ("There are no codons in " + NameGene + " that are both complete and are not expressed in multiple frames and therefore no alignment was saved for this gene")
        
    ElseIf StripOLFlag = 1 Then
        MsgBox ("There are no codons in " + NameGene + " that are  not expressed in multiple frames and therefore no alignment was saved for this gene")
    ElseIf StripPartFlag = 1 Then
        MsgBox ("There are no codons in " + NameGene + " that are  complete and therefore no alignment was saved for this gene")
    End If
    Call UnModNextno
    Call UnModSeqNum(0)
    RelX = oRelX
    RelY = oRelY
    XX = NextNo
    Exit Sub
End If

'from here on out we only work with tempseq and not geneseq (they no longer match-up)
If GeneList(CurGeneNo).Orientation = 2 Then
    'make the reverse complement
    For x = 0 To NextNo
        TempSeq(x) = ReverseComplement(TempSeq(x))
    Next x
End If


'make sure that the first nt is in frame
'first make a gap-stripped version of the alignment
Dim GapStripped() As Byte, CCode As Byte, LenGapstrip() As Long, FrameX As Long, FrameLengths() As Long
ReDim GapStripped(LenSave + 1, NextNo), LenGapstrip(NextNo), FrameLengths(2, NextNo)

For x = 0 To NextNo
    Z = 0
    For Y = 1 To LenSave
        CCode = Asc(Mid$(TempSeq(x), Y, 1))
        If CCode > 47 Then
            Z = Z + 1
            GapStripped(Z, x) = CCode
        End If
    Next Y
    'GapStripped(X) = Trim(GapStripped(X))
    LenGapstrip(x) = Z
Next x

'EE = abs(gettickcount)
'TT = EE - SS
Form1.ProgressBar1 = 64
'find longest Frame
Dim P1 As Byte, P2 As Byte, P3 As Byte
For x = 0 To NextNo
    For FrameX = 0 To 2
        For Y = 1 + FrameX To LenGapstrip(x) Step 3
            'Look for TAA TAG TGA
            If GapStripped(Y, x) = 84 Then '"T"
                If GapStripped(Y + 1, x) = 65 Then '"A"
                    If GapStripped(Y + 2, x) = 65 Then '"A"
                        Exit For
                    ElseIf GapStripped(Y + 2, x) = 71 Then '"A"
                        Exit For
                    End If
                ElseIf GapStripped(Y + 1, x) = 71 Then '"G"
'                    If Y + 2 > UBound(GapStripped, 1) Then
'                        Exit For
                    If GapStripped(Y + 2, x) = 65 Then '"A"
                        Exit For
                    End If
                End If
            End If
        Next Y
        FrameLengths(FrameX, x) = Y
    Next FrameX
Next x



Dim BestFrame() As Long, BestScore As Long
ReDim BestFrame(NextNo)
For x = 0 To NextNo
    BestScore = 0
    For Y = 0 To 2
        If BestScore < FrameLengths(Y, x) Then
            BestScore = FrameLengths(Y, x)
            BestFrame(x) = Y
        End If
    Next Y
Next x

Dim FirstSite() As Long, NumS As Long
ReDim FirstSite(NextNo, 2)
For x = 0 To NextNo
    NumS = -1
    For Y = 1 To Len(TempSeq(x))
        If Mid$(TempSeq(x), Y, 1) <> "-" Then
            NumS = NumS + 1
            FirstSite(x, NumS) = Y
            If NumS = 2 Then Exit For
        End If
    Next Y
Next x


Dim FrameLen() As Byte
ReDim FrameLen(LenSave)
NumS = 0
For x = 1 To LenSave
    FrameLen(x) = NumS
    NumS = NumS + 1
    If NumS = 3 Then NumS = 0
Next x

Dim RemoveNT As Long

Dim WinFrame(2) As Long
For x = 0 To NextNo
    WinFrame(BestFrame(x)) = WinFrame(BestFrame(x)) + 1
Next x
Dim TotFrame(3) As Long
For x = 0 To NextNo
    For Y = 0 To 2
        TotFrame(FrameLen(FirstSite(x, Y))) = TotFrame(FrameLen(FirstSite(x, Y))) + FrameLengths(Y, x)
    Next Y
Next x

'XX = WinFrame(0)
'XX = WinFrame(1)
'XX = WinFrame(2)

RemoveNT = 0
If TotFrame(2) > TotFrame(1) And TotFrame(2) > TotFrame(0) Then
    For x = 0 To NextNo
        Mid$(TempSeq(x), 1, Len(TempSeq(x)) - 2) = Mid$(TempSeq(x), 3, Len(TempSeq(x)) - 2)
        Mid$(TempSeq(x), Len(TempSeq(x)), 2) = TempSeq(x) + "--"
    Next x
ElseIf TotFrame(1) > TotFrame(2) And TotFrame(1) > TotFrame(0) Then
    For x = 0 To NextNo
        'Left(TempSeq(X), Len(TempSeq(X)) - 1) = Right(TempSeq(X), Len(TempSeq(X)) - 1)
        Mid$(TempSeq(x), 1, Len(TempSeq(x)) - 1) = Mid$(TempSeq(x), 2, Len(TempSeq(x)) - 1)
        Mid$(TempSeq(x), Len(TempSeq(x)), 1) = TempSeq(x) + "-"
    Next x
End If

'For X = 0 To Nextno
'
'    RemoveNT = 0
'    If BestFrame(X) = 2 Then
'        RemoveNT = 1
'    ElseIf BestFrame(X) = 1 Then
'        RemoveNT = 2
'    End If
'
'    If RemoveNT > 0 Then
'        For Y = 1 To LenSave
'            If Asc(Mid$(TempSeq(X), Y, 1)) > 46 Then
'                Mid$(TempSeq(X), Y, 1) = "-"
'                RemoveNT = RemoveNT - 1
'                If RemoveNT = 0 Then Exit For
'            End If
'        Next Y
'        X = X
'    End If
'
'Next X
Dim FirstFlag As Byte
'StripPartFlag = 0
If StripPartFlag = 1 Then
    Dim GapCount(3) As Long, GapTot As Long
    'strip out partial codons (i.e. "fix" partial codons or replace them with gap characters
    
    If x = x Then
        Dim PosBefore() As Byte, StartY As Long, EndY As Long, PosCounter As Long
        ReDim PosBefore(LenSave, NextNo)
        For x = 0 To NextNo
            
            For Y = 1 To LenSave
                If Mid$(TempSeq(0), Y, 1) <> "-" Then
                   StartY = Y
                   Exit For
                End If
                PosBefore(Y, x) = 4
            Next Y
            For Y = LenSave To 1 Step -1
                If Mid$(TempSeq(0), Y, 1) <> "-" Then
                   EndY = Y
                   Exit For
                End If
                PosBefore(Y, x) = 4
            Next Y
            PosCounter = 0
            For Y = StartY To EndY
                If Mid$(TempSeq(0), Y, 1) <> "-" Then
                   PosCounter = PosCounter + 1
                   If PosCounter = 4 Then PosCounter = 1
                   PosBefore(Y, x) = PosCounter
                End If
            Next Y
        Next x
        
        'work out consensus codon coords and gap positions (4 = begin and end gaps, 1,2,3 are codon positions, 0 is a gap)
        Dim ConsensusSites() As Long, SState As Long, CBest As Long, CWin As Long, Cons() As Byte
        ReDim ConsensusSites(LenSave, 4)
        ReDim Cons(LenSave * 3)
        For x = 0 To NextNo
            For Y = 1 To LenSave
                SState = PosBefore(Y, x)
                ConsensusSites(Y, SState) = ConsensusSites(Y, SState) + 1
            Next Y
        
        Next x
        
        For Y = 1 To LenSave
            CBest = 0
            CWin = 4
            For x = 1 To 3
                If ConsensusSites(Y, x) > CBest Then
                    CBest = ConsensusSites(Y, x)
                    CWin = x
                End If
                If CWin = 4 Then
                    If ConsensusSites(Y, 0) > 0 Then
                        CWin = 0
                    End If
                End If
            Next x
            Cons(Y) = CWin
        Next Y
        'make sure that the consensus"1"s all start on the first position
        Dim RunT As Long
        RunT = 0
        Y = 1
        Do While Y < LenSave - 2
            RunT = RunT + 1
            If RunT = 4 Then RunT = 1
            If Cons(Y) <> RunT And Cons(Y) <> 4 Then
                If Cons(Y) = 0 Then
                    If RunT = 1 Then
                        If Cons(Y + 1) = 1 Then
                            Call AddGaps(Y + 1, NextNo, Cons(), TempSeq(), 2, LenSave)
                        ElseIf Cons(Y + 2) = 1 Then
                            Call AddGaps(Y + 2, NextNo, Cons(), TempSeq(), 1, LenSave)
                        End If
                    ElseIf RunT = 2 Then
                        If Cons(Y + 1) = 2 Then
                            Call AddGaps(Y + 1, NextNo, Cons(), TempSeq(), 2, LenSave)
                        ElseIf Cons(Y + 2) = 2 Then
                            Call AddGaps(Y + 2, NextNo, Cons(), TempSeq(), 1, LenSave)
                        End If
                    ElseIf RunT = 3 Then
                        If Cons(Y + 1) = 3 Then
                            Call AddGaps(Y + 1, NextNo, Cons(), TempSeq(), 2, LenSave)
                        ElseIf Cons(Y + 2) = 3 Then
                            Call AddGaps(Y + 2, NextNo, Cons(), TempSeq(), 1, LenSave)
                        End If
                    End If
                ElseIf Cons(Y) = 1 Then
                    If RunT = 2 Then
                        Call AddGaps(Y, NextNo, Cons(), TempSeq(), 2, LenSave)
                    ElseIf RunT = 3 Then
                        Call AddGaps(Y, NextNo, Cons(), TempSeq(), 1, LenSave)
                    End If
                ElseIf Cons(Y) = 2 Then
                    If RunT = 1 Then
                        Call AddGaps(Y, NextNo, Cons(), TempSeq(), 1, LenSave)
                    ElseIf RunT = 3 Then
                        Call AddGaps(Y, NextNo, Cons(), TempSeq(), 2, LenSave)
                    End If
                
                ElseIf Cons(Y) = 3 Then
                    If RunT = 1 Then
                        Call AddGaps(Y, NextNo, Cons(), TempSeq(), 2, LenSave)
                    ElseIf RunT = 2 Then
                        Call AddGaps(Y, NextNo, Cons(), TempSeq(), 1, LenSave)
                    End If
                End If
            End If
            Y = Y + 1
        Loop
        
        
        
    Else
        For x = 0 To NextNo
            FirstFlag = 0
            For Y = 1 To LenSave - 2 Step 3
                
                'count the gaps
'                XX = Mid$(TempSeq(X), Y, 1)
'                YY = Mid$(TempSeq(X), Y + 1, 1)
'                ZZ = Mid$(TempSeq(X), Y + 2, 1)
                GapCount(1) = 0: GapCount(2) = 0: GapCount(3) = 0
                If Mid$(TempSeq(x), Y, 1) = "-" Then
                    GapCount(1) = 1
                End If
                If Mid$(TempSeq(x), Y + 1, 1) = "-" Then
                    GapCount(2) = 1
                End If
                If Mid$(TempSeq(x), Y + 2, 1) = "-" Then
                    GapCount(3) = 1
                End If
                GapTot = GapCount(1) + GapCount(2) + GapCount(3)
                If GapTot > 0 And GapTot < 3 Then
                    If FirstFlag = 0 Then
                        Mid$(TempSeq(x), Y, 3) = "---"
                        FirstFlag = 1
                    Else
                        If GapCount(1) = 1 And GapCount(2) = 0 And GapCount(3) = 0 Then
                            If Y + 3 < LenSave Then
                                If Mid$(TempSeq(x), Y + 3, 2) = "--" Then
                                    Mid$(TempSeq(x), Y + 3, 1) = Mid$(TempSeq(x), Y + 1, 1)
                                    Mid$(TempSeq(x), Y + 4, 1) = Mid$(TempSeq(x), Y + 2, 1)
                                    Mid$(TempSeq(x), Y, 3) = "---"
                                Else
                                    Mid$(TempSeq(x), Y, 1) = Mid$(TempSeq(x), Y + 1, 1)
                                    Mid$(TempSeq(x), Y + 1, 1) = Mid$(TempSeq(x), Y + 2, 1)
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Y + 3, 1)
                                    Mid$(TempSeq(x), Y + 3, 1) = "-"
                                    Y = Y - 3
                                End If
                            End If
                        ElseIf GapCount(1) = 0 And GapCount(2) = 1 And GapCount(3) = 0 Then
                            If Y + 3 < LenSave Then
                                If Mid$(TempSeq(x), Y + 3, 2) = "--" Then
                                    Mid$(TempSeq(x), Y + 3, 1) = Mid$(TempSeq(x), Y, 1)
                                    Mid$(TempSeq(x), Y + 4, 1) = Mid$(TempSeq(x), Y + 2, 1)
                                    Mid$(TempSeq(x), Y, 3) = "---"
                                Else
                                    
                                    Mid$(TempSeq(x), Y + 1, 1) = Mid$(TempSeq(x), Y + 2, 1)
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Y + 3, 1)
                                    Mid$(TempSeq(x), Y + 3, 1) = "-"
                                    Y = Y - 3
                                End If
                            End If
                        ElseIf GapCount(1) = 0 And GapCount(2) = 0 And GapCount(3) = 1 Then
                            If Y + 3 < LenSave Then
                                If Mid$(TempSeq(x), Y + 3, 2) = "--" Then
                                    Mid$(TempSeq(x), Y + 3, 1) = Mid$(TempSeq(x), Y, 1)
                                    Mid$(TempSeq(x), Y + 4, 1) = Mid$(TempSeq(x), Y + 1, 1)
                                    Mid$(TempSeq(x), Y, 3) = "---"
                                ElseIf Mid$(TempSeq(x), Y + 3, 1) <> "-" Then
                                    
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Y + 3, 1)
                                    Mid$(TempSeq(x), Y + 3, 1) = "-"
                                    
                                Else
                                    'find next non-gap site
                                    Z = Y + 4
                                    Do While Z <= LenSave
                                        If Mid$(TempSeq(x), Z, 1) <> "-" Then
                                            Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Z, 1)
                                             Mid$(TempSeq(x), Z, 1) = "-"
                                            Exit Do
                                        End If
                                        Z = Z + 1
                                    Loop
                                    
                                End If
                            End If
                        ElseIf GapCount(1) = 1 And GapCount(2) = 1 And GapCount(3) = 0 Then
                            If Y + 2 < LenSave Then
                                If Mid$(TempSeq(x), Y + 3, 2) = "-" Then
                                    Mid$(TempSeq(x), Y + 3, 1) = Mid$(TempSeq(x), Y + 2, 1)
                                    Mid$(TempSeq(x), Y, 3) = "---"
                                Else
                                    'XX = Mid$(TempSeq(X), Y, 10)
                                    Mid$(TempSeq(x), Y, 1) = Mid$(TempSeq(x), Y + 2, 1)
                                    Mid$(TempSeq(x), Y + 1, 1) = Mid$(TempSeq(x), Y + 3, 1)
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Y + 4, 1)
                                    Mid$(TempSeq(x), Y + 3, 2) = "--"
                                    'YY = Mid$(TempSeq(X), Y, 10)
                                    
                                    Y = Y - 3
                                End If
                            End If
                        ElseIf GapCount(1) = 1 And GapCount(2) = 0 And GapCount(3) = 1 Then
                            If Y + 2 < LenSave Then
                                If Mid$(TempSeq(x), Y + 3, 2) = "-" Then
                                    Mid$(TempSeq(x), Y + 3, 1) = Mid$(TempSeq(x), Y + 1, 1)
                                    Mid$(TempSeq(x), Y, 3) = "---"
                                Else
                                    Mid$(TempSeq(x), Y, 1) = Mid$(TempSeq(x), Y + 1, 1)
                                    Mid$(TempSeq(x), Y + 1, 1) = Mid$(TempSeq(x), Y + 3, 1)
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Y + 4, 1)
                                    Mid$(TempSeq(x), Y + 3, 2) = "--"
                                    Y = Y - 3
                                End If
                            End If
                        ElseIf GapCount(1) = 0 And GapCount(2) = 1 And GapCount(3) = 1 Then
                            If Y + 2 < LenSave Then
                                If Mid$(TempSeq(x), Y + 3, 2) = "-" Then
                                    Mid$(TempSeq(x), Y + 3, 1) = Mid$(TempSeq(x), Y, 1)
                                    Mid$(TempSeq(x), Y, 3) = "---"
                                ElseIf Mid$(TempSeq(x), Y + 3, 2) <> "--" Then
                                    Mid$(TempSeq(x), Y + 1, 1) = Mid$(TempSeq(x), Y + 3, 1)
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Y + 4, 1)
                                    Mid$(TempSeq(x), Y + 3, 2) = "--"
                                    Y = Y - 3
                                Else
                                    Z = Y + 4
                                    Do While Z <= LenSave - 1
                                        If Mid$(TempSeq(x), Z, 1) <> "-" Then
                                            Mid$(TempSeq(x), Y + 1, 2) = Mid$(TempSeq(x), Z, 2)
                                            Mid$(TempSeq(x), Z, 2) = "--"
                                            Exit Do
                                        End If
                                        Z = Z + 1
                                    Loop
                                End If
                            End If
                        End If
                    End If
                End If
            Next Y
        Next x
    End If
    
    
    
'    EE = abs(gettickcount)
'    TT = EE - SS '266
    
    'rejoin separated codons and erase partial codons
    
    'rejoins
    Form1.ProgressBar1 = 71
    LenSave = Len(TempSeq(0))
    
    'If X = 12345 Then
    For x = 0 To NextNo '63,346
        For Y = 1 To LenSave - 2 Step 3
            If x = 1 And Y = 346 Then
                x = x
            End If
            XX = Mid$(TempSeq(x), Y, 1)
            Yy = Mid$(TempSeq(x), Y + 1, 1)
            ZZ = Mid$(TempSeq(x), Y + 2, 1)
            If Mid$(TempSeq(x), Y, 1) <> "-" Then
                If Mid$(TempSeq(x), Y + 1, 1) = "-" Then
                    If Mid$(TempSeq(x), Y + 2, 1) = "-" Then
                        'find the next nongap and check if its a pos2
                        For Z = Y + 3 To LenSave
                            If Mid$(TempSeq(x), Z, 1) <> "-" Then
                                If Cons(Z) = 2 Then
                                    Mid$(TempSeq(x), Z - 1, 1) = Mid$(TempSeq(x), Y, 1)
                                    Mid$(TempSeq(x), Y, 1) = "-"
                                End If
                                Exit For
                            End If
                        Next Z
                    Else
                        Mid$(TempSeq(x), Y, 3) = "---"
                    End If
                Else 'second position is not a gap either
                    'If the third position is a gap then try to find a position three to join
                    If Mid$(TempSeq(x), Y + 2, 1) = "-" Then
                        For Z = Y + 3 To LenSave
                            If Mid$(TempSeq(x), Z, 1) <> "-" Then
                                If Cons(Z) = 3 Then
                                    Mid$(TempSeq(x), Y + 2, 1) = Mid$(TempSeq(x), Z, 1)
                                    Mid$(TempSeq(x), Z, 1) = "-"
                                End If
                                Exit For
                            End If
                        Next Z
                    
                        
                    End If
                  
                End If
                
            Else 'first codon position is "-" - if second or third at not gaps then erase these
                If Mid$(TempSeq(x), Y + 1, 1) <> "-" Then
                    Mid$(TempSeq(x), Y + 1, 2) = "--"
                ElseIf Mid$(TempSeq(x), Y + 2, 1) <> "-" Then
                    Mid$(TempSeq(x), Y + 1, 2) = "--"
                End If
            End If
        Next Y
    Next x
    'End If
'    'erases
'    For X = 0 To Nextno
'        For Y = 1 To LenSave - 2 Step 3
'            If Mid$(TempSeq(X), Y, 1) = "-" Then
'        Next Y
'    Next X
    
    'strip out stop codons
    For x = 0 To NextNo
        For Y = 1 To LenSave - 2 Step 3
            If Mid(TempSeq(x), Y, 1) = "T" Then
                If Mid(TempSeq(x), Y + 1, 1) = "A" Then '"A"
                    If Mid(TempSeq(x), Y + 2, 1) = "A" Then '"A"
                        Mid$(TempSeq(x), Y, 3) = "---"
                    ElseIf Mid(TempSeq(x), Y + 2, 1) = "G" Then
                        Mid$(TempSeq(x), Y, 3) = "---"
                    End If
                ElseIf Mid(TempSeq(x), Y + 1, 1) = "G" Then
                    If Mid(TempSeq(x), Y + 2, 1) = "A" Then '"A"
                        Mid$(TempSeq(x), Y, 3) = "---"
                    End If
                End If
            End If
        Next Y
    Next x
    
End If




Dim Char1 As String, Char2 As String, Char3 As String


If StripPartFlag = 1 Then



    For x = 0 To NextNo
        'replace partial codons with gaps
        For Y = 1 To LenSave - 2 Step 3
            Char1 = Mid$(TempSeq(x), Y, 1)
            Char2 = Mid$(TempSeq(x), Y + 1, 1)
            Char3 = Mid$(TempSeq(x), Y + 2, 1)
            If Char1 = "N" Or Char2 = "N" Or Char3 = "N" Then
                Mid$(TempSeq(x), Y, 3) = "---"
           
            
            End If
            Char1 = Mid$(TempSeq(x), Y, 1)
            Char2 = Mid$(TempSeq(x), Y + 1, 1)
            Char3 = Mid$(TempSeq(x), Y + 2, 1)
            If Char1 = "-" Or Char2 = "-" Or Char3 = "-" Then
                Mid$(TempSeq(x), Y, 3) = "---"
           
            
            End If
        Next Y
        'finish off the ends
        For Y = LenSave - 2 To LenSave
            If Mid$(TempSeq(x), Y, 1) = "N" Then
                Mid$(TempSeq(x), Y, 1) = "-"
            End If
        Next Y
    Next x


Else
    For x = 0 To NextNo
    
        For Y = 1 To LenSave
            If Mid$(TempSeq(x), Y, 1) = "N" Then
                Mid$(TempSeq(x), Y, 1) = "-"
            
            End If
        Next Y
    Next x
End If


'EE = abs(gettickcount)
'TT = EE - SS '609

Form1.ProgressBar1 = 84
'remove columns where there are fewer than 3 sequences that have nts
Dim Numnts() As Long, LTS As Long
ReDim Numnts(LenSave)
For x = 0 To NextNo
    For Y = 1 To LenSave
        Char1 = Mid$(TempSeq(x), Y, 1)
        If Char1 <> "N" And Char1 <> "-" Then
            Numnts(Y) = Numnts(Y) + 1
        End If
    Next Y

Next x

Form1.ProgressBar1 = 85

'EE = abs(gettickcount)
'TT = EE - SS '219
Dim TSX As String
For Y = LenSave To 1 Step -1
    If Numnts(Y) < 3 Then
        
        LTS = Len(TempSeq(0))
        For x = 0 To NextNo
            
            If Y < LTS And Y > 1 Then
                TSX = String(LTS, "-")
                Mid$(TSX, 1, Y - 1) = Left$(TempSeq(x), Y - 1)
                Mid$(TSX, Y, LTS - 1) = Mid$(TempSeq(x), Y + 1, LTS)
                TempSeq(x) = TSX
                'TempSeq(x) = Left$(TempSeq(x), Y - 1) + Mid$(TempSeq(x), Y + 1, LTS)
            ElseIf Y < LTS Then
                TempSeq(x) = Mid$(TempSeq(x), Y + 1, LTS)
            ElseIf Y > 1 Then
                TempSeq(x) = Left$(TempSeq(x), Y - 1)
            End If
        Next x
    End If
Next Y




'remove empty sequences
x = 0
Do While x <= NextNo '162,222,249
'    If X = 222 Then
'        X = X
'    End If
    GoOn = 1
    For Y = 1 To LenSave
        Char1 = Mid$(TempSeq(x), Y, 1)
        If Char1 <> "N" And Char1 <> "-" Then
            'Mid$(TempSeq(X), Y, 1) = "-"
            GoOn = 0
            Exit For
        End If
    Next Y
    If GoOn = 1 Then 'remove the sequences
        If x < NextNo Then
            TempSeq(x) = TempSeq(NextNo)
            TempName(x) = TempName(NextNo)
            x = x - 1
        End If
        NextNo = NextNo - 1
        
    End If
    
    x = x + 1
Loop




If StripDuplicates = 0 Then
    Dim ExtraTS As String, ExtraNS As String, CurNum
    'reorder them so that they occur in groups (also add numbers to their names so that names are unique
    For x = 0 To NextNo - 1
'        Pos = InStr(1, TempName(X), "BR025", vbBinaryCompare)
'        If Pos > 0 Then
'            X = X
'        End If
        CurNum = 1
        For Y = x + 1 To NextNo '8,323,409
'            Pos = InStr(1, TempName(Y), "BR025", vbBinaryCompare)
'            If Pos > 0 Then
'                X = X
'            End If
            If TempName(x) = TempName(Y) Then
                
                CurNum = CurNum + 1
                ExtraTS = TempSeq(x + CurNum - 1)
                ExtraNS = TempName(x + CurNum - 1)
                TempSeq(x + CurNum - 1) = TempSeq(Y)
                TempName(x + CurNum - 1) = TempName(Y) + "-" + Trim(Str(CurNum))
                TempSeq(Y) = ExtraTS
                TempName(Y) = ExtraNS
            End If
            
        Next Y
        If CurNum > 1 Then
            TempName(x) = TempName(x) + "-1"
        End If
        x = x + CurNum - 1
    Next x


End If



EE = Abs(GetTickCount)
TT = EE - SS '500
'4123
Form1.ProgressBar1 = 100
Call WriteSequences(NextNo, AName, TempName(), TempSeq(), 0)

Call UnModNextno
Call UnModSeqNum(0)
XX = NextNo
RelX = oRelX
RelY = oRelY
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
End Sub
Public Sub AddGaps(PosGap, NextNo As Long, Cons() As Byte, TempSeq() As String, LenGap, LenSave)
Dim x As Long
For x = 0 To NextNo
    TempSeq(x) = Left$(TempSeq(x), PosGap - 1) + String(LenGap, "-") + Right$(TempSeq(x), Len(TempSeq(x)) - PosGap + 1)
    'XX = Len(TempSeq(X))
Next x
XX = Cons(PosGap)
XX = Cons(PosGap + 1)
XX = Cons(PosGap + 2)
XX = Cons(PosGap + 3)


For x = LenSave To PosGap Step -1
    Cons(x + LenGap) = Cons(x)
Next x
For x = 0 To LenGap - 1
    Cons(PosGap + x) = 0
Next x
LenSave = LenSave + LenGap
x = x
End Sub

Public Function ReverseComplement(InSeq As String) As String
Dim x As Long, outSeq As String, Conv() As Byte, Y As Long
outSeq = String(Len(InSeq), " ")
ReDim Conv(255)
Conv(Asc("A")) = Asc("T")
Conv(Asc("C")) = Asc("G")
Conv(Asc("G")) = Asc("C")
Conv(Asc("T")) = Asc("A")
Conv(Asc(" ")) = Asc("-")
Conv(Asc("-")) = Asc("-")
Y = 0
For x = Len(InSeq) To 1 Step -1
   Y = Y + 1
   Mid(outSeq, Y, 1) = Chr(Conv(Asc(Mid(InSeq, x, 1))))
Next x

ReverseComplement = outSeq
End Function
Public Sub FindGCContent(SeqNum() As Integer, GCContent() As Single, WindowSize As Long)
Dim x As Long, Y As Long, LSeq As Long, NucMat(100) As Long, HWinSize As Long
Dim WinSize As Long, SubValid() As Single, SubTot() As Single, AllSeqs As Long

Call UnModNextno
Call UnModSeqNum(0)
AllSeqs = PermNextno + 1
LSeq = Len(StrainSeq(0))
WinSize = WindowSize

ReDim SubValid(LSeq), SubTot(LSeq)

For x = 1 To LSeq
    SubValid(x) = AllSeqs
Next x


For x = 0 To PermNextno
    For Z = 1 To LSeq
        If SeqNum(Z, x) = 68 Or SeqNum(Z, x) = 72 Then
            SubTot(Z) = SubTot(Z) + 1
        ElseIf SeqNum(Z, x) = 46 Then
            SubValid(Z) = SubValid(Z) - 1
        End If
    Next Z
Next x

For x = 1 To LSeq
    If SubValid(x) > 0 Then
        SubTot(x) = SubTot(x) / SubValid(x)
    Else
        SubTot(x) = 0
    End If
Next x

If WinSize >= LSeq Then WinSize = LSeq - 1
HWinSize = WinSize / 2

ReDim GCContent(LSeq)
'do first window
If HWinSize > LSeq Then HWinSize = LSeq - 1
For x = -HWinSize + 1 To HWinSize
    If x < 1 Then
        Z = LSeq + x
    Else
        Z = x
    End If
    GCContent(1) = GCContent(1) + SubTot(Z)
Next x

For x = 2 To LSeq
    Y = x - HWinSize + 1
    If Y < 1 Then
        Z = LSeq + Y
    Else
        Z = Y
    End If
    GCContent(x) = GCContent(x - 1) - SubTot(Z)
    Y = x + HWinSize
    If Y > LSeq Then
        Z = Y - LSeq
    Else
        Z = Y
    End If
    GCContent(x) = GCContent(x) + SubTot(Z)
Next x


For x = 1 To LSeq
    GCContent(x) = GCContent(x) / WinSize
Next x




MaxGCContent = -1000000
MinGCContent = 1000000
For x = 1 To LSeq
    
    If GCContent(x) > MaxGCContent Then
        MaxGCContent = GCContent(x)
    ElseIf GCContent(x) < MinGCContent Then
        MinGCContent = GCContent(x)
    End If

Next 'X


End Sub


Public Sub SaveUndo()
Dim oDir As String, FF As Long, FileName As String
'MaxUndos As Long, UndoCycle As Long, UndoSlot As Long

Call UnModSeqNum(0)
Call UnModNextno

UndoSlot = UndoSlot + 1
If UndoSlot > MaxUndos Then
    UndoSlot = 1
    UndoCycle = UndoCycle + 1
End If
LatestSlot = UndoSlot

oDir = CurDir
ChDrive App.Path
ChDir App.Path

FF = FreeFile
FileName = "UndoSlot" + Trim(Str(UndoSlot)) + UFTag
Open FileName For Binary As #FF

'save recombinationInfo
ReDim Preserve CurrentXOver(PermNextno)
Put #FF, , CurrentXOver()
UB1 = UBound(XoverList, 1)
UB2 = UBound(XoverList, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , XoverList

Put #FF, , XOMiMaInFileFlag
If XOMiMaInFileFlag = 1 Then
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    ReDim BestXOListMi(PermNextno, UBXOMi)
    If MiRec < 1 Then
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF2
        Get #FF2, , BestXOListMi()
        Close #FF2
        MiRec = 1
    End If
    ChDrive oDir
    ChDir oDir
End If

ReDim Preserve BCurrentXoverMi(PermNextno)
Put #FF, , BCurrentXoverMi()
Dim BiggestX As Long
BiggestX = 0
For x = 0 To PermNextno
    If BiggestX < BCurrentXoverMi(x) Then BiggestX = BCurrentXoverMi(x)
Next x
If BiggestX + 1 < UBound(BestXOListMi, 2) Then
    ReDim Preserve BestXOListMi(UBound(BestXOListMi, 1), BiggestX + 1)
End If

UB1 = UBound(BestXOListMi, 1)
UB2 = UBound(BestXOListMi, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , BestXOListMi()

If XOMiMaInFileFlag = 1 Then
    Erase BestXOListMi
    MiRec = MiRec - 1
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    ReDim BestXOListMa(PermNextno, UBXoMa)
    If MaRec < 1 Then
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF2
        Get #FF2, , BestXOListMa()
        Close #FF2
        MaRec = 1
    End If
    ChDrive oDir
    ChDir oDir
    
End If

ReDim Preserve BCurrentXoverMa(PermNextno)

BiggestX = 0
For x = 0 To PermNextno
    If BiggestX < BCurrentXoverMa(x) Then BiggestX = BCurrentXoverMa(x)
Next x
If BiggestX + 1 < UBound(BestXOListMa, 2) Then
    ReDim Preserve BestXOListMa(UBound(BestXOListMa, 1), BiggestX + 1)
End If

Put #FF, , BCurrentXoverMa()
UB1 = UBound(BestXOListMa, 1)
UB2 = UBound(BestXOListMa, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , BestXOListMa()


If XOMiMaInFileFlag = 1 Then
    Erase BestXOListMa
    MaRec = MaRec - 1
End If

If DebuggingFlag < 2 Then On Error Resume Next
UB2 = -1
UB1 = -1
UB1 = UBound(NOPINI, 1)
UB2 = UBound(NOPINI, 2)
On Error GoTo 0

Put #FF, , UB1
Put #FF, , UB2
If UB2 > -1 Then
    Put #FF, , SEventNumber
    Put #FF, , Eventnumber
    Put #FF, , NOPINI()
End If

UB1 = UBound(DScores, 1)
UB2 = UBound(DScores, 2)
UB3 = UBound(DScores, 3)

Put #FF, , UB1
Put #FF, , UB2
Put #FF, , UB3

Put #FF, , DScores()


UB1 = UBound(SuperEventList, 1)
Put #FF, , UB1
Put #FF, , SuperEventList()

UB1 = UBound(Daught, 1)
UB2 = UBound(Daught, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , Daught()

UB1 = UBound(MinorPar, 1)
UB2 = UBound(MinorPar, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , MinorPar()

UB1 = UBound(MajorPar, 1)
UB2 = UBound(MajorPar, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , MajorPar()

UB1 = UBound(BestEvent, 1)
UB2 = UBound(BestEvent, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , BestEvent()

UB1 = UBound(Confirm, 1)
UB2 = UBound(Confirm, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , Confirm()

UB1 = UBound(ConfirmP, 1)
UB2 = UBound(ConfirmP, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmP()

UB1 = UBound(ConfirmMi, 1)
UB2 = UBound(ConfirmMi, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmMi()

UB1 = UBound(ConfirmPMi, 1)
UB2 = UBound(ConfirmPMi, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmPMi()

UB1 = UBound(ConfirmMa, 1)
UB2 = UBound(ConfirmMa, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmMa()

UB1 = UBound(ConfirmPMa, 1)
UB2 = UBound(ConfirmPMa, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , ConfirmPMa()

Put #FF, , StepNo
UB1 = UBound(Steps, 1)
UB2 = UBound(Steps, 2)
Put #FF, , UB1
Put #FF, , UB2
Put #FF, , Steps()


UB1 = UBound(BPCIs, 1)
UB2 = UBound(BPCIs, 2)
Put #FF, , UB1
Put #FF, , UB2

Put #FF, , BPCIs()

Put #FF, , RelX
Put #FF, , RelY
Put #FF, , PermXVal
Put #FF, , PermYVal

Close #FF

ChDrive oDir
ChDir oDir

End Sub
Public Sub DoUndo()
Dim OMP As Long
OMP = Screen.MousePointer
Form1.SSPanel1.Caption = "Undoing last change"
Screen.MousePointer = 11
Call UpdateF2Prog
Form1.WindowState = Form1.WindowState

Dim oDir As String, FF As Long, FileName As String
'UndoCycle As Long, UndoSlot As Long

Call UnModSeqNum(0)
Call UnModNextno

oDir = CurDir
ChDrive App.Path
ChDir App.Path

FF = FreeFile
FileName = "UndoSlot" + Trim(Str(UndoSlot)) + UFTag
Open FileName For Binary As #FF

ReDim CurrentXOver(NextNo)
Get #FF, , CurrentXOver()

Get #FF, , UB1
Get #FF, , UB2
ReDim XoverList(UB1, UB2)
Get #FF, , XoverList

Get #FF, , XOMiMaInFileFlag

ReDim BCurrentXoverMi(NextNo)
Get #FF, , BCurrentXoverMi()
Get #FF, , UB1
Get #FF, , UB2
ReDim BestXOListMi(UB1, UB2)

'@
Get #FF, , BestXOListMi()
MiRec = 1

If XOMiMaInFileFlag = 1 Then
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    
    Open "RDP5BestXOListMi" + UFTag For Binary As #FF2
    Put #FF2, , BestXOListMi()
    Close #FF2
    
    MiRec = MiRec - 1
    ChDrive oDir
    ChDir oDir
    
    Erase BestXOListMi
End If

ReDim BCurrentXoverMa(NextNo)
Get #FF, , BCurrentXoverMa()
Get #FF, , UB1
Get #FF, , UB2
ReDim BestXOListMa(UB1, UB2)
Get #FF, , BestXOListMa()
MaRec = 1
If XOMiMaInFileFlag = 1 Then
    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF2 = FreeFile
    Open "RDP5BestXOListMa" + UFTag For Binary As #FF2
    Put #FF2, , BestXOListMa()
    MaRec = MaRec - 1
    Close #FF2
    ChDrive oDir
    ChDir oDir
    Erase BestXOListMa
End If


Get #FF, , UB1
Get #FF, , UB2
If UB1 > -1 And UB2 > -1 Then
    ReDim NOPINI(UB1, UB2)
    Get #FF, , SEventNumber
    Get #FF, , Eventnumber
    Get #FF, , NOPINI()
    If UBound(NOPINI, 1) = 0 Then
        ReDim NOPINI(2, 0)
    End If
    
End If

Get #FF, , UB1
Get #FF, , UB2
Get #FF, , UB3

ReDim DScores(UB1, UB2, UB3)
Get #FF, , DScores()


Get #FF, , UB1
ReDim SuperEventList(UB1)
Get #FF, , SuperEventList()

Get #FF, , UB1
Get #FF, , UB2
ReDim Daught(UB1, UB2)
Get #FF, , Daught()


Get #FF, , UB1
Get #FF, , UB2
ReDim MinorPar(UB1, UB2)
Get #FF, , MinorPar()


Get #FF, , UB1
Get #FF, , UB2
ReDim MajorPar(UB1, UB2)
Get #FF, , MajorPar()


Get #FF, , UB1
Get #FF, , UB2
ReDim BestEvent(UB1, UB2)
Get #FF, , BestEvent()


Get #FF, , UB1
Get #FF, , UB2
ReDim Confirm(UB1, UB2)
Get #FF, , Confirm()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmP(UB1, UB2)
Get #FF, , ConfirmP()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmMi(UB1, UB2)
Get #FF, , ConfirmMi()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmPMi(UB1, UB2)
Get #FF, , ConfirmPMi()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmMa(UB1, UB2)
Get #FF, , ConfirmMa()


Get #FF, , UB1
Get #FF, , UB2
ReDim ConfirmPMa(UB1, UB2)
Get #FF, , ConfirmPMa()

Get #FF, , StepNo

Get #FF, , UB1
Get #FF, , UB2
ReDim Steps(UB1, UB2)
Get #FF, , Steps()

Get #FF, , UB1
Get #FF, , UB2
ReDim BPCIs(UB1, UB2)
Get #FF, , BPCIs()

Get #FF, , RelX
Get #FF, , RelY
Get #FF, , PermXVal
Get #FF, , PermYVal



Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())

Call IntegrateXOvers(0)

If RelX > 0 Or RelY > 0 Then
    Call GoToThis2(1, RelX, RelY, PermXVal, PermYVal)
End If

Close #FF

Form1.Enabled = True

ChDrive oDir
ChDir oDir

Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
Screen.MousePointer = OMP
End Sub



Public Sub TajimasD2(SeqNum() As Integer, TajD() As Single, WinSize As Long)
Dim x As Long, Y As Long, LSeq As Long, Z As Long, NucMat(255) As Long, TVal() As Long, nt As Byte, HWinSize  As Long, SubTot() As Long, TotalPairs As Long, k() As Single
LSeq = Len(StrainSeq(0))

NucMat(66) = 1
NucMat(68) = 2
NucMat(72) = 3
NucMat(85) = 4
NucMat(46) = 5
If WinSize >= LSeq Then WinSize = LSeq - 1
HWinSize = WinSize / 2
TotalPairs = ((NextNo + 1) * NextNo) / 2

ReDim TVal(LSeq, 5)
For x = 0 To NextNo - 1
    'For Y = X + 1 To Nextno
        For Z = 1 To LSeq
            nt = NucMat(SeqNum(Z, x))
            TVal(Z, nt) = TVal(Z, nt) + 1
        Next Z
    'Next Y
Next x

Dim TopX() As Long


ReDim SubTot(LSeq), TopX(LSeq), k(LSeq)
For x = 1 To LSeq
    SubTot(x) = 0
    For Y = 1 To 4
        For Z = Y + 1 To 5
            SubTot(x) = SubTot(x) + TVal(x, Y) * TVal(x, Z)
        Next Z
        
    Next Y
    
Next x

'do first window
For x = -HWinSize + 1 To HWinSize
    If x < 1 Then
        Y = x + LSeq
    Else
        Y = Z
    End If
    k(1) = k(1) + SubTot(Y)
    If SubTot(Y) > 0 Then
        TopX(1) = TopX(1) + 1
    End If
Next x

For x = 2 To LSeq
    Z = x - HWinSize + 1
    If Z < 1 Then
        Z = LSeq + Z
    End If
    k(x) = k(x - 1) - SubTot(Z)
    If SubTot(Z) > 0 Then
        TopX(x) = TopX(x - 1) - 1
    Else
        TopX(x) = TopX(x - 1)
    End If
    
    Z = x + HWinSize
    If Z > LSeq Then
        Z = Z - LSeq
    End If
    k(x) = k(x) + SubTot(Z)
    If SubTot(Z) > 0 Then
        TopX(x) = TopX(x) + 1
    End If
    x = x
    
    
Next x
'Dim TajD() As Single
ReDim TajD(LSeq)
For x = 1 To LSeq
    TajD(x) = k(x) / TotalPairs
    'X = X
Next x

Dim BottomX As Double
For x = 1 To NextNo
    BottomX = BottomX + 1 / x
Next x


For x = 1 To LSeq
    TajD(x) = TajD(x) - TopX(x) / BottomX
    'X = X
Next x

MaxTajD = -1000000
MinTajD = 1000000
For x = 1 To LSeq
    
    If TajD(x) > MaxTajD Then
        MaxTajD = TajD(x)
    ElseIf TajD(x) < MinTajD Then
        MinTajD = TajD(x)
    End If

Next 'X

End Sub

Public Sub TajimasD(SeqNum() As Integer, Tajima() As Single, WinSize As Long)
Dim x As Long, Y As Long, k() As Single, TVal As Long, HWinSize  As Long, A As Long, LSeq As Long, TotalPairs As Long

LSeq = Len(StrainSeq(0))
TotalPairs = ((NextNo + 1) * NextNo) / 2
If WinSize > LSeq Then WinSize = LSeq - 1
ReDim Tajima(LSeq), k(LSeq)
HWinSize = WinSize / 2
'Do First Window
TVal = 0
For x = 0 To NextNo - 1
    For Y = x + 1 To NextNo
        For Z = -HWinSize + 1 To 0
            
            A = LSeq + Z
            
            If SeqNum(A, x) <> SeqNum(A, Y) Then
                TVal = TVal + 1
            End If
        Next Z
    Next Y
Next x

For x = 0 To NextNo - 1
    For Y = x + 1 To NextNo
        For Z = 1 To HWinSize
            
            If SeqNum(Z, x) <> SeqNum(Z, Y) Then
                TVal = TVal + 1
            End If
        Next Z
    Next Y
Next x


k(1) = TVal / TotalPairs


For Z = 2 To LSeq
    
    A = Z - HWindowWidth + 1
    If A < 1 Then
        A = LSeq + A
    End If
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            If SeqNum(A, x) <> SeqNum(A, Y) Then
                TVal = TVal - 1
            End If
        Next Y
    Next x
    
    A = Z + HWindowWidth
    If A > LSeq Then
        A = A - LSeq
    End If
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            If SeqNum(A, x) <> SeqNum(A, Y) Then
                TVal = TVal + 1
            End If
        Next Y
    Next x
    k(Z) = TVal / TotalPairs
Next Z


End Sub
Public Sub CalcttyfAdjust(TYFM As Integer, tTYF As Double, FirstSeq As Long, SeqSpaceIncrement As Long)
Dim x As Long, Y1 As Long, Y2 As Long

For x = StartX To NumSeqLines - 1
    If SeqLines(0, x) <> 0 Then
        FirstSeq = x
        Y1 = (SeqLines(3, x) - TYFM) * tTYF - AdjVSVModY
        'If Y1 > -30 And Y1 < Targ Then
            Y2 = (SeqLines(3, x + 1) - TYFM) * tTYF - AdjVSVModY
            SeqSpaceIncrement = Y2 - Y1
            Exit For
        'End If
    End If
Next x


For x = NumSeqLines - 1 To StartX Step -1
    If SeqLines(0, x) <> 0 Then
        
        Y2 = (SeqLines(3, x) - TYFM) * tTYF '- AdjVSVModY 'this is the max unmodded position
        
        Y1 = (SeqLines(3, FirstSeq) - TYFM) * tTYF '- AdjVSVModY 'VSV - ModYV 'yposition
        Y1 = Y1 + (x - FirstSeq) * SeqSpaceIncrement 'this is the maxmodded position
        
        x = x
        If Y2 > 0 Then
            ttyfAdjust = Y1 / Y2
        Else
            ttyfAdjust = 1
        End If
        Exit For
        'If Y1 > -30 And Y1 < Targ Then
    End If
Next x

End Sub
'option explicit
Public Sub CheckUnFlash()
    DontFade = -1
    LastP1X = -1
    LastP1Y = -1
    LastntNum = -1
    Exit Sub
    Dim TV1 As Variant, TV2 As Variant, FF As Long, oDirX As String, Spos As Long, ntPos As Long, LenTXT As Integer, HiTxt As Integer, TPosX As Integer, TPosY As Integer, CSeq As Long, VSV
    Dim tTYF As Double, TYFM As Integer
    Call ModOffsets(P1FontSize, Form1.Picture1, tTYF, TYFM)
    
    If ltPosY > -1 And ltPosX > -1 Then
        VSV = Form1.VScroll3.Value / ScrollSF
        LenTXT = Form1.Picture1.TextWidth("A")
        HiTxt = Form1.Picture1.TextHeight("A")
        'Picture1.Refresh
        Form1.Picture1.ToolTipText = ""
        Form1.Picture1.AutoRedraw = True
        Form1.Picture1.DrawMode = 6
        '(X * 13 - TYFM) * tTYF)
        'Picture1.Line (((TPosX - 1) * LenTxt + 1), (TPosY - TYFM) * HiTxt)-(((TPosX - 1) * LenTxt + LenTxt - 1), (TPosY - TYFM) * HiTxt + (HiTxt) * tTYF), RGB(196, 196, 0), BF
        TV1 = ltPosY
        TV1 = TV1 * 13 - TYFM
        TV1 = TV1 * tTYF * ttyfAdjust - VSV + 1
        TV2 = ltPosY + 1
        TV2 = (TV2 * 13 - TYFM) * tTYF * ttyfAdjust + 1 - VSV
        If ltPosY <= PermNextno And ltPosY <= NextNo Then
            Form1.Picture1.Line (((ltPosX - 1) * LenTXT), TV1)-(((ltPosX - 1) * LenTXT + LenTXT - 1), TV2), RGB(0, 0, 120), BF
        End If
        ltPosY = -1: ltPosX = -1
        Form1.Picture1.DrawMode = 13
    End If
End Sub
Public Sub DrawCompatMatTB()
Dim PSize As Long, Pict As Long
Dim x As Long, Y As Long, RelaventSites() As Long, tCnt As Byte, VarNumTB As Long, BinMat() As Byte, YP As Long, XP As Long
Dim CompSeq As Long, tCMat() As Byte, PV As Double
OVx = Form1.Command25.Enabled
'ssxx = Abs(GetTickCount)
'Form1.Command25.Enabled = True
Form1.Command25.ToolTipText = "Stop making the matrix"
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True

If DoneMatX(14) = 0 Then
    Form1.Command25.Enabled = True
    Form1.SSPanel1.Caption = "Doing PHITest"
    PV = PHITest(MatrixTB(), SeqNum(), NextNo, Len(StrainSeq(0)), 0, PHIWin, 0)
    Form1.SSPanel1.Caption = ""
    PhiTestPVal = PV
'    Dim MaxVal As Double
'    MaxVal = 0
'    For Y = 0 To UBound(MatrixTB, 1)
'        For X = 0 To UBound(MatrixTB, 2)
'            If MaxVal < MatrixTB(X, Y) Then
'                MaxVal = MatrixTB(X, Y)
'            End If
'        Next X
'
'    Next Y
 
    DoneMatX(14) = 1
    MaxN = 0
    For Y = 0 To UBound(MatrixTB, 2)
        For x = Y + 1 To UBound(MatrixTB, 1)
            If MaxN < MatrixTB(x, Y) Then
                MaxN = MatrixTB(x, Y)
            End If
        Next x
        
    Next Y
    MatBound(14) = MaxN 'UBound(MatrixTB, 1)
    'VarNumTB = X
'    EE = Abs(GetTickCount)
'            TT = EE - SS
'            '53297
'            '656
'            '11657 - David robertson HIV results
'            '10656
'            X = X
Else
    MaxN = MatBound(14)
End If

VarNumTB = UBound(MatrixTB, 1) 'MatBound(14)

    
    Dim cAddj As Long, MatPic() As Single, PosS(1) As Single, PosE(1) As Single, DistD As Long
    
    If VarNumTB = 0 Then
        Dummy = MsgBox("Cannot construct a Bruin Compatibility matrix because there are not enough informative sites")
        CurMatrixFlag = 255
        PhiTestPVal = 1
        PV = 1
        Exit Sub
    End If
    DistD = VarNumTB / MatZoom(14)
    Dim XAD As Single
    Form1.Picture26.ScaleMode = 3
    
    XAddj = (Form1.Picture26.ScaleHeight) / DistD
    XAD = XAddj
    cAddj = (Int((1 / XAddj) + 1)) ^ 2
    cAddj = Int(255 / cAddj) '(255 * (XAddj ^ 2)) - 1
    
    If cAddj > 255 Then cAddj = 255
    If XAddj <= 1 Then
        PSize = XAddj * VarNumTB
    Else
        PSize = VarNumTB
    End If
    If XAddj > 1 Then
        Span = Int(XAddj + 1)
    Else
        Span = 1
    End If
    Dim SpT As Long, SpE As Long
    SpT = CLng(-(Span / 2)) + 1
    SpE = CLng((Span / 2) - 0.00001)
    If SpT > SpE Then SpT = SpE
    
    'if spt=spe
    PosS(0) = MatCoord(14, 0)
    PosE(0) = PosS(0) + DistD
    PosS(1) = MatCoord(14, 1)
    PosE(1) = PosS(1) + DistD
    If PosE(1) > (UBound(MatrixTB, 1) - 1) - 1 Then PosE(1) = (UBound(MatrixTB, 1) - 1) - 1
    If PosE(0) > (UBound(MatrixTB, 1) - 1) - 1 Then PosE(0) = (UBound(MatrixTB, 1) - 1) - 1
       
    If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
    If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
    
    'SSAa = Abs(GetTickCount)
    
    ReDim MatPic(UBound(MatrixTB, 1), UBound(MatrixTB, 1))
    
    
    
    'If XAddj < 1 Then
    
'    EE = Abs(GetTickCount)
'    TT = EE - ssxx
    
    'SS = Abs(GetTickCount)
    If XAddj <= 1 Then
        If SpT <> SpE Then
            For Y = SY To PosE(1)
                For x = SX To PosE(0)

                    'If MatrixTB(X, Y) = 1 Then
                        For A = SpT To SpE
                            If CLng(x * XAD) + A >= 0 And CLng(x * XAD) + A <= PSize Then
                                For b = SpT To SpE
                                    If CLng(Y * XAD) + b >= 0 And CLng(Y * XAD) + b <= PSize Then
                                        'If MatPic(CLng(X * XAD + 0.001) + A, CLng(Y * XAD + 0.001) + B) + cAddj <= 255 Then
                                            MatPic(CLng(x * XAD + 0.001) + A, CLng(Y * XAD + 0.001) + b) = MatrixTB(x, Y)

                                        'End If
                                    End If
                                Next b
                            End If
                        Next A
                    'End If
                Next x
            Next Y




        Else
            'If X = X Then

                MaxNx = ModMatPicTB(cAddj, SY, SX, XAD, PosE(0), PosE(1), UBound(MatPic, 1), UBound(MatrixTB, 1), MatPic(0, 0), MatrixTB(0, 0))
                x = x
'            Else
'                For Y = SY To PosE(1)
'                    YP = CLng(Y * XAD + 0.001)
'                    For X = SX To PosE(0)
'
'                        If matrixtb(X, Y) = 1 Then
'                            XP = CLng(X * XAD + 0.001)
'                            MatPic(XP, YP) = MatPic(XP, YP) + cAddj
'                        End If
'                    Next X
'                Next Y
            'End If
        End If
    Else
'        For X = 0 To VarNumTB
'            For Y = 0 To VarNumTB
'                If MatrixTB(X, Y) = 1 Then
'                    MatPic(X, Y) = 255
'                End If
'            Next Y
'        Next X
        '
        MaxNx = MatCToMatPicTB(SX, SY, PosE(0), PosE(1), UBound(MatPic, 1), UBound(MatrixTB, 1), MatPic(0, 0), MatrixTB(0, 0))
        
    End If
    
'    EE = Abs(GetTickCount)
'    TT = EE - SS
'    X = X
'Else
    
'    SS = Abs(GetTickCount)
'    'SS = Abs(GetTickCount)
'    If X = 123445677 Then 'this is not working for matpic
'        MaxN = FindMaxNS(PSize, MatPic(0, 0))
'
'    ElseIf X = 1234567890 Then
'        MaxN = 0
'        For X = 0 To PSize
'            For Y = 0 To PSize
'                If MatPic(X, Y) > MaxN Then
'                    MaxN = MatPic(X, Y)
'                End If
'            Next Y
'        Next X
'
'    End If
'    MaxN = MaxN / (cAddj)
'    MaxN = FindMaxNS(UBound(MatPic, 1) - 1, MatPic(0, 0))
'    Dim BlockX As Single, MaxNx As Single
'    BlockX = (((1 / XAddj)) ^ 2)
'    'If MaxN = 0 Then MaxN = 1
    
    If XAddj <= 1 Then
        MaxNx = (1 / XAddj) ^ 2 * MaxN
    Else
        MaxNx = MaxN
    End If
'    MaxNx = CLng((MaxN / BlockX) + 1)
'    MaxN = BlockX * MaxNx
'    XX = MaxN
'
'    X = X
'Else
'    For X = 0 To VArNumTB
'        For Y = 0 To VArNumTB
'            If matrixtb(X, Y) = 1 Then
'                MatPic(CLng(X * XAddj), CLng(Y * XAddj)) = MatPic(CLng(X * XAddj), CLng(Y * XAddj)) + cAddj
'            End If
'        Next Y
'    Next X
'End If


'Form1.Picture26.Picture = LoadPicture()
'Form1.Picture26.ScaleMode = 3
'Form1.Picture26.AutoRedraw = True


'If XAddj > 1 Then
'    Form1.Picture26.DrawWidth = CInt(XAddj + 1)
'End If
'Pict = Form1.Picture26.hdc
'Dim PntAPI As POINTAPI
'If XAddj < 1 Then xaddjx = 1 Else xaddjx = XAddj

Dim PosEx(1) As Single, PosSx(1) As Single

For x = 0 To 1
    PosEx(x) = CLng(PosE(x) * XAD + 0.001)
    PosSx(x) = CLng(PosS(x) * XAD + 0.001)
Next x

'eexx = Abs(GetTickCount)
'
'
'TT = eexx - ssxx
'T = eexx - SSAa
'tttt = eexx - SSA
'ttt = eexx - SS
'
'
'
'SSA = Abs(GetTickCount)

If XAddj <= 1 Then
    Call DrawMatsVB(Form1.Picture26, 0, PosEx(), PosSx(), SX * XAddj, SY * XAddj, 1, MatPic(), HeatMap, CurScale, MaxNx)
Else
    Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatPic(), HeatMap, CurScale, MaxNx)
End If
    
'
' EE = Abs(GetTickCount)
' TT = EE - ssxx
' ttt = EE - SSA
'    X = X '0.889,0.422, 0.343
'X = X
If DontDoKey = 0 Or x = x Then
    Call DoKey(0, MaxN, 0, 0, "Incompatibility score", CurScale)
End If
Form1.Command25.Enabled = OVx
Form1.Command25.ToolTipText = ""
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True
If DontRefreshFlag = 0 Then
    Form1.Picture26.Refresh
End If
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub
Public Sub UpdateF2Prog()
If Form2.Visible = True Then
    Form2.SSPanel3.Caption = Form1.SSPanel1.Caption
    Form2.ProgressBar1 = Form1.ProgressBar1
End If
End Sub

Public Function Normal01CDF(x As Double)

'double normal_01_cdf ( double x )
'
'//******************************************************************************
'//
'//  Purpose:
'//
'//    NORMAL_01_CDF evaluates the Normal 01 CDF.
'//
'//  Modified:
'//
'//    10 February 1999
'//
'//  Author:
'//
'//    John Burkardt
'//
'//  Reference:
'//
'//    A G Adams,
'//    Areas Under the Normal Curve,
'//    Algorithm 39,
'//    Computer j.,
'//    Volume 12, pages 197-198, 1969.
'//
'//  Parameters:
'//
'//    Input, double X, the argument of the CDF.
'//
'//    Output, double CDF, the value of the CDF.
'//
'{
  
  Dim A1 As Double, A2 As Double, A3 As Double, a4 As Double, a5 As Double, a6 As Double, a7 As Double
  Dim b1 As Double, b2 As Double, b3 As Double, b4 As Double, b5 As Double, b6 As Double, b0 As Double
  Dim b7 As Double, b8 As Double, b9 As Double, b10 As Double, b11 As Double
   A1 = 0.398942280444
   A2 = 0.399903438504
   A3 = 5.75885480458
   a4 = 29.8213557808
   a5 = 2.62433121679
   a6 = 48.6959930692
   a7 = 5.92885724438
   b0 = 0.398942280385
   b1 = 0.000000038052
   b2 = 1.00000615302
   b3 = 0.000398064794
   b4 = 1.98615381364
   b5 = 0.151679116635
   b6 = 5.29330324926
   b7 = 4.8385912808
   b8 = 15.1508972451
   b9 = 0.742380924027
   b10 = 30.789933034
   b11 = 3.99019417011
  Dim cdf As Double
  Dim Q As Double, Y As Double
  Dim h1 As Double, h2 As Double, H3 As Double, h4 As Double, h5 As Double, h6 As Double
'//
'//  |X| <= 1.28.
'//
  If Abs(x) <= 1.28 Then
  
    Y = 0.5 * x * x
    variantx = (A1 - A2 * Y / (Y + A3 - a4 / (Y + a5 + a6 / (Y + a7))))
    Q = 0.5 - Abs(x) * variantx
      
'//
'//  1.28 < |X| <= 12.7
'//
  
  ElseIf Abs(x) <= 12.7 Then
  
    Y = 0.5 * x * x
    h1 = (Abs(x) + b9 + b10 / (Abs(x) + b11))
    h2 = (Abs(x) - b5 + b6 / (Abs(x) + b7 - b8 / h1))
    H3 = (Abs(x) - b1 + b2 / (Abs(x) + b3 + b4 / h2))
    Q = Exp(-Y) * b0 / H3
'//
'//  12.7 < |X|
'//
 
  Else
  
    Q = 0#
  End If
'//
'//  Take account of negative X.
'//
  If x < 0# Then
  
    cdf = Q
  
  Else
  
    cdf = 1# - Q
  End If

  Normal01CDF = cdf

End Function





Public Sub ReorderChars(Alignment() As Byte, num_sites As Long, num_taxa As Long, new_alignment() As Integer)
Dim x As Long, Dummy As Long
'/* In: alignment     - ordered by taxa
'       site_states   - number of states at each site
'       num_sites     - number of sites
'       num_taxa      - number of taxa...
'Out:
'       new_alignment - ordered by character
'                       where each character goes from
'               0..k, for k states, with NEGATIVE
'               states for missing/gaps...
'
'*/
'void reorder_chars( align_type **alignment,  alignmentClass alignKind, cbool stateMissing,int num_sites, int num_taxa, align_type ***new_alignment)
'{
    Dim state_map(100) As Long
    Dim state_count As Long, cur_state As Long
    Dim i  As Long, j As Long, k As Long, char_a As Long
    ReDim new_alignment(num_taxa, num_sites)
  
    
    If x = x Then
        Dummy = MakeNewAlignment(num_taxa, num_sites, UBound(new_alignment, 1), UBound(Alignment, 1), state_map(0), Alignment(0, 0), new_alignment(0, 0))
        
    Else
        For j = 0 To num_sites - 1
          
            For k = 0 To 99
                state_map(k) = -1
            Next k
            state_count = 0
            For i = 0 To num_taxa - 1
           
                char_a = Alignment(i, j)
                
    '            /* Figure out which positive state 0..k */
    '            /*      if(char_A <=MAX_STATE)*/
                If char_a > 46 Then
                  
                    If state_map(char_a) < 0 Then
                  
                        state_map(char_a) = state_count
                        cur_state = state_count
                        state_count = state_count + 1
                    
                  
                    Else
                  
                        cur_state = state_map(char_a)
                    End If
                  
                Else
                  cur_state = -1
                End If
                new_alignment(i, j) = cur_state
            Next i
            
          
        Next j
    End If


End Sub


Public Sub GetInformative(SeqNum() As Integer, site_desc() As Site, site_states() As Long, num_taxa As Long, num_sites As Long, new_num_sites As Long, new_alignment() As Byte, new_site_states() As Long, new_site_desc() As Site)

Dim x As Long, Dummy As Long
'/* In:   alignment           - alignment ordered by taxa
'         site_desc           - a description of each site
'         site_states         - the number of states at each site
'         num_taxa.. num_inf  - number of taxa char, etc..
'   Out:  new_num_sites       - the new number of sites
'         new_alignment       - alignment ordered by taxa with only informative
'         new_site_states     - number of states at each informative site
'     new_site_desc       - description of states at each informative site
'*/
'
'void get_informative( align_type **alignment,  site* site_desc,  int *site_states, int num_taxa, int num_sites, int* new_num_sites, align_type ***new_alignment, int **new_site_states, site **new_site_desc)
'{
    Dim i As Long, j As Long
    Dim site_count As Long, informative_count As Long
    site_count = 0
    informative_count = 0
    For i = 0 To num_sites - 1
        If site_desc(i).infstatus = 1 Then
            informative_count = informative_count + 1
        End If
    Next i
    
    Dim Subset As Single
    If informative_count > 8000 Then
        Subset = 8000 / informative_count
    Else
        Subset = 0
    End If
    
   
    
    
    new_num_sites = informative_count
    ReDim new_site_states(informative_count)
    ReDim new_site_desc(informative_count)
    ReDim new_alignment(num_taxa, informative_count) 'note this is swapped around relative to seqnum
    Dim UBSN As Long
    Dim UBNA As Long
    UBSN = UBound(SeqNum, 1)
    UBNA = UBound(new_alignment, 1)
    ReDim VarPosTB(Len(StrainSeq(0)))
'    If X = X Then
        For j = 0 To num_sites - 1
        
      
            If site_desc(j).infstatus = 1 Then
            
                If Subset <= Rnd Then
                    Dummy = CopyColumn(j, UBNA, UBSN, num_taxa, site_count, SeqNum(0, 0), new_alignment(0, 0))
                    new_site_states(site_count) = site_states(j)
                    new_site_desc(site_count) = site_desc(j)
        '            (*new_site_desc)[site_count].inf=site_desc[j].inf;
        '            (*new_site_desc)[site_count].poly=site_desc[j].poly;
        '            (*new_site_desc)[site_count].gap=site_desc[j].gap;
        '            (*new_site_desc)[site_count].orig_index=site_desc[j].orig_index;
        '            (*new_site_desc)[site_count].num_missing=site_desc[j].num_missing;
                     
                    site_count = site_count + 1
                    VarPosTB(site_count) = j
                Else
                    site_desc(j).infstatus = 0
                End If
            End If
        Next j
'    Else
'
'        For J = 0 To num_sites - 1
'
'
'            If site_desc(J).infstatus = 1 Then
'
'
'                For i = 0 To num_taxa - 1
'
'                    new_alignment(i, site_count) = SeqNum(J, i)
'                Next i
'                new_site_states(site_count) = site_states(J)
'                new_site_desc(site_count) = site_desc(J)
'    '            (*new_site_desc)[site_count].inf=site_desc[j].inf;
'    '            (*new_site_desc)[site_count].poly=site_desc[j].poly;
'    '            (*new_site_desc)[site_count].gap=site_desc[j].gap;
'    '            (*new_site_desc)[site_count].orig_index=site_desc[j].orig_index;
'    '            (*new_site_desc)[site_count].num_missing=site_desc[j].num_missing;
'
'                site_count = site_count + 1
'            End If
'        Next J
'    End If
    ReDim Preserve new_site_states(site_count)
    ReDim Preserve new_site_desc(site_count)
    ReDim Preserve new_alignment(num_taxa, site_count)
    new_num_sites = site_count


End Sub
Public Sub FindStates(SeqNum() As Integer, NextNo As Long, num_sites As Long, site_desc() As Site, site_states() As Long)

Dim num_taxa As Long, x As Long

num_taxa = NextNo + 1
'/* In:  alignment       - ordered by taxa
'        num_taxa        - number of taxa
'    num_sites       - number of sites
'   Out: site_states     - number of states at every site
'        site_desc       - type of every site
'
'*/
'void find_states( align_type **alignment, alignmentClass alignKind, cbool stateMissing, int num_taxa, int num_sites,  site** site_desc, int** site_states)
'{
  Dim state_count As Long, big_states As Long, char_a As Long, i As Long, j As Long
  Dim state_map(100) As Long
  Dim missing_ambig_count As Long
  missing_ambig_count = 0
  Dim S(250) As Byte
  Dim MaxInf As Long
  MaxInf = 6000

  Dim gap_char As Long
  
  ReDim site_desc(num_sites)
  ReDim site_states(num_sites)
    Dim UBSN As Long
    UBSN = UBound(SeqNum, 1)
    
Dim NumInf As Long
NumInf = 0
  For j = 0 To num_sites - 1
        
        
     If x = x Then
        state_count = MakeStateMap(num_taxa, j, UBSN, SeqNum(0, 0), state_map(0), gap_char)
     Else
          For i = 0 To 99
            state_map(i) = 0
          Next i
          state_count = 0
          gap_char = 0
          missing_ambig_count = 0
    
    
          For i = 0 To num_taxa - 1
        
              char_a = SeqNum(j, i)
        
              If char_a > 46 Then
                
                
                    If state_map(char_a) <= 0 Then
                
                        state_count = state_count + 1
                        state_map(char_a) = state_map(char_a) + 1
                  
                
                    Else
                        state_map(char_a) = state_map(char_a) + 1
                    End If
                
              
              ElseIf char_a = 46 Then
                
                  gap_char = True
                
              End If
          
        Next i
    End If
     ' /* Add current index to description */
    site_desc(j).orig_index = j
       
    
      '/*Add state count */
    site_states(j) = state_count
      
    site_desc(j).num_states = state_count
      
      '/* Add missing count */
    site_desc(j).num_missing = 0
      
      
     ' /* Check if gapped */
    If gap_char = 1 Then
    
        site_desc(j).gapstatus = 1
    
    Else
    
        site_desc(j).gapstatus = 0
    End If

      '/* Check if informative */
    big_states = 0
      
    If state_count >= 2 Then
      
        For i = 0 To 99
            If state_map(i) >= 2 Then
                big_states = big_states + 1
            End If
        Next i
        
    
    End If


    If state_count >= 2 Then
    
        site_desc(j).polystatus = 1 'polymorphic
        If big_states >= 2 Then
            site_desc(j).infstatus = 1 'informative
            NumInf = NumInf + 1
        Else
            site_desc(j).infstatus = 0 'informative
        End If
    
    Else
    
      site_desc(j).infstatus = 0 'uninformtive

      site_desc(j).polystatus = 0 'constant


    End If
  
 

 
  
Next j
Dim DelEvery As Double, Counter As Long, RN As Long

If NumInf > MaxInf Then
    Counter = 0
        Rnd (-BSRndNumSeed)
     
   DelEvery = ((MaxInf / NumInf) * 100)
   
   For j = 0 To num_sites - 1
        If site_desc(j).infstatus = 1 Then
            RN = Int((99 * Rnd) + 1)
            
            If RN > DelEvery Then
                
                site_desc(j).infstatus = 0
            End If
        End If
   Next j
End If

End Sub


Public Function PHI(inc_matrix() As Byte, num_states() As Long, permutation() As Long, num_chars As Long, k As Long) As Double

'double PHI(inc_type **inc_matrix,int *num_states,int *permutation, int num_chars, int k)

      Dim i As Long, j As Long
      Dim p_i As Long, p_j As Long, states_i As Long, states_j As Long
      Dim val As Double
      Dim Score As Double
      Score = 0#
      Dim terms As Long
      
      For i = 0 To num_chars - 2
        
            p_i = permutation(i)
            
            states_i = num_states(p_i)
              
            For j = 1 To k
            
                If i < num_chars - j Then
                    
                      p_j = permutation(i + j)
                      states_j = num_states(p_j)
                      val = inc_matrix(p_i, p_j)
'                      If inc_matrix(p_i, p_j) <> 0 Then
'                        X = X
'                      End If
                      Score = Score + val
                End If
            Next j
      Next i
      terms = (k * (2 * num_chars - k - 1)) / 2
      If terms > 0 Then
        PHI = (Score / terms)
      Else
        PHI = 0
      End If
      'X = X


End Function

Public Sub GetFandG(inc_matrix() As Byte, num_states() As Long, num_chars As Long, f_values() As Double, g_values() As Double)
'void get_f_and_g(inc_type **inc_matrix,int *num_states,int num_chars, double *f_values,double *g_values)
' {
   Dim i As Long, j As Long
   Dim fscore As Double, gscore As Double
   fscore = 0#: gscore = 0#
   Dim val As Double
   '''''''''
   For i = 0 To num_chars - 1
     
           fscore = 0#
           gscore = 0#
           f_values(i) = 0#
           g_values(i) = 0#
    
           For j = 0 To num_chars - 1
         
                val = inc_matrix(i, j)
                fscore = fscore + val
                gscore = gscore + val * val
    
            Next j
           f_values(i) = fscore
           g_values(i) = gscore
     
    Next i
End Sub
Public Sub AnalyticMeanVariance(inc_matrix() As Byte, num_states() As Long, num_chars As Long, k_val As Long, mean As Double, varnce As Double)

'void analytic_mean_variance(inc_type** inc_matrix, int* num_states, int num_chars,int k_val, double *mean, double *varnce)

  Dim coeff_1 As Double, coeff_2 As Double, coeff_3 As Double, sum1 As Double, sum2 As Double, sum3 As Double
  Dim i As Long, Dummy As Long
  
  Dim n As Double, Top As Double, Bottom As Double
  Dim f_vals() As Double, g_vals() As Double

    ReDim f_vals(num_chars), g_vals(num_chars)
    Dim k As Double
    k = k_val
    n = num_chars
 
'    If X = 1234567 Then
'        Call GetFandG(inc_matrix(), num_states(), num_chars, f_vals, g_vals)
'    Else
        Dummy = get_f_and_g(inc_matrix(0, 0), num_states(0), num_chars, f_vals(0), g_vals(0))
'    End If
  
  '/* Figure out mean */
    sum1 = 0
    For i = 0 To num_chars - 1
   
        sum1 = sum1 + f_vals(i)
    Next i
  
    mean = sum1 / ((num_chars * (num_chars - 1)))
 
  '/* Figure out variance - one term at a time */
  
  '/* First coeff */
  Top = CDbl(27 * k * n - 18 * k ^ 2 + 28 * k ^ 2 * n - 21 * k * n ^ 2 - 9 * k + 5 * n - 9 * k ^ 3 - 11 * n ^ 2 + 6 * n ^ 3 + 6 * k ^ 3 * n - 4 * k ^ 2 * n ^ 2)
  Bottom = CDbl(k * ((k + 1 - 2 * n) ^ 2) * ((n - 1) ^ 2) * (n - 2) * (n - 3) * (n ^ 2))
  If Bottom > 0 Then
  coeff_1 = ((2#) / (3#)) * (Top / Bottom)
  Else
     coeff_1 = 1000000000
  End If
  '/* Second coeff */
  Top = CDbl(8 * (k ^ 2) * n - 14 * (k ^ 2) + 39 * k * n + 19 * n - 21 * k + 3 * (k ^ 3) - 15 * k * (n ^ 2) + 6 * (n ^ 3) - 21 * (n ^ 2) - 4)
  Bottom = CDbl(k * ((2 * n - k - 1) ^ 2) * n * (n - 1) * (n - 2) * (n - 3))
  If Bottom > 0 Then
    coeff_2 = ((2#) / (3#)) * (Top / Bottom)
  Else
    coeff_2 = 1000000000
  End If
  '/* Third coeff */
  Top = CDbl(-18 * k * n - 2 * (k ^ 2) * n + 16 * (k ^ 2) + 6 * (n ^ 2) - 10 * n + 2 + 15 * k + 3 * (k ^ 3))
  Bottom = CDbl(k * ((k + 1 - 2 * n) ^ 2) * n * (n - 1) * (n - 2) * (n - 3))
  If Bottom > 0 Then
    coeff_3 = (-4# / 3#) * (Top / Bottom)
  Else
    coeff_3 = 1000000000
  End If
  '/* Now figure out (sum(f))^2, sumg(g) and sum(f^2) */
  sum1 = sum1 * sum1
  
  sum2 = 0
    For i = 0 To num_chars - 1
    
        sum2 = sum2 + g_vals(i)
    Next i
  
  sum3 = 0
  For i = 0 To num_chars - 1
    
        sum3 = sum3 + (f_vals(i)) * (f_vals(i))
   Next i

  varnce = coeff_1 * sum1 + coeff_2 * sum2 + coeff_3 * sum3


End Sub
Public Sub IdentityPermutation(permutation() As Long, n As Long)
'void identity_permutation(int *permutation, int n)
'{
    Dim i As Long
 
    i = 0
    For i = 0 To n - 1
        permutation(i) = i
    Next i
End Sub
Public Sub SamplePermutation(permutation() As Long, n As Long)
'void sample_permutation(int *permutation, int n)
'{
    Dim i As Long, Temp As Long, val As Long

    i = 0
    Call IdentityPermutation(permutation, n)
  
    For i = 0 To n - 2
    
        val = Int(((n - 2) * Rnd) + 1) 'rand() % (n-i) +i;
        '//fprintf(stdout, "Val is between %d & %d - got %d\n",i,(n-1),val);
        Temp = permutation(i)
        permutation(i) = permutation(val)
        permutation(val) = Temp
    Next i

End Sub

Public Function PHITest(inc_matrix() As Byte, SeqNum() As Integer, NextNo As Long, LSeq As Long, k As Long, optWinsize As Long, doPerm As Byte) As Double

Dim PV As Double, x As Long, Y As Long, Z As Long, DSize As Long, LowestPval As Double
PV = PHITest2(inc_matrix(), SeqNum(), NextNo, LSeq, k, optWinsize, doPerm)
DSize = 10
Dim tincmat() As Byte
If PV = 1 Then ' test is potentially "flooded"
    
    If NextNo > DSize Then
        Dim DatasetNo As Long
        'redo with random subsets of dsize sequences
        DatasetNo = CLng((NextNo / DSize) + 0.5)
        Dim TempSeqNum() As Integer, DoneSeq() As Long, CurseqNo As Long, RndSeq As Long
        
        
        LowestPval = 100
        For x = 1 To DatasetNo
            ReDim DoneSeq(NextNo)
            ReDim TempSeqNum(UBound(SeqNum, 1), DSize)
            CurseqNo = 0
            Do While CurseqNo < DSize
                Do
                    RndSeq = Int((NextNo * Rnd) + 1)
                    If DoneSeq(RndSeq) = 0 Then Exit Do
                Loop
                DoneSeq(RndSeq) = 1
                For Y = 1 To LSeq
                    TempSeqNum(Y, CurseqNo) = SeqNum(Y, RndSeq)
                Next Y
                CurseqNo = CurseqNo + 1
            Loop
            PV = PHITest2(tincmat(), TempSeqNum(), DSize, LSeq, 0, optWinsize, 0)
            'XX = PHIWin
            If PV < LowestPval Then LowestPval = PV
            x = x
            If Form1.ProgressBar1.Value < (x / DatasetNo) * 100 Then Form1.ProgressBar1.Value = (x / DatasetNo) * 100
            Form1.WindowState = Form1.WindowState
        Next x
        PV = LowestPval * DatasetNo
        If PV > 1 Then PV = 1
    End If
    PHITest = PV
Else
    PHITest = PV
    
End If
Form1.ProgressBar1.Value = 0
End Function
Public Function PHITest2(inc_matrix() As Byte, SeqNum() As Integer, NextNo As Long, LSeq As Long, k As Long, optWinsize As Long, doPerm As Byte) As Double
'This and all the routines it calls is a VB translation of Tervor Bruins PHIPACK C code
 'SS = abs(gettickcount)
'  align_type **alignment;
'  char **taxa_names;



Dim NumTaxa As Long, num_taxa As Long, num_sites As Long
Dim num_inf As Long
Dim FF As Long, LSSS As Long, pair_inc As Long
Dim Dummy As Long, divg As Double, val As Double

Dim x As Long, Max_inf As Long
  
 ' options opt;
  
'  /* Number of states at each character and description of each site */
Dim site_states() As Long
  

Call UnModNextno

Call UnModSeqNum(0)
num_taxa = NextNo + 1
  
'  typedef struct {
'  polystatus poly;
'  infstatus inf;
'  gapstatus gap;
'  int       orig_index;
'  int       num_states;
'  int       num_missing;
'} site;
  
Dim site_desc() As Site, inf_site_desc() As Site

'  /* Counts of incompatibilities */
Dim counts() As Long, max_state As Long, max_inc As Long
max_state = 4 'i.e. is DNA
'  /* Alignment for informative states */
Dim inf_alignment() As Byte
Dim inf_states() As Long


'  /* Alignment by characters */
Dim char_alignment() As Integer 'needs to be an integer because it includes negative numbers
  
  
'  typedef int inc_type;
'typedef char align_type;
  
  
'  /* Matrix of incompatibilities */
Dim i As Long, j As Long

  
'  /* Log file */
'  FILE *alignfile,*logfile;
 
  
  '/* Values of statistics */
  Dim valid_normal_approx As Boolean
  Dim orig_PHI As Double, orig_NSS As Double, cur_PHI As Double, cur_NSS As Double
  Dim sum_PHI As Double, sum_sq_PHI As Double, obs_mean As Double, obs_varnce As Double
  sum_PHI = 0#
  sum_sq_PHI = 0#
  obs_mean = 0#
  obs_varnce = 0#
  Dim mean As Double, variance As Double
  
  mean = 0#
  variance = 0#
  
  Dim difference As Double, normal_p_val As Double
  Dim emp_PHI As Long, emp_NSS As Long, emp_MAXCHI As Long
 
 normal_p_val = 0#
 emp_PHI = 0
 emp_NSS = 0
 emp_MAXCHI = 0
  Dim permutation() As Long

'  /* For maxChi */
'  double windowScale= 2/3;
  
 ' /* Seed random number generator */
  Rnd (-BSRndNumSeed)
  NumTaxa = NextNo + 1
  num_sites = LSeq
'  get_params(argc,argv,&opt);
'
'  /* Open log file */
'
'  logfile=ffopen("Phi.log","w");
'
'  fprintf(stdout,"Reading sequence file %s\n",opt.seqFile);
'  fprintf(logfile,"Reading sequence file %s\n",opt.seqFile);
'
'  Switch (opt.Infile)
'    {
'    Case strict:
'      read_phylip(opt.seqFile,TRUE, &taxa_names,&alignment,&num_taxa,&num_sites);
'      break;
'    Case relaxed:
'      read_phylip(opt.seqFile,FALSE, &taxa_names,&alignment,&num_taxa,&num_sites);
'      break;
'    Case fasta:
'      read_fasta(opt.seqFile, &taxa_names,&alignment,&num_taxa,&num_sites );
'      break;
'    }
'
'  fprintf(logfile,"Allocating space for %d taxa and %d sites\n",num_taxa,num_sites);
'
'  if(num_taxa<=0 || num_sites<=0)
'    error("No sequences or sitesin alignment");
'
  
'  /* Validate alignment type */
'  validate_alignment(alignment,opt.alignKind,num_taxa,num_sites);
'  fprintf(stdout,"Alignment looks like a valid ");
'  fprintf(logfile,"Alignment looks like a valid ");
'  Switch (opt.alignKind)
'    {
'    Case DNA:
'      fprintf(stdout,"DNA alignment.\n");
'      fprintf(logfile,"DNA alignment.\n");
'      break;
'    Case AA:
'      fprintf(stdout,"AA alignment.\n");
'      fprintf(logfile,"AA alignment.\n");
'      break;
'    Case OTHER:
'      fprintf(stdout,"OTHER alignment.\n");
'      fprintf(logfile,"OTHER alignment.\n");
'      break;
'    }
'
'  /* FIX - Add complete deletion ?  */
'
'  get_seq_div(alignment, opt.alignKind, num_taxa, num_sites, &divg);
'  fprintf(stdout,"Estimated diversity is (pairwise deletion - ignoring missing/ambig): %4.1lf%%\n",(divg*100.0));
'  fprintf(logfile,"Estimated diversity is (pairwise deletion - ignoring missing/ambig): %4.1lf%%\n",(divg*100.0));

 ' /* Get informative sites */
  Call FindStates(SeqNum(), NextNo, LSeq, site_desc(), site_states())
  
  Call GetInformative(SeqNum(), site_desc(), site_states(), num_taxa, num_sites, num_inf, inf_alignment(), inf_states(), inf_site_desc())
  
 ' fprintf(stdout,"Found %d informative sites.\n",num_inf);
 ' fprintf(logfile,"Found %d informative sites.\n",num_inf);
  
 ' /* Open seq file */

'  alignfile=ffopen("Phi.inf.sites","w");
  
'  fprintf(stdout  ,"Writing alignment of informative sites to: Phi.inf.sites\n");
'  fprintf(logfile,"Writing alignment of informative sites to: Phi.inf.sites\n");
'
    
'   Switch (opt.Infile)
'    {
'    Case strict:
'      write_phylip(alignfile,TRUE, taxa_names,inf_alignment,num_taxa,num_inf);
'      break;
'    Case relaxed:
'      write_phylip(alignfile,FALSE, taxa_names,inf_alignment,num_taxa,num_inf);
'      break;
'    Case fasta:
'      write_fasta(alignfile, taxa_names,inf_alignment,num_taxa,num_inf );
'      break;
'    }
'   fclose(alignfile);
'
'   /* Write where those sites occured */
'   alignfile=ffopen("Phi.inf.list","w");
'
'   fprintf(stdout  ,"Writing list of informative sites to:      Phi.inf.list\n");
'   fprintf(logfile, "Writing list of informative sites to:      Phi.inf.list\n");
'   for(i=0;i<num_inf;i++)
'     fprintf(alignfile,"%4d %4d\n",i+1,(inf_site_desc[i]).orig_index);
'
'   fclose(alignfile);

   '/* Allocate possibly sparsely - big matrix sequential stride */
  ReDim inc_matrix(num_inf, num_inf) '=(inc_type **)mcalloc(num_inf , sizeof(inc_type *) );
  
 ' /* Reorder by character */
  Call ReorderChars(inf_alignment(), num_inf, num_taxa, char_alignment())
  
  max_inc = max_state * max_state - 2 * max_state + 1
  
  
    If k = 0 Then
      '{
        val = (CDbl(num_inf)) / (CDbl(num_sites))
        val = val * optWinsize
        
        k = CLng(val)
        
          'If K < 10 Then
          '    K = num_inf / 2
          'End If
          If k < 10 Then k = 10
          If k > num_inf Then k = (num_inf / 2) - 1
          If k <= 0 Then k = 1
          
      '}
    Else
      '{
        val = (CDbl(num_sites)) / (CDbl(num_inf))
        val = val * k
        optWinsize = val
      '}
    End If
  'k = 6
 ' fprintf(stdout,"Calculating all pairwise incompatibilities...\n");
  '/* Now get incompatibilities between all pairs... */
    
    'Open "lastpair.csv" For Output As #1
   
    
    
    'make the pairsite matrix
    
    Dim PairsMatrix() As Byte
     '1=a, 2 =c, 3 = g, 4 = t, 0 = -
    
    
    
    
    
    Dim A As Long, b As Long, C As Long, D As Long, NewEntry As Byte, oDirX As String
    NewEntry = 0
    
    Dim SqScore(3, 3) As Long
    C = 1
    
    For A = 0 To 3
        For b = 0 To 3
            SqScore(A, b) = C
            C = C * 2
        Next b
    Next A
    ReDim PairsMatrix(3, 3)

    If x = 1234455 Then
        For i = 0 To num_inf - 1
        
            'Open "lastpair.csv" For Output As #3
           ' For J = i To num_inf - 1
        
'                If i = J Then
'                  inc_matrix(i, J) = 0
'                Else
'
'                    'Close #3
'
'                    'Print #3, i
'                    'Print #3, J
'
'                    'pair_inc = PairScore(char_alignment, inf_states, i, j, num_inf, num_taxa)
'    '                XX = UBound(char_alignment, 2)
'    '                XX = char_alignment(2, 20)
'    '                XX = inf_alignment(20, 2)
                    Dummy = pair_score2(char_alignment(0, 0), inf_states(0), i, num_inf, num_taxa, inc_matrix(0, 0))
                    x = x
'                    inc_matrix(i, J) = pair_inc
'                    inc_matrix(J, i) = pair_inc
                 ' End If
           ' Next J
            'Close #3
            x = x
            Form1.ProgressBar1 = (i / (num_inf - 1)) * 100
            Call UpdateF2Prog
        Next i
    ElseIf x = x Then
        
        For i = 0 To num_inf - 1
        
            'Open "lastpair.csv" For Output As #3
            
            If x = x Then
                '@
            
                NewEntry = FillIncMatrix(i, num_inf, NumTaxa, inf_states(0), PairsScores(0), char_alignment(0, 0), PairsMatrix(0, 0), SqScore(0, 0), inc_matrix(0, 0))
                x = x
            Else
            
                inc_matrix(i, i) = 0
                '
                For j = i + 1 To num_inf - 1
            
                    
                      
                        D = GetDScore(NumTaxa, i, j, SqScore(0, 0), char_alignment(0, 0), PairsMatrix(0, 0))
                        
                        If PairsScores(D) = 255 Then
                            PairsScores(D) = pair_score(char_alignment(0, 0), inf_states(0), i, j, num_inf, num_taxa)
                            NewEntry = 1
                        
                        End If
                        '
                        inc_matrix(i, j) = PairsScores(D)
                        '
                        inc_matrix(j, i) = PairsScores(D)
                        
                        If inc_matrix(i, j) <> 0 Then
                            x = x
                        End If
                      
                Next j
            End If
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                If num_inf > 1 Then
                    If Form1.ProgressBar1 < (i / (num_inf - 1)) * 100 Then Form1.ProgressBar1 = (i / (num_inf - 1)) * 100
                End If
                Call UpdateF2Prog
            End If
        Next i
    Else
    
        
        
        For i = 0 To num_inf - 1
        
            'Open "lastpair.csv" For Output As #3
            inc_matrix(i, i) = 0
            '
            For j = i + 1 To num_inf - 1
        
                
                  
                    'Close #3
                    
                    'Print #3, i
                    'Print #3, J
                    
                    'pair_inc = PairScore(char_alignment, inf_states, i, j, num_inf, num_taxa)
    '                XX = UBound(char_alignment, 2)
    '                XX = char_alignment(2, 20)
    '                XX = inf_alignment(20, 2)
'                    If X = 12345 Then
'
'                          ReDim PairsMatrix(3, 3)
'
'                          For A = 0 To NumTaxa - 1
'                              char_a = char_alignment(A, i)
'
'                              If (char_a > -1) Then
'                                  char_b = char_alignment(A, J)
'                                  If char_b > -1 Then
'                                      PairsMatrix(char_a, char_b) = 1
'                                  End If
'                              End If
'                          Next A
'
'                          D = 0
'                          For A = 0 To 3
'                              For B = 0 To 3
'                                 If PairsMatrix(A, B) = 1 Then
'                                      D = D + SqScore(A, B)
'
'                                 End If
'                              Next B
'                          Next A
'                    Else
                     '''''''
                        D = GetDScore(NumTaxa, i, j, SqScore(0, 0), char_alignment(0, 0), PairsMatrix(0, 0))
                    'End If
                    
                    If PairsScores(D) = 255 Then
                        PairsScores(D) = pair_score(char_alignment(0, 0), inf_states(0), i, j, num_inf, num_taxa)
                        NewEntry = 1
                    
                    End If
                    '
                    inc_matrix(i, j) = PairsScores(D)
                    '
                    inc_matrix(j, i) = PairsScores(D)
                  
            Next j
            'Close #3
            SSS = Abs(GetTickCount)
            If Abs(SSS - LSSS) > 500 Then
                LSSS = SSS
                If Form1.ProgressBar1 < (i / (num_inf - 1)) * 100 Then Form1.ProgressBar1 = (i / (num_inf - 1)) * 100
                Call UpdateF2Prog
            End If
        Next i
    End If
    If NewEntry = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        'XX = CurDir
        FF = FreeFile
        Open "PairsScores" For Binary As #FF
        Put #FF, , PairsScores()
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    'XX = CurDir
    
    'Form1.ProgressBar1 = 0
    Call UpdateF2Prog
'  fprintf(stdout,"\b\b\b\b\b\b");
'  fprintf(stdout,"%5.1f%%",100.0);
'  fflush(stdout);
'  fprintf(stdout,"\n\n");

  'CALL inc_stats(max_inc,num_inf,opt.verbose,inc_matrix,&counts,logfile)


'  fprintf(stdout, "Using a window size of %3.0lf with k as %d\n",optWinsize,opt.k);
'  fprintf(logfile, "Using a window size of %3.0lf with k as %d\n",optWinsize,opt.k);

   
   ReDim permutation(num_inf)
   Call IdentityPermutation(permutation, num_inf)
   orig_PHI = PHI(inc_matrix, inf_states, permutation, num_inf, k) '1790, 19
   
   If num_inf <= 2 * k Then
     
       valid_normal_approx = 0
'       fprintf(stdout, "Too few informative sites to use normal approximation.\nTry doing a permutation test or increasing alignment length\nCan also try decreasing windowsize.\n\n");
'       fprintf(logfile, "Too few informative sites to use normal approximation.\nTry doing a permutation test or increasing alignment length\nCan also try decreasing windowsize.\n\n");
     
   Else
     
       valid_normal_approx = 1
'       fprintf(stdout,"\nCalculating analytical mean and variance\n");
'       fprintf(logfile,"\nCalculating analytical mean and variance\n");
       
'       /* Fix argument with 1 */
      Call AnalyticMeanVariance(inc_matrix, inf_states, num_inf, k, mean, variance)
      
      difference = mean - orig_PHI
       '
       If variance > 0 Then
            normal_p_val = Normal01CDF((-difference) / Sqr(variance))
        Else
            normal_p_val = 1
        End If
      x = x
      'NPV = 0.462223
      'mean = 0.168634
      'variance = 1.54861x10-5
      
      'p = 0
      'm = 0.58623
      'var =6.675 x 10-6
      'var = 9.8267 x10-7
      x = x
     End If
   
'   If doPerm = 1 Then
''     {
''       if(opt.k >= num_inf)
''     {
''       error("Too few informative sites to test significance.  Try decreasing windowsize or increasing alignment length\n\n");
''     }
''       fprintf(stdout,"\nDoing permutation test for PHI\n");
''       fprintf(logfile,"\nDoing permutation test for PHI\n");
'        For I = 0 To opt.ntrials - 1
'           'for(i=0;i<opt.ntrials;i++)
'
'            '{
'              Call SamplePermutation(permutation, num_inf)
'              cur_PHI = PHI(inc_matrix, inf_states, permutation, num_inf, K)
'              If cur_PHI <= orig_PHI Then
'                emp_PHI = empPHI + 1
'              End If
'              sum_PHI = sum_PHI + cur_PHI
'              sum_sq_PHI = sum_sq_PHI + cur_PHI * cur_PHI
'
'            '}
'        Next I
'       obs_mean = sum_PHI / (CDbl(opt.ntrials))
'       obs_varnce = (sum_sq_PHI - opt.ntrials * obs_mean * obs_mean) / (opt.ntrials - 1)
'
' '    }
'   End If
   
   PHITest2 = normal_p_val
'   EE = abs(gettickcount)
'    TT = EE - SS '101151, 99.573, 99.404, 94.958, 76.144,75.146, 6.022, 4.820,4.352, 1.107
'
    '1.513
    'XX = num_inf
    '101.884 for 3200 seqs with 6000 informative sites
    '106.455, 103.241, 101.863, 100.636
   x = x
'   if(opt.otherStats)
'     {
'       /* For NSS */
'       fprintf(stdout,"\nDoing permutation test for NSS\n");
'       fprintf(logfile,"\nDoing permutation test for NSS\n");
'
'         identity_permutation(permutation,num_inf);
'
'       orig_NSS=NSS(inc_matrix,permutation,num_inf);
'       if(opt.verbose)
'     {
'       fprintf(stdout,"\nThe Neighbour Similarity score is %6.4le\n",orig_NSS);
'       fprintf(logfile,"\nThe Neighbour Similarity score is %6.4le\n",orig_NSS);
'     }
'
'       for(i=0;i<opt.ntrials;i++)
'     {
'       sample_permutation(permutation,num_inf);
'       cur_NSS=NSS(inc_matrix,permutation,num_inf);
'       if(cur_NSS >= orig_NSS)
'        emp_NSS++;
'     }
       
'       /* For Max Chi^2 */
'       windowScale=2.0/3.0;
'       maxchi(windowScale,opt.verbose,logfile,opt.inFile,alignment,site_desc,site_states,taxa_names,num_taxa,num_sites,opt.ntrials,&emp_MAXCHI);
'
'     }
'
'   if(opt.verbose)
'     {
'       fprintf(stdout,"\n                      PHI Values\n");
'       fprintf(stdout,"                      ----------\n");
'
'       fprintf(logfile,"\n                      PHI Values\n");
'       fprintf(logfile,"                      ----------\n");
'
'       if(!opt.doPerm)
'     i=0;
'       Else
'     i=opt.ntrials;
'
'       fprintf(stdout,"              Analytical    (%d) Permutations\n\n",i);
'       fprintf(logfile,"              Analytical    (%d) Permutations\n\n",i);
'
'       fprintf(stdout,"Mean:          ");
'       fprintf(logfile,"Mean:          ");
'
'       print_vals(logfile,valid_normal_approx,opt.doPerm,mean,obs_mean);
'
'       fprintf(stdout,"Variance:      ");
'       fprintf(logfile,"Variance:      ");
'
'       print_vals(logfile,valid_normal_approx,opt.doPerm,variance,obs_varnce);
'
'       fprintf(stdout,"Observed:      %4.2le          %4.2le   \n\n",orig_PHI,orig_PHI);
'        fprintf(logfile,"Observed:      %4.2le          %4.2le   \n\n",orig_PHI,orig_PHI);
'     }
'
'   if(opt.printMatrix)
'     {
'       fprintf(stdout, "\nOutputting incompatibility matrix to file matrix.ppm\n");
'       fprintf(logfile, "\nOutputting incompatibility matrix to file matrix.ppm\n");
'
'       create_incompat_pic(max_state,max_inc,inc_matrix,opt.embellish,num_inf);
'
'
'     }

'   fprintf(stdout,"\n     **p-Value(s)**     \n");
'   fprintf(stdout,"       ----------\n\n");
'
'
'   fprintf(logfile,"\n       p-Value(s)\n");
'   fprintf(logfile,"       ----------\n\n");
'
'
'   if(opt.otherStats)
'     {
'       val=((double)emp_NSS)/((double)(opt.ntrials));
'
'       fprintf(stdout,"NSS:                 %4.2le  (%d permutations)\n",val,opt.ntrials);
'       fprintf(logfile,"NSS:                 %4.2le  (%d permutations)\n",val,opt.ntrials);
'
'       val=((double)emp_MAXCHI)/((double)(opt.ntrials));
'
'       fprintf(stdout,"Max Chi^2:           %4.2le  (%d permutations)\n",val,opt.ntrials);
'       fprintf(logfile,"Max Chi^2:           %4.2le  (%d permutations)\n",val,opt.ntrials);
'
'     }
'   if(opt.doPerm)
'     {
'       val=((double)emp_PHI)/((double)(opt.ntrials));
'       fprintf(stdout,"PHI (Permutation):   %4.2le  (%d permutations)\n",val,opt.ntrials);
'       fprintf(logfile,"PHI (Permutation):   %4.2le  (%d permutations)\n",val,opt.ntrials);
'     }
'
'   if(valid_normal_approx)
'     {
'       fprintf(stdout,"PHI (Normal):        %4.2le\n",normal_p_val);
'       fprintf(logfile,"PHI (Normal):        %4.2le\n",normal_p_val);
'     }
'   Else
'     {
'       fprintf(stdout,"PHI (Normal):        --\n");
'       fprintf(logfile,"PHI (Normal):        --\n");
'     }
'
'
'   fprintf(stdout,"\n");
'   fprintf(logfile,"\n");
'   fclose(logfile);
''   return 0;
'
'}


End Function
Public Sub MakeQis(x As Long, Xis() As Byte)
    Dim A As Byte
    A = x
    Xis(0) = 0
    Xis(1) = 0
    Xis(2) = 0
    Xis(3) = 0
    If A = 128 Then
    x = x
    End If
    'first position
    If Int(A / 128) > 0 Then
        Xis(0) = 2
        A = A - 128
        If Int(A / 64) > 0 Then
            A = A - 64
        End If
    ElseIf Int(A / 64) > 0 Then
        Xis(0) = 1
        A = A - 64
    End If
    'second position
    If Int(A / 32) > 0 Then
        Xis(1) = 2
        A = A - 32
        If Int(A / 16) > 0 Then
            A = A - 16
        End If
    ElseIf Int(A / 16) > 0 Then
        Xis(1) = 1
        A = A - 16
    End If
    
    'third position
    If Int(A / 8) > 0 Then
        Xis(2) = 2
        A = A - 8
        If Int(A / 4) > 0 Then
            A = A - 4
        End If
    ElseIf Int(A / 4) > 0 Then
        Xis(2) = 1
        A = A - 4
    End If
    
    'fourth position
    If Int(A / 2) > 0 Then
        Xis(3) = 2
        A = A - 2
        If Int(A) > 0 Then
            A = A - 1
        End If
    ElseIf Int(A) > 0 Then
        Xis(3) = 1
        
    End If
x = x
End Sub
Public Sub MakeQis3(x As Long, Xis() As Byte)
    Dim A As Byte
    A = x
    Xis(0) = 0
    Xis(1) = 0
    Xis(2) = 0
   
    
    
    'second position
    If Int(A / 32) > 0 Then
        Xis(0) = 2
        A = A - 32
        If Int(A / 16) > 0 Then
            A = A - 16
        End If
    ElseIf Int(A / 16) > 0 Then
        Xis(0) = 1
        A = A - 16
    End If
    
    'third position
    If Int(A / 8) > 0 Then
        Xis(1) = 2
        A = A - 8
        If Int(A / 4) > 0 Then
            A = A - 4
        End If
    ElseIf Int(A / 4) > 0 Then
        Xis(1) = 1
        A = A - 4
    End If
    
    'fourth position
    If Int(A / 2) > 0 Then
        Xis(2) = 2
        A = A - 2
        If Int(A) > 0 Then
            A = A - 1
        End If
    ElseIf Int(A) > 0 Then
        Xis(2) = 1
        
    End If
x = x
End Sub
Public Sub DoKeydown(KeyCode)

Dim VSV As Long
'P1Seq = -1
'P1NT = -1
'f2p2y = -1
'oP7XP = -1
If KeyCode = vbKeyF Or KeyCode = vbKeyControl Then
    If GetAsyncKeyState(vbKeyF) < 0 And GetAsyncKeyState(vbKeyControl) < 0 Then
        Call FindSequences
    End If
End If

If KeyCode = vbKeyZ Or KeyCode = vbKeyControl Then
    If GetAsyncKeyState(vbKeyZ) < 0 And GetAsyncKeyState(vbKeyControl) < 0 Then
         Dim OMP As Long
         OMP = Screen.MousePointer
         Form1.SSPanel1.Caption = "Undoing last change"
         Screen.MousePointer = 11
         Call UpdateF2Prog
         Form1.WindowState = Form1.WindowState

         If UndoSlot = LatestSlot Then
            Call SaveUndo
            'UndoSlot = UndoSlot - 1
         End If
'        If UndoSlot = LatestSlot Then
'            UndoSlot = UndoSlot + 1
'            If UndoSlot > MaxUndos Then
'                UndoSlot = 0
'            End If
'            Dummy = MsgBox("I can't remember anything from before")
'        Else
            
        'End If
        UndoSlot = UndoSlot - 1
        If UndoSlot < 1 Then
            If UndoCycle > 0 Then
                UndoSlot = MaxUndos
                UndoCycle = UndoCycle - 1
            Else
                Dummy = MsgBox("I can't remember anything from before")
                UndoSlot = 1
                Screen.MousePointer = OMP
                Form1.SSPanel1.Caption = ""
                Call UpdateF2Prog
                P2KC = -1
                Exit Sub
            End If
        ElseIf UndoSlot = LatestSlot Then
            UndoSlot = UndoSlot + 1
            Dummy = MsgBox("I can't remember anything from before")
            Screen.MousePointer = OMP
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            P2KC = -1
            Exit Sub
        End If
        Call DoUndo
        
        Screen.MousePointer = OMP
        P2KC = -1
        Exit Sub
    ElseIf KeyCode = vbKeyZ Then
        x = x
    End If
End If

If KeyCode = vbKeyY Or KeyCode = vbKeyControl Then
    If GetAsyncKeyState(vbKeyY) < 0 And GetAsyncKeyState(vbKeyControl) < 0 Then
        
        If UndoSlot = LatestSlot Then
            Dummy = MsgBox("I can't remember what you did next")
            Exit Sub
        Else
            UndoSlot = UndoSlot + 1
            If UndoSlot > MaxUndos Then
                
                UndoSlot = 1
                UndoCycle = UndoCycle + 1
                
            End If
            
            Call DoUndo
            x = x
            If UndoSlot = LatestSlot Then
                UndoSlot = UndoSlot - 1
                If UndoSlot < 1 Then
                    If UndoCycle > 0 Then
                        UndoSlot = MaxUndos
                        UndoCycle = UndoCycle - 1
                    End If
                End If
                LatestSlot = UndoSlot
                Exit Sub
            End If
            
        End If
        Exit Sub
    End If
End If



If F2P2Y > -1 Then

    If KeyCode = vbKeyUp Then
        Call TreeZoom(1)
    ElseIf KeyCode = vbKeyDown Then
        Call TreeZoom(0)
    End If
    'P2KC = -1
    'Exit Sub
 ElseIf F1P7X > -1 Then
    If KeyCode = vbKeyAdd Or KeyCode = vbKeyUp Then
        lP7XP = 0
        p7CurWinSize = Recompress(GYAxHi(1) / 8)
        P7ZoomLevel = P7ZoomLevel + 2
        If P7ZoomLevel > 50 Then P7ZoomLevel = 50
        P7XP = oP7XP
        Call RedrawPlotAA(1)
        Form1.Picture7.Refresh
        P7XP = 0
    ElseIf KeyCode = vbKeySubtract Or KeyCode = vbKeyDown Then
        lP7XP = 0
        p7CurWinSize = Recompress(GYAxHi(1) / 8)
        P7ZoomLevel = P7ZoomLevel - 2
        If P7ZoomLevel = 0 Then P7ZoomLevel = 0
        P7XP = oP7XP
        Call RedrawPlotAA(1)
        Form1.Picture7.Refresh
        P7XP = 0
    End If
ElseIf P1Seq > -1 Then
    'DontRefreshP1 = 1
    If KeyCode = vbKeyDown Then
    'Call Command33_Click(1)
        Call DoSeqZoom(0)
    ElseIf KeyCode = vbKeyUp Then
        'Call Command33_Click(0)
        Call DoSeqZoom(1)
    End If
ElseIf F1P2Y > -1 Then
    If Form1.VScroll4.Max < 0 Then Form1.VScroll4.Max = 0
    VSV = Form1.VScroll4.Value
    If KeyCode = vbKeyDown Then
        VSV = VSV + 15
    ElseIf KeyCode = vbKeyUp Then
        VSV = VSV - 15
    End If
    If VSV > Form1.VScroll4.Max Then
        VSV = Form1.VScroll4.Max
    ElseIf VSV < 0 Then
        VSV = 0
    End If
   ' XX = VS4Max
    Form1.VScroll4.Value = VSV
ElseIf F1P3Y > -1 Then
    VSV = Form1.VScroll3.Value
    If KeyCode = vbKeyDown Then
        VSV = VSV + 15
    ElseIf KeyCode = vbKeyUp Then
        VSV = VSV - 15
    End If
    If VSV > Form1.VScroll3.Max Then
        VSV = Form1.VScroll3.Max
    ElseIf VSV < 0 Then
        VSV = 0
    End If
    Form1.VScroll3.Value = VSV
ElseIf F1P6Y > -1 Then
    VSV = Form1.VScroll2.Value
    If KeyCode = vbKeyDown Then
        VSV = VSV + 15
    ElseIf KeyCode = vbKeyUp Then
        VSV = VSV - 15
    End If
    If VSV > Form1.VScroll2.Max Then
        VSV = Form1.VScroll2.Max
    ElseIf VSV < 0 Then
        VSV = 0
    End If
    Form1.VScroll2.Value = VSV
ElseIf F2P3Y > -1 Then
    VSV = Form2.VScroll1(F2P3Y).Value
    If KeyCode = vbKeyDown Then
        VSV = VSV + 30
    ElseIf KeyCode = vbKeyUp Then
        VSV = VSV - 30
    End If
    XX = Form2.VScroll1(F2P3Y).Max
    If VSV > Form2.VScroll1(F2P3Y).Max And Form2.VScroll1(F2P3Y).Max > 0 Then
        VSV = Form2.VScroll1(F2P3Y).Max
    ElseIf VSV < 0 Then
        VSV = 0
    End If
    Form2.VScroll1(F2P3Y).Value = VSV
ElseIf F1P16Y > -1 Then
    If Form1.VScroll1.Enabled = False Then 'this will zoom
        If KeyCode = vbKeyUp Then
            Call TreeZoom(1)
        ElseIf KeyCode = vbKeyDown Then
            Call TreeZoom(0)
        End If
    Else
    'this will scroll instead of zoom
        VSV = Form1.VScroll1.Value
        If KeyCode = vbKeyDown Then
            VSV = VSV + 15
        ElseIf KeyCode = vbKeyUp Then
            VSV = VSV - 15
        End If
        If VSV > Form1.VScroll1.Max Then
            VSV = Form1.VScroll1.Max
        ElseIf VSV < 0 Then
            VSV = 0
        End If
        Form1.VScroll1.Value = VSV
    End If
ElseIf F1P26Y > -1 Then
    'If Form1.VScroll1.Enabled = False Then 'this will zoom
    DontResetFocus = 1
    If KeyCode = vbKeyUp Then
        Call DoMatrixZoom(1)
    ElseIf KeyCode = vbKeyDown Then
        Call DoMatrixZoom(0)
    End If
    DontResetFocus = 0
    'Form1.Timer3.Enabled = False
'    If Form2.WindowState = 0 Then
'        Form2.Picture2(0).SetFocus
'    Else
'        Form1.Picture6.SetFocus
'    End If
    'Else
End If

End Sub

Public Sub DoMatrixZoom(Index As Integer)
Dim SS As Long, EE As Long, TT As Long
Dim TDist(1) As Double, ScrollPos(1) As Long, UB As Long
Dim RealZoom As Single

Dim MidPixelH As Single, MidPixelV As Single, oMidPixelH As Single, oMidPixelV As Single, MidHorizontal As Single, MidVertical As Single, oMidHorizontal As Single, oMidVertical As Single, nMidHorizontal As Single, nMidVertical As Single
Dim MidPixelPosX As Single, MidPixelPosY As Single, OffXAddj As Single, OffYAddj As Single
Dim oMidPixelPosX As Single, oMidPixelPosY As Single, oOffXAddj As Single, oOffYAddj As Single
ButtonScrollFlag = 1
ohm = Form1.HScroll4.Max

If CurMatrixFlag = 2 Then
    UB = (UBound(MatrixM, 1) - 1)
ElseIf CurMatrixFlag = 1 Then
        UB = (UBound(MatrixR, 1) - 1)
ElseIf CurMatrixFlag = 0 Then
        UB = (UBound(MatrixC, 1) - 1)
ElseIf CurMatrixFlag = 14 Then
        UB = (UBound(MatrixTB, 1) - 1)
ElseIf CurMatrixFlag = 3 Then
        UB = (UBound(MatrixRR, 1) - 1)
ElseIf CurMatrixFlag = 4 Then
        UB = (UBound(MatrixBP, 1) - 1)
ElseIf CurMatrixFlag = 5 Then
    UB = UBound(MatrixLD, 1) - 1
ElseIf CurMatrixFlag = 6 Then
    UB = UBound(MatrixRMin, 1) - 1
ElseIf CurMatrixFlag = 7 Then
    UB = UBound(MatrixRMinD, 1) - 1
ElseIf CurMatrixFlag = 8 Then
    UB = UBound(MatrixMC, 1) - 1
ElseIf CurMatrixFlag = 11 Then
    UB = UBound(MatrixL, 1) - 1
ElseIf CurMatrixFlag = 12 Then

    UB = UBound(MatrixSH, 1) - 1
ElseIf CurMatrixFlag = 13 Then

    UB = UBound(MatrixRF, 1) - 1
End If
Dim oVH As Single, oVV As Single, nVH As Single, nVV As Single
oVH = Form1.HScroll4.Value
oVV = Form1.VScroll5.Value
If CurMatrixFlag = 255 Then Exit Sub
oMidHorizontal = ((UB / 2) / MatZoom(CurMatrixFlag)) '(UB - (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))) / 2
'XX = (UB - (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))) / 2
oMidVertical = (UB / 2) / MatZoom(CurMatrixFlag) '(UB - (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))) / 2
If MatZoom(CurMatrixFlag) = 1 Then
    Form1.HScroll4.Max = 0
    Form1.VScroll5.Max = 0
End If

Dim MousePixelX As Single, MousePixelY As Single
If F1P26Y > -1 Then
    MousePixelX = F1P26PX + MatCoord(CurMatrixFlag, 0) 'Form1.HScroll4.Value / UB '((F1P26X / MatZoom(CurMatrixFlag) + Form1.HScroll4.Value) / MatZoom(CurMatrixFlag))
    MousePixelY = F1P26PY + MatCoord(CurMatrixFlag, 1) 'F1P26Y / MatZoom(CurMatrixFlag) + Form1.VScroll5.Value
End If

oMidPixelH = ActualMidPixelH
    

oMidPixelV = ActualMidPixelV
    
'XX = CurMatrixFlag
'If CLine = "" Or CLine = " " Then
'    Form1.Command3.SetFocus
'End If
If Index = 0 Then
    DontDoKey = 1
    DoVS5 = 1
    
'    If Form1.Timer3.Enabled = False Then
'        Form1.Command3.SetFocus
'    End If
    If MatZoom(CurMatrixFlag) = 1 Then
        Form1.Timer3.Enabled = False
        Form1.Command39(0).Enabled = False
        Exit Sub
    End If

'     If MatZoomMod(CurMatrixFlag) >= 1 And X = 1234567 Then
'         MatZoomMod(CurMatrixFlag) = MatZoomMod(CurMatrixFlag) - 1
'         If MatZoomMod(CurMatrixFlag) > 0 Then
'             MatZoom(CurMatrixFlag) = (UB / Form1.Picture26.ScaleWidth) / (1 / MatZoomMod(CurMatrixFlag)) '((UB / ((Form1.Picture26.ScaleWidth / UB) / MatZoomMod(CurMatrixFlag))) / UB)
'         Else
'             MatZoom(CurMatrixFlag) = (UB / Form1.Picture26.ScaleWidth)
'         End If
'     Else
         MatZoom(CurMatrixFlag) = MatZoom(CurMatrixFlag) - 0.25
'     End If
     
     
    If MatZoomMod(CurMatrixFlag) < 0 Then MatZoomMod(CurMatrixFlag) = 0
    
    If MatZoom(CurMatrixFlag) < 1 Or MatZoom(CurMatrixFlag) = 1 Then
        MatZoom(CurMatrixFlag) = 1
        Form1.Command39(0).Enabled = False
        Form1.Timer3.Enabled = False
        'VScroll5.Enabled = False
        'HScroll4.Enabled = False
    End If
    'Exit Sub
    'command39(1).Enabled = True
    If (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 32000 And (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight > 0 Then
        Form1.VScroll5.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        Form1.HScroll4.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        
       ' Form1.VScroll5.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
       ' Form1.HScroll4.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
    ElseIf (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 1 Then
        Form1.HScroll4.Max = 0: Form1.HScroll4.Enabled = False
        Form1.VScroll5.Max = 0: Form1.VScroll5.Enabled = False
    Else
        Form1.VScroll5.Max = 32000
        Form1.HScroll4.Max = 32000
        MatZoom(CurMatrixFlag) = (Form1.HScroll4.Max + Form1.Picture26.ScaleHeight) / (Form1.Picture26.ScaleHeight * 2)
    End If
    If Form1.VScroll5.Max < 1 Then
        Form1.VScroll5.Max = 0
    End If
    If Form1.HScroll4.Max < 1 Then
        Form1.HScroll4.Max = 0
    End If
    If Form1.HScroll4.Enabled = True Then
        Form1.HScroll4.LargeChange = Form1.HScroll4.Max / MatZoom(CurMatrixFlag)
        Form1.HScroll4.SmallChange = CLng(MatZoom(CurMatrixFlag) * 4)
    End If
    If Form1.VScroll5.Enabled = True Then
        Form1.VScroll5.LargeChange = Form1.VScroll5.Max / MatZoom(CurMatrixFlag)
        Form1.VScroll5.SmallChange = CLng(MatZoom(CurMatrixFlag) * 4)
    End If
           
        
        If Form1.HScroll4.Max > 0 Then
            TDist(0) = (Form1.HScroll4.Value / Form1.HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
        Else
            TDist(0) = 0
        End If
        If Form1.VScroll5.Max > 0 Then
            TDist(1) = (Form1.VScroll5.Value / Form1.VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
        Else
            TDist(1) = 0
        End If
        
        If TDist(0) <= 1 And TDist(0) >= 0 Then
            Form1.HScroll4.Value = TDist(0) * Form1.HScroll4.Max
        ElseIf TDist(0) < 0 Then
            Form1.HScroll4.Value = 0
            Form1.Command39(1).Enabled = False
            Form1.Timer3.Enabled = False
        
        End If
'        DoVS5 = 1
'
'
'    If F1P26Y > -1 Then
'        '45,70
''        XX = XDiffPos(45)
''        XX = XPosDiff(70)
'        XX = (UB * MatZoom(CurMatrixFlag))
'    Else
'        nMidHorizontal = ((UB / 2) / MatZoom(CurMatrixFlag)) 'oMidHorizontal / MatZoom(CurMatrixFlag)
'        nMidVertical = ((UB / 2) / MatZoom(CurMatrixFlag)) 'oMidVertical / MatZoom(CurMatrixFlag)
'        MidPixelH = oMidPixelH - nMidHorizontal
'        MidPixelV = oMidPixelV - nMidVertical
'    End If
'
'        'XX = XPosDiff(342)
'        'XX = XPosDiff(429)
'
'    If MidPixelH < 0 Then
'        MidPixelH = 0
'    ElseIf MidPixelH + nMidHorizontal > UB Then
'        MidPixelH = UB - nMidHorizontal
'    End If
'    If MidPixelV < 0 Then
'        MidPixelV = 0
'    ElseIf MidPixelV + nMidVertical > UB Then
'        MidPixelV = UB - nMidVertical
'    End If
'
''    nVH = (HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
''    nVV = (VScroll5.Value / VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
'
'
'
'
'     If Form1.HScroll4.Max > 0 Then
'        nVH = ((MidPixelH * MatZoom(CurMatrixFlag)) / (UB * (MatZoom(CurMatrixFlag) - 1))) * Form1.HScroll4.Max ' / MatZoom(CurMatrixFlag) * HScroll4.Max
'        If nVH > Form1.HScroll4.Max Then nVH = Form1.HScroll4.Max
'        Form1.HScroll4.Value = CLng(nVH)
'        'HScroll4.Value = MidHorizontal / UB * HScroll4.Max '(MidHorizontal / ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)) * HScroll4.Max
'    End If
'    If Form1.VScroll5.Max > 0 Then
'        nVV = ((MidPixelV * MatZoom(CurMatrixFlag)) / (UB * (MatZoom(CurMatrixFlag) - 1))) * Form1.VScroll5.Max
'        If nVV > Form1.HScroll4.Max Then nVV = Form1.VScroll5.Max
'        Form1.VScroll5.Value = CLng(nVV)
'        'VScroll5.Value = MidVertical / UB * VScroll5.Max '(MidVertical / ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)) * VScroll5.Max
'    End If
'
'    DoVS5 = 0
'
'    If CurMatrixFlag = 0 Then
'        DontDoKey = 2
'    End If
'    If Form1.HScroll4.Value > 0 Then
'        H1C = 1
'        Form1.HScroll4.Value = Form1.HScroll4.Value - 1
'        H1C = 0
'        Form1.HScroll4.Value = Form1.HScroll4.Value + 1
'    ElseIf Form1.HScroll4.Max > 0 Then
'        H1C = 1
'        Form1.HScroll4.Value = Form1.HScroll4.Value + 1
'        H1C = 0
'        Form1.HScroll4.Value = Form1.HScroll4.Value - 1
'    End If
'    'Call HScroll4_Change
'    If CurMatrixFlag = 0 Then
'        DontDoKey = 1
'    End If
'    DontDoKey = 0
Else 'zoom in
    

    If (MatZoom(CurMatrixFlag) + 1) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight > 32000 Then
        Form1.Timer3.Enabled = False
        Form1.Command39(1).Enabled = False
        Exit Sub
    End If
    
    
'    If Form1.Timer3.Enabled = False Then
'        Form1.Command3.SetFocus
'    End If
    DontDoKey = 1
    Form1.Command39(0).Enabled = True
    
    'MatZoom(12) = 1
'    If HScroll4.Max > 0 Then
'        TDist(0) = (HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
'    Else
'        TDist(0) = 0
'    End If
'    If VScroll5.Max > 0 Then
'        TDist(1) = (VScroll5.Value / VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
'    Else
'        TDist(1) = 0
'    End If
    
    'XX = Form1.Picture26.ScaleHeight
    'XX = Form1.Picture26.ScaleWidth
    
    RealZoom = (UB / (MatZoom(CurMatrixFlag) + 0.5)) / Form1.Picture26.ScaleHeight
    
Redo:
    If RealZoom <= 1 And CurMatrixFlag <> 13 And x = 12345 Then
        MatZoomMod(CurMatrixFlag) = MatZoomMod(CurMatrixFlag) + 1
        MatZoom(CurMatrixFlag) = (UB / Form1.Picture26.ScaleHeight) / (1 / MatZoomMod(CurMatrixFlag)) '((UB / ((Form1.Picture26.ScaleWidth / UB) / MatZoomMod(CurMatrixFlag))) / UB)
        If (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) * 2 - Form1.Picture26.ScaleHeight > 32000 Then
            MatZoomMod(CurMatrixFlag) = MatZoomMod(CurMatrixFlag) - 2
            GoTo Redo
        End If
    
    Else
        MatZoom(CurMatrixFlag) = MatZoom(CurMatrixFlag) + 0.25
    End If
    'realzoom = (UB / MatZoom(CurMatrixFlag)) / Form1.Picture26.ScaleWidth
    'nMidHorizontal = oMidHorizontal / MatZoom(CurMatrixFlag)
    'nMidVertical = oMidVertical / MatZoom(CurMatrixFlag)
    
    Form1.VScroll5.Enabled = True
    Form1.HScroll4.Enabled = True
    DoVS5 = 1
    If (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 32000 And (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight > 0 Then
        Form1.VScroll5.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        Form1.HScroll4.Max = MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight
        
       ' Form1.VScroll5.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
       ' Form1.HScroll4.Max = (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight
    ElseIf (MatZoom(CurMatrixFlag) * Form1.Picture26.ScaleHeight) - Form1.Picture26.ScaleHeight < 1 Then
        Form1.HScroll4.Max = 0: Form1.HScroll4.Enabled = False
        Form1.VScroll5.Max = 0: Form1.VScroll5.Enabled = False
    Else
        Form1.VScroll5.Max = 32000
        Form1.HScroll4.Max = 32000
        MatZoom(CurMatrixFlag) = (Form1.HScroll4.Max + Form1.Picture26.ScaleHeight) / (Form1.Picture26.ScaleHeight * 2)
    End If
    If Form1.VScroll5.Max < 1 Then
        Form1.VScroll5.Max = 0
    End If
    If Form1.HScroll4.Max < 1 Then
        Form1.HScroll4.Max = 0
    End If
    
    If Form1.VScroll5.Max > 1 Then
        Form1.HScroll4.LargeChange = Form1.HScroll4.Max / MatZoom(CurMatrixFlag)
        Form1.VScroll5.LargeChange = Form1.VScroll5.Max / MatZoom(CurMatrixFlag)
        Form1.HScroll4.SmallChange = CLng(MatZoom(CurMatrixFlag) * 4)
        Form1.VScroll5.SmallChange = CLng(MatZoom(CurMatrixFlag) * 4)
    End If
    
    
    If Form1.HScroll4.Max > 0 Then
        TDist(0) = (Form1.HScroll4.Value / Form1.HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
    Else
        TDist(0) = 0
    End If
    If Form1.VScroll5.Max > 0 Then
        TDist(1) = (Form1.VScroll5.Value / Form1.VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
    Else
        TDist(1) = 0
    End If
    
    If TDist(0) <= 1 And TDist(0) >= 0 Then
        Form1.HScroll4.Value = TDist(0) * Form1.HScroll4.Max
    ElseIf TDist(0) < 0 Then
        Form1.HScroll4.Value = 0
        Form1.Command39(1).Enabled = False
        Form1.Timer3.Enabled = False
    End If


End If

    DoVS5 = 1
'    If TDist(1) <= 1 And TDist(1) >= 0 Then
'        VScroll5.Value = TDist(1) * VScroll5.Max
'    ElseIf TDist(1) < 0 Then
'        VScroll5.Value = 0
'        Command39(1).Enabled = False
'        Timer3.Enabled = False
'    End If
'MidHorizontal = (HScroll4.Value / HScroll4.Max) * (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))
    'MidHorizontal = MidHorizontal + (UB - (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))) / 2
    'MidHorizontal = MidHorizontal - (UB - (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))) / 2
    'MidVertical = MidVertical - (UB - (((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))) / 2
    
    
    If F1P26Y > -1 Then ' need to work out the midpixel in relation to the selected pixel so that we actually zoom to the pixel under the pointer
        XX = F1P26PX
        XX = F1P26PY
        MidPixelPosX = Form1.Picture26.ScaleHeight / 2
        MidPixelPosY = Form1.Picture26.ScaleHeight / 2
        OffXAddj = CLng((F1P26X - MidPixelPosX) * ((UB / Form1.Picture26.ScaleHeight) / MatZoom(CurMatrixFlag)))
        OffYAddj = CLng((F1P26Y - MidPixelPosY) * ((UB / Form1.Picture26.ScaleHeight) / MatZoom(CurMatrixFlag)))
        nMidHorizontal = ((UB / 2) / MatZoom(CurMatrixFlag)) 'oMidHorizontal / MatZoom(CurMatrixFlag)
        nMidVertical = ((UB / 2) / MatZoom(CurMatrixFlag)) 'oMidVertical / MatZoom(CurMatrixFlag)
        MidPixelH = CLng(F1P26PX - nMidHorizontal - OffXAddj)
        MidPixelV = CLng(F1P26PY - nMidVertical - OffYAddj)
        x = x
        ' x-position in matcoord=(HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
    Else
        nMidHorizontal = ((UB / 2) / MatZoom(CurMatrixFlag)) 'oMidHorizontal / MatZoom(CurMatrixFlag)
        nMidVertical = ((UB / 2) / MatZoom(CurMatrixFlag)) 'oMidVertical / MatZoom(CurMatrixFlag)
        MidPixelH = oMidPixelH - nMidHorizontal
        MidPixelV = oMidPixelV - nMidVertical
    End If
    If MidPixelH < 0 Then
        MidPixelH = 0
    ElseIf MidPixelH + nMidHorizontal > UB Then
        MidPixelH = UB - nMidHorizontal
    End If
    If MidPixelV < 0 Then
        MidPixelV = 0
    ElseIf MidPixelV + nMidVertical > UB Then
        MidPixelV = UB - nMidVertical
    End If
'    nVH = (HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
'    nVV = (VScroll5.Value / VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
    
    If MatZoom(CurMatrixFlag) = 1 Then
        nVH = 0
        nVV = 0
    Else
        If F1P26Y > -1 Then
            'iteratively adjust hscroll4 until mousepointer is over f1p26px
            Dim Tcoord As Long, AddjV As Single, AddonX As Long, AddonY As Long, XC As Single, XP As Single, YP As Single, YC As Single, TU As Long, TD As Long
            
            'I must update hscrollmaxes first
'            DoVS5 = 1
'            If Form1.VScroll5.Value > 0 Then
'                Form1.VScroll5.Value = Form1.VScroll5.Value - 1
'
'            ElseIf Form1.VScroll5.Value < Form1.VScroll5.Max Then
'                Form1.VScroll5.Value = Form1.VScroll5.Value + 1
'            End If
XX = ohm
            nVH = CLng(((MidPixelH * MatZoom(CurMatrixFlag)) / (UB * (MatZoom(CurMatrixFlag) - 1))) * Form1.HScroll4.Max)
            AddjV = (UB / Form1.Picture26.ScaleHeight)
           TU = 0
           TD = 0
            onvh = nVH
            
            'nVH = nVH - Form1.HScroll4.SmallChange
            Do
                ' / MatZoom(CurMatrixFlag) * HScroll4.Max
                'If nVH > Form1.HScroll4.Max Then nVH = Form1.HScroll4.Max
                'Form1.HScroll4.Value = CLng(nVH)
                Tcoord = CLng((nVH / Form1.HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))
                
                
                AddonX = (Tcoord * MatZoom(CurMatrixFlag)) / AddjV
                'AddonY = (MatCoord(CurMatrixFlag, 1) * MatZoom(CurMatrixFlag)) / AddjV
                'XX = MatCoord(CurMatrixFlag, 0)
                XC = (F1P26X + AddonX) / ((Form1.Picture26.ScaleHeight) * MatZoom(CurMatrixFlag))  'CLng((X / Picture26.ScaleHeight) * ((UBound(MatrixM, 1)-1) - 1))
                'YC = (F1P26Y + AddonY) / ((Picture26.ScaleHeight) * MatZoom(CurMatrixFlag)) 'CLng((Y / Picture26.ScaleWidth) * ((UBound(MatrixM, 1)-1) - 1))
                
                XP = CLng((XC * UB) - 0.5) + 1
                'YP = CLng((YC * UB) - 0.5) + 1
                If CLng(F1P26PX) > CLng(XP) Then
                    nVH = nVH + 1
                    TU = TU + 1
                ElseIf CLng(F1P26PX) < CLng(XP) Then
                    nVH = nVH - 1
                    TD = TD + 1
                Else
                    Exit Do
                End If
                If TU > 2 And TD > 2 Then
                    Exit Do
                End If
            Loop
'            lnvh = nVH
'            nVH = onvh
'             nVH = nVH + Form1.HScroll4.SmallChange
'
'             TU = 0
'             TD = 0
'            Do
'                ' / MatZoom(CurMatrixFlag) * HScroll4.Max
'                'If nVH > Form1.HScroll4.Max Then nVH = Form1.HScroll4.Max
'                'Form1.HScroll4.Value = CLng(nVH)
'                Tcoord = CLng((nVH / Form1.HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))
'
'
'                AddonX = (Tcoord * MatZoom(CurMatrixFlag)) / AddjV
'                'AddonY = (MatCoord(CurMatrixFlag, 1) * MatZoom(CurMatrixFlag)) / AddjV
'                'XX = MatCoord(CurMatrixFlag, 0)
'                XC = (F1P26X + AddonX) / ((Form1.Picture26.ScaleWidth - MatZoom(CurMatrixFlag)) * MatZoom(CurMatrixFlag)) 'CLng((X / Picture26.ScaleHeight) * ((UBound(MatrixM, 1)-1) - 1))
'                'YC = (F1P26Y + AddonY) / ((Picture26.ScaleHeight) * MatZoom(CurMatrixFlag)) 'CLng((Y / Picture26.ScaleWidth) * ((UBound(MatrixM, 1)-1) - 1))
'
'                XP = CLng((XC * UB) - 0.5) + 1
'                'YP = CLng((YC * UB) - 0.5) + 1
'                If CLng(F1P26PX) > CLng(XP) Then
'                    nVH = nVH + 1
'                    TU = TU + 1
'                ElseIf CLng(F1P26PX) < CLng(XP) Then
'                    nVH = nVH - 1
'                    TD = TD + 1
'                Else
'                    Exit Do
'                End If
'                If TU > 2 And TD > 2 Then
'                    Exit Do
'                End If
'            Loop
'
'            nVH = (lnvh + (nVH - lnvh) / 2)
'            nVH = nVH - (Form1.HScroll4.SmallChange)
            nVV = CLng(((MidPixelV * MatZoom(CurMatrixFlag)) / (UB * (MatZoom(CurMatrixFlag) - 1))) * Form1.VScroll5.Max)
            onvv = nVV
            'nVV = nVV - Form1.VScroll5.SmallChange
            TU = 0
            TD = 0
            Do
                ' / MatZoom(CurMatrixFlag) * HScroll4.Max
                'If nVH > Form1.HScroll4.Max Then nVH = Form1.HScroll4.Max
                'Form1.HScroll4.Value = CLng(nVH)
                Tcoord = CLng((nVV / Form1.VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))
                
                
                'AddonX = (MatCoord(CurMatrixFlag, 0) * MatZoom(CurMatrixFlag)) / AddjV
                AddonY = CLng((Tcoord * MatZoom(CurMatrixFlag)) / AddjV)
                'XX = MatCoord(CurMatrixFlag, 0)
                'XC = (F1P26X + AddonX) / ((Picture26.ScaleWidth) * MatZoom(CurMatrixFlag)) 'CLng((X / Picture26.ScaleHeight) * ((UBound(MatrixM, 1)-1) - 1))
                YC = (F1P26Y + AddonY) / ((Form1.Picture26.ScaleHeight) * MatZoom(CurMatrixFlag))  'CLng((Y / Picture26.ScaleWidth) * ((UBound(MatrixM, 1)-1) - 1))
                
                'XP = CLng((XC * UB) - 0.5) + 1
                YP = CLng((YC * UB) - 0.5) + 1
                If CLng(F1P26PY) > CLng(YP) Then
                    nVV = nVV + 1
                    TU = TU + 1
                ElseIf CLng(F1P26PY) < CLng(YP) Then
                    nVV = nVV - 1
                    TD = TD + 1
                Else
                    Exit Do
                End If
                If TU > 2 And TD > 2 Then
                    Exit Do
                End If
            Loop
'            lnvv = nVV
'            nVV = onvv
'            nVV = nVV + Form1.VScroll5.SmallChange
'            TU = 0
'            TD = 0
'            Do
'                ' / MatZoom(CurMatrixFlag) * HScroll4.Max
'                'If nVH > Form1.HScroll4.Max Then nVH = Form1.HScroll4.Max
'                'Form1.HScroll4.Value = CLng(nVH)
'                Tcoord = CLng((nVV / Form1.VScroll5.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag))
'
'
'                'AddonX = (MatCoord(CurMatrixFlag, 0) * MatZoom(CurMatrixFlag)) / AddjV
'                AddonY = CLng((Tcoord * MatZoom(CurMatrixFlag)) / AddjV)
'                'XX = MatCoord(CurMatrixFlag, 0)
'                'XC = (F1P26X + AddonX) / ((Picture26.ScaleWidth) * MatZoom(CurMatrixFlag)) 'CLng((X / Picture26.ScaleHeight) * ((UBound(MatrixM, 1)-1) - 1))
'                YC = (F1P26Y + AddonY) / ((Form1.Picture26.ScaleHeight - MatZoom(CurMatrixFlag)) * MatZoom(CurMatrixFlag)) 'CLng((Y / Picture26.ScaleWidth) * ((UBound(MatrixM, 1)-1) - 1))
'
'                'XP = CLng((XC * UB) - 0.5) + 1
'                YP = CLng((YC * UB) - 0.5) + 1
'                If CLng(F1P26PY) > CLng(YP) Then
'                    nVV = nVV + 1
'                    TU = TU + 1
'                ElseIf CLng(F1P26PY) < CLng(YP) Then
'                    nVV = nVV - 1
'                    TD = TD + 1
'                Else
'                    Exit Do
'                End If
'                If TU > 2 And TD > 2 Then
'                    Exit Do
'                End If
'            Loop
'            nVV = lnvv + (nVV - lnvv) / 2
            ' x-position in matcoord=(HScroll4.Value / HScroll4.Max) * ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)
        Else
            If Form1.HScroll4.Max > 0 Then
                nVH = ((MidPixelH * MatZoom(CurMatrixFlag)) / (UB * (MatZoom(CurMatrixFlag) - 1))) * Form1.HScroll4.Max ' / MatZoom(CurMatrixFlag) * HScroll4.Max
                
                
                'HScroll4.Value = MidHorizontal / UB * HScroll4.Max '(MidHorizontal / ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)) * HScroll4.Max
            End If
            If Form1.VScroll5.Max > 0 Then
                nVV = ((MidPixelV * MatZoom(CurMatrixFlag)) / (UB * (MatZoom(CurMatrixFlag) - 1))) * Form1.VScroll5.Max
                
                
                'VScroll5.Value = MidVertical / UB * VScroll5.Max '(MidVertical / ((UB * (MatZoom(CurMatrixFlag) - 1))) / MatZoom(CurMatrixFlag)) * VScroll5.Max
            End If
        End If
        If nVH > Form1.HScroll4.Max Then nVH = Form1.HScroll4.Max
        If nVV > Form1.VScroll5.Max Then nVV = Form1.VScroll5.Max
        If nVV < 0 Then nVV = 0
        If nVH < 0 Then nVH = 0
    End If
    
    Form1.HScroll4.Value = CLng(nVH)
    Form1.VScroll5.Value = CLng(nVV)
    DoVS5 = 0
    'SS = Abs(GetTickCount)
    If CurMatrixFlag = 0 Then
        DontDoKey = 2
    End If
    Call Form1.HScroll4_Change
    If CurMatrixFlag = 0 Then
        DontDoKey = 1
    End If
    
    'EE = Abs(GetTickCount)
    'TT = EE - SS
    x = x
    
    If ((MatZoom(CurMatrixFlag) + 0.5) * Form1.Picture26.ScaleHeight) * 2 - Form1.Picture26.ScaleHeight > 16000 And CurMatrixFlag <> 0 Then
        Form1.Command39(1).Enabled = False
        Form1.Timer3.Enabled = False
    End If
'End If

Call DoMatCap
ButtonScrollFlag = 0
End Sub
Public Sub DoRecFreeMLTree()
Dim Y As Long, x As Long, Z As Long

Call UnModNextno
ReDim TempSeq(PermNextno)
For x = 0 To PermNextno
    TempSeq(x) = StrainSeq(x)
Next x
Dim tMissingData() As Byte
ReDim tMissingData(Len(StrainSeq(0)), NextNo)
Dim SomeAcceptFlag As Byte
SomeAcceptFlag = 0
For x = 0 To PermNextno
    For Y = 1 To CurrentXOver(x)
        If XoverList(x, Y).Accept = 1 Then
            SomeAcceptFlag = 1
            Exit For
        End If
    Next Y
    If SomeAcceptFlag = 1 Then Exit For
Next x
Dim AF As Byte
If SomeAcceptFlag = 1 Then
    Response = MsgBox("Would you like to remove only manually 'accepted' evidence of recombination during tree construction. Pressing the 'No' button will remove all detected evidence of recombination whether manually accepted or not", 36)
Else
    Response = 7
    
End If
If Response = 7 Then
    AF = 0
Else
    AF = 1
End If

For Y = 1 To SEventNumber
    Bx = BestEvent(Y, 0)
    By = BestEvent(Y, 1)
    If XoverList(Bx, By).Beginning <> XoverList(Bx, By).Ending And (AF = 0 Or (AF = 1 And XoverList(Bx, By).Accept = 1)) Then
      If Bx <= UBound(TempSeq, 1) Then
        If TempSeq(Bx) <> "" Then
            If By = -1 Then Exit For
            BTree = XoverList(Bx, By).Beginning
            ETree = XoverList(Bx, By).Ending
            Dim LenRegion As Long
            
            For Z = 0 To PermNextno
                If Daught(Y, Z) > 0 Then
                    If BTree < ETree Then
                        LenRegion = ETree - BTree + 1
                        Mid(TempSeq(Z), BTree, LenRegion) = String(LenRegion, "-")
                        For D = BTree To ETree
                            tMissingData(D, Z) = 1
                        Next D
                    Else
                        LenRegion = Len(StrainSeq(0)) - BTree + 1
                        Mid(TempSeq(Z), BTree, LenRegion) = String(LenRegion, "-")
                        For D = BTree To Len(StrainSeq(0))
                            tMissingData(D, Z) = 1
                        Next D
                        LenRegion = ETree
                        Mid(TempSeq(Z), 1, LenRegion) = String(LenRegion, "-")
                        For D = 1 To ETree
                            tMissingData(D, Z) = 1
                        Next D
                    End If
                End If
            Next Z
        End If
      End If
    End If
Next Y




F2TreeIndex = 3
'TreeTypeFlag = 3
CurTree(3) = 1
CTF = 1
NHFlag = 16
PseudoFlag = 1
BSTreeStrat = 4
BusyWithTreeFlag = BusyWithTreeFlag + 1
Call NJTree2(1)

TType = 1
TNum = 3
For x = 0 To NextNo
    A = x
    YPos = YCord(TType, TNum, A) - 1
    MapBlockNumX = MapBlockNumX + 1
    If MapBlockNumX > UBound(MapBlocks, 4) Then
        ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
    End If
    
    MapBlocks(TType, TNum, 0, MapBlockNumX) = 1 / Len(StrainSeq(0))
    MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
    MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
    MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(220, 220, 220) 'HalfColour ' RGB(197, 197, 255) 'ThreeQuaterColour 'RGB(255, 255, 255)
    For D = 1 To Len(StrainSeq(0))
        If tMissingData(D, A) = 0 Then
            MapBlockNumX = MapBlockNumX + 1
            If MapBlockNumX > UBound(MapBlocks, 4) Then
                ReDim Preserve MapBlocks(4, 4, 4, UBound(MapBlocks, 4) + CLng(PermNextno / 4))
            End If
            
            MapBlocks(TType, TNum, 0, MapBlockNumX) = Decompress(D) / Decompress(Len(StrainSeq(0)))
            MapBlocks(TType, TNum, 2, MapBlockNumX) = YPos
            MapBlocks(TType, TNum, 3, MapBlockNumX) = RGB(128, 128, 128)
            For C = D + 1 To Len(StrainSeq(0))
                If tMissingData(C, A) = 1 Then
                   'A = C - 1
                   MapBlocks(TType, TNum, 1, MapBlockNumX) = (Decompress(C) - 1) / Decompress(Len(StrainSeq(0)))
                   Exit For
                End If
                
            Next C
            D = C - 1
            If C = Len(StrainSeq(0)) + 1 Then
                MapBlocks(TType, TNum, 1, MapBlockNumX) = 1
            End If
        End If
    Next D
    
Next x
MapBlockNum(TType, TNum) = MapBlockNumX

'ubD = UBound(MapBlocks, 4)
'ubA = UBound(MapBlocks, 1)
'ubB = UBound(MapBlocks, 2)
'ubC = UBound(MapBlocks, 3)
'
'ReDim MapBlocksR(ubC, ubD, ubA, ubB)
'For A = 0 To ubA
'    For B = 0 To ubB
'        For C = 0 To ubC
'            For D = 0 To ubD
'                MapBlocksR(C, D, A, B) = MapBlocks(A, B, C, D)
'            Next D
'        Next C
'    Next B
'Next A



PseudoFlag = 0
TreeImage(3) = 1
BusyWithTreeFlag = 0
End Sub


Public Sub MakeAnalysisListQvR()

MCCorrection = 0
Dim UB As Long, RefSeqs() As Long, RNum As Long, QuerySeqs() As Long, QNum As Long, x As Long, Y As Long, Z As Long, A As Long, b As Long, C As Long
ReDim RefSeqs(NextNo), QuerySeqs(NextNo)
ReDim Analysislist(2, 10000)
UB = 10000
RNum = 0
QNum = 0
For x = 0 To PermNextno
    If MaskSeq(x) = 0 Then
        If ReferenceList(x) > 0 And MaskSeq(x) = 0 Then
            RNum = RNum + 1
            RefSeqs(RNum) = x
        Else
            QNum = QNum + 1
            QuerySeqs(QNum) = x
        End If
    End If
Next x
TripListLen = 0

If x = 123456 Then 'do it based on only the best reference matches
    Dim BestReference() As Long, Closest() As Single

    
    For x = 1 To QNum
        ReDim BestReference(RefNum)
        A = QuerySeqs(x)
        If MaskSeq(A) = 0 Then
        
            ReDim Closest(RefNum)
            For Z = 0 To PermNextno
                b = ReferenceList(Z)
                If b > 0 Then
                    If Closest(b) < Distance(A, Z) Then
                        Closest(b) = Distance(A, Z)
                        BestReference(b) = Z
                    ElseIf Closest(b) = Distance(A, Z) And Closest(b) > 0 Then
                        If PermValid(A, Z) > PermValid(A, BestReference(b)) Then
                            Closest(b) = Distance(A, Z)
                            BestReference(b) = Z
                        End If
                    End If
                End If
            Next Z
            For Y = 1 To RefNum
                b = BestReference(Y)
                For Z = Y + 1 To RefNum
                    C = BestReference(Z)
                    TripListLen = TripListLen + 1
                    If TripListLen > UB Then
                        UB = UB + 10000
                        ReDim Preserve Analysislist(2, UB)
                    End If
                    Analysislist(0, TripListLen) = A
                    Analysislist(1, TripListLen) = b
                    Analysislist(2, TripListLen) = C
                Next Z
            Next Y
        End If
    Next x
    
    MCCorrection = TripListLen
    
Else
    For x = 1 To RNum
        A = RefSeqs(x)
        For Y = x + 1 To RNum
            b = RefSeqs(Y)
            If ReferenceList(A) <> ReferenceList(b) Then
                For Z = 1 To QNum
                    C = QuerySeqs(Z)
                    
                    TripListLen = TripListLen + 1
                    If TripListLen > UB Then
                        UB = UB + 10000
                        ReDim Preserve Analysislist(2, UB)
                    End If
                    
                    Analysislist(0, TripListLen) = A
                    Analysislist(1, TripListLen) = b
                    Analysislist(2, TripListLen) = C
                    
                Next Z
            End If
        Next Y
    Next x
    XX = RefNum
    MCCorrection = ((RefNum * (RefNum - 1)) / 2) * QNum
End If

ReDim Preserve Analysislist(2, TripListLen + 1)
End Sub
Public Sub Highlight(HFlagX)
     'Highlights recombinant region in the plot display
    If ManFlag > -1 Or TManFlag > 1 Then Exit Sub
    Dim EP As Long, SP As Long, X1 As Integer, X2 As Integer, Y1 As Integer, Y2 As Integer
    Dim DoneB(2) As Byte, EN As Long, Pict As Long, x As Long, A As Long, BB As Long, EE As Long
    
    
    'BPCIs(ZZ, SEventNumber)
    
    GBlockNum = -1
    If DebuggingFlag < 2 Then On Error Resume Next
    EN = -1
    EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
    On Error GoTo 0
    If EN = -1 Then Exit Sub
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.DrawMode = 13
    Dim PntAPI As POINTAPI
    Pict = Form1.Picture7.hdc
    If (ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210) And EN <= UBound(BPCIs, 2) And HFlagX = 0 Then
        For x = 0 To 1
            A = x * 3
             
            If BPCIs(A, EN) <> BPCIs(A + 1, EN) Or (BPCIs(A, EN) > 0 And BPCIs(A + 1, EN) > 0) Then
            
                If BPCIs(A, EN) <= 0 Then
                    Form1.Picture7.ForeColor = RGB(180, 180, 180)
                Else
                    Form1.Picture7.ForeColor = RGB(64, 64, 64)
                End If
                BB = Abs(BPCIs(A, EN)) '0,27
                EE = Abs(BPCIs(A + 1, EN))
                If BB <= EE Then
                    'MoveToEx Pict, 30 + Decompress(BB) * xFactor, 20, PntAPI
                    'LineTo Pict, 30 + Decompress(EE) * xFactor, 20
                    'LineTo Pict, 30 + Decompress(EE) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(BB) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(BB) * xFactor, 20
                    GBlockNum = GBlockNum + 1
                    ReDim Preserve GBlock(4, GBlockNum)
                    GBlock(0, GBlockNum) = BB
                    GBlock(1, GBlockNum) = 0
                    GBlock(2, GBlockNum) = EE
                    GBlock(3, GBlockNum) = 0
                    GBlock(4, GBlockNum) = RGB(197, 197, 197)
                    
                    X1 = 30 + Decompress(BB) * XFactor + XFactor
                    X2 = 30 + Decompress(EE) * XFactor + XFactor
                    Y1 = 20
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(197, 197, 197), BF
                    
                    Form1.Picture7.DrawMode = 13
                 Else
                    GBlockNum = GBlockNum + 1
                    ReDim Preserve GBlock(4, GBlockNum)
                    GBlock(0, GBlockNum) = BB
                    GBlock(1, GBlockNum) = 0
                    GBlock(2, GBlockNum) = Len(StrainSeq(0))
                    GBlock(3, GBlockNum) = 0
                    GBlock(4, GBlockNum) = RGB(197, 197, 197)
                    
                    X1 = 30 + Decompress(BB) * XFactor + XFactor
                    X2 = 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor
                    Y1 = 20
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(197, 197, 197), BF
                    Form1.Picture7.DrawMode = 13
                    x = x
                    'MoveToEx Pict, 30 + Decompress(BB) * xFactor, 20, PntAPI
                    'LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * xFactor, 20
                    'MoveToEx Pict, 30 + Decompress(Len(StrainSeq(0))) * xFactor, PicHeight - 15, PntAPI
                    'LineTo Pict, 30 + Decompress(BB) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(BB) * xFactor, 20
                    
                    GBlockNum = GBlockNum + 1
                    ReDim Preserve GBlock(4, GBlockNum)
                    GBlock(0, GBlockNum) = 1
                    GBlock(1, GBlockNum) = 0
                    GBlock(2, GBlockNum) = EE
                    GBlock(3, GBlockNum) = 0
                    GBlock(4, GBlockNum) = RGB(197, 197, 197)
                    
                    X1 = 30 + Decompress(1) * XFactor + XFactor
                    X2 = 30 + Decompress(EE) * XFactor + XFactor
                    Y1 = 20
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(197, 197, 197), BF
                    Form1.Picture7.DrawMode = 13
                    'MoveToEx Pict, 30 + Decompress(1) * xFactor, 20, PntAPI
                    'LineTo Pict, 30 + Decompress(EE) * xFactor, 20
                    'LineTo Pict, 30 + Decompress(EE) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(1) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(1) * xFactor, 20
                    x = x
                End If
                    
                    
                
            
            End If
        Next x
    
    End If
    If (ExRecFlag = 0 Or ExRecFlag = 203 Or ExRecFlag = 210) And EN <= UBound(BPCIs, 2) And HFlagX = 0 Then
        For x = 0 To 1
            A = x * 3
             
            If BPCIs(A, EN) <> BPCIs(A + 1, EN) Or (BPCIs(A, EN) > 0 And BPCIs(A + 1, EN) > 0) Then
            
                
                    
                    
                If x = 0 Then
                    BB = Abs(BPCIs(6, EN))
                    EE = Abs(BPCIs(7, EN))
                Else
                    BB = Abs(BPCIs(8, EN))
                    EE = Abs(BPCIs(9, EN))
                End If
                
                If BB <= EE Then
                    GBlockNum = GBlockNum + 1
                    ReDim Preserve GBlock(4, GBlockNum)
                    GBlock(0, GBlockNum) = BB
                    GBlock(1, GBlockNum) = 0
                    GBlock(2, GBlockNum) = EE
                    GBlock(3, GBlockNum) = 0
                    GBlock(4, GBlockNum) = RGB(160, 160, 160)
                    
                    X1 = 30 + Decompress(BB) * XFactor + XFactor
                    X2 = 30 + Decompress(EE) * XFactor + XFactor
                    Y1 = 20
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(160, 160, 160), BF
                    Form1.Picture7.DrawMode = 13
                    x = x
                Else
                    GBlockNum = GBlockNum + 1
                    ReDim Preserve GBlock(4, GBlockNum)
                    GBlock(0, GBlockNum) = BB
                    GBlock(1, GBlockNum) = 0
                    GBlock(2, GBlockNum) = Len(StrainSeq(0))
                    GBlock(3, GBlockNum) = 0
                    GBlock(4, GBlockNum) = RGB(160, 160, 160)
                    
                    X1 = 30 + Decompress(BB) * XFactor + XFactor
                    X2 = 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor
                    Y1 = 20
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(160, 160, 160), BF
                    Form1.Picture7.DrawMode = 13
                    x = x
                    'MoveToEx Pict, 30 + Decompress(BB) * xFactor, 20, PntAPI
                    'LineTo Pict, 30 + Decompress(Len(StrainSeq(0))) * xFactor, 20
                    'MoveToEx Pict, 30 + Decompress(Len(StrainSeq(0))) * xFactor, PicHeight - 15, PntAPI
                    'LineTo Pict, 30 + Decompress(BB) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(BB) * xFactor, 20
                    
                    GBlockNum = GBlockNum + 1
                    ReDim Preserve GBlock(4, GBlockNum)
                    GBlock(0, GBlockNum) = 1
                    GBlock(1, GBlockNum) = 0
                    GBlock(2, GBlockNum) = EE
                    GBlock(3, GBlockNum) = 0
                    GBlock(4, GBlockNum) = RGB(160, 160, 160)
                    X1 = 30 + Decompress(1) * XFactor + XFactor
                    X2 = 30 + Decompress(EE) * XFactor + XFactor
                    Y1 = 20
                    Y2 = PicHeight - 15
                    Form1.Picture7.DrawMode = 13
                    Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(160, 160, 160), BF
                    Form1.Picture7.DrawMode = 13
                    'MoveToEx Pict, 30 + Decompress(1) * xFactor, 20, PntAPI
                    'LineTo Pict, 30 + Decompress(EE) * xFactor, 20
                    'LineTo Pict, 30 + Decompress(EE) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(1) * xFactor, PicHeight - 15
                    'LineTo Pict, 30 + Decompress(1) * xFactor, 20
                    x = x
                End If
            
            End If
        Next x
    
    End If
    GBlockNum = GBlockNum + 1
    ReDim Preserve GBlock(4, GBlockNum)
    GBlock(0, GBlockNum) = 0
    GBlock(1, GBlockNum) = 10 'this is a legend block = 95% coinfdence interval
    GBlock(2, GBlockNum) = 0
    GBlock(3, GBlockNum) = 0
    GBlock(4, GBlockNum) = RGB(160, 160, 160)
    
    GBlockNum = GBlockNum + 1
    ReDim Preserve GBlock(4, GBlockNum)
    GBlock(0, GBlockNum) = 0
    GBlock(1, GBlockNum) = 11 'this is a legend block = 99% coinfdence interval
    GBlock(2, GBlockNum) = 0
    GBlock(3, GBlockNum) = 0
    GBlock(4, GBlockNum) = RGB(197, 197, 197)
    
   Form1.Picture7.DrawWidth = 1
    
    Dim UB As Long
    
    If ScanFlagX = 0 Then
        
        For x = 1 To Len(StrainSeq(0))
            Form1.Picture7.DrawMode = 13
            
            UB = UBound(MissingData, 2)
            If Seq3 <= UB And Seq1 <= UB And Seq2 <= UB Then
                XX = UBound(MissingData, 1)
                XX = Len(StrainSeq(0))
                XX = Decompress(Len(StrainSeq(0)))
                If MissingData(x, Seq1) + MissingData(x, Seq2) + MissingData(x, Seq3) > 0 Then
                        SP = x
                        Do While MissingData(x, Seq1) + MissingData(x, Seq2) + MissingData(x, Seq3) > 0
                          x = x + 1
                          If x > Len(StrainSeq(0)) Then Exit Do
                        Loop
                        EP = x - 1
                        X1 = 30 + Decompress(SP) * XFactor + XFactor
                        X2 = 30 + Decompress(EP) * XFactor + XFactor
                        Y1 = 10
                        Y2 = PicHeight - 15
                        Form1.Picture7.DrawMode = 13
                        Form1.Picture7.Line (X1, Y1)-(X2, Y2), RGB(197, 197, 255), BF
                        Form1.Picture7.DrawMode = 13
                        GBlockNum = GBlockNum + 1
                        ReDim Preserve GBlock(4, GBlockNum)
                        GBlock(0, GBlockNum) = SP
                        GBlock(1, GBlockNum) = 0
                        GBlock(2, GBlockNum) = EP
                        GBlock(3, GBlockNum) = 0
                        GBlock(4, GBlockNum) = RGB(197, 197, 255)
                        If DoneB(1) = 0 Then
                            GBlockNum = GBlockNum + 1
                            ReDim Preserve GBlock(4, GBlockNum)
                            GBlock(0, GBlockNum) = 0
                            GBlock(1, GBlockNum) = 1 'this is a legend block = tract of sequence that is missing data in one of the three sequences
                            GBlock(2, GBlockNum) = 0
                            GBlock(3, GBlockNum) = 0
                            GBlock(4, GBlockNum) = RGB(197, 197, 255)
                            DoneB(1) = 1
                       End If
                End If
            
            End If
        Next x
        ColHL = RGB(0, 255, 255)
        If x = x Then 'HFlagX = 0 Then
            If XoverList(RelX, RelY).Beginning < XoverList(RelX, RelY).Ending Then
                X1 = 30 + Decompress(XoverList(RelX, RelY).Beginning) * XFactor + XFactor
                X2 = 30 + Decompress(XoverList(RelX, RelY).Ending) * XFactor + XFactor
                Y1 = 10
                Y2 = PicHeight - 15
                Form1.Picture7.DrawMode = 12
                Form1.Picture7.Line (X1, Y1)-(X2, Y1 + 10), ColHL, BF
                Form1.Picture7.Line (X1, Y2)-(X2, Y2 + 10), ColHL, BF
                Form1.Picture7.Line (X1, Y1)-(X1, Y2), ColHL, BF
                Form1.Picture7.Line (X2, Y1)-(X2, Y2), ColHL, BF
                
                'FontSizeAddjust = Picture2.FontSize / 6.75
                'XX = Picture2.TextHeight("A")
                'line
                
                
                Form1.Picture7.DrawMode = 13
                
                GBlockNum = GBlockNum + 1
                ReDim Preserve GBlock(4, GBlockNum)
                GBlock(0, GBlockNum) = XoverList(RelX, RelY).Beginning 'this is for the pink highlighted region
                GBlock(1, GBlockNum) = 0
                GBlock(2, GBlockNum) = XoverList(RelX, RelY).Ending
                GBlock(3, GBlockNum) = 0
                GBlock(4, GBlockNum) = RGB(255, 210, 210)
                
                
                GBlockNum = GBlockNum + 1
                ReDim Preserve GBlock(4, GBlockNum)
                GBlock(0, GBlockNum) = 0
                GBlock(1, GBlockNum) = 2 'this is a legend block = tract of sequence derived from one of the parentals equences
                GBlock(2, GBlockNum) = 0
                GBlock(3, GBlockNum) = 0
                GBlock(4, GBlockNum) = RGB(255, 210, 210)
            Else
                X1 = 30 + Decompress(XoverList(RelX, RelY).Beginning) * XFactor + XFactor
                X2 = 30 + Decompress(Len(StrainSeq(0))) * XFactor + XFactor
                Y1 = 10
                Y2 = PicHeight - 15
                Form1.Picture7.DrawMode = 12
                Form1.Picture7.Line (X1, Y1)-(X2, Y1 + 10), ColHL, BF
                Form1.Picture7.Line (X1, Y2)-(X2, Y2 + 10), ColHL, BF
                Form1.Picture7.Line (X1, Y1)-(X1, Y2), ColHL, BF
               
                
                GBlockNum = GBlockNum + 1
                ReDim Preserve GBlock(4, GBlockNum)
                GBlock(0, GBlockNum) = XoverList(RelX, RelY).Beginning
                GBlock(1, GBlockNum) = 0
                GBlock(2, GBlockNum) = Len(StrainSeq(0))
                GBlock(3, GBlockNum) = 0
                GBlock(4, GBlockNum) = RGB(255, 190, 190)
                
                GBlockNum = GBlockNum + 1
                ReDim Preserve GBlock(4, GBlockNum)
                GBlock(0, GBlockNum) = 0
                GBlock(1, GBlockNum) = 2 'this is a legend block = tract of sequence derived from one of the parentals equences
                GBlock(2, GBlockNum) = 0
                GBlock(3, GBlockNum) = 0
                GBlock(4, GBlockNum) = RGB(255, 190, 190)
                
                X1 = 30 + XFactor
                X2 = 30 + Decompress(XoverList(RelX, RelY).Ending) * XFactor + XFactor
                Y1 = 10
                Y2 = PicHeight - 15
                Form1.Picture7.Line (X1, Y1)-(X2, Y1 + 10), ColHL, BF
                Form1.Picture7.Line (X1, Y2)-(X2, Y2 + 10), ColHL, BF
                Form1.Picture7.Line (X2, Y1)-(X2, Y2), ColHL, BF
                Form1.Picture7.DrawMode = 13
                
                GBlockNum = GBlockNum + 1
                ReDim Preserve GBlock(4, GBlockNum)
                GBlock(0, GBlockNum) = 1
                GBlock(1, GBlockNum) = 0
                GBlock(2, GBlockNum) = XoverList(RelX, RelY).Ending
                GBlock(3, GBlockNum) = 0
                GBlock(4, GBlockNum) = RGB(255, 190, 190)
            End If
        End If
        
    End If

End Sub

Public Sub Build3SeqTable()

Form1.SSPanel1 = "Building 3Seq p-value lookup table"
'Find max memory needed by looking at max permdist()
Dim MaxPermDists As Long, W As Long, x As Long, Y As Long, Z As Long, YTable() As Single
ReDim WTable(1, 1, 1, 1)
MaxPermDists = 0
For x = 0 To NextNo - 1
    For Y = x + 1 To NextNo
        If PermDIffs(x, Y) > MaxPermDists Then
            MaxPermDists = PermDIffs(x, Y)
        End If
    Next Y
Next x


'Work out how much memory is available
Dim MaxTableSize As Double, SizeStore As Long
GlobalMemoryStatus MemSit

APhys = Abs(MemSit.dwTotalPhys)
If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
MaxTableSize = APhys


'MaxTableSize = MaxTableSize / 2 'only allow use of 1/2 of available memory

MaxTableSize = MaxTableSize / 16 '4 bytes for single,only allow use of 1/4 of phys mem
'XX = 1000 ^ (1 / 4)
MaxTableSize = MaxTableSize ^ (1 / 4) '4dimentions
MaxTableSize = MaxTableSize / 2 'only permit use of 1/2 of memory


If MaxPermDists > MaxTableSize Then
    MaxPermDists = CLng(MaxTableSize)
End If

Dim oDir As String, FF As Long
oDir = CurDir
If DebuggingFlag < 2 Then On Error Resume Next

ChDir App.Path
ChDrive App.Path
On Error GoTo 0

ReDim XTable(0, 0, 0)

If Len(StrainSeq(0)) < 100000 Then
    FF = FreeFile
    Open "3seqTable" For Binary As #FF
    Get #FF, , SizeStore
    If MaxPermDists <= SizeStore Then
        ReDim XTable(SizeStore + 1, SizeStore + 1, SizeStore + 1)
        Get #FF, , XTable()
    End If
    Close #FF
End If
If DebuggingFlag < 2 Then On Error Resume Next

ChDir oDir
ChDrive oDir
Dim Dummy As Long, Tot As Variant, nM As Long, nK As Long, NN As Long, dPValue As Double


On Error GoTo 0
If UBound(XTable, 1) = 0 Then 'calculate the table if a big enough table is not available
    
StepBackin:


    On Error GoTo DropMaxPermDists
    ReDim XTable(MaxPermDists + 1, MaxPermDists + 1, MaxPermDists + 1)
    'Form1.ProgressBar1 = 3
    ReDim YTable(MaxPermDists + 1, MaxPermDists + 1, MaxPermDists + 1, MaxPermDists + 1)
    
    On Error GoTo 0
    'Form1.ProgressBar1 = 10
    Dummy = Fill4DSingArray(MaxPermDists + 1, MaxPermDists + 1, MaxPermDists + 1, MaxPermDists + 1, -1, YTable(0, 0, 0, 0))
    'Form1.ProgressBar1 = 15
    Tot = (MaxPermDists + 1) ^ 3
    
    
    
    'AbortFlag = 1
    x = 0
    For nM = 0 To MaxPermDists
        For NN = 0 To MaxPermDists
            For nK = 0 To MaxPermDists
                dPValue = Seq3PVals(UBound(YTable, 1), UBound(YTable, 3), nM, NN, nK, YTable(0, 0, 0, 0))
                XTable(nM, NN, nK) = dPValue
                x = x + 1
            Next
        Next
       
        'Form1.ProgressBar1 = 15 + X / Tot * 70
    Next
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    Open "3seqTable" For Binary As #1
    Put #1, , MaxPermDists
    Put #1, , XTable()
    Close #1
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
End If

XTableFlag = 1
'Form1.ProgressBar1 = 70
'Form1.SSPanel1 = ""
Exit Sub
DropMaxPermDists:
MaxPermDists = CLng(MaxPermDists / 2)
ReDim XTable(0, 0, 0), YTable(0, 0, 0, 0)
On Error GoTo 0
GoTo StepBackin
Erase YTable
End Sub

Public Sub GetTSPVal(WF, nM, NN, nK, dPValue)
Dim odPValue As Double, onK As Double, PVM As Double, onM As Double, onN As Double, xN As Long, XM As Long, xK As Long

onN = NN
onM = nM
onK = nK
If nM >= UBound(XTable, 1) - 1 Or NN >= UBound(XTable, 1) - 1 Or nK >= UBound(XTable, 1) - 1 Then
    
    'If X = X Then
        xN = NN
        XM = nM
        xK = nK
        dPValue = SiegmundDiscrete(XM, xN, xK)
        WF = 1
       
        'XX = XTable(100, 200, 150)
        'XX = SiegmundDiscrete(100, 200, 150)
       ' X = X
    ''End If
    
    If dPValue >= 1 Or dPValue <= 0 Then
    
    
    
        If nM >= NN And nM >= nK Then
            PVM = nM / (UBound(XTable, 1) - 2)
        ElseIf NN >= nM And NN >= nK Then
            PVM = NN / (UBound(XTable, 1) - 2)
        Else
            PVM = nK / (UBound(XTable, 1) - 2)
        End If
        
        nM = Int(nM / PVM)
        NN = Int(NN / PVM)
        nK = Int(nK / PVM)
        If nM > 0 Then
            PVM = onM / nM
            If onM / nM > PVM Then
                PVM = onM / nM
            End If
        ElseIf NN > 0 Then
            PVM = onN / NN
            If onN / NN > PVM Then
                PVM = onN / NN
            End If
        End If
        
        WF = 1
    Else
        Exit Sub
    End If
Else

    WF = 0
    PVM = 1
End If

dPValue = XTable(nM, NN, nK)
odPValue = dPValue
If PVM > 1 Then
    dPValue = dPValue ^ PVM ' / (10 ^ (PVM - 1))
End If
If dPValue = 0 And odPValue > 0 Then
    dPValue = 10 ^ -300
End If
nM = onM
NN = onN
nK = onK
End Sub
Public Sub WriteNames2(tSeq1, tSeq2, tSeq3, Green, blue, red)
OFontSize = Form1.Picture7.FontSize
L1 = Form1.Picture7.TextWidth(WNStr(1))
L2 = Form1.Picture7.TextWidth(WNStr(2))
L3 = Form1.Picture7.TextWidth(WNStr(3))
DrawLen = Form1.Picture7.ScaleWidth - 30
TotLen = L1 + L2 + L3

If DrawLen > TotLen Then
    LOSpace = (DrawLen - TotLen) / 2
    XPos1 = 25
    XPos2 = XPos1 + L1 + LOSpace
    XPos3 = XPos2 + L2 + LOSpace
Else

    Do Until TotLen < DrawLen
        LastFontSize = Form1.Picture7.FontSize
        Form1.Picture7.FontSize = Form1.Picture7.FontSize - 1
        If Form1.Picture7.FontSize = LastFontSize Then Exit Do
        L1 = Form1.Picture7.TextWidth(OriginalName(Seq1))
        L2 = Form1.Picture7.TextWidth(OriginalName(Seq2))
        L3 = Form1.Picture7.TextWidth(OriginalName(Seq3))
        TotLen = L1 + L2 + L3
    Loop

    LOSpace = (DrawLen - TotLen) / 2
    XPos1 = 25
    XPos2 = XPos1 + L1 + LOSpace
    XPos3 = XPos2 + L2 + LOSpace
End If
YPos = Form1.Picture7.Height * (0.92)
Form1.Picture7.ForeColor = ThreeQuaterColour
Form1.Picture7.CurrentX = XPos1 - 1
Form1.Picture7.CurrentY = YPos - 1
Form1.Picture7.Print WNStr(1)
Form1.Picture7.CurrentX = XPos2 - 1
Form1.Picture7.CurrentY = YPos - 1
Form1.Picture7.Print WNStr(2)
Form1.Picture7.CurrentX = XPos3 - 1
Form1.Picture7.CurrentY = YPos - 1
Form1.Picture7.Print WNStr(3)
Form1.Picture7.ForeColor = QuaterColour
Form1.Picture7.CurrentX = XPos1 + 1
Form1.Picture7.CurrentY = YPos + 1
Form1.Picture7.Print WNStr(1)
Form1.Picture7.CurrentX = XPos2 + 1
Form1.Picture7.CurrentY = YPos + 1
Form1.Picture7.Print WNStr(2)
Form1.Picture7.CurrentX = XPos3 + 1
Form1.Picture7.CurrentY = YPos + 1
Form1.Picture7.Print WNStr(3)
Form1.Picture7.CurrentX = XPos1
Form1.Picture7.CurrentY = YPos
Form1.Picture7.ForeColor = Green 'RGB(255, 0, 0)'this is actually green
Form1.Picture7.Print WNStr(1)
Form1.Picture7.CurrentX = XPos2
Form1.Picture7.CurrentY = YPos
Form1.Picture7.ForeColor = blue 'RGB(0, 255, 0)'this is actually blue
Form1.Picture7.Print WNStr(2)
Form1.Picture7.CurrentX = XPos3
Form1.Picture7.CurrentY = YPos
Form1.Picture7.ForeColor = red 'RGB(0, 0, 255)'this is actually red
Form1.Picture7.Print WNStr(3)
'Form1.Picture7.Refresh
Form1.Picture7.FontSize = OFontSize
End Sub
Public Sub TSXOverC()

Dim BE As Long, EN As Long, BE2 As Long, EN2 As Long, nK As Long, nM As Long, NN As Long, NL As Long, x As Long, CurrentHeight As Long, XoverSeqNumTS() As Long, Y As Long, MaxSeen As Long, MaxDescentSeen As Long
Dim II As Long, dPValue As Double
tSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3


MinPA = 100

If DebuggingFlag < 2 Then On Error Resume Next
ReDim XoverSeqNumTS(Len(StrainSeq(0)))

On Error GoTo 0

If XTableFlag = 0 Then Call Build3SeqTable

Seq1 = tSeq3 ' this silly conversion needed so names and colours match up with those of chimaera
Seq2 = tSeq2
Seq3 = tSeq1


'Call TSXOver(0)
ReDim XoverSeqNumTS(Len(StrainSeq(0)))


Dim tXOverSeqNum() As Long

Rnd (-BSRndNumSeed)
Dim Tmp As Long, THold(2) As Long, SeqRnd() As Integer, dPValue2 As Double, xPosdiffx() As Long, xDiffposx() As Long, sn As Long, SM As Long, sk As Long, sbe As Long, SEN As Long


        
Dim BES1 As Long, BES2 As Long, BES3 As Long, ENS1 As Long, ENS2 As Long, ENS3 As Long
Dim BE2S1 As Long, BE2S2 As Long, BE2S3 As Long, EN2S1 As Long, EN2S2 As Long, EN2S3 As Long
Dim nMS1 As Long, nNS1 As Long, nKS1 As Long, nLS1 As Long, nMS2 As Long, nNS2 As Long, nKS2 As Long, nLS2 As Long, nMS3 As Long, nNS3 As Long, nKS3 As Long, nLS3 As Long
Dim XPosDiffS1() As Long, XDiffposS1() As Long, XPosDiffS2() As Long, XDiffposS2() As Long, XPosDiffS3() As Long, XDiffposS3() As Long
Dim XoverSeqNumTS1() As Long, XoverSeqNumTS2() As Long, XoverSeqNumTS3() As Long
Dim LenXoverSeqS1 As Long, LenXoverSeqS2 As Long, LenXoverSeqS3 As Long

ReDim XPosDiffS1(Len(StrainSeq(0))), XDiffposS1(Len(StrainSeq(0))), XPosDiffS2(Len(StrainSeq(0))), XDiffposS2(Len(StrainSeq(0))), XPosDiffS3(Len(StrainSeq(0))), XDiffposS3(Len(StrainSeq(0)))
ReDim XoverSeqNumTS1(Len(StrainSeq(0))), XoverSeqNumTS2(Len(StrainSeq(0))), XoverSeqNumTS3(Len(StrainSeq(0)))

LenXoverSeqS1 = FindSubSeqTS2(Len(StrainSeq(0)), Seq2, Seq3, Seq1, BES1, ENS1, BE2S1, EN2S1, nMS1, nNS1, nKS1, nLS1, XPosDiffS1(0), XDiffposS1(0), SeqNum(0, 0), XoverSeqNumTS1(0), MissingData(0, 0))
LenXoverSeqS2 = FindSubSeqTS2(Len(StrainSeq(0)), Seq1, Seq3, Seq2, BES2, ENS2, BE2S2, EN2S2, nMS2, nNS2, nKS2, nLS2, XPosDiffS2(0), XDiffposS2(0), SeqNum(0, 0), XoverSeqNumTS2(0), MissingData(0, 0))
LenXoverSeqS3 = FindSubSeqTS2(Len(StrainSeq(0)), Seq1, Seq2, Seq3, BES3, ENS3, BE2S3, EN2S3, nMS3, nNS3, nKS3, nLS3, XPosDiffS3(0), XDiffposS3(0), SeqNum(0, 0), XoverSeqNumTS3(0), MissingData(0, 0))
'2,7,3:2642,1208,1208,2642:26,20,12,19
        
        '1312,2309
        '2352,1306
        
        '1306,2309
        '2309,1306
'45 26,20,12,19
If x = x Then
    Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeqS1, 1, CircularFlag, nKS1, BES1, ENS1, XDiffposS1(0), XPosDiffS1(0), XoverSeqNumTS1(0))
    Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeqS1, -1, CircularFlag, nLS1, BE2S1, EN2S1, XDiffposS1(0), XPosDiffS1(0), XoverSeqNumTS1(0))

    Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeqS2, 1, CircularFlag, nKS2, BES2, ENS2, XDiffposS2(0), XPosDiffS2(0), XoverSeqNumTS2(0))
    Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeqS2, -1, CircularFlag, nLS2, BE2S2, EN2S2, XDiffposS2(0), XPosDiffS2(0), XoverSeqNumTS2(0))

    Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeqS3, 1, CircularFlag, nKS3, BES3, ENS3, XDiffposS3(0), XPosDiffS3(0), XoverSeqNumTS3(0))
    Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeqS3, -1, CircularFlag, nLS3, BE2S3, EN2S3, XDiffposS3(0), XPosDiffS3(0), XoverSeqNumTS3(0))
    '12,2642,1208------19,2653,1208
    '19,1208,2642------19,1214,2642
    x = x
Else
    Call CheckWrap(LenXoverSeqS1, nKS1, BES1, ENS1, 1, XDiffposS1(), XPosDiffS1(), XoverSeqNumTS1())
    Call CheckWrap(LenXoverSeqS1, nLS1, BE2S1, EN2S1, -1, XDiffposS1(), XPosDiffS1(), XoverSeqNumTS1())
            
    Call CheckWrap(LenXoverSeqS2, nKS2, BES2, ENS2, 1, XDiffposS2(), XPosDiffS2(), XoverSeqNumTS2())
    Call CheckWrap(LenXoverSeqS2, nLS2, BE2S2, EN2S2, -1, XDiffposS2(), XPosDiffS2(), XoverSeqNumTS2())
    
    Call CheckWrap(LenXoverSeqS3, nKS3, BES3, ENS3, 1, XDiffposS3(), XPosDiffS3(), XoverSeqNumTS3())
    Call CheckWrap(LenXoverSeqS3, nLS3, BE2S3, EN2S3, -1, XDiffposS3(), XPosDiffS3(), XoverSeqNumTS3())
End If
'13,2653,1208
'19,1214,2642
       
Dim dPValueS1 As Double, dPValueS2 As Double, dPValueS3 As Double
Dim dPValue2S1 As Double, dPValue2S2 As Double, dPValue2S3 As Double
Dim WFS1, WF2S1, WFS2, WF2S2, WFS3, WF2S3

GetTSPVal WFS1, nMS1, nNS1, nKS1, dPValueS1 '503,622,445
GetTSPVal WF2S1, nNS1, nMS1, nLS1, dPValue2S1

GetTSPVal WFS2, nMS2, nNS2, nKS2, dPValueS2
GetTSPVal WF2S2, nNS2, nMS2, nLS2, dPValue2S2

GetTSPVal WFS3, nMS3, nNS3, nKS3, dPValueS3
GetTSPVal WF2S3, nNS3, nMS3, nLS3, dPValue2S3
        
Dim MultNegS1, MultNegS2, MultNegS3
        
MultNegS1 = 0: MultNegS2 = 0: MultNegS3 = 0

If dPValueS1 = 0 Then dPValueS1 = 10
If dPValueS2 = 0 Then dPValueS2 = 10
If dPValueS3 = 0 Then dPValueS3 = 10
If dPValue2S1 = 0 Then dPValue2S1 = 10
If dPValue2S2 = 0 Then dPValue2S2 = 10
If dPValue2S3 = 0 Then dPValue2S3 = 10


If dPValue2S1 < dPValueS1 Then
    Call SwapRound(WFS1, WF2S1, BES1, ENS1, BE2S1, EN2S1, nMS1, nNS1, nKS1, nLS1, dPValueS1, dPValue2S1, MultNegS1)
End If

If dPValue2S2 < dPValueS2 Then
    Call SwapRound(WFS2, WF2S2, BES2, ENS2, BE2S2, EN2S2, nMS2, nNS2, nKS2, nLS2, dPValueS2, dPValue2S2, MultNegS2)
End If

If dPValue2S3 < dPValueS3 Then
    Call SwapRound(WF3, WF2S3, BES3, ENS3, BE2S3, EN2S3, nMS3, nNS3, nKS3, nLS3, dPValueS3, dPValue2S3, MultNegS3)
End If


If MultNegS1 = 1 Then
    For x = 0 To LenXoverSeqS1
        XoverSeqNumTS1(x) = XoverSeqNumTS1(x) * -1
    Next x
End If

If MultNegS2 = 1 Then
    For x = 0 To LenXoverSeqS2
        XoverSeqNumTS2(x) = XoverSeqNumTS2(x) * -1
    Next x
End If

If MultNegS3 = 1 Then
    For x = 0 To LenXoverSeqS3
        XoverSeqNumTS3(x) = XoverSeqNumTS3(x) * -1
    Next x
End If

    '1.646-4,699,18
 ' XX = Recompress(340552) '11189-11362
Call CheckSplit3Seq(BES1, ENS1, nMS1, nNS1, dPValueS1, LenXoverSeqS1, XoverSeqNumTS1(), XPosDiffS1(), XDiffposS1())

If dPValueS1 > dPValue2S1 Or FindallFlag = 1 Then
    
    If MultNegS1 = 0 Then
        For x = 0 To LenXoverSeqS1
            XoverSeqNumTS1(x) = XoverSeqNumTS1(x) * -1
        Next x
        'Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, nN, nK, nL, dPValue, dPValue2, MultNeg)
    End If
    'Call SwapRound(WFS1, WF2S1, BES1, ENS1, BE2S1, EN2S1, nMS1, nNS1, nKS1, nLS1, dPValueS1, dPValue2S1, MultNegS1)
    
    
    
    Call CheckSplit3Seq(BE2S1, EN2S1, nNS1, nMS1, dPValue2S1, LenXoverSeqS1, XoverSeqNumTS1(), XPosDiffS1(), XDiffposS1())
    If FindallFlag = 0 And dPValueS1 > dPValue2S1 Then
        If MultNegS1 = 1 Then
            MultNegS1 = 0
            
        Else
            MultNegS1 = 1
            
            
        End If
        
        Call SwapRound(WFS1, WF2S1, BES1, ENS1, BE2S1, EN2S1, nMS1, nNS1, nKS1, nLS1, dPValueS1, dPValue2S1, MultNegS1)
    End If

End If
        
        
Call CheckSplit3Seq(BES2, ENS2, nMS2, nNS2, dPValueS2, LenXoverSeqS2, XoverSeqNumTS2(), XPosDiffS2(), XDiffposS2())

If dPValueS2 > dPValue2S2 Or FindallFlag = 1 Then
    If MultNegS2 = 0 Then
        For x = 0 To LenXoverSeqS2
            XoverSeqNumTS2(x) = XoverSeqNumTS2(x) * -1
        Next x
        'Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, nN, nK, nL, dPValue, dPValue2, MultNeg)
    End If
    
    Call CheckSplit3Seq(BE2S2, EN2S2, nNS2, nMS2, dPValue2S2, LenXoverSeqS2, XoverSeqNumTS2(), XPosDiffS2(), XDiffposS2())
    If FindallFlag = 0 And dPValueS2 > dPValue2S2 Then
        If MultNegS2 = 1 Then
            MultNegS2 = 0
            
        Else
            MultNegS2 = 1
        End If
        Call SwapRound(WFS2, WF2S2, BES2, ENS2, BE2S2, EN2S2, nMS2, nNS2, nKS2, nLS2, dPValueS2, dPValue2S2, MultNegS2)
        
    End If

End If

Call CheckSplit3Seq(BES3, ENS3, nMS3, nNS3, dPValueS3, LenXoverSeqS3, XoverSeqNumTS3(), XPosDiffS3(), XDiffposS3())

If dPValueS3 > dPValue2S3 Or FindallFlag = 1 Then
    If MultNegS3 = 0 Then
        For x = 0 To LenXoverSeqS3
            XoverSeqNumTS3(x) = XoverSeqNumTS3(x) * -1
        Next x
        'Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, nN, nK, nL, dPValue, dPValue2, MultNeg)
    End If
    
    Call CheckSplit3Seq(BE2S3, EN2S3, nNS3, nMS3, dPValue2S3, LenXoverSeqS3, XoverSeqNumTS3(), XPosDiffS3(), XDiffposS3())
    If FindallFlag = 0 And dPValueS3 > dPValue2S3 Then
        If MultNegS3 = 1 Then
            MultNegS3 = 0
            
        Else
            MultNegS3 = 1
            
            
        End If
        Call SwapRound(WFS3, WF2S3, BES3, ENS3, BE2S3, EN2S3, nMS3, nNS3, nKS3, nLS3, dPValueS3, dPValue2S3, MultNegS3)
        
    End If

End If
        
        
        
If BES1 = 0 Then BES1 = XDiffposS1(0)
If BES2 = 0 Then BES2 = XDiffposS2(0)
If BES3 = 0 Then BES3 = XDiffposS3(0)

If LenXoverSeqS1 < 1 Or LenXoverSeqS2 < 1 Or LenXoverSeqS3 < 1 Then Exit Sub


Dim tMissingData() As Byte
ReDim tMissingData(Len(StrainSeq(0)), 2)
For x = 0 To Len(StrainSeq(0))
    tMissingData(x, 0) = MissingData(x, Seq1)
    tMissingData(x, 1) = MissingData(x, Seq2)
    tMissingData(x, 2) = MissingData(x, Seq3)
Next x

Dim PermRangeS1() As Long, PermRangeS2() As Long, PermRangeS3() As Long
ReDim PermRangeS1(1, LenXoverSeqS1), PermRangeS2(1, LenXoverSeqS2), PermRangeS3(1, LenXoverSeqS3)

For A = 0 To 2
    'ReDim XOverSeqNumPerms(Len(StrainSeq(0)), 100)
    ReDim tXOverSeqNum(Len(StrainSeq(0)))
    ReDim SeqRnd(Len(StrainSeq(0)), 2)
    ReDim PermRange(1, Len(StrainSeq(0)))
    
    If A = 0 Then
        If MultNegS1 = 0 Then
            Seq1 = tSeq2
            Seq2 = tSeq1
        Else
            Seq2 = tSeq2
            Seq1 = tSeq1
        End If
        Seq3 = tSeq3
    ElseIf A = 1 Then
        
        If MultNegS2 = 0 Then
            Seq1 = tSeq3
            Seq2 = tSeq1
        Else
            Seq2 = tSeq3
            Seq1 = tSeq1
        End If
        Seq3 = tSeq2
    Else
        If MultNegS3 = 0 Then
            Seq1 = tSeq3
            Seq2 = tSeq2
        Else
            Seq2 = tSeq3
            Seq1 = tSeq2
        End If
        
        Seq3 = tSeq1
    End If
    ReDim xPosdiffx(Len(StrainSeq(0))), xDiffposx(Len(StrainSeq(0)))
    ReDim tXOverSeqNum(Len(StrainSeq(0)))
    'SS = Abs(GetTickCount)
    If LenXoverSeqS1 >= LenXoverSeqS2 And LenXoverSeqS1 >= LenXoverSeqS3 Then
        LenXoverSeq = LenXoverSeqS1
    ElseIf LenXoverSeqS2 >= LenXoverSeqS1 And LenXoverSeqS2 >= LenXoverSeqS3 Then
        LenXoverSeq = LenXoverSeqS2
    Else
        LenXoverSeq = LenXoverSeqS3
    End If
    For Z = 0 To LenXoverSeq
        PermRange(1, Z) = LenXoverSeq
        PermRange(0, Z) = -LenXoverSeq
    Next Z
    Dim TimeX As Long, TimeY As Long
    If UpdateIDFlag = 0 Then
        For x = 1 To 100
         
            
            Dummy = TSeqPerms(Seq1, Seq2, Seq3, Len(StrainSeq(0)), THold(0), tMissingData(0, 0), SeqNum(0, 0), SeqRnd(0, 0))
            'Dummy = TSeqPermsP(Seq1, Seq2, Seq3, Len(StrainSeq(0)), THold(0), tMissingData(0, 0), SeqNum(0, 0), SeqRnd(0, 0))
  
            
            
            sbe = 0
            SEN = 0
            SM = 0
            sn = 0
            sk = 0
            
            '@
            LenXoverSeqx = FindSubSeqTS2(Len(StrainSeq(0)), 0, 1, 2, sbe, SEN, BE2, EN2, SM, sn, sk, NL, xPosdiffx(0), xDiffposx(0), SeqRnd(0, 0), tXOverSeqNum(0), tMissingData(0, 0))
            'For Z = 0 To Len(StrainSeq(0))
            '    XOverSeqNumPerms(Z, X) = tXOverSeqNum(Z)
            'Next Z
            
            '@
            For Z = 0 To LenXoverSeqx
                If tXOverSeqNum(Z) > PermRange(0, Z) Then
                    PermRange(0, Z) = tXOverSeqNum(Z)
                End If
                If tXOverSeqNum(Z) < PermRange(1, Z) Then
                    PermRange(1, Z) = tXOverSeqNum(Z)
                End If
            Next Z
            '@
'            TimeX = abs(gettickcount)
'            If Abs(TimeX - TimeY) > 500 Then
'                TimeY = TimeX
'                Form1.SSPanel1.Caption = Trim(Str(X)) + " of 100 permutations completed"
'                Form1.ProgressBar1 = (A / 3 * 33) + (X / 100) * 33
'                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'            End If
        Next x
    End If
'    EE = Abs(GetTickCount)
'    TT = EE - SS '53328,53578
'     SS = Abs(GetTickCount)
'
'    EE = Abs(GetTickCount)
'    TT = EE - SS
'    X = X
    If A = 0 Then
        For x = 0 To LenXoverSeqS1
            PermRangeS1(1, x) = PermRange(1, x)
            PermRangeS1(0, x) = PermRange(0, x)
        Next x
    ElseIf A = 1 Then
        For x = 0 To LenXoverSeqS2
            PermRangeS2(1, x) = PermRange(1, x)
            PermRangeS2(0, x) = PermRange(0, x)
        Next x
    Else
        For x = 0 To LenXoverSeqS3
            PermRangeS3(1, x) = PermRange(1, x)
            PermRangeS3(0, x) = PermRange(0, x)
        Next x
    End If
Next A
    
 If dPValueS1 > 0 And (dPValueS1 <= dPValueS2 Or dPValueS2 = 0) And (dPValueS1 <= dPValueS3 Or dPValueS3 = 0) Then
    dPValue = dPValueS1
    EN = ENS1
    BE = BES1
 ElseIf dPValueS2 > 0 And (dPValueS2 <= dPValueS1 Or dPValueS1 = 0) And (dPValueS2 <= dPValueS3 Or dPValueS3 = 0) Then
    dPValue = dPValueS2
    EN = ENS2
    BE = BES2
 Else
    dPValue = dPValueS3
    EN = ENS3
    BE = BES3
 End If
' performs a Dunn-Sidak correction for pval with m trials
 xpValue = dPValue * MCCorrection
 If dPValue >= 1 Then
     dPValue = 1
 Else
     dPValue = 1 - (1 - dPValue) ^ MCCorrection
 End If
 'characterise the event
 If dPValue = 0 Then dPValue = xpValue
 Dim Max As Double, Min As Double
 Max = -LenXoverSeq
 Min = LenXoverSeq
 For x = 0 To LenXoverSeqS1
     If Max < XoverSeqNumTS1(x) Then Max = XoverSeqNumTS1(x)
     If Min > XoverSeqNumTS1(x) Then Min = XoverSeqNumTS1(x)
 Next x
 
For x = 0 To LenXoverSeqS2
    If Max < XoverSeqNumTS2(x) Then Max = XoverSeqNumTS2(x)
    If Min > XoverSeqNumTS2(x) Then Min = XoverSeqNumTS2(x)
Next x

For x = 0 To LenXoverSeqS3
    If Max < XoverSeqNumTS3(x) Then Max = XoverSeqNumTS3(x)
    If Min > XoverSeqNumTS3(x) Then Min = XoverSeqNumTS3(x)
Next x


For x = 0 To LenXoverSeqS1
    If Max < PermRangeS1(0, x) Then Max = PermRangeS1(0, x)
    If Min > PermRangeS1(1, x) Then Min = PermRangeS1(1, x)
Next x

For x = 0 To LenXoverSeqS2
    If Max < PermRangeS2(0, x) Then Max = PermRangeS2(0, x)
    If Min > PermRangeS2(1, x) Then Min = PermRangeS2(1, x)
Next x

For x = 0 To LenXoverSeqS3
    If Max < PermRangeS3(0, x) Then Max = PermRangeS3(0, x)
    If Min > PermRangeS3(1, x) Then Min = PermRangeS3(1, x)
Next x
 
 Dim YScaleFactor As Double, PntAPI As POINTAPI, Pict As Long
'Form1.Picture7.Picture = LoadPicture()
YScaleFactor = 0.85
PicHeight = Form1.Picture7.Height * YScaleFactor
XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))


 Dim red As Long, Green As Long, blue As Long, hRed As Long, hGreen As Long, hBlue As Long


ReDim XDiffPosC(Len(StrainSeq(0)) + 200, 2)
ReDim xLenXoverSeq(2)
GDPCFlag = 1
xLenXoverSeq(0) = LenXoverSeqS1
xLenXoverSeq(1) = LenXoverSeqS2
xLenXoverSeq(2) = LenXoverSeqS3

'xLenXoverSeq(Z)

For x = 0 To LenXoverSeqS1
    XDiffPosC(x, 0) = XDiffposS1(x)
Next 'X

For x = 0 To LenXoverSeqS2
    XDiffPosC(x, 1) = XDiffposS2(x)
Next 'X

For x = 0 To LenXoverSeqS3
    XDiffPosC(x, 2) = XDiffposS3(x)
Next 'X
   
GYAxHi(1) = Decompress(Len(StrainSeq(0)))
'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, Max, Min, 2, "Height")


MinPA = dPValue

If BestRescanFlag = 1 Then
    If BestRescanP > MinPA And MinPA < LowestProb And MinPA > 0 Then
        BestRescanP = MinPA
    End If
End If


If (UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
    ReDim GPVTFont(5, 100), GPVText(100)
    XX = Seq1
    XX = Seq2
    XX = Seq3
    XX = tSeq1
    XX = tSeq2
    XX = tSeq3
    GPVTNum = -1
    Green = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 6), CInt(BkB - BkB / 2))
    red = RGB(CInt(BkR - BkR / 6), CInt(BkG - BkG / 2), CInt(BkB - BkB / 2))
    blue = RGB(CInt(BkR - BkR / 2), CInt(BkG - BkG / 2), CInt(BkB - BkB / 6))
    
    
    If TManFlag <> 22 Then
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
        End If
    Else
        BE = 0
        EN = Len(StrainSeq(0))
        GBlockNum = -1
    End If
    
    'Colour the bkround white
    
    hRed = RGB(254, 254, 254)
    hBlue = RGB(253, 253, 253)
    hGreen = RGB(252, 252, 252)
    Form1.Picture7.DrawMode = 13
    Form1.Picture7.ForeColor = hGreen + 1
    
    'For X = LenXoverSeqS1 To 0 Step -1
    '    LineTo Pict, 30 + Decompress(XDiffposS1(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS1(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    '
    'LineTo Pict, 30 + Decompress(XDiffposS1(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS1(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
    
    Form1.Picture7.FillStyle = 0
    Form1.Picture7.FillColor = hGreen
    Pict = Form1.Picture7.hdc
    'dy = PicHeight - (15 + ((((PermRangeS1(1, 0) + (PermRangeS1(0, 0) - PermRangeS1(1, 0)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
    'FloodFill Pict, 30 + XDiffposS1(0) * XFactor + XFactor + 2, dy, hGreen + 1
    x = 0
    GoOn = 0
    
    Dim MaxR As Long, WinR As Long
    WinR = 10000000
    MaxR = 0
    Do While x <= LenXoverSeqS1
        If PermRangeS1(0, x) - PermRangeS1(1, x) > MaxR Then
            MaxR = PermRangeS1(0, x) - PermRangeS1(1, x)
            WinR = x
        End If
        x = x + 1
    Loop
    
    x = WinR
    If WinR = 10000000 Then Exit Sub
    
    'Do While X <= LenXoverSeqS1
        If PermRangeS1(1, x) <> PermRangeS1(0, x) Then
            If x < LenXoverSeqS1 Then
                dy = PicHeight - (15 + ((((PermRangeS1(1, x) + (PermRangeS1(0, x) - PermRangeS1(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                dX = 30 + Decompress(XDiffposS1(x)) * XFactor + XFactor
            Else
                dy = PicHeight - (15 + ((((PermRangeS1(1, x) + (PermRangeS1(0, x) - PermRangeS1(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                dX = 30 + Decompress(XDiffposS1(x)) * XFactor + XFactor
            End If
            GoOn = 1
        End If
    '    X = X + 1
    'Loop
    'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
    Pict = Form1.Picture7.hdc
    
    'If GoOn = 1 Then
    '    FloodFill Pict, dX, dy, hGreen + 1
    'End If
    
    Form1.Picture7.FillStyle = 1
    
    
    'Form1.Picture7.ForeColor = hBlue + 1
    'Pict = Form1.Picture7.hDC
    'MoveToEx Pict, 30 + Decompress(XDiffposS2(0)) * xFactor, (PicHeight - (15 + ((PermRangeS2(0, 0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    'For X = 0 To LenXoverSeqS2
    '    LineTo Pict, 30 + Decompress(XDiffposS2(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS2(1, X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    'For X = LenXoverSeqS2 To 0 Step -1
    '    LineTo Pict, 30 + Decompress(XDiffposS2(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS2(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    '
    'LineTo Pict, 30 + Decompress(XDiffposS2(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS2(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
    
    Form1.Picture7.FillStyle = 0
    Form1.Picture7.FillColor = hBlue
    Pict = Form1.Picture7.hdc
    'dy = PicHeight - (15 + ((((PermRangeS2(1, 0) + (PermRangeS2(0, 0) - PermRangeS2(1, 0)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
    'FloodFill Pict, 30 + XDiffposS2(0) * XFactor + XFactor + 2, dy, hBlue + 1
    Form1.Picture7.FillStyle = 1
    x = 0
    GoOn = 0
    WinR = 10000000
    MaxR = 0
    Do While x <= LenXoverSeqS2
        If PermRangeS2(0, x) - PermRangeS2(1, x) > MaxR Then
            MaxR = PermRangeS2(0, x) - PermRangeS2(1, x)
            WinR = x
        End If
        x = x + 1
    Loop
    If WinR < 100000 Then
        x = WinR
    
    'Do While X <= LenXoverSeqS2
        If PermRangeS2(1, x) <> PermRangeS2(0, x) Then
            If x < LenXoverSeqS2 Then
                dy = PicHeight - (15 + ((((PermRangeS2(1, x) + (PermRangeS2(0, x) - PermRangeS2(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                dX = 30 + Decompress(XDiffposS2(x)) * XFactor + XFactor
            Else
                dy = PicHeight - (15 + ((((PermRangeS2(1, x) + (PermRangeS2(0, x) - PermRangeS2(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                dX = 30 + Decompress(XDiffposS2(x)) * XFactor + XFactor
            End If
            GoOn = 1
        End If
    End If
    '    X = X + 1
    'Loop
    'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
    'Form1.Picture7.AutoRedraw = True
    Form1.Picture7.FillStyle = 0
    Form1.Picture7.FillColor = hBlue
    Pict = Form1.Picture7.hdc
    'If GoOn = 1 Then
    '    FloodFill Pict, CLng(dX), CLng(dy), hBlue + 1
    'End If
    'Form1.Picture7.Circle (dx, dy), 10, 0
    'Form1.Picture7.ForeColor = hBlue + 1
    'Form1.Picture7.DrawWidth = 1
    
    'MoveToEx Pict, dx, dy, PntAPI
    'LineTo Pict, dx, dy
    
    Form1.Picture7.ForeColor = hRed + 1
    'Pict = Form1.Picture7.hDC
    'MoveToEx Pict, 30 + Decompress(XDiffposS3(0)) * xFactor, (PicHeight - (15 + ((PermRangeS3(0, 0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    'For X = 0 To LenXoverSeqS3
    '    LineTo Pict, 30 + Decompress(XDiffposS3(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS3(1, X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    'For X = LenXoverSeqS3 To 0 Step -1
    '    LineTo Pict, 30 + Decompress(XDiffposS3(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS3(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    '
    'LineTo Pict, 30 + Decompress(XDiffposS3(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS3(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
    Form1.Picture7.FillStyle = 0
    Form1.Picture7.FillColor = hRed
    Pict = Form1.Picture7.hdc
    'dy = PicHeight - (15 + ((((PermRangeS3(1, 0) + (PermRangeS3(0, 0) - PermRangeS3(1, 0)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
    'FloodFill Pict, 30 + XDiffposS3(0) * XFactor + XFactor + 2, dy, hRed + 1
    
    x = 0
    WinR = 10000000
    MaxR = 0
    Do While x <= LenXoverSeqS3
        If PermRangeS3(0, x) - PermRangeS3(1, x) > MaxR Then
            MaxR = PermRangeS3(0, x) - PermRangeS3(1, x)
            WinR = x
        End If
        x = x + 1
    Loop
    
    
    If WinR < 10000000 Then
        x = WinR
        GoOn = 0
    
    'Do While X <= LenXoverSeqS3
        If PermRangeS3(1, x) <> PermRangeS3(0, x) Then
            If x < LenXoverSeqS3 Then
                dy = PicHeight - (15 + ((((PermRangeS3(1, x) + (PermRangeS3(0, x) - PermRangeS3(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                dX = 30 + Decompress(XDiffposS3(x)) * XFactor + XFactor
            Else
                dy = PicHeight - (15 + ((((PermRangeS3(1, x) + (PermRangeS3(0, x) - PermRangeS3(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                dX = 30 + Decompress(XDiffposS3(x)) * XFactor + XFactor
            End If
            GoOn = 1
        End If
    End If
    '    X = X + 1
    'Loop
    'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
    Pict = Form1.Picture7.hdc
    
    'If GoOn = 1 Then
    '    FloodFill Pict, dX, dy, hRed + 1
    'End If
    
    'XX = Form1.Picture7.FillStyle
    
    
    Form1.Picture7.FillStyle = 1
    Form1.Picture7.DrawMode = 13
    
    
    
    'Now do the plots
    'hRed = RGB(CInt(BkR - BkR / 4), CInt(BkG - BkG / 24), CInt(BkB - BkB / 4)) '
    '    hBlue = RGB(CInt(BkR - BkR / 24), CInt(BkB - BkB / 4), CInt(BkG - BkG / 4))
    '    hGreen = RGB(CInt(BkR - BkR / 4), CInt(BkG - BkG / 4), CInt(BkB - BkB / 24))
    
    hGreen = RGB(CInt(BkR - BkR / 4), CInt(BkG - BkG / 24), CInt(BkB - BkB / 3))
    hRed = RGB(CInt(BkR - BkR / 24), CInt(BkB - BkB / 3), CInt(BkG - BkG / 4))
    hBlue = RGB(CInt(BkR - BkR / 3), CInt(BkG - BkG / 4), CInt(BkB - BkB / 24))
    
    For Z = 0 To 0
        If Z = 0 Then
            curm = 9
        ElseIf Z = 1 Then
            
            curm = 14
        ElseIf Z = 2 Then
            curm = 10
        End If
         '6,14,10
         '3,6,9,5,5
        
        Form1.Picture7.FillStyle = 1
        Form1.Picture7.DrawMode = 13
        Form1.Picture7.ForeColor = hRed + 1
    '    Pict = Form1.Picture7.hDC
    '    MoveToEx Pict, 30 + Decompress(XDiffposS3(0)) * xFactor, (PicHeight - (15 + ((PermRangeS3(0, 0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    '    For X = 0 To LenXoverSeqS3
    '        LineTo Pict, 30 + Decompress(XDiffposS3(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS3(1, X) - Min) / (Max - Min))) * (PicHeight - 35))
    '    Next 'X
    '    For X = LenXoverSeqS3 To 0 Step -1
    '        LineTo Pict, 30 + Decompress(XDiffposS3(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS3(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
    '    Next 'X
    '
    '    LineTo Pict, 30 + Decompress(XDiffposS3(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS3(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
        Form1.Picture7.DrawMode = curm
        Form1.Picture7.FillStyle = 0
        Form1.Picture7.FillColor = hRed
        Pict = Form1.Picture7.hdc
        
        'dy = PicHeight - (15 + ((((PermRangeS3(1, 0) + (PermRangeS3(0, 0) - PermRangeS3(1, 0)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
        
        x = 0
        WinR = 10000000
        MaxR = 0
        Do While x <= LenXoverSeqS3
            If PermRangeS3(0, x) - PermRangeS3(1, x) > MaxR Then
                MaxR = PermRangeS3(0, x) - PermRangeS3(1, x)
                WinR = x
            End If
            x = x + 1
        Loop
        If WinR < 10000000 Then
            x = WinR
            GoOn = 0
            'Do While X <= LenXoverSeqS3
            If PermRangeS3(1, x) <> PermRangeS3(0, x) Then
                If x < LenXoverSeqS3 Then
                    dy = PicHeight - (15 + ((((PermRangeS3(1, x) + (PermRangeS3(0, x) - PermRangeS3(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                    dX = 30 + Decompress(XDiffposS3(x)) * XFactor + XFactor
                Else
                    dy = PicHeight - (15 + ((((PermRangeS3(1, x) + (PermRangeS3(0, x) - PermRangeS3(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                    dX = 30 + Decompress(XDiffposS3(x)) * XFactor + XFactor
                End If
                GoOn = 1
            End If
        End If
        '    X = X + 1
        'Loop
        'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
        Pict = Form1.Picture7.hdc
    
    '    If GoOn = 1 Then
    '        FloodFill Pict, dX, dy, hRed + 1
    '    End If
        'FloodFill Pict, 30 + XDiffposS3(0) * XFactor + XFactor + 2, dy, hRed + 1
        Form1.Picture7.FillStyle = 1
        Form1.Picture7.DrawMode = 13
        
        Form1.Picture7.DrawMode = 13
        Form1.Picture7.ForeColor = hGreen + 1
    '    Pict = Form1.Picture7.hDC
    '    MoveToEx Pict, 30 + Decompress(XDiffposS1(0)) * xFactor, (PicHeight - (15 + ((PermRangeS1(0, 0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    '    For X = 0 To LenXoverSeqS1
    '        LineTo Pict, 30 + Decompress(XDiffposS1(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS1(1, X) - Min) / (Max - Min))) * (PicHeight - 35))
    '    Next 'X
    '    For X = LenXoverSeqS1 To 0 Step -1
    '        LineTo Pict, 30 + Decompress(XDiffposS1(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS1(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
    '    Next 'X
    '
    '    LineTo Pict, 30 + Decompress(XDiffposS1(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS1(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
        Form1.Picture7.DrawMode = curm
        Form1.Picture7.FillStyle = 0
        Form1.Picture7.FillColor = hGreen
        Pict = Form1.Picture7.hdc
        'dy = PicHeight - (15 + ((((PermRangeS1(1, 0) + (PermRangeS1(0, 0) - PermRangeS1(1, 0)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
        'FloodFill Pict, 30 + XDiffposS1(0) * XFactor + XFactor + 2, dy, hGreen + 1
        
        x = 0
        GoOn = 0
        WinR = 10000000
        MaxR = 0
        Do While x <= LenXoverSeqS1
            If PermRangeS1(0, x) - PermRangeS1(1, x) > MaxR Then
                MaxR = PermRangeS1(0, x) - PermRangeS1(1, x)
                WinR = x
            End If
            x = x + 1
        Loop
        
        x = WinR
        'Do While X <= LenXoverSeqS1
            If PermRangeS1(1, x) <> PermRangeS1(0, x) Then
                If x < LenXoverSeqS1 Then
                    dy = PicHeight - (15 + ((((PermRangeS1(1, x) + (PermRangeS1(0, x) - PermRangeS1(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                    dX = 30 + Decompress(XDiffposS1(x)) * XFactor + XFactor
                Else
                    dy = PicHeight - (15 + ((((PermRangeS1(1, x) + (PermRangeS1(0, x) - PermRangeS1(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                    dX = 30 + Decompress(XDiffposS1(x)) * XFactor + XFactor
                End If
                GoOn = 1
            End If
        '    X = X + 1
        'Loop
        'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
        
        'Form1.Picture7.FillStyle = 0
        'Form1.Picture7.FillColor = hGreen
    '    Pict = Form1.Picture7.hDC
    '    If GoOn = 1 Then
    '        FloodFill Pict, dX, dy, hGreen + 1
    '    End If
        'Form1.Picture7.DrawWidth = 4
        'Form1.Picture7.DrawMode = 13
        'Form1.Picture7.ForeColor = 0
        'Pict = Form1.Picture7.hdc
        'MoveToEx Pict, dx, dy, PntAPI
        'LineTo Pict, dx, dy
        Form1.Picture7.FillStyle = 1
        
        Form1.Picture7.DrawMode = 13
        Form1.Picture7.ForeColor = hBlue + 1 'actually red
    '    Pict = Form1.Picture7.hDC
    '    MoveToEx Pict, 30 + Decompress(XDiffposS2(0)) * xFactor, (PicHeight - (15 + ((PermRangeS2(0, 0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    '    For X = 0 To LenXoverSeqS2
    '        LineTo Pict, 30 + Decompress(XDiffposS2(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS2(1, X) - Min) / (Max - Min))) * (PicHeight - 35))
    '    Next 'X
    '    For X = LenXoverSeqS2 To 0 Step -1
    '        LineTo Pict, 30 + Decompress(XDiffposS2(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS2(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
    '    Next 'X
    '
    '    LineTo Pict, 30 + Decompress(XDiffposS2(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRangeS2(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
        Form1.Picture7.DrawMode = curm
        Form1.Picture7.FillStyle = 0
        Form1.Picture7.FillColor = hBlue
        Pict = Form1.Picture7.hdc
        'dy = PicHeight - (15 + ((((PermRangeS2(1, 0) + (PermRangeS2(0, 0) - PermRangeS2(1, 0)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
        'FloodFill Pict, 30 + XDiffposS2(0) * XFactor + XFactor + 2, dy, hBlue + 1
        x = 0
        GoOn = 0
        WinR = 10000000
        MaxR = 0
        Do While x <= LenXoverSeqS2
            If PermRangeS2(0, x) - PermRangeS2(1, x) > MaxR Then
                MaxR = PermRangeS2(0, x) - PermRangeS2(1, x)
                WinR = x
            End If
            x = x + 1
        Loop
        If WinR < 10000000 Then
            x = WinR
        
        'Do While X <= LenXoverSeqS2
            If PermRangeS2(1, x) <> PermRangeS2(0, x) Then
                If x < LenXoverSeqS2 Then
                    dy = PicHeight - (15 + ((((PermRangeS2(1, x) + (PermRangeS2(0, x) - PermRangeS2(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                    dX = 30 + Decompress(XDiffposS2(x)) * XFactor + XFactor
                Else
                    dy = PicHeight - (15 + ((((PermRangeS2(1, x) + (PermRangeS2(0, x) - PermRangeS2(1, x)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
                    dX = 30 + Decompress(XDiffposS2(x)) * XFactor + XFactor
                End If
                GoOn = 1
            End If
        '    X = X + 1
        'Loop
        'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
        End If
    '    Pict = Form1.Picture7.hDC
    '
    '    If GoOn = 1 Then
    '        FloodFill Pict, dX, dy, hBlue + 1
    '    End If
        
        Form1.Picture7.DrawMode = 13
        Form1.Picture7.FillStyle = 1
        
        
        
    Next Z
    
    
    
    If Z = 0 Then
        Form1.Picture7.ForeColor = red
        SP = 10
        EP = 13
    ElseIf Z = 1 Then
        Form1.Picture7.ForeColor = Green
        SP = SP + 3
        EP = EP + 3
    Else
        SP = SP + 3
        EP = EP + 3
        Form1.Picture7.ForeColor = blue
    End If
    Pict = Form1.Picture7.hdc
    
    Form1.Picture7.ForeColor = Green
    SP = 10
    EP = 13
    'For X = 0 To LenXoverSeqS3
    '    MoveToEx Pict, (30 + Decompress(XDiffposS3(X)) * xFactor), SP, PntAPI
    '    LineTo Pict, (30 + Decompress(XDiffposS3(X)) * xFactor), EP
    'Next X
    '
    Form1.Picture7.ForeColor = blue
    SP = SP + 3
    EP = EP + 3
    'For X = 0 To LenXoverSeqS2
    '    MoveToEx Pict, (30 + Decompress(XDiffposS2(X)) * xFactor), SP, PntAPI
    '    LineTo Pict, (30 + Decompress(XDiffposS2(X)) * xFactor), EP
    'Next X
    '
    Form1.Picture7.ForeColor = red
    SP = SP + 3
    EP = EP + 3
    'For X = 0 To LenXoverSeqS1
    '    MoveToEx Pict, (30 + Decompress(XDiffposS1(X)) * xFactor), SP, PntAPI
    '    LineTo Pict, (30 + Decompress(XDiffposS1(X)) * xFactor), EP
    'Next X
    Form1.Picture7.DrawWidth = 2
    Form1.Picture7.ForeColor = Green
    'Pict = Form1.Picture7.hDC
    'MoveToEx Pict, 30 + Decompress(XDiffposS1(0)) * xFactor, (PicHeight - (15 + ((XoverSeqNumTS1(0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    'For X = 1 To LenXoverSeqS1
    '    LineTo Pict, 30 + Decompress(XDiffposS1(X)) * xFactor + xFactor, PicHeight - (15 + (((XoverSeqNumTS1(X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    
    'Form1.Picture7.ForeColor = blue
    'Pict = Form1.Picture7.hDC
    'MoveToEx Pict, 30 + Decompress(XDiffposS2(0)) * xFactor, (PicHeight - (15 + ((XoverSeqNumTS2(0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    'For X = 1 To LenXoverSeqS2
    '    LineTo Pict, 30 + Decompress(XDiffposS2(X)) * xFactor + xFactor, PicHeight - (15 + (((XoverSeqNumTS2(X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    
    'Form1.Picture7.ForeColor = red
    'Pict = Form1.Picture7.hDC
    'MoveToEx Pict, 30 + Decompress(XDiffposS3(0)) * xFactor, (PicHeight - (15 + ((XoverSeqNumTS3(0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
    'For X = 1 To LenXoverSeqS3
    '    LineTo Pict, 30 + Decompress(XDiffposS3(X)) * xFactor + xFactor, PicHeight - (15 + (((XoverSeqNumTS3(X) - Min) / (Max - Min))) * (PicHeight - 35))
    'Next 'X
    
    Form1.Picture7.DrawWidth = 1
    
    'Write sequenc names
    WN1 = tSeq1: WN2 = tSeq2: WN3 = tSeq3
    WNStr(1) = OriginalName(WN1): WNStr(2) = OriginalName(WN2): WNStr(3) = OriginalName(WN3)
    
    If DontRedrawPlotsFlag = 0 Then
        Call WriteNames2(WN1, WN2, WN3, Green, blue, red)
    End If
    'Call WriteNames2(tSeq1, tSeq2, tSeq3, Green, blue, red)
    
End If
 


Seq1 = tSeq1
Seq2 = tSeq2
Seq3 = tSeq3

 
 

ProbY = 1
 
 If BE < EN Then
     ProbX = (Decompress(BE) + (Decompress(EN) - Decompress(BE)) / 2)
 Else
     If EN > Len(StrainSeq(0)) - BE Then
         ProbX = Decompress(EN) / 2
     Else
         ProbX = Decompress(BE) + (Decompress(Len(StrainSeq(0))) - Decompress(BE)) / 2
     End If
     
 End If
             
 
EN = SuperEventList(XoverList(RelX, RelY).Eventnumber)
ProbTest = dPValue
If (DontRedrawPlotsFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
   Call PrintProbability
End If

If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
   XoverList(RelX, RelY).Probability = dPValue
End If

If Confirm(EN, 8) > 0 Then
    If Abs(ConfirmP(EN, 8)) < 300 Then
        PT = 10 ^ (-ConfirmP(EN, 8))
    Else
        PT = 10 ^ 300
    End If
Else
    PT = 1
End If
If MinPA < BestParentP And MinPA < LowestProb And MinPA > 0 Then
    BestParent = CheckParent: WinMethod = 6
    BestParentP = MinPA
End If
If MinPA < 0.9 Or MinPA <= LowestProb Then
     If (Confirm(EN, 8) = 1 Or Confirm(EN, 8) = 0) Or (XoverList(RelX, RelY).ProgramFlag <> 8 And XoverList(RelX, RelY).ProgramFlag <> 8 + AddNum) Then
    
            If ((Confirm(EN, 8) = 0 Or (Confirm(EN, 8) = 1) And MinPA < PT)) And MinPA < 1 And MinPA > 0 Then
                Confirm(EN, 8) = 1
                ConfirmP(EN, 8) = -Log10(MinPA)
                'ConfirmPMa(EN, 8) = -Log10(MinPA)
                If Form1.HScroll3.Value = 0 Then
                    Form1.HScroll3.Value = 1
                Else
                    Form1.HScroll3.Value = 0
                End If
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
    
        End If
 End If
 
    
If LenXoverSeqS1 >= LenXoverSeqS2 And LenXoverSeqS1 >= LenXoverSeqS3 Then
    LenXoverSeq = LenXoverSeqS1
ElseIf LenXoverSeqS2 >= LenXoverSeqS1 And LenXoverSeqS2 >= LenXoverSeqS3 Then
    LenXoverSeq = LenXoverSeqS2
ElseIf LenXoverSeqS3 >= LenXoverSeqS2 And LenXoverSeqS3 >= LenXoverSeqS1 Then
    LenXoverSeq = LenXoverSeqS3
End If
    
    
    'get everything into standard save/copy format

If (UpdateIDFlag = 0 And BestRescanFlag = 0) Or (BestRescanFlag = 1 And BestRescanP = MinPA) Then
    GPrintNum = 5 'six lines
    NSites = LenXoverSeq + 1
    ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)
    
    ReDim GVarPos(2, NSites)
    ReDim Preserve PermRangeS1(1, LenXoverSeq + 1), PermRangeS2(1, LenXoverSeq + 1), PermRangeS3(1, LenXoverSeq + 1)
    For x = LenXoverSeqS1 To NSites
        XDiffposS1(x) = XDiffposS1(LenXoverSeqS1)
        XoverSeqNumTS1(x) = XoverSeqNumTS1(LenXoverSeqS1)
        PermRangeS1(0, x) = PermRangeS1(0, LenXoverSeqS1)
        PermRangeS1(1, x) = PermRangeS1(1, LenXoverSeqS1)
    Next x
    For x = LenXoverSeqS2 To NSites
        XDiffposS2(x) = XDiffposS2(LenXoverSeqS2)
        XoverSeqNumTS2(x) = XoverSeqNumTS2(LenXoverSeqS2)
        PermRangeS2(0, x) = PermRangeS2(0, LenXoverSeqS2)
        PermRangeS2(1, x) = PermRangeS2(1, LenXoverSeqS2)
    Next x
    For x = LenXoverSeqS3 To NSites
        XDiffposS3(x) = XDiffposS3(LenXoverSeqS3)
        XoverSeqNumTS3(x) = XoverSeqNumTS3(LenXoverSeqS3)
        PermRangeS3(0, x) = PermRangeS3(0, LenXoverSeqS3)
        PermRangeS3(1, x) = PermRangeS3(1, LenXoverSeqS3)
    Next x
    
    For x = 1 To NSites
        GVarPos(0, x) = XDiffposS1(x - 1)
        GVarPos(1, x) = XDiffposS2(x - 1)
        GVarPos(2, x) = XDiffposS3(x - 1)
    Next x
    
    
    ReDim GCritval(0)
    
    
    GLegend = "Height"
    GPrintLen = NSites * 2 + 2 'how many points to plot
    GPrintCol(3) = Green 'line is black
    GPrintCol(0) = hGreen 'line is grey
    
    GPrintCol(4) = blue 'line is black
    GPrintCol(1) = hBlue 'line is grey
    
    GPrintCol(5) = red 'line is black
    GPrintCol(2) = hRed 'line is grey
    
    GPrintType = 0 'a normal line plot
    GPrintMin(0) = Min   'bottom val
    GPrintMin(1) = Max  'upper val
    
    
    
    For x = 0 To NSites - 1
        
        GPrint(3, x) = XoverSeqNumTS1(x) 'GraphPlt(0, X)
        'GPrint(0, NSites * 2 - X) = XoverSeqNumTS1(X)  'GraphPlt(0, X)
        GPrintPos(3, x) = XDiffposS1(x) 'PltPos(X)
        'GPrintPos(0, NSites * 2 - X) = XDiffposS1(X) ' PltPos(X)
        
        GPrint(4, x) = XoverSeqNumTS2(x) 'GraphPlt(0, X)
        'GPrint(1, NSites * 2 - X) = XoverSeqNumTS2(X)  'GraphPlt(0, X)
        GPrintPos(4, x) = XDiffposS2(x) 'PltPos(X)
        'GPrintPos(1, NSites * 2 - X) = XDiffposS2(X) ' PltPos(X)
        
        GPrint(5, x) = XoverSeqNumTS3(x) 'GraphPlt(0, X)
        'GPrint(2, NSites * 2 - X) = XoverSeqNumTS3(X)  'GraphPlt(0, X)
        GPrintPos(5, x) = XDiffposS3(x) 'PltPos(X)
        'GPrintPos(2, NSites * 2 - X) = XDiffposS3(X) ' PltPos(X)
        
    Next x
    
    
    For x = 0 To NSites - 1
        'PValMap(DN, PermutationX * 0.01)
        GPrint(0, x) = PermRangeS1(0, x) 'GraphPlt(1, X)
        GPrint(0, NSites * 2 - x) = PermRangeS1(1, x) 'GraphPlt(2, X)
        GPrintPos(0, x) = XDiffposS1(x) 'PltPos(X)
        GPrintPos(0, NSites * 2 - x) = XDiffposS1(x) 'PltPos(X)
        
        GPrint(1, x) = PermRangeS2(0, x) 'GraphPlt(1, X)
        GPrint(1, NSites * 2 - x) = PermRangeS2(1, x) 'GraphPlt(2, X)
        GPrintPos(1, x) = XDiffposS2(x) 'PltPos(X)
        GPrintPos(1, NSites * 2 - x) = XDiffposS2(x) 'PltPos(X)
        
        GPrint(2, x) = PermRangeS3(0, x) 'GraphPlt(1, X)
        GPrint(2, NSites * 2 - x) = PermRangeS3(1, x) 'GraphPlt(2, X)
        GPrintPos(2, x) = XDiffposS3(x) 'PltPos(X)
        GPrintPos(2, NSites * 2 - x) = XDiffposS3(x) 'PltPos(X)
        
    Next x
    GPrintPos(0, GPrintLen - 1) = GPrintPos(3, 0)
    GPrintPos(1, GPrintLen - 1) = GPrintPos(4, 0)
    GPrintPos(2, GPrintLen - 1) = GPrintPos(5, 0)
    
    'GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
    'GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
    'GPrint(0, GPrintLen - 1) = GPrint(0, 0)
    '
    'GPrintPos(1, GPrintLen - 1) = GPrintPos(1, 0)
    'GPrintPos(1, GPrintLen) = GPrintPos(1, 0)
    'GPrint(1, GPrintLen - 1) = GPrint(1, 0)
    '
    'GPrintPos(2, GPrintLen - 1) = GPrintPos(2, 0)
    'GPrintPos(2, GPrintLen) = GPrintPos(2, 0)
    'GPrint(2, GPrintLen - 1) = GPrint(2, 0)
    
    
    GPrintPos(0, GPrintLen) = GPrintPos(3, 0)
    GPrintPos(1, GPrintLen) = GPrintPos(4, 0)
    GPrintPos(2, GPrintLen) = GPrintPos(5, 0)
    GPrint(0, GPrintLen - 1) = GPrint(3, GPrintLen - 2)
    GPrint(0, GPrintLen) = GPrint(3, 0)
    GPrint(1, GPrintLen - 1) = GPrint(4, GPrintLen - 2)
    GPrint(1, GPrintLen) = GPrint(4, 0)
    GPrint(2, GPrintLen - 1) = GPrint(5, GPrintLen - 2)
    GPrint(2, GPrintLen) = GPrint(5, 0)
    
    GExtraTNum = 5
    ReDim GExtraText(5)
    GExtraText(3) = "Hyper-geometric random walk (" + OriginalName(Seq1) + ")"
    GExtraText(4) = "Hyper-geometric random walk (" + OriginalName(Seq2) + ")"
    GExtraText(5) = "Hyper-geometric random walk (" + OriginalName(Seq3) + ")"
    
    GExtraText(0) = "Bounds of 100 permuted datasets for " + OriginalName(Seq1)
    GExtraText(1) = "Bounds of 100 permuted datasets for " + OriginalName(Seq2)
    GExtraText(2) = "Bounds of 100 permuted datasets for " + OriginalName(Seq3)
    
    Call RedrawPlotAA(1)
    
      Seq1 = tSeq1
     Seq2 = tSeq2
     Seq3 = tSeq3f
     
     'MinPAGlobal = MinPA
End If
    MinPAGlobal = MinPA
End Sub
Public Sub TSXOverB()
Dim BE As Long, EN As Long, BE2 As Long, EN2 As Long, nK As Long, nM As Long, NN As Long, NL As Long, x As Long, CurrentHeight As Long, XoverSeqNumTS() As Long, XOverSeqNumPerms() As Long, Y As Long, MaxSeen As Long, MaxDescentSeen As Long
Dim II As Long, dPValue As Double
On Error Resume Next

XX = ManFlag

If UBound(XoverSeqNumTS, 1) < Len(StrainSeq(0)) Then
    ReDim XoverSeqNumTS(Len(StrainSeq(0)))
    ReDim XPosDiff(Len(StrainSeq(0)) + 100), XDiffPos(Len(StrainSeq(0)) + 100)
End If
On Error GoTo 0



tSeq1 = Seq1
tSeq2 = Seq2
tSeq3 = Seq3
'XX = RelX
'XX = RelY

If XTableFlag = 0 Then Call Build3SeqTable
If XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Then
    Seq3 = CLng(Abs(XoverList(RelX, RelY).DHolder))
    'XOverList(RelX, RelY).DHolder = 51
    'Seq1 = 6
    'XOverList(RelX, RelY).LHolder = 75
    If Seq3 <> tSeq1 And Seq3 <> tSeq2 And Seq3 <> tSeq3 Then
        For x = 0 To NextNo
            If TreeTrace(x) = Seq3 And (x = tSeq1 Or x = tSeq2 Or x = tSeq3) Then
                Seq3 = x: Exit For
            End If
        Next x
    End If
    If Seq3 = tSeq1 Then
        Seq2 = tSeq2
        Seq1 = tSeq3
    ElseIf Seq3 = tSeq2 Then
        Seq2 = tSeq1
        Seq1 = tSeq3
    ElseIf Seq3 = tSeq3 Then
        Seq2 = tSeq1
        Seq1 = tSeq2
    Else
        
        
        Seq1 = tSeq1
        Seq2 = tSeq2
        Seq3 = tSeq3
        Call TSXOverC
        Exit Sub
    End If
Else
    Seq1 = tSeq3
    Seq2 = tSeq1
    Seq3 = tSeq2
End If




'Call TSXOver(0)
ReDim XoverSeqNumTS(Len(StrainSeq(0)))
'ReDim XOverSeqNumPerms(Len(StrainSeq(0)), 100)

Dim tXOverSeqNum() As Long
ReDim tXOverSeqNum(Len(StrainSeq(0)))
Rnd (-BSRndNumSeed)
Dim Tmp As Long, THold(2) As Long, SeqRnd() As Integer, dPValue2 As Double, xPosdiffx() As Long, xDiffposx() As Long, sn As Long, SM As Long, sk As Long, sbe As Long, SEN As Long
ReDim SeqRnd(Len(StrainSeq(0)), 2)
        
        BE = 0
        EN = 0
        nM = 0
        NN = 0
        nK = 0
        LenXoverSeq = FindSubSeqTS2(Len(StrainSeq(0)), Seq1, Seq2, Seq3, BE, EN, BE2, EN2, nM, NN, nK, NL, XPosDiff(0), XDiffPos(0), SeqNum(0, 0), XoverSeqNumTS(0), MissingData(0, 0))
        'XX = XDiffPos(1)
        'XX = XPosDiff(23)
'        For X = 0 To UBound(XPosDiff, 1) - 1
'            XPosDiff(X) = XPosDiff(X + 1)
'        Next X
        '2,7,3:2642,1208,1208,2642:26,20,13,19
        '1312,2309
        '2352,1306
        
        '1306,2309
        '2309,1306
        '9280-1426
    
        
        Call CheckWrap(LenXoverSeq, nK, BE, EN, 1, XDiffPos(), XPosDiff(), XoverSeqNumTS())
        Call CheckWrap(LenXoverSeq, NL, BE2, EN2, -1, XDiffPos(), XPosDiff(), XoverSeqNumTS())
        '13,2653,1208
        '19,1214,2642
       
        GetTSPVal WF, nM, NN, nK, dPValue
        GetTSPVal WF2, NN, nM, NL, dPValue2
        MultNeg = 0
        If dPValue2 < dPValue Then
            Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, NN, nK, NL, dPValue, dPValue2, MultNeg)
        End If
        '1496-140, 153-1426
        If MultNeg = 1 Then
            For x = 0 To LenXoverSeq
                XoverSeqNumTS(x) = XoverSeqNumTS(x) * -1
            Next x
        End If
            '1.646-4,699,18
            
        Call CheckSplit3Seq(BE, EN, nM, NN, dPValue, LenXoverSeq, XoverSeqNumTS(), XPosDiff(), XDiffPos())
        If dPValue > dPValue2 Or FindallFlag = 1 Then
            If MultNeg = 0 Then
                For x = 0 To LenXoverSeq
                    XoverSeqNumTS(x) = XoverSeqNumTS(x) * -1
                Next x
                'Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, nN, nK, nL, dPValue, dPValue2, MultNeg)
            End If
            Call CheckSplit3Seq(BE2, EN2, NN, nM, dPValue2, LenXoverSeq, XoverSeqNumTS(), XPosDiff(), XDiffPos())
            If FindallFlag = 0 And dPValue > dPValue2 Then
                If MultNeg = 1 Then
                    MultNeg = 0
                    'For X = 0 To LenXoverSeq
                    '    XoverSeqNumTS(X) = XoverSeqNumTS(X) * -1
                    'Next X
                Else
                    MultNeg = 1
                    'For X = 0 To LenXoverSeq
                    '    XoverSeqNumTS(X) = XoverSeqNumTS(X) * -1
                    'Next X
                    
                End If
                Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, NN, nK, NL, dPValue, dPValue2, MultNeg)
                
            End If
        
        End If
        
        
        
        
        If BE = 0 Then BE = XDiffPos(0)
        If LenXoverSeq < 1 Then Exit Sub
        
        
        Dim tMissingData() As Byte
        ReDim tMissingData(Len(StrainSeq(0)), 2)
        For x = 0 To Len(StrainSeq(0))
        
'            If MissingData(X, Seq1) > 0 Or MissingData(X, Seq2) > 0 Or MissingData(X, Seq3) > 0 Then
'                X = X
'            End If
            tMissingData(x, 0) = MissingData(x, Seq1)
            tMissingData(x, 1) = MissingData(x, Seq2)
            tMissingData(x, 2) = MissingData(x, Seq3)
        Next x
        
        xtSeq1 = Seq1
        xtSeq2 = Seq2
        
        If MultNeg = 1 Then
            Seq1 = xtSeq2
            Seq2 = xtSeq1
        End If
        Dim PermRange() As Long
        ReDim PermRange(1, LenXoverSeq)
        For x = 0 To LenXoverSeq
            PermRange(1, x) = LenXoverSeq
            PermRange(0, x) = -LenXoverSeq
           
        Next x
        ReDim xPosdiffx(Len(StrainSeq(0))), xDiffposx(Len(StrainSeq(0)))
        ReDim tXOverSeqNum(Len(StrainSeq(0)))
        
        For x = 1 To 100
            If x = x Then
                Dummy = TSeqPerms(Seq1, Seq2, Seq3, Len(StrainSeq(0)), THold(0), tMissingData(0, 0), SeqNum(0, 0), SeqRnd(0, 0))
            Else
                 For Z = 1 To Len(StrainSeq(0))
                     
                     SeqRnd(Z, 0) = SeqNum(Z, Seq1)
                     SeqRnd(Z, 1) = SeqNum(Z, Seq2)
                     SeqRnd(Z, 2) = SeqNum(Z, Seq3)
                 Next Z
                
                 For Z = 1 To Len(StrainSeq(0))
                     NewPos = CLng(Rnd * (Len(StrainSeq(0)) - 1)) + 1
                     
                     If tMissingData(Z, 0) = 0 And tMissingData(Z, 1) = 0 And tMissingData(Z, 2) = 0 And tMissingData(NewPos, 0) = 0 And tMissingData(NewPos, 1) = 0 And tMissingData(NewPos, 2) = 0 Then
                         THold(0) = SeqRnd(Z, 0)
                         THold(1) = SeqRnd(Z, 1)
                         THold(2) = SeqRnd(Z, 2)
                         SeqRnd(Z, 0) = SeqRnd(NewPos, 0)
                         SeqRnd(Z, 1) = SeqRnd(NewPos, 1)
                         SeqRnd(Z, 2) = SeqRnd(NewPos, 2)
                         SeqRnd(NewPos, 0) = THold(0)
                         SeqRnd(NewPos, 1) = THold(1)
                         SeqRnd(NewPos, 2) = THold(2)
                     End If
                 Next Z
            End If
            
            sbe = 0
            SEN = 0
            SM = 0
            sn = 0
            sk = 0
            
            LenXoverSeqx = FindSubSeqTS2(Len(StrainSeq(0)), 0, 1, 2, sbe, SEN, BE2, EN2, SM, sn, sk, NL, xPosdiffx(0), xDiffposx(0), SeqRnd(0, 0), tXOverSeqNum(0), tMissingData(0, 0))
            For Z = 0 To LenXoverSeq
                If tXOverSeqNum(Z) > PermRange(0, Z) Then PermRange(0, Z) = tXOverSeqNum(Z)
                If tXOverSeqNum(Z) < PermRange(1, Z) Then PermRange(1, Z) = tXOverSeqNum(Z)
            Next Z
            Form1.Refresh
        
            SS = Abs(GetTickCount)
            If Abs(SS - LS) > 500 Then
                LS = SS
                
                Form1.SSPanel1.Caption = Str(x) + "% of permutations completed"
                Call UpdateF2Prog
                If App.UnattendedApp = True Then DoEvents
            End If
        Next x
        'App.UnattendedApp = False
        Seq1 = xtSeq1
        Seq2 = xtSeq2
   
    
    'If nN > 0 And nK = 1 Then Exit Sub
    
    'If nN - nM = nK Then Exit Sub
    
    'Compute P-vale for maxdescent=(nK)
    
   ' if( m < mSize && n < nSize && k < kSize && n < kSize && n < jSize )
   ' {
   '     double dPValue = ((double)0);
    
    
    
    
    
    
    
   ' performs a Dunn-Sidak correction for pval with m trials
    xpValue = dPValue * MCCorrection
    If dPValue >= 1 Then
        dPValue = 1
    Else
        dPValue = 1 - (1 - dPValue) ^ MCCorrection
    End If
    'characterise the event
    If dPValue = 0 Then dPValue = xpValue
    Dim Max As Double, Min As Double
    Max = -LenXoverSeq
    Min = LenXoverSeq
    For x = 0 To LenXoverSeq
        If Max < XoverSeqNumTS(x) Then Max = XoverSeqNumTS(x)
        If Min > XoverSeqNumTS(x) Then Min = XoverSeqNumTS(x)
        
    
    Next x
    
    'For Z = 1 To 100
    For x = 0 To LenXoverSeq
        If Max < PermRange(0, x) Then Max = PermRange(0, x)
        If Min > PermRange(1, x) Then Min = PermRange(1, x)
        
    
    Next x
    'Next Z
    
    Dim YScaleFactor As Double, PntAPI As POINTAPI, Pict As Long
    Form1.Picture7.Picture = LoadPicture()
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
    
    
    
    
    GPrintNum = 1 'two lines
NSites = LenXoverSeq + 1





ReDim GPVTFont(5, 100), GPVText(100)
    GPVTNum = -1








ReDim GPrint(GPrintNum, NSites * 2 + 2), GPrintCol(GPrintNum), GPrintPos(GPrintNum, NSites * 2 + 2)

ReDim GVarPos(0, NSites)
For x = 1 To NSites
    GVarPos(0, x) = XDiffPos(x - 1)
'    If XDiffPos(X - 1) = 0 Then
'        X = X
'    End If
Next x
GVarPos(0, 0) = GVarPos(0, 1)
'XX = GVarPos(0, NSites)
'GVarPos(0, NSites + 1) = GVarPos(0, NSites)
ReDim GCritval(0)


GLegend = "Height"
GPrintLen = NSites * 2 + 2 'how many points to plot
GPrintCol(0) = 0 'line is black
GPrintCol(1) = RGB(128, 128, 128) 'line is grey


GPrintType = 0 'a normal line plot
GPrintMin(0) = Min   'bottom val
GPrintMin(1) = Max  'upper val





For x = 0 To NSites - 1
    
    GPrint(0, x + 1) = XoverSeqNumTS(x) 'GraphPlt(0, X)
    'GPrint(0, NSites * 2 - X) = XoverSeqNumTS(X)  'GraphPlt(0, X)
    GPrintPos(0, x + 1) = XDiffPos(x) 'PltPos(X)
    'GPrintPos(0, NSites * 2 - X) = XDiffPos(X) ' PltPos(X)
    
    
Next x


For x = 0 To NSites - 1
    'PValMap(DN, PermutationX * 0.01)
    GPrint(1, x) = PermRange(0, x) 'GraphPlt(1, X)
    GPrint(1, NSites * 2 - x) = PermRange(1, x) 'GraphPlt(2, X)
    GPrintPos(1, x) = XDiffPos(x) 'PltPos(X)
    GPrintPos(1, NSites * 2 - x) = XDiffPos(x) 'PltPos(X)
    
    
Next x

















GPrintPos(1, GPrintLen - 1) = GPrintPos(1, 0)

'GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)
GPrintPos(1, GPrintLen) = GPrintPos(1, 0)
'GPrintPos(0, GPrintLen) = GPrintPos(0, 0)

'GPrint(0, GPrintLen - 1) = GPrint(0, 0)
GPrint(1, GPrintLen - 1) = GPrint(1, GPrintLen - 2)
GPrint(1, GPrintLen) = GPrint(1, 0)

GExtraTNum = 1
ReDim GExtraText(1)
GExtraText(0) = "Hyper-geometric random walk"
GExtraText(1) = "Bounds of 100 permuted datasets"
    
'XX = GPrintPos(0, 0)
 'Dim XDiffPosC() As Long


    GYAxHi(1) = Decompress(Len(StrainSeq(0)))
    
    'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, Max, Min, 1, "Height")
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    If TManFlag <> 22 Then
        If DontRedrawPlotsFlag = 0 Then
            Call Highlight(0)
        End If
    End If
'
'
'
'    Pict = Form1.Picture7.hDC
'
'    Form1.Picture7.ForeColor = RGB(127, 127, 127)
'    MoveToEx Pict, 30 + Decompress(XDiffPos(0)) * xFactor, (PicHeight - (15 + ((PermRange(0, 0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
'
'    For X = 0 To LenXOverSeq
'
'        LineTo Pict, 30 + Decompress(XDiffPos(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRange(1, X) - Min) / (Max - Min))) * (PicHeight - 35))
'    Next 'X
'
'    For X = LenXOverSeq To 0 Step -1
'
'        LineTo Pict, 30 + Decompress(XDiffPos(X)) * xFactor + xFactor, PicHeight - (15 + (((PermRange(0, X) - Min) / (Max - Min))) * (PicHeight - 35))
'    Next 'X
'    LineTo Pict, 30 + Decompress(XDiffPos(0)) * xFactor + xFactor, PicHeight - (15 + (((PermRange(1, 0) - Min) / (Max - Min))) * (PicHeight - 35))
'
'    'MoveToEx Pict, 30 + XDiffpos(2) * XFactor + XFactor, 0, PntAPI
'    'LineTo Pict, 30 + XDiffpos(2) * XFactor + XFactor, 1000
'    Form1.Picture7.FillStyle = 0
'    Form1.Picture7.FillColor = RGB(128, 128, 128)
'    Pict = Form1.Picture7.hDC
'    X = 0
'    GoOn = 0
'    Dim MaxR As Long, WinR As Long
'    WinR = -1
'
'    MaxR = 0
'    Do While X <= LenXOverSeq
'        If PermRange(0, X) - PermRange(1, X) > MaxR Then
'            MaxR = PermRange(0, X) - PermRange(1, X)
'            WinR = X
'        End If
'        X = X + 1
'    Loop
'
'    X = WinR
'    If X < LenXOverSeq Then
'        dy = PicHeight - (15 + ((((PermRange(1, X) + (PermRange(0, X) - PermRange(1, X)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
'        dX = 30 + Decompress(XDiffPos(X)) * xFactor + xFactor
'    Else
'        dy = PicHeight - (15 + ((((PermRange(1, X) + (PermRange(0, X) - PermRange(1, X)) / 2) - Min) / (Max - Min))) * (PicHeight - 35))
'        dX = 30 + Decompress(XDiffPos(X)) * xFactor + xFactor
'    End If
'    GoOn = 1
'
'
'
'        'get everything into standard save/copy format
'
'
'
'
'
'    'ExtFloodFill Pict, XDiffpos(0) * XFactor + XFactor + 1, dy, RGB(128, 128, 128), 1
'    Pict = Form1.Picture7.hDC
'
'    If GoOn = 1 Then
'        FloodFill Pict, dX, dy, RGB(127, 127, 127)
'    End If
'
'    'LineTo Pict, 30 + XDiffpos(0) * XFactor + XFactor + 2, dy
'    Form1.Picture7.FillStyle = 1
    If TManFlag <> 22 Then
        'Call Highlight(0)
    Else
        BE = 0
        EN = Len(StrainSeq(0))
         GBlockNum = -1
    End If

'    Form1.Picture7.ForeColor = 0
'
'
'
'    MoveToEx Pict, 30 + Decompress(XDiffPos(0)) * xFactor, (PicHeight - (15 + ((XoverSeqNumTS(0) - Min) / (Max - Min)) * (PicHeight - 35))), PntAPI
'
'    For X = 1 To LenXOverSeq
'
'        LineTo Pict, 30 + Decompress(XDiffPos(X)) * xFactor + xFactor, PicHeight - (15 + (((XoverSeqNumTS(X) - Min) / (Max - Min))) * (PicHeight - 35))
'    Next 'X


    Call RedrawPlotAA(1)

    Seq1 = tSeq1
    Seq2 = tSeq2
    Seq3 = tSeq3

    
    ProbY = 1
    If BE < EN Then
        ProbX = (Decompress(BE) + (Decompress(EN) - Decompress(BE)) / 2)
    Else
        If EN > Decompress(Len(StrainSeq(0))) - Decompress(BE) Then
            ProbX = Decompress(EN) / 2
        Else
            ProbX = Decompress(BE) + (Decompress(Len(StrainSeq(0))) - Decompress(BE)) / 2
        End If
        
    End If
                
    
    
    ProbTest = dPValue
    If DontRedrawPlotsFlag = 0 Then
        Call PrintProbability
    End If
    If CurrentCheck = -1 Or GrabProbsFlag = 1 Then
        XoverList(RelX, RelY).Probability = dPValue
    End If
    If TManFlag <> 22 Then
        ReDim CXoverSeq(2)
        
        CXoverSeq(0) = String(LenXoverSeq, " ")
        CXoverSeq(1) = String(LenXoverSeq, " ")
        CXoverSeq(2) = String(LenXoverSeq, " ")
        A = 0
        For x = 1 To LenXoverSeq
            If XDiffPos(x) > 0 Then
                A = A + 1
                Mid(CXoverSeq(0), A, 1) = Mid(StrainSeq(TreeTrace(Seq1)), XDiffPos(x), 1)
                Mid(CXoverSeq(1), A, 1) = Mid(StrainSeq(TreeTrace(Seq2)), XDiffPos(x), 1)
                Mid(CXoverSeq(2), A, 1) = Mid(StrainSeq(TreeTrace(Seq3)), XDiffPos(x), 1)
            End If
        Next x
    End If
    Seq1 = tSeq1
    Seq2 = tSeq2
    Seq3 = tSeq3
    
 
    MinPAGlobal = MinPA



    
    
    
End Sub
Public Sub TSChecking()
    Dim WeightMod() As Long, Scratch() As Integer
    'This is the subroutine that is called when checking RDP results
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    OptFlag = -1
    
    
    Dim OS1 As Long, OS2 As Long, OS3 As Long
    
    OS1 = Seq1
    OS2 = Seq2
    OS3 = Seq3
    Seq1 = ISPerm(0)
    Seq2 = ISPerm(1)
    Seq3 = ISPerm(2)
    If CurrentCheck = 16 Or AllCheckFlag = 1 Then
        If TSSFlag = 1 Then
            Call TSXOverB
        Else
            Call TSXOverC
        End If
    ElseIf CurrentCheck = 0 Then
        xSpacerFlag = SpacerFlag
        XOverWindowX = CDbl(Form3.Text2.Text)
        
        Call XOverIII(0)
        
        SpacerFlag = xSpacerFlag
        Call FindSubSeqChi
    ElseIf CurrentCheck = 1 Then
            If Len(StrainSeq(0)) >= 30000 Then
                Call GCCompare
            End If
        'If togglex = 0 Then
            Call GCCheck(0)
            Call FindSubSeqChi
        'Else
        '    Call GCXoverE
        'End If
        'togglex = togglex + 1
        'If togglex = 2 Then togglex = 0
        
    ElseIf CurrentCheck = 13 Then
        Call PXoverD(0)
       Call FindSubSeqChi
     
        
    ElseIf CurrentCheck = 2 Then
        
        Call FindSubSeqBS
        
        If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then

            Call BSXoverl(0)

        Else

            
                
                s1col = Yellow
                s1colb = LYellow
                s2col = Purple
                s2colb = LPurple
                s3col = Green
                s2colb = LGreen
                Call FindSubSeqBS
                
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())

               

            

        End If
        
        Call FindSubSeqChi

    ElseIf CurrentCheck = 3 Then
        
        Call FindSubSeqBS
        
        
            s1col = Yellow
            s1colb = LYellow
            s2col = Purple
            s2colb = LPurple
            s3col = Green
            s2colb = LGreen
            Call FindSubSeqBS
            
                ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                Call BSXoverM(0, 0, WeightMod())


        Call FindSubSeqChi
        
        
    ElseIf CurrentCheck = 4 Then
        
        Call MCXoverG(0)
        Call FindSubSeqChi
       
    ElseIf CurrentCheck = 5 Then
        
        Call SSXoverB(0)
       
       Call FindSubSeqChi
       
    ElseIf CurrentCheck = 6 Then

       
            
            Call FindSubSeqBS
            
            Call LXoverB(0, 1)
            Call FindSubSeqChi
          

    ElseIf CurrentCheck = 7 Then

  

    ElseIf CurrentCheck = 8 Then
        
        Call FindSubSeqBS
        
        Call DXoverE
        Call FindSubSeqChi
    ElseIf CurrentCheck = 40 Then
        Call VisRD(1)
    ElseIf CurrentCheck = 41 Then
        Call VisRD(0)
    ElseIf CurrentCheck = 9 Then

        
            
            Call FindSubSeqBS
            
            Call TXover3
            Call FindSubSeqChi

    ElseIf CurrentCheck = 10 Then
        
        Call CXoverC(0)
        Call FindSubSeqChi
    ElseIf CurrentCheck = 11 Then

        Call RecOverview2

    ElseIf CurrentCheck = 12 Then
        Call RecombMap
    ElseIf CurrentCheck = 14 Then
        Call RecombMapII
    ElseIf CurrentCheck = 15 Then
        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
            Call RecombMapIIIS
        Else
            Call RecombMapIII
        End If
    ElseIf CurrentCheck = 55 Then
        
        Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)
    End If
    Dim AH(2) As Long
    Seq1 = OS1
    Seq2 = OS2
    Seq3 = OS3
    
    If Screen.MousePointer <> oPointer Then
        Screen.MousePointer = oPointer
    End If
End Sub

Public Function Get3SeqPval(M, n, k, j)
'VB version of Boni's float ytable::prob(int m, int n, int k, int j) in ProbTables.ccp
If M > UBound(YTable, 1) - 1 Or n > UBound(YTable, 1) - 1 Then Get3SeqPval = 1: Exit Function
If j > UBound(YTable, 3) - 1 Or k > UBound(YTable, 3) - 1 Then Get3SeqPval = 1: Exit Function
Dim D As Single
    
    
    D = -1
    If j > k Then
    
        Get3SeqPval = 0
        Exit Function
    ElseIf k > n Or k < n - M Or j > n Or j < n - M Then
    
        Get3SeqPval = 0
        Exit Function
    ElseIf n = 0 Then
    
        If k = 0 And j = 0 Then
        
            Get3SeqPval = 1
            Exit Function
        
        Else
            Get3SeqPval = 0
            Exit Function
        End If
    ElseIf M = 0 Then
   
        If k = n And j = n Then
       
            Get3SeqPval = 1
            Exit Function
        
        Else
       
            Get3SeqPval = 0
            Exit Function
       End If
     ElseIf k = 0 And j = 0 Then
    
        If n = 0 Then
        
            Get3SeqPval = 1
            Exit Function
        
        Else
        
            Get3SeqPval = 0
            Exit Function
        End If
    End If
    
    
    
'    if( metatable[ m*nSize + n ] == NULL )
'    {
'        metatable[ m*nSize + n ] = new float[ jSize*kSize ];
'    T = metatable[ m*nSize + n ];
    
'    // now fill it up with (-1)s
'    for(a=0; a < kSize; a++)
'        for(b=0; b < jSize; b++ )
'        {
'            T[ jSize*a + b ] = ((float)-1);
'        }
'
'    // and make sure you record that you have allocated memory for
'    // another pointer in the metatable
'    nNumAllocatedInMeta++;
'    }
'    Else
'    {
'        T = metatable[ m*nSize + n ];
'    }
    
    ' if it's in the table, just return it
    
    
   
        
        
        If YTable(M, n, k, j) >= 0 Then
            
            Get3SeqPval = YTable(M, n, k, j)
            '50,1,1,1
            '50,1,1,0
        Else
            If j = 0 Then
            
                D = (M / (n + M)) * (Get3SeqPval(M - 1, n, k, 1) + Get3SeqPval(M - 1, n, k, 0))
                
            Else 'j > 0 Then
                If k = j Then
                    D = (n / (n + M)) * (Get3SeqPval(M, n - 1, j - 1, j - 1) + Get3SeqPval(M, n - 1, j, j - 1))
                Else ' k > j Then
                    D = (M / (n + M)) * Get3SeqPval(M - 1, n, k, j + 1) + (n / (n + M)) * Get3SeqPval(M, n - 1, k, j - 1)
                End If
            End If
            
            
            YTable(M, n, k, j) = D
            
            Get3SeqPval = D
        End If
    
    
End Function

Public Sub SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, NN, nK, NL, dPValue, dPValue2, MultNeg)
Dim T As Double, Tmp As Double
T = BE: BE = BE2: BE2 = T
T = EN: EN = EN2: EN2 = T

Tmp = nM
nM = NN
NN = Tmp

T = nK: nK = NL: NL = T
T = dPValue: dPValue = dPValue2: dPValue2 = T
MultNeg = 1
End Sub
Public Sub CheckSplit3Seq(BE, EN, nM, NN, dPValue, LenXoverSeq, XoverSeqNumTS() As Long, XPosDiff() As Long, XDiffPos() As Long)
Dim x As Long, SplitFlag As Byte, tdPValue As Double, tBE As Long, tEN As Long, LenS As Long


tBE = BE
tEN = EN
x = BE - 1
LenS = Len(StrainSeq(0))

'@'@'@'@'@'@'@
Do While x <> EN
    If x > LenS Then
        x = 1
        If EN = 0 Or EN = 1 Then
            Exit Do
        End If
    End If
    If x < 0 Then x = LenS
    If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
        '8.799e-5'26,47,33
        
        dPValue = 1
        tdPValue = SubPVal(nM, NN, LenXoverSeq, BE, x, XPosDiff(), XDiffPos, XoverSeqNumTS())
        If tdPValue < dPValue Then
            dPValue = tdPValue
            tBE = BE
            tEN = x - 1
        End If
        Exit Do
    End If
    If x = EN Then Exit Do
    x = x + 1
    If x = EN Then Exit Do
Loop

If x <> EN Then
    x = EN + 1
    '@
    Do While x <> BE
        If x < 0 Then x = Len(StrainSeq(0))
        If x > Len(StrainSeq(0)) Then x = 1
        If MissingData(x, Seq1) = 1 Or MissingData(x, Seq2) = 1 Or MissingData(x, Seq3) = 1 Then
            
            tdPValue = SubPVal(nM, NN, LenXoverSeq, x, EN, XPosDiff(), XDiffPos, XoverSeqNumTS())
            If tdPValue < dPValue Then
                dPValue = tdPValue
                tBE = x + 1
                tEN = EN
            End If
            Exit Do
        End If
        If x = BE Then Exit Do
        x = x - 1
    Loop

End If
EN = tEN
BE = tBE
End Sub

Public Sub CheckWrap(LenXoverSeq, nK, BE, EN, NegMod, XDiffPos() As Long, XPosDiff() As Long, XoverSeqNumTS() As Long)
    If BE = 0 Then BE = XDiffPos(0)
    
    If CircularFlag = 1 Or x = x Then
        'need to carry on and check to see if mindescent gets lower with wrapping
       MaxSeen = XoverSeqNumTS(XPosDiff(BE)) * NegMod
       tempAscent = XoverSeqNumTS(LenXoverSeq) * NegMod
       If BE < EN Then
            For x = 0 To XPosDiff(BE)
                 
                 If tempAscent + XoverSeqNumTS(x) * NegMod > MaxSeen Then
                    MaxSeen = tempAscent + XoverSeqNumTS(x) * NegMod
                    BE = XDiffPos(x)
                 End If
                 If MaxSeen - (tempAscent + XoverSeqNumTS(x) * NegMod) > nK Then
                    nK = MaxSeen - (tempAscent + XoverSeqNumTS(x) * NegMod)
                    EN = XDiffPos(x)
                End If
                 
             Next x
             
             'XX = MissingData(EN, Seq3)
        Else
            '0 to 15
            For x = 0 To XPosDiff(EN)
                 
                 
                 If tempAscent + XoverSeqNumTS(x) * NegMod > MaxSeen Then
                    MaxSeen = tempAscent + XoverSeqNumTS(x) * NegMod
                    BE = XDiffPos(x)
                 End If
                 If MaxSeen - (tempAscent + XoverSeqNumTS(x) * NegMod) > nK Then
                    nK = MaxSeen - (tempAscent + XoverSeqNumTS(x) * NegMod)
                    EN = XDiffPos(x)
                    x = x
                End If
                 
             Next x
        x = x
        End If
    
        
        
    End If
 '   If NegMod = 1 Then
        'If BE < EN Then 'ie highest point first, lowest point last
        
            If XPosDiff(BE) < LenXoverSeq Then
                BE = XDiffPos(XPosDiff(BE) + 1)
            Else
                BE = XDiffPos(0)
            End If
        'Else 'ie lowest point first, higest point last
        '    If XPosDiff(EN) < LenXOverSeq Then
        '        EN = XDiffPos(XPosDiff(EN) + 1)
        '    Else
        '        EN = XDiffPos(0)
        '    End If
        
        'End If
 '   Else
        'If BE > EN Then 'ie lowest point first, highest point last
    
 '           If XPosDiff(BE) < LenXOverSeq Then
 '               BE = XDiffPos(XPosDiff(BE) + 1)
 '           Else
 '               BE = XDiffPos(0)
 '           End If
        'Else 'ie highest point first, lowest point last
        '    If XPosDiff(EN) < LenXOverSeq Then
        '        EN = XDiffPos(XPosDiff(EN) + 1)
        '    Else
        '        EN = XDiffPos(0)
        '    End If
       '
       ' End If
 '   End If
    
    
    If CircularFlag = 0 Then
       
        If BE > EN Then
            If XPosDiff(EN) < LenXoverSeq Then
                TE = XDiffPos(XPosDiff(EN) + 1)
            Else
                TE = 1
            End If
            If XPosDiff(BE) > 0 Then
                EN = XDiffPos(XPosDiff(BE) - 1)
            Else
                EN = Len(StrainSeq(0))
            End If
             
            BE = TE
        End If
    
    End If
    
    
    
    Exit Sub
    'Centre the breakpoints
    If XPosDiff(EN) < LenXoverSeq Then
        EN = XDiffPos(XPosDiff(EN)) + (XDiffPos(XPosDiff(EN) + 1) - XDiffPos(XPosDiff(EN))) / 2
    Else
        EN = Len(StrainSeq(0))
    End If
    If XPosDiff(BE) > 0 Then
        BE = XDiffPos(XPosDiff(BE) - 1) + (XDiffPos(XPosDiff(BE)) - XDiffPos(XPosDiff(BE) - 1)) / 2
    Else
        BE = 1
    End If
End Sub

Public Sub PreSelect()
Dim x As Long
    
    For x = 0 To NextNo
        UYPos(x) = -1
        SYPos(x) = -1
    Next 'X
    If RefNum > 0 Then
        For x = 0 To PermNextno
            If ReferenceList(x) > 0 Then
                Selected(x) = 1
             Else
                Selected(x) = 0
            End If
        Next x
    Else
        If RelX > 0 Or RelY > 0 Then
            For x = 0 To NextNo
                Selected(x) = 0
            Next x
            olima = Selected(XoverList(RelX, RelY).MajorP)
            olimi = Selected(XoverList(RelX, RelY).MinorP)
            Selected(XoverList(RelX, RelY).MajorP) = 1
            Selected(XoverList(RelX, RelY).MinorP) = 1
            OLI = Form5.Combo1.ListIndex
            Form5.Combo1.ListIndex = RelX + 1
        End If
    End If
End Sub
Public Sub TSXOver(FindallFlag)


Dim ENX As Long, BEX As Long, BWarn As Long, EWarn As Long, DoneRedo As Long, SIP As Long, NumInList As Long, Z As Long, xpValue As Double, dPValue2 As Double, WF As Long, WF2 As Long, tempAscent As Long, BE As Long, EN As Long, BE2 As Long, EN2 As Long, nK As Long, nM As Long, NN As Long, NL As Long, x As Long, CurrentHeight As Long, Y As Long, MaxSeen As Long, MaxDescentSeen As Long
'3.610
Dim XB As Long, XE As Long, GoOn As Long, Dummy As Long, PBinFlag As Long

PBinFlag = -1
    If SelGrpFlag = 1 Then
        If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
            Exit Sub
        End If
    End If
    
    
    
    If XTableFlag = 0 Then Call Build3SeqTable
    If UBound(XoverSeqNumTS, 1) < Len(StrainSeq(0)) Then
        ReDim XoverSeqNumTS(Len(StrainSeq(0)))
    End If
        
    '@'@'@
    If SEventNumber = 0 Then
        LenXoverSeq = FindSubSeqTS(Len(StrainSeq(0)), Seq1, Seq2, Seq3, BE, EN, BE2, EN2, nM, NN, nK, NL, XPosDiff(0), XDiffPos(0), SeqNum(0, 0), XoverSeqNumTS(0))
    Else
        LenXoverSeq = FindSubSeqTS2(Len(StrainSeq(0)), Seq1, Seq2, Seq3, BE, EN, BE2, EN2, nM, NN, nK, NL, XPosDiff(0), XDiffPos(0), SeqNum(0, 0), XoverSeqNumTS(0), MissingData(0, 0))
    End If
    If LenXoverSeq < 3 Then Exit Sub
    
        
    
    
'50.016
'43.235

' scan through the loop 5.391
'24.469 just to do currntheight
'34.704 - adding vals to xoverseqnum
'    If SEventNumber = 4 Then '1
'        If Seq1 = 12 Or Seq1 = 21 Or Seq1 = 27 Then
'        If Seq2 = 12 Or Seq2 = 21 Or Seq2 = 27 Then
'        If Seq3 = 12 Or Seq3 = 21 Or Seq3 = 27 Then
'            X = X
'        End If
'        End If
'        End If
'        End If
    
    
    '26, 543-2309
    '11, 2352,398 :1775,398

    Dim II As Long, dPValue As Double, MultNeg As Byte, T As Double
    
    'Calculate/read P-value for maxdescent=(nK)
    
    GetTSPVal WF, nM, NN, nK, dPValue
    GetTSPVal WF2, NN, nM, NL, dPValue2
    
    If x = x Then
        Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeq, 1, CircularFlag, nK, BE, EN, XDiffPos(0), XPosDiff(0), XoverSeqNumTS(0))
        Dummy = CheckwrapC(Len(StrainSeq(0)), LenXoverSeq, -1, CircularFlag, NL, BE2, EN2, XDiffPos(0), XPosDiff(0), XoverSeqNumTS(0))
    Else
        Call CheckWrap(LenXoverSeq, nK, BE, EN, 1, XDiffPos(), XPosDiff(), XoverSeqNumTS())
        Call CheckWrap(LenXoverSeq, NL, BE2, EN2, -1, XDiffPos(), XPosDiff(), XoverSeqNumTS())
    End If
    
    
    'dPValue2 = 10
    MultNeg = 0
    
    If dPValue2 < dPValue Then
        Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, NN, nK, NL, dPValue, dPValue2, MultNeg)
    End If
    
    If NN > 0 And nK = 1 Then Exit Sub
    If NN - nM = nK Then Exit Sub
    
    Dim odPValue As Double, dPValueX As Double
    odPValue = dPValue
    
        
    
   ' performs a Dunn-Sidak correction for pval with m trials
    If MCFlag = 0 Then
        xpValue = dPValue * MCCorrection
        If dPValue >= 1 Or xpValue >= 1 Then
            dPValue = 1
        Else
            If dPValue > 0.000000000000001 Then
                'varv = (1 - 0.000000000000001)
                varv = (1 - dPValue)
                dPValue = 1 - (varv) ^ MCCorrection
            Else
                dPValue = xpValue
            End If
        End If
    Else
        xpValue = dPValue
    End If
    
    'characterise the event
    If ((dPValue < 1 And dPValue <= LowestProb) Or (dPValue = 1 And xpValue < LowestProb)) And xpValue > 0 Then
    
        
        If SEventNumber > 0 Then
            If MultNeg = 1 Then
                For x = 0 To LenXoverSeq
                    XoverSeqNumTS(x) = XoverSeqNumTS(x) * -1
                Next x
            End If
            '1.646-4,699,18
            
            Call CheckSplit3Seq(BE, EN, nM, NN, odPValue, LenXoverSeq, XoverSeqNumTS(), XPosDiff(), XDiffPos())
            If odPValue > dPValue2 Or FindallFlag = 1 Then
                For x = 0 To LenXoverSeq
                    XoverSeqNumTS(x) = XoverSeqNumTS(x) * -1
                Next x
                Call CheckSplit3Seq(BE2, EN2, NN, nM, dPValue2, LenXoverSeq, XoverSeqNumTS(), XPosDiff(), XDiffPos())
                If FindallFlag = 0 And odPValue > dPValue2 Then
                    
                    Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, NN, nK, NL, odPValue, dPValue2, MultNeg)
                    
                End If
            
            End If
            
            If MCFlag = 0 Then
                xpValue = odPValue * MCCorrection
                
                If odPValue >= 1 Then
                    dPValue = 1
                Else
                    If odPValue < 1 And odPValue > 0 Then
                        If odPValue > 0.000000000000001 Then
                            dPValue = 1 - (1 - odPValue) ^ MCCorrection
                        Else
                            dPValue = xpValue
                        End If
                    Else
                        If odPValue > 1 Then
                            dPValue = 10
                        ElseIf odPValue < 0 Then
                            dPValue = 0
                        End If
                    End If
                End If
                
            Else
                xpValue = odPValue
                dPValue = xpValue
            End If
        End If
        If dPValue = 0 Then dPValue = xpValue
        For Z = 0 To 1
            If ((dPValue < 1 And dPValue <= LowestProb) Or (dPValue = 1 And xpValue < LowestProb)) And xpValue > 0 Then
                'Keep track of signal numbers
                
                If SEventNumber = 0 Then
                    If FastestFlag = 1 Then
                        If PBinFlag = -1 Then
                            If UseALFlag = 0 Then
                                NumInList = GetNumInList(Seq1, Seq2, Seq3)
                            Else
                                NumInList = CurrentTripListNum
                            End If
                            PBinFlag = 1
                            If ProgBinRead(6, Worthwhilescan(NumInList)) = 0 Then
                            
                                Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 64
                            End If
                            
                        End If
                    End If
                End If
                
                If LongWindedFlag = 1 Then
                    
                    If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                        ActiveSeq = Seq1
                        ActiveMinorP = Seq2
                        ActiveMajorP = Seq3
                       
                    ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                        ActiveSeq = Seq2
                        ActiveMinorP = Seq1
                        ActiveMajorP = Seq3
                        
                    ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                        ActiveSeq = Seq3
                        ActiveMinorP = Seq1
                        ActiveMajorP = Seq2
                       
                        
                    ElseIf StoreLPV(8, Seq1) >= StoreLPV(8, Seq2) And StoreLPV(8, Seq1) >= StoreLPV(8, Seq3) Then
                        ActiveSeq = Seq1
                        ActiveMinorP = Seq2
                        ActiveMajorP = Seq3
                    ElseIf StoreLPV(8, Seq2) >= StoreLPV(8, Seq1) And StoreLPV(8, Seq2) >= StoreLPV(8, Seq3) Then
                        ActiveSeq = Seq2
                        ActiveMinorP = Seq1
                        ActiveMajorP = Seq3
                    ElseIf StoreLPV(8, Seq3) >= StoreLPV(8, Seq1) And StoreLPV(8, Seq3) >= StoreLPV(8, Seq2) Then
                        ActiveSeq = Seq3
                        ActiveMinorP = Seq1
                        ActiveMajorP = Seq2
                    End If
                End If
                oRecombNo(100) = oRecombNo(100) + 1
                oRecombNo(8) = oRecombNo(8) + 1
                
                If APermFlag = 0 Then
                    Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 8, dPValue, SIP)
                Else
                    SIP = 1
                End If
                'Exit Sub
                NewOneFound = 1
                ActualFound = 1
                If SIP = -1 Then
                    If DoneRedo = 0 Then
                        DoneRedo = 1
                        Call AddToRedoList(8, Seq1, Seq2, Seq3)
                    End If
                Else
                    
                    XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                    XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                    XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                    XoverList(ActiveSeq, SIP).SBPFlag = 0
                    XoverList(ActiveSeq, SIP).ProgramFlag = 8
                    BWarn = 0
                    EWarn = 0
                    
                    
                  
                    
                    Call CentreBP(0, 0, Seq1, Seq2, Seq3, BE, EN, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
                    
                    
                    
                    
                    XoverList(ActiveSeq, SIP).Beginning = BE
                    XoverList(ActiveSeq, SIP).Ending = EN
                    XoverList(ActiveSeq, SIP).Probability = dPValue
                    If WF >= 0 Then
                        XoverList(ActiveSeq, SIP).PermPVal = WF
                    End If
                    XoverList(ActiveSeq, SIP).BeginP = 0
                    XoverList(ActiveSeq, SIP).EndP = 0
                    XoverList(ActiveSeq, SIP).DHolder = Seq3
                    
                    
                    
                    
                    If ShortOutFlag = 1 Then
                        ShortOutput(8) = 1
                        AbortFlag = 1
                        Exit Sub
                    End If
                    If ShortOutFlag = 50 Then ShortOutput(8) = 1
                    
                    
                   
                    XoverList(ActiveSeq, SIP).LHolder = 0
                    If LongWindedFlag = 1 And (SEventNumber > 0 Or CircularFlag = 0) Then
                        
                        If XPosDiff(EN) = LenXoverSeq Then
                            ENX = 1
                        Else
                            ENX = XPosDiff(EN) + 1
                        End If
                        If XPosDiff(BE) = 1 Or XPosDiff(BE) = 0 Then
                            BEX = LenXoverSeq
                        Else
                            BEX = XPosDiff(BE) - 1
                        End If
                        
                        'If BE = 1451 And EN = 2460 Then
                        '    X = X
                        'End If
                        If SEventNumber > 0 Then
                            If EWarn = 0 Then Call CheckEndsVB(0, 0, 10, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                            If BWarn = 0 Then Call CheckEndsVB(0, 0, 10, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BE, EN, SeqNum(), XPosDiff(), XDiffPos())
                        End If
                        
                        
                        
                        '1451,2460
                        If BWarn = 1 And EWarn = 1 Then
                            XoverList(ActiveSeq, SIP).SBPFlag = 3
                        ElseIf BWarn = 1 Then
                            XoverList(ActiveSeq, SIP).SBPFlag = 1
                        ElseIf EWarn = 1 Then
                            XoverList(ActiveSeq, SIP).SBPFlag = 2
                        End If
                        
                    End If
                    
                    If FindallFlag = 1 Then
                        Dim oSIP As Long
                        oSIP = SIP
                        If APermFlag = 0 Then
                            Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 8, dPValue, SIP)
                        Else
                            SIP = 1
                        End If
                        If SIP > -1 Then
                        
                            If UBound(XoverList, 2) > SIP Then
                                XoverList(ActiveSeq, SIP) = XoverList(ActiveSeq, oSIP)
                                XoverList(ActiveSeq, SIP).MajorP = XoverList(ActiveSeq, oSIP).MinorP
                                XoverList(ActiveSeq, SIP).MinorP = XoverList(ActiveSeq, oSIP).MajorP
                                XoverList(ActiveSeq, SIP).Beginning = XoverList(ActiveSeq, oSIP).Ending
                                XoverList(ActiveSeq, SIP).Ending = XoverList(ActiveSeq, oSIP).Beginning
                                If XoverList(ActiveSeq, SIP).SBPFlag = 1 Then
                                    XoverList(ActiveSeq, SIP).SBPFlag = 2
                                ElseIf XoverList(ActiveSeq, SIP).SBPFlag = 2 Then
                                    XoverList(ActiveSeq, SIP).SBPFlag = 1
                                End If
                            End If
                        End If
                    End If
                    
                    
                    
                    'If FindallFlag = 1 Then
                    '        If CurrentXOver(Seq1) <= CurrentXOver(Seq2) And CurrentXOver(Seq1) <= CurrentXOver(Seq3) Then
                    '            ActiveSeq = Seq1
                    '            ActiveMinorP = Seq2
                    '            ActiveMajorP = Seq3
                    '        ElseIf CurrentXOver(Seq2) <= CurrentXOver(Seq1) And CurrentXOver(Seq2) <= CurrentXOver(Seq3) Then
                    '            ActiveSeq = Seq2
                    '            ActiveMinorP = Seq1
                    '            ActiveMajorP = Seq3
                    '        Else
                    '            ActiveSeq = Seq3
                    '            ActiveMinorP = Seq1
                    '            ActiveMajorP = Seq2
                    '        End If
                    '        Call UpdateXOList3(ActiveSeq, CurrentXOver(), XOverList(), 8, dPValue, SIP)
                    '        XOverList(ActiveSeq, SIP).Daughter = ActiveSeq
                    '        XOverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                    '        XOverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                    '        XOverList(ActiveSeq, SIP).SBPFlag = 0
                    '        XOverList(ActiveSeq, SIP).ProgramFlag = 8
                    '        If EN < Len(StrainSeq(0)) Then
                    '            XOverList(ActiveSeq, SIP).Beginning = EN
                    '        Else
                    '
                    '        End If
                    '        XOverList(ActiveSeq, SIP).Ending = BE
                    '        XOverList(ActiveSeq, SIP).Probability = dPValue
                    '        XOverList(ActiveSeq, SIP).PermPVal = WF
                    '
                    '        XOverList(ActiveSeq, SIP).BeginP = 0
                    '        XOverList(ActiveSeq, SIP).EndP = 0
                     '       XOverList(ActiveSeq, SIP).DHolder = Seq3
                    '        XOverList(ActiveSeq, SIP).LHolder = 0
                    '        If BWarn = 1 And EWarn = 1 Then
                    '            XOverList(ActiveSeq, SIP).SBPFlag = 3
                    '        ElseIf BWarn = 1 Then
                    '            XOverList(ActiveSeq, SIP).SBPFlag = 1
                    '        ElseIf EWarn = 1 Then
                    '            XOverList(ActiveSeq, SIP).SBPFlag = 2
                    '        End If
                    '    End If
                    GoOn = 1
                    XB = BE
                    XE = EN
                    
                    
                    If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                        StartPlt(8) = 1
                        Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                    End If
                End If
                
           
    
            End If
            If FindallFlag = 1 Then
                Call SwapRound(WF, WF2, BE, EN, BE2, EN2, nM, NN, nK, NL, odPValue, dPValue2, MultNeg)
                If MCFlag = 0 Then
                    If odPValue < 0 Then
                        x = x
                        odPValue = 0
                    End If
                    xpValue = odPValue * MCCorrection
                    
                    If odPValue >= 1 Then
                        dPValue = 1
                    Else
                        If odPValue < 1 And odPValue > 0 Then
                            dPValue = 1 - (1 - odPValue) ^ MCCorrection
                        Else
                            If odPValue > 1 Then
                                dPValue = 10
                            ElseIf odPValue < 0 Then
                                dPValue = 0
                            End If
                        End If
                    End If
                    If dPValue = 0 Then dPValue = xpValue
                Else
                    xpValue = odPValue
                End If
            Else
                Exit For
            End If
        Next
    End If

End Sub
Public Function SubPVal(nM, NN, LenXoverSeq, SP, EP, XPosDiff() As Long, XDiffPos() As Long, XoverSeqNumTS() As Long)

Dim dPValue As Double, WF As Long, nK As Double, e As Long, b As Long, ModX As Long, EPX As Long, x As Long, MinSeen As Long, MaxSeen As Long

If XPosDiff(SP) > 0 Then
    x = XPosDiff(SP) - 1
Else
    x = LenXoverSeq
End If



MaxSeen = -1000
MinSeen = 1000
If XPosDiff(EP) + 1 > LenXoverSeq Then
    EPX = LenXoverSeq
Else
    EPX = XPosDiff(EP) + 1
End If
If x = EPX Then EPX = EPX - 1
If EPX = 0 Then EPX = LenXoverSeq

ModX = 0
Do While x <> EPX
     If x < 0 Then
        x = LenXoverSeq + x
     End If
     If x > LenXoverSeq Then
         ModX = XoverSeqNumTS(LenXoverSeq)
         x = x - LenXoverSeq - 1
        
     End If
    If x < 0 Then Exit Function
    If MaxSeen < XoverSeqNumTS(x) + ModX Then
        MaxSeen = XoverSeqNumTS(x) + ModX: b = x
    End If
    If MinSeen > XoverSeqNumTS(x) + ModX Then
        MinSeen = XoverSeqNumTS(x) + ModX: e = x
    End If
    If x = EPX Then Exit Do
    x = x + 1
Loop
nK = (MaxSeen - MinSeen)

GetTSPVal WF, nM, NN, nK, dPValue

'XX = XTable(26, 47, 36)

SubPVal = dPValue
End Function

Public Sub DeactivateScans()
ConsensusProg = 0
For x = 0 To AddNum - 1
    DoScans(0, x) = 0
Next x
End Sub
Public Sub SSXoverC(FindallFlag As Long, WinNum As Long, SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double, CorrectP As Double, oSeq As Long, PermSScores() As Long, PermPScores() As Long, SScoreHolder() As Long, PScoreHolder() As Long, TraceSub() As Long, SeqScore3() As Integer, MeanPScore() As Double, SDPScore() As Double, Seq34Conv() As Byte, VRandConv() As Byte, VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte, DG1() As Byte, DG2() As Byte, DoGroupS() As Byte, DoGroupP() As Byte)


Dim UB As Long, rLen As Long, Y As Long, x As Long, NN1 As Long, NN2 As Long, Dummy As Long, WinNumX As Long, PScores3() As Long
Dim EWarn As Long, BWarn As Long, NumInList As Long, Z As Long, GoOn As Long, PBinFlag As Long
PBinFlag = -1

WinNumX = WinNum
'61 seconds
Dim NxtX As Long
If SelGrpFlag = 1 Then
    If GrpMaskSeq(Seq1) + GrpMaskSeq(Seq2) + GrpMaskSeq(Seq3) < 2 Then
        Exit Sub
    End If
End If

Dim SIP As Long, HVX As Byte, GoOnDraw As Byte, DA As Long, Ma As Long, Mi As Long, maxz As Double, wps As Byte, LSeq As Long, RndNum As Long

Dim DistanceX(2) As Single, ValidX As Double
Dim DoneThis As Byte
Dim SHPos As Long
Dim YPos As Byte, HN1 As Byte, HN2 As Byte, HN3 As Byte, Hi As Integer, Tally() As Long
Dim HV As Integer, LV1 As Integer, LV2 As Integer, LV3 As Integer, HP As Integer, LP1 As Integer, LP2 As Integer
Dim FHPos As Long
Dim tZPScore() As Double, tZSScore() As Double, HRandTemplate2() As Long, LRegion As Long
Dim tSeq1 As Long, tSeq2 As Long, tSeq3 As Long, C As Long, WinScore As Double, WinP As Double, TotP As Double, SP As Long, EP As Long



Rnd (-BSRndNumSeed)
LSeq = Len(StrainSeq(0))


C = 0

'Set random number seed

'For Seq1 = 0 To NextNo - 2
'    For Seq2 = Seq1 + 1 To NextNo - 1
'        For Seq3 = Seq2 + 1 To NextNo
GoOnDraw = 0
'1.297


Call OrderSeqs(tSeq1, tSeq2, tSeq3, Seq1, Seq2, Seq3, TraceSub())

'1.516
'0.984



If (MaskSeq(TraceSub(Seq1)) = 0 And MaskSeq(TraceSub(Seq2)) = 0 And MaskSeq(TraceSub(Seq3)) = 0 And TraceSub(Seq3) > TraceSub(Seq2) And TraceSub(Seq2) > TraceSub(Seq1)) Or (IndividualB > -1 And Seq1 <> Seq2 And Seq2 <> Seq3 And Seq1 <> Seq3 And (Seq1 = IndividualB Or Seq1 = IndividualA) And (Seq2 = IndividualB Or Seq2 = IndividualA) And MaskSeq(TraceSub(Seq3)) <= 1) Or (IndividualA > -1 And IndividualB = -1 And Seq1 <> Seq2 And Seq3 > Seq2 And Seq3 <> Seq1 And (Seq1 = IndividualA Or Seq2 = IndividualA) And MaskSeq(TraceSub(Seq3)) <= 1 And MaskSeq(TraceSub(Seq2)) <= 1) Then
        ReDim Tally(5)
        ReDim PScores3(15)
        ReDim tZPScore(1, 15), tZSScore(1, 14)
 '1.687
 '1.484


        WinNumX = CLng(Len(StrainSeq(0)) / SSStep + 1)
        'Dim SeqMap() As Byte, ZPScoreHolder() As Double, ZSScoreHolder() As Double
        
        
        'ReDim SeqMap(Len(StrainSeq(0)))
        'ReDim ZPScoreHolder(WinNumX, 15)
        'ReDim ZSScoreHolder(WinNumX, 14)

        
        Dummy = BlankSSArrays(UBound(ZSScoreHolder, 1), UBound(ZSScoreHolder, 2), UBound(ZPScoreHolder, 1), UBound(ZPScoreHolder, 2), ZSScoreHolder(0, 0), ZPScoreHolder(0, 0))
 
                'Triplet specific stuff

                
                 
                DoneThis = 0
                FHPos = 0
                
                '2.422('8.844/2.375/9.875)?
                '2.172

                'Get Outlyer
                tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                SSOutlyerFlag = pSSOutlyerFlag
                'If X = X Then
                    'If UBound(TreeDistance, 1) <> UBound(Distance, 1) Then
                    '    X = X
                    'End If
                    
                    If DebuggingFlag < 3 Then On Error Resume Next
                    NN1 = -1
                    NN2 = -1
                    
                    NN1 = UBound(TreeDistance, 1)
                    NN2 = UBound(Distance, 1)
                    On Error GoTo 0
                    If NN1 = -1 Or NN2 = -1 Then Exit Sub
                    If Seq1 > NN1 Or Seq2 > NN1 Or Seq3 > NN1 Or oSeq > NN1 Then Exit Sub
                    If BusyWithExcludes = 0 Or x = x Then
                        Dummy = GetSSOL(Len(StrainSeq(0)), SEventNumber, NN1, NN2, PermNextno, NextNo, SSOutlyerFlag, 0, Seq1, Seq2, Seq3, oSeq, TreeDistance(0, 0), Distance(0, 0), MissingData(0, 0), TraceSub(0))
                    Else
                        Dim tTraceSub() As Long
                        ReDim tTraceSub(NextNo)
                        For A = 0 To NextNo
                            tTraceSub(A) = A
                            Dummy = GetSSOL(Len(StrainSeq(0)), SEventNumber, NN1, NN2, PermNextno, NextNo, SSOutlyerFlag, 0, Seq1, Seq2, Seq3, oSeq, TreeDistance(0, 0), Distance(0, 0), MissingData(0, 0), tTraceSub(0))
                        Next A
                    End If
'                Else
'                    Call GetSSOutlyer(oSeq, 0, TraceSub())
'                End If
                
                If oSeq = -1 Then Exit Sub
                If Seq3 > NextNo Then
                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                    SSOutlyerFlag = 0
                    oSeq = NextNo + 1
                End If
                
                If PermNextno > MemPoc And x = 1234567 Then
                    ReDim Distance(0, 0)
                End If
                
                '9.156 (12.407?)
                '6.609
                '8.657
                '2.515
  

                
                 On Error Resume Next
                
                ValidX = MakeDistX(Seq1, Seq2, Seq3, Len(StrainSeq(0)), DistanceX(0), SeqNum(0, 0))
                    
                On Error GoTo 0
                '10.781
                '4.062
      
                    
                If FindallFlag = 0 Then
                    If DistanceX(0) < DistanceX(1) And DistanceX(0) < DistanceX(2) Then
                        HV = 0: LV1 = 1: LV2 = 2: LV3 = 3
                        HP = 2: LP1 = 3: LP2 = 4
                    ElseIf DistanceX(1) < DistanceX(0) And DistanceX(1) < DistanceX(2) Then
                        HV = 1: LV1 = 0: LV2 = 2: LV3 = 3
                        HP = 3: LP1 = 2: LP2 = 4
                    Else
                        HV = 2: LV1 = 0: LV2 = 1: LV3 = 3
                        HP = 4: LP1 = 2: LP2 = 3
                    End If
                Else
                    If DistanceX(0) < DistanceX(1) And DistanceX(0) < DistanceX(2) Then
                        LV3 = 0: LV1 = 1: LV2 = 2: HV = 3
                        HP = 2: LP1 = 3: LP2 = 4
                    ElseIf DistanceX(1) < DistanceX(0) And DistanceX(1) < DistanceX(2) Then
                        LV3 = 1: LV1 = 0: LV2 = 2: HV = 3
                        HP = 3: LP1 = 2: LP2 = 4
                    Else
                        LV3 = 2: LV1 = 0: LV2 = 1: HV = 3
                        HP = 4: LP1 = 2: LP2 = 3
                    End If
                End If
                'Calculate 3 sequence scores
                ReDim PScores(Len(StrainSeq(0)))
                
                '10.663
                '4.328
                
                'This could be speeded up with better nesting
                
                Get3Score SSGapFlag, Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), SeqScore3(0)
                
                '12.047
                '5.844
                
                'Examine the windows (10/18)
                If SSFastFlag = 0 Or ShowPlotFlag = 1 Then
                    GoOn = 1
                Else
                    GoOn = 0
                End If
                '@
                For x = 1 To LSeq - SSWinLen Step SSStep
                    
                    
                    If SSFastFlag = 1 And ShowPlotFlag <> 1 Then
                        'Quick check to see if this window is worth examining
                        
                        NxtX = QuickCheckB(HP, LP1, LP2, SSStep, Len(StrainSeq(0)), x, SSWinLen, Tally(0), SeqScore3(0))
                        If NxtX > LSeq - SSWinLen Then Exit For
                        
                        x = NxtX
                        GoOn = 1
                    End If
                    
                    
                     
                     SHPos = x / SSStep
                     '141,161,181,201,261,281,301,321,341,361,381,401,421,441,461,481,501
                     If FHPos = 0 Then FHPos = SHPos
                      
                     If SSOutlyerFlag = 0 Then
                         ReDim PScores3(15)
                         
                        GetPScoresRnd x, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0), HRandTemplate(0)
                        x = x
                        
                     Else
                         '@
                         ReDim PScores3(15)
                         'If oSeq > PermNextNo Or Seq1 > PermNextNo Or Seq3 > PermNextNo Or Seq2 > PermNextNo Or UBound(SeqNum, 2) < PermNextNo Then
                         '   x = x
                         '
                         'End If
                         If UBound(SeqNum, 2) < Seq1 Or UBound(SeqNum, 2) < Seq2 Or UBound(SeqNum, 2) < Seq3 Or UBound(SeqNum, 2) < oSeq Then
                            If UBound(SeqNum, 2) < Seq1 Then
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq1)
                            End If
                            If UBound(SeqNum, 2) < Seq2 Then
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq2)
                            End If
                            If UBound(SeqNum, 2) < Seq3 Then
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq3)
                            End If
                            If UBound(SeqNum, 2) < oSeq Then
                                ReDim Preserve SeqNum(Len(StrainSeq(0)), oSeq)
                            End If
                            x = x
                         End If
                         '@
                         GetPScores2 x, SSWinLen, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
                        x = x
                        
                        
                     End If
                     
                     'Do Perms
                     
                     
                     
                     ''@'@'$
                     Dummy = DoPerms3(Len(StrainSeq(0)), SSWinLen, SSNumPerms, SSNumPerms2, PScores3(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
                     
                     'Calculate Z scores
       '
                     
                     '@
                     Dummy = MakeZValue2(SHPos, WinNumX, 15, SSNumPerms, SSNumPerms2, DG1(0), PermPScores(0, 0), ZPScoreHolder(0, 0))
                     '@'@
                     DoSums SSNumPerms, SSNumPerms2, PermSScores(0, 0), PermPScores(0, 0)
                     'Calculate Z Scores for sums
                     
                     MakeZValue2 SHPos, WinNumX, 12, SSNumPerms, SSNumPerms2, DG2(0), PermSScores(0, 0), ZSScoreHolder(0, 0)
                     
                    x = x
                Next 'X
                'Exit Sub
                'Exit Sub
                '175.953 : 160.562, 161.125, 161.016, 155.000, 102.093,68.437, 67.531,53.013, 48.738
                '144.313 - MakeZValue2(31.828), 60.641 (7.796), 49.641
                '125.125 - dosums (19.188),52.359 (8.282),41.422
                '87.953 - makexvalue1 (37.172),37.000 (15.359),37.203
                '47.672 - doperms3 (40.281),19.329 (17.671) 19.266
                '35.188 - getpscores2 (12.484),14.109 (5.22)
                '34.063- quickcheck (1.125)
                'Background (22.012):9.000
                
         
                'GoOn = 0
                If GoOn = 1 Then
                    GoOn = 0
                    
                    
                    'Find potentially recombinant regions from the S and P plots
                    
                    
                    
                    If FindallFlag = 0 Then
                        Dummy = FindMaxZ(HV, LV1, LV2, LV3, WinNumX, FHPos, SHPos, SeqMap(0), DoGroupS(0, 0), DoGroupP(0, 0), maxz, WinP, WinScore, wps, ZSScoreHolder(0, 0), ZPScoreHolder(0, 0))
                    Else
                        Dummy = FindMaxZ(HV, LV1, LV2, LV3, WinNumX, FHPos, SHPos, SeqMap(0), DoGroupS(0, 0), DoGroupP(0, 0), maxz, WinP, WinScore, wps, ZSScoreHolder(0, 0), ZPScoreHolder(0, 0))
                    End If
                    
                                    
                    'Find the regions (ie not just the interesting windows)
                    'This is done by expanding windows until P-values stop increasing.
                    For x = FHPos To SHPos
                        
                        If SeqMap(x) <> HV Then
                            If SeqMap(x) <> 3 Then
                                HVX = SeqMap(x)
                                
                                EP = 1
                                SP = x
                                Do
                                    
                                    If SeqMap(x + EP) <> SeqMap(SP) Then
                                        If FindallFlag = 0 Then
                                            Exit Do
                                        Else
                                            If SeqMap(x + EP) <> HV Then
                                                Exit Do
                                            End If
                                        End If
                                    End If
                                    EP = EP + 1
                                    If x + EP > SHPos Then
                                        If CircularFlag = 0 Then
                                            EP = SHPos - x + 1
                                            Exit Do
                                        Else
                                            If SHPos = WinNumX Then
                                                EP = 1
                                                x = FHPos
                                            Else
                                                EP = SHPos - x + 1
                                                Exit Do
                                            End If
                                        End If
                                    End If
                                Loop
                                'XX = (EP * 20)
                                EP = x + EP - 1
                                'Erase trace of region so it isn't redone
                                If EP >= SP Then
                                    For Z = SP To EP
                                        SeqMap(Z) = HV
                                    Next Z
                                Else
                                    For Z = 0 To EP
                                        SeqMap(Z) = HV
                                    Next Z
                                    For Z = EP To WinNumX
                                        SeqMap(Z) = HV
                                    Next Z
                                End If
                                
                                'Shrink region
                                
                                
                                Dim TBegin As Long, TEnd As Long
                                TBegin = 0
                                TEnd = 0
                                'HVX = SeqMap(EP)
                                'B = TBegin
                                
                                '4:39
                                '835 : 4:03 : 4:01
                                If x = x Then
'                                     If HVX = 3 Then
'                                        x = x
'                                    End If
                                    '@
                                    Dummy = ShrinkRegionC(Len(StrainSeq(0)), SSGapFlag, SSStep, SSWinLen, HVX, Seq1, Seq2, Seq3, EP, SP, TEnd, TBegin, SeqNum(0, 0))
                                x = x
                                Else
                                
                                    Call ShrinkRegion(HVX, TBegin, TEnd, SP, EP, SSStep, SSWinLen, SSGapFlag, SeqNum())
                                End If
                                If TBegin <> 0 And TEnd <> 0 And TBegin <> TEnd Then
                                    'Work out significance
                                    
                                    If TBegin < TEnd Then
                                        LRegion = TEnd - TBegin + 1
                                    Else
                                        LRegion = TEnd + (Len(StrainSeq(0)) - TBegin + 1)
                                    End If
                                    
                                    If SSOutlyerFlag = 0 Then
                                        ReDim PScores3(15), HRandTemplate2(LRegion), TakenPos(LRegion)
                                        For Z = 1 To LRegion
                                            RndNum = Int((LRegion * Rnd) + 1)
                                            If TakenPos(RndNum) = 0 Then
                                                HRandTemplate2(Z) = RndNum
                                                TakenPos(RndNum) = 1
                                            Else 'find next available position to the right
                                                Y = RndNum
                                                Do While TakenPos(Y) = 1
                                                    Y = Y + 1
                                                    If Y > LRegion Then Y = 1
                                                Loop
                                                HRandTemplate2(Z) = Y
                                                TakenPos(Y) = 1
                                            End If
                                        Next 'X
                                        
                                        GetPScoresRnd TBegin, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0), HRandTemplate2(0)
                                                    
                                    Else
                                        
                                       ReDim PScores3(15)
                                        If UBound(SeqNum, 2) < Seq1 Or UBound(SeqNum, 2) < Seq2 Or UBound(SeqNum, 2) < Seq3 Or UBound(SeqNum, 2) < oSeq Then
                                           If UBound(SeqNum, 2) < Seq1 Then
                                                ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq1)
                                            End If
                                            If UBound(SeqNum, 2) < Seq2 Then
                                                ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq2)
                                            End If
                                            If UBound(SeqNum, 2) < Seq3 Then
                                                ReDim Preserve SeqNum(Len(StrainSeq(0)), Seq3)
                                            End If
                                            If UBound(SeqNum, 2) < oSeq Then
                                                ReDim Preserve SeqNum(Len(StrainSeq(0)), oSeq)
                                            End If
                                        End If
                                        GetPScores2 TBegin, LRegion, Seq1, Seq2, Seq3, oSeq, Len(StrainSeq(0)), PScores3(0), Seq34Conv(0, 0), SeqScore3(0), SeqNum(0, 0)
                                    End If
                                                
'                                   XX = SEventNumber
                                    
                                    '@
                                    Dummy = DoPerms3P(Len(StrainSeq(0)), LRegion, SSNumPerms, SSNumPerms, PScores3(0), VRandTemplate(0, 0), VRandConv(0, 0), PermPScores(0, 0))
                                    
                                    MakeZValue2 0, 1, 15, SSNumPerms, SSNumPerms, DG1(0), PermPScores(0, 0), tZPScore(0, 0)
                                    
                                    '6:25 - 200 win 200,20 perms
                                    '11:12 - 200 win 1000,100 perms
                                    
                                    '@
                                    DoSums SSNumPerms, SSNumPerms, PermSScores(0, 0), PermPScores(0, 0)
                                        
                                    'SScoreHolder(SHPos, 1) = PermSScores(0, 1)
                                    'SScoreHolder(SHPos, 2) = PermSScores(0, 2)
                                    'SScoreHolder(SHPos, 3) = PermSScores(0, 3)
                                    'SScoreHolder(SHPos, 4) = PermSScores(0, 4)
                                    'SScoreHolder(SHPos, 5) = PermSScores(0, 5)
                                    'SScoreHolder(SHPos, 7) = PermSScores(0, 7)
                                            
                                    'Calculate Z Scores
                                    
                                    MakeZValue2 0, 1, 12, SSNumPerms, SSNumPerms, DG2(0), PermSScores(0, 0), tZSScore(0, 0)
                                                
                                    maxz = 0: WinP = 0: wps = 0
                                                
                                    For Z = 0 To 1
                                        If Abs(tZPScore(0, DoGroupP(Z, HV))) < Abs(tZPScore(0, DoGroupP(Z, LV1))) Or Abs(tZPScore(0, DoGroupP(Z, HV))) < Abs(tZPScore(0, DoGroupP(Z, LV2))) Then
                                                        
                                            For Y = 0 To 2
                                                If Y <> HV Then
                                                    If Abs(tZPScore(0, DoGroupP(Z, Y))) > maxz Then
                                                        maxz = Abs(tZPScore(0, DoGroupP(Z, Y)))
                                                        WinScore = DoGroupP(Z, Y)
                                                        wps = 1
                                                    End If
                                                End If
                                            Next Y
                                        End If
                                    Next Z
                                    
                                    For Z = 0 To 1
                                        If Abs(tZSScore(0, DoGroupS(Z, HV))) < Abs(tZSScore(0, DoGroupS(Z, LV1))) Or Abs(tZSScore(0, DoGroupS(Z, HV))) < Abs(tZSScore(0, DoGroupS(Z, LV2))) Then
                                            For Y = 0 To 2
                                                If Y <> HV Then
                                                    If Abs(tZSScore(0, DoGroupS(Z, Y))) > maxz Then
                                                        maxz = Abs(tZSScore(0, DoGroupS(Z, Y)))
                                                        WinScore = DoGroupS(Z, Y)
                                                        wps = 2
                                                    End If
                                                End If
                                            Next Y
                                        End If
                                    Next Z
                                            
                                    If maxz > CriticalZ Or (ShortOutFlag = 3 And maxz <> 0) Then
                                        
                                        If TBegin < TEnd Then
                                            rLen = TEnd - TBegin
                                        Else
                                            rLen = TEnd + (Len(StrainSeq(0)) - TBegin)
                                        End If
                                        WinP = NormalZ(maxz)
                                        WinP = WinP * (Len(StrainSeq(0)) / rLen)
                                        If MCFlag = 0 Then
                                            WinP = WinP * MCCorrection * (Len(StrainSeq(0)) / SSWinLen)
                                        End If
                                        If ShortOutFlag = 3 Then
                                            If WinP <= mtP(5) Then
                                                mtP(5) = WinP
                                            End If
                                        End If
                                        'XX = SEventNumber
                                        If WinP < LowestProb Then
                                            If SEventNumber = 0 Then
                                                If FastestFlag = 1 Then
                                                    If PBinFlag = -1 Then
                                                        If UseALFlag = 0 Then
                                                            NumInList = GetNumInList(Seq1, Seq2, Seq3)
                                                        Else
                                                            NumInList = CurrentTripListNum
                                                        End If
                                                        PBinFlag = 1
                                                        If ProgBinRead(5, Worthwhilescan(NumInList)) = 0 Then
                                                        
                                                            Worthwhilescan(NumInList) = Worthwhilescan(NumInList) + 32
                                                        End If
                                                        
                                                    End If
                                                End If
                                            End If
                                            GoOnDraw = 1
                                            'Keep track of signal numbers
                                            oRecombNo(100) = oRecombNo(100) + 1
                                            oRecombNo(5) = oRecombNo(5) + 1
                                            If ShortOutFlag = 1 Then
                                                ShortOutput(5) = 1
                                                AbortFlag = 1
                                                Exit Sub
                                            End If
                                            If ShortOutFlag = 50 Then ShortOutput(5) = 1
                                            ReDim Tally(5)
                                            If TBegin < TEnd Then
                                                QuickCheck TBegin, TEnd - TBegin, Tally(0), SeqScore3(0)
                                            Else
                                                QuickCheck 1, TEnd, Tally(0), SeqScore3(0)
                                                QuickCheck TBegin, Len(StrainSeq(0)), Tally(0), SeqScore3(0)
                                            End If
                                                        
                                            If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
                                                ActiveSeq = Seq1
                                                ActiveMinorP = Seq2
                                                ActiveMajorP = Seq3
                                               
                                            ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
                                                ActiveSeq = Seq2
                                                ActiveMinorP = Seq1
                                                ActiveMajorP = Seq3
                                                
                                            ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
                                                ActiveSeq = Seq3
                                                ActiveMinorP = Seq1
                                                ActiveMajorP = Seq2
                                               
                                                
                                            ElseIf StoreLPV(5, Seq1) >= StoreLPV(5, Seq2) And StoreLPV(5, Seq1) >= StoreLPV(5, Seq3) Then
                                                ActiveSeq = Seq1
                                                ActiveMinorP = Seq2
                                                ActiveMajorP = Seq3
                                            ElseIf StoreLPV(5, Seq2) >= StoreLPV(5, Seq1) And StoreLPV(5, Seq2) >= StoreLPV(5, Seq3) Then
                                                ActiveSeq = Seq2
                                                ActiveMinorP = Seq1
                                                ActiveMajorP = Seq3
                                            ElseIf StoreLPV(5, Seq3) >= StoreLPV(5, Seq1) And StoreLPV(5, Seq3) >= StoreLPV(5, Seq2) Then
                                                ActiveSeq = Seq3
                                                ActiveMinorP = Seq1
                                                ActiveMajorP = Seq2
                                            End If
                                            SIP = 0
                                            If APermFlag = 0 Then
                                                Call UpdateXOList3(ActiveSeq, CurrentXOver(), XoverList(), 5, WinP, SIP)
                                            Else
                                                SIP = 1
                                            End If
                                            'Call UpdateXOList(ActiveSeq, CurrentXOver(), XoverList())
                                            NewOneFound = 1
                                            ActualFound = 1
                                            If SIP > 0 Then
'                                                XX = UBound(XOverlist, 2)
                                                
                                                XoverList(ActiveSeq, SIP).LHolder = WinScore + 10 * (wps - 1)
                                                XoverList(ActiveSeq, SIP).MajorP = ActiveMajorP
                                                XoverList(ActiveSeq, SIP).MinorP = ActiveMinorP
                                                XoverList(ActiveSeq, SIP).DHolder = oSeq
                                                XoverList(ActiveSeq, SIP).Daughter = ActiveSeq
                                                If DebuggingFlag < 3 Then On Error Resume Next
                                                UB = 0
                                                UB = UBound(Scores, 1)
                                                If UB = 0 Then
                                                    ReDim Scores(Len(StrainSeq(0)), 2)
                                                End If
                                                On Error GoTo 0
                                                
                                                '@'@'@'@'@'@'@'@'@
                                                If DoScans(0, 5) = 1 Then
                                                    LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), Scores(0, 0))
                                                    
                                                    
                                                    EWarn = 0: BWarn = 0
                                                    
                                                    Call CentreBP(0, 0, Seq1, Seq2, Seq3, TBegin, TEnd, XPosDiff(), XDiffPos(), BWarn, EWarn, 10, LenXoverSeq)
                                                
                                                End If
                                                XoverList(ActiveSeq, SIP).Beginning = TBegin
                                                XoverList(ActiveSeq, SIP).Ending = TEnd
                                                
                                                Call FixEnds(BWarn, EWarn, MissingData(), XoverList(), ActiveSeq, SIP)
                                                
                                                'XOverList(ActiveSeq, SIP).Beginning = TBegin
                                                'XOverList(ActiveSeq, SIP).Ending = TEnd
                                                
                                                XoverList(ActiveSeq, SIP).Probability = WinP
                                                XoverList(ActiveSeq, SIP).ProgramFlag = 5
                                                
                                                If TBegin = 478 And TEnd = 994 Then
                                                    x = x
                                                End If
                                                If MCFlag = 2 Then
                                                    ProbabilityXOver = WinP
                                                    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
                                                        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
                                                    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
                                                        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
                                                    End If
                                                End If
                                                If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
                                                    StartPlt(5) = 1
                                                    Call UpdatePlotB(ActiveSeq, ActiveMajorP, ActiveMinorP, SIP)
                                                    
                                                End If
                                            End If
                                            
                                            
                                            
                                            'Call FindDaughter(ActiveSeq, ActiveMinorP, ActiveMajorP, 0, 0, 5, SIP)
                                                        
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Next x
                End If
                
Skip:
                C = C + 1
            End If
            
'            ET =abs(gettickcount)
'
'            If ET - LT > 500 Or AbortFlag = 1 Then
'                SSE =abs(gettickcount)
'                If C < MCCorrection + 1 Then
'                    Form1.ProgressBar1.Value = (C + 1) / (MCCorrection + 1) * 100
'                End If
'                Form1.label50(10).Caption = DoTimeII(SSE - SSS)
'                Form1.label50(12).Caption = DoTimeII(ET - ST)
'                Form1.label50(11).Caption = CStr(TotalSSRecombinants)
'                Form1.label50(13).Caption = CStr( oRecombNo(100) )
'                If oRecombNo(100) > oRec And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
'                    StartPlt(5) = 1
 '                   oRec =  oRecombNo(100)
'                    Call UpdatePlotC
'                End If
'                LT = ET
'                Form1.SSPanel13.Caption = "Approximately " & DoTime((SSE - SSS) * (100 / Form1.ProgressBar1.Value) - (SSE - SSS)) & " remaining"
'                Form1.SSPanel1.Caption = Str(C) & " of" & Str(MCCorrection) & " triplets examined"
'                DoEvents
'
'                If AbortFlag = 1 Then
'                    Form1.SSPanel1.Caption = ""
'                    Form1.ProgressBar1.Value = 0
'                    Exit Sub
'                End If
'
'            End If
'
ESub:
            
            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
'        Next 'Seq3
'    Next 'Seq2
'Next 'Seq1


End Sub
Private Function GetHTMLFromURL(sUrl As String) As String
'From Peter G. Aitken
'    Dim s As String
'    Dim hOpen As Long
'    Dim hOpenUrl As Long
'    Dim bDoLoop As Boolean
'    Dim bRet As Boolean
'    Dim sReadBuffer As String * 2048
'    Dim lNumberOfBytesRead As Long
'
'    hOpen = InternetOpen(scUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, vbNullString, vbNullString, 0)
'    hOpenUrl = InternetOpenUrl(hOpen, sUrl, vbNullString, 0, INTERNET_FLAG_RELOAD, 0)
'
'    bDoLoop = True
'    While bDoLoop
'        sReadBuffer = vbNullString
'        bRet = InternetReadFile(hOpenUrl, sReadBuffer, Len(sReadBuffer), lNumberOfBytesRead)
'        s = s & left$(sReadBuffer, lNumberOfBytesRead)
'        If Not CBool(lNumberOfBytesRead) Then bDoLoop = False
'    Wend
'
'    If hOpenUrl <> 0 Then InternetCloseHandle (hOpenUrl)'
'    If hOpen <> 0 Then InternetCloseHandle (hOpen)
'
'    GetHTMLFromURL = s

End Function


Public Sub NucleotideEg()


Dim CNum As Long, WebEnv As String, QueryKey As String, RetMax As String, lString As String, Utils As String, DB As String, Query As String, Report As String, ESearch As String, Efetch As String

Utils = "http://www.ncbi.nlm.nih.gov/entrez/eutils"
DB = "nucleotide"
Query = "begomovirus"
'docsum, brief, gb, citation, medline, asn.1, mlasn1, uilist, sgml, gen, fasta
Report = "fasta"
RetMax = "20"
ESearch = Utils + "/esearch.fcgi?&email=darrenpatrickmartin@gmail.com&tool=darrenmartinrdp&db=" + DB + "&usehistory=y&term=" + Query
lString = GetHTMLFromURL(ESearch) 'Form1.Inet1.OpenURL(ESearch)
If Len(lString) > 0 Then
    Pos = InStr(1, lString, "<Count>", vbBinaryCompare)
    Pos2 = InStr(1, lString, "</Count>", vbBinaryCompare)
    CNum = Mid$(lString, Pos + 7, (Pos2 - (Pos + 7)))
    Pos = InStr(1, lString, "<QueryKey>", vbBinaryCompare)
    Pos2 = InStr(1, lString, "</QueryKey>", vbBinaryCompare)
    QueryKey = Mid$(lString, Pos + 10, (Pos2 - (Pos + 10)))
    Pos = InStr(1, lString, "<WebEnv>", vbBinaryCompare)
    Pos2 = InStr(1, lString, "</WebEnv>", vbBinaryCompare)
    WebEnv = Mid$(lString, Pos + 8, Pos2 - (Pos + 8))
    'lString = ""
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir App.Path
    ChDrive App.Path
    
    Kill Query + ".fas"
    On Error GoTo 0
    Open Query + ".fas" For Output As #1
    
    'For X = 0 To CNum - 1
    '    Efetch = Utils + "/efetch.fcgi?&email=darren@science.uct.ac.za&tool=darrenmartinrdp&rettype=" + Report + "&retmode=text&retstart=" + Trim(Str(X)) + "&retmax=1&db=" + db + "&query_key=" + QueryKey + "&WebEnv=" + WebEnv
    '    lString = Form1.Inet1.OpenURL(Efetch)
    '
    '    Put #1, , lString
    'Next X
    'get in 1 chunk
    'For X = 0 To CNum - 1
    lString = ""
    
    Dim Bitesize() As Byte, LenToss As Long, RS As Long, Target As String, T2 As String, lString2 As String, LoadChunk As Long
    
    For x = 0 To CNum - 1 Step RetMax
        'get the sequence title
        ST = 1: EN = 2
        Efetch = Utils + "/efetch.fcgi?&email=darrenpatrickmartin@gmail.com&tool=darrenmartinrdp&retmax=" + RetMax + "&retmode=text&retstart=" + Trim(Str(x)) + "&rettype=" + Report + "&db=" + DB + "&query_key=" + QueryKey + "&WebEnv=" + WebEnv
        lString = ""
        Z = 0
        Do While lString = "" Or Left(lString, 5) = "Error"
            lString = GetHTMLFromURL(Efetch) 'Form1.Inet1.OpenURL(Efetch)
            Z = Z + 1
            If Z = 20 Then
                Exit Sub
                
            End If
        Loop
        Print #1, lString
        
        
        If x + 3 < CNum Then
            Form1.ProgressBar1.Value = (x + 3) / CNum * 100
            Form1.SSPanel1.Caption = (x + 3) & " of " & CNum & " sequences loaded"
            Call UpdateF2Prog
        Else
            Form1.ProgressBar1.Value = 100
            Form1.SSPanel1.Caption = CNum & " of " & CNum & " sequences loaded"
            Call UpdateF2Prog
        End If
    Next x
    XX = Len(lString)
     
     
    'Next X
    Close #1
End If
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
'Open "testout" For Output As #1
'Print #1, Efetch
'Print #1, lString
'Close #1
x = x
End Sub

Public Sub SaveAlign(AName As String, AddEventFlag As Byte, OriginalName() As String, SIndex As Integer)

 Dim SaveChar As Long, FF2 As Long, TempString3 As String, WritePos() As Long, TS3 As String
    'Subroutine used to save multiple sequence alignments
    'I must remember to incorporate the "save recombinant region" thing here
    TempSeqInFileFlag = 0
    Dim STraceA() As Long
    
    'sindex = 7 = save dispersed alignment with prompting user to consider only accepted events
    'sindex = 17 = save dispersed alignment without prompting user to consider only accepted events
    
    Dim OP As Long, TG As Long, TS As String, LL As Long
    Dim SeqSave() As Integer
    Dim SeqMask() As Byte, DontInclude As Byte
    Dim Addj As Integer, Addon As Integer
    Dim NumSeqs As Long, LastPos As Long, x As Long, Y As Long, Z As Long
    Dim TString As String
    Dim NameString() As String, TempSeq() As String, TempName() As String, AcceptC(2) As Byte
    'XX = UBound(TempSeq)
    ReDim TempSeq(NextNo)
    ReDim TempName(NextNo)
    If AName = "" Then
        With Form1.CommonDialog1
            .FileName = ""
            .DefaultExt = "fas"
            .Filter = "FASTA Multiple Alignment Format (*.fas)|*.fas|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
            .FilterIndex = 1
            .Action = 2 'Specify that the "open file" action is required.
            AName = .FileName  'Stores selected file name in the
            ANameII = .FileTitle
        End With
    End If
    If AName = "" Then Exit Sub
    NumSeqs = 0
    
    Call MakeAcceptC(SIndex, AcceptC())
    
    Form1.SSPanel1.Caption = "Saving alignment"
    'If SIndex <> 5 And SIndex <> 0 And SIndex <> 6 Then
    '    GoOn = 0
    '    For X = 0 To PermNextNo
    '        For Y = 1 To CurrentXOver(X)
    '            If XOverList(X, Y).Accept = 1 Then
    '                GoOn = 1
    '                Exit For
    '            End If
    '        Next Y
    '        If GoOn = 1 Then Exit For
    '     Next X
    '    If GoOn = 1 Then
    '        Response = MsgBox("Would you like to only account for those recombination signals that have been manually 'accepted' (i.e. those depicted by a coloured block with a red border in the bottom right program panel)?  If you would like to take every detected recombination signal into account (i.e. those that are either accepted or unaccepted) then press 'No'", vbYesNo)
    '    Else
    '        Response = 7
    '        '6=yes, 7=no
    '    End If
    'End If
    
    
    'If Decompress(Len(StrainSeq(0)) <> Len(StrainSeq(0))) Then 'if the sequences are compressed then need to replace strainseq with actual sequences
    '    FN = FreeFile
    '    Open BIGFilename For Binary Access Read As FN
    '    GetStringA = String$(LOF(1), " ")
    '    Get #1, 1, GetStringA
    '    Close #1
        
    'End If
    Dim GetStringA As String
    If SIndex = 0 Then
        
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            If Dir("RDP5ExcludeList" + UFTag) <> "" Then 'there is a lot of data stored on disk
                TempSeqInFileFlag = 1
                NumSeqs = NextnoBak
                
                FF2 = FreeFile
                Open "TF" + UFTag For Binary As #FF2
                TempString3 = String(Decompress(Len(StrainSeq(0))), "x")
                ReDim WritePos(NextnoBak)
                
                For x = 0 To NextnoBak
                    WritePos(x) = Seek(FF2)
                    Put #FF2, , TempString3
                    SS = GetTickCount
                    
                    If Abs(SS - LL) > 500 Then
                        LL = SS
                        Form1.SSPanel1.Caption = "Creating memory space for" + Str(x) + " of" + Str(NextnoBak) + " sequences"
                        DoEvents
                    End If
                Next x '
                
                ReDim TempName(NextnoBak)
                ReDim TempSeq(NextnoBak)
                TempSeq(0) = String(Len(StrainSeq(0)), "-")
                For x = 0 To NextNo
                    TempName(OriginalPos(x)) = OriginalName(x)
                    Put #FF2, WritePos(OriginalPos(x)), StrainSeq(x)
                Next x
                
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                
                Do While Not EOF(FF)
                    Get #FF, , LL
                    For Z = 1 To LL
                    
                        
                        Get #FF, , TG
                        Get #FF, , OP
                        Get #FF, , TG
                        Get #FF, , TG
                        TempName(OP) = String(TG, " ")
                        Get #FF, , TempName(OP)
                        Get #FF, , TG
                        TS = String(TG, " ")
                        Get #FF, , TS
                        Get #FF, , TG
                        'TempSeq(OP) = String(TG, " ")
                        'Get #FF, , TempSeq(OP)
                        TS3 = String(TG, " ")
                        Get #FF, , TS3
                        Put #FF2, WritePos(OP), TS3
                    Next Z
                Loop
                Close #FF
                
                
            Else
                NumSeqs = NextNo
                For x = 0 To NextNo
                    
                    TempName(x) = OriginalName(x)
                    TempSeq(x) = StrainSeq(x)
                   
                Next 'X
            End If
            ChDrive oDirX
            ChDir oDirX
        Else
           NumSeqs = NextNo
           If x = x Then
                If DebuggingFlag < 2 Then On Error Resume Next
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                For x = 0 To NextNo
                    TempName(x) = OriginalName(x)
                    'TempSeq(X) = String(BigFileOffsets(X, 1) - BigFileOffsets(X, 0), " ")
                    FN = FreeFile
                     
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(x) = GetStringA
                    Close #FN
                    'Exit Sub
                Next x
                If DebuggingFlag < 2 Then On Error Resume Next
                ChDir oDir
                ChDrive oDir
                On Error GoTo 0
                'Exit Sub
           Else
                If DebuggingFlag < 2 Then On Error Resume Next
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                Kill AName$
                FileCopy BIGFilename, AName$
                If DebuggingFlag < 2 Then On Error Resume Next
                ChDir oDir
                ChDrive oDir
                Exit Sub
            End If
        End If
    ElseIf SIndex = 5 Then ' save only disabled
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            If Dir("RDP5ExcludeList" + UFTag) <> "" Then 'there is a lot of data stored on disk
                TempSeqInFileFlag = 1
                NumSeqs = NextnoBak
                
                FF2 = FreeFile
                Open "TF" + UFTag For Binary As #FF2
                TempString3 = String(Decompress(Len(StrainSeq(0))), "x")
                ReDim WritePos(NextnoBak)
                
                For x = 0 To NextnoBak
                    WritePos(x) = Seek(FF2)
                    Put #FF2, , TempString3
                    SS = GetTickCount
                    
                    If Abs(SS - LL) > 500 Then
                        LL = SS
                        Form1.SSPanel1.Caption = "Creating memory space for" + Str(x) + " of" + Str(NextnoBak) + " sequences"
                        DoEvents
                    End If
                Next x '
                
                ReDim TempName(NextnoBak)
                ReDim TempSeq(NextnoBak)
                TempSeq(0) = String(Len(StrainSeq(0)), "-")
                NumSeqs = -1
                For x = 0 To NextNo
                    If MaskSeq(x) > 0 Then
                        NumSeqs = NumSeqs + 1
                    End If
                Next x
                
                If NumSeqs <> NextNo Then
                    NumSeqs = 0
                    For x = 0 To NextNo
        
                        If MaskSeq(x) > 0 Then
                            Put #FF2, WritePos(NumSeqs), StrainSeq(x)
                            TempName(NumSeqs) = OriginalName(x)
                            NumSeqs = NumSeqs + 1
                        End If
            
                    Next 'X
                    'then must add all the excludes
                    FF = FreeFile
                    Open "RDP5ExcludeList" + UFTag For Binary As #FF
                    'NumSeqs = 0
                    Do While Not EOF(FF)
                        Get #FF, , LL
                        For Z = 1 To LL
    
    
                            Get #FF, , TG
                            Get #FF, , OP
                            Get #FF, , TG
                            Get #FF, , TG
                            TempName(NumSeqs) = String(TG, " ")
                            Get #FF, , TempName(NumSeqs)
                            Get #FF, , TG
                            TS = String(TG, " ")
                            Get #FF, , TS
                            Get #FF, , TG
                            'TempSeq(OP) = String(TG, " ")
                            'Get #FF, , TempSeq(OP)
                            TS3 = String(TG, " ")
                            Get #FF, , TS3
                            Put #FF2, WritePos(NumSeqs), TS3
                            NumSeqs = NumSeqs + 1
                        Next Z
                    Loop
                    Close #FF
                    
                ElseIf NumSeqs = 0 Then
                    FF = FreeFile
                    Open "RDP5ExcludeList" + UFTag For Binary As #FF
                    NumSeqs = 0
                    Do While Not EOF(FF)
                        Get #FF, , LL
                        For Z = 1 To LL
                            Get #FF, , TG
                            Get #FF, , OP
                            Get #FF, , TG
                            Get #FF, , TG
                            TempName(NumSeqs) = String(TG, " ")
                            Get #FF, , TempName(NumSeqs)
                            Get #FF, , TG
                            TS = String(TG, " ")
                            Get #FF, , TS
                            Get #FF, , TG
                            'TempSeq(OP) = String(TG, " ")
                            'Get #FF, , TempSeq(OP)
                            TS3 = String(TG, " ")
                            Get #FF, , TS3
                            Put #FF2, WritePos(NumSeqs), TS3
                            NumSeqs = NumSeqs + 1
                        Next Z
                    Loop
                    Close #FF
                    
                 Else
                    NumSeqs = 0
                    For x = 0 To NextNo
        
                        'If MaskSeq(x) = 0 Then
                        Put #FF2, WritePos(OriginalPos(x)), StrainSeq(x)
                        TempName(OriginalPos(x)) = OriginalName(x)
                        NumSeqs = NumSeqs + 1
                        'End If
            
                    Next 'X
                    FF = FreeFile
                    Open "RDP5ExcludeList" + UFTag For Binary As #FF
    
                    Do While Not EOF(FF)
                        Get #FF, , LL
                        For Z = 1 To LL
    
    
                            Get #FF, , TG
                            Get #FF, , OP
                            Get #FF, , TG
                            Get #FF, , TG
                            TempName(OP) = String(TG, " ")
                            Get #FF, , TempName(OP)
                            Get #FF, , TG
                            TS = String(TG, " ")
                            Get #FF, , TS
                            Get #FF, , TG
                            'TempSeq(OP) = String(TG, " ")
                            'Get #FF, , TempSeq(OP)
                            TS3 = String(TG, " ")
                            Get #FF, , TS3
                            Put #FF2, WritePos(OP), TS3
                        Next Z
                    Loop
                    Close #FF
                    NumSeqs = NextnoBak
                 End If
                
                

                
                
            Else
                NumSeqs = 0
                For x = 0 To NextNo
                    If MaskSeq(x) > 0 Then
                        TempSeq(NumSeqs) = StrainSeq(x)
                        TempName(NumSeqs) = OriginalName(x)
                        NumSeqs = NumSeqs + 1
                    End If
                Next 'X
            End If
            ChDrive oDirX
            ChDir oDirX
            
            
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            On Error GoTo 0
            For x = 0 To NextNo
                If MaskSeq(x) > 0 Then
                    TempName(NumSeqs) = OriginalName(x)
                    'TempSeq(X) = String(BigFileOffsets(X, 1) - BigFileOffsets(X, 0), " ")
                    FN = FreeFile
                     
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(NumSeqs) = GetStringA
                    Close #FN
                    'Exit Sub
                    NumSeqs = NumSeqs + 1
                End If
            Next x
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
        
        End If

        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 6 Then ' save only enabled
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            If Dir("RDP5ExcludeList" + UFTag) <> "" Then 'there is a lot of data stored on disk
                TempSeqInFileFlag = 1
                NumSeqs = NextnoBak
                
                FF2 = FreeFile
                Open "TF" + UFTag For Binary As #FF2
                TempString3 = String(Decompress(Len(StrainSeq(0))), "x")
                ReDim WritePos(NextnoBak)
                
                For x = 0 To NextnoBak
                    WritePos(x) = Seek(FF2)
                    Put #FF2, , TempString3
                    SS = GetTickCount
                    
                    If Abs(SS - LL) > 500 Then
                        LL = SS
                        Form1.SSPanel1.Caption = "Creating memory space for" + Str(x) + " of" + Str(NextnoBak) + " sequences"
                        DoEvents
                    End If
                Next x '
                
                ReDim TempName(NextnoBak)
                ReDim TempSeq(NextnoBak)
                TempSeq(0) = String(Len(StrainSeq(0)), "-")
                NumSeqs = -1
                For x = 0 To NextNo
                    If MaskSeq(x) = 0 Then
                        NumSeqs = NumSeqs + 1
                    End If
                Next x
                
                If NumSeqs <> NextNo Then
                    NumSeqs = 0
                    For x = 0 To NextNo
        
                        If MaskSeq(x) = 0 Then
                            Put #FF2, WritePos(NumSeqs), StrainSeq(x)
                            TempName(NumSeqs) = OriginalName(x)
                            NumSeqs = NumSeqs + 1
                        End If
            
                    Next 'X
                 Else
                    NumSeqs = 0
                    For x = 0 To NextNo
        
                        'If MaskSeq(x) = 0 Then
                        Put #FF2, WritePos(OriginalPos(x)), StrainSeq(x)
                        TempName(OriginalPos(x)) = OriginalName(x)
                        NumSeqs = NumSeqs + 1
                        'End If
            
                    Next 'X
                    FF = FreeFile
                    Open "RDP5ExcludeList" + UFTag For Binary As #FF
    
                    Do While Not EOF(FF)
                        Get #FF, , LL
                        For Z = 1 To LL
    
    
                            Get #FF, , TG
                            Get #FF, , OP
                            Get #FF, , TG
                            Get #FF, , TG
                            TempName(OP) = String(TG, " ")
                            Get #FF, , TempName(OP)
                            Get #FF, , TG
                            TS = String(TG, " ")
                            Get #FF, , TS
                            Get #FF, , TG
                            'TempSeq(OP) = String(TG, " ")
                            'Get #FF, , TempSeq(OP)
                            TS3 = String(TG, " ")
                            Get #FF, , TS3
                            Put #FF2, WritePos(OP), TS3
                        Next Z
                    Loop
                    Close #FF
                    NumSeqs = NextnoBak
                 End If
                
                

                
                
            Else
                NumSeqs = 0
                For x = 0 To NextNo
    
                    If MaskSeq(x) = 0 Then
                        TempSeq(NumSeqs) = StrainSeq(x)
                        TempName(NumSeqs) = OriginalName(x)
                        NumSeqs = NumSeqs + 1
                    End If
        
                Next 'X
            End If
            ChDrive oDirX
            ChDir oDirX
            
            
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            On Error GoTo 0
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    TempName(NumSeqs) = OriginalName(x)
                    'TempSeq(X) = String(BigFileOffsets(X, 1) - BigFileOffsets(X, 0), " ")
                    FN = FreeFile
                     
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(NumSeqs) = GetStringA
                    Close #FN
                    'Exit Sub
                    NumSeqs = NumSeqs + 1
                End If
            Next x
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
        
        End If
        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 1 Then 'recombinant sequences removed
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" Then  'there is a lot of data stored on disk
            TempSeqInFileFlag = 1
            NumSeqs = NextnoBak
            FF2 = FreeFile
            Open "TF" + UFTag For Binary As #FF2
            TempString3 = String(Decompress(Len(StrainSeq(0))), "x")
            ReDim WritePos(NextnoBak)
            
            For x = 0 To NextnoBak
                WritePos(x) = Seek(FF2)
                Put #FF2, , TempString3
                SS = GetTickCount
                
                If Abs(SS - LL) > 500 Then
                    LL = SS
                    Form1.SSPanel1.Caption = "Creating memory space for" + Str(x) + " of" + Str(NextnoBak) + " sequences"
                    DoEvents
                End If
            Next x '
            
            ReDim TempName(NextnoBak)
            ReDim TempSeq(NextnoBak)
            TempSeq(0) = String(Len(StrainSeq(0)), "-")
            'TempSeq(0) = String(Len(StrainSeq(0)), "-")
            For x = 0 To NextNo
                TempName(OriginalPos(x)) = OriginalName(x)
                Put #FF2, WritePos(OriginalPos(x)), StrainSeq(x)
            Next x
            
            FF = FreeFile
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
           
            Do While Not EOF(FF)
                Get #FF, , LL
                For Z = 1 To LL
                
                    
                    Get #FF, , TG
                    Get #FF, , OP
                    Get #FF, , TG
                    Get #FF, , TG
                    TempName(OP) = String(TG, " ")
                    Get #FF, , TempName(OP)
                    Get #FF, , TG
                    TS = String(TG, " ")
                    Get #FF, , TS
                    Get #FF, , TG
                    'TempSeq(OP) = String(TG, " ")
                    'Get #FF, , TempSeq(OP)
                    TS3 = String(TG, " ")
                    Get #FF, , TS3
                    Put #FF2, WritePos(OP), TS3
                Next Z
            Loop
            Close #FF
            
            
            NumSeqs = NextnoBak
            Dim MFR() As Byte
            ReDim MFR(NextnoBak)
            For x = 0 To NextNo
                If CurrentXOver(x) = 0 Then
                Else
                    DontInclude = 0
    
                    For Y = 1 To CurrentXOver(x)
                        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                        If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Or x = x Then
                        
                            MFR(OriginalPos(x)) = 1
                            If ExcludedEventNum > 0 Then
                                If NumExcludedEventNum > 0 Then
                                    'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                                    NF3 = FreeFile
                                    oDirX = CurDir
                                    ChDrive App.Path
                                    ChDir App.Path
                                    Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                                    Put #NF3, 1, ExcludedEventNum
                                    Put #NF3, , EventsInExcludeds
                                    Close #NF3
                                    ReDim EventsInExcludeds(5, 1000)
                                    'ExcludedEventNum = 1
                                    ChDrive oDirX
                                    ChDir oDirX
                                End If
                                
                                For j = 0 To NumExcludedEventNum
                                    If NumExcludedEventNum > 0 Then
                                        NF3 = FreeFile
                                        oDirX = CurDir
                                        ChDrive App.Path
                                        ChDir App.Path
                                        Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                                        Get #NF3, , ExcludedEventNum
                                        ReDim EventsInExcludeds(5, ExcludedEventNum)
                                        Get #NF3, , EventsInExcludeds
                                        Close #NF3
                                        'ExcludedEventNum = 1
                                        ChDrive oDirX
                                        ChDir oDirX
                                    End If
                                    For A = 1 To ExcludedEventNum
                                        If EventsInExcludeds(3, A) = x And Daught(Abs(EventsInExcludeds(1, A)), EventsInExcludeds(3, A)) > 0 Then
                                            MFR(EventsInExcludeds(4, A)) = 1 '8,16,9,13
                                        End If
                                    Next A
                                Next j
                                Exit For
                            End If
                        End If
    
                    Next 'Y
                End If
                Form1.ProgressBar1.Value = x / NextNo * 60
                Call UpdateF2Prog
            Next 'X
            NumSeqs = 0
            TS3 = String(TG, " ")
            FF3 = FreeFile
            Open AName + "DroppedSeqs.csv" For Output As #FF3
            Print #FF3, "SequenceNumber, SequenceName"
            For x = 0 To NextnoBak
                If MFR(x) = 0 Then
                    Get #FF2, WritePos(x), TS3
                    Put #FF2, WritePos(NumSeqs), TS3
                    WritePos(NumSeqs) = WritePos(x)
                    'TempSeq(NumSeqs) = TempSeq(x)
                    TempName(NumSeqs) = TempName(x)
                    NumSeqs = NumSeqs + 1
                Else
                    Print #FF3, Str(x + 1) + "," + TempName(x)
                End If
            Next x
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            
            NumSeqs = NumSeqs - 1
            ReDim Preserve TempSeq(NumSeqs)
            ReDim Preserve TempName(NumSeqs)
            
        Else
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = 0
            For x = 0 To NextNo
    
                If CurrentXOver(x) = 0 Then
                    If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                        TempSeq(NumSeqs) = StrainSeq(x)
                    Else
                        If DebuggingFlag < 2 Then On Error Resume Next
                        oDir = CurDir
                        ChDir App.Path
                        ChDrive App.Path
                        On Error GoTo 0
                        FN = FreeFile
                        Open BIGFilename For Binary Access Read As FN
                        GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                        Get #FN, BigFileOffsets(x, 0), GetStringA
                        TempSeq(NumSeqs) = GetStringA
                        Close #FN
                        If DebuggingFlag < 2 Then On Error Resume Next
                        ChDir oDir
                        ChDrive oDir
                        On Error GoTo 0
                    End If
                    
                    TempName(NumSeqs) = OriginalName(x)
                    NumSeqs = NumSeqs + 1
                Else
                    DontInclude = 0
    
                    For Y = 1 To CurrentXOver(x)
                        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                        If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        
                            DontInclude = 1
                            Exit For
                        End If
    
                    Next 'Y
    
                    If DontInclude = 0 Then
                        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                            TempSeq(NumSeqs) = StrainSeq(x)
                        Else
                            If DebuggingFlag < 2 Then On Error Resume Next
                            oDir = CurDir
                            ChDir App.Path
                            ChDrive App.Path
                            On Error GoTo 0
                            FN = FreeFile
                            Open BIGFilename For Binary Access Read As FN
                            GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                            Get #FN, BigFileOffsets(x, 0), GetStringA
                            TempSeq(NumSeqs) = GetStringA
                            Close #FN
                            If DebuggingFlag < 2 Then On Error Resume Next
                            ChDir oDir
                            ChDrive oDir
                            On Error GoTo 0
                        End If
                        TempName(NumSeqs) = OriginalName(x)
                        NumSeqs = NumSeqs + 1
                    End If
    
                End If
                Form1.ProgressBar1.Value = x / NextNo * 60
                Call UpdateF2Prog
            Next 'X
    
            NumSeqs = NumSeqs - 1
        End If
    ElseIf SIndex = 2 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" And x = 123456 Then 'there is a lot of data stored on disk
            NumSeqs = NextnoBak
            ReDim TempName(NextnoBak)
            ReDim TempSeq(NextnoBak)
            For x = 0 To NextNo
                TempName(OriginalPos(x)) = OriginalName(x)
                TempSeq(OriginalPos(x)) = StrainSeq(x)
            Next x
            
            FF = FreeFile
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
           
            Do While Not EOF(FF)
                Get #FF, , LL
                For Z = 1 To LL
                
                    
                    Get #FF, , TG
                    Get #FF, , OP
                    Get #FF, , TG
                    Get #FF, , TG
                    TempName(OP) = String(TG, " ")
                    Get #FF, , TempName(OP)
                    Get #FF, , TG
                    TS = String(TG, " ")
                    Get #FF, , TS
                    Get #FF, , TG
                    TempSeq(OP) = String(TG, " ")
                    Get #FF, , TempSeq(OP)
                Next Z
            Loop
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            
            
            If PermSeqNumInFile = 1 Then
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                    If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        For A = 0 To NextNo
                            If BE < EN Then
                                For Z = BE To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            Else
                                For Z = BE To Len(StrainSeq(0))
                                    SeqSave(Z, A) = 46
                                Next Z
                                For Z = 1 To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            End If
                        Next A
                    End If
                Next Y
                Form1.ProgressBar1.Value = x / NextNo * 30
                Call UpdateF2Prog
            Next x
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                Mid$(TempSeq(x), Decompress(Y), Decompress(Z) - Decompress(Y)) = GetStringA
                                GoOn = 1
                                Exit For
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                Form1.ProgressBar1.Value = 30 + x / NextNo * 30
                Call UpdateF2Prog
            Next x
        Else
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = NextNo
            
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            If PermSeqNumInFile = 1 Then
                
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                    If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        For A = 0 To NextNo
                            If BE < EN Then
                                For Z = BE To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            Else
                                For Z = BE To Len(StrainSeq(0))
                                    SeqSave(Z, A) = 46
                                Next Z
                                For Z = 1 To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            End If
                        Next A
                    End If
                Next Y
                Form1.ProgressBar1.Value = x / NextNo * 30
                Call UpdateF2Prog
            Next x
            For x = 0 To NextNo
                If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                    TempSeq(x) = StrainSeq(x)
                Else
                    If DebuggingFlag < 2 Then On Error Resume Next
                    oDir = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    On Error GoTo 0
                    FN = FreeFile
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(x) = GetStringA
                    Close #FN
                    If DebuggingFlag < 2 Then On Error Resume Next
                    ChDir oDir
                    ChDrive oDir
                    On Error GoTo 0
                End If
                TempName(x) = OriginalName(x)
                
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                Mid$(TempSeq(x), Decompress(Y), Decompress(Z) - Decompress(Y)) = GetStringA
                                GoOn = 1
                                Exit For
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                Form1.ProgressBar1.Value = 30 + x / NextNo * 30
                Call UpdateF2Prog
            Next x
        End If
    ElseIf SIndex = 3 Or (SIndex = 17 And SEventNumber + PermNextno > 1000 And Decompress(Len(StrainSeq(0))) > 100000) Then 'recombinant regions removed
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        XX = StrainSeq(0)
        If Dir("RDP5ExcludeList" + UFTag) <> "" Then 'there is a lot of data stored on disk
            TempSeqInFileFlag = 1
            'Make a big empty file on disk containing all the sequence data
           
            FF2 = FreeFile
            Open "TF" + UFTag For Binary As #FF2
            TempString3 = String(Decompress(Len(StrainSeq(0))), "x")
            ReDim WritePos(NextnoBak)
            
            For x = 0 To NextnoBak
                WritePos(x) = Seek(FF2)
                Put #FF2, , TempString3
                SS = GetTickCount
                
                If Abs(SS - LL) > 500 Then
                    LL = SS
                    Form1.SSPanel1.Caption = "Creating memory space for" + Str(x) + " of" + Str(NextnoBak) + " sequences"
                    DoEvents
                End If
            Next x '
            'Close #FF2
            Form1.SSPanel1.Caption = "Editing sequences"
            
            NumSeqs = NextnoBak
            ReDim TempName(NextnoBak)
            ReDim TempSeq(NextnoBak)
            TempSeq(0) = String(Len(StrainSeq(0)), "-") 'need to fill tempseq(0) because its used as a write-length guide in writesequences and writesequence2
            For x = 0 To NextNo
                TempName(OriginalPos(x)) = OriginalName(x)
                'TempSeq(OriginalPos(x)) = StrainSeq(x)
                Put #FF2, WritePos(OriginalPos(x)), StrainSeq(x)
            Next x
            
            FF = FreeFile
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
            
            
           
            Do While Not EOF(FF)
                Get #FF, , LL
                For Z = 1 To LL
                
                    
                    Get #FF, , TG
                    Get #FF, , OP
                    Get #FF, , TG
                    Get #FF, , TG
                    TempName(OP) = String(TG, " ")
                    Get #FF, , TempName(OP)
                    Get #FF, , TG
                    TS = String(TG, " ")
                    Get #FF, , TS
                    Get #FF, , TG
                    'TempSeq(OP) = String(TG, " ")
                    TS3 = String(TG, " ")
                    Get #FF, , TS3
                    Put #FF2, WritePos(OP), TS3
                Next Z
            Loop
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            
            
            If PermSeqNumInFile = 1 Then
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For A = 1 To SEventNumber
                If A = 20 Then
                    x = x
                End If
                x = BestEvent(A, 0)
                Y = BestEvent(A, 1)
                If x > 0 Or Y > 0 Then
                    If XoverList(x, Y).BeginP >= 0 Then 'This is a pre-busywithexcludes event
                        GoOn = 0
                        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                        
                        If (AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1) Or (XoverList(x, Y).MissIdentifyFlag = 13 Or XoverList(x, Y).MissIdentifyFlag = 3) Or x = x Then
                            BE = XoverList(x, Y).Beginning
                            EN = XoverList(x, Y).Ending
                            
                            For b = 0 To NextNo
                                
                                If Daught(A, b) > 0 Then
                                    If BE < EN Then
                                        For Z = BE To EN
                                            SeqSave(Z, b) = 46
                                            'SeqSave(Z, b) = 79
                                        Next Z
                                    Else
                                        For Z = BE To Len(StrainSeq(0))
                                            SeqSave(Z, b) = 46
                                            'SeqSave(Z, b) = 79
                                        Next Z
                                        For Z = 1 To EN
                                            SeqSave(Z, b) = 46
                                            'SeqSave(Z, b) = 79
                                        Next Z
                                    End If
                                End If
                            Next b
                        End If
                    Else
                        
                    End If
                End If
                Form1.ProgressBar1.Value = 10 + A / SEventNumber * 10
                Call UpdateF2Prog
            Next A
            'Before dealing with the busywithexcludes events go through each of the include sequences and edit all of their associated excludes
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                'GetStringA = String(Decompress(Z) - Decompress(Y), "N")
                                
                                'Mid$(TempSeq(OriginalPos(x)), Decompress(Y), (Decompress(Z) - Decompress(Y))) = GetStringA
                                Put #FF2, WritePos(OriginalPos(x)) + Decompress(Y), GetStringA
                                
                                If ExcludedEventNum > 0 Then
                                    If NumExcludedEventNum > 0 Then
                                        'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                                        NF3 = FreeFile
                                        oDirX = CurDir
                                        ChDrive App.Path
                                        ChDir App.Path
                                        Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                                        Put #NF3, 1, ExcludedEventNum
                                        Put #NF3, , EventsInExcludeds
                                        Close #NF3
                                        ReDim EventsInExcludeds(5, 1000)
                                        'ExcludedEventNum = 1
                                        ChDrive oDirX
                                        ChDir oDirX
                                    End If
                                    
                                    For j = 0 To NumExcludedEventNum
                                        If NumExcludedEventNum > 0 Then
                                            NF3 = FreeFile
                                            oDirX = CurDir
                                            ChDrive App.Path
                                            ChDir App.Path
                                            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                                            Get #NF3, , ExcludedEventNum
                                            ReDim EventsInExcludeds(5, ExcludedEventNum)
                                            Get #NF3, , EventsInExcludeds
                                            Close #NF3
                                            'ExcludedEventNum = 1
                                            ChDrive oDirX
                                            ChDir oDirX
                                        End If
                                
                                        For A = 1 To ExcludedEventNum
                                            If EventsInExcludeds(3, A) = x And Daught(Abs(EventsInExcludeds(1, A)), EventsInExcludeds(3, A)) > 0 Then
                                                'Mid$(TempSeq(EventsInExcludeds(4, A)), Decompress(Y), (Decompress(Z) - Decompress(Y))) = GetStringA
                                                Put #FF2, WritePos(EventsInExcludeds(4, A)) + Decompress(Y), GetStringA
                                            End If
                                        Next A
                                    Next j
                                End If
                                GoOn = 1
                                Exit For
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                'do any extra edits that are unique to the excludes
                If ExcludedEventNum > 0 Then
                    If NumExcludedEventNum > 0 Then
                        'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                        NF3 = FreeFile
                        oDirX = CurDir
                        ChDrive App.Path
                        ChDir App.Path
                        Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                        Put #NF3, 1, ExcludedEventNum
                        Put #NF3, , EventsInExcludeds
                        Close #NF3
                        ReDim EventsInExcludeds(5, 1000)
                        'ExcludedEventNum = 1
                        ChDrive oDirX
                        ChDir oDirX
                    End If
                    
                    For j = 0 To NumExcludedEventNum
                        If NumExcludedEventNum > 0 Then
                            NF3 = FreeFile
                            oDirX = CurDir
                            ChDrive App.Path
                            ChDir App.Path
                            Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                            Get #NF3, , ExcludedEventNum
                            ReDim EventsInExcludeds(5, ExcludedEventNum)
                            Get #NF3, , EventsInExcludeds
                            Close #NF3
                            'ExcludedEventNum = 1
                            ChDrive oDirX
                            ChDir oDirX
                        End If
                        For A = 1 To ExcludedEventNum
                            If EventsInExcludeds(3, A) = x And Daught(Abs(EventsInExcludeds(1, A)), EventsInExcludeds(3, A)) > 0 Then
                                'check and see if the "include" breakpoints were wrong
                                If A <= UBound(EventsInExcludedsBP, 2) Then
                                    If EventsInExcludedsBP(0, A) <> 0 Or EventsInExcludedsBP(1, A) <> 0 Then
                                        
                                        If EventsInExcludedsBP(0, A) < EventsInExcludedsBP(1, A) Then
                                            GetStringA = String(Decompress(EventsInExcludedsBP(1, A)) - Decompress(EventsInExcludedsBP(0, A)) + 1, "-")
                                            'Mid$(TempSeq(EventsInExcludeds(4, A)), Decompress(EventsInExcludedsBP(0, A)), Len(GetStringA)) = GetStringA
                                            Put #FF2, WritePos(EventsInExcludeds(4, A)) + Decompress(EventsInExcludedsBP(0, A)), GetStringA
                                        
                                        Else
                                            GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(EventsInExcludedsBP(0, A)) + 1, "-")
                                            'Mid$(TempSeq(EventsInExcludeds(4, A)), Decompress(EventsInExcludedsBP(0, A)), Len(GetStringA)) = GetStringA
                                            Put #FF2, WritePos(EventsInExcludeds(4, A)) + Decompress(EventsInExcludedsBP(0, A)), GetStringA
                                            GetStringA = String(EventsInExcludedsBP(1, A), "-")
                                            'Mid$(TempSeq(EventsInExcludeds(4, A)), 1, Len(GetStringA)) = GetStringA
                                            Put #FF2, WritePos(EventsInExcludeds(4, A)), GetStringA
                                        End If
                                    End If
                                End If
                            End If
                        Next A
                    Next j
                End If
                Form1.ProgressBar1.Value = 20 + x / NextNo * 20
                Call UpdateF2Prog
            Next x
            
            'Now deal with the busywitexcludes events
            For A = 1 To SEventNumber
                If A = 20 Then
                    x = x
                End If
                x = BestEvent(A, 0)
                Y = BestEvent(A, 1)
'
                If x > 0 Or Y > 0 Then
                    If XoverList(x, Y).BeginP >= 0 Then 'This is a pre-busywithexcludes event
                    
                    Else
                        'the primary example of this event is in one of the excludes
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        If x = x Then 'XoverList(x, Y).EndP < 0 Then'need to do this if these events are crrently erased during the busywithexcludes screen
                            For b = 0 To NextNo
    '                            If b = 146 Then
    '                                x = x
    '                            End If
                                If Daught(A, b) > 0 Then
                                    If BE < EN Then
                                        For Z = BE To EN
                                            SeqSave(Z, b) = 46
                                        Next Z
                                        GetStringA = String(Decompress(EN) - Decompress(BE) + 1, "-")
                                        Put #FF2, WritePos(OriginalPos(b)) + Decompress(BE), GetStringA
                                    Else
                                        For Z = BE To Len(StrainSeq(0))
                                            SeqSave(Z, b) = 46
                                        Next Z
                                        For Z = 1 To EN
                                            SeqSave(Z, b) = 46
                                        Next Z
                                        GetStringA = String(Decompress(EN), "-")
                                        'Mid(TempSeq(b), 1, Len(GetStringA)) = GetStringA
                                        Put #FF2, WritePos(OriginalPos(b)), GetStringA
                                        GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(BE) + 1, "-")
                                        'Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                        Put #FF2, WritePos(OriginalPos(b)) + Decompress(BE), GetStringA
                                    End If
                                End If
                            Next b
                        
                        
                        
                        End If
                        
                        
                        
                        
                        Dim BV0 As Long, BV1 As Long, mP As Long, e As Long
                        mP = SuperEventList(XoverList(x, Y).Eventnumber) 'could just use A
    '                    If MP <> A Then
    '                        X = X
    '                    End If
                        'Call SplitP(-XoverList(x, Y).BeginP, BV0, BV1)
                        'MP = WhereIsExclude(BV0)
                        If XoverList(x, Y).Daughter <> x Then
                            
                            If ExcludedEventNum > 0 Then
                                If NumExcludedEventNum > 0 Then
                                    'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                                    NF3 = FreeFile
                                    oDirX = CurDir
                                    ChDrive App.Path
                                    ChDir App.Path
                                    Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                                    Put #NF3, 1, ExcludedEventNum
                                    Put #NF3, , EventsInExcludeds
                                    Close #NF3
                                    ReDim EventsInExcludeds(5, 1000)
                                    'ExcludedEventNum = 1
                                    ChDrive oDirX
                                    ChDir oDirX
                                End If
                                
                                For j = 0 To NumExcludedEventNum
                                    If NumExcludedEventNum > 0 Then
                                        NF3 = FreeFile
                                        oDirX = CurDir
                                        ChDrive App.Path
                                        ChDir App.Path
                                        Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                                        Get #NF3, , ExcludedEventNum
                                        ReDim EventsInExcludeds(5, ExcludedEventNum)
                                        Get #NF3, , EventsInExcludeds
                                        Close #NF3
                                        'ExcludedEventNum = 1
                                        ChDrive oDirX
                                        ChDir oDirX
                                    End If
                                    For e = 0 To UBound(EventsInExcludeds, 2)
                                        If EventsInExcludeds(1, e) = -mP And EventsInExcludeds(0, e) = 3 Then
                                            b = EventsInExcludeds(4, e)
                                            
                                            If BE < EN Then
                                                GetStringA = String(Decompress(EN) - Decompress(BE) + 1, "-")
                                                'Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                                Put #FF2, WritePos(b) + Decompress(BE), GetStringA
                                            Else
                                                GetStringA = String(Decompress(EN), "-")
                                                'Mid(TempSeq(b), 1, Len(GetStringA)) = GetStringA
                                                Put #FF2, WritePos(b), GetStringA
                                                GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(BE) + 1, "-")
                                                'Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                                Put #FF2, WritePos(b) + Decompress(BE), GetStringA
                                            End If
                                        End If
                                    Next e
                                Next j
                            End If
                        Else
                            If ExcludedEventNum > 0 Then
                                If NumExcludedEventNum > 0 Then
                                    'put the current ExcludedEventNum onto the disk and load the ExcludedEventNum0 in
                                    NF3 = FreeFile
                                    oDirX = CurDir
                                    ChDrive App.Path
                                    ChDir App.Path
                                    Open "ExcludedEventNum" + Str(NumExcludedEventNum) + UFTag For Binary As #NF3
                                    Put #NF3, 1, ExcludedEventNum
                                    Put #NF3, , EventsInExcludeds
                                    Close #NF3
                                    ReDim EventsInExcludeds(5, 1000)
                                    'ExcludedEventNum = 1
                                    ChDrive oDirX
                                    ChDir oDirX
                                End If
                                
                                For j = 0 To NumExcludedEventNum
                                    If NumExcludedEventNum > 0 Then
                                        NF3 = FreeFile
                                        oDirX = CurDir
                                        ChDrive App.Path
                                        ChDir App.Path
                                        Open "ExcludedEventNum" + Str(j) + UFTag For Binary As #NF3
                                        Get #NF3, , ExcludedEventNum
                                        ReDim EventsInExcludeds(5, ExcludedEventNum)
                                        Get #NF3, , EventsInExcludeds
                                        Close #NF3
                                        'ExcludedEventNum = 1
                                        ChDrive oDirX
                                        ChDir oDirX
                                    End If
                                    For e = 0 To UBound(EventsInExcludeds, 2)
                                        If EventsInExcludeds(1, e) = -mP Then 'And EventsInExcludeds(0, E) = 1 Then
                                            b = OriginalPos(x)
                                            
                                            If BE < EN Then
                                                GetStringA = String(Decompress(EN) - Decompress(BE) + 1, "-")
                                                'Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                                Put #FF2, WritePos(b) + Decompress(BE), GetStringA
                                            Else
                                                GetStringA = String(Decompress(EN), "-")
                                                'Mid(TempSeq(b), 1, Len(GetStringA)) = GetStringA
                                                Put #FF2, WritePos(b), GetStringA
                                                GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(BE) + 1, "-")
                                                'Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                                Put #FF2, WritePos(b) + Decompress(BE), GetStringA
                                            End If
                                        End If
                                    Next e
                                Next j
                            End If
                        End If
                        x = x
                    End If
                End If
                'Next Y
                Form1.ProgressBar1.Value = 40 + A / SEventNumber * 10
                Call UpdateF2Prog
                
            Next A
            Close #FF2
            x = x
'            x = x
'            For x = 1 To Len(TempSeq(2))
'                If Mid(TempSeq(2), x, 1) <> "-" Then
'                    x = x
'                End If
'            Next x
'            x = x
        Else
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = NextNo
            
            
            If SIndex = 17 Then
                If AddEventFlag = 2 Or AddEventFlag = 3 Then
                    ReDim btMissingData(Len(StrainSeq(0)), NextNo)
                End If
                If AddEventFlag = 2 Then
                    ReDim BigTreeTraceEvent(NextNo)
                ElseIf AddEventFlag = 3 Then
                    ReDim BigTreeTraceEventU(NextNo)
                End If
                ReDim STraceA(NextNo)
                For x = 0 To NextNo
                    STraceA(x) = x
                    
                Next x
            
            End If
            
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            
            
            If PermSeqNumInFile = 1 Then
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            SaveChar = 79
            For A = 1 To SEventNumber
                x = BestEvent(A, 0)
                Y = BestEvent(A, 1)
                'For Y = 1 To CurrentXOver(X)
                    GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                    If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        For b = 0 To NextNo
                            'XX = UBound(Daught, 2)
                            If Daught(A, b) > 0 Then
                                If BE < EN Then
                                    For Z = BE To EN
                                        SeqSave(Z, b) = SaveChar
                                    Next Z
                                Else
                                    For Z = BE To Len(StrainSeq(0))
                                        SeqSave(Z, b) = SaveChar
                                    Next Z
                                    For Z = 1 To EN
                                        SeqSave(Z, b) = SaveChar
                                    Next Z
                                End If
                            End If
                        Next b
                    End If
                'Next Y
                Form1.ProgressBar1.Value = 10 + x / NextNo * 40
                Call UpdateF2Prog
            Next A
            For x = 0 To NextNo
                TempName(x) = OriginalName(x)
                
                If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                    TempSeq(x) = StrainSeq(x)
                Else
                    If DebuggingFlag < 2 Then On Error Resume Next
                    oDir = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    On Error GoTo 0
                    FN = FreeFile
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(x) = GetStringA
                    Close #FN
                    If DebuggingFlag < 2 Then On Error Resume Next
                    ChDir oDir
                    ChDrive oDir
                    On Error GoTo 0
                End If
                
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> SaveChar) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                'GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                GetStringA = String(Decompress(Z) - Decompress(Y), Chr(SaveChar - 1))
                                'XX = Len(GetStringA)
                                Mid$(TempSeq(x), Decompress(Y), (Decompress(Z) - Decompress(Y))) = GetStringA
                                GoOn = 1
                                Exit For
                                x = x
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                Form1.ProgressBar1.Value = 50 + x / NextNo * 10
                Call UpdateF2Prog
            Next x
            'XX = TempSeq(5)
            'XX = InStr(1, TempSeq(21), "A", vbBinaryCompare)
            x = x
        
        End If
    ElseIf SIndex = 123 Then
        NumSeqs = NextNo
        
        ReDim STraceA(NextNo)
        For x = 0 To NextNo
            STraceA(x) = x
            
        Next x
        ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
        
        
        If PermSeqNumInFile = 1 Then
            ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5PSNFile" + UFTag For Binary As #FF
            Get #FF, , SeqSave
            Close #FF
            Open "RDP5PSNFile" + UFTag For Binary As #FF
            Get #FF, , PermSeqNum
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    SeqSave(Y, x) = PermSeqNum(Y, x)
                Next Y
            Next x
        End If
        x = x
        Dim P1Array() As String, P2Array() As String
        ReDim P1Array(PermNextno), P2Array(PermNextno)
        For x = 0 To PermNextno
            P1Array(x) = StrainSeq(x)
            P2Array(x) = StrainSeq(x)
        Next x
        Dim RecS, MapX, MipX, DoneX()
        ReDim DoneX(PermNextno)
        For A = 1 To SEventNumber
            x = BestEvent(A, 0)
            Y = BestEvent(A, 1)
            'For Y = 1 To CurrentXOver(X)
                If x = x Then
                    BE = XoverList(x, Y).Beginning
                    EN = XoverList(x, Y).Ending
                    RecS = XoverList(x, Y).Daughter
                    MapX = XoverList(x, Y).MajorP
                    MipX = XoverList(x, Y).MinorP
                    
                    DoneX(RecS) = 1
                    If MipX = 1 Then
                        If BE < EN Then
                            For Z = BE To EN
                                Mid$(P1Array(RecS), Z, 1) = "-"
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                Mid$(P1Array(RecS), Z, 1) = "-"
                            Next Z
                            For Z = 1 To EN
                                Mid$(P1Array(RecS), Z, 1) = "-"
                            Next Z
                        End If
                    Else
                        If BE < EN Then
                            For Z = BE To EN
                                Mid$(P2Array(RecS), Z, 1) = "-"
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                Mid$(P2Array(RecS), Z, 1) = "-"
                            Next Z
                            For Z = 1 To EN
                                Mid$(P2Array(RecS), Z, 1) = "-"
                            Next Z
                        End If
                    End If
                End If
            'Next Y
        
        Next A
        'get rid of empties
        
        Close #1
        Open AName + "-Parent1.fas" For Output As #1
        Open AName + "-Parent2.fas" For Output As #2
        
        Print #1, ">" & Trim(OriginalName(0))
        Print #1, P1Array(0)
        
        Print #2, ">" & Trim(OriginalName(1))
        Print #2, P2Array(1)
        

        For x = 2 To PermNextno
            If DoneX(x) = 0 Then
                If Distance(x, 0) > Distance(x, 1) Then
                    Print #1, ">" & Trim(OriginalName(x))
                    Print #1, P1Array(x)
                Else
                    Print #2, ">" & Trim(OriginalName(x))
                    Print #2, P2Array(x)
                End If
            Else
                Print #1, ">" & Trim(OriginalName(x))
                Print #1, P1Array(x)
                Print #2, ">" & Trim(OriginalName(x))
                Print #2, P2Array(x)
            End If
        Next x
        
        
        Close #1
        Close #2
        
        If PermNextno > MemPoc And x = 1234567 Then
            ReDim Distance(0, 0)
        End If
        Exit Sub
    ElseIf SIndex = 7 Or SIndex = 17 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" And x = 123456 Then 'there is a lot of data stored on disk
            NumSeqs = NextnoBak


        Else
            ChDrive oDirX
            ChDir oDirX
             NumSeqs = NextNo
             
             If AddEventFlag = 2 Or AddEventFlag = 3 Then
                 ReDim btMissingData(Len(StrainSeq(0)), NextNo)
             End If
             If AddEventFlag = 2 Then
                 ReDim BigTreeTraceEvent(NextNo)
             ElseIf AddEventFlag = 3 Then
                 ReDim BigTreeTraceEventU(NextNo)
             End If
             ReDim STraceA(NextNo)
             For x = 0 To NextNo
                 STraceA(x) = x
                 
             Next x
             If NextNo > PermNextno Then
                 ReDim SeqSave(Len(StrainSeq(0)) + SEventNumber * 10, NextNo)
             Else
                 ReDim SeqSave(Len(StrainSeq(0)) + SEventNumber * 10, PermNextno)
             End If
             
            
             
             
             If PermSeqNumInFile = 1 Then
                 ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                 oDirX = CurDir
                 ChDrive App.Path
                 ChDir App.Path
                 FF = FreeFile
                 
                 Open "RDP5PSNFile" + UFTag For Binary As #FF
                 Get #FF, , PermSeqNum
                 Close #FF
                 ChDrive oDirX
                 ChDir oDirX
             
             End If
             
             
             For x = 0 To PermNextno
                 For Y = 1 To Len(StrainSeq(0))
                     SeqSave(Y, x) = PermSeqNum(Y, x)
                 Next Y
                 
             Next x
             
             ReDim DoneEv(SEventNumber, NextNo), DoneAtAll(SEventNumber), AddString(NextNo)
             ReDim NameTaken(NextNo)
             'Exit Sub
             'get rid of misaligned nts and rejected events
             
             
             For A = 0 To NextNo
                 For b = 1 To CurrentXOver(A)
                     
                     If XoverList(A, b).MissIdentifyFlag = 13 Or XoverList(A, b).MissIdentifyFlag = 3 Or XoverList(A, b).Accept = 2 Then
                         BE = XoverList(A, b).Beginning
                         EN = XoverList(A, b).Ending
                         If BE < EN Then
                             For C = BE To EN
                                 SeqSave(C, A) = 46
                             Next C
                         Else
                             For C = BE To Len(StrainSeq(0))
                                 SeqSave(C, A) = 46
                             Next C
                             For C = 1 To EN
                                 SeqSave(C, A) = 46
                             Next C
                         End If
                     End If
                 Next b
             Next A
             
             For A = 1 To SEventNumber
                 If NextNo > -1 Then
                 ReDim AddedC(NextNo)
                 x = BestEvent(A, 0)
                 Y = BestEvent(A, 1)
                 'For Y = 1 To CurrentXOver(X)
                 GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                     If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                         BE = XoverList(x, Y).Beginning
                         EN = XoverList(x, Y).Ending
                         
                         SE = SuperEventList(XoverList(x, Y).Eventnumber)
                         LNextno = NextNo
                         For b = 0 To NextNo
                             
                             If Daught(A, STraceA(b)) > 0 Then
                                 
                                 'check and make sure the breakpoints are actually splitting up some sequences - if they are not then the sequence must be left as is
                                 If BE < EN Then
                                     GoOn = 0
                                     For x = 1 To BE - 1
                                         If SeqSave(x, b) > 50 Then
                                             GoOn = 1
                                             Exit For
                                         End If
                                     Next x
                                     If GoOn = 0 Then
                                         For x = EN + 1 To Len(StrainSeq(0))
                                             If SeqSave(x, b) > 50 Then
                                                 GoOn = 1
                                                 Exit For
                                             End If
                                         Next x
                                     End If
                                     If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                                         GoOn = 0
                                         For x = BE To EN
                                             If SeqSave(x, b) > 50 Then
                                                 GoOn = 1
                                                 Exit For
                                             End If
                                         Next x
                                     End If
                                     
                                 Else
                                     GoOn = 0
                                     For x = EN + 1 To BE - 1
                                         If SeqSave(x, b) > 50 Then
                                             GoOn = 1
                                             Exit For
                                         End If
                                     Next x
                                     
                                     If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                                         GoOn = 0
                                         For x = BE To Len(StrainSeq(0))
                                             If SeqSave(x, b) > 50 Then
                                                 GoOn = 1
                                                 Exit For
                                             End If
                                         Next x
                                         If GoOn = 0 Then
                                             For x = 1 To EN
                                                 If SeqSave(x, b) > 50 Then
                                                     GoOn = 1
                                                     Exit For
                                                 End If
                                             Next x
                                         End If
                                     End If
                                 End If
                                 
                                 
                                 If GoOn = 1 Then
                                 
                                     NextNo = NextNo + 1
                                     
                                     If A = 1 Or NextNo > UBound(STraceA, 1) Then
                                          TmpX = NextNo
                                          NextNo = NextNo + 40
                                          ReDim Preserve STraceA(NextNo)
                                          If AddEventFlag = 2 Then
                                             ReDim Preserve BigTreeTraceEvent(NextNo)
                                          ElseIf AddEventFlag = 3 Then
                                             ReDim Preserve BigTreeTraceEventU(NextNo)
                                          End If
                                          ReDim Preserve OriginalName(NextNo), SeqSave(Len(StrainSeq(0)) + SEventNumber * 10, NextNo)
                                          ReDim Preserve AddString(NextNo)
                                          NextNo = TmpX
                                     End If
                                     If AddEventFlag = 2 Then
                                         BigTreeTraceEvent(NextNo) = SE
                                     ElseIf AddEventFlag = 3 Then
                                         BigTreeTraceEventU(NextNo) = SE
                                     End If
                                     STraceA(NextNo) = STraceA(b)
                                     If AddEventFlag = 1 Then
                                         OriginalName(NextNo) = OriginalName(STraceA(b))
                                         If DoneEv(SE, STraceA(b)) = 0 Then
                                             
                                             If Right$(OriginalName(STraceA(b)), 1) = "_" Then
                                                  OriginalName(STraceA(b)) = OriginalName(STraceA(b)) + Trim(Str(SE)) + "_"
                                                  x = x
                                             Else
                                                  OriginalName(STraceA(b)) = OriginalName(STraceA(b)) + "_" + Trim(Str(SE)) + "_"
                                                  x = x
                                             End If
                                            
                                             DoneEv(SE, STraceA(b)) = 1
                                             AddString(NextNo) = AddString(STraceA(b)) + String(10, "A")
                                             For g = 0 To NextNo - 1
                                                 If STraceA(g) = STraceA(NextNo) Then
                                                     AddString(g) = AddString(g) + String(10, "C")
                                                 ElseIf g > PermNextno And g < LNextno Then
                                                     If AddedC(g) = 0 Then
                                                         AddString(g) = AddString(g) + String(10, "C")
                                                         AddedC(g) = 1
                                                     End If
                                                 End If
                                             Next g
                                             If Right$(OriginalName(NextNo), 1) = "_" Then
                                                 OriginalName(NextNo) = OriginalName(NextNo) + Trim(Str(SE)) + "_"
                                                 x = x
                                             Else
                                                 OriginalName(NextNo) = OriginalName(NextNo) + "_" + Trim(Str(SE)) + "_"
                                                 x = x
                                             End If
                                         Else
                                             AddString(NextNo) = Left(AddString(STraceA(b)), Len(AddString(STraceA(b))) - 10) + String(10, "A")
                                         End If
                                         x = x
                                         
                                     Else
                                          OriginalName(NextNo) = OriginalName(STraceA(b)) + "_" + Trim(Str(BE)) + "-" + Trim(Str(EN))
                                          x = x
                                          'If OriginalName(Nextno) = "B_2863-2961" Then
                                          '   X = X
                                          'End If
                                     End If
                                     If AddEventFlag <> 1 Then
                                         For nt = 0 To NextNo - 1
                                             If OriginalName(NextNo) = OriginalName(nt) Then
                                                 OriginalName(NextNo) = OriginalName(NextNo) + "(2)"
                                             End If
                                             x = x
                                         Next nt
                                     End If
                                     If BE < EN Then
                                         For Z = BE To EN
                                             SeqSave(Z, NextNo) = SeqSave(Z, b)
                                             SeqSave(Z, b) = 46
                                             
                                             
                                         Next Z
                                     Else
                                         For Z = BE To Len(StrainSeq(0))
                                             SeqSave(Z, NextNo) = SeqSave(Z, b)
                                             SeqSave(Z, b) = 46
                                         Next Z
                                         For Z = 1 To EN
                                             SeqSave(Z, NextNo) = SeqSave(Z, b)
                                             SeqSave(Z, b) = 46
                                         Next Z
                                     End If
                                     If AddEventFlag = 2 Or AddEventFlag = 3 Then
                                         If NextNo > UBound(btMissingData, 2) Then ReDim Preserve btMissingData(Len(StrainSeq(0)), NextNo)
                                         If BE < EN Then
                                             For Z = 1 To BE - 1
                                                 btMissingData(Z, NextNo) = 1
                                             Next Z
                                             For Z = BE To EN
                                                 btMissingData(Z, b) = 1
                                             Next Z
                                              For Z = EN + 1 To Len(StrainSeq(0))
                                                 btMissingData(Z, NextNo) = 1
                                             Next Z
                                         Else
                                             For Z = 1 To EN
                                                 btMissingData(Z, b) = 1
                                             Next Z
                                             For Z = EN + 1 To BE - 1
                                                 btMissingData(Z, NextNo) = 1
                                             Next Z
                                              For Z = BE To Len(StrainSeq(0))
                                                 btMissingData(Z, b) = 1
                                             Next Z
                                         End If
                                     End If
                                 End If
                             Else
                                 If AddEventFlag = 1 Then
                                     If AddedC(b) = 0 Then
                                         AddString(b) = AddString(b) + String(10, "C")
                                         AddedC(b) = 1
                                     End If
                                 End If
                             End If
                             
                         Next b
                     
                         
                     
                     End If
                 'Next Y
                 Else
                     Exit Sub
                 End If
                 If A / 20 = CLng(A / 20) Then
                     b = 0
                     'Nextno = Nextno - 40
                     Do While b <= NextNo
                         SLenX = 0
                         For Z = 1 To Len(StrainSeq(0))
                             If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                                 SLenX = SLenX + 1
                                 If SLenX > 50 Then Exit For
                                 
                                 
                             End If
                         Next Z
                         If SLenX = 0 Then
                             OriginalName(b) = OriginalName(NextNo)
                             STraceA(b) = STraceA(NextNo)
                             If AddEventFlag = 2 Then
                                 BigTreeTraceEvent(b) = BigTreeTraceEvent(NextNo)
                             ElseIf AddEventFlag = 3 Then
                                 BigTreeTraceEventU(b) = BigTreeTraceEventU(NextNo)
                             End If
                             For Z = 0 To Len(StrainSeq(0))
                                 SeqSave(Z, b) = SeqSave(Z, NextNo)
                                 SeqSave(Z, NextNo) = 46
                             Next Z
                             If AddEventFlag = 2 Or AddEventFlag = 3 Then
                                 For Z = 0 To Len(StrainSeq(0))
                                     btMissingData(Z, b) = btMissingData(Z, NextNo)
                                 Next Z
                             End If
                             
                             
                             If AddEventFlag = 1 Then
                                 AddString(b) = AddString(NextNo)
                             End If
                             NextNo = NextNo - 1
                             b = b - 1
                         End If
                         b = b + 1
                     Loop
                     Form1.ProgressBar1 = (A / SEventNumber) * 5
                     Form1.SSPanel1.Caption = Str(A) + " of " + Str(SEventNumber) + " recombination events examined"
                     Call UpdateF2Prog
                 End If
                 
             Next A
             'get rid of empties
             Form1.SSPanel1.Caption = Str(SEventNumber) + " of " + Str(SEventNumber) + " recombination events examined"
             
             'XX = OriginalName(13)
             
             b = 0
             
             Do While b <= NextNo
                 SLenX = 0
                 For Z = 1 To Len(StrainSeq(0))
                     If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                         SLenX = SLenX + 1
                         If SLenX > 50 Then Exit For
                         
                         
                     End If
                 Next Z
                 If SLenX = 0 Then '57,57,57,57,57,57,58
                     
                     OriginalName(b) = OriginalName(NextNo)
                     STraceA(b) = STraceA(NextNo)
                     If AddEventFlag = 2 Then
                         BigTreeTraceEvent(b) = BigTreeTraceEvent(NextNo)
                     ElseIf AddEventFlag = 2 Then
                         BigTreeTraceEventU(b) = BigTreeTraceEventU(NextNo)
                     End If
                     For Z = 0 To Len(StrainSeq(0))
                         SeqSave(Z, b) = SeqSave(Z, NextNo)
                         SeqSave(Z, NextNo) = 46
                     Next Z
                     If AddEventFlag = 1 Then
                         AddString(b) = AddString(NextNo)
                         
                     End If
                     NextNo = NextNo - 1
                     b = b - 1
                 End If
                 b = b + 1
             Loop
             
             ReDim TempSeq(NextNo)
             ReDim TempName(NextNo)
             LSx = Len(Trim(Str(NextNo)))
             If LSx < 2 Then LSx = 2
             
             If Len(StrainSeq(0)) <> Decompress(Len(StrainSeq(0))) And (CLine = "" Or CLine = " ") Then
                 MsgBox ("Note that because of sequence compression the alignment that is saved will only contain the subset of sites used to detect recombination")
             End If
             
             For x = 0 To NextNo
                 TempSeq(x) = String((Len(StrainSeq(0))), "-")
                 
                 If AddEventFlag = 0 Then
                     TempName(x) = OriginalName(x)
                 Else
                     TempName(x) = "S" + String(LSx - Len(Trim(Str(x))), "0") + Trim(Str(x))
                     x = x
                 End If
                 For Y = 1 To Len(StrainSeq(0))
                     If SeqSave(Y, x) = 0 Then
                         'SeqSave(Y, X) = 46
                     Else
                         Mid(TempSeq(x), Y, 1) = Chr(SeqSave(Y, x) - 1)
                     End If
                 Next Y
                 Form1.ProgressBar1 = 5 + x / NextNo * 50
                 Call UpdateF2Prog
             Next x
             
             
             ReDim SeqCoverage(NextNo)
             
             
             
             
             x = 0
             'delete empty sequences
             Do While x <= NextNo
                 If TempSeq(x) = String(Len(StrainSeq(0)), "-") Then
                     If x < NextNo Then
                         TempSeq(x) = TempSeq(NextNo)
                         If AddEventFlag = 1 Then
                             AddString(x) = AddString(NextNo)
                         End If
                         OriginalName(x) = OriginalName(NextNo)
                     End If
                     NextNo = NextNo - 1
                     x = x - 1
                 End If
                 x = x + 1
             Loop
             NumSeqs = NextNo
             Rnd (-BSRndNumSeed)
             If AddEventFlag <> 0 Then
                 
                 'Gets rid of 100% identical sequences
                 For x = 0 To NextNo
                     TempSeq(x) = TempSeq(x) + AddString(x)
                     TempSeq(x) = Left(TempSeq(x), Len(TempSeq(0)))
                 Next x
                 
                 SS = Abs(GetTickCount)
                 For x = 0 To NextNo
                     For Y = x + 1 To NextNo
                         If TempSeq(x) = TempSeq(Y) Then
                             Do
                                 Do
                                     MyValue = CLng((Len(StrainSeq(0)) * Rnd) + 1)
                                     If MyValue <= Len(StrainSeq(0)) Then Exit Do
                                 Loop
                                 If Mid$(TempSeq(x), MyValue, 1) <> "-" Then
                                     MyValue2 = CLng((4 * Rnd) + 1)
                                     If MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "A"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "G"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "C"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "T"
                                     End If
                                     MyValue2 = CLng((4 * Rnd) + 1)
                                     If MyValue2 = 1 Then
                                         'XX = Len(StrainSeq(0))
                                         Mid$(TempSeq(Y), MyValue, 1) = "A"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(Y), MyValue, 1) = "G"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(Y), MyValue, 1) = "C"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(Y), MyValue, 1) = "T"
                                     End If
                                     Exit Do
                                     x = x - 1
                                 End If
                             Loop
                         End If
                     Next Y
                 Next x
                 
                 EE = Abs(GetTickCount)
                 TT = EE - SS '5.7 for run 9
                 If AddEventFlag = 2 Then
                     ArSize = UBound(STraceA, 1)
                     ReDim BigTreeTrace(ArSize)
                     For x = 0 To ArSize
                         BigTreeTrace(x) = STraceA(x)
                     Next x
                 ElseIf AddEventFlag = 3 Then
                     ArSize = UBound(STraceA, 1)
                     ReDim BigTreeTraceU(ArSize)
                     For x = 0 To ArSize
                         BigTreeTraceU(x) = STraceA(x)
                     Next x
                 End If
                 
                 
             Else
                 If AddEventFlag = 0 Then
                     NextNo = PermNextno
                 End If
             End If
             Form1.ProgressBar1.Value = 60
             Call UpdateF2Prog
             
             SS = Abs(GetTickCount)
             
             For x = 0 To NextNo
             
                 'XX = UBound(SeqSpaces, 1)
                 Gaps = 0
                 
                 Fullbit = Len(TempSeq(0))
                 
                 For Y = 1 To Fullbit
                     If Mid(TempSeq(x), Y, 1) = "-" Then Gaps = Gaps + 1
                 Next Y
                 
                 SeqCoverage(x) = (Fullbit - Gaps) / Fullbit
                
                 
             Next x
        End If
        EE = Abs(GetTickCount)
        TT = EE - SS '3.343 for run 9
        x = x
    End If

    
    Close #1
    
    Form1.SSPanel1.Caption = "Writing alignment file"
    If TempSeqInFileFlag = 0 Then
        Call WriteSequences(NumSeqs, AName, TempName(), TempSeq(), 1)
    Else
        Call WriteSequences2(NumSeqs, AName, TempName(), TempSeq(), 1, WritePos())
    End If
    
    If SIndex = 7 Or SIndex = 17 Then Call UnModSeqNum(0)

    
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
    '    ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    
    End If
    'XX = CurDir
    
'    If Dir("TF" + UFTag) <> "" Then
'        KillFile "TF" + UFTag
'    End If
    
End Sub

Public Sub SaveAlign2(AName As String, AddEventFlag As Byte, OriginalName() As String, SIndex As Integer)
    'Subroutine used to save multiple sequence alignments
    'I must remember to incorporate the "save recombinant region" thing here
    
    Dim STraceA() As Long
    
    'sindex = 7 = save dispersed alignment with prompting user to consider only accepted events
    'sindex = 17 = save dispersed alignment without prompting user to consider only accepted events
    
    
    Dim SeqSave() As Integer
    Dim SeqMask() As Byte, DontInclude As Byte
    Dim Addj As Integer, Addon As Integer
    Dim NumSeqs As Long, LastPos As Long, x As Long, Y As Long, Z As Long
    Dim TString As String
    Dim NameString() As String, TempSeq() As String, TempName() As String, AcceptC(2) As Byte
    'XX = UBound(TempSeq)
    ReDim TempSeq(NextNo)
    ReDim TempName(NextNo)
    If AName = "" Then
        With Form1.CommonDialog1
            .FileName = ""
            .DefaultExt = "fas"
            .Filter = "FASTA Multiple Alignment Format (*.fas)|*.fas|Clustal Multiple Alignment Format (*.aln)|*.aln|DNAMan Multiple Alignment Format (*.msd)|*.msd|GCG Multiple Alignment Format (*.gcg)|*.gcg|GDE Multiple Alignment Format (*.gde)|*.gde|NEXUS Format (*.nex)|*.nex|Mega Multiple Alignment Format (*.meg)|*.meg|PHYLIP Format (*.phy)|*.phy|Sequence Files (*.seq)|*.seq"
            .FilterIndex = 1
            .Action = 2 'Specify that the "open file" action is required.
            AName = .FileName  'Stores selected file name in the
            ANameII = .FileTitle
        End With
    End If
    If AName = "" Then Exit Sub
    NumSeqs = 0
    
    Call MakeAcceptC(SIndex, AcceptC())
    
    Form1.SSPanel1.Caption = "Saving alignment"
    'If SIndex <> 5 And SIndex <> 0 And SIndex <> 6 Then
    '    GoOn = 0
    '    For X = 0 To PermNextNo
    '        For Y = 1 To CurrentXOver(X)
    '            If XOverList(X, Y).Accept = 1 Then
    '                GoOn = 1
    '                Exit For
    '            End If
    '        Next Y
    '        If GoOn = 1 Then Exit For
    '     Next X
    '    If GoOn = 1 Then
    '        Response = MsgBox("Would you like to only account for those recombination signals that have been manually 'accepted' (i.e. those depicted by a coloured block with a red border in the bottom right program panel)?  If you would like to take every detected recombination signal into account (i.e. those that are either accepted or unaccepted) then press 'No'", vbYesNo)
    '    Else
    '        Response = 7
    '        '6=yes, 7=no
    '    End If
    'End If
    
    
    'If Decompress(Len(StrainSeq(0)) <> Len(StrainSeq(0))) Then 'if the sequences are compressed then need to replace strainseq with actual sequences
    '    FN = FreeFile
    '    Open BIGFilename For Binary Access Read As FN
    '    GetStringA = String$(LOF(1), " ")
    '    Get #1, 1, GetStringA
    '    Close #1
        
    'End If
    Dim GetStringA As String
    If SIndex = 0 Then
        
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            If Dir("RDP5ExcludeList" + UFTag) <> "" Then 'there is a lot of data stored on disk
                NumSeqs = NextnoBak
                ReDim TempName(NextnoBak)
                ReDim TempSeq(NextnoBak)
                For x = 0 To NextNo
                    TempName(OriginalPos(x)) = OriginalName(x)
                    TempSeq(OriginalPos(x)) = StrainSeq(x)
                Next x
                
                FF = FreeFile
                Open "RDP5ExcludeList" + UFTag For Binary As #FF
                Dim OP As Long, TG As Long, TS As String, LL As Long
                Do While Not EOF(FF)
                    Get #FF, , LL
                    For Z = 1 To LL
                    
                        
                        Get #FF, , TG
                        Get #FF, , OP
                        Get #FF, , TG
                        Get #FF, , TG
                        TempName(OP) = String(TG, " ")
                        Get #FF, , TempName(OP)
                        Get #FF, , TG
                        TS = String(TG, " ")
                        Get #FF, , TS
                        Get #FF, , TG
                        TempSeq(OP) = String(TG, " ")
                        Get #FF, , TempSeq(OP)
                    Next Z
                Loop
                Close #FF
                
                
            Else
                NumSeqs = NextNo
                For x = 0 To NextNo
                    
                    TempName(x) = OriginalName(x)
                    TempSeq(x) = StrainSeq(x)
                   
                Next 'X
            End If
            ChDrive oDirX
            ChDir oDirX
        Else
           NumSeqs = NextNo
           If x = x Then
                If DebuggingFlag < 2 Then On Error Resume Next
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                For x = 0 To NextNo
                    TempName(x) = OriginalName(x)
                    'TempSeq(X) = String(BigFileOffsets(X, 1) - BigFileOffsets(X, 0), " ")
                    FN = FreeFile
                     
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(x) = GetStringA
                    Close #FN
                    'Exit Sub
                Next x
                If DebuggingFlag < 2 Then On Error Resume Next
                ChDir oDir
                ChDrive oDir
                On Error GoTo 0
                'Exit Sub
           Else
                If DebuggingFlag < 2 Then On Error Resume Next
                oDir = CurDir
                ChDir App.Path
                ChDrive App.Path
                On Error GoTo 0
                Kill AName$
                FileCopy BIGFilename, AName$
                If DebuggingFlag < 2 Then On Error Resume Next
                ChDir oDir
                ChDrive oDir
                Exit Sub
            End If
        End If
    ElseIf SIndex = 5 Then ' save only disabled
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            For x = 0 To NextNo
    
                If MaskSeq(x) > 0 Then
                    TempSeq(NumSeqs) = StrainSeq(x)
                    TempName(NumSeqs) = OriginalName(x)
                    NumSeqs = NumSeqs + 1
                End If
    
            Next 'X
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            On Error GoTo 0
            For x = 0 To NextNo
                If MaskSeq(x) > 0 Then
                    TempName(NumSeqs) = OriginalName(x)
                    'TempSeq(X) = String(BigFileOffsets(X, 1) - BigFileOffsets(X, 0), " ")
                    FN = FreeFile
                     
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(NumSeqs) = GetStringA
                    Close #FN
                    'Exit Sub
                    NumSeqs = NumSeqs + 1
                End If
            Next x
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
        
        End If

        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 6 Then ' save only enabled
        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
            For x = 0 To NextNo
    
                If MaskSeq(x) = 0 Then
                    TempSeq(NumSeqs) = StrainSeq(x)
                    TempName(NumSeqs) = OriginalName(x)
                    NumSeqs = NumSeqs + 1
                End If
    
            Next 'X
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            oDir = CurDir
            ChDir App.Path
            ChDrive App.Path
            On Error GoTo 0
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    TempName(NumSeqs) = OriginalName(x)
                    'TempSeq(X) = String(BigFileOffsets(X, 1) - BigFileOffsets(X, 0), " ")
                    FN = FreeFile
                     
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(NumSeqs) = GetStringA
                    Close #FN
                    'Exit Sub
                    NumSeqs = NumSeqs + 1
                End If
            Next x
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDir oDir
            ChDrive oDir
            On Error GoTo 0
        
        End If
        NumSeqs = NumSeqs - 1
    ElseIf SIndex = 1 Then 'recombinant sequences removed
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" Then  'there is a lot of data stored on disk
            NumSeqs = NextnoBak
            ReDim TempName(NextnoBak)
            ReDim TempSeq(NextnoBak)
            For x = 0 To NextNo
                TempName(OriginalPos(x)) = OriginalName(x)
                TempSeq(OriginalPos(x)) = StrainSeq(x)
            Next x
            
            FF = FreeFile
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
           
            Do While Not EOF(FF)
                Get #FF, , LL
                For Z = 1 To LL
                
                    
                    Get #FF, , TG
                    Get #FF, , OP
                    Get #FF, , TG
                    Get #FF, , TG
                    TempName(OP) = String(TG, " ")
                    
                    Get #FF, , TempName(OP)
                    Get #FF, , TG
                    TS = String(TG, " ")
                    Get #FF, , TS
                    Get #FF, , TG
                    TempSeq(OP) = String(TG, " ")
                    Get #FF, , TempSeq(OP)
                Next Z
            Loop
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = NextnoBak
            Dim MFR() As Byte
            ReDim MFR(NextnoBak)
            For x = 0 To NextNo
                If CurrentXOver(x) = 0 Then
                Else
                    DontInclude = 0
    
                    For Y = 1 To CurrentXOver(x)
                        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                        If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Or x = x Then
                        
                            MFR(OriginalPos(x)) = 1
                            
                            For A = 1 To ExcludedEventNum
                                If EventsInExcludeds(3, A) = x And Daught(Abs(EventsInExcludeds(1, A)), EventsInExcludeds(3, A)) > 0 Then
                                    MFR(EventsInExcludeds(4, A)) = 1 '8,16,9,13
                                End If
                            Next A
                            Exit For
                        End If
    
                    Next 'Y
                End If
                Form1.ProgressBar1.Value = x / NextNo * 60
                Call UpdateF2Prog
            Next 'X
            NumSeqs = 0
            For x = 0 To NextnoBak
                If MFR(x) = 0 Then
                    TempSeq(NumSeqs) = TempSeq(x)
                    TempName(NumSeqs) = TempName(x)
                    NumSeqs = NumSeqs + 1
                End If
            Next x
            
            NumSeqs = NumSeqs - 1
            ReDim Preserve TempSeq(NumSeqs)
            ReDim Preserve TempName(NumSeqs)
            
        Else
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = 0
            For x = 0 To NextNo
    
                If CurrentXOver(x) = 0 Then
                    If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                        TempSeq(NumSeqs) = StrainSeq(x)
                    Else
                        If DebuggingFlag < 2 Then On Error Resume Next
                        oDir = CurDir
                        ChDir App.Path
                        ChDrive App.Path
                        On Error GoTo 0
                        FN = FreeFile
                        Open BIGFilename For Binary Access Read As FN
                        GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                        Get #FN, BigFileOffsets(x, 0), GetStringA
                        TempSeq(NumSeqs) = GetStringA
                        Close #FN
                        If DebuggingFlag < 2 Then On Error Resume Next
                        ChDir oDir
                        ChDrive oDir
                        On Error GoTo 0
                    End If
                    
                    TempName(NumSeqs) = OriginalName(x)
                    NumSeqs = NumSeqs + 1
                Else
                    DontInclude = 0
    
                    For Y = 1 To CurrentXOver(x)
                        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                        If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        
                            DontInclude = 1
                            Exit For
                        End If
    
                    Next 'Y
    
                    If DontInclude = 0 Then
                        If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                            TempSeq(NumSeqs) = StrainSeq(x)
                        Else
                            If DebuggingFlag < 2 Then On Error Resume Next
                            oDir = CurDir
                            ChDir App.Path
                            ChDrive App.Path
                            On Error GoTo 0
                            FN = FreeFile
                            Open BIGFilename For Binary Access Read As FN
                            GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                            Get #FN, BigFileOffsets(x, 0), GetStringA
                            TempSeq(NumSeqs) = GetStringA
                            Close #FN
                            If DebuggingFlag < 2 Then On Error Resume Next
                            ChDir oDir
                            ChDrive oDir
                            On Error GoTo 0
                        End If
                        TempName(NumSeqs) = OriginalName(x)
                        NumSeqs = NumSeqs + 1
                    End If
    
                End If
                Form1.ProgressBar1.Value = x / NextNo * 60
                Call UpdateF2Prog
            Next 'X
    
            NumSeqs = NumSeqs - 1
        End If
    ElseIf SIndex = 2 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" And x = 123456 Then 'there is a lot of data stored on disk
            NumSeqs = NextnoBak
            ReDim TempName(NextnoBak)
            ReDim TempSeq(NextnoBak)
            For x = 0 To NextNo
                TempName(OriginalPos(x)) = OriginalName(x)
                TempSeq(OriginalPos(x)) = StrainSeq(x)
            Next x
            
            FF = FreeFile
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
           
            Do While Not EOF(FF)
                Get #FF, , LL
                For Z = 1 To LL
                
                    
                    Get #FF, , TG
                    Get #FF, , OP
                    Get #FF, , TG
                    Get #FF, , TG
                    TempName(OP) = String(TG, " ")
                    Get #FF, , TempName(OP)
                    Get #FF, , TG
                    TS = String(TG, " ")
                    Get #FF, , TS
                    Get #FF, , TG
                    TempSeq(OP) = String(TG, " ")
                    Get #FF, , TempSeq(OP)
                Next Z
            Loop
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            
            
            If PermSeqNumInFile = 1 Then
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                    If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        For A = 0 To NextNo
                            If BE < EN Then
                                For Z = BE To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            Else
                                For Z = BE To Len(StrainSeq(0))
                                    SeqSave(Z, A) = 46
                                Next Z
                                For Z = 1 To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            End If
                        Next A
                    End If
                Next Y
                Form1.ProgressBar1.Value = x / NextNo * 30
                Call UpdateF2Prog
            Next x
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                Mid$(TempSeq(x), Decompress(Y), Decompress(Z) - Decompress(Y)) = GetStringA
                                GoOn = 1
                                Exit For
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                Form1.ProgressBar1.Value = 30 + x / NextNo * 30
                Call UpdateF2Prog
            Next x
        Else
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = NextNo
            
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            If PermSeqNumInFile = 1 Then
                
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For x = 0 To NextNo
                For Y = 1 To CurrentXOver(x)
                    GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                    If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        For A = 0 To NextNo
                            If BE < EN Then
                                For Z = BE To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            Else
                                For Z = BE To Len(StrainSeq(0))
                                    SeqSave(Z, A) = 46
                                Next Z
                                For Z = 1 To EN
                                    SeqSave(Z, A) = 46
                                Next Z
                            End If
                        Next A
                    End If
                Next Y
                Form1.ProgressBar1.Value = x / NextNo * 30
                Call UpdateF2Prog
            Next x
            For x = 0 To NextNo
                If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                    TempSeq(x) = StrainSeq(x)
                Else
                    If DebuggingFlag < 2 Then On Error Resume Next
                    oDir = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    On Error GoTo 0
                    FN = FreeFile
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(x) = GetStringA
                    Close #FN
                    If DebuggingFlag < 2 Then On Error Resume Next
                    ChDir oDir
                    ChDrive oDir
                    On Error GoTo 0
                End If
                TempName(x) = OriginalName(x)
                
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                Mid$(TempSeq(x), Decompress(Y), Decompress(Z) - Decompress(Y)) = GetStringA
                                GoOn = 1
                                Exit For
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                Form1.ProgressBar1.Value = 30 + x / NextNo * 30
                Call UpdateF2Prog
            Next x
        End If
    ElseIf SIndex = 3 Or (SIndex = 17 And SEventNumber + PermNextno > 1000 And Decompress(Len(StrainSeq(0))) > 100000) Then 'recombinant regions removed
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" Then 'there is a lot of data stored on disk
            NumSeqs = NextnoBak
            ReDim TempName(NextnoBak)
            ReDim TempSeq(NextnoBak)
            For x = 0 To NextNo
                TempName(OriginalPos(x)) = OriginalName(x)
                TempSeq(OriginalPos(x)) = StrainSeq(x)
            Next x
            
            FF = FreeFile
            Open "RDP5ExcludeList" + UFTag For Binary As #FF
           
            Do While Not EOF(FF)
                Get #FF, , LL
                For Z = 1 To LL
                
                    
                    Get #FF, , TG
                    Get #FF, , OP
                    Get #FF, , TG
                    Get #FF, , TG
                    TempName(OP) = String(TG, " ")
                    Get #FF, , TempName(OP)
                    Get #FF, , TG
                    TS = String(TG, " ")
                    Get #FF, , TS
                    Get #FF, , TG
                    TempSeq(OP) = String(TG, " ")
                    
                    Get #FF, , TempSeq(OP)
                Next Z
            Loop
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            
            
            If PermSeqNumInFile = 1 Then
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For A = 1 To SEventNumber
                x = BestEvent(A, 0)
                Y = BestEvent(A, 1)
                If x > 0 Or Y > 0 Then
                    If XoverList(x, Y).BeginP >= 0 Then 'This is a pre-busywithexcludes event
                        GoOn = 0
                        GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                        
                        If (AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1) Or (XoverList(x, Y).MissIdentifyFlag = 13 Or XoverList(x, Y).MissIdentifyFlag = 3) Or x = x Then
                            BE = XoverList(x, Y).Beginning
                            EN = XoverList(x, Y).Ending
                            
                            For b = 0 To NextNo
                                
                                If Daught(A, b) > 0 Then
                                    If BE < EN Then
                                        For Z = BE To EN
                                            SeqSave(Z, b) = 46
                                        Next Z
                                    Else
                                        For Z = BE To Len(StrainSeq(0))
                                            SeqSave(Z, b) = 46
                                        Next Z
                                        For Z = 1 To EN
                                            SeqSave(Z, b) = 46
                                        Next Z
                                    End If
                                End If
                            Next b
                        End If
                    Else
                        
                    End If
                End If
                Form1.ProgressBar1.Value = 10 + A / SEventNumber * 10
                Call UpdateF2Prog
            Next A
            'Before dealing with the busywithexcludes events go through each of the include sequences and edit all of their associated excludes
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                
                                Mid$(TempSeq(OriginalPos(x)), Decompress(Y), (Decompress(Z) - Decompress(Y))) = GetStringA
                                
                                For A = 1 To ExcludedEventNum
                                    If EventsInExcludeds(3, A) = x And Daught(Abs(EventsInExcludeds(1, A)), EventsInExcludeds(3, A)) > 0 Then
                                        Mid$(TempSeq(EventsInExcludeds(4, A)), Decompress(Y), (Decompress(Z) - Decompress(Y))) = GetStringA
                                    End If
                                Next A
                                
                                GoOn = 1
                                Exit For
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                'do any extra edits that are unique to the excludes
                For A = 1 To ExcludedEventNum
                    If EventsInExcludeds(3, A) = x And Daught(Abs(EventsInExcludeds(1, A)), EventsInExcludeds(3, A)) > 0 Then
                        'check and see if the "include" breakpoints were wrong
                        If A <= UBound(EventsInExcludedsBP, 2) Then
                            If EventsInExcludedsBP(0, A) <> 0 Or EventsInExcludedsBP(1, A) <> 0 Then
                                If EventsInExcludeds(4, A) = 2 Then
                                    x = x
                                End If
                                If EventsInExcludedsBP(0, A) < EventsInExcludedsBP(1, A) Then
                                    GetStringA = String(Decompress(EventsInExcludedsBP(1, A)) - Decompress(EventsInExcludedsBP(0, A)) + 1, "-")
                                    Mid$(TempSeq(EventsInExcludeds(4, A)), Decompress(EventsInExcludedsBP(0, A)), Len(GetStringA)) = GetStringA
                                Else
                                    GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(EventsInExcludedsBP(0, A)) + 1, "-")
                                    Mid$(TempSeq(EventsInExcludeds(4, A)), Decompress(EventsInExcludedsBP(0, A)), Len(GetStringA)) = GetStringA
                                    GetStringA = String(EventsInExcludedsBP(1, A), "-")
                                    Mid$(TempSeq(EventsInExcludeds(4, A)), 1, Len(GetStringA)) = GetStringA
                                End If
                            End If
                        End If
                    End If
                Next A
                
                
                Form1.ProgressBar1.Value = 20 + x / NextNo * 20
                Call UpdateF2Prog
            Next x
            
            'Now deal with the busywitexcludes events
            For A = 1 To SEventNumber
                x = BestEvent(A, 0)
                Y = BestEvent(A, 1)
'
                If x > 0 Or Y > 0 Then
                    If XoverList(x, Y).BeginP >= 0 Then 'This is a pre-busywithexcludes event
                    
                    Else
                        'the primary example of this event is in one of the excludes
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        If x = x Then 'XoverList(x, Y).EndP < 0 Then'need to do this if these events are crrently erased during the busywithexcludes screen
                            For b = 0 To NextNo
    '                            If b = 146 Then
    '                                x = x
    '                            End If
                                If Daught(A, b) > 0 Then
                                    If BE < EN Then
                                        For Z = BE To EN
                                            SeqSave(Z, b) = 46
                                        Next Z
                                    Else
                                        For Z = BE To Len(StrainSeq(0))
                                            SeqSave(Z, b) = 46
                                        Next Z
                                        For Z = 1 To EN
                                            SeqSave(Z, b) = 46
                                        Next Z
                                    End If
                                End If
                            Next b
                        
                        
                        
                        End If
                        
                        
                        
                        
                        Dim BV0 As Long, BV1 As Long, mP As Long, e As Long
                        mP = SuperEventList(XoverList(x, Y).Eventnumber) 'could just use A
    '                    If MP <> A Then
    '                        X = X
    '                    End If
                        'Call SplitP(-XoverList(x, Y).BeginP, BV0, BV1)
                        'MP = WhereIsExclude(BV0)
                        If XoverList(x, Y).Daughter <> x Then
                            For e = 0 To UBound(EventsInExcludeds, 2)
                                If EventsInExcludeds(1, e) = -mP And EventsInExcludeds(0, e) = 3 Then
                                    b = EventsInExcludeds(4, e)
                                    If b = 2 Then
                                        x = x
                                    End If
                                    If BE < EN Then
                                        GetStringA = String(Decompress(EN) - Decompress(BE) + 1, "-")
                                        Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                    Else
                                        GetStringA = String(Decompress(EN), "-")
                                        Mid(TempSeq(b), 1, Len(GetStringA)) = GetStringA
                                        GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(BE) + 1, "-")
                                        Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                    End If
                                End If
                            Next e
                        Else
                            For e = 0 To UBound(EventsInExcludeds, 2)
                                If EventsInExcludeds(1, e) = -mP Then 'And EventsInExcludeds(0, E) = 1 Then
                                    b = OriginalPos(x)
                                    If b = 2 Then
                                        x = x
                                    End If
                                    If BE < EN Then
                                        GetStringA = String(Decompress(EN) - Decompress(BE) + 1, "-")
                                        Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                    Else
                                        GetStringA = String(Decompress(EN), "-")
                                        Mid(TempSeq(b), 1, Len(GetStringA)) = GetStringA
                                        GetStringA = String(Decompress(Len(StrainSeq(0))) - Decompress(BE) + 1, "-")
                                        Mid(TempSeq(b), Decompress(BE), Len(GetStringA)) = GetStringA
                                    End If
                                End If
                            Next e
                        
                        End If
                        x = x
                    End If
                End If
                'Next Y
                Form1.ProgressBar1.Value = 40 + A / SEventNumber * 10
                Call UpdateF2Prog
            Next A
'            x = x
'            For x = 1 To Len(TempSeq(2))
'                If Mid(TempSeq(2), x, 1) <> "-" Then
'                    x = x
'                End If
'            Next x
'            x = x
        Else
            ChDrive oDirX
            ChDir oDirX
            NumSeqs = NextNo
            
            
            If SIndex = 17 Then
                If AddEventFlag = 2 Or AddEventFlag = 3 Then
                    ReDim btMissingData(Len(StrainSeq(0)), NextNo)
                End If
                If AddEventFlag = 2 Then
                    ReDim BigTreeTraceEvent(NextNo)
                ElseIf AddEventFlag = 3 Then
                    ReDim BigTreeTraceEventU(NextNo)
                End If
                ReDim STraceA(NextNo)
                For x = 0 To NextNo
                    STraceA(x) = x
                    
                Next x
            
            End If
            
            ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
            
            
            If PermSeqNumInFile = 1 Then
                ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , SeqSave
                Close #FF
                Open "RDP5PSNFile" + UFTag For Binary As #FF
                Get #FF, , PermSeqNum
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                For x = 0 To NextNo
                    For Y = 1 To Len(StrainSeq(0))
                        SeqSave(Y, x) = PermSeqNum(Y, x)
                    Next Y
                Next x
            End If
            For A = 1 To SEventNumber
                x = BestEvent(A, 0)
                Y = BestEvent(A, 1)
                'For Y = 1 To CurrentXOver(X)
                    GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                    If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                        BE = XoverList(x, Y).Beginning
                        EN = XoverList(x, Y).Ending
                        
                        For b = 0 To NextNo
                            'XX = UBound(Daught, 2)
                            If Daught(A, b) > 0 Then
                                If BE < EN Then
                                    For Z = BE To EN
                                        SeqSave(Z, b) = 46
                                    Next Z
                                Else
                                    For Z = BE To Len(StrainSeq(0))
                                        SeqSave(Z, b) = 46
                                    Next Z
                                    For Z = 1 To EN
                                        SeqSave(Z, b) = 46
                                    Next Z
                                End If
                            End If
                        Next b
                    End If
                'Next Y
                Form1.ProgressBar1.Value = 10 + x / NextNo * 40
                Call UpdateF2Prog
            Next A
            For x = 0 To NextNo
                TempName(x) = OriginalName(x)
                
                If Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0)) Then
                    TempSeq(x) = StrainSeq(x)
                Else
                    If DebuggingFlag < 2 Then On Error Resume Next
                    oDir = CurDir
                    ChDir App.Path
                    ChDrive App.Path
                    On Error GoTo 0
                    FN = FreeFile
                    Open BIGFilename For Binary Access Read As FN
                    GetStringA = String(BigFileOffsets(x, 1) - BigFileOffsets(x, 0), " ")
                    Get #FN, BigFileOffsets(x, 0), GetStringA
                    TempSeq(x) = GetStringA
                    Close #FN
                    If DebuggingFlag < 2 Then On Error Resume Next
                    ChDir oDir
                    ChDrive oDir
                    On Error GoTo 0
                End If
                
                For Y = 1 To Len(StrainSeq(0))
                    GoOn = 0
                    If SeqSave(Y, x) <> PermSeqNum(Y, x) Then 'find the start of the region
                        For Z = Y + 1 To Len(StrainSeq(0))
                            If (SeqSave(Z, x) = PermSeqNum(Z, x) And PermSeqNum(Z, x) <> 46) Or Z = Len(StrainSeq(0)) Then 'find the end
                                
                                If Z <> Len(StrainSeq(0)) Then
                                    Z = Z - 1
                                End If
                                GetStringA = String(Decompress(Z) - Decompress(Y), "-")
                                'XX = Len(GetStringA)
                                Mid$(TempSeq(x), Decompress(Y), (Decompress(Z) - Decompress(Y))) = GetStringA
                                GoOn = 1
                                Exit For
                                x = x
                            End If
                                
                        Next Z
                        If GoOn = 1 Then Y = Z
                    End If
                    
                Next Y
                Form1.ProgressBar1.Value = 50 + x / NextNo * 10
                Call UpdateF2Prog
            Next x
            'XX = TempSeq(5)
            'XX = InStr(1, TempSeq(21), "A", vbBinaryCompare)
            x = x
        
        End If
    ElseIf SIndex = 123 Then
        NumSeqs = NextNo
        
        ReDim STraceA(NextNo)
        For x = 0 To NextNo
            STraceA(x) = x
            
        Next x
        ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
        
        
        If PermSeqNumInFile = 1 Then
            ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5PSNFile" + UFTag For Binary As #FF
            Get #FF, , SeqSave
            Close #FF
            Open "RDP5PSNFile" + UFTag For Binary As #FF
            Get #FF, , PermSeqNum
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            For x = 0 To NextNo
                For Y = 1 To Len(StrainSeq(0))
                    SeqSave(Y, x) = PermSeqNum(Y, x)
                Next Y
            Next x
        End If
        x = x
        Dim P1Array() As String, P2Array() As String
        ReDim P1Array(PermNextno), P2Array(PermNextno)
        For x = 0 To PermNextno
            P1Array(x) = StrainSeq(x)
            P2Array(x) = StrainSeq(x)
        Next x
        Dim RecS, MapX, MipX, DoneX()
        ReDim DoneX(PermNextno)
        For A = 1 To SEventNumber
            x = BestEvent(A, 0)
            Y = BestEvent(A, 1)
            'For Y = 1 To CurrentXOver(X)
                If x = x Then
                    BE = XoverList(x, Y).Beginning
                    EN = XoverList(x, Y).Ending
                    RecS = XoverList(x, Y).Daughter
                    MapX = XoverList(x, Y).MajorP
                    MipX = XoverList(x, Y).MinorP
                    
                    DoneX(RecS) = 1
                    If MipX = 1 Then
                        If BE < EN Then
                            For Z = BE To EN
                                Mid$(P1Array(RecS), Z, 1) = "-"
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                Mid$(P1Array(RecS), Z, 1) = "-"
                            Next Z
                            For Z = 1 To EN
                                Mid$(P1Array(RecS), Z, 1) = "-"
                            Next Z
                        End If
                    Else
                        If BE < EN Then
                            For Z = BE To EN
                                Mid$(P2Array(RecS), Z, 1) = "-"
                            Next Z
                        Else
                            For Z = BE To Len(StrainSeq(0))
                                Mid$(P2Array(RecS), Z, 1) = "-"
                            Next Z
                            For Z = 1 To EN
                                Mid$(P2Array(RecS), Z, 1) = "-"
                            Next Z
                        End If
                    End If
                End If
            'Next Y
        
        Next A
        'get rid of empties
        
        Close #1
        Open AName + "-Parent1.fas" For Output As #1
        Open AName + "-Parent2.fas" For Output As #2
        
        Print #1, ">" & Trim(OriginalName(0))
        Print #1, P1Array(0)
        
        Print #2, ">" & Trim(OriginalName(1))
        Print #2, P2Array(1)
        

        For x = 2 To PermNextno
            If DoneX(x) = 0 Then
                If Distance(x, 0) > Distance(x, 1) Then
                    Print #1, ">" & Trim(OriginalName(x))
                    Print #1, P1Array(x)
                Else
                    Print #2, ">" & Trim(OriginalName(x))
                    Print #2, P2Array(x)
                End If
            Else
                Print #1, ">" & Trim(OriginalName(x))
                Print #1, P1Array(x)
                Print #2, ">" & Trim(OriginalName(x))
                Print #2, P2Array(x)
            End If
        Next x
        
        
        Close #1
        Close #2
        
        If PermNextno > MemPoc And x = 1234567 Then
            ReDim Distance(0, 0)
        End If
        Exit Sub
    ElseIf SIndex = 7 Or SIndex = 17 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        If Dir("RDP5ExcludeList" + UFTag) <> "" And x = 123456 Then 'there is a lot of data stored on disk
            NumSeqs = NextnoBak


        Else
            ChDrive oDirX
            ChDir oDirX
             NumSeqs = NextNo
             
             If AddEventFlag = 2 Or AddEventFlag = 3 Then
                 ReDim btMissingData(Len(StrainSeq(0)), NextNo)
             End If
             If AddEventFlag = 2 Then
                 ReDim BigTreeTraceEvent(NextNo)
             ElseIf AddEventFlag = 3 Then
                 ReDim BigTreeTraceEventU(NextNo)
             End If
             ReDim STraceA(NextNo)
             For x = 0 To NextNo
                 STraceA(x) = x
                 
             Next x
             If NextNo > PermNextno Then
                 ReDim SeqSave(Len(StrainSeq(0)) + SEventNumber * 10, NextNo)
             Else
                 ReDim SeqSave(Len(StrainSeq(0)) + SEventNumber * 10, PermNextno)
             End If
             
            
             
             
             If PermSeqNumInFile = 1 Then
                 ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
                 oDirX = CurDir
                 ChDrive App.Path
                 ChDir App.Path
                 FF = FreeFile
                 
                 Open "RDP5PSNFile" + UFTag For Binary As #FF
                 Get #FF, , PermSeqNum
                 Close #FF
                 ChDrive oDirX
                 ChDir oDirX
             
             End If
             
             
             For x = 0 To PermNextno
                 For Y = 1 To Len(StrainSeq(0))
                     SeqSave(Y, x) = PermSeqNum(Y, x)
                 Next Y
                 
             Next x
             
             ReDim DoneEv(SEventNumber, NextNo), DoneAtAll(SEventNumber), AddString(NextNo)
             ReDim NameTaken(NextNo)
             'Exit Sub
             'get rid of misaligned nts and rejected events
             
             
             For A = 0 To NextNo
                 For b = 1 To CurrentXOver(A)
                     
                     If XoverList(A, b).MissIdentifyFlag = 13 Or XoverList(A, b).MissIdentifyFlag = 3 Or XoverList(A, b).Accept = 2 Then
                         BE = XoverList(A, b).Beginning
                         EN = XoverList(A, b).Ending
                         If BE < EN Then
                             For C = BE To EN
                                 SeqSave(C, A) = 46
                             Next C
                         Else
                             For C = BE To Len(StrainSeq(0))
                                 SeqSave(C, A) = 46
                             Next C
                             For C = 1 To EN
                                 SeqSave(C, A) = 46
                             Next C
                         End If
                     End If
                 Next b
             Next A
             
             For A = 1 To SEventNumber
                 If NextNo > -1 Then
                 ReDim AddedC(NextNo)
                 x = BestEvent(A, 0)
                 Y = BestEvent(A, 1)
                 'For Y = 1 To CurrentXOver(X)
                 GoOn = EnoughDetect(x, Y) 'must check whether enough methods have detected the event
                     If AcceptC(XoverList(x, Y).Accept) = 1 And GoOn = 1 Then
                         BE = XoverList(x, Y).Beginning
                         EN = XoverList(x, Y).Ending
                         
                         SE = SuperEventList(XoverList(x, Y).Eventnumber)
                         LNextno = NextNo
                         For b = 0 To NextNo
                             
                             If Daught(A, STraceA(b)) > 0 Then
                                 
                                 'check and make sure the breakpoints are actually splitting up some sequences - if they are not then the sequence must be left as is
                                 If BE < EN Then
                                     GoOn = 0
                                     For x = 1 To BE - 1
                                         If SeqSave(x, b) > 50 Then
                                             GoOn = 1
                                             Exit For
                                         End If
                                     Next x
                                     If GoOn = 0 Then
                                         For x = EN + 1 To Len(StrainSeq(0))
                                             If SeqSave(x, b) > 50 Then
                                                 GoOn = 1
                                                 Exit For
                                             End If
                                         Next x
                                     End If
                                     If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                                         GoOn = 0
                                         For x = BE To EN
                                             If SeqSave(x, b) > 50 Then
                                                 GoOn = 1
                                                 Exit For
                                             End If
                                         Next x
                                     End If
                                     
                                 Else
                                     GoOn = 0
                                     For x = EN + 1 To BE - 1
                                         If SeqSave(x, b) > 50 Then
                                             GoOn = 1
                                             Exit For
                                         End If
                                     Next x
                                     
                                     If GoOn = 1 Then 'i.e. there are some nts in the maj par region of reombinant
                                         GoOn = 0
                                         For x = BE To Len(StrainSeq(0))
                                             If SeqSave(x, b) > 50 Then
                                                 GoOn = 1
                                                 Exit For
                                             End If
                                         Next x
                                         If GoOn = 0 Then
                                             For x = 1 To EN
                                                 If SeqSave(x, b) > 50 Then
                                                     GoOn = 1
                                                     Exit For
                                                 End If
                                             Next x
                                         End If
                                     End If
                                 End If
                                 
                                 
                                 If GoOn = 1 Then
                                 
                                     NextNo = NextNo + 1
                                     
                                     If A = 1 Or NextNo > UBound(STraceA, 1) Then
                                          TmpX = NextNo
                                          NextNo = NextNo + 40
                                          ReDim Preserve STraceA(NextNo)
                                          If AddEventFlag = 2 Then
                                             ReDim Preserve BigTreeTraceEvent(NextNo)
                                          ElseIf AddEventFlag = 3 Then
                                             ReDim Preserve BigTreeTraceEventU(NextNo)
                                          End If
                                          ReDim Preserve OriginalName(NextNo), SeqSave(Len(StrainSeq(0)) + SEventNumber * 10, NextNo)
                                          ReDim Preserve AddString(NextNo)
                                          NextNo = TmpX
                                     End If
                                     If AddEventFlag = 2 Then
                                         BigTreeTraceEvent(NextNo) = SE
                                     ElseIf AddEventFlag = 3 Then
                                         BigTreeTraceEventU(NextNo) = SE
                                     End If
                                     STraceA(NextNo) = STraceA(b)
                                     If AddEventFlag = 1 Then
                                         OriginalName(NextNo) = OriginalName(STraceA(b))
                                         If DoneEv(SE, STraceA(b)) = 0 Then
                                             
                                             If Right$(OriginalName(STraceA(b)), 1) = "_" Then
                                                  OriginalName(STraceA(b)) = OriginalName(STraceA(b)) + Trim(Str(SE)) + "_"
                                                  x = x
                                             Else
                                                  OriginalName(STraceA(b)) = OriginalName(STraceA(b)) + "_" + Trim(Str(SE)) + "_"
                                                  x = x
                                             End If
                                            
                                             DoneEv(SE, STraceA(b)) = 1
                                             AddString(NextNo) = AddString(STraceA(b)) + String(10, "A")
                                             For g = 0 To NextNo - 1
                                                 If STraceA(g) = STraceA(NextNo) Then
                                                     AddString(g) = AddString(g) + String(10, "C")
                                                 ElseIf g > PermNextno And g < LNextno Then
                                                     If AddedC(g) = 0 Then
                                                         AddString(g) = AddString(g) + String(10, "C")
                                                         AddedC(g) = 1
                                                     End If
                                                 End If
                                             Next g
                                             If Right$(OriginalName(NextNo), 1) = "_" Then
                                                 OriginalName(NextNo) = OriginalName(NextNo) + Trim(Str(SE)) + "_"
                                                 x = x
                                             Else
                                                 OriginalName(NextNo) = OriginalName(NextNo) + "_" + Trim(Str(SE)) + "_"
                                                 x = x
                                             End If
                                         Else
                                             AddString(NextNo) = Left(AddString(STraceA(b)), Len(AddString(STraceA(b))) - 10) + String(10, "A")
                                         End If
                                         x = x
                                         
                                     Else
                                          OriginalName(NextNo) = OriginalName(STraceA(b)) + "_" + Trim(Str(BE)) + "-" + Trim(Str(EN))
                                          x = x
                                          'If OriginalName(Nextno) = "B_2863-2961" Then
                                          '   X = X
                                          'End If
                                     End If
                                     If AddEventFlag <> 1 Then
                                         For nt = 0 To NextNo - 1
                                             If OriginalName(NextNo) = OriginalName(nt) Then
                                                 OriginalName(NextNo) = OriginalName(NextNo) + "(2)"
                                             End If
                                             x = x
                                         Next nt
                                     End If
                                     If BE < EN Then
                                         For Z = BE To EN
                                             SeqSave(Z, NextNo) = SeqSave(Z, b)
                                             SeqSave(Z, b) = 46
                                             
                                             
                                         Next Z
                                     Else
                                         For Z = BE To Len(StrainSeq(0))
                                             SeqSave(Z, NextNo) = SeqSave(Z, b)
                                             SeqSave(Z, b) = 46
                                         Next Z
                                         For Z = 1 To EN
                                             SeqSave(Z, NextNo) = SeqSave(Z, b)
                                             SeqSave(Z, b) = 46
                                         Next Z
                                     End If
                                     If AddEventFlag = 2 Or AddEventFlag = 3 Then
                                         If NextNo > UBound(btMissingData, 2) Then ReDim Preserve btMissingData(Len(StrainSeq(0)), NextNo)
                                         If BE < EN Then
                                             For Z = 1 To BE - 1
                                                 btMissingData(Z, NextNo) = 1
                                             Next Z
                                             For Z = BE To EN
                                                 btMissingData(Z, b) = 1
                                             Next Z
                                              For Z = EN + 1 To Len(StrainSeq(0))
                                                 btMissingData(Z, NextNo) = 1
                                             Next Z
                                         Else
                                             For Z = 1 To EN
                                                 btMissingData(Z, b) = 1
                                             Next Z
                                             For Z = EN + 1 To BE - 1
                                                 btMissingData(Z, NextNo) = 1
                                             Next Z
                                              For Z = BE To Len(StrainSeq(0))
                                                 btMissingData(Z, b) = 1
                                             Next Z
                                         End If
                                     End If
                                 End If
                             Else
                                 If AddEventFlag = 1 Then
                                     If AddedC(b) = 0 Then
                                         AddString(b) = AddString(b) + String(10, "C")
                                         AddedC(b) = 1
                                     End If
                                 End If
                             End If
                             
                         Next b
                     
                         
                     
                     End If
                 'Next Y
                 Else
                     Exit Sub
                 End If
                 If A / 20 = CLng(A / 20) Then
                     b = 0
                     'Nextno = Nextno - 40
                     Do While b <= NextNo
                         SLenX = 0
                         For Z = 1 To Len(StrainSeq(0))
                             If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                                 SLenX = SLenX + 1
                                 If SLenX > 50 Then Exit For
                                 
                                 
                             End If
                         Next Z
                         If SLenX = 0 Then
                             OriginalName(b) = OriginalName(NextNo)
                             STraceA(b) = STraceA(NextNo)
                             If AddEventFlag = 2 Then
                                 BigTreeTraceEvent(b) = BigTreeTraceEvent(NextNo)
                             ElseIf AddEventFlag = 3 Then
                                 BigTreeTraceEventU(b) = BigTreeTraceEventU(NextNo)
                             End If
                             For Z = 0 To Len(StrainSeq(0))
                                 SeqSave(Z, b) = SeqSave(Z, NextNo)
                                 SeqSave(Z, NextNo) = 46
                             Next Z
                             If AddEventFlag = 2 Or AddEventFlag = 3 Then
                                 For Z = 0 To Len(StrainSeq(0))
                                     btMissingData(Z, b) = btMissingData(Z, NextNo)
                                 Next Z
                             End If
                             
                             
                             If AddEventFlag = 1 Then
                                 AddString(b) = AddString(NextNo)
                             End If
                             NextNo = NextNo - 1
                             b = b - 1
                         End If
                         b = b + 1
                     Loop
                     Form1.ProgressBar1 = (A / SEventNumber) * 5
                     Form1.SSPanel1.Caption = Str(A) + " of " + Str(SEventNumber) + " recombination events examined"
                     Call UpdateF2Prog
                 End If
                 
             Next A
             'get rid of empties
             Form1.SSPanel1.Caption = Str(SEventNumber) + " of " + Str(SEventNumber) + " recombination events examined"
             
             'XX = OriginalName(13)
             
             b = 0
             
             Do While b <= NextNo
                 SLenX = 0
                 For Z = 1 To Len(StrainSeq(0))
                     If SeqSave(Z, b) <> 46 And SeqSave(Z, b) <> 0 Then
                         SLenX = SLenX + 1
                         If SLenX > 50 Then Exit For
                         
                         
                     End If
                 Next Z
                 If SLenX = 0 Then '57,57,57,57,57,57,58
                     
                     OriginalName(b) = OriginalName(NextNo)
                     STraceA(b) = STraceA(NextNo)
                     If AddEventFlag = 2 Then
                         BigTreeTraceEvent(b) = BigTreeTraceEvent(NextNo)
                     ElseIf AddEventFlag = 2 Then
                         BigTreeTraceEventU(b) = BigTreeTraceEventU(NextNo)
                     End If
                     For Z = 0 To Len(StrainSeq(0))
                         SeqSave(Z, b) = SeqSave(Z, NextNo)
                         SeqSave(Z, NextNo) = 46
                     Next Z
                     If AddEventFlag = 1 Then
                         AddString(b) = AddString(NextNo)
                         
                     End If
                     NextNo = NextNo - 1
                     b = b - 1
                 End If
                 b = b + 1
             Loop
             
             ReDim TempSeq(NextNo)
             ReDim TempName(NextNo)
             LSx = Len(Trim(Str(NextNo)))
             If LSx < 2 Then LSx = 2
             
             If Len(StrainSeq(0)) <> Decompress(Len(StrainSeq(0))) And (CLine = "" Or CLine = " ") Then
                 MsgBox ("Note that because of sequence compression the alignment that is saved will only contain the subset of sites used to detect recombination")
             End If
             
             For x = 0 To NextNo
                 TempSeq(x) = String((Len(StrainSeq(0))), "-")
                 
                 If AddEventFlag = 0 Then
                     TempName(x) = OriginalName(x)
                 Else
                     TempName(x) = "S" + String(LSx - Len(Trim(Str(x))), "0") + Trim(Str(x))
                     x = x
                 End If
                 For Y = 1 To Len(StrainSeq(0))
                     If SeqSave(Y, x) = 0 Then
                         'SeqSave(Y, X) = 46
                     Else
                         Mid(TempSeq(x), Y, 1) = Chr(SeqSave(Y, x) - 1)
                     End If
                 Next Y
                 Form1.ProgressBar1 = 5 + x / NextNo * 50
                 Call UpdateF2Prog
             Next x
             
             
             ReDim SeqCoverage(NextNo)
             
             
             
             
             x = 0
             'delete empty sequences
             Do While x <= NextNo
                 If TempSeq(x) = String(Len(StrainSeq(0)), "-") Then
                     If x < NextNo Then
                         TempSeq(x) = TempSeq(NextNo)
                         If AddEventFlag = 1 Then
                             AddString(x) = AddString(NextNo)
                         End If
                         OriginalName(x) = OriginalName(NextNo)
                     End If
                     NextNo = NextNo - 1
                     x = x - 1
                 End If
                 x = x + 1
             Loop
             NumSeqs = NextNo
             Rnd (-BSRndNumSeed)
             If AddEventFlag <> 0 Then
                 
                 'Gets rid of 100% identical sequences
                 For x = 0 To NextNo
                     TempSeq(x) = TempSeq(x) + AddString(x)
                     TempSeq(x) = Left(TempSeq(x), Len(TempSeq(0)))
                 Next x
                 
                 SS = Abs(GetTickCount)
                 For x = 0 To NextNo
                     For Y = x + 1 To NextNo
                         If TempSeq(x) = TempSeq(Y) Then
                             Do
                                 Do
                                     MyValue = CLng((Len(StrainSeq(0)) * Rnd) + 1)
                                     If MyValue <= Len(StrainSeq(0)) Then Exit Do
                                 Loop
                                 If Mid$(TempSeq(x), MyValue, 1) <> "-" Then
                                     MyValue2 = CLng((4 * Rnd) + 1)
                                     If MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "A"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "G"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "C"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(x), MyValue, 1) = "T"
                                     End If
                                     MyValue2 = CLng((4 * Rnd) + 1)
                                     If MyValue2 = 1 Then
                                         'XX = Len(StrainSeq(0))
                                         Mid$(TempSeq(Y), MyValue, 1) = "A"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(Y), MyValue, 1) = "G"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(Y), MyValue, 1) = "C"
                                     ElseIf MyValue2 = 1 Then
                                         Mid$(TempSeq(Y), MyValue, 1) = "T"
                                     End If
                                     Exit Do
                                     x = x - 1
                                 End If
                             Loop
                         End If
                     Next Y
                 Next x
                 
                 EE = Abs(GetTickCount)
                 TT = EE - SS '5.7 for run 9
                 If AddEventFlag = 2 Then
                     ArSize = UBound(STraceA, 1)
                     ReDim BigTreeTrace(ArSize)
                     For x = 0 To ArSize
                         BigTreeTrace(x) = STraceA(x)
                     Next x
                 ElseIf AddEventFlag = 3 Then
                     ArSize = UBound(STraceA, 1)
                     ReDim BigTreeTraceU(ArSize)
                     For x = 0 To ArSize
                         BigTreeTraceU(x) = STraceA(x)
                     Next x
                 End If
                 
                 
             Else
                 If AddEventFlag = 0 Then
                     NextNo = PermNextno
                 End If
             End If
             Form1.ProgressBar1.Value = 60
             Call UpdateF2Prog
             
             SS = Abs(GetTickCount)
             
             For x = 0 To NextNo
             
                 'XX = UBound(SeqSpaces, 1)
                 Gaps = 0
                 
                 Fullbit = Len(TempSeq(0))
                 
                 For Y = 1 To Fullbit
                     If Mid(TempSeq(x), Y, 1) = "-" Then Gaps = Gaps + 1
                 Next Y
                 
                 SeqCoverage(x) = (Fullbit - Gaps) / Fullbit
                
                 
             Next x
        End If
        EE = Abs(GetTickCount)
        TT = EE - SS '3.343 for run 9
        x = x
    End If

    
    Close #1
    
    Call WriteSequences(NumSeqs, AName, TempName(), TempSeq(), 1)

    
    If SIndex = 7 Or SIndex = 17 Then Call UnModSeqNum(0)

    
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    ReDim SeqSave(Len(StrainSeq(0)), PermNextno)
    '    ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    
    End If
    
    
End Sub

Public Sub FindSimilar(DaughterSeq, RecNumber, AcceptFlag, StartAcceptX)

Dim LenXOver2 As Long, LenXOver As Long, HitsPerseq() As Long, RSP As Long, REP As Long, RSP2 As Long, REP2 As Long, RS As Long, RE As Long, TP As Long, RS2 As Long, RE2 As Long, TP2 As Long, LSeq As Long
Dim GroupEvents() As Long, Eventholder As Long, EventPos() As Long, EventTraceA() As Long, EventTraceB() As Long
Dim EventBegin() As Long, EventEnd() As Long, TreePoses() As Long, PosNumber() As Long
Dim CNum() As Long, CPVal() As Double

LSeq = Len(StrainSeq(0))
ReDim GEvents(CurrentXOver(DaughterSeq))
ENumbs = 0
x = DaughterSeq
Y = RecNumber
StartAccept = StartAcceptX
            
            
            RSP = XoverList(x, Y).Beginning
            REP = XoverList(x, Y).Ending
'XXXZZZ              TP = XOverlist(X, Y).TreePos(0)
            
                If RSP > REP Then REP = LSeq + REP
                LenXOver = REP - RSP
                
                RE = REP - LenXOver / 4
                RS = RSP + LenXOver / 4
                
                For Z = 1 To CurrentXOver(x)
                    
                    If XoverList(x, Z).Accept = StartAccept Then
                        'Exit Sub
                        If x = 123456 Then
                            RSP2 = XoverList(x, Z).Beginning
                            REP2 = XoverList(x, Z).Ending
                            
'XXXZZZ                                  TP2 = XOverlist(X, Z).TreePos(0)
                                
                                If RSP2 < REP2 Then
                                    If REP > LSeq Then
                                        If REP2 < RSP Then
                                            RSP2 = RSP2 + LSeq
                                            REP2 = REP2 + LSeq
                                        End If
                                    End If
                                Else
                                    If REP > LSeq Then
                                        REP2 = REP2 + LSeq
                                    Else
                                        RSP2 = RSP2 - LSeq
                                    End If
                                End If
                                
                                LenXOver2 = REP2 - RSP2
                                OL = 0
                                OL2 = 0
                                If REP > REP2 Then
                                    OL = REP - REP2
                                ElseIf REP < REP2 Then
                                    OL2 = REP2 - REP
                                End If
                                If RSP > RSP2 Then
                                    OL2 = OL2 + RSP - RSP2
                                ElseIf RSP < RSP2 Then
                                    OL = OL + RSP2 - RSP
                                End If
                                RE2 = REP2 - LenXOver2 / 4
                                RS2 = RSP2 + LenXOver2 / 4
                                'Exit Sub
                                
                                If LenXOver > 0 And LenXOver2 > 0 Then
                                    If RS2 < RE And RE2 > RS And TP = TP2 And OL / LenXOver < 0.5 And OL2 / LenXOver2 < 0.5 Then
                                        ENumbs = ENumbs + 1
                                        GEvents(ENumbs) = Z
                                        XoverList(x, Z).Accept = AcceptFlag
                                        
                                    End If
                                End If
                            Else
                                If XoverList(x, Z).Eventnumber = XoverList(x, Y).Eventnumber Then
                                    ENumbs = ENumbs + 1
                                    GEvents(ENumbs) = Z
                                    XoverList(x, Z).Accept = AcceptFlag
                                End If
                            End If
                    End If
                Next Z
End Sub
Public Sub ReCheck()

    Dim HitsPerseq() As Long
    Dim NumHits() As Long
    Dim LSeq As Long, BPos As Long, Epos As Long, Ma As Long, Mi As Long, SubM As Long
    Dim x As Long, EY As Long, Y As Long, Z As Long
    Dim NumToAdd As Long
    NumToAdd = 1
    LSeq = Len(StrainSeq(0))
    ReDim HitsPerseq(NextNo, LSeq)

    For x = 0 To NextNo
        EY = CurrentXOver(x)

        For Y = 1 To EY

            If XoverList(x, Y).Ending > LSeq Then
                XoverList(x, Y).Ending = LSeq
                XoverList(x, Y).Beginning = LSeq - 15
            End If

            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            BPos = XoverList(x, Y).Beginning
            Epos = XoverList(x, Y).Ending

            If BPos <= Epos Then
                SubM = Int((Epos - BPos) / 3)
                BPos = BPos + SubM
                Epos = Epos - SubM
                
                AddScores BPos, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
'                For Z = BPos To EPos
'                    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    'HitsPerSeq(Ma, Z) = HitsPerSeq(Ma, Z) + 1
'                    'HitsPerSeq(Mi, Z) = HitsPerSeq(Mi, Z) + 1
'                Next 'Z

            Else
                SubM = Int((Epos + (LSeq - BPos)) / 3)
                BPos = BPos + SubM

                If BPos > LSeq Then BPos = BPos - LSeq
                Epos = Epos - SubM

                If Epos < 0 Then Epos = LSeq + Epos

                If Epos < BPos Then
                    AddScores 1, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    AddScores BPos, LSeq, NextNo, NumToAdd, x, HitsPerseq(0, 0)
           '         For Z = 1 To EPos
           '             HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
           '         Next 'Z'

'                    For Z = BPos To LSeq
'                        HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    Next 'Z

                Else
                    AddScores BPos, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    
              '      For Z = BPos To EPos
              '          HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
              '      Next 'Z

                End If

            End If

        Next 'Y

    Next 'X
    For x = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXOver(x)
            ReDim NumHits(2)
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            

            If Mi <= NextNo And Mi <> x Then
                
                BPos = XoverList(x, Y).Beginning
                Epos = XoverList(x, Y).Ending
                
               ' If BPos <= EPos Then
               '     SubM = Int((EPos - BPos) / 3)
               '     BPos = BPos + SubM
               '     EPos = EPos - SubM
               ' Else
               '     SubM = Int((EPos + (LSeq - BPos)) / 3)
               '     BPos = BPos + SubM
   '
     '               If BPos > LSeq Then BPos = BPos - LSeq
     '               EPos = EPos - SubM
   '
   '                 If EPos < 0 Then EPos = LSeq + EPos
   '             End If
                
                If BPos <= Epos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, Epos, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
       '             For Z = BPos To EPos
       '                 NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
       '                 NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
       '                 NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
       '             Next 'Z

                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits2 1, Epos, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    DoHits2 BPos, LSeq, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If

                If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                    Call UpdateXOList(Mi, CurrentXOver(), XoverList())
                    
                    XoverList(Mi, CurrentXOver(Mi)) = XoverList(x, Y)
                    XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                    XoverList(Mi, CurrentXOver(Mi)).Daughter = XoverList(x, Y).MinorP
                    XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(x, Y).Daughter
                    XoverList(Mi, CurrentXOver(Mi)).MajorP = XoverList(x, Y).MajorP

                    If XoverList(x, Y).OutsideFlag = 0 Then
                        XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                    ElseIf XoverList(x, Y).OutsideFlag = 1 Then
                        XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                    ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                        Temp = XoverList(Mi, CurrentXOver(Mi)).MinorP
                        XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(ActiveMinorP, CurrentXOver(ActiveMinorP)).MajorP
                        XoverList(Mi, CurrentXOver(Mi)).MajorP = Temp
                        XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 0
                        XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                    Else
                        XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = XoverList(x, Y).OutsideFlag
                    End If
                    
                    If Y = CurrentXOver(x) Then
                        CurrentXOver(x) = CurrentXOver(x) - 1
                    ElseIf CurrentXOver(x) > 0 Then
                        XoverList(x, Y) = XoverList(x, CurrentXOver(x))
                        CurrentXOver(x) = CurrentXOver(x) - 1
                        Y = Y - 1
                    End If

                ElseIf NumHits(2) > NumHits(0) And NumHits(2) > NumHits(1) Then
                    Call UpdateXOList(Ma, CurrentXOver(), XoverList())
                    XoverList(Ma, CurrentXOver(Ma)) = XoverList(x, Y)
                    XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                    XoverList(Ma, CurrentXOver(Ma)).Daughter = XoverList(x, Y).MajorP
                    XoverList(Ma, CurrentXOver(Ma)).MinorP = XoverList(x, Y).MinorP
                    XoverList(Ma, CurrentXOver(Ma)).MajorP = XoverList(x, Y).Daughter
                    XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2

                   
                    If XoverList(x, Y).OutsideFlag = 1 Then
                        XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                    ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                        Temp = XoverList(Ma, CurrentXOver(Ma)).MinorP
                        XoverList(Ma, CurrentXOver(Ma)).MinorP = XoverList(Ma, CurrentXOver(Ma)).MajorP
                        XoverList(Ma, CurrentXOver(Ma)).MajorP = Temp
                        XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 0
                        XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                    ElseIf XoverList(x, Y).OutsideFlag = 0 Then
                        XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                        XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                    Else
                        XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = XoverList(x, Y).OutsideFlag
                    End If
                    
                    If Y = CurrentXOver(x) Then
                        CurrentXOver(x) = CurrentXOver(x) - 1
                    ElseIf CurrentXOver(x) > 1 Then
                        XoverList(x, Y) = XoverList(x, CurrentXOver(x))
                        CurrentXOver(x) = CurrentXOver(x) - 1
                        Y = Y - 1
                    
                    End If

                End If

            End If

            Y = Y + 1
        Loop

    Next 'X

End Sub
Public Sub ReCheck2()
    Dim HitsPerseq() As Long, HitsPerSeq2() As Long
    Dim NumHits() As Long
    Dim LSeq As Long, BPos As Long, Epos As Long, Ma As Long, Mi As Long, SubM As Long
    Dim x As Long, EY As Long, Y As Long, Z As Long
    Dim NumToAdd As Long
    NumToAdd = 1
    LSeq = Len(StrainSeq(0))
    
    ReDim HitsPerseq(NextNo, LSeq)
    ReDim HitsPerSeq2(NextNo, LSeq)
    'Exit Sub
    For x = 0 To NextNo
        EY = CurrentXOver(x)

        For Y = 1 To EY

            If XoverList(x, Y).Ending > LSeq Then
                XoverList(x, Y).Ending = LSeq
                XoverList(x, Y).Beginning = LSeq - 15
            End If

            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            BPos = XoverList(x, Y).Beginning
            Epos = XoverList(x, Y).Ending

            If BPos <= Epos Then
                SubM = Int((Epos - BPos) / 3)
                BPos = BPos + SubM
                Epos = Epos - SubM
                
                AddScores BPos, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
'                For Z = BPos To EPos
'                    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    'HitsPerSeq(Ma, Z) = HitsPerSeq(Ma, Z) + 1
'                    'HitsPerSeq(Mi, Z) = HitsPerSeq(Mi, Z) + 1
'                Next 'Z

            Else
                SubM = Int((Epos + (LSeq - BPos)) / 3)
                BPos = BPos + SubM

                If BPos > LSeq Then BPos = BPos - LSeq
                Epos = Epos - SubM

                If Epos < 0 Then Epos = LSeq + Epos

                If Epos < BPos Then
                    AddScores 1, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    AddScores BPos, LSeq, NextNo, NumToAdd, x, HitsPerseq(0, 0)
           '         For Z = 1 To EPos
           '             HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
           '         Next 'Z'

'                    For Z = BPos To LSeq
'                        HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
'                    Next 'Z

                Else
                    AddScores BPos, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    
              '      For Z = BPos To EPos
              '          HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + 1
              '      Next 'Z

                End If

            End If

        Next 'Y
        Form1.ProgressBar1.Value = ((x / NextNo) * 0.2) * 100
        Call UpdateF2Prog
    Next 'X
    
    For x = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXOver(x)
            ReDim NumHits(2)
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            

            If Mi <= NextNo And Mi <> x Then
                
                BPos = XoverList(x, Y).Beginning
                Epos = XoverList(x, Y).Ending
                
                If BPos <= Epos Then
                    SubM = Int((Epos - BPos) / 4)
                    BPos = BPos + SubM
                    Epos = Epos - SubM
                Else
                    SubM = Int((Epos + (LSeq - BPos)) / 4)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    Epos = Epos - SubM
   
                    If Epos < 0 Then Epos = LSeq + Epos
                End If
                
                If BPos <= Epos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, Epos, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
       '             For Z = BPos To EPos
       '                 NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
       '                 NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
       '                 NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
       '             Next 'Z
                    If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                        For Z = BPos To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                        For Z = BPos To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            
                        Next 'Z
                    ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                        For Z = BPos To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    Else
                      '  For Z = BPos To EPos
                      '      HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                       '     HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                      '      HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                      '  Next 'Z
                    End If

                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits 1, Epos, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    DoHits BPos, LSeq, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                    
                    If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                        For Z = 1 To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                        For Z = 1 To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                        Next 'Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                        Next 'Z
                    ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                        For Z = 1 To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 1
                            HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                            HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                        Next 'Z
                    End If
                    
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                
            End If
            Y = Y + 1
        Loop
        Form1.ProgressBar1.Value = 20 + ((x / NextNo) * 0.2) * 100
        Call UpdateF2Prog
    Next 'X
                
    
            
                
                
                
    For x = 0 To NextNo
        
        Y = 1
        Do While Y <= CurrentXOver(x)
            
          
            ReDim NumHits(2)
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            

            If Mi <= NextNo And Mi <> x Then
                
                BPos = XoverList(x, Y).Beginning
                Epos = XoverList(x, Y).Ending
                
                If BPos <= Epos Then
                    SubM = Int((Epos - BPos) / 4)
                    BPos = BPos + SubM
                    Epos = Epos - SubM
                Else
                    SubM = Int((Epos + (LSeq - BPos)) / 4)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    Epos = Epos - SubM
   
                    If Epos < 0 Then Epos = LSeq + Epos
                End If
                
                If BPos <= Epos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, Epos, NextNo, x, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)


                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits2 1, Epos, NextNo, x, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
                    DoHits2 BPos, LSeq, NextNo, x, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                    Call UpdateXOList(Mi, CurrentXOver(), XoverList())
                    
                    XoverList(Mi, CurrentXOver(Mi)) = XoverList(x, Y)
                    'XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    XoverList(Mi, CurrentXOver(Mi)).Daughter = XoverList(x, Y).MinorP
                    XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(x, Y).Daughter
                    XoverList(Mi, CurrentXOver(Mi)).MajorP = XoverList(x, Y).MajorP
                    
                    D = x
                    Outer1 = 0
                    If XoverList(x, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XoverList(x, Y).OutsideFlag = 0 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = XoverList(x, Y).OutsideFlag
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 2
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 1 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                            Temp = XoverList(Mi, CurrentXOver(Mi)).MinorP
                            XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(Mi, CurrentXOver(Mi)).MajorP
                            XoverList(Mi, CurrentXOver(Mi)).MajorP = Temp
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                            
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            Outer1 = 0
                            If Distance(Mi, Ma) < (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                                Outer1 = 1
                            End If
                            
                            If Outer1 = 1 And x = 1233456 Then
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                            Else
                                Temp = XoverList(Mi, CurrentXOver(Mi)).MinorP
                                XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(Mi, CurrentXOver(Mi)).MajorP
                                XoverList(Mi, CurrentXOver(Mi)).MajorP = Temp
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 1
                                XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                            End If
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Or x = x Then
                                                                
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 1
                                
                            Else
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                            End If
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    If Y = CurrentXOver(x) Then
                        CurrentXOver(x) = CurrentXOver(x) - 1
                    ElseIf CurrentXOver(x) > 0 Then
                        XoverList(x, Y) = XoverList(x, CurrentXOver(x))
                        
                        CurrentXOver(x) = CurrentXOver(x) - 1
                        Y = Y - 1
                    End If

                ElseIf NumHits(2) > NumHits(0) And NumHits(2) > NumHits(1) Then
                    Call UpdateXOList(Ma, CurrentXOver(), XoverList())
                    
                    XoverList(Ma, CurrentXOver(Ma)).Beginning = XoverList(x, Y).Beginning
                    'XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    XoverList(Ma, CurrentXOver(Ma)).Daughter = XoverList(x, Y).MajorP
                    XoverList(Ma, CurrentXOver(Ma)).MinorP = XoverList(x, Y).MinorP
                    XoverList(Ma, CurrentXOver(Ma)).MajorP = XoverList(x, Y).Daughter
                    D = x
                    Outer1 = 0
                    If XoverList(x, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XoverList(x, Y).OutsideFlag = 0 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = XoverList(x, Y).OutsideFlag
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 2
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 1 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            Temp = XoverList(Ma, CurrentXOver(Ma)).MinorP
                            XoverList(Ma, CurrentXOver(Ma)).MinorP = XoverList(Ma, CurrentXOver(Ma)).MajorP
                            XoverList(Ma, CurrentXOver(Ma)).MajorP = Temp
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                            
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 0
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Then
                                                                
                                XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 1
                                
                            Else
                                XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            End If
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    If Y = CurrentXOver(x) Then
                        CurrentXOver(x) = CurrentXOver(x) - 1
                    ElseIf CurrentXOver(x) > 1 Then
                        XoverList(x, Y) = XoverList(x, CurrentXOver(x))
                        CurrentXOver(x) = CurrentXOver(x) - 1
                        Y = Y - 1
                    
                    End If

                End If

            End If

            Y = Y + 1
        Loop
        Form1.ProgressBar1.Value = 40 + ((x / NextNo) * 0.6) * 100
        Call UpdateF2Prog
    Next 'X
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
End Sub

Public Sub ReSortB()

    Dim HitsPerseq() As Long, HitsPerSeq2() As Long
    Dim NumHits() As Long
    Dim LSeq As Long, BPos As Long, Epos As Long, Ma As Long, Mi As Long, SubM As Long
    Dim NumToAdd As Long, x As Long, EY As Long, Y As Long, Z As Long
    
    LSeq = Len(StrainSeq(0))
    ReDim HitsPerseq(NextNo, LSeq)
    ReDim HitsPerSeq2(NextNo, LSeq)
    Form1.SSPanel1.Caption = "Re-Sorting Regions"
    For x = 0 To NextNo
        EY = CurrentXOver(x)

        For Y = 1 To EY
            If XoverList(x, Y).Ending > LSeq Then
                XoverList(x, Y).Ending = LSeq
                XoverList(x, Y).Beginning = LSeq - 15
            End If

            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            BPos = XoverList(x, Y).Beginning
            Epos = XoverList(x, Y).Ending
            If XoverList(x, Y).Accept = 0 Then
                NumToAdd = 1
            ElseIf XoverList(x, Y).Accept = 2 Then
                NumToAdd = 0
            ElseIf XoverList(x, Y).Accept = 1 Then
                NumToAdd = 10000
            End If
            
            If BPos <= Epos Then
                SubM = Int((Epos - BPos) / 3)
                BPos = BPos + SubM
                Epos = Epos - SubM
                
                'AddScores BPos, EPos, Nextno, NumToAdd, X, HitsPerseq(0, 0)
                
                For Z = BPos To Epos
                    HitsPerseq(x, Z) = HitsPerseq(x, Z) + NumToAdd
                    x = x
                Next 'Z

            Else
                SubM = Int((Epos + (LSeq - BPos)) / 3)
                BPos = BPos + SubM

                If BPos > LSeq Then BPos = BPos - LSeq
                Epos = Epos - SubM

                If Epos < 0 Then Epos = LSeq + Epos

                If Epos < BPos Then
                    
                    AddScores 1, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    AddScores BPos, LSeq, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    'For Z = 1 To EPos
                    '    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + NumToAdd
                    'Next 'Z
                    
                    'For Z = BPos To LSeq
                    '    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + NumToAdd
                    'Next 'Z

                Else
                    AddScores BPos, Epos, NextNo, NumToAdd, x, HitsPerseq(0, 0)
                    'For Z = BPos To EPos
                    '    HitsPerSeq(X, Z) = HitsPerSeq(X, Z) + NumToAdd
                   ' Next 'Z

                End If

            End If

        Next 'Y
        Form1.ProgressBar1 = (x / NextNo) * 30
        Call UpdateF2Prog
    Next 'X

    For x = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXOver(x)
            
            ReDim NumHits(2)
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            

            If Mi <= NextNo And Mi <> x Then
                
                BPos = XoverList(x, Y).Beginning
                Epos = XoverList(x, Y).Ending
                
                If BPos <= Epos Then
                    SubM = Int((Epos - BPos) / 3)
                    BPos = BPos + SubM
                    Epos = Epos - SubM
                Else
                    SubM = Int((Epos + (LSeq - BPos)) / 3)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    Epos = Epos - SubM
   
                    If Epos < 0 Then Epos = LSeq + Epos
                End If
                
                If BPos <= Epos Then
                    If XoverList(x, Y).Accept = 1 Then
                        For Z = BPos To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 10000
                        Next Z
                    Else
                        'First count the number of hits for this sequence
                        DoHits2 BPos, Epos, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                        'For Z = BPos To EPos
                        '    NumHits(0) = NumHits(0) + HitsPerseq(X, Z)
                        '    NumHits(1) = NumHits(1) + HitsPerseq(Mi, Z)
                        '    NumHits(2) = NumHits(2) + HitsPerseq(Ma, Z)
                        'Next 'Z
                        If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                            For Z = BPos To Epos
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                            For Z = BPos To Epos
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            Next 'Z
                        ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                            For Z = BPos To Epos
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        Else
                          '  For Z = BPos To EPos
                          '      HitsPerSeq2(X, Z) = HitsPerSeq2(X, Z) - 1
                           '     HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                          '      HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                          '  Next 'Z
                        End If
                    End If
                Else
                    
                    If XoverList(x, Y).Accept = 1 Then
                        For Z = 1 To Epos
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 10000
                        Next Z
                        For Z = BPos To LSeq
                            HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 10000
                        Next Z
                    Else
                        ' if region overlaps the ends
                        'First count the number of hits for this sequence
                        DoHits 1, Epos, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                        DoHits BPos, LSeq, NextNo, x, Mi, Ma, HitsPerseq(0, 0), NumHits(0)
                        
                        If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                            For Z = 1 To Epos
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                            For Z = BPos To LSeq
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) + 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        ElseIf NumHits(2) > NumHits(0) And (NumHits(2) > NumHits(1)) Then
                            For Z = 1 To Epos
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            Next 'Z
                            For Z = BPos To LSeq
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) - 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) + 1
                            Next 'Z
                        ElseIf NumHits(0) > NumHits(1) And (NumHits(0) > NumHits(2)) Then
                            For Z = 1 To Epos
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                            For Z = BPos To LSeq
                                HitsPerSeq2(x, Z) = HitsPerSeq2(x, Z) + 1
                                HitsPerSeq2(Mi, Z) = HitsPerSeq2(Mi, Z) - 1
                                HitsPerSeq2(Ma, Z) = HitsPerSeq2(Ma, Z) - 1
                            Next 'Z
                        End If
                    End If
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                
            End If
            Y = Y + 1
        Loop
        Form1.ProgressBar1 = 30 + (x / NextNo) * 30
        Call UpdateF2Prog
    Next 'X
    
    For x = 0 To NextNo
        Y = 1
        Do While Y <= CurrentXOver(x)
            ReDim NumHits(2)
            Mi = XoverList(x, Y).MinorP
            Ma = XoverList(x, Y).MajorP
            

            If Mi <= NextNo And Mi <> x Then
                
                BPos = XoverList(x, Y).Beginning
                Epos = XoverList(x, Y).Ending
                
                If BPos <= Epos Then
                    SubM = Int((Epos - BPos) / 3)
                    BPos = BPos + SubM
                    Epos = Epos - SubM
                Else
                    SubM = Int((Epos + (LSeq - BPos)) / 3)
                    BPos = BPos + SubM
   
                   If BPos > LSeq Then BPos = BPos - LSeq
                    Epos = Epos - SubM
   
                    If Epos < 0 Then Epos = LSeq + Epos
                End If
                
                If BPos <= Epos Then

                    'First count the number of hits for this sequence
                    DoHits2 BPos, Epos, NextNo, x, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)


                Else
                    
                    
                    ' if region overlaps the ends
                    'First count the number of hits for this sequence
                    DoHits2 1, Epos, NextNo, x, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
                    DoHits2 BPos, LSeq, NextNo, x, Mi, Ma, HitsPerSeq2(0, 0), NumHits(0)
     '               For Z = BPos To LSeq
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

     '               For Z = 1 To EPos
     '                   NumHits(0) = NumHits(0) + HitsPerSeq(X, Z)
     '                   NumHits(1) = NumHits(1) + HitsPerSeq(Mi, Z)
     '                   NumHits(2) = NumHits(2) + HitsPerSeq(Ma, Z)
     '               Next 'Z

                End If
                If NumHits(1) > NumHits(0) And (NumHits(1) > NumHits(2)) Then
                    Call UpdateXOList(Mi, CurrentXOver(), XoverList())
                    
                    XoverList(Mi, CurrentXOver(Mi)) = XoverList(x, Y)
                    'XOverList(Mi, CurrentXover(Mi)).MissIdentifyFlag = 1
                    XoverList(Mi, CurrentXOver(Mi)).Daughter = XoverList(x, Y).MinorP
                    XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(x, Y).Daughter
                    XoverList(Mi, CurrentXOver(Mi)).MajorP = XoverList(x, Y).MajorP
                    Outer1 = 0
                    D = x
                    If XoverList(x, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XoverList(x, Y).OutsideFlag = 0 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 1
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = XoverList(x, Y).OutsideFlag
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 1
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 2
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 1 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 0
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = XoverList(x, Y).OutsideFlag
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            Temp = XoverList(Mi, CurrentXOver(Mi)).MinorP
                            XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(Mi, CurrentXOver(Mi)).MajorP
                            XoverList(Mi, CurrentXOver(Mi)).MajorP = Temp
                            XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 0
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Or x = x Then
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 1
                                Temp = XoverList(Mi, CurrentXOver(Mi)).MinorP
                                XoverList(Mi, CurrentXOver(Mi)).MinorP = XoverList(Mi, CurrentXOver(Mi)).MajorP
                                XoverList(Mi, CurrentXOver(Mi)).MajorP = Temp
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 0
                                
                            Else
                                XoverList(Mi, CurrentXOver(Mi)).OutsideFlag = 2
                            End If
                            XoverList(Mi, CurrentXOver(Mi)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    Call CompressList(x, Y, XoverList(), CurrentXOver())
                    
                    If CurrentXOver(x) > 1 And Y < CurrentXOver(x) Then Y = Y - 1
                ElseIf NumHits(2) > NumHits(0) And NumHits(2) > NumHits(1) Then
                    Call UpdateXOList(Ma, CurrentXOver(), XoverList())
                    XoverList(Ma, CurrentXOver(Ma)) = XoverList(x, Y)

                    'XOverList(Ma, CurrentXover(Ma)).MissIdentifyFlag = 1
                    XoverList(Ma, CurrentXOver(Ma)).Daughter = XoverList(x, Y).MajorP
                    XoverList(Ma, CurrentXOver(Ma)).MinorP = XoverList(x, Y).MinorP
                    XoverList(Ma, CurrentXOver(Ma)).MajorP = XoverList(x, Y).Daughter
                    D = x
                    Outer1 = 0
                    If XoverList(x, Y).MissIdentifyFlag = 1 Then
                    
                        If Distance(Mi, Ma) > (Distance(Mi, D) + Distance(Ma, D)) / 2 Then
                            Outer1 = 1
                        End If
                        
                    End If
                    If XoverList(x, Y).OutsideFlag = 0 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = XoverList(x, Y).OutsideFlag
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 2
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 1 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            Temp = XoverList(Ma, CurrentXOver(Ma)).MinorP
                            XoverList(Ma, CurrentXOver(Ma)).MinorP = XoverList(Ma, CurrentXOver(Ma)).MajorP
                            XoverList(Ma, CurrentXOver(Ma)).MajorP = Temp
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                            
                        End If
                    ElseIf XoverList(x, Y).OutsideFlag = 2 Then
                        If XoverList(x, Y).MissIdentifyFlag = 0 Or XoverList(x, Y).MissIdentifyFlag = 2 Then
                            
                            XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 0
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = XoverList(x, Y).MissIdentifyFlag
                        ElseIf XoverList(x, Y).MissIdentifyFlag = 1 Then
                            If Outer1 = 1 Then
                                                                
                                XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 1
                                
                            Else
                                XoverList(Ma, CurrentXOver(Ma)).OutsideFlag = 2
                            End If
                            XoverList(Ma, CurrentXOver(Ma)).MissIdentifyFlag = 1
                        End If
                    End If
                    
                    Call CompressList(x, Y, XoverList(), CurrentXOver())
                    
                    If CurrentXOver(x) > 1 And Y < CurrentXOver(x) Then
                        Y = Y - 1
                    
                    End If

                End If

            End If

            Y = Y + 1
        Loop
        Form1.ProgressBar1 = 60 + (x / NextNo) * 30
        Call UpdateF2Prog
    Next 'X
    If PermNextno > MemPoc And x = 1234567 Then
        ReDim Distance(0, 0)
    End If
End Sub

Public Sub LoadLF(FN As String, DoSeqNo, LFCode)
Dim FNum As Integer
ErrorFlag = 0
FNum = FreeFile
Open "infile" For Output As #FNum
Print #FNum, FN
Print #FNum, Trim(Str(DoSeqNo + 1))
Close #FNum
ExpectFL = DoSeqNo
'OP = GetCommandOutput("lkgen.bat", 5, True, True)
Call ShellAndClose(LKString, 0)

If FN = "LF0100" Then
   FN = "LF0" + Trim(Str(DoSeqNo + 1))
ElseIf FN = "LF1100" Then
   FN = "LF1" + Trim(Str(DoSeqNo + 1))
ElseIf FN = "LF250" Then
   FN = "LF2" + Trim(Str(DoSeqNo + 1))
End If
If DebuggingFlag < 2 Then On Error Resume Next
If FN <> "LF0100" And FN <> "LF1100" And FN <> "LF250" Then
    Kill FN
End If
On Error GoTo 0
Open "new_lk.txt" For Append As #FNum
If LOF(FNum) = 0 Then
    
    Response = MsgBox("There was a problem extracting data from the likelihood lookup file.  Make sure that files named 'lkgen.exe' and 'LF0100' are in the RDP startup directory", 0, "RDP Warning")
    
    Close #FNum
    VRFlag = 0
    Form1.SSPanel1.Caption = ""
    ErrorFlag = 1
    Exit Sub
End If
Close #FNum
If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "LF" & (Trim(Str(LFCode))) & (Trim(Str(DoSeqNo + 1)))
On Error GoTo 0

Name "new_lk.txt" As "LF" & Trim(Str(LFCode)) & (Trim(Str(DoSeqNo + 1)))

FN = "LF" + Trim(Str(LFCode)) + Trim(Str(DoSeqNo + 1))
End Sub
Public Sub MakePVO5(RS, PVO As String)
Pos = InStr(1, PVO, ".", vbBinaryCompare) 'Check for decimal

If Pos = 0 Then
    If Len(PVO) < RS - 1 Then
        PVO = PVO + "."
    Else
        Exit Sub
    End If
End If
If Len(PVO) = RS Then
    Exit Sub
ElseIf Len(PVO) = RS - 1 Then
    PVO = PVO + "0"
ElseIf Len(PVO) = RS - 2 Then
    PVO = PVO + "00"
ElseIf Len(PVO) = RS - 3 Then
    PVO = PVO + "000"
ElseIf Len(PVO) = RS - 4 Then
    PVO = PVO + "0000"
ElseIf Len(PVO) = RS - 5 Then
    PVO = PVO + "00000"
ElseIf Len(PVO) = RS - 6 Then
    PVO = PVO + "00000"
ElseIf Len(PVO) = RS - 7 Then
    PVO = PVO + "00000"
End If

End Sub
Public Sub NextSeqs(GoOn)
GoOn = 1
Seq3 = Seq3 + 1
If Seq3 > NextNo Then
    Seq2 = Seq2 + 1
    If Seq2 < NextNo Then
        Seq3 = Seq2 + 1
    Else
        Seq1 = Seq1 + 1
        If Seq1 < NextNo - 1 Then
            Seq2 = Seq1 + 1
            Seq3 = Seq2 + 1
        Else
            GoOn = 0
        End If
    End If
End If
If Seq1 > NextNo Or Seq2 > NextNo Or Seq3 > NextNo Then
    x = x
End If

End Sub
Public Sub RefreshTimes()
Dim oShowPlt As Byte
If DontRefreshFlag = 1 Then Exit Sub
oShowPlt = ShowPlotFlag
ShowPlotFlag = 0




If NoF3Check = 1 Or NoF3Check2 = 1 Then
    ShowPlotFlag = oShowPlt
    Exit Sub
End If
If Form3.Visible = True And Form3.Command1.Enabled = True And Form3.Command1.Visible = True Then
    Form3.Command1.SetFocus
End If
Dim TotT As Double
    
If Form3.Check1.Value = 1 Then
    DoScans(0, 2) = 1
Else
    DoScans(0, 2) = 0
End If
If Form3.Check12.Value = 1 Then
    DoScans(0, 8) = 1
Else
    DoScans(0, 8) = 0
End If
If Form3.Check2.Value = 1 Then
    DoScans(0, 3) = 1
Else
    DoScans(0, 3) = 0
End If
If Form3.Check3.Value = 1 Then
    DoScans(0, 4) = 1
Else
    DoScans(0, 4) = 0
End If
If Form3.Check4.Value = 1 Then
    DoScans(0, 0) = 1
Else
    DoScans(0, 0) = 0
End If
If Form3.Check5.Value = 1 Then
    DoScans(0, 1) = 1
Else
    DoScans(0, 1) = 0
End If
If Form3.Check6.Value = 1 Then
    DoScans(0, 5) = 1
Else
    DoScans(0, 5) = 0
End If
If Form3.Check12.Value = 1 Then
    DoScans(0, 8) = 1
Else
    DoScans(0, 8) = 0
End If
If Form3.Check21.Value = 1 Then
    DoScans(0, 7) = 1
Else
    DoScans(0, 7) = 0
End If



If Form3.Check14.Value = 1 Then
    DoScans(1, 0) = 1
Else
    DoScans(1, 0) = 0
End If
If Form3.Check15.Value = 1 Then
    DoScans(1, 1) = 1
Else
    DoScans(1, 1) = 0
End If
If Form3.Check16.Value = 1 Then
    DoScans(1, 2) = 1
Else
    DoScans(1, 2) = 0
End If
If Form3.Check17.Value = 1 Then
    DoScans(1, 3) = 1
Else
    DoScans(1, 3) = 0
End If
If Form3.Check18.Value = 1 Then
    DoScans(1, 4) = 1
Else
    DoScans(1, 4) = 0
End If
If Form3.Check19.Value = 1 Then
    DoScans(1, 5) = 1
Else
    DoScans(1, 5) = 0
End If
If Form3.Check20.Value = 1 Then
    DoScans(1, 8) = 1
Else
    DoScans(1, 8) = 0
End If
If Form3.Check22.Value = 1 Then
    DoScans(1, 7) = 1
Else
    DoScans(1, 7) = 0
End If


Call GetTot(TotT)



Call DoProgLine(TotT)



ShowPlotFlag = oShowPlt
End Sub

Public Sub SetChecks()
NoF3Check = 1
If DoScans(0, 2) = 1 Then
    Form3.Check1.Value = 1
Else
    Form3.Check1.Value = 0
End If

If DoScans(0, 8) = 1 Then
    Form3.Check12.Value = 1
Else
    Form3.Check12.Value = 0
End If

If DoScans(0, 3) = 1 Then
    Form3.Check2.Value = 1
Else
    Form3.Check2.Value = 0
End If

If DoScans(0, 4) = 1 Then
    Form3.Check3.Value = 1
Else
    Form3.Check3.Value = 0
End If

If DoScans(0, 0) = 1 Then
    Form3.Check4.Value = 1
Else
    Form3.Check4.Value = 0
End If

If DoScans(0, 1) = 1 Then
    Form3.Check5.Value = 1
Else
    Form3.Check5.Value = 0
End If

If DoScans(0, 5) = 1 Then
    Form3.Check6.Value = 1
Else
    Form3.Check6.Value = 0
End If

If DoScans(0, 8) = 1 Then
    Form3.Check12.Value = 1
Else
    Form3.Check12.Value = 0
End If

If DoScans(0, 7) = 1 Then
    Form3.Check21.Value = 1
Else
    Form3.Check21.Value = 0
End If

If DoScans(1, 0) = 1 Then
    Form3.Check14.Value = 1
Else
    Form3.Check14.Value = 0
End If

If DoScans(1, 1) = 1 Then
    Form3.Check15.Value = 1
Else
    Form3.Check15.Value = 0
End If

If DoScans(1, 2) = 1 Then
    Form3.Check16.Value = 1
Else
    Form3.Check16.Value = 0
End If

If DoScans(1, 3) = 1 Then
    Form3.Check17.Value = 1
Else
    Form3.Check17.Value = 0
End If

If DoScans(1, 4) = 1 Then
    Form3.Check18.Value = 1
Else
    Form3.Check18.Value = 0
End If

If DoScans(1, 5) = 1 Then
    Form3.Check19.Value = 1
Else
    Form3.Check19.Value = 0
End If
If DoScans(1, 8) = 1 Then
    Form3.Check20.Value = 1
Else
    Form3.Check20.Value = 0
End If
If DoScans(1, 7) = 1 Then
    Form3.Check22.Value = 1
Else
    Form3.Check22.Value = 0
End If
NoF3Check = 0
End Sub
Public Sub UpdateAgeScore(Z, CurAge, Curscore, Beginning, Ending, AgeScore() As Single, EventScore() As Long)
If AllowConflict = 1 Then Exit Sub
Dim A As Long
    If Beginning < Ending Then
        For A = Beginning To Ending
            
            If AgeScore(A, Z) > CurAge Or AgeScore(A, Z) = -1 Then
                AgeScore(A, Z) = CurAge
                EventScore(A, Z) = Curscore
                
            End If
        Next A
    Else
        For A = 1 To Ending
            If AgeScore(A, Z) > CurAge Or AgeScore(A, Z) = -1 Then
                AgeScore(A, Z) = CurAge
                EventScore(A, Z) = Curscore
            End If
        Next A
        For A = Beginning To Len(StrainSeq(0))
            If AgeScore(A, Z) > CurAge Or AgeScore(A, Z) = -1 Then
                AgeScore(A, Z) = CurAge
                EventScore(A, Z) = Curscore
            End If
        Next A
    End If
End Sub
Public Sub SetUpScanArrays(SProg As Byte)
    If SProg = 1 Then
        Form1.SSPanel1.Caption = "Sorting data"
        Form1.ProgressBar1.Value = 5
        Call UpdateF2Prog
    End If
'    If X = 12345 Then
'        ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
'        ReDim XDiffPos(Len(StrainSeq(0)) + 200)
'        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
'        ReDim ValidSpacer(Nextno)
'        ReDim SpacerSeqs(Nextno)
'        ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
'        ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)
'    End If
    
'If DoScans(0, 1) = 1 Then
    'If GCtripletflag = 1 Then
'    If X = 12345 Then
'        ReDim SubSeq(Len(StrainSeq(0)), 6)
'        ReDim FragMaxScore(GCDimSize, 5)
'        ReDim MaxScorePos(GCDimSize, 5)
'        ReDim PVals(GCDimSize, 5)
'        ReDim FragSt(GCDimSize, 6)
'        ReDim FragEn(GCDimSize, 6)
'        ReDim FragScore(GCDimSize, 6)
'        ReDim DeleteArray(Len(StrainSeq(0)) + 1)
'    End If
   ' End If
'End If
    
'If DoScans(0, 3) = 1 Then
    'If MCTripletFlag = 0 Then
'    If X = 12345 Then
'        HWindowWidth = CLng(MCWinSize / 2)
'        ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
'        ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
'        ReDim Chivals(Len(StrainSeq(0)), 2)
'        ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
'        ReDim SmoothChi(Len(StrainSeq(0)), 2)
'        If MCProportionFlag = 0 Then
'
'            Call GetCriticalDiff(0)
'
'            If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
'                MCWinSize = HWindowWidth * 2
'            End If
'        End If
'    End If
   ' End If
'End If
'If DoScans(0, 4) = 1 Then
'    If X = 12345 Then
'        HWindowWidth = CLng(CWinSize / 2)
'        ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
'        ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
'        ReDim ChiValsX(Len(StrainSeq(0)))
'        ReDim SmoothChiX(Len(StrainSeq(0)))
'        Call GetCriticalDiff(1)
'        If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
'            CWinSize = HWindowWidth * 2
'        End If
'    End If
    
'End If
    If SProg = 1 Then
        Form1.ProgressBar1.Value = 15
        Call UpdateF2Prog
    End If
    If XTableFlag = 0 Then
        Call Build3SeqTable
    End If
    
    ReDim XoverSeqNumTS(0)
    If SProg = 1 Then
        Form1.ProgressBar1.Value = 100
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
    End If
End Sub

Public Sub ProcessEvent(PRN, ProbabilityXOver As Double, BTarget As Long, ETarget As Long, XPosDiff() As Long, XDiffPos() As Long, BWarn, EWarn, XoverWindow, LenXoverSeq)

Dim DoneRedo As Long, SIP As Long, AD As Long, AMi As Long, AMa As Long
'AD = Daughter
'seq1=2, seq2=103, seq3 =154
If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
    AD = Seq1
    AMa = Seq2
    AMi = Seq3
   
ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
    AD = Seq2
    AMa = Seq1
    AMi = Seq3
  
    
ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
    AD = Seq3
    AMa = Seq1
    AMi = Seq2
   
    
ElseIf StoreLPV(PRN, Seq1) >= StoreLPV(PRN, Seq2) And StoreLPV(PRN, Seq1) >= StoreLPV(PRN, Seq3) Then
    AD = Seq1
    AMa = Seq2
    AMi = Seq3
ElseIf StoreLPV(PRN, Seq2) >= StoreLPV(PRN, Seq1) And StoreLPV(PRN, Seq2) >= StoreLPV(PRN, Seq3) Then
    AD = Seq2
    AMa = Seq1
    AMi = Seq3
ElseIf StoreLPV(PRN, Seq3) >= StoreLPV(PRN, Seq1) And StoreLPV(PRN, Seq3) >= StoreLPV(PRN, Seq2) Then
    AD = Seq3
    AMa = Seq1
    AMi = Seq2
End If
'Keep track of signal numbers
oRecombNo(100) = oRecombNo(100) + 1
oRecombNo(PRN) = oRecombNo(PRN) + 1
If APermFlag = 0 Then
    Call UpdateXOList3(AD, CurrentXOver(), XoverList(), PRN, ProbabilityXOver, SIP)
Else
    SIP = 1
End If
                                        
                                            
If MCFlag = 2 Then
    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
    End If
End If

'if p high eough then add it to list, if not discard then repeat from Z to en.
ActualFound = 1
NewOneFound = 1
If SIP > 0 Then

'    If Seq2 = 258 Or Seq3 = 258 Then
'        x = x
'    End If

    Call CentreBP(0, 0, Seq1, Seq2, Seq3, BTarget, ETarget, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
    If AD > UBound(XoverList, 1) Then Exit Sub
    
    XoverList(AD, SIP).Beginning = BTarget '635-1165 (103,2),635-1165(111,1)
    XoverList(AD, SIP).Ending = ETarget
    
    XoverList(AD, SIP).MajorP = AMa
    XoverList(AD, SIP).MinorP = AMi
    XoverList(AD, SIP).Daughter = AD
    XoverList(AD, SIP).ProgramFlag = PRN
    XoverList(AD, SIP).Probability = ProbabilityXOver
    
    
    If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
         StartPlt(PRN) = 1
         Call UpdatePlotB(AD, AMa, AMi, SIP)
    
    End If
    'Make a reminder that one of the berakpoints went undetected
    If SEventNumber > 0 Then
        If EWarn = 0 Then Call CheckEndsVB(0, 0, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BTarget, ETarget, SeqNum(), XPosDiff(), XDiffPos())
        If BWarn = 0 Then Call CheckEndsVB(0, 0, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BTarget, ETarget, SeqNum(), XPosDiff(), XDiffPos())
    End If
    If BWarn = 1 And EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 3
    ElseIf BWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 1
    ElseIf EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 2
    End If

    
    
ElseIf DoneRedo = 0 Then
    DoneRedo = 1
    Call AddToRedoList(PRN, Seq1, Seq2, Seq3)
    x = x
End If



End Sub
Public Sub ProcessEvent2(ElementX As Long, PRN, ProbabilityXOver As Double, BTarget As Long, ETarget As Long, XPosDiff() As Long, XDiffPos() As Long, BWarn, EWarn, XoverWindow, LenXoverSeq)

Dim DoneRedo As Long, SIP As Long, AD As Long, AMi As Long, AMa As Long

'AD = Daughter
If CurrentXOver(Seq1) < CurrentXOver(Seq2) And CurrentXOver(Seq1) < CurrentXOver(Seq3) Then
    AD = Seq1
    AMa = Seq2
    AMi = Seq3
   
ElseIf CurrentXOver(Seq2) < CurrentXOver(Seq1) And CurrentXOver(Seq2) < CurrentXOver(Seq3) Then
    AD = Seq2
    AMa = Seq1
    AMi = Seq3
  
    
ElseIf CurrentXOver(Seq3) < CurrentXOver(Seq1) And CurrentXOver(Seq3) < CurrentXOver(Seq2) Then
    AD = Seq3
    AMa = Seq1
    AMi = Seq2
ElseIf StoreLPV(PRN, Seq1) >= StoreLPV(PRN, Seq2) And StoreLPV(PRN, Seq1) >= StoreLPV(PRN, Seq3) Then
    AD = Seq1
    AMa = Seq2
    AMi = Seq3
ElseIf StoreLPV(PRN, Seq2) >= StoreLPV(PRN, Seq1) And StoreLPV(PRN, Seq2) >= StoreLPV(PRN, Seq3) Then
    AD = Seq2
    AMa = Seq1
    AMi = Seq3
ElseIf StoreLPV(PRN, Seq3) >= StoreLPV(PRN, Seq1) And StoreLPV(PRN, Seq3) >= StoreLPV(PRN, Seq2) Then
    AD = Seq3
    AMa = Seq1
    AMi = Seq2
End If
'Keep track of signal numbers
oRecombNo(100) = oRecombNo(100) + 1
oRecombNo(PRN) = oRecombNo(PRN) + 1
If APermFlag = 0 Then
    Call UpdateXOList3(AD, CurrentXOver(), XoverList(), PRN, ProbabilityXOver, SIP)
Else
    SIP = 1
End If
                                        
                                            
If MCFlag = 2 Then
    If -Log10(ProbabilityXOver) * 2 > 0 And -Log10(ProbabilityXOver) * 2 < 100 Then
        PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) = PValCat(CurrentCorrect, CInt(-Log10(ProbabilityXOver) * 2)) + 1
    ElseIf CInt(-Log10(ProbabilityXOver) * 2) >= 100 Then
        PValCat(CurrentCorrect, 100) = PValCat(CurrentCorrect, 100) + 1
    End If
End If

'if p high eough then add it to list, if not discard then repeat from Z to en.
NewOneFound = 1
ActualFound = 1
If SIP > 0 Then
    Call CentreBP2(ElementX, 0, 0, Seq1, Seq2, Seq3, BTarget, ETarget, XPosDiff(), XDiffPos(), BWarn, EWarn, XoverWindow, LenXoverSeq)
    If AD > UBound(XoverList, 1) Then Exit Sub
    
    XoverList(AD, SIP).Beginning = BTarget
    XoverList(AD, SIP).Ending = ETarget
    
    XoverList(AD, SIP).MajorP = AMa
    XoverList(AD, SIP).MinorP = AMi
    XoverList(AD, SIP).Daughter = AD
    XoverList(AD, SIP).ProgramFlag = PRN
    XoverList(AD, SIP).Probability = ProbabilityXOver
    
    
    If SEventNumber = 0 And ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
         StartPlt(PRN) = 1
         Call UpdatePlotB(AD, AMa, AMi, SIP)
    
    End If
    'Make a reminder that one of the berakpoints went undetected
    If SEventNumber > 0 Then
        If EWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, XoverWindow, EWarn, LenXoverSeq, 1, CircularFlag, Seq1, Seq2, Seq3, BTarget, ETarget, SeqNum(), XPosDiff(), XDiffPos())
        If BWarn = 0 Then Call CheckEndsVB2(ElementX, 0, 0, XoverWindow, BWarn, LenXoverSeq, 0, CircularFlag, Seq1, Seq2, Seq3, BTarget, ETarget, SeqNum(), XPosDiff(), XDiffPos())
    End If
    If BWarn = 1 And EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 3
    ElseIf BWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 1
    ElseIf EWarn = 1 Then
        XoverList(AD, SIP).SBPFlag = 2
    End If

    
    
ElseIf DoneRedo = 0 Then
    DoneRedo = 1
    Call AddToRedoList(PRN, Seq1, Seq2, Seq3)
    x = x
End If



End Sub
Public Sub GetFromFile(PValCon, AddNumX, SNNextNo, FN, x, Y, XoverList() As XOverDefine)
Dim TS As String
If DebuggingFlag < 2 Then On Error Resume Next
Call GetTS(FN, TS)
XoverList(x, Y).Daughter = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).MajorP = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).MinorP = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).Beginning = CLng(TS)
XoverList(x, Y).Beginning = Recompress(XoverList(x, Y).Beginning)
Call GetTS(FN, TS)
XoverList(x, Y).Ending = CLng(TS)
XoverList(x, Y).Ending = Recompress(XoverList(x, Y).Ending)
Call GetTS(FN, TS)
'XOverlist(X, Y).Probability = val(TS)
XoverList(x, Y).Probability = CDbl(val(TS))
Call GetTS(FN, TS)
XoverList(x, Y).OutsideFlag = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).MissIdentifyFlag = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).PermPVal = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).ProgramFlag = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).LHolder = CLng(TS)
Call GetTS(FN, TS)
'XOverlist(X, Y).DHolder = val(TS)
XoverList(x, Y).DHolder = CDbl(val(TS))
Call GetTS(FN, TS)
'XOverlist(X, Y).BeginP = val(TS)
XoverList(x, Y).BeginP = CLng(val(TS))
Call GetTS(FN, TS)
'XOverlist(X, Y).EndP = val(TS)
XoverList(x, Y).EndP = CLng(val(TS))
Call GetTS(FN, TS)
XoverList(x, Y).SBPFlag = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).Accept = CLng(TS)
Call GetTS(FN, TS)
XoverList(x, Y).Eventnumber = CLng(TS)
                
If XoverList(x, Y).ProgramFlag >= AddNumX Then XoverList(x, Y).Accept = 2
XoverList(x, Y).MajorP = XoverList(x, Y).MajorP + SNNextNo
XoverList(x, Y).MinorP = XoverList(x, Y).MinorP + SNNextNo
XoverList(x, Y).Daughter = XoverList(x, Y).Daughter + SNNextNo
XoverList(x, Y).Probability = XoverList(x, Y).Probability * PValCon
If XoverList(x, Y).DHolder >= 0 Then
    XoverList(x, Y).DHolder = XoverList(x, Y).DHolder + SNNextNo
Else
    XoverList(x, Y).DHolder = (Abs(XoverList(x, Y).DHolder) + SNNextNo) * -1
End If
If XoverList(x, Y).ProgramFlag >= AddNumX Then
    XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag - AddNumX + AddNum
End If
On Error GoTo 0

End Sub

Public Sub GetFromFile2(PValCon, AddNumX, SNNextNo, FN, x, Y, XoverList() As XOverDefine)
Dim TS As String
If DebuggingFlag < 2 Then On Error Resume Next


Input #1, XoverList(x, Y).Daughter, XoverList(x, Y).MajorP, XoverList(x, Y).MinorP, Decompress(XoverList(x, Y).Beginning), Decompress(XoverList(x, Y).Ending), XoverList(x, Y).Probability, XoverList(x, Y).OutsideFlag, XoverList(x, Y).MissIdentifyFlag, XoverList(x, Y).PermPVal, XoverList(x, Y).ProgramFlag, XoverList(x, Y).LHolder, XoverList(x, Y).DHolder, XoverList(x, Y).BeginP, XoverList(x, Y).EndP, XoverList(x, Y).SBPFlag, XoverList(x, Y).Accept, XoverList(x, Y).Eventnumber


                
If XoverList(x, Y).ProgramFlag >= AddNumX Then XoverList(x, Y).Accept = 2
XoverList(x, Y).MajorP = XoverList(x, Y).MajorP + SNNextNo
XoverList(x, Y).MinorP = XoverList(x, Y).MinorP + SNNextNo
XoverList(x, Y).Daughter = XoverList(x, Y).Daughter + SNNextNo
XoverList(x, Y).Probability = XoverList(x, Y).Probability * PValCon
If XoverList(x, Y).DHolder >= 0 Then
    XoverList(x, Y).DHolder = XoverList(x, Y).DHolder + SNNextNo
Else
    XoverList(x, Y).DHolder = (Abs(XoverList(x, Y).DHolder) + SNNextNo) * -1
End If
If XoverList(x, Y).ProgramFlag >= AddNumX Then
    XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag - AddNumX + AddNum
End If
On Error GoTo 0
End Sub

Public Sub GetTS(FN, TS As String)

TS = ""
'Input #FN, TS
'If TS <> "" Then Exit Sub
'If DebuggingFlag < 2 Then On Error Resume Next
Do While Not EOF(FN)
    Input #FN, TS
    If TS <> "" Then Exit Sub
Loop
On Error GoTo 0
End Sub


Public Sub DrawLRDMat()

Form1.Picture26.ScaleMode = 3
Form1.Picture26.AutoRedraw = True
CurMatrixFlag = 11
Form1.Check1.Enabled = False
DoneMatX(11) = 1
MatFlag = 11
MaxN = MatBound(MatFlag)
RSize = UBound(MatrixL, 1) - 1

Dim PosS(1) As Single, PosE(1) As Single, DistD As Long

XAddj = (Form1.Picture26.ScaleHeight) / RSize
DistD = RSize / MatZoom(MatFlag)

PosS(0) = MatCoord(MatFlag, 0)
PosE(0) = PosS(0) + DistD
PosS(1) = MatCoord(MatFlag, 1)
PosE(1) = PosS(1) + DistD

Dim Limit As Long
Limit = RSize + 1

    
If PosE(1) > (Limit - 1) - 1 Then PosE(1) = (Limit - 1) - 1
If PosE(0) > (Limit - 1) - 1 Then PosE(0) = (Limit - 1) - 1
       
If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
        

Form1.Picture26.Picture = LoadPicture()
Form1.Picture26.ScaleMode = 3

DistD = RSize / MatZoom(MatFlag)
XAddj = (Form1.Picture26.ScaleHeight) / DistD
     

Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixL(), HeatMap(), CurScale, MaxN)

If DontDoKey = 0 Then
    Call DoKey(1, MaxN, 0, MatFlag, "Log Likelihood Ratio", CurScale)
End If

BPos = XoverList(RelX, RelY).Beginning
Epos = XoverList(RelX, RelY).Ending


'BPCoord(0) = ((BPos - LRDStep / 2) / Len(StrainSeq(0))) * RSize
'BPCoord(1) = ((EPos + LRDStep / 2) / Len(StrainSeq(0))) * RSize
BPCoord(0) = ((BPos) / Len(StrainSeq(0))) * RSize
BPCoord(1) = ((Epos) / Len(StrainSeq(0))) * RSize

FirstPass = 1
Call DoSpot(11)
Form1.Picture26.Refresh
Form1.Picture17.Refresh
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
Form1.Picture26.AutoRedraw = tr
End Sub


Public Sub DoEnds(SPF)
Dim RL As Long, LS As Long, BPos As Long, Epos As Long
    If XoverList(RelX, RelY).ProgramFlag = 1 Then
            x = x
        End If
    If XoverList(RelX, RelY).ProgramFlag = 0 Then
        RL = XoverWindow
        
    ElseIf XoverList(RelX, RelY).ProgramFlag = 1 Then
        RL = 10
    ElseIf XoverList(RelX, RelY).ProgramFlag = 2 Then
        RL = 10
    ElseIf XoverList(RelX, RelY).ProgramFlag = 3 Then
        RL = MCWinSize / 2
    ElseIf XoverList(RelX, RelY).ProgramFlag = 4 Then
        RL = CWinSize / 2
    ElseIf XoverList(RelX, RelY).ProgramFlag = 5 Then
        RL = 10
    ElseIf XoverList(RelX, RelY).ProgramFlag = 8 Then
        RL = 10
    End If
    RL = 10
    LS = LenXoverSeq
    BPos = XoverList(RelX, RelY).Beginning
    Epos = XoverList(RelX, RelY).Ending
    If SPF = 0 Or SPF = 2 Then
        Warn = 0
        Call CheckEndsVB(0, 0, RL, Warn, LS, 0, CircularFlag, Seq1, Seq2, Seq3, BPos, Epos, SeqNum(), XPosDiff(), XDiffPos())
        
        If Warn = 1 Then
            If XoverList(RelX, RelY).SBPFlag = 0 Then
                XoverList(RelX, RelY).SBPFlag = 1
            ElseIf XoverList(RelX, RelY).SBPFlag = 2 Then
                XoverList(RelX, RelY).SBPFlag = 3
            End If
        Else
            If XoverList(RelX, RelY).SBPFlag = 1 Then
                XoverList(RelX, RelY).SBPFlag = 0
            ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
                XoverList(RelX, RelY).SBPFlag = 2
            End If
        End If
    End If
    If SPF = 1 Or SPF = 2 Then
        
        Warn = 0
        Call CheckEndsVB(0, 0, RL, Warn, LS, 1, CircularFlag, Seq1, Seq2, Seq3, BPos, Epos, SeqNum(), XPosDiff(), XDiffPos())
    
        If Warn = 1 Then
            If XoverList(RelX, RelY).SBPFlag = 0 Then
                XoverList(RelX, RelY).SBPFlag = 2
            ElseIf XoverList(RelX, RelY).SBPFlag = 1 Then
                XoverList(RelX, RelY).SBPFlag = 3
            End If
        Else
            If XoverList(RelX, RelY).SBPFlag = 2 Then
                XoverList(RelX, RelY).SBPFlag = 0
            ElseIf XoverList(RelX, RelY).SBPFlag = 3 Then
                XoverList(RelX, RelY).SBPFlag = 1
            End If
        End If
    End If
End Sub
Public Sub MCXoverK(SPF)



Dim RescaleFlag As Byte, TWin As Long, x As Long, LO As Long, RO As Long, n As Long, b As Long, D As Long, Spos As Long, Epos As Long, step As Long, LSeq As Long, Last As Long, NumSites As Long, NumPairs As Long, WindowWidth As Long, NumBreakpoints As Long
Dim lPrb As Double, mPrb As Double, MChi As Double, oMCWinSize As Long, oMCWinfract As Double
RescaleFlag = 0
MatFlag = 8


LenXoverSeq = 0

SS = Abs(GetTickCount)
If SPF = 1 Then
    Form1.ProgressBar1 = 5
    Call UpdateF2Prog
End If
If DoneMatX(8) = 0 Then
    ReDim XDiffPos(Len(StrainSeq(0)) + 200)
    ReDim XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim VarsitesMC(Len(StrainSeq(0)) + 200)
    LenXoverSeq = FindSubSeqC(Len(StrainSeq(0)) + 1, NextNo, Seq1, Seq2, Seq3, SeqNum(0, 0), VarsitesMC(0), XPosDiff(0))
    
    If LenXoverSeq > 2000 Then ' subsample
        Dim PropSites As Single, PropStep As Long
        PropSites = 2000 / LenXoverSeq
        PropStep = 1 / PropSites
        Dim tVarsitesMC() As Long, tXPosdiff() As Long, VarCount As Long
        ReDim tVarsitesMC(LenXoverSeq + 200), tXPosdiff(LenXoverSeq + 200)
        VarCount = 0
        For x = 0 To LenXoverSeq Step PropStep
            tVarsitesMC(VarCount) = VarsitesMC(x)
            tXPosdiff(VarCount) = XPosDiff(x)
            VarCount = VarCount + 1
        Next x
        LenXoverSeq = VarCount
        ReDim XPosDiff(Len(StrainSeq(0)) + 200)
        ReDim VarsitesMC(Len(StrainSeq(0)) + 200)
        For x = 0 To LenXoverSeq
            VarsitesMC(x) = tVarsitesMC(x)
            XPosDiff(x) = tXPosdiff(x)
            
        Next x
    End If
    DoneMatX(8) = 1
    Form1.SSPanel1.Caption = "Drawing MaxChi breakpoint matrix"
    ReDim MatrixMC(LenXoverSeq + 1, LenXoverSeq + 1)
    If LenXoverSeq < 2 Then Exit Sub
        
    ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
    ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2)
    
    Dim CurMChi As Double
    
    
    'ReDim LenFrag(LenXOverSeq, LenXOverSeq)
    'ReDim WinScores(LenXOverSeq + 1, LenXOverSeq + 1, 2, 1)
    
    HWindowWidth = 1
    Dummy = WinScoreCalc(CriticalDiff, HWindowWidth, LenXoverSeq, Len(StrainSeq(0)) + 1, Seq1, Seq2, Seq3, Scores(0, 0), VarsitesMC(0), SeqNum(0, 0), Winscores(0, 0))
    Dim A(2) As Single, C(2) As Single, CntX As Long, TargetCntX As Long
    If x = x Then
        Dummy = MakeMatrixMC(Len(StrainSeq(0)), LenXoverSeq, A(0), C(0), Scores(0, 0), MatrixMC(0, 0))
    Else
    
    
        CntX = 0: TargetCntX = LenXoverSeq * (LenXoverSeq - 1) / 2
        EEE = 0
        For x = 1 To LenXoverSeq - 3
            For Y = x + 3 To LenXoverSeq
                CntX = CntX + 1
                If Y = x + 3 Then
                   CurMChi = 0
                   For Z = 0 To 2
                       A(Z) = 0
                       C(Z) = 0
                       For P = 1 To x
                           A(Z) = A(Z) + Scores(P, Z)
                       Next P
                       For P = x + 1 To Y
                           C(Z) = C(Z) + Scores(P, Z)
                       Next P
                       For P = Y + 1 To LenXoverSeq
                           A(Z) = A(Z) + Scores(P, Z)
                       Next P
                       b = (LenXoverSeq - (Y - x)) - A(Z)
                        D = (Y - x) - (Z)
                       thMChi = CalcChiV(A(Z), b, C(Z), D)
                       
                       If thMChi > CurMChi Then CurMChi = thMChi
                   Next Z
                Else
                    CurMChi = 0
                    For Z = 0 To 2
                        A(Z) = A(Z) - Scores(Y, Z) '96
                        C(Z) = C(Z) + Scores(Y, Z) '0
                        b = (LenXoverSeq - (Y - x)) - A(Z) '757
                        D = (Y - x) - C(Z) '3
                        thMChi = CalcChiV(A(Z), b, C(Z), D)
                        If thMChi > CurMChi Then CurMChi = thMChi
                    Next Z
                End If
                
                MatrixMC(x, Y) = -Log10(ChiPVal(CurMChi))
                MatrixMC(Y, x) = MatrixMC(x, Y)
            Next Y
            SSS = Abs(GetTickCount)
            If Abs(SSS - EEE) > 500 Then
                EEE = SSS
                Form1.ProgressBar1.Value = (CntX / TargetCntX) * 100
                Call UpdateF2Prog
            End If
        Next x
    End If
    
    MaxN = FindMaxNS(LenXoverSeq, MatrixMC(0, 0))
    'For X = 1 To LenXOverSeq
    '    For Y = X + 1 To LenXOverSeq
    '        If MatrixMC(X, Y) > MaxN Then MaxN = MatrixMC(X, Y)
    '    Next Y
    'Next X
    MatBound(8) = MaxN
Else
    MatFlag = 8
    MaxN = MatBound(MatFlag)
    LenXoverSeq = UBound(MatrixMC, 1) - 1
End If

If SPF = 1 Then
    Form1.ProgressBar1 = 10
    Call UpdateF2Prog
End If

RSize = LenXoverSeq
Dim PosS(1) As Single, PosE(1) As Single, DistD As Long
XAddj = (Form1.Picture26.ScaleHeight) / RSize
DistD = RSize / MatZoom(MatFlag)
PosS(0) = MatCoord(MatFlag, 0)
PosE(0) = PosS(0) + DistD
PosS(1) = MatCoord(MatFlag, 1)
PosE(1) = PosS(1) + DistD
Dim Limit As Long
Limit = UBound(MatrixMC, 1)


'convert matrixmc back to real coords

x = x

Dim ConvMatrix() As Single, XAdj2 As Double, CXLen As Double, BiggestVal As Double, JumpNo As Long
CXLen = LenXoverSeq
'If cxlen < LenXoverSeq Then cxlen = LenXoverSeq

ReDim ConvMatrix(CXLen, CXLen)
XAdj2 = Len(StrainSeq(0)) / CXLen
JumpNo = Int(XAdj2)
If JumpNo = 0 Then JumpNo = 1

If RescaleFlag = 1 Then
    SS = Abs(GetTickCount)
    For x = 0 To Len(StrainSeq(0)) Step JumpNo
        M = CInt(x / XAdj2)
        O = XPosDiff(x)
        For Y = 0 To Len(StrainSeq(0)) Step JumpNo
            
            n = CInt(Y / XAdj2)
            P = XPosDiff(Y)
            If ConvMatrix(M, n) < MatrixMC(O, P) Then
               ConvMatrix(M, n) = MatrixMC(O, P)
            End If
        Next Y
    Next x
    EE = Abs(GetTickCount)
    TT = EE - SS '47.125, 33.453, 1.250
    x = x
End If



If PosE(1) > (Limit - 1) - 1 Then PosE(1) = (Limit - 1) - 1
If PosE(0) > (Limit - 1) - 1 Then PosE(0) = (Limit - 1) - 1
       
If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
        

Form1.Picture26.Picture = LoadPicture()
Form1.Picture26.ScaleMode = 3
DistD = RSize / MatZoom(MatFlag)
XAddj = (Form1.Picture26.ScaleHeight) / DistD
 XX = Form1.Picture26.Top
SS = Abs(GetTickCount)

'For X = 1 To 20
Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixMC(), HeatMap(), CurScale, MaxN)
'Next X
EE = Abs(GetTickCount)
TT = EE - SS '687,703,687'500,500
'391,375, 407, 172, 156 VC15
'62 with parallelization

If SPF = 1 Then
    Form1.ProgressBar1 = 95
    Call UpdateF2Prog
End If

If DontDoKey = 0 Then
    Call DoKey(1, MaxN, 0, MatFlag, "-Log(Chi P-Val)", CurScale)
End If



BPos = XoverList(RelX, RelY).Beginning
Epos = XoverList(RelX, RelY).Ending


For x = 1 To LenXoverSeq - 1
    If (VarsitesMC(x) <= BPos And VarsitesMC(x + 1) >= BPos) Or (BPos = 1 And x = 1) Then
        BPCoord(0) = x
    End If
    If (VarsitesMC(x) <= Epos And VarsitesMC(x + 1) >= Epos) Or (x = LenXoverSeq - 1 And Epos = Len(StrainSeq(0))) Then
        BPCoord(1) = x
    End If
    x = x
Next x
If SPF = 1 Then
    Form1.ProgressBar1 = 100
    Call UpdateF2Prog
End If
FirstPass = 1
Call DoSpot(8)


If RescaleFlag = 1 Then
    Form2.Picture1.Width = Form1.Picture26.Width
    Form2.Picture1.Height = Form1.Picture26.Height
    Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, ConvMatrix(), HeatMap(), CurScale, MaxN)
End If




Form1.Picture26.Refresh
Form1.Picture17.Refresh
Form1.ProgressBar1.Value = 0
Form1.Picture26.AutoRedraw = True
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
End Sub

Public Sub DoSpot(CurMatrixFlag)

If CurMatrixFlag = 8 Then
    RSize = UBound(MatrixMC, 1) - 1
ElseIf CurMatrixFlag = 11 Then
    
    UB = -1
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = UBound(MatrixL, 1)
   
    On Error GoTo 0
     If UB = -1 Then
        Exit Sub
    End If
    RSize = UBound(MatrixL, 1) - 1
'ElseIf CurMatrixFlag = 12 Then
'    RSize = UBound(MatrixSH, 2) - 1
End If
Dim lTimerVal As Long
    If FirstPass = 1 Then TimerVal = 0
           If TimerVal > 0 Then
            lTimerVal = TimerVal - 40
           Else
            lTimerVal = 480
           End If
           DistD = RSize / MatZoom(CurMatrixFlag)
            ''PosS(0) = MatCoord(MatFlag, 0)
            'PosE(0) = PosS(0) + DistD
            'PosS(1) = MatCoord(MatFlag, 1)
            'PosE(1) = PosS(1) + DistD
            'XX = MatCoord(CurMatrixFlag, 0)
            XPicAddjust2 = (Form1.Picture26.ScaleHeight) / DistD
           Form1.Picture26.DrawMode = 7
           Dim Portion As Long, lPortion As Long
           Portion = 255 - 255 * (TimerVal ^ 0.5 / 520 ^ 0.5)
           lPortion = 255 - 255 * (lTimerVal ^ 0.5 / 520 ^ 0.5)
           'XPicAddjust2 = Picture26.ScaleHeight / UBound(MatrixMC, 1)
           Form1.Picture26.AutoRedraw = True
           'If CurMatrixFlag = 8 Then
               xcoord = (BPCoord(0) - MatCoord(CurMatrixFlag, 0) - 0.5) * XPicAddjust2
               ycoord = (BPCoord(1) - MatCoord(CurMatrixFlag, 1) - 0.5) * XPicAddjust2
            'ElseIf CurMatrixFlag = 11 Then
             '   xcoord = ((BPCoord(0) / Len(StrainSeq(0)) * RSize) - MatCoord(CurMatrixFlag, 0)) * XPicAddjust2
             '   ycoord = ((BPCoord(1) / Len(StrainSeq(0)) * RSize) - MatCoord(CurMatrixFlag, 1)) * XPicAddjust2
            'End If
           'Picture26.Refresh
           
           
           Form1.Picture26.DrawWidth = (Int(lTimerVal / 100) + 1)
           If FirstPass = 0 Then
            
                Form1.Picture26.Circle (xcoord, ycoord), lTimerVal / 40, RGB(lPortion, lPortion, lPortion)
                xcoord = (BPCoord(1) - MatCoord(CurMatrixFlag, 0) - 0.5) * XPicAddjust2
                ycoord = (BPCoord(0) - MatCoord(CurMatrixFlag, 1) - 0.5) * XPicAddjust2
                Form1.Picture26.Circle (xcoord, ycoord), lTimerVal / 40, RGB(lPortion, lPortion, lPortion)
            Else
                FirstPass = 0
                
           End If
           Form1.Picture26.DrawWidth = (Int(TimerVal / 100) + 1)
           xcoord = (BPCoord(0) - MatCoord(CurMatrixFlag, 0) - 0.5) * XPicAddjust2
           ycoord = (BPCoord(1) - MatCoord(CurMatrixFlag, 1) - 0.5) * XPicAddjust2
           Form1.Picture26.Circle (xcoord, ycoord), TimerVal / 40, RGB(Portion, Portion, Portion)
           xcoord = (BPCoord(1) - MatCoord(CurMatrixFlag, 0) - 0.5) * XPicAddjust2
           ycoord = (BPCoord(0) - MatCoord(CurMatrixFlag, 1) - 0.5) * XPicAddjust2
           Form1.Picture26.Circle (xcoord, ycoord), TimerVal / 40, RGB(Portion, Portion, Portion)
           'Form1.Picture26.AutoRedraw = True
           If Portion < 200 Then
                x = x
            End If
           Form1.Picture26.DrawWidth = 1
            Form1.Picture26.DrawMode = 13
End Sub
Public Sub TXover3()
    SS = Abs(GetTickCount)
    AbortFlag = 0
    Dim TotMat2() As Single, PosCount As Long, CurrentPos As Long, x As Long, Y As Long
    Dim Z As Long, b As Long, A As Long, OWinLen As Long, OStepSize As Long, MoveOver As Long
    Dim AF As Double, CF As Double, GF As Double, TF As Double, SumFirstDiff As Double, MeanFirstDiff As Double
    Dim oDir As String, BootName As String, Header As String, GetStringA As String, GetStringB As String
    Dim Boots() As String
    Dim SumVal As Double
    Dim DSS() As Double
    Dim FirstDiff() As Double
    Dim PlotPos As Long
    Dim Pict As Long
    Dim XFactor As Double, YScaleFactor As Double, PicHeight As Double
    Dim PntAPI As POINTAPI
    Dim LSeqs As Long
    Dim LTree As Long, STartT As Long, NumWins As Long, FF As Integer
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqnum() As Integer
  
    Dim PTOMat() As Double
'TOPower = 0
    LSeqs = Len(StrainSeq(0))
    Dim oPointer As Long
    oPointer = Screen.MousePointer
    If Screen.MousePointer <> 11 Then
        Screen.MousePointer = 11
    End If
    Form1.Picture8.Enabled = False
    'Form1.SSPanel8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    Form1.SSPanel2.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the 3SEQ scan"
    Form1.Picture7.Enabled = False
    TOPFlag = 0

    Dim TOSSFlag As Integer

    TOSSFlag = 0

    Dim TOXOSeq() As String

    ReDim TOXOSeq(NextNo)
    
    
    Dim TOXDiffPos() As Long, TOXPosDiff() As Long
    
    
    'Set up copies of sequences
    ReDim TOXDiffPos(LSeqs + 200)
    ReDim TOXPosDiff(LSeqs + 200)

    If TManFlag = 8 Then 'if it is a manual scan
        ReDim RevSeq(NextNo + 1)
        ReDim TOSeq(NextNo)
        ToNumSeqs = 0

        For x = 0 To NextNo

            If Selected(x) = 1 Then
                TOSeq(ToNumSeqs) = StrainSeq(x)
                RevSeq(ToNumSeqs) = x
                ToNumSeqs = ToNumSeqs + 1
            End If

        Next 'X

        ToNumSeqs = ToNumSeqs - 1
        ToNumSeqs = ToNumSeqs
        
    Else ' If it is a checking scan
        Dim TSeq(2) As String ', X As Long
        For x = 0 To 2
            TSeq(x) = String(Len(StrainSeq(0)), " ")
        
        Next x
        
        For x = 1 To Len(StrainSeq(0))
            'If X > 2050 Then
            '    X = X
            'End If
            
            If SeqNum(x, Seq1) <> 46 And SeqNum(x, Seq2) <> 46 And SeqNum(x, Seq3) <> 46 Then
                Mid(TSeq(0), x, 1) = Chr(SeqNum(x, Seq1) - 1)
                Mid(TSeq(1), x, 1) = Chr(SeqNum(x, Seq2) - 1)
                Mid(TSeq(2), x, 1) = Chr(SeqNum(x, Seq3) - 1)
            Else
                Mid(TSeq(0), x, 1) = "-"
                Mid(TSeq(1), x, 1) = "-"
                Mid(TSeq(2), x, 1) = "-"
            End If
        Next x
        If Seq1 = Seq2 Or Seq1 = Seq3 Or Seq2 = Seq3 Then
            ToNumSeqs = NextNo
            ReDim TOSeq(ToNumSeqs + 1)

            For x = 0 To ToNumSeqs
                TOSeq(x) = StrainSeq(x)
            Next 'X

        Else
            Form1.SSPanel1.Caption = "Constructing an Outlyer Sequence"
            ToNumSeqs = 3
            ReDim TOSeq(ToNumSeqs + 1)
            TOSeq(0) = TSeq(0)
            TOSeq(1) = TSeq(1)
            TOSeq(2) = TSeq(2)
            Count = 0
            Count2 = 0
            Y = 0

            For x = 1 To LSeqs
                TOXPosDiff(x) = Y

                If SeqNum(x, Seq1) = SeqNum(x, Seq2) And SeqNum(x, Seq1) = SeqNum(x, Seq3) Then
                    
                    TOSeq(3) = TOSeq(3) + Mid$(StrainSeq(TreeTraceSeqs(1, Seq1)), x, 1)
                Else
                    OddOne = -1
                    GoodOne = -1

                    If SeqNum(x, Seq1) = 46 Or SeqNum(x, Seq2) = 46 Or SeqNum(x, Seq3) = 46 Then
                        TOSeq(3) = TOSeq(3) + "-"
                        Mid$(TOSeq(0), x, 1) = "-"
                        Mid$(TOSeq(1), x, 1) = "-"
                        Mid$(TOSeq(2), x, 1) = "-"
                    ElseIf SeqNum(x, Seq1) <> SeqNum(x, Seq2) And SeqNum(x, Seq1) <> SeqNum(x, Seq3) And SeqNum(x, Seq2) <> SeqNum(x, Seq3) Then
                        TOSeq(3) = TOSeq(3) + "-"
                        Mid$(TOSeq(0), x, 1) = "-"
                        Mid$(TOSeq(1), x, 1) = "-"
                        Mid$(TOSeq(2), x, 1) = "-"
                    Else
                        Y = Y + 1
                        TOXDiffPos(Y) = x
                        TOXPosDiff(x) = Y
                        Y = Y + 1
                        TOXDiffPos(Y) = x
                        TOXPosDiff(x) = Y

                        If SeqNum(x, Seq1) = SeqNum(x, Seq2) Then
                            Mid$(TOSeq(0), x, 1) = "C"
                            Mid$(TOSeq(1), x, 1) = "C"
                            Mid$(TOSeq(2), x, 1) = "T"
                            TOSeq(3) = TOSeq(3) + "G"
                            TOXOSeq(0) = TOXOSeq(0) + "CA"
                            TOXOSeq(1) = TOXOSeq(1) + "CA"
                            TOXOSeq(2) = TOXOSeq(2) + "TA"
                            TOXOSeq(3) = TOXOSeq(3) + "GA"
                        ElseIf SeqNum(x, Seq1) = SeqNum(x, Seq3) Then
                            Mid$(TOSeq(0), x, 1) = "C"
                            Mid$(TOSeq(2), x, 1) = "C"
                            Mid$(TOSeq(1), x, 1) = "T"
                            TOSeq(3) = TOSeq(3) + "G"
                            TOXOSeq(0) = TOXOSeq(0) + "CA"
                            TOXOSeq(2) = TOXOSeq(2) + "CA"
                            TOXOSeq(1) = TOXOSeq(1) + "TA"
                            TOXOSeq(3) = TOXOSeq(3) + "GA"
                        ElseIf SeqNum(x, Seq2) = SeqNum(x, Seq3) Then
                            Mid$(TOSeq(2), x, 1) = "C"
                            Mid$(TOSeq(1), x, 1) = "C"
                            Mid$(TOSeq(0), x, 1) = "T"
                            TOSeq(3) = TOSeq(3) + "G"
                            TOXOSeq(2) = TOXOSeq(2) + "CA"
                            TOXOSeq(1) = TOXOSeq(1) + "CA"
                            TOXOSeq(0) = TOXOSeq(0) + "TA"
                            TOXOSeq(3) = TOXOSeq(3) + "GA"
                        End If

                    End If

                End If

                If x / 100 = CLng(x / 100) Then Form1.ProgressBar1.Value = (x / LSeqs) * 100: Call UpdateF2Prog
                
            Next 'X

        End If

    End If


    ReDim TOTSeqNum(Len(TOSeq(0)), ToNumSeqs)
    Dim TSeqSpaces() As Long
    ReDim TSeqSpaces(Len(TOSeq(0)), ToNumSeqs)
    
    For x = 0 To ToNumSeqs
        Dummy = CopyString(Len(TOSeq(0)), TOTSeqNum(0, x), TOSeq(x), TSeqSpaces(0, x))
    Next x
    
    For x = 0 To Len(TOSeq(0))
        If TOTSeqNum(x, 0) = 46 Or TOTSeqNum(x, 1) = 46 Or TOTSeqNum(x, 2) = 46 Then
            TOTSeqNum(x, 0) = 46
            TOTSeqNum(x, 1) = 46
            TOTSeqNum(x, 2) = 46
            TOTSeqNum(x, 3) = 46
        End If
    Next x
    If TOSSFlag = 1 Then
        OWinLen = TOWinLen
        OStepSize = TOStepSize
        TOWinLen = 100
        TOStepSize = 10
        TOSeq(0) = TOXOSeq(0)
        TOSeq(1) = TOXOSeq(1)
        TOSeq(2) = TOXOSeq(2)
        TOSeq(3) = TOXOSeq(3)
    ElseIf CurrentCheck = 9 Then
        OWinLen = TOWinLen
        Dim BE As Long, EN As Long
        
        If RelX > 0 Or RelY > 0 Then
            BE = XoverList(RelX, RelY).Beginning
            EN = XoverList(RelX, RelY).Ending
            If BE < EN Then
                TOWinLen = EN - BE
            Else
                TOWinLen = Len(StrainSeq(0)) - BE + EN
                
            End If
            TOWinLen = TOWinLen / 2
        End If
    End If
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(Len(TOSeq(0)))
    ReDim Prod2(Len(TOSeq(0)))
    ReDim Prod3(Len(TOSeq(0)))
    ReDim Alias(Len(TOSeq(0)))
    ReDim Ally(Len(TOSeq(0)))
    ReDim Location(Len(TOSeq(0)))
    ReDim Px(ToNumSeqs, Len(TOSeq(0)))
    ReDim TTempSeq2(Len(TOSeq(0)), ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim num(1)
    ReDim WeightMod(0, Len(TOSeq(0)))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Len(TOSeq(0)))
    
    Form1.ProgressBar1.Value = 5
    Form1.SSPanel1.Caption = "Calculating Average Distance"
    Call UpdateF2Prog
    ReDim LastMatrix(ToNumSeqs, ToNumSeqs)
    ReDim Boots(ToNumSeqs + 1)
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    'TOSeq(1) = X
    'Do Batch Files
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "dnadist.bat" For Output As #1
    Print #1, "dnadist <optfiled"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Print #1, "del dnadist.bat"
    On Error GoTo 0
Close #1
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "neighbor1.bat" For Output As #1
    Print #1, "neighborrdp <optfilen1"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    
    Open "neighbor2.bat" For Output As #1
    Print #1, "neighborrdp <optfilen2"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch1.bat" For Output As #1
    Print #1, "fitch <optfilef1"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch2.bat" For Output As #1
    Print #1, "fitch <optfilef2"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch3.bat" For Output As #1
    Print #1, "fitch <optfilef3"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    Open "fitch4.bat" For Output As #1
    Print #1, "fitch <optfilef4"
    Print #1, "del outfilex"
    Print #1, "rename outfile outfilex"
    Close #1
    
    On Error GoTo 0
    

    
    'Do Optionfiles
    
    'Neighbor option file - used during DSS calculations.
    Open "optfilen1" For Output As #1
    Print #1, "j"
    Print #1, BSRndNumSeed
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Neighbor2 option file - used for parametric bootstrap
    Open "optfilen2" For Output As #1
    Print #1, "j"
    Print #1, BSRndNumSeed
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch1 option file
    Open "optfilef1" For Output As #1
    Print #1, "g"
    Print #1, "j"
    Print #1, BSRndNumSeed
    Print #1, "1"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch2 option file - used fo SS genration with "user"
    'defined tree
    Open "optfilef2" For Output As #1
    Print #1, "u"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch3 option file - used for parametric Bootstrap (LS)
    Open "optfilef3" For Output As #1
    Print #1, "g"
    Print #1, "j"
    Print #1, BSRndNumSeed
    Print #1, "3"
    Print #1, "p"
    Print #1, TOPower
    'Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch4 option file - used with NJ generated tree.
    Open "optfilef4" For Output As #1
    Print #1, "u"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Clean up files
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "outfile"
    KillFile "outfilex"
    KillFile "infile"
    KillFile "dist.mat"
    KillFile "distmatrix"
    KillFile "simtree"
    KillFile "infilebak"
    On Error GoTo 0
    Sleep (5)
    'STEP1 Work out average distances

    'MakeSubAlign NumberOfSeqs, Len(StrainSeq(0)), B, DPStep, DPWindow, TTempSeq2(0, 0), TempSeq2(0, 0)
    DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Len(TOSeq(0)), TOTSeqNum(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
    
    ReDim TotMat2(ToNumSeqs, ToNumSeqs)
    For Z = 0 To ToNumSeqs - 1
        For Y = Z + 1 To ToNumSeqs
            'If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
            TotMat2(Z, Y) = TotMat(Z, Y)
            TotMat2(Y, Z) = TotMat(Z, Y)
        Next Y
    Next Z
    
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    
    If AbortFlag = 1 Then
        OldAbort = 1
        Form1.Command25.Enabled = False
        Form1.Command25.ToolTipText = ""
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
        Form1.Picture10.Enabled = True
        Form1.Frame7.Enabled = True
        Form1.Picture23(1).Enabled = True
        Form1.SSPanel2.Enabled = True
        Form1.Picture8.Enabled = True
        Form1.Picture5.Enabled = True
        Form1.Command6(0).Enabled = True
        If DebuggingFlag < 2 Then On Error Resume Next
        Close #1
        Close #2
        On Error GoTo 0
        Erase TOTSeqNum
        If TOSSFlag = 1 Then
            TOWinLen = OWinLen
            TOStepSize = OStepSize
        ElseIf CurrentCheck = 9 Then
            TOWinLen = OWinLen
        End If
        Exit Sub
    End If

    'Exit Sub

    'Call ReadDistMatrix(TONumSeqs, "outfilex")
    ReDim PTOMat(ToNumSeqs, ToNumSeqs)
    For A = 0 To ToNumSeqs
        For b = 0 To ToNumSeqs
            LastMatrix(A, b) = TotMat(A, b)
            PTOMat(A, b) = TotMat(A, b)
        Next 'B
    Next 'A

    Call AverageMatrix(ToNumSeqs, MatAverage)

    tAV = MatAverage
    'Name "outfilex" As "distmatrix"
    Sleep (5)
    ReDim SSScore(3, LSeqs)
    '2.5 seconds
    Form1.ProgressBar1 = 18
    Call UpdateF2Prog
    'Get forward and backwards SSScores.

    Call TopalRun3(MatAverage, CurrentPos)

    If AbortFlag = 1 Then
        OldAbort = 1
        Form1.Command25.Enabled = False
        Form1.Command25.ToolTipText = ""
        'ChDir (olddir$)
        Form1.ProgressBar1.Value = 0
        Form1.SSPanel1.Caption = ""
        Call UpdateF2Prog
        'Form1.SSPanel8.Enabled = True
        Form1.Picture10.Enabled = True
        Form1.Frame7.Enabled = True
        Form1.Picture23(1).Enabled = True
        Form1.SSPanel2.Enabled = True
        Form1.Picture8.Enabled = True
        Form1.Picture5.Enabled = True
        Form1.Command29(0).Enabled = True
        Form1.Command6(0).Enabled = True
        If DebuggingFlag < 2 Then On Error Resume Next
        Close #1
        Close #2
        On Error GoTo 0
        Erase TOTSeqNum
        If TOSSFlag = 1 Then
            TOWinLen = OWinLen
            TOStepSize = OStepSize
        ElseIf CurrentCheck = 9 Then
            TOWinLen = OWinLen
        End If
        Exit Sub
    End If
    Dim TPo As Long
    Dim TSm As Long

    TSm = TOSmooth - 1
    
    '14 seconds
    'Calculate DSS and Firstdiff
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    ReDim FirstDiff(CurrentPos)
    ReDim DSS(TOPerms, CurrentPos * 3)

    For x = 0 To CurrentPos - 1

        If Abs(SSScore(0, x) - SSScore(1, x)) > Abs(SSScore(2, x) - SSScore(3, x)) Then
            DSS(0, x) = Abs(SSScore(0, x) - SSScore(1, x))
        Else
            DSS(0, x) = Abs(SSScore(2, x) - SSScore(3, x))
        End If

        If x > 0 Then
            FirstDiff(x - 1) = DSS(0, x - 1) - DSS(0, x)
            SumFirstDiff = SumFirstDiff + FirstDiff(x - 1)
        End If

    Next 'X

    MeanFirstDiff = SumFirstDiff / (CurrentPos - 1)
    SumFirstDiff = 0

    For x = 0 To PosCount - 1
        SumFirstDiff = SumFirstDiff + (FirstDiff(x) - MeanFirstDiff) * (FirstDiff(x) - MeanFirstDiff)
    Next 'X

    VarFirstDiff = SumFirstDiff / (PosCount - 2)

    For x = 0 To CurrentPos - 1
        SumFirstDiff = SumFirstDiff + (FirstDiff(x) - MeanFirstDiff) * (FirstDiff(x) - MeanFirstDiff)
    Next 'X

    VarFirstDiff = SumFirstDiff / (CurrentPos - 2)
    'Look at "choosebig" to see the calculation of lower and upperbound
    '95% and 99% CIsI may need to write these to a file
    ' 95%CI = 1.96*(sqrt(varfirstdiff))
    ' 95%CI = 2.58*(sqrt(varfirstdiff))
    'Parametric bootstrapping bit
    '4.8 seconds
    TOEndPlot = CurrentPos / 2 + 1

    If TOPerms > 0 Then 'make simtree
        Form1.ProgressBar1.Value = 2
        Form1.SSPanel1.Caption = "Drawing LS Tree"
        Call UpdateF2Prog
        'Draw the plot to show that something is happening

        If Seq1 = Seq2 Or Seq1 = Seq3 Or Seq2 = Seq3 Or CurrentCheck = 9 Then
        Else
            Form1.Picture7.Top = 0
            Form1.Picture7.ScaleMode = 3
            Form1.Picture10.BackColor = BackColours
            Form1.Picture7.BackColor = BackColours
            Form1.Picture10.ScaleMode = 3
            YScaleFactor = 0.85
            PicHeight = Form1.Picture7.Height * YScaleFactor
            XFactor = ((Form1.Picture7.Width - 40) / Decompress(LSeqs))
            
            
            SumVal = 0

            For Z = 0 To Int(TOSmooth / 2) - 1
                SumVal = SumVal + DSS(0, Z)
            Next 'Z
            ReDim SmoothDSS(0, TOEndPlot * 2)
            SmoothDSS(0, 0) = SumVal / (Int(TOSmooth / 2))
            'Exit Sub
            divnumx = (Int(TOSmooth / 2))
            For x = 1 To TOEndPlot 'CurrentPos - (TOSmooth - 1)
                If x - Int(TOSmooth / 2) >= 0 Then
                    SumVal = SumVal - DSS(0, x - Int(TOSmooth / 2)) + DSS(0, x + Int(TOSmooth / 2) - 1)
                Else
                    SumVal = SumVal + DSS(0, x + Int(TOSmooth / 2) - 1)
                    divnumx = divnumx + 1
                End If
                SmoothDSS(0, x) = SumVal / divnumx
            Next 'X
            
            
            ReDim HighestDSS(TOPerms)

            For Y = 1 To TOEndPlot
                'For X = 0 To TOPerms

                If SmoothDSS(0, Y) >= HighestDSS(0) Then
                    HighestDSS(0) = SmoothDSS(0, Y)
                    
                End If

                'Next 'X
            Next 'Y

            TOHigh = HighestDSS(0)
            Form1.Picture10.BackColor = BackColours
            Form1.Picture7.BackColor = BackColours
            Form1.Picture10.ScaleMode = 3
            Form1.Picture7.ScaleMode = 3
            If ManFlag = -1 And TManFlag = -1 And CurrentCheck <> 9 Then
            
                Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(TOHigh), 0, 1, "DSS")
            Else
                Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(TOHigh), 0, 0, "DSS")
            End If
            
            Form1.Picture7.Enabled = False
            PlotPos = Int(TOWinLen / 2)
            Form1.Picture7.DrawWidth = 3
            Form1.Picture7.ForeColor = ThreeQuaterColour
            Pict = Form1.Picture7.hdc
            
            If TOSSFlag = 0 Then
                Dummy = MoveToEx(Pict, 30 + Decompress((PlotPos)) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                'Exit Sub
                PlotPos = PlotPos + TOStepSize

                For x = 1 To TOEndPlot
                
                    Dummy = LineTo(Pict, 30 + Decompress(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, x) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                    If PlotPos > UBound(Decompress) Then Exit For
                Next 'X

            Else
                Dummy = MoveToEx(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                PlotPos = PlotPos + TOStepSize
                x = 1

                For x = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * XFactor, PicHeight - (15 + (SmoothDSS(0, x) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                    If PlotPos > UBound(Decompress) Then Exit For
                Next 'X

            End If

            Dim EXCurrentPos As Long
            If ManFlag = -1 And RunFlag >= 1 Then

                Call Highlight(0)

            End If
            EXCurrentPos = CurrentPos
            Form1.Picture7.DrawWidth = 1
            Form1.Picture7.ForeColor = RGB(0, 0, 0)
            'Exit Sub
            Pict = Form1.Picture7.hdc
            PlotPos = Int(TOWinLen / 2)
            Form1.Picture7.ForeColor = RGB(0, 0, 0)

            If TOSSFlag = 0 Then
                Dummy = MoveToEx(Pict, 30 + (Decompress(PlotPos)) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                PlotPos = PlotPos + TOStepSize

                For x = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + Decompress(PlotPos) * XFactor, PicHeight - (15 + (SmoothDSS(0, x) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                    If PlotPos > UBound(Decompress) Then Exit For
                Next 'X

            Else
                Dummy = MoveToEx(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * XFactor, PicHeight - (15 + (SmoothDSS(0, 0) / HighestDSS(0)) * (PicHeight - 35)), PntAPI)
                PlotPos = PlotPos + TOStepSize

                For x = 1 To TOEndPlot
                    Dummy = LineTo(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * XFactor, PicHeight - (15 + (SmoothDSS(0, x) / HighestDSS(0)) * (PicHeight - 35)))
                    PlotPos = PlotPos + TOStepSize
                    If PlotPos > UBound(Decompress) Then Exit For
                Next 'X

            End If

            

            Form1.Picture7.Refresh
        End If

        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "infile"
        On Error GoTo 0
        
        Open "infile" For Output As #1
    Pos = 0
            Dim TS As String
            Print #1, "  " & CStr(ToNumSeqs + 1)

            For x = 0 To ToNumSeqs
                OutString = "S0" & Trim$(CStr(x)) & String$(9 - Len(Trim$(CStr(x))), " ")

                For Y = 0 To ToNumSeqs
                    
                    If PTOMat(x, Y) = 0 Then
                        OutString = OutString & "  0.00000"
                    ElseIf PTOMat(x, Y) = 1 Then
                        OutString = OutString & "  1.00000"
                    ElseIf PTOMat(x, Y) >= 10 Then
                        TS = Left(Trim$(CStr(PTOMat(x, Y))), 7)
                        OutString = OutString & " " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    ElseIf PTOMat(x, Y) > 1 Then
                        TS = Left(Trim$(CStr(PTOMat(x, Y))), 7)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    Else
                        TS = PTOMat(x, Y) * 10000
                        
                        
                        TS = CLng(PTOMat(x, Y) * 100000)
                        If Len(TS) <= 5 Then
                            TS = "0." & String(5 - Len(TS), "0") & TS
                        End If
                        'TS = "0." & String(5 - Len(TS), "0") & TS
                        TS = Left(Trim$(TS), 7)
                        OutString = OutString & "  " & TS
                        If Len(TS) < 7 Then
                            OutString = OutString & String$((7 - Len(TS)), "0")
                        End If
                    End If
                Next 'Y
                Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Do While Pos > 0
                    Mid(OutString, Pos, 1) = "."
                    Pos = InStr(1, OutString, ",", vbBinaryCompare)
                Loop
               
                Print #1, OutString
            Next 'x

        Close #1
        
        If TOTreeType = 1 Or ToNumSeqs = 2 Then
            
           
            Pos = 0
            
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            'Do NJ tree
            ReDim ColTotals(ToNumSeqs)
            
            ReDim Treearray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 2, BSRndNumSeed, 1, ToNumSeqs + 1, TotMat2(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
            LTree = LTree + 2
            SHolder(LTree - 1) = 10
            SHolder(LTree) = 13
            f2 = FreeFile
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "intree"
            On Error GoTo 0
            Open "intree" For Binary Access Write As #f2
            Put #f2, 1, SHolder
            Close #f2
            'ShellAndClose "neighbor2.bat", 0

            If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                Form1.Command25.ToolTipText = ""
                'ChDir (olddir$)
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Call UpdateF2Prog
                'Form1.SSPanel8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.Picture23(1).Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6(0).Enabled = True
                Form1.Command29(0).Enabled = True
                If DebuggingFlag < 2 Then On Error Resume Next
                Close #1
                Close #2
                On Error GoTo 0
                Erase TOTSeqNum
                If TOSSFlag = 1 Then
                    TOWinLen = OWinLen
                    TOStepSize = OStepSize
                ElseIf CurrentCheck = 9 Then
                    TOWinLen = OWinLen
                End If
                Exit Sub
            End If
            
            
        
    
            ShellAndClose "fitch4.bat", 0

            If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                Form1.Command25.ToolTipText = ""
                'ChDir (olddir$)
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Call UpdateF2Prog
                'Form1.SSPanel8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.Picture23(1).Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command29(0).Enabled = True
                Form1.Command6(0).Enabled = True
                If DebuggingFlag < 2 Then On Error Resume Next
                Close #1
                Close #2
                On Error GoTo 0
                If TOSSFlag = 1 Then
                    TOWinLen = OWinLen
                    TOStepSize = OStepSize
                ElseIf CurrentCheck = 9 Then
                    TOWinLen = OWinLen
                End If
                Exit Sub
            End If
            Name "outtree" As "simtree"
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "outfile"
            KillFile "outtree"
            On Error GoTo 0
            ShellAndClose "fitch3.bat", 0

            If AbortFlag = 1 Then
                OldAbort = 1
                Form1.Command25.Enabled = False
                Form1.Command25.ToolTipText = ""
                'ChDir (olddir$)
                Form1.ProgressBar1.Value = 0
                Form1.SSPanel1.Caption = ""
                Call UpdateF2Prog
                'Form1.SSPanel8.Enabled = True
                Form1.Picture10.Enabled = True
                Form1.Frame7.Enabled = True
                Form1.Picture23(1).Enabled = True
                Form1.SSPanel2.Enabled = True
                Form1.Picture8.Enabled = True
                Form1.Picture5.Enabled = True
                Form1.Command6(0).Enabled = True
                Form1.Command29(0).Enabled = True
                If DebuggingFlag < 2 Then On Error Resume Next
                Close #1
                Close #2
                On Error GoTo 0
                If TOSSFlag = 1 Then
                    TOWinLen = OWinLen
                    TOStepSize = OStepSize
                ElseIf CurrentCheck = 9 Then
                    TOWinLen = OWinLen
                End If
                Exit Sub
            End If
            Name "outtree" As "simtree"
        End If

        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "distmatrix"
        On Error GoTo 0
        Name "infile" As "distmatrix"
        
        Sleep (5)
        TOPFlag = 1
        SS = Abs(GetTickCount)
        Call TopalRunPerms3(MatAverage, CurrentPos)
        EE = Abs(GetTickCount)
        TT = EE - SS '37
        '68 seconds

        If AbortFlag = 1 Then
            OldAbort = 1
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
            'ChDir (olddir$)
            Form1.ProgressBar1.Value = 0
            Form1.SSPanel1.Caption = ""
            Call UpdateF2Prog
            'Form1.SSPanel8.Enabled = True
            Form1.Picture10.Enabled = True
            Form1.Frame7.Enabled = True
            Form1.Picture23(1).Enabled = True
            Form1.SSPanel2.Enabled = True
            Form1.Picture8.Enabled = True
            Form1.Picture5.Enabled = True
            Form1.Command6(0).Enabled = True
            Form1.Command29(0).Enabled = True
            If DebuggingFlag < 2 Then On Error Resume Next
            Close #1
            Close #2
            On Error GoTo 0
            If TOSSFlag = 1 Then
                TOWinLen = OWinLen
                TOStepSize = OStepSize
            ElseIf CurrentCheck = 9 Then
                TOWinLen = OWinLen
            End If
            Exit Sub
        End If

        Form1.ProgressBar1.Value = 100
        Call UpdateF2Prog
        x = 1
        Y = 0
        ttCPos = CurrentPos
        CurrentPos = TOEndPlot 'CLng((CurrentPos / 2)) ' / TOPerms)

        Do

            If Abs(SSScore(0, MoveOver + Y) - SSScore(1, MoveOver + Y)) > Abs(SSScore(2, MoveOver + Y) - SSScore(3, MoveOver + Y)) Then
                DSS(x, Y) = Abs(SSScore(0, MoveOver + Y) - SSScore(1, MoveOver + Y))
            Else
                DSS(x, Y) = Abs(SSScore(2, MoveOver + Y) - SSScore(3, MoveOver + Y))
                'GoTo FinishAndCleanUp
            End If

            Y = Y + 1

            If Y >= CurrentPos Or Y > UBound(DSS, 2) Or Y + MoveOver > UBound(SSScore, 2) Then
                MoveOver = MoveOver + Y
                Y = 0
                x = x + 1
                'MoveOver = (X - 1) * CurrentPos

                If x > TOPerms Or Y + MoveOver > UBound(SSScore, 2) Then Exit Do
            End If

        Loop

    Else
        CurrentPos = CLng(CurrentPos / 2)
    End If

    If EXCurrentPos > 0 Then EXCurrentPos = CLng(EXCurrentPos / 2)

    If EXCurrentPos < CurrentPos Then
        ReDim SmoothDSS(TOPerms, TOEndPlot * 2)
    Else
        ReDim SmoothDSS(TOPerms, TOEndPlot * 2)
    End If

    ReDim HighestDSS(TOPerms)
    'Smooth DSS values

    Dim TCurrentPos As Long
    

    TPo = TOEndPlot '- (TOSmooth - 1)

    
    'If TOSmooth > 1 Then

    For Y = 0 To TOPerms

        If Y = 0 And EXCurrentPos > 0 Then
            TCurrentPos = CurrentPos
            CurrentPos = EXCurrentPos
        End If

        SumVal = 0

        For Z = 0 To Int(TOSmooth / 2) - 1
            SumVal = SumVal + DSS(Y, Z)
        Next 'Z
        divnumx = (Int(TOSmooth / 2))
        SmoothDSS(Y, 0) = SumVal / divnumx
        For x = 1 To TOEndPlot 'CurrentPos - (TOSmooth - 1)
            If x - Int(TOSmooth / 2) >= 0 Then
                SumVal = SumVal - DSS(Y, x - Int(TOSmooth / 2)) + DSS(Y, x + Int(TOSmooth / 2) - 1)
            Else
                SumVal = SumVal + DSS(Y, x + Int(TOSmooth / 2) - 1)
                divnumx = divnumx + 1
            End If
            SmoothDSS(Y, x) = SumVal / divnumx
        Next 'X

        If TCurrentPos > 0 Then CurrentPos = TCurrentPos
    Next 'Y

    'End If
    'For X = 0 To CurrentPos
    '    If SmoothDSS(0, X) <> DSS(0, X) Then
    '
    '    End If
    'Next 'X
    ReDim HighestDSS(TOPerms)

    For x = 0 To TOPerms

        If x = 0 And EXCurrentPos > 0 Then
            TCurrentPos = CurrentPos
            CurrentPos = EXCurrentPos
        End If

        For Y = 0 To TPo 'CurrentPos - (TOSmooth - 1)

            If SmoothDSS(x, Y) >= HighestDSS(x) Then
                HighestDSS(x) = SmoothDSS(x, Y)
            End If

        Next 'Y

        If TCurrentPos > 0 Then CurrentPos = TCurrentPos
    Next 'X

    TOHigh = HighestDSS(0)

    For x = 1 To TOPerms

        If HighestDSS(x) > TOHigh Then TOHigh = HighestDSS(x)
    Next 'X

    '(2)for every permutation take dss values and calculate
    'moving average along the sequence (with a set window length)
    'write highest average to an array(x).
    '(3) sort the set of highest values from lowest to highest.
    '(4)from actual dataset .dss values smooth the values (moving
    'average etc etc.)
    '(5) significance = proportion of simulated .dss values that are
    'higher than the calculated values. eg-pvalue cutoff =0.5 then the
    '0.05 dss cutoff = the 5th percentile of simulated .dss values
    If DebuggingFlag < 2 Then On Error Resume Next

    ChDir oDir
    ChDrive oDir
    On Error GoTo 0
    
    If TOHigh = 0 Then
        GoTo FinishAndCleanUp:
    End If
    
    Dim MaxDSS() As Double
    ReDim MaxDSS(TOPerms)
    For x = 1 To TOPerms
        For Y = 1 To TPo
            If MaxDSS(x) < SmoothDSS(x, Y) Then MaxDSS(x) = SmoothDSS(x, Y)
        Next Y
    Next x
    'sort the values
    For x = 1 To TOPerms
        Win = -1: WinP = -1
        For Y = x To TOPerms
            If MaxDSS(Y) > Win Then
                Win = MaxDSS(Y)
                WinP = Y
            End If
        Next Y
        MaxDSS(WinP) = MaxDSS(x)
        MaxDSS(x) = Win
        
    Next x
    ReDim GCritval(10)
    GCritval(2) = MaxDSS(CLng(0.01 * TOPerms + 0.5))
    GCritval(3) = MaxDSS(CLng(0.05 * TOPerms + 0.5))
    
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    If (Seq1 = Seq2 Or Seq1 = Seq3 Or Seq2 = Seq3) And ManFlag = -1 And TManFlag <> 8 Then
    Else
        Form1.Picture7.Top = 0
        Form1.Picture7.ScaleMode = 3
        Form1.Picture10.BackColor = BackColours
        Form1.Picture7.BackColor = BackColours
        Form1.Picture10.ScaleMode = 3
        XFactor = ((Form1.Picture7.Width - 40) / Decompress(LSeqs))
        YScaleFactor = 0.85
        PicHeight = Form1.Picture7.Height * YScaleFactor

        If ManFlag = -1 And TManFlag = -1 Then
                Call FindSubSeqBS
                XX = LenXoverSeq
                GYAxHi(1) = Decompress(Len(StrainSeq(0)))
                'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, TOHigh, 0, 1, "DSS")
            Else
                
                GYAxHi(1) = Decompress(Len(StrainSeq(0)))
                'Call DoAxes(0,0, Decompress(Len(StrainSeq(0))), -1, TOHigh, 0, 0, "DSS")
            End If

        
        If EXCurrentPos > 0 Then CurrentPos = EXCurrentPos
        Form1.Picture7.DrawWidth = 3
        Form1.Picture7.ForeColor = ThreeQuaterColour
        Pict = Form1.Picture7.hdc
        PlotPos = Int(TOWinLen / 2)
        If TOSSFlag = 0 Then
'            Dummy = MoveToEx(Pict, (30 + Decompress(PlotPos) * xFactor), PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
'            'Exit Sub
'            PlotPos = PlotPos + TOStepSize
'            Form1.Picture7.AutoRedraw = True
'
'            For X = 1 To TPo
'                Dummy = LineTo(Pict, 30 + Decompress(PlotPos) * xFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
'                PlotPos = PlotPos + TOStepSize
'            Next 'X

        Else
'            Dummy = MoveToEx(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * xFactor, PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
'            PlotPos = PlotPos + TOStepSize
'
'            For X = 1 To TPo
'                Dummy = LineTo(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * xFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
'                PlotPos = PlotPos + TOStepSize
'            Next 'X

        End If
        If ManFlag = -1 And RunFlag >= 1 Then

            Call Highlight(0)

        End If
        Form1.Picture7.DrawWidth = 1
        Form1.Picture7.ForeColor = RGB(0, 0, 0)

        If TCurrentPos > 0 And TCurrentPos >= CurrentPos * 2 Then
            CurrentPos = TCurrentPos / 2
        ElseIf TCurrentPos > 0 Then
            CurrentPos = TCurrentPos
        End If

        Form1.Picture7.ForeColor = ThreeQuaterColour

        Dim PFactor As Double

        If LSeqs < 32000 Then
            PFactor = XFactor
        Else
            PFactor = ((Form1.Picture7.Width - 40) / 32000)
        End If

        For Y = 1 To TOPerms
            PlotPos = Int(TOWinLen / 2)
            

            If TOSSFlag = 0 Then
                'Form1.Picture7.ForeColor = QBColor(4)
'                Pict = Form1.Picture7.hDC
'                Dummy = MoveToEx(Pict, 30 + PlotPos * PFactor, PicHeight - (15 + (SmoothDSS(Y, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
'
'                For X = 1 To TPo
'                    PlotPos = PlotPos + TOStepSize
'                    Dummy = LineTo(Pict, 30 + PlotPos * PFactor, PicHeight - (15 + (SmoothDSS(Y, X) / TOHigh) * (PicHeight - 35)))
'                Next 'X

            Else
'                Dummy = MoveToEx(Pict, 30 + TOXDiffPos(PlotPos) * PFactor, PicHeight - (15 + (SmoothDSS(Y, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
'
'                For X = 1 To TPo
'                    PlotPos = PlotPos + TOStepSize
'                    Dummy = LineTo(Pict, 30 + TOXDiffPos(PlotPos) * PFactor, PicHeight - (15 + (SmoothDSS(Y, X) / TOHigh) * (PicHeight - 35)))
'                Next

            End If

        Next
        
        'critical vals
        Form1.Picture7.DrawStyle = 2
        Form1.Picture7.ForeColor = 0
'        Dummy = MoveToEx(Pict, 30, PicHeight - (15 + (GCritval(3) / TOHigh) * (PicHeight - 35)), PntAPI)
'        Dummy = LineTo(Pict, 30 + Len(StrainSeq(0)), PicHeight - (15 + (GCritval(3) / TOHigh) * (PicHeight - 35)))
'
'        Dummy = MoveToEx(Pict, 30, PicHeight - (15 + (GCritval(2) / TOHigh) * (PicHeight - 35)), PntAPI)
'        Dummy = LineTo(Pict, 30 + Len(StrainSeq(0)), PicHeight - (15 + (GCritval(2) / TOHigh) * (PicHeight - 35)))
        Form1.Picture7.DrawStyle = 0
        PlotPos = Int(TOWinLen / 2)

        If EXCurrentPos > 0 Then CurrentPos = TCurrentPos
        Form1.Picture7.ForeColor = RGB(0, 0, 0)

        If TOSSFlag = 0 Then
'            Dummy = MoveToEx(Pict, 30 + Decompress(PlotPos) * xFactor, PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
'            PlotPos = PlotPos + TOStepSize
'
'            For X = 1 To TPo
'                Dummy = LineTo(Pict, 30 + Decompress(PlotPos) * xFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
'                PlotPos = PlotPos + TOStepSize
'            Next

        Else
'            Dummy = MoveToEx(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * xFactor, PicHeight - (15 + (SmoothDSS(0, 0) / TOHigh) * (PicHeight - 35)), PntAPI)
'            PlotPos = PlotPos + TOStepSize
'
'            For X = 1 To TPo
'                Dummy = LineTo(Pict, 30 + Decompress(TOXDiffPos(PlotPos)) * xFactor, PicHeight - (15 + (SmoothDSS(0, X) / TOHigh) * (PicHeight - 35)))
'                PlotPos = PlotPos + TOStepSize
'            Next

        End If

        'Next 'X






        

        Form1.Picture7.Refresh
    End If

        PosCount = TPo
'Get everything into the standard format for printing and saving
        NumLines = TOPerms + 1 'number of lines to print
        ReDim GPrint(NumLines - 1, PosCount + 2), GPrintCol(NumLines - 1), GPrintPos(NumLines - 1, PosCount + 2)
        If ManFlag = -1 And TManFlag = -1 Then
            ReDim GVarPos(0, LenXoverSeq)
            For x = 1 To LenXoverSeq
                GVarPos(0, x) = XDiffPos(x)
                
            Next x
        Else
            ReDim GVarPos(0, 0)
        End If
        
        
        GLegend = "DSS"
        GPrintLen = PosCount + 1 'how many points to plot
        GPrintCol(NumLines - 1) = 0 'line is black
        For x = 0 To NumLines - 2
            GPrintCol(x) = -HalfColour
        Next x
        GPrintNum = NumLines - 1 'six lines
        GPrintType = 0 'a normal line plot
        
        GPrintMin(0) = 0 'bottom val
        GPrintMin(1) = TOHigh 'upper val
        
        
        For Y = 1 To NumLines - 1
            PlotPos = Int(TOWinLen / 2)
            For x = 0 To PosCount
                
                GPrint(Y - 1, x + 2) = SmoothDSS(Y, x)
                GPrintPos(Y - 1, x + 2) = PlotPos
                PlotPos = PlotPos + TOStepSize
                
            Next x
        Next Y
        PlotPos = Int(TOWinLen / 2)
        For x = 0 To PosCount
            
            GPrint(NumLines - 1, x + 2) = SmoothDSS(0, x)
            GPrintPos(NumLines - 1, x + 2) = PlotPos
            PlotPos = PlotPos + TOStepSize
            
        Next x
        For x = 0 To NumLines - 1
            'GPrintPos(X, GPrintLen + 1) = Len(StrainSeq(0))
            'GPrint(X, GPrintLen) = (GPrint(X, GPrintLen - 1) + GPrint(X, 1)) / 2
            GPrintPos(x, 1) = 1
            GPrint(x, 1) = (GPrint(x, GPrintLen - 1) + GPrint(x, 1)) / 2
        Next x
        GExtraTNum = 1
        ReDim GExtraText(GExtraTNum)
        GExtraText(0) = "Real sequences"
        GExtraText(1) = "Sequences simulated without recombination"
        If ManFlag = -1 Then
            GExtraText(0) = GExtraText(0) & " (" + OriginalName(Seq1) + ", " + OriginalName(Seq2) + ", " + OriginalName(Seq3) + ", and a simulated outlyer)"
        Else
            GBlockNum = -1
        End If
        
Call RedrawPlotAA(1)
EE = Abs(GetTickCount)
TT = EE - SS



'46.6 -50 reps, kom, ns ,reu ,tas
'13.532
    'If TOEndPlot <= 2 Then TOEndPlot = PlotPos - TOStepSize
FinishAndCleanUp:
    Form1.ProgressBar1.Value = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog
    Form1.Combo1.Enabled = True
    'Form1.SSPanel8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
    Form1.Picture7.Enabled = True
    'Form1.Command29(0).Enabled = True
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    
    Form1.Picture21.Width = Form1.Picture7.Width + 100
Form1.Picture21.Height = Form1.Picture7.Height + 100
    Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5

    If TOSSFlag = 1 Then
        TOWinLen = OWinLen
        TOStepSize = OStepSize
    ElseIf CurrentCheck = 9 Then
        TOWinLen = OWinLen
    End If
    Erase TOTSeqNum
End Sub
Public Sub TopalRun3(MatAveragex As Double, CPos As Long)
Dim NextWrite As Long
Dim OutString As String
    Dim NumDatasets As Long, C As Long, D As Long
    Dim NewAverage As Double, MultFactorx As Double
    Dim StartPos As Long, x As Long, Y As Long, Z As Long, A As Long, b As Long
    Dim BootName As String
    Dim Getstring As String
    Dim GetStringA As String
    Dim GetStringB As String
    Dim GetStringC As String
    Dim GetStringD As String
    Dim GetStringE As String
    Dim GetStringF As String
    Dim Boots() As String
    Dim MatrixByte() As Byte
    Dim Pos As Long
    Dim MatrixLen As Long, SeqNumber As Long
    Dim Len1 As Long
    Dim LastPos As Long
    Dim ReadposA As Long
    Dim LenString As Long
     Dim LTree As Long, STartT As Long, NumWins As Long
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqnum() As Integer
    
    
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(TOWinLen)
    ReDim Prod2(TOWinLen)
    ReDim Prod3(TOWinLen)
    ReDim Alias(TOWinLen)
    ReDim Ally(TOWinLen)
    ReDim Location(TOWinLen)
    ReDim Px(ToNumSeqs, TOWinLen)
    ReDim TTempSeq2(TOWinLen, ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim num(1)
    ReDim WeightMod(0, Int(TOWinLen / 2))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Int(TOWinLen / 2))
     SeqLen = Len(StrainSeq(0))

    ReDim Boots(ToNumSeqs + 1)
    
    StartPos = 1
    CPos = 0
   
    Form1.ProgressBar1.Value = 20
    Call UpdateF2Prog
    'Now can sort out the optfiles

    

    Form1.SSPanel1.Caption = "Calculating Distances"

    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 40
    Call UpdateF2Prog
    StartPos = 1
    CPos = 0
    StartPos = 0
     Dim TempSeq2() As Integer
    ReDim TempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    Dim TS As String
    
  If TOTreeType = 1 Then
    f2 = FreeFile
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "intree"
        On Error GoTo 0
        Open "intree" For Binary Access Write As #f2
        
    End If
    FF = FreeFile
    NumDatasets = 0
    NextWrite = 1
    Open "infile" For Output As #FF
        Do While StartPos + TOWinLen < SeqLen
            
            'Do the first half of the window.
            
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 4), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            Call AverageMatrix(ToNumSeqs, NewAverage)
            
            If NewAverage > 0 Then
                MultFactorx = MatAveragex / NewAverage

                Call MatrixMultiply(ToNumSeqs, MultFactorx)

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        LastMatrix(C, D) = TotMat(C, D)
                    Next 'd

                Next 'C

            Else
                MultFactorx = 1

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        TotMat(C, D) = LastMatrix(C, D)
                    Next 'd

                Next 'C

            End If
            
            Call DistsToFile(FF, ToNumSeqs, TotMat())
            
            If TOTreeType = 1 Then
                ReDim TotMat2(ToNumSeqs, ToNumSeqs)
                For Z = 0 To ToNumSeqs - 1
                    For Y = Z + 1 To ToNumSeqs
                        'If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
                        TotMat2(Z, Y) = TotMat(Z, Y)
                        TotMat2(Y, Z) = TotMat(Z, Y)
                    Next Y
                Next Z
                
                Pos = 0
                
                'This is where the writing to file thing used to go
                ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
                'Do NJ tree
                ReDim ColTotals(ToNumSeqs)
                
                ReDim Treearray(ToNumSeqs, ToNumSeqs)
                LTree = NEIGHBOUR(1, 2, BSRndNumSeed, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                LTree = LTree + 2
                SHolder(LTree - 1) = 10
                SHolder(LTree) = 13
                Put #f2, NextWrite, SHolder
                
                NextWrite = NextWrite + LTree
                
            End If
            
            'Do second half of window
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 2) + Int(TOWinLen / 4), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            For x = 0 To TOWinLen / 2
                TOTSeqNum(x + 100, 0) = TOTSeqNum(x + 100, 0)
                TempSeq2(x, 0) = TempSeq2(x, 0)
                TempSeq2(x, 1) = TempSeq2(x, 1)
                TempSeq2(x, 2) = TempSeq2(x, 2)
                TempSeq2(x, 3) = TempSeq2(x, 3)
            Next x
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            Call AverageMatrix(ToNumSeqs, NewAverage)

            If NewAverage > 0 Then
                MultFactorx = MatAveragex / NewAverage

                Call MatrixMultiply(ToNumSeqs, MultFactorx)

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        LastMatrix(C, D) = TotMat(C, D)
                    Next 'd

                Next 'C

            Else
                MultFactorx = 1

                For C = 0 To ToNumSeqs

                    For D = 0 To ToNumSeqs
                        TotMat(C, D) = LastMatrix(C, D)
                    Next 'd

                Next 'C

            End If
            
            Call DistsToFile(FF, ToNumSeqs, TotMat())
            If TOTreeType = 1 Then
                ReDim TotMat2(ToNumSeqs, ToNumSeqs)
                For Z = 0 To ToNumSeqs - 1
                    For Y = Z + 1 To ToNumSeqs
                        'If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
                        TotMat2(Z, Y) = TotMat(Z, Y)
                        TotMat2(Y, Z) = TotMat(Z, Y)
                    Next Y
                Next Z
                
                Pos = 0
                
                'This is where the writing to file thing used to go
                ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
                'Do NJ tree
                ReDim ColTotals(ToNumSeqs)
                
                ReDim Treearray(ToNumSeqs, ToNumSeqs)
                LTree = NEIGHBOUR(1, 2, BSRndNumSeed, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
                LTree = LTree + 2
                SHolder(LTree - 1) = 10
                SHolder(LTree) = 13
                Put #f2, NextWrite, SHolder
                
                NextWrite = NextWrite + LTree
                
            End If
            CPos = CPos + 1
            StartPos = StartPos + TOStepSize
            NumDatasets = NumDatasets + 2
        Loop

    

    Close #FF
    If TOTreeType = 1 Then
        Close #f2
    End If
    StartPos = 1
    Form1.ProgressBar1.Value = 44
    '3.7 seconds
    CPos = 0
    Form1.SSPanel1.Caption = "Calculating SS Scores"
    Call UpdateF2Prog
    BB = Abs(GetTickCount)
    
    If TOPFlag = 0 Then
        
        'Fitch1 option file
        Open "optfilef1" For Output As #1
        Print #1, "g"
        Print #1, "j"
        Print #1, BSRndNumSeed
        Print #1, "1"
        Print #1, "p"
        Print #1, TOPower
        Print #1, "m"
        Print #1, NumDatasets
        Print #1, "3"
        Print #1, "2"
        Print #1, "3"
        Print #1, "y"
        Close #1
        'Fitch2 option file - used with NJ generated tree
        'and SS genration with "user" defined tree
        Open "optfilef2" For Output As #1
        Print #1, "u"
        Print #1, "p"
        Print #1, TOPower
        Print #1, "m"
        Print #1, NumDatasets
        Print #1, "3"
        Print #1, "2"
        Print #1, "3"
        Print #1, "y"
        Close #1
        Open "optfilen1" For Output As #1
        Print #1, "j"
        Print #1, BSRndNumSeed
        Print #1, "2"
        Print #1, "m"
        Print #1, NumDatasets
        'Print #1, "2"
        'Print #1, "3"
        Print #1, "3"
        Print #1, "y"
        Close #1
    End If
    
    If TOTreeType = 0 Then 'do NJ if it is either set or you're working with permutations.
       ' Do
        If x = 12345 Then
            ShellAndClose "neighbor1.bat", 0
            If AbortFlag = 1 Then
                AbortFlag = 1
                Exit Sub
            End If
            Open "treefile" For Binary Access Read As #1
    
            If LOF(1) = 0 Then
                MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component NeighborRDP.")
                AbortFlag = 1
                Close #1
                Exit Sub
            End If
        
            
            Close #1
            KillFile "intree"
            Name "treefile" As "intree"
        End If
        FileCopy "infile", "infilebak"
        
        
        'Loop
        
        If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "outfile"
            KillFile "outtree"
        On Error GoTo 0
        
        
        
        
        Open "optfilef2" For Output As #1
        Print #1, "u"
        Print #1, "p"
        Print #1, TOPower
        Print #1, "m"
        Print #1, NumDatasets
        Print #1, "3"
        Print #1, "3"
        Print #1, "2"
        Print #1, "y"
        Close #1
        
        
        
        ShellAndClose "fitch2.bat", 0
        
        If AbortFlag = 1 Then
            Exit Sub
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "infile"
        On Error GoTo 0
        Name "infilebak" As "infile"
    Else
        
        ShellAndClose "fitch1.bat", 0

        If AbortFlag = 1 Then
            Exit Sub
        End If

    End If

    Form1.ProgressBar1.Value = 78
    Call UpdateF2Prog
    '4.9 seconds (NJ)
    '2.4 seconds (LS)
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If
    
    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    'get ssscores
    ReDim SSScore(3, NumDatasets)
    Pos = 1
    CPos = 0

    Do
        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(0, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(0, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
        End If

        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(2, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(2, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
            CPos = CPos + 1
        End If

    Loop

    Form1.SSPanel1.Caption = "Recalculating SS scores"
    Open "infile" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    
    'Work out distance matrix spacing
    Pos = InStr(1, GetStringA, "S00", vbBinaryCompare)
    Form1.Refresh
    HeaderLen = Pos - 1
    LastPos = Pos
    Pos = InStr(LastPos + 1, GetStringA, "S00", vbBinaryCompare)
    Len1 = Pos - LastPos
    
    LenString = Len(GetStringA)
    Pos = 1
    LastPos = -2
    ReadposA = 1
    Open "infile" For Output As #1
    
    NumDatasets = 0
    Do While (ReadposA + Len1 * 2) - 1 <= LenString
        GetStringC = Mid$(GetStringA, ReadposA, Len1)
        ReadposA = ReadposA + Len1
        GetStringE = Mid$(GetStringA, ReadposA, Len1)
        ReadposA = ReadposA + Len1
        Pos = InStr(LastPos + 3, GetStringB, ";", vbBinaryCompare)

        
        LastPos = Pos
        Print #1, GetStringE
        
        Print #1, GetStringC
        
        NumDatasets = NumDatasets + 2
    Loop
    
    Close #1

        
    ShellAndClose "fitch2.bat", 0
    
    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 95
    Call UpdateF2Prog
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    'get ssscores
    Pos = 1
    CPos = 0

    Do
        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(1, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(1, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
        End If

        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(3, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(3, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
            CPos = CPos + 1
        End If

    Loop

    CPos = NumDatasets
    'SSScore(3, 15) = X
End Sub
Public Sub DistsToFile(FF, ToNumSeqs, TotMat() As Single)

Dim Pos As Long, Z As Long, Y As Long
Dim OutString As String, TS As String

Pos = 0
Print #FF, ""
Print #FF, "  " & CStr(ToNumSeqs + 1)
For Z = 0 To ToNumSeqs
    If Z < 10 Then
        OutString = "S0" & Trim$(CStr(Z)) & String$(9 - Len(Trim$(CStr(Z))), " ")
    Else
        OutString = "S" & Trim$(CStr(Z)) & String$(9 - Len(Trim$(CStr(Z))), " ")
    End If
    For Y = 0 To ToNumSeqs
        If TotMat(Z, Y) = 0 Then
            OutString = OutString & "  0.0000"
        ElseIf TotMat(Z, Y) = 1 Then
            OutString = OutString & "  1.0000"
        ElseIf TotMat(Z, Y) >= 10 Then
            TS = Left(Trim$(CStr(TotMat(Z, Y))), 6)
            OutString = OutString & " " & TS
            If Len(TS) < 7 Then
                OutString = OutString & String$((7 - Len(TS)), "0")
            End If
        ElseIf TotMat(Z, Y) > 1 Then
            TS = Left(Trim$(CStr(TotMat(Z, Y))), 5)
            OutString = OutString & "  " & TS
            If Len(TS) < 6 Then
                OutString = OutString & String$((6 - Len(TS)), "0")
            End If
        Else
            TS = Left(Trim$(CStr(TotMat(Z, Y))), 5)
            OutString = OutString & "  " & TS
            If Len(TS) < 6 Then
                OutString = OutString & String$((6 - Len(TS)), "0")
            End If
        End If
    Next 'Y
    Pos = InStr(1, OutString, ",", vbBinaryCompare)
    Do While Pos > 0
        Mid(OutString, Pos, 1) = "."
        Pos = InStr(1, OutString, ",", vbBinaryCompare)
    Loop
    Print #FF, OutString
Next 'z
End Sub

Public Sub TopalRunPerms3(MatAveragex As Double, CPos As Long)
    'This code will take a sequence (in TOSeq), split it into window
    'size chunks, calculate SS scores for chunks and return
    'an array containing the SS data
    
    Dim AF As Double, CF As Double, GF As Double, TF As Double, FF As Integer, FF2 As Integer
    Dim Target As String, OutString As String, Getstring As String, GetStringA As String, GetStringB As String, GetStringC As String, GetStringD As String, GetStringE As String, GetStringF As String, BootName As String, Header As String
    Dim StartPos  As Long, SeqLen As Long, NumDatasets As Long, Pos As Long, ReadposA As Long, Len1 As Long, LastPos As Long, LenString As Long, MatrixLen As Long
    Dim NewAverage As Double, MultFactorx As Double, BB As Double, EE As Double
    Dim x As Integer, Y  As Integer, Z  As Integer, A  As Integer, b As Integer
    Dim Boots() As String
    Dim MatrixByte() As Byte
    Dim LTree As Long, STartT As Long, NumWins As Long
    Dim RndNum2 As Long, RndNum As Long
    Dim NameLen As Integer, ttSeqNum() As Integer, Px() As Integer, XX1() As Integer, XX2() As Integer
    Dim WeightMod() As Long, Num1() As Long, Num2() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long
    Dim TMat2() As Single, num() As Double, DistVal() As Double, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
    Dim SHolder() As Byte
    Dim TreeOut As String
    Dim NodeOrder() As Long
    Dim NodeLen() As Double
    Dim DoneNode() As Long
    Dim TempNodeOrder() As Long
    Dim DstOut() As Integer, tSeqnum() As Integer
    
    Dim TotMat2() As Single
    
    ReDim XX1(3)
    ReDim XX2(3)
    ReDim Prod1(Int(TOWinLen / 2))
    ReDim Prod2(Int(TOWinLen / 2))
    ReDim Prod3(Int(TOWinLen / 2))
    ReDim Alias(Int(TOWinLen / 2))
    ReDim Ally(Int(TOWinLen / 2))
    ReDim Location(Int(TOWinLen / 2))
    ReDim Px(ToNumSeqs, Int(TOWinLen / 2))
    ReDim TTempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim DistVal(1)
    ReDim Num1(1)
    ReDim Num2(1)
    ReDim DEN(1)
    ReDim num(1)
    ReDim WeightMod(0, Int(TOWinLen / 2))
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    ReDim SHolder((ToNumSeqs) * 40 * 2)
    ReDim Weight(0, Int(TOWinLen / 2))
    ReDim Boots(ToNumSeqs + 1)
    SeqLen = Len(StrainSeq(0))
    Dim NextWrite As Long
    If SeqLen > 32000 Then SeqLen = 32000
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    FF = 0
    CPos = 0
    Dim TempSeq2() As Integer
    ReDim TempSeq2(Int(TOWinLen / 2), ToNumSeqs)
    ReDim TotMat(ToNumSeqs, ToNumSeqs)
    Dim TS As String
    f2 = FreeFile
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "intree"
        On Error GoTo 0
        Open "intree" For Binary Access Write As #f2
        
    NextWrite = 1
    EEE = 0
    For x = 1 To TOPerms
        SSS = Abs(GetTickCount)
        If Abs(SSS - EEE) > 500 Then
            EEE = SSS
            Form1.SSPanel1.Caption = "Simulating " & x & " of " & TOPerms & " alignments"
            Form1.ProgressBar1.Value = 10 + (x / TOPerms) * 42
            Call UpdateF2Prog
        End If
        BB = Abs(GetTickCount)
        'Generate a simulated dataset using seqgen
        If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "outfilex"
            KillFile "out"
        On Error GoTo 0
        Call MakeSeqGenBat2(x)
        
        
        ShellAndClose "seqgen.bat", 0

        If AbortFlag = 1 Then
            Exit Sub
        End If

        'Load simulated datasets into a string array (ToSeq)
        FF2 = FreeFile
        Open "outfilex" For Input As #FF2

        If LOF(FF2) = 0 Then
            MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be SEQGEN.")
            AbortFlag = 1
            Close #FF2
            Close FF
            Exit Sub
        End If

        Line Input #FF2, Header

        If Len(Header) = LOF(FF2) Then 'some systems will not simply read lines - they go for the entire file
            Close #FF2
            Target = Chr$(10)
            LastPos = 1

            Do
                Pos = InStr(LastPos, Header, Target, vbBinaryCompare)

                If Pos > 0 Then
                    Header = Left$(Header, Pos - 1) + Chr$(13) + Right$(Header, Len(Header) - (Pos - 1))
                    LastPos = Pos + 3
                Else
                    Exit Do
                End If

            Loop

            Open "outfilex" For Output As #FF2
            Print #FF2, Header
            Close #FF2
            Open "outfilex" For Input As #FF2
            Line Input #FF2, Header
        End If

        For Y = 0 To ToNumSeqs
            Header = ""

            Do Until Len(Header) > 0
                Line Input #FF2, Header
            Loop
            Z = val(Trim$(Mid$(Header, 2, 5)))
            TOSeq(Z) = Right$(Header, Len(Header) - 10)
        Next 'Y

        Close #FF2
        
        'Name "outfilex" As "outfile" & X
        'convert toseq to integer array
        
        Dim TSeqSpaces() As Long
        ReDim TSeqSpaces(Len(TOSeq(0)), ToNumSeqs)
        For Z = 0 To ToNumSeqs
            Dummy = CopyString(Len(TOSeq(0)), TOTSeqNum(0, Z), TOSeq(Z), TSeqSpaces(0, Z))
        Next 'Z
        
        'Do the windows

        If FF = 0 Then
            FF = FreeFile
            Open "infile" For Output As #FF
        End If

        StartPos = 1
        
        
        Do While StartPos + TOWinLen < SeqLen
            
            'Do the first half of the window.
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 4), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            Call AverageMatrix(ToNumSeqs, NewAverage)

            If NewAverage = 0 Then
                MultFactorx = 1
            Else
                MultFactorx = MatAveragex / NewAverage
            End If

            Call MatrixMultiply(ToNumSeqs, MultFactorx)
            
            Call DistsToFile(FF, ToNumSeqs, TotMat())
            
            ReDim TotMat2(ToNumSeqs, ToNumSeqs)
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    'If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
                    TotMat2(Z, Y) = TotMat(Z, Y)
                    TotMat2(Y, Z) = TotMat(Z, Y)
                Next Y
            Next Z
            
            Pos = 0
            
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            'Do NJ tree
            ReDim ColTotals(ToNumSeqs)
            
            ReDim Treearray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 2, BSRndNumSeed, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
            LTree = LTree + 2
            SHolder(LTree - 1) = 10
            SHolder(LTree) = 13
            
            On Error Resume Next
            testlen = -1
            testlen = LOF(f2)
            On Error GoTo 0
            If testlen = -1 Then
                f2 = FreeFile
                Open "intree" For Binary Access Write As #f2
            End If
            
            
            Put #f2, NextWrite, SHolder
            NextWrite = NextWrite + LTree
            'Do second half of window
            MakeSubAlign ToNumSeqs, Len(TOSeq(0)), StartPos + Int(TOWinLen / 2) + Int(TOWinLen / 4), 1, Int(TOWinLen / 2), TempSeq2(0, 0), TOTSeqNum(0, 0)
            DNADIST TOCoeffVar, TOTvTs, TOFreqFlag, TOModel, TOFreqA, TOFreqC, TOFreqG, TOFreqT, ToNumSeqs + 1, Int(TOWinLen / 2), TempSeq2(0, 0), Alias(0), Ally(0), Weight(0, 0), Location(0), Px(0, 0), XX1(0), XX2(0), Prod1(0), Prod2(0), Prod3(0), TotMat(0, 0)
            
            Call AverageMatrix(ToNumSeqs, NewAverage)

            If NewAverage = 0 Then
                MultFactorx = 1
            Else
                MultFactorx = MatAveragex / NewAverage
            End If

            Call MatrixMultiply(ToNumSeqs, MultFactorx)
            
            Call DistsToFile(FF, ToNumSeqs, TotMat())
            
            
            ReDim TotMat2(ToNumSeqs, ToNumSeqs)
            For Z = 0 To ToNumSeqs - 1
                For Y = Z + 1 To ToNumSeqs
                    'If TotMat(Z, Y) = 0 Then TotMat(Z, Y) = 0.00005
                    TotMat2(Z, Y) = TotMat(Z, Y)
                    TotMat2(Y, Z) = TotMat(Z, Y)
                Next Y
            Next Z
            
            Pos = 0
            
            'This is where the writing to file thing used to go
            ReDim SHolder((ToNumSeqs + 1) * 40 * 2)
            'Do NJ tree
            ReDim ColTotals(ToNumSeqs)
            
            ReDim Treearray(ToNumSeqs, ToNumSeqs)
            LTree = NEIGHBOUR(1, 2, BSRndNumSeed, 1, ToNumSeqs + 1, TotMat(0, 0), SHolder(0), ColTotals(0), Treearray(0, 0))
            LTree = LTree + 2
            SHolder(LTree - 1) = 10
            SHolder(LTree) = 13
            Put #f2, NextWrite, SHolder
            NextWrite = NextWrite + LTree
            CPos = CPos + 1
            StartPos = StartPos + TOStepSize
        Loop

        '3.6 seconds per perm
        
    Next 'X

    Close #FF
    Close #f2
    NumDatasets = (CPos - 1) * 2
    'Now we can sort out the optfiles
    
    'Fitch1 option file
    Open "optfilef1" For Output As #1
    Print #1, "g"
    Print #1, "j"
    Print #1, BSRndNumSeed
    Print #1, "1"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "m"
    Print #1, NumDatasets
    Print #1, "3"
    Print #1, "3"
    Print #1, "2"
    Print #1, "y"
    Close #1
    'Fitch2 option file - used with NJ generated tree
    'and SS genration with "user" defined tree
    Open "optfilef2" For Output As #1
    Print #1, "u"
    Print #1, "p"
    Print #1, TOPower
    Print #1, "m"
    Print #1, NumDatasets
    Print #1, "3"
    Print #1, "2"
    Print #1, "3"
    Print #1, "y"
    Close #1
    Open "optfilen1" For Output As #1
    Print #1, "j"
    Print #1, BSRndNumSeed
    Print #1, "2"
    Print #1, "m"
    Print #1, NumDatasets
    Print #1, "2"
    Print #1, "3"
    Print #1, "y"
    Close #1
    
    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 58
    Call UpdateF2Prog
    '4.7 seconds
    StartPos = 1
    CPos = 0
    

    

    
    StartPos = 1
    Form1.SSPanel1.Caption = "Calculating SS Scores"
    CPos = 0
    Form1.ProgressBar1.Value = 63
    Call UpdateF2Prog
    '3.7 seconds
    BB = Abs(GetTickCount)
    If x = 12345 Then
        If TOTreeType = 1 Or TOPFlag = 1 Then  'do NJ if it is either set or you're working with permutations.
            
            
            ShellAndClose "neighbor1.bat", 0
            
            If AbortFlag = 1 Then
                Exit Sub
            End If
    
            
            FileCopy "infile", "infilebak"
            
            KillFile "intree"
            Name "treefile" As "intree"
            
            'passing NJ calculated tree to fitch within the batch
            'infile requires some moving of trees and distance matrices
            'about
            
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "outfile"
            KillFile "outtree"
            On Error GoTo 0
            SS = Abs(GetTickCount)
            ExpectFL = NumDatasets * 30: BatIndex = 9
            StartProgress = Form1.ProgressBar1.Value
            EndProgress = 90
            ShellAndClose "fitch2.bat", 0

            If AbortFlag = 1 Then
                Exit Sub
            End If
    
            KillFile "infile"
            Name "infilebak" As "infile"
            '22 seconds
        Else
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "outfile"
            KillFile "outtree"
            On Error GoTo 0
            ExpectFL = NumDatasets * 30: BatIndex = 9
            StartProgress = Form1.ProgressBar1.Value
            EndProgress = 90
            ShellAndClose "fitch1.bat", 0
    
            If AbortFlag = 1 Then
                Exit Sub
            End If
    
        End If
    Else
        FileCopy "infile", "infilebak"
            
           ' killfile "intree"
           ' Name "treefile" As "intree"
            
            'passing NJ calculated tree to fitch within the batch
            'infile requires some moving of trees and distance matrices
            'about
            
            If DebuggingFlag < 2 Then On Error Resume Next
            KillFile "outfile"
            KillFile "outtree"
            On Error GoTo 0
            SS = Abs(GetTickCount)
            ExpectFL = NumDatasets * 30: BatIndex = 9
            StartProgress = Form1.ProgressBar1.Value
            EndProgress = 90
            ShellAndClose "fitch2.bat", 0

            If AbortFlag = 1 Then
                Exit Sub
            End If
    
            KillFile "infile"
            Name "infilebak" As "infile"
    End If
    EE = Abs(GetTickCount)
    TT = EE - BB
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    Form1.ProgressBar1.Value = 90
    Call UpdateF2Prog
    'get ss scores for best fit trees
    ReDim SSScore(3, NumDatasets + 2)
    Pos = 1
    CPos = 0

    Do
        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            'SSScore(0, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(0, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(0, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
        End If

        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(2, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(2, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
            CPos = CPos + 1
        End If

    Loop

    Form1.SSPanel1.Caption = "Recalculating SS scores"
    Open "infile" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    If LOF(1) > 50000000 Then 'need to do it in separate pieces
        
        'Do While Not EOF(1)
            'read a bit to work out the distance between matrices
            GetStringA = String(100000, " ")
            Get #1, , GetStringA
'            If (Len(GetStringA) + Len(GetStringB)) <= 100000000 Then
'                GetStringB = GetStringB + GetStringA
'            ElseIf Len(GetStringC) + Len(GetStringA) <= 100000000 Then
'                GetStringC = GetStringC + GetStringA
'            ElseIf Len(GetStringD) + Len(GetStringA) <= 100000000 Then
'                GetStringD = GetStringD + GetStringA
'            ElseIf Len(GetStringE) + Len(GetStringA) <= 100000000 Then
'                GetStringE = GetStringE + GetStringA
'            End If
'            XX = LOF(1)
'            XX = XX
'        Loop
        
'        GetStringA = Left(GetStringB, LOF(1))
'        GetStringB = ""
'        x = x
        Close #1
         'Work out distance matrix spacing
        Pos = InStr(1, GetStringA, "S0", vbBinaryCompare)
        HeaderLen = Pos - 1
        LastPos = Pos
        Pos = InStr(LastPos + 1, GetStringA, "S00", vbBinaryCompare)
        Len1 = Pos - LastPos
        LenString = Len(GetStringA)
        Pos = 1
        LastPos = -2
        ReadposA = 1
        Name "infile" As "infile2"
        
        'Close #1
        'Write the infile for SS calculation with fitch
        Open "infile" For Output As #1
        FF = FreeFile
        Open "infile2" For Binary Access Read As #FF
        
        NumDatasets = 0
        Do While Not EOF(FF)
            'get distances
            GetStringC = String(Len1, " ")
            Get #FF, ReadposA, GetStringC
            
            'GetStringC = Mid$(GetStringA, ReadposA, Len1)
            
            ReadposA = ReadposA + Len1
            
            
            GetStringE = String(Len1, " ")
            Get #FF, ReadposA, GetStringE
            'GetStringE = Mid$(GetStringA, ReadposA, Len1)
            ReadposA = ReadposA + Len1
            
            'note:previous cycle's trees used
           
            Print #1, GetStringE
            
            Print #1, GetStringC
            
            NumDatasets = NumDatasets + 2
        Loop
        
        Close #1
        Close #FF
        Kill "infile2"
    Else 'can do it in just 1 chunk
        XX = LOF(1)
        If XX > 30000000 Then
            XX = 30000000
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        'Do
            'GetStringA = ""
        GetStringA = String(XX, " ")
            
        'Loop
        On Error GoTo 0
        Get #1, 1, GetStringA
        'XX = Len(GetStringA)
        Close #1
         'Work out distance matrix spacing
        Pos = InStr(1, GetStringA, "S0", vbBinaryCompare)
        HeaderLen = Pos - 1
        LastPos = Pos
        Pos = InStr(LastPos + 1, GetStringA, "S00", vbBinaryCompare)
        Len1 = Pos - LastPos
        LenString = Len(GetStringA)
        Pos = 1
        LastPos = -2
        ReadposA = 1
        'Write the infile for SS calculation with fitch
        Open "infile" For Output As #1
        
        NumDatasets = 0
        Do While (ReadposA + Len1 * 2) - 1 <= LenString
            'get distances
            GetStringC = Mid$(GetStringA, ReadposA, Len1)
            ReadposA = ReadposA + Len1
            GetStringE = Mid$(GetStringA, ReadposA, Len1)
            ReadposA = ReadposA + Len1
            
            'note:previous cycle's trees used
           
            Print #1, GetStringE
            
            Print #1, GetStringC
            
            NumDatasets = NumDatasets + 2
        Loop
        
        Close #1
    End If
    
    
    
   
    If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "outfile"
        KillFile "outtree"
        On Error GoTo 0
        SS = Abs(GetTickCount)
    ExpectFL = NumDatasets * 30: BatIndex = 9
    StartProgress = Form1.ProgressBar1.Value
    EndProgress = 98
    ShellAndClose "fitch2.bat", 0
    EE = Abs(GetTickCount)
    TT = EE - SS
    If AbortFlag = 1 Then
        Exit Sub
    End If

    Form1.ProgressBar1.Value = 98
    Call UpdateF2Prog
    '4.6 seconds
    BB = Abs(GetTickCount)
    Open "outfilex" For Binary Access Read As #1

    If LOF(1) = 0 Then
        MsgBox ("An error occured during the execution of TOPAL.  The problem appears to be the Phyip component FITCH.")
        AbortFlag = 1
        Close #1
        Exit Sub
    End If

    GetStringA = String$(LOF(1), " ")
    Get #1, 1, GetStringA
    Close #1
    'get ssscores
    Pos = 1
    CPos = 0

    Do
        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
           
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(1, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(1, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
        End If

        Pos = InStr(Pos, GetStringA, "Sum of squares =   ", vbBinaryCompare)

        If Pos = 0 Then
            Exit Do
        Else
            
            If DebuggingFlag < 2 Then On Error Resume Next
            SSScore(3, CPos) = val(Mid$(GetStringA, Pos + 21, 7))
            SSScore(3, CPos) = CDbl(Mid$(GetStringA, Pos + 21, 7))
            On Error GoTo 0
            Pos = Pos + 1
            CPos = CPos + 1
        End If

    Loop
    '0.2 seconds
    'CPos = NumDatasets
End Sub



Public Sub MakeSeqGenBat2(CurPerm)
'Write seq-gen batch file
Dim AF As Double, CF As Double, GF As Double, TF As Double
    FFX = FreeFile
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "seqgen.bat" For Output As #FFX
    'different cline parametes must be given for different models
    'onlt JC model options are given
    'Note that for JN and ML extra things must be either calculated
    'Shape parameter alpha distribution for JN and bpfrequencies for
    'ML).
    ToSeqGenCLine = "seq-gen"

    If TOModel = 0 Then
        ToSeqGenCLine = ToSeqGenCLine & " -mHKY -t0.5"
    ElseIf TOModel = 1 Then
        ToSeqGenCLine = ToSeqGenCLine & " -mHKY -t" & TOTvTs
    ElseIf TOModel = 2 Then
        ToSeqGenCLine = ToSeqGenCLine & " -mHKY -t" & TOTvTs
    Else
        ToSeqGenCLine = ToSeqGenCLine & " -mF84 -t" & TOTvTs

        If TOFreqFlag = 0 Then

            Call CalcBPFreqs(AF, CF, GF, TF)

            ToSeqGenCLine = ToSeqGenCLine & " -f " & AF & " " & CF & " " & GF & " " & TF
        Else
            ToSeqGenCLine = ToSeqGenCLine & " -f " & TOFreqA & " " & TOFreqC & " " & TOFreqG & " " & TOFreqT
        End If

    End If
    ToSeqGenCLine = ToSeqGenCLine & " -z" & CStr(CurPerm)
    
    If Len(TOSeq(0)) < 32000 Then
        ToSeqGenCLine = ToSeqGenCLine & " -l" & Len(TOSeq(0)) & " -n1 <simtree > out"
    Else
        ToSeqGenCLine = ToSeqGenCLine & " -l32000 -n1 <simtree > out"
    End If
    
    
    
    Print #FFX, ToSeqGenCLine
    Print #FFX, "del outfilex"
    Print #FFX, "rename out outfilex"
    Close #FFX
    On Error GoTo 0
End Sub
Public Sub LXoverA()
 'This subroutine executes LARD for automated screens - it only uses 2 bp scans with a heuristic search
    Dim PVal As Double, LRDRegion As Byte, BPos As Long, Epos As Long, LRDWin
    LRDRegion = 2
    LRDWin = 0
    Dim TSeq(2) As String, x As Long
    For x = 1 To Len(StrainSeq(0))
        
        TSeq(0) = TSeq(0) + Chr(SeqNum(x, Seq1) - 1)
        TSeq(1) = TSeq(1) + Chr(SeqNum(x, Seq2) - 1)
        TSeq(2) = TSeq(2) + Chr(SeqNum(x, Seq3) - 1)
        
    Next x
    
    Dim PID As Long, ProcessID As Long, LastLen As Long, SCount As Long, FLen As Long, NewSurface As Long, Pict As Long, CurPos As Long, Count As Long, retVal As Long, NewPos As Long
    Dim PntAPI As POINTAPI
    Dim OldDir As String, LARDCLine As String, TitleTmp As String

    Const STILL_ACTIVE = &H103
    ReDim LXPos(Len(StrainSeq(0)))
    
    If DebuggingFlag < 2 Then On Error Resume Next

    OldDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    On Error GoTo 0
    
    'Writes the alignment file for LARD
    Open "lardin" For Output As #1
    
    
    
    'LRDWin = 1
    'LRDWinLen = 200
    
    
    If LRDWin = 0 Then
        
        NumWins = 1
        
        Print #1, " 3  " + CStr(Len(StrainSeq(0))) ' 200"
        Print #1, "s1"
        Print #1, TSeq(0)
        Print #1, "s2"
        Print #1, TSeq(1)
        Print #1, "s3"
        Print #1, TSeq(2)
        
    Else
        
        'LRDWinLen = 200
        NumWins = (Len(StrainSeq(0)) - LRDWinLen) / LRDStep
        
        For x = 0 To NumWins - 1
            Print #1, " 3  " + CStr(LRDWinLen)
            Z = x * LRDStep + 1
            Print #1, "s1"
            Print #1, Mid$(TSeq(0), Z, LRDWinLen)
            Print #1, "s2"
            Print #1, Mid$(TSeq(1), Z, LRDWinLen)
            Print #1, "s3"
            Print #1, Mid$(TSeq(2), Z, LRDWinLen)
            Print #1, ""
        Next x
    End If
    Close #1
    'Exit Sub
    'Creates a fake outfile and then kills it
    Open "likelihood.surface" For Binary As 1
    Put #1, 1, ""
    Close #1
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "likelihood.surface"
    On Error GoTo 0
    'Creates a fake stackdump file and then kills it
    Open "LARD.EXE.stackdump" For Output As #1
    Close #1
    KillFile "LARD.EXE.stackdump"
    'Constructs the LARD command line
    LARDCLine = "lard.exe"
    
    If LRDWin = 0 Then
        LARDCLine = LARDCLine + " -r" + Trim(Str(CInt(LRDRegion)))
    Else
        LARDCLine = LARDCLine + " -r1"
    End If
    If LRDModel = 2 Then LRDModel = 0
    If LRDModel = 0 Or LRDModel = 1 Then

        If LRDModel = 0 Then
            LARDCLine = LARDCLine & " -mHKY"
        Else
            LARDCLine = LARDCLine & " -mF84"
        End If

        LARDCLine = LARDCLine & " -t" & LRDTvRat

        If LRDModel = 0 Or (LRDModel = 1 And LRDBaseFreqFlag = 1) Then

            If LRDAFreq <> LRDCFreq Or LRDAFreq <> LRDGFreq Or LRDAFreq <> LRDTFreq Then
                LARDCLine = LARDCLine & " -f" & LRDAFreq & " " & LRDCFreq & " " & LRDGFreq & " " & LRDTFreq
            End If

        End If

    Else
        LARDCLine = LARDCLine & " -mREV"

        If LRDAFreq <> LRDCFreq Or LRDAFreq <> LRDGFreq Or LRDAFreq <> LRDTFreq Then
            LARDCLine = LARDCLine & " -f" & LRDAFreq & " " & LRDCFreq & " " & LRDGFreq & " " & LRDTFreq
        End If

        If LRDACCoeff <> 1 Or LRDAGCoeff <> 1 Or LRDATCoeff <> 1 Or LRDCGCoeff <> 1 Or LRDCTCoeff <> 1 Then
            LARDCLine = LARDCLine & " -t" & LRDACCoeff & " " & LRDAGCoeff & " " & LRDATCoeff & " " & LRDCGCoeff & " " & LRDCTCoeff
        End If

    End If
    lrdgd = 0
    
    If LRDWin = 1 Then
        LARDCLine = LARDCLine + " -n" + CStr(Int(NumWins))
        LARDCLine = LARDCLine + " -u" + CStr(CLng(LRDWinLen / 2))
    Else
        If lrdgd = 0 Then
            LARDCLine = LARDCLine & " -e -s" & LRDStep
        Else
            LARDCLine = LARDCLine & " -d -s" & LRDStep
        End If
        
        LARDCLine = LARDCLine & " -z" + Trim(Str(CInt(LRDStep * 2)))
    End If
    
    
   

    If LRDCodon1 <> LRDCodon2 Or LRDCodon1 <> LRDCodon3 Then
        LARDCLine = LARDCLine & " -c" & LRDCodon1 & " " & LRDCodon2 & " " & LRDCodon3
    End If

    If LRDCategs > 0 Then
        LARDCLine = LARDCLine & " -g" & LRDCategs
        LARDCLine = LARDCLine & " -a" & LRDShape
    End If
    LARDCLine = LARDCLine & " -vp"
    LARDCLine = LARDCLine & " <lardin"
    'Creates a batch file so that lard can be executed with a command line
    
    
    'LARDCLine = "cmd.exe /c " + LARDCLine + " >c:\test.txt"
    'LARDCLine = "cmd.exe /c ping /? >c:\test.txt"
    
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "lard.bat" For Output As #1
    
    Do
        Pos = InStr(1, LARDCLine, ",")
        If Pos = 0 Then Exit Do
        Mid$(LARDCLine, Pos, 1) = "."
    Loop
    Print #1, LARDCLine
    Close #1
    On Error GoTo 0
    'Checks to see if a previously aborted run of lard was made and terminates it if necessary

    
    'ProcessID = Shell("lard.bat ", 0)
    'Do
    
    Dim OP As String
    'ProcessID = Shell("lard.bat", 1)
    'OP = GetCommandOutput(LARDCLine, True, True)
    'SS = Abs(GetTickCount)
    
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the LARD scan"
    
    Dim EC As Long
    EC = CInt(Len(StrainSeq(0)) / LRDStep) + 2
    'pvalcalc = 2*lik ratio chisquare with 4 df per breakpoint
    If LRDRegion = 2 Then
        
        ExpectFL = EC * EC * 22
            
    End If
    
    If LRDWin = 1 Then
        OP = GetCommandOutput("lard.bat", 0, True, False)
    Else
        OP = GetCommandOutput("lard.bat", 0, True, True)
    End If
    
    Pos = InStr(1, OP, "STATUS_ACCESS_VIOLATION", vbBinaryCompare)
    If Pos > 0 Then
         'LARD has failed
         MsgBox ("Execution of LARD failed because it did not have write access in the directory from which it is being run.  This could happen because of your Windows security settings in the directory where you have RDP installed")
         Form1.ProgressBar1.Value = 0
         Form1.SSPanel1.Caption = ""
         Call UpdateF2Prog
         Call EnableInterface
            Form1.Command25.Enabled = False
            Form1.Command25.ToolTipText = ""
         Exit Sub
    End If
    
    
    Open "screen.out" For Output As #1
    Print #1, OP
    Close #1
    'check to see if this beats the p-val cutoff
    If MCFlag = 0 Then
        MC = MCCorrection * (Len(StrainSeq(0)) / LRDStep)
    Else
        MC = (Len(StrainSeq(0)) / LRDStep)
    End If
    
    
    
    Pos = InStr(1, OP, "LR=", vbBinaryCompare)
    Pos = Pos + 3
    Pos2 = InStr(Pos + 1, OP, Chr(13), vbBinaryCompare)
    Pos3 = InStr(Pos + 1, OP, Chr(10), vbBinaryCompare)
    
    If Pos > 22 Then
        If (Pos2 < Pos3 Or Pos3 = 0) And Pos2 > Pos Then
            'XX = Mid$(OP, Pos, Pos2 - Pos)
            MaxL = Mid$(OP, Pos, Pos2 - Pos)
        Else
            MaxL = Mid$(OP, Pos, Pos3 - Pos)
        End If
    
    End If
    If MaxL > 745 Then MaxL = 745
    PVal = chi2(MaxL * 2, 4) * MC
    
    
    If PVal > LowestProb Then
        If DebuggingFlag < 2 Then On Error Resume Next
        ChDir OldDir
        ChDrive OldDir
        On Error GoTo 0
        Exit Sub
        
    End If
    If LRDWin = 0 Then
    
        'there is no likelihood surface file with heuristic screen so don't bother with that
        'read likelihoods from the OP output
        Pos = InStr(1, OP, "Recombination region (to the left of):", vbBinaryCompare)
        If Pos = 0 Then
            If DebuggingFlag < 2 Then On Error Resume Next
            ChDir OldDir
            ChDrive OldDir
            On Error GoTo 0
            Exit Sub
        End If
        LastPos = Pos + 1
        
        Pos = InStr(LastPos, OP, "->", vbBinaryCompare)
        'XX = Mid$(OP, LastPos + 38, Pos - LastPos - 38)
        BPos = CLng(Mid$(OP, LastPos + 38, Pos - LastPos - 38))
        LastPos = Pos + 2
        Pos = InStr(LastPos, OP, Chr(9), vbBinaryCompare)
        Epos = CLng(Mid$(OP, LastPos, Pos - LastPos))
        x = x
    Else
        'work out bpos and epos however I can - possibly split the alignment at maxpeak and do single scan for next maxpeak.
        'read positions from op
        ReDim LXPos(0, NumWins)
        ReDim LSurface(NumWins)
       
        x = x
        Pos = InStr(1, OP, "cross", vbBinaryCompare)
        If Pos > 0 Then
            LastPos = Pos
            
            For x = 0 To Int(NumWins) - 1
                For Y = 0 To 2
                    Pos = InStr(LastPos + 1, OP, Chr(9), vbBinaryCompare)
                    LastPos = Pos
                    'XX = Mid$(OP, Pos, 20)
                    x = x
                Next Y
                TPos = Pos
                Pos = InStr(LastPos + 1, OP, Chr(9), vbBinaryCompare)
                LastPos = Pos
                
                LSurface(x + 1) = CDbl(Mid$(OP, TPos + 1, Pos - TPos - 1))
                LXPos(0, x + 1) = (LRDStep * x) + LRDWinLen / 2
            Next x
        Else
            'handle this sometime
        End If
    End If
        
    
    Dim ScoresX() As Byte
    ReDim ScoresX(Len(StrainSeq(0)), 2)
    LenXoverSeq = BSSubSeq(Len(StrainSeq(0)), Seq1, Seq2, Seq3, SeqNum(0, 0), XPosDiff(0), XDiffPos(0), ScoresX(0, 0))
    
    Call ProcessEvent(7, PVal, BPos, Epos, XPosDiff(), XDiffPos(), 0, 0, 10, LenXoverSeq)
    
    Call ProcessEvent(7, PVal, Epos, BPos, XPosDiff(), XDiffPos(), 0, 0, 10, LenXoverSeq)
    'check to see whether the best even is significant and if it is add it to xoverlist with a prgflag=6
    
     If DebuggingFlag < 2 Then On Error Resume Next
    ChDir OldDir
    ChDrive OldDir
    On Error GoTo 0
    

End Sub
Public Sub AddToBak(SuperEventList() As Long, ReplaceE, WinE, oEventNumber, S2TraceBack() As Long, oSuperEventList() As Long, BakXOList() As XOverDefine, BakCurXOver() As Integer, XoverList() As XOverDefine, CurrentXOver() As Integer)
If ReplaceE > 1 Then
    x = x '1471,1472,1471,1469:1498,1471,1472,1471,1469
End If
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If WinE = SuperEventList(XoverList(x, Y).Eventnumber) Then
                    
            BakCurXOver(S2TraceBack(x)) = BakCurXOver(S2TraceBack(x)) + 1
            If BakCurXOver(S2TraceBack(x)) > UBound(BakXOList, 2) Then
                ReDim Preserve BakXOList(PermNextno, BakCurXOver(S2TraceBack(x)) + 100)
            End If
            
            BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))) = XoverList(x, Y)
            BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).Daughter = S2TraceBack(XoverList(x, Y).Daughter)
            BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).MajorP = S2TraceBack(XoverList(x, Y).MajorP)
            BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).MinorP = S2TraceBack(XoverList(x, Y).MinorP)
            'XX = XoverList(x, Y).Beginning
            BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).Eventnumber = oEventNumber + XoverList(x, Y).Eventnumber
            
            If BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).Eventnumber > UBound(oSuperEventList, 1) Then
                ReDim Preserve oSuperEventList(BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).Eventnumber + 100)
            End If
            oSuperEventList(BakXOList(S2TraceBack(x), BakCurXOver(S2TraceBack(x))).Eventnumber) = ReplaceE
            
        End If
    Next Y
Next x
'XX = BakXOlist(1, 6).Eventnumber

End Sub

Public Sub GetAge(EN, Daught() As Byte, g, D, P1, P2, FMat() As Single, SMat() As Single, PermDIffs() As Single, PermValid() As Single, AgeEvent() As Double)
Dim x As Long, Y As Long
Dim Age As Double, Addj(1) As Double, ID() As Double, Tot(2) As Double, TParDist As Double, ParDist As Double
Dim MaxDist() As Double
If SEventNumber = 1 Then
    ReDim AgeEvent(1, 10)
Else
    If UBound(AgeEvent, 1) < SEventNumber Then
        ReDim Preserve AgeEvent(1, SEventNumber + 10)
    End If
End If
ReDim ID(1, 2)
ID(0, 0) = FMat(D, P1): ID(0, 1) = FMat(D, P2): ID(0, 2) = FMat(P1, P2)
ID(1, 0) = SMat(D, P1): ID(1, 1) = SMat(D, P2): ID(1, 2) = SMat(P1, P2)
'Work out the distance modifyer for each region
Tot(0) = 0: Tot(1) = 0: Tot(2) = 0
For x = 0 To NextNo
    For Y = x + 1 To NextNo
        'If DontUse(X) = 0 And DontUse(Y) = 0 Then
            If FMat(x, Y) < 3 Then
                Tot(0) = Tot(0) + FMat(x, Y)
                Tot(1) = Tot(1) + SMat(x, Y)
                If PermValid(x, Y) > 0 Then
                    TParDist = 1 - PermDIffs(x, Y) / PermValid(x, Y)
                    If TParDist > 0.25 Then
                        TParDist = (4# * TParDist - 1#) / 3#
                        TParDist = Log(TParDist)
                        TParDist = -0.75 * TParDist
                       
                    Else
                        TParDist = 1
                    End If
                Else
                    TParDist = 1
                End If
                Tot(2) = Tot(2) + TParDist
            End If
        'End If
    Next Y
Next x

If Tot(0) > 0 And Tot(2) > 0 Then '42.6091706,18.498428
    Addj(0) = Tot(0) / Tot(2)
Else
    Addj(0) = 1
End If
If Tot(1) > 0 And Tot(2) > 0 Then '42.6091706,18.498428
    Addj(1) = Tot(1) / Tot(2)
Else
    Addj(1) = 1
End If
'Modify the recombinant region dists
For x = 0 To 2
    ID(0, x) = ID(0, x) / Addj(0)
    ID(1, x) = ID(1, x) / Addj(1)
   
Next x

ParDist = 0: Age = 1000
For x = 0 To 1
    For Y = 0 To 2
        If Age > ID(x, Y) Then Age = ID(x, Y)
        If ParDist < ID(x, Y) Then ParDist = ID(x, Y)
        
    Next Y
Next x



ParDist = ParDist - Age



If ParDist < 0 Then ParDist = 0
'AgeEvent(1, G) = ParDist
AgeEvent(0, EN) = Age
'now work out the minimum age of each event
ReDim MaxDist(1)
For Y = 0 To NextNo
    If Daught(g, Y) > 0 Then
         If FMat(D, Y) > MaxDist(0) Then MaxDist(0) = FMat(D, Y)
         If SMat(D, Y) > MaxDist(1) Then MaxDist(1) = SMat(D, Y)
    End If
Next Y
MaxDist(0) = MaxDist(0) / Addj(0)
MaxDist(1) = MaxDist(1) / Addj(1)
If MaxDist(0) < MaxDist(1) Then
    AgeEvent(1, EN) = MaxDist(0)
Else
    AgeEvent(1, EN) = MaxDist(1)
End If

If AgeEvent(0, EN) < AgeEvent(1, EN) Then
    AgeEvent(1, EN) = AgeEvent(0, EN)
Else
    If AgeEvent(1, EN) = 0 Then
        AgeEvent(1, EN) = AgeEvent(0, EN) / 2
    Else
         AgeEvent(1, EN) = AgeEvent(1, EN) + (AgeEvent(0, EN) - AgeEvent(1, EN)) / 2
         
    End If
End If
x = x
End Sub

Public Sub EraseEvidence(NextNo, CE, BakXOList() As XOverDefine, BakCurXOver() As Integer, SuperEventList() As Long)
Dim x As Long, Y As Long
For x = 0 To NextNo
    Y = 1
    Do While Y <= BakCurXOver(x)
        If SuperEventList(BakXOList(x, Y).Eventnumber) = CE Then
            If Y < BakCurXOver(x) Then
                BakXOList(x, Y) = BakXOList(x, BakCurXOver(x))
            End If
            BakCurXOver(x) = BakCurXOver(x) - 1
        
        End If
        Y = Y + 1
    Loop
Next x
End Sub
Public Sub MakeBestEvent()

Dim FF As Long, oDirX As String, UB As Long, Z As Long, BP As Double, PF As Long, x As Long, Y As Long, BestP() As Double, AProg() As Byte, SEN As Long, ProbV As Double
ReDim AProg(AddNum * 2)
'Eventnumber = 1000
If DoScans(0, 0) = 1 Then AProg(0) = 1: AProg(0 + AddNum) = 1
If DoScans(0, 1) = 1 Then AProg(1) = 1: AProg(1 + AddNum) = 1
If DoScans(0, 2) = 1 Then AProg(2) = 1: AProg(2 + AddNum) = 1
If DoScans(0, 3) = 1 Then AProg(3) = 1: AProg(3 + AddNum) = 1
If DoScans(0, 4) = 1 Then AProg(4) = 1: AProg(4 + AddNum) = 1
If DoScans(0, 5) = 1 Then AProg(5) = 1: AProg(5 + AddNum) = 1
If DoScans(0, 6) = 1 Then AProg(6) = 1: AProg(6 + AddNum) = 1
If DoScans(0, 7) = 1 Then AProg(7) = 1: AProg(7 + AddNum) = 1
If DoScans(0, 8) = 1 Then AProg(8) = 1: AProg(8 + AddNum) = 1

ReDim BestEvent(SEventNumber, 1), BestP(SEventNumber)
ReDim Confirm(SEventNumber + 1, AddNum - 1), ConfirmP(SEventNumber + 1, AddNum - 1), ConfirmMi(SEventNumber + 1, AddNum - 1), ConfirmPMi(SEventNumber + 1, AddNum - 1), ConfirmMa(SEventNumber + 1, AddNum - 1), ConfirmPMa(SEventNumber + 1, AddNum - 1)

'find the bestp for every event
'XX = SEventNumber
'XX = UBound(SuperEventList)
XX = UBound(BestP, 1)
For x = 0 To PermNextno
    For Y = 1 To CurrentXOver(x)
'        If x = 38 And Y = 1 Then
'            x = x
'            XX = XoverList(x, Y).Daughter
'            XX = XoverList(x, Y).MajorP
'            XX = XoverList(x, Y).MinorP
'            XX = XoverList(x, Y).PermPVal
'            XX = XoverList(x, Y).Probability
'        End If
        PF = XoverList(x, Y).ProgramFlag
        If PF <= AddNum - 1 Then 'only consider unrejected events
            SEN = SuperEventList(XoverList(x, Y).Eventnumber)
            
            ProbV = XoverList(x, Y).Probability
            If ProbV > 0 And (ProbV < BestP(SEN) Or BestP(SEN) = 0) Then
                If AProg(PF) = 1 Then
                    BestP(SEN) = ProbV
                End If
            End If
            If XoverList(x, Y).PermPVal < 0 Then
            
                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 0) = x
                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 1) = Y
                If XoverList(x, Y).DHolder > 0 Then
                    
                        XoverList(x, Y).DHolder = -XoverList(x, Y).DHolder
                    
                Else
                    If XoverList(x, Y).DHolder = 0 Then
                        XoverList(x, Y).DHolder = -1
                    End If
                End If
                
            ElseIf XoverList(x, Y).DHolder < 0 And AllowConflict <> 0 Then
                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 0) = x
                BestEvent(SuperEventList(XoverList(x, Y).Eventnumber), 1) = Y
            End If
            If PF > AddNum - 1 Then PF = PF - AddNum
            If Confirm(SEN, PF) < 32000 Then
                Confirm(SEN, PF) = Confirm(SEN, PF) + 1
                ConfirmP(SEN, PF) = ConfirmP(SEN, PF) + -Log10(ProbV)
            End If
        End If
    Next Y
Next x
'XX = Confirm(7, 0)
  'XX = BestP(7)
   XX = AddNum
 
'this will only updatebestevent if BestEvent(X, 0) = 0 And BestEvent(X, 1) = 0

'XX = BestEvent(5, 0)
'XX = BestEvent(5, 1)
'First look if there are suitable ebstevents among the primary screening methods
 For x = 1 To SEventNumber '2,3
     BP = 10000
     If BestEvent(x, 0) = 0 And BestEvent(x, 1) = 0 Then
         'make the nextbest the best
         For Z = 0 To PermNextno
             For Y = 1 To CurrentXOver(Z)
                 If SuperEventList(XoverList(Z, Y).Eventnumber) = x Then
                     If XoverList(Z, Y).ProgramFlag > AddNum * 2 Then XoverList(Z, Y).ProgramFlag = XoverList(Z, Y).ProgramFlag - AddNum
                     If AProg(XoverList(Z, Y).ProgramFlag) = 1 Then
                        ProbV = XoverList(Z, Y).Probability
                        If (ProbV > 0 And ProbV < BP) Or XoverList(Z, Y).PermPVal < 0 Then
                             
                             BestEvent(x, 0) = Z: BestEvent(x, 1) = Y
                             If XoverList(Z, Y).PermPVal < 0 Then
                                BP = -100
                             Else
                                BP = XoverList(Z, Y).Probability
                             End If
                         End If
                     End If
                 End If
             Next Y
         Next Z
         
         If BestEvent(x, 0) <> 0 Or BestEvent(x, 1) <> 0 Then
'             XX = XoverList(0, 1).Daughter
'             XX = XoverList(0, 1).MinorP
'             XX = XoverList(0, 1).MajorP
             If XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder > 0 Then
                 XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder = -XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder
             ElseIf XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder = 0 Then
                 XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder = -0.00001
             End If
         End If
     
     End If
 
 Next x
 
 'if no bestevent was found for the primary screening methods then looks again among the other methods
 For x = 1 To SEventNumber
     BP = 10000
     If BestEvent(x, 0) = 0 And BestEvent(x, 1) = 0 Then
         'make the nextbest the best
         For Z = 0 To NextNo
             For Y = 1 To CurrentXOver(Z)
                 If SuperEventList(XoverList(Z, Y).Eventnumber) = x Then
                    
                     If XoverList(Z, Y).Probability > 0 And XoverList(Z, Y).Probability < BP Then
                         BestEvent(x, 0) = Z: BestEvent(x, 1) = Y
                         BP = XoverList(Z, Y).Probability
                        
                     End If
                 End If
             Next Y
         Next Z
         
     End If
     If BestEvent(x, 0) <> 0 Or BestEvent(x, 1) <> 0 Then
         If XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder > 0 Then
             XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder = -XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder
         ElseIf XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder = 0 Then
             XoverList(BestEvent(x, 0), BestEvent(x, 1)).DHolder = -0.00001
         
         End If
     End If
 Next x
 
 
 
 'now update confirm and confirmp for all events that are completely rejected
 For x = 0 To PermNextno
     For Y = 1 To CurrentXOver(x)
         PF = XoverList(x, Y).ProgramFlag
         
         'this may be a bug - no idea why this only screens rejected events (i.e. one where programflag is >=addnum)
         If PF > AddNum - 1 Then
            SEN = SuperEventList(XoverList(x, Y).Eventnumber)
             If XoverList(x, Y).Probability > 0 And (XoverList(x, Y).Probability < BestP(SEN) Or BestP(SEN) = 0) Then
                 If AProg(PF) = 1 Then
                     If BestP(SEN) = 0 Then
                         BestP(SEN) = XoverList(x, Y).Probability
                     Else
                         If XoverList(BestEvent(SEN, 0), BestEvent(SEN, 1)).ProgramFlag > AddNum - 1 Then
                             BestP(SEN) = XoverList(x, Y).Probability
                         End If
                     End If
                 End If
             End If
             
             If PF > AddNum - 1 Then PF = PF - AddNum
             Confirm(SEN, PF) = Confirm(SEN, PF) + 1
             ConfirmP(SEN, PF) = ConfirmP(SEN, PF) + -Log10(XoverList(x, Y).Probability)
         End If
     Next Y
 Next x
 
 If DebuggingFlag < 2 Then On Error Resume Next
 UB = -1
 UB = UBound(BestXOListMi, 2)
 
 If UB = -1 Then
 
    If XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim BestXOListMi(PermNextno, UBXOMi)
        ReDim BestXOListMa(PermNextno, UBXoMa)
        UBXoMa = UBound(BestXOListMa, 2)
        If MiRec < 1 Then
            Open "RDP5BestXOListMi" + UFTag For Binary As #FF
            Get #FF, , BestXOListMi()
            Close #FF
            MiRec = 1
        End If
        If MaRec < 1 Then
            Open "RDP5BestXOListMa" + UFTag For Binary As #FF
            Get #FF, , BestXOListMa()
            Close #FF
            MaRec = 1
        End If
        ChDrive oDirX
        ChDir oDirX
        
    End If
 
 
 
 End If
 
 On Error GoTo 0
 
 'wrong - all that effor for xoverlist and so little for this........... seems bad
 For x = 0 To PermNextno
     For Y = 1 To BCurrentXoverMi(x)
         PF = BestXOListMi(x, Y).ProgramFlag
         If PF > AddNum - 1 Then PF = PF - AddNum
         If PF > AddNum - 1 Then PF = PF - AddNum
         ConfirmMi(SuperEventList(BestXOListMi(x, Y).Eventnumber), PF) = ConfirmMi(SuperEventList(BestXOListMi(x, Y).Eventnumber), PF) + 1
         ConfirmPMi(SuperEventList(BestXOListMi(x, Y).Eventnumber), PF) = ConfirmPMi(SuperEventList(BestXOListMi(x, Y).Eventnumber), PF) + -Log10(BestXOListMi(x, Y).Probability)
     Next Y
 Next x
 For x = 0 To PermNextno
     For Y = 1 To BCurrentXoverMa(x)
         PF = BestXOListMa(x, Y).ProgramFlag
         If PF > AddNum - 1 Then PF = PF - AddNum
         If PF > AddNum - 1 Then PF = PF - AddNum
         ConfirmMa(SuperEventList(BestXOListMa(x, Y).Eventnumber), PF) = ConfirmMa(SuperEventList(BestXOListMa(x, Y).Eventnumber), PF) + 1
         ConfirmPMa(SuperEventList(BestXOListMa(x, Y).Eventnumber), PF) = ConfirmPMa(SuperEventList(BestXOListMa(x, Y).Eventnumber), PF) + -Log10(BestXOListMa(x, Y).Probability)
     Next Y
 Next x
 
 
 If UB = -1 Then
    If XOMiMaInFileFlag = 1 Then
        Erase BestXOListMa
        Erase BestXOListMi
        MaRec = MaRec - 1
        MiRec = MiRec - 1
    End If
 End If
 
End Sub

Public Sub DrawGMap()

Dim GMap() As Integer
ReDim GMap(Len(StrainSeq(0)), NextNo)

For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) = 46 Then
            'check for missing data
            Cnt = 0
            For Z = Y To Y + 10 'len(strainseq(0))
                If Z <= Len(StrainSeq(0)) Then
                    If SeqNum(Z, x) = 46 Then
                        Cnt = Cnt + 1
                    End If
                Else
                    Exit For
                    Cnt = 10
                End If
            Next Z
            If Cnt >= 10 Then
                For Z = Y To Len(StrainSeq(0))
                    If SeqNum(Z, x) = 46 Then
                        GMap(Z, x) = -1
                    Else
                        Y = Z
                        Exit For
                    End If
                Next Z
            
            End If
        End If
        
    Next Y
Next x



For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        If GMap(Y, x) <> -1 Then
            If SeqNum(Y, x) = SeqNum(Y, 0) And SeqNum(Y, x) = SeqNum(Y, 1) Then
            
            ElseIf SeqNum(Y, x) = SeqNum(Y, 0) Then
                GMap(Y, x) = 1
            ElseIf SeqNum(Y, x) = SeqNum(Y, 1) Then
                GMap(Y, x) = 2
            Else
                GMap(Y, x) = 100
            End If
        End If
        
    Next Y
Next x

If DebuggingFlag < 2 Then On Error Resume Next
KillFile "tmp2.emf"
On Error GoTo 0
semfnameII = "tmp2.emf"
semfname$ = "tmp2.emf"

Dim SP As Long, EP As Long
Dim PColIn As Long, HFactor As Double, WFactor As Double
Dim OldFont As Long, oldpen As Long, PEN As Long, LOffset As Long, TOffset As Long, MhDC As Long, EMFCls As Long

Dim LPn As LOGPEN
Dim red As Long, Green As Long, Green2 As Long, blue As Long
Dim rct As RECT
Dim LoFnt As Long

rct.Left = 0
rct.Top = 0
rct.Right = Len(StrainSeq(0)) * 20
rct.Bottom = 16000


HFactor = 200
WFactor = 0.5 '500 / Len(StrainSeq(0))
LOffset = 70
TOffset = 40
    
Form1.Picture1.AutoRedraw = False
MhDC = CreateEnhMetaFile(Form1.Picture1.hdc, semfname$, rct, "")
Form1.Picture1.AutoRedraw = True

'Get original Metafile font and pen
LoFnt = CreateFont(20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "Arial")
OldFont = SelectObject(MhDC, LoFnt)
PEN = CreatePenIndirect(LPn)
oldpen = SelectObject(MhDC, PEN)


    
    
'Draw lines
Dim PntAPI As POINTAPI
For x = 0 To NextNo
    For Y = 0 To Len(StrainSeq(0))
        If GMap(Y, x) <> 0 Then
            If GMap(Y, x) = -1 Then
                LPn.lopnColor = RGB(196, 196, 196)
                PEN = CreatePenIndirect(LPn)
                SelectObject MhDC, PEN
                dl = 3
            ElseIf GMap(Y, x) = 1 Then
                LPn.lopnColor = RGB(255, 0, 0)
                PEN = CreatePenIndirect(LPn)
                SelectObject MhDC, PEN
                dl = 5
            ElseIf GMap(Y, x) = 2 Then
                LPn.lopnColor = RGB(0, 0, 255)
                PEN = CreatePenIndirect(LPn)
                SelectObject MhDC, PEN
                dl = 5
            Else
                LPn.lopnColor = RGB(0, 0, 0)
                PEN = CreatePenIndirect(LPn)
                SelectObject MhDC, PEN
                dl = 10
            End If
            
            MoveToEx MhDC, LOffset + WFactor * Y, TOffset + TOffset * x - dl, PntAPI
            LineTo MhDC, LOffset + WFactor * Y, TOffset + TOffset * x + dl
        End If
    Next Y
Next x

LPn.lopnColor = RGB(0, 0, 0)
PEN = CreatePenIndirect(LPn)
SelectObject MhDC, PEN
'Draw backbones of sequences

For x = 0 To NextNo

    MoveToEx MhDC, LOffset, TOffset + TOffset * x, PntAPI
    LineTo MhDC, LOffset + WFactor * Len(StrainSeq(0)), TOffset + TOffset * x
    TextOut MhDC, LOffset + WFactor * Len(StrainSeq(0)) + 20, TOffset + TOffset * x - 10, OriginalName(x), Len(OriginalName(x))
Next x
 


'Clear up and close  emf
PEN = SelectObject(MhDC, oldpen)
DeleteObject (PEN)
LoFnt = SelectObject(MhDC, OldFont)
DeleteObject (LoFnt)
EMFCls = CloseEnhMetaFile(MhDC)
Dummy = DeleteEnhMetaFile(EMFCls)
    
Clipboard.Clear
Clipboard.SetData LoadPicture("tmp2.emf"), 3
If DebuggingFlag < 2 Then On Error Resume Next
On Error GoTo 0

End Sub
Public Sub AlphabetiseNames()

Dim SCx() As Long
ReDim SCx(NextNo)
For x = 0 To NextNo
    
    If InStr(1, OriginalName(x), "{", vbBinaryCompare) > 0 Or Len(OriginalName(x)) < 5 Then
        
    Else
        
        Do While val(Left(OriginalName(x), 1)) > 0 Or Left(OriginalName(x), 1) = "0"
            OriginalName(x) = Mid(OriginalName(x), 2, Len(OriginalName(x)) - 1)
            If Mid(OriginalName(x), 3, 1) = "_" Then Exit Do 'Or Mid(originalname(X), 3, 1) = "."
        Loop
        
        
        x = x
    End If
    SCx(x) = 0
    SCx(x) = SCx(x) + Asc(Mid(OriginalName(x), 1, 1))
    SCx(x) = SCx(x) * 1000
    SCx(x) = SCx(x) + Asc(Mid(OriginalName(x), 2, 1)) * 100
    SCx(x) = SCx(x) + Asc(Mid(OriginalName(x), 3, 1)) * 10
    If Len(OriginalName(x)) > 3 Then
        SCx(x) = SCx(x) + Asc(Mid(OriginalName(x), 4, 1))
    End If
Next x
WinX = 0
For x = 0 To NextNo
    MS = 0
    For Y = 0 To NextNo
        If SCx(Y) > MS Then
            MS = SCx(Y)
            WinX = Y
        End If
    Next Y
    If MS = 0 Then
        Exit For
    Else
        Print #1, ">" + OriginalName(WinX)
        Print #1, StrainSeq(WinX)
        SCx(WinX) = 0
    End If
Next x

'Close #2
Close #1

End Sub
Public Sub EnableFrame6()
'Form3.Frame6(0).Visible = True
'Form3.Frame6(2).Visible = False
'Exit Sub
With Form3
    .Frame6(0).Enabled = True
    .Label1(45).Enabled = True
    .Label1(46).Enabled = True
    .Text1(33).Enabled = True
    .Text1(34).Enabled = True
    .Text1(33).BackColor = RGB(255, 255, 255)
    .Text1(34).BackColor = RGB(255, 255, 255)
    .Text1(33).ForeColor = 0
    .Text1(34).ForeColor = 0
End With


End Sub
Public Sub DisableFrame6()
'Form3.Frame6(0).Visible = False
'Form3.Frame6(2).Visible = True
'Exit Sub
With Form3
    .Frame6(0).Enabled = False
    .Label1(45).Enabled = False
    .Label1(46).Enabled = False
    .Text1(33).Enabled = False
    .Text1(34).Enabled = False
    .Text1(33).ForeColor = RGB(128, 128, 128)
    .Text1(34).ForeColor = RGB(128, 128, 128)
    .Text1(33).BackColor = Form1.BackColor
    .Text1(34).BackColor = Form1.BackColor
End With


End Sub
Public Sub SetMLModel()

Form3.Label1(59).Enabled = True
Form3.Label1(60).Enabled = True
Form3.Label21(46).Enabled = True
Form3.Label21(52).Enabled = True
Form3.Text23(34).Visible = True
Form3.Text23(35).Visible = False
Form3.Text1(17).Enabled = True
Form3.Text1(17).BackColor = QBColor(15)
Form3.Text1(18).Enabled = True
Form3.Text1(18).BackColor = QBColor(15)
Form3.Command28(43).Enabled = True
Form3.Command28(47).Enabled = True
Form3.Command28(44).Enabled = True
Form3.Text23(42).BackColor = QBColor(15)
Form3.Text23(42).Enabled = True


If ModelTestFlag = 1 Then
    Form3.Label1(69) = "Automatic model selection (fast with PhyML1)"
    Form3.Label1(24).Enabled = False
    Form3.Command28(43).Enabled = False
    Form3.Command28(44).Enabled = False
    Form3.Label1(59).Enabled = False
    Form3.Label1(60).Enabled = False
    Form3.Label21(46).Enabled = False
    Form3.Label21(42).Enabled = False
    Form3.Label21(52).Enabled = False
    Form3.Text23(34).BackColor = Form1.BackColor
    Form3.Text23(42).BackColor = Form1.BackColor
    Form3.Text1(18).BackColor = Form1.BackColor
    Form3.Text1(17).BackColor = Form1.BackColor
    Form3.Text23(34).Enabled = False
    Form3.Text23(42).Enabled = False
    Form3.Text1(18).Enabled = False
    Form3.Text1(17).Enabled = False
ElseIf ModelTestFlag = 2 Then
    Form3.Label1(69) = "Automatic model selection (slower with PhyML3)"
    Form3.Label1(24).Enabled = False
    Form3.Command28(43).Enabled = False
    Form3.Command28(44).Enabled = False
    Form3.Label1(59).Enabled = False
    Form3.Label1(60).Enabled = False
    Form3.Label21(46).Enabled = False
    Form3.Label21(42).Enabled = False
    Form3.Label21(52).Enabled = False
    Form3.Text23(34).BackColor = Form1.BackColor
    Form3.Text23(42).BackColor = Form1.BackColor
    Form3.Text1(18).BackColor = Form1.BackColor
    Form3.Text1(17).BackColor = Form1.BackColor
    Form3.Text23(34).Enabled = False
    Form3.Text23(42).Enabled = False
    Form3.Text1(18).Enabled = False
    Form3.Text1(17).Enabled = False
        
Else
    Form3.Label1(69) = "User specified model"
    Form3.Label1(24).Enabled = True
    Form3.Command28(43).Enabled = True
    Form3.Command28(44).Enabled = True
    Form3.Label1(59).Enabled = True
    Form3.Label1(60).Enabled = True
    Form3.Label21(46).Enabled = True
    Form3.Label21(42).Enabled = True
    Form3.Label21(52).Enabled = True
    Form3.Text23(34).BackColor = QBColor(15)
    Form3.Text23(42).BackColor = QBColor(15)
    Form3.Text1(18).BackColor = QBColor(15)
    Form3.Text1(17).BackColor = QBColor(15)
    Form3.Text23(34).Enabled = True
    Form3.Text23(42).Enabled = True
    Form3.Text1(18).Enabled = True
    Form3.Text1(17).Enabled = True
    If TPModel = 0 Then
        Form3.Label1(24).Caption = "Jukes and Cantor, 1969"
        Form3.Frame21(6).Enabled = False
        
        'Disable Transition transversion ratio option
        Form3.Text1(17).Text = "0.5"
        Form3.Text1(17).Enabled = False
        Form3.Text1(17).BackColor = Form1.BackColor
        Form3.Label1(59).Enabled = False
        
        'Disable base frequency estimate option
        Form3.Label21(46).Enabled = False
        Form3.Command28(44).Enabled = False
        
        
        
        Form3.Text23(30).BackColor = Form1.BackColor
        Form3.Text23(31).BackColor = Form1.BackColor
        Form3.Text23(32).BackColor = Form1.BackColor
        Form3.Text23(33).BackColor = Form1.BackColor
        Form3.Text23(30).Enabled = False
        Form3.Text23(31).Enabled = False
        Form3.Text23(32).Enabled = False
        Form3.Text23(33).Enabled = False
        Form3.Label21(36).Enabled = False
        Form3.Label21(37).Enabled = False
        Form3.Label21(38).Enabled = False
        Form3.Label21(39).Enabled = False
    ElseIf TPModel = 1 Then
        Form3.Label1(24).Caption = "Kimura, 1980"
        
        'Enable transition transversion rate selection option
        Form3.Text1(17).Text = TPTVRat
        Form3.Text1(17).Enabled = True
        Form3.Text1(17).BackColor = QBColor(15)
        Form3.Label1(59).Enabled = True
        
        'Disable base frequency estimate option
        Form3.Label21(46).Enabled = False
        Form3.Command28(44).Enabled = False
        
        
        
    ElseIf TPModel = 2 Then
        Form3.Label1(24).Caption = "Felsenstein, 1981"
        'Disable Transition transversion ratio option
        Form3.Text1(17).Text = "0.5"
        Form3.Text1(17).Enabled = False
        Form3.Text1(17).BackColor = Form1.BackColor
        Form3.Label1(59).Enabled = False
        
        'Enable base frequency estimate option
        Form3.Label21(46).Enabled = True
        Form3.Command28(44).Enabled = True
        
        
        
    ElseIf TPModel = 3 Then
        Form3.Label1(24).Caption = "Felsenstein, 1984"
        'Enable transition transversion rate selection option
        Form3.Text1(17).Text = TPTVRat
        Form3.Text1(17).Enabled = True
        Form3.Text1(17).BackColor = QBColor(15)
        Form3.Label1(59).Enabled = True
        
        'Enable base frequency estimate option
        Form3.Label21(46).Enabled = True
        Form3.Command28(44).Enabled = True
        
        
        
       
        
    ElseIf TPModel = 4 Then
        Form3.Label1(24).Caption = "Tamura and Nei, 1993"
         'Enable transition transversion rate selection option
        Form3.Text1(17).Text = TPTVRat
        Form3.Text1(17).Enabled = True
        Form3.Text1(17).BackColor = QBColor(15)
        Form3.Label1(59).Enabled = True
        
        'Enable base frequency estimate option
        Form3.Label21(46).Enabled = True
        Form3.Command28(44).Enabled = True
        
        
        
    
    ElseIf TPModel = 6 Then
        Form3.Label1(24).Caption = "Hasagawa, Kishino and Yano, 1985"
         'Enable transition transversion rate selection option
        Form3.Text1(17).Text = TPTVRat
        Form3.Text1(17).Enabled = True
        Form3.Text1(17).BackColor = QBColor(15)
        Form3.Label1(59).Enabled = True
        
        'Enable base frequency estimate option
        Form3.Label21(46).Enabled = True
        Form3.Command28(44).Enabled = True
        
        
        Form3.Frame21(6).Enabled = True
        
    
        
    ElseIf TPModel = 5 Then
        Form3.Label1(24).Caption = "General Time reversible"
        'Disable Transition transversion ratio option
        Form3.Text1(17).Text = "0.5"
        Form3.Text1(17).Enabled = False
        Form3.Text1(17).BackColor = Form1.BackColor
        Form3.Label1(59).Enabled = False
        
        'Enable base frequency estimate option
        Form3.Label21(46).Enabled = True
        Form3.Command28(44).Enabled = True
        
      
        
    End If
End If
End Sub

Public Sub SetTBGamma()
If TBGamma = 0 Then
    Form3.Label21(51).Caption = "No rate variation accross sites"
    Form3.Text1(20).Enabled = False
    Form3.Text1(20).ForeColor = RGB(128, 128, 128)
    Form3.Text1(20).BackColor = Form1.BackColor
    Form3.Label1(62).Enabled = False
ElseIf TBGamma = 1 Then

    Form3.Label21(51).Caption = "Gamma-distributed rate variation"
    
    Form3.Text1(20).Enabled = True
    Form3.Text1(20).ForeColor = 0
    Form3.Text1(20).BackColor = RGB(255, 255, 255)
    Form3.Label1(62).Enabled = True
    
ElseIf TBGamma = 2 Then
    Form3.Label21(51).Caption = "Auto-correlated gamma-distributed rate variation"
ElseIf TBGamma = 3 Then
ElseIf TBGamma = 4 Then
Else
End If
End Sub
Public Sub SetTBModel()

If TBModel = 0 Then
    Form3.Label1(61).Caption = "All 6 substitution types are equally likely"
ElseIf TBModel = 1 Then
    Form3.Label1(61).Caption = "Transitions/transversions can be unequally likely "
Else
    Form3.Label1(61).Caption = "All 6 substitution types can be unequally likely"
End If
 Form3.Label1(61).Refresh
 End Sub
Public Sub SetF3Vals(BMFlag)
Dim xBSRndNumSeed As Long, x As Long, WeightedFlag As Long, MaDistanceX As Long, PNum As Long, xGCOutfileName As String, xGCEndLen As Long, xGCMissmatchPen As Single
Dim tDbl As Single, RetSiteFlag As Long, xBSCDSpan As Long, xBSCDStepSize As Long, xBSCDecreaseStepFlag As Long, xGCMaxPermPVal As Single, xGCNumPerms As Long, xGCMaxOverlapFrags As Long, xGCMinPairScore As Long, xGCOffsetAddjust As Double, xGCMaxPairFrags As Long, xGCMinFragLen As Long, xGCMinPolyInFrag As Long
OKPress = 0
With Form3

        OLSeq = .List1.TopIndex

        If SpacerFlag = 0 Then
            .Option2.Value = 1
        ElseIf SpacerFlag = 1 Then
            .Option3.Value = 1
        ElseIf SpacerFlag = 2 Then
            .Option4.Value = 1
        ElseIf SpacerFlag = 3 Then
            .Option5.Value = 1
        ElseIf SpacerFlag = 4 Then
            .Option6.Value = 1
        ElseIf SpacerFlag = 5 Then
            .Option6.Value = 1
        End If

        .Frame4(SpacerFlag).Visible = True
        .Frame4(SpacerFlag).ZOrder
        HomologyIndicatorT = HomologyIndicator
        CircularFlagT = CircularFlag
        WeightedFlagT = WeightedFlag
        ShowPlotFlagT = ShowPlotFlag
        MCFlagT = MCFlag
        MaDistanceX = MaDistance
        
        'Do visRD settings
        xVisRDWin = VisRDWin
        Form3.Text1(44) = CStr(VisRDWin)
        'do recrate settings
        xGCFlag = GCFlag
        .Text2 = XOverWindowX
        .Text6(0) = StartRho
        .Text6(1) = BlockPen
        .Text6(2) = FreqCo
        .Text6(3) = FreqCoMD
        .Text6(4) = GCTractLen
        .Text6(5) = MCMCUpdates
        
        xBlockPen = BlockPen
        xStartRho = StartRho
        xMCMCUpdates = MCMCUpdates
        xFreqCo = FreqCo
        xFreqCoMD = FreqCoMD
        xGCFlag = GCFlag
        xGCTractLen = GCTractLen
        If GCFlag = 0 Then
            .Label2(4).Caption = "Do not use gene conversion model"
            .Label2(5).Enabled = False
            .Text6(4).Enabled = False
            .Text6(4).BackColor = Form1.BackColor
        Else
            .Label2(4).Caption = "Use gene conversion model"
            .Label2(5).Enabled = True
            .Text6(4).Enabled = True
            .Text6(4).BackColor = RGB(255, 255, 255)
        End If
        
        
        If ConservativeGroup = 0 Or ConservativeGroup > 1 Then
            ConservativeGroup = 0
            Form3.Label15.Caption = "Group recombinants realistically"
            Form3.Label15.ToolTipText = "The program will only infer that recombinants are descended from the same common ancestor if they have similar breakpoints and if they tend to group together in phylogenetic trees"
            Form3.Command8.ToolTipText = "The program will only infer that recombinants are descended from the same common ancestor if they have similar breakpoints and if they tend to group together in phylogenetic trees"

        Else
            Form3.Label15.Caption = "Group recombinants conservatively"
            Form3.Label15.ToolTipText = "The program will infer that recombinants are descended from the same common ancestor if they have similar breakpoints (even if they don't tend to group together in phylogenetic trees)"
            Form3.Command8.ToolTipText = "The program will infer that recombinants are descended from the same common ancestor if they have similar breakpoints (even if they don't tend to group together in phylogenetic trees)"

        End If
        
   
         .Picture27.Refresh
        
        If BMFlag = 1 Then
        
            
            
            
            
            If CircularFlag = 1 Then
                .Label16 = "Sequences are circular"
            Else
                .Label16 = "Sequences are linear"
            End If
    
            '.Text2.Text = Form1.Text5.Text
            .Text3.Text = Form1.Text1.Text
    
            If ShowPlotFlagT = 0 Then
                .Label20 = "Do not show plots during scan"
            ElseIf ShowPlotFlagT = 1 Then
                .Label20 = "Show plots during scan"
            ElseIf ShowPlotFlagT = 2 Then
                .Label20 = "Show overview during scan"
            End If
    
            If MCFlag = 1 Then
                .Label23 = "No multiple comparison correction"
            ElseIf MCFlag = 0 Then
                .Label23 = "Bonferroni correction"
            ElseIf MCFlag = 2 Then
                .Label23 = "Step down correction"
            End If
            xPermTypeFlag = PermTypeFlag
            .Text1(37) = GPerms
            If PermTypeFlag = 1 Then
            
                .Label1(54) = "Shuffle alignment columns"
            Else
                
                .Label1(54) = "Use SEQGEN parametric simulations"
            End If
            
            DontRefreshFlag = 1
    
            Dim TotT As Double
            xAllowConflict = AllowConflict
            
            If AllowConflict = 0 Then
                .Check13 = 1
            Else
                .Check13 = 0
            End If
           
           
            TotT = 0
            PNum = 0
            If DoScans(0, 0) = 1 Then
                .Check4.Value = 1
                TotT = TotT + AnalT(0)
                PNum = PNum + 1
            Else
                .Check4.Value = 0
            End If
     
            If DoScans(0, 1) = 1 Then
                .Check5.Value = 1
                TotT = TotT + AnalT(1)
                PNum = PNum + 1
            Else
                .Check5.Value = 0
            End If
    
            If DoScans(0, 2) = 1 Then
                .Check1.Value = 1
                TotT = TotT + AnalT(2)
                PNum = PNum + 1
            Else
                .Check1.Value = 0
            End If
    
            If DoScans(0, 3) = 1 Then
                .Check2.Value = 1
                TotT = TotT + AnalT(3)
                PNum = PNum + 1
            Else
                .Check2.Value = 0
            End If
    
            If DoScans(0, 4) = 1 Then
                .Check3.Value = 1
                TotT = TotT + AnalT(4)
                PNum = PNum + 1
            Else
                .Check3.Value = 0
            End If
    
            If DoScans(0, 5) = 1 Then
                .Check6.Value = 1
                TotT = TotT + AnalT(5)
                PNum = PNum + 1
            Else
                .Check6.Value = 0
            End If
            
            If DoScans(0, 8) = 1 Then
                .Check12.Value = 1
                TotT = TotT + AnalT(6)
                PNum = PNum + 1
            Else
                .Check12.Value = 0
            End If
                
            If SEventNumber = 0 Then
                DontRefreshFlag = 0
            End If
            xConsensusProg = ConsensusProg
            
            
            If ConsensusProg = 0 Then
                .Label43 = "List all events"
            ElseIf ConsensusProg = 1 Then
                .Label43 = "List events detected by >1 method"
            ElseIf ConsensusProg = 2 Then
                .Label43 = "List events detected by >2 methods"
            ElseIf ConsensusProg = 3 Then
                .Label43 = "List events detected by >3 methods"
            ElseIf ConsensusProg = 4 Then
                .Label43 = "List events detected by >4 methods"
            ElseIf ConsensusProg = 5 Then
                .Label43 = "List events detected by >5 methods"
            ElseIf ConsensusProg = 6 Then
                .Label43 = "List events detected by >6 methods"
            End If
             
            .Check10 = ForcePhylE
            
            
            
            .Check9 = PolishBPFlag
            
            .Check11 = RealignFlag
            
            Dim PWidth As Integer
            Dim CurXpos As Double
    
            PWidth = .Picture27.Width - 100
            CurXpos = 25
            .Picture27.Picture = LoadPicture()
            DontRefreshFlag = 0
            
           
            
            Call RefreshTimes
            
        End If
        
        If GCSeqTypeFlag = 0 Then
            .Label29.Caption = "Automatic detection of sequence type"
            .Label32.Enabled = False
            .Command28(4).Enabled = False
        ElseIf GCSeqTypeFlag = 1 Then
            .Label29.Caption = "Sequences are DNA"
            .Label32.Enabled = False
            .Command28(4).Enabled = False
        ElseIf GCSeqTypeFlag = 2 Then
            .Label29.Caption = "Sequences are DNA coding region"
            .Command28(4).Enabled = True
            .Label32.Enabled = True
        ElseIf GCSeqTypeFlag = 3 Then
            .Label29.Caption = "Sequences are protein"
            .Command28(4).Enabled = False
            .Label32.Enabled = False
        End If

        If GCIndelFlag = 0 Then
            .Label31.Caption = "Ignor indels"
        ElseIf GCIndelFlag = 1 Then
            .Label31.Caption = "Treat indel blocs as one polymorphism"
        ElseIf GCIndelFlag = 2 Then
            .Label31.Caption = "Treat each indel site as a polymorphism"
        End If

        .Label32.Caption = "Use standard (nuclear) code"
        

        If GCMonoSiteFlag = 0 Then
            .Label39.Caption = "Do not use monomorphic sites"
        Else
            .Label39.Caption = "Use monomorphic sites"
        End If

        .Text21 = CStr(GCSeqRange(0))
        .Text22 = CStr(GCSeqRange(1))
        

        If GCOutFlag = 0 Then
            .Label27.Caption = "Space separated output"
        ElseIf GCOutFlag = 1 Then
            .Label27.Caption = "Tab separated output"
        ElseIf GCOutFlag = 2 Then
            .Label27.Caption = "DIF-format spreadsheet output"
        ElseIf GCOutFlag = 3 Then
            .Label27.Caption = "Output in all formats"
        End If

        If GCOutFlagII = 0 Then
            .Label33.Caption = "Simple output"
            .Command29.Enabled = False
        Else
            .Label33.Caption = "Maximum output"
            'Command29.Enabled = True
        End If

        If GCSortFlag = 0 Then
            .Label34.Caption = "Sort fragment lists by P-Value"
        ElseIf GCSortFlag = 1 Then
            .Label34.Caption = "Sort lists alphabetically by name"
        ElseIf GCSortFlag = 2 Then
            .Label34.Caption = "Sort lists by P-Value then name"
        End If

        .Text10 = CStr(GCEndLen)
        .Text11 = CStr(GCOffsetAddjust)

        If GCLogFlag = 0 Then
            .Label28.Caption = "Write log file"
        ElseIf GCLogFlag = 1 Then
            .Label28.Caption = "Append existing log file"
        ElseIf GCLogFlag = 2 Then
            .Label28.Caption = "Do not write log file"
        End If

        
        .Text12 = CStr(GCMissmatchPen)
        .Text14 = CStr(GCMaxGlobFrags)
        .Text13 = CStr(GCMaxPairFrags)
        .Text15 = CStr(GCMinFragLen)
        .Text16 = CStr(GCMinPolyInFrag)
        .Text17 = CStr(GCMinPairScore)
        .Text18 = CStr(GCMaxOverlapFrags)
        .Text19 = CStr(GCNumPerms)
        .Text20 = GCMaxPermPVal

        If GCPermPolyFlag = 0 Then
            .Label59.Caption = "Use simple polymorphisms"
        Else
            .Label59.Caption = "Use only multiple polymorphisms"
        End If
        
        If GCtripletflag = 0 Then
            .Label39.Caption = "Scan sequence pairs"
            'Disbable large sections of the interface
            .Command28(2).Enabled = True
            .Command28(4).Enabled = True
            .Text21.Enabled = True
            .Text22.Enabled = True
            .Label48.Enabled = True
            .Label47.Enabled = True
            .Label32.Enabled = True
            .Label29.Enabled = True
            
            .Frame13.Enabled = True
            .Label38.Enabled = True
            .Text14.Enabled = True
            .Text13.Enabled = True
            .Label37.Enabled = True
            
            .Frame16.Enabled = True
            .Label26.Enabled = True
            .Label27.Enabled = True
            .Label33.Enabled = True
            .Label34.Enabled = True
            .Label30.Enabled = True
            .Label35.Enabled = True
            .Label28.Enabled = True
            .Label45.Enabled = True
            .Label46.Enabled = True
            .Label59.Enabled = True
            
            .Text19.Enabled = True
            .Text20.Enabled = True
            
            .Text10.Enabled = True
            .Text11.Enabled = True
            .Command28(0).Enabled = True
            .Command28(5).Enabled = True
            .Command28(6).Enabled = True
            .Command28(1).Enabled = True
            .Command28(7).Enabled = True
            .Text21.BackColor = QBColor(15)
            .Text11.BackColor = QBColor(15)
            .Text10.BackColor = QBColor(15)
            
            .Text20.BackColor = QBColor(15)
            .Text19.BackColor = QBColor(15)
            .Text14.BackColor = QBColor(15)
            .Text13.BackColor = QBColor(15)
            .Text22.BackColor = QBColor(15)
        Else
            .Label39.Caption = "Scan sequence triplets"
            'Disbable large sections of the interface
            .Command28(2).Enabled = False
            .Command28(4).Enabled = False
            .Text21.Enabled = False
            .Text22.Enabled = False
            .Label48.Enabled = False
            .Label47.Enabled = False
            .Label32.Enabled = False
            .Label29.Enabled = False
            
            .Frame13.Enabled = False
            .Label38.Enabled = False
            .Text14.Enabled = False
            .Text13.Enabled = False
            .Label37.Enabled = False
            
            .Frame16.Enabled = False
            .Label26.Enabled = False
            .Label27.Enabled = False
            .Label33.Enabled = False
            .Label34.Enabled = False
            .Label30.Enabled = False
            .Label35.Enabled = False
            .Label28.Enabled = False
            .Label45.Enabled = False
            .Label46.Enabled = False
            .Label59.Enabled = False
            
            .Text19.Enabled = False
            .Text20.Enabled = False
            
            .Text10.Enabled = False
            .Text11.Enabled = False
            .Command28(0).Enabled = False
            .Command28(5).Enabled = False
            .Command28(6).Enabled = False
            .Command28(1).Enabled = False
            .Command28(7).Enabled = False
            .Text21.BackColor = Form1.Command1.BackColor
            .Text11.BackColor = Form1.Command1.BackColor
            .Text10.BackColor = Form1.Command1.BackColor
            
            .Text20.BackColor = Form1.Command1.BackColor
            .Text19.BackColor = Form1.Command1.BackColor
            .Text14.BackColor = Form1.Command1.BackColor
            .Text13.BackColor = Form1.Command1.BackColor
            .Text22.BackColor = Form1.Command1.BackColor
        End If
        
        xGCTripletFlag = GCtripletflag
        'store backed up GC variables
        xGCSeqTypeFlag = GCSeqTypeFlag
        xGCIndelFlag = GCIndelFlag
        
        xGCMonoSiteFlag = GCMonoSiteFlag
        ReDim xGCSeqRange(1)
        xGCSeqRange(0) = GCSeqRange(0)
        xGCSeqRange(1) = GCSeqRange(1)
        xGCOutfileName = GCOutfileName
        xGCOutFlag = GCOutFlag
        xGCOutFlagII = GCOutFlagII
        xGCSortFlag = GCSortFlag
        xGCEndLen = GCEndLen
        xGCOffsetAddjust = GCOffsetAddjust
        xGCLogFlag = GCLogFlag
        xGCMissmatchPen = GCMissmatchPen
        xGCMaxPairFrags = GCMaxPairFrags
        xGCMinFragLen = GCMinFragLen
        xGCMinPolyInFrag = GCMinPolyInFrag
        xGCMinPairScore = GCMinPairScore
        xGCMaxOverlapFrags = GCMaxOverlapFrags
        xGCNumPerms = GCNumPerms
        xGCMaxPermPVal = GCMaxPermPVal
        xGCPermPolyFlag = GCPermPolyFlag
        .Text1(0) = BSStepWin
        .Text1(1) = BSStepSize
        .Text1(5) = BSCutOff * 100
        .Text1(2) = BSBootReps
        .Text1(3) = BSRndNumSeed
        .Text1(28) = BSCoeffVar

        If BSSubModelFlag = 0 Then
            .Label1(4).Caption = "Jukes and Cantor, 1969"
            .Text1(4).Enabled = False
            .Text1(4).BackColor = Form1.BackColor
            .Text1(4).ForeColor = QBColor(8)
            .Text1(4) = 0.5
            .Label1(5).Enabled = False
            .Text1(28).Enabled = False
            .Text1(28).BackColor = Form1.BackColor
            .Text1(28).ForeColor = QBColor(8)
            .Label1(39).Enabled = False
            .Frame21(5).Enabled = False
            .Command28(24).Enabled = False

            For x = 26 To 29
                .Text23(x).BackColor = Form1.BackColor
                .Text23(x).Enabled = False
            Next 'X

            For x = 30 To 34
                .Label21(x).Enabled = False
            Next 'X
        ElseIf BSSubModelFlag = 4 Then
            .Label1(4).Caption = "Similarities"
            .Text1(4).Enabled = False
            .Text1(4).BackColor = Form1.BackColor
            .Text1(4).ForeColor = QBColor(8)
            .Text1(4) = 0.5
            .Label1(5).Enabled = False
            .Text1(28).Enabled = False
            .Text1(28).BackColor = Form1.BackColor
            .Text1(28).ForeColor = QBColor(8)
            .Label1(39).Enabled = False
            .Frame21(5).Enabled = False
            .Command28(24).Enabled = False

            For x = 26 To 29
                .Text23(x).BackColor = Form1.BackColor
                .Text23(x).Enabled = False
            Next 'X

            For x = 30 To 34
                .Label21(x).Enabled = False
            Next 'X
        ElseIf BSSubModelFlag = 1 Then
            .Label1(4).Caption = "Kimura, 1980"
            .Text1(4).Enabled = True
            .Text1(4).BackColor = QBColor(15)
            .Text1(4).ForeColor = QBColor(0)
            .Text1(4) = BSTTRatio
            .Label1(5).Enabled = True
            .Text1(28).Enabled = False
            .Text1(28).BackColor = Form1.BackColor
            .Text1(28).ForeColor = QBColor(8)
            .Label1(39).Enabled = False
            .Frame21(5).Enabled = False
            .Command28(24).Enabled = False

            For x = 26 To 29
                .Text23(x).BackColor = Form1.BackColor
                .Text23(x).Enabled = False
            Next 'X

            For x = 30 To 34
                .Label21(x).Enabled = False
            Next 'X

        ElseIf BSSubModelFlag = 2 Then
            .Label1(4).Caption = "Jin  and  Nei, 1990"
            .Text1(4).Enabled = True
            .Text1(4).BackColor = QBColor(15)
            .Text1(4).ForeColor = QBColor(0)
            .Text1(4) = BSTTRatio
            .Text1(28).Enabled = True
            .Text1(28).BackColor = QBColor(15)
            .Text1(28).ForeColor = QBColor(0)
            .Label1(39).Enabled = True
            .Label1(5).Enabled = True
            .Frame21(5).Enabled = False
            .Command28(24).Enabled = False

            For x = 26 To 29
                .Text23(x).BackColor = Form1.BackColor
                .Text23(x).Enabled = False
            Next 'X

            For x = 30 To 34
                .Label21(x).Enabled = False
            Next 'X

        ElseIf BSSubModelFlag = 3 Then
            .Label1(4).Caption = "Felsenstein, 1984"
            .Text1(4).Enabled = True
            .Text1(4).BackColor = QBColor(15)
            .Text1(4).ForeColor = QBColor(0)
            .Text1(4) = BSTTRatio
            .Text1(28).Enabled = False
            .Text1(28).BackColor = Form1.BackColor
            .Text1(28).ForeColor = QBColor(8)
            .Label1(39).Enabled = False
            .Label1(5).Enabled = True
            .Frame21(5).Enabled = True
            .Command28(24).Enabled = True
            .Label21(34).Enabled = True

            If BSFreqFlag = 0 Then

                For x = 26 To 29
                    .Text23(x).BackColor = Form1.BackColor
                    .Text23(x).Enabled = False
                Next 'X

                For x = 30 To 33
                    .Label21(x).Enabled = False
                Next 'X

            Else

                For x = 26 To 29
                    .Text23(x).BackColor = QBColor(15)
                    .Text23(x).Enabled = True
                Next 'X

                For x = 30 To 33
                    .Label21(x).Enabled = True
                Next 'X

            End If

        End If

        If BSFreqFlag = 0 Then
            .Label21(34).Caption = "Estimate from alignment"
        Else
            .Label21(34).Caption = "User defined"
        End If

        .Text23(28) = BSFreqA
        .Text23(27) = BSFreqC
        .Text23(26) = BSFreqG
        .Text23(29) = BSFreqT

        If BSTypeFlag = 0 Then
            .Label1(37) = "Use distances"
        ElseIf BSTypeFlag = 1 Then
            .Label1(37) = "Use UPGMAs"
        ElseIf BSTypeFlag = 2 Then
            .Label1(37) = "Use neighbour joining trees"
        ElseIf BSTypeFlag = 3 Then
            .Label1(37) = "Use least squares trees"
        ElseIf BSTypeFlag = 4 Then
            .Label1(37) = "Use maximum likelihood trees"
        End If

        
        
        If BSPValFlag = 0 Then
            .Label1(48) = "Use bootstrap value as P-value"
        ElseIf BSPValFlag = 1 Then
            .Label1(48) = "Calculate binomial P-value"
        ElseIf BSPValFlag = 2 Then
            .Label1(48) = "Calculate Chi square P-value"
        End If
        
        .Text1(6) = BSStepWin
        .Text1(7) = BSStepSize
        .Text1(10) = BSBootReps
        '.Check7.Value = BSCCenterFlag
        .Check8.Value = BSCDecreaseStepFlag
        .Text1(8) = BSCDStepSize
        .Text1(11) = BSStepWin
        '.Text1(12) = BSCDBootReps
        .Text1(9) = BSCDSpan

        If .Check8.Value = 1 Then
            .Text1(8).Enabled = True
            .Text1(9).Enabled = True
            .Text1(11).Enabled = True
            .Text1(12).Enabled = True
            .Frame18.Enabled = True
            .Text1(8).BackColor = QBColor(15)
            .Text1(9).BackColor = QBColor(15)
            .Text1(8).ForeColor = QBColor(0)
            .Text1(9).ForeColor = QBColor(0)
            .Label1(7).Enabled = True
            .Label1(10).Enabled = True
            .Label1(14).Enabled = True
            .Label1(15).Enabled = True
        Else
            .Frame18.Enabled = False
            .Text1(8).Enabled = False
            .Text1(9).Enabled = False
            .Text1(11).Enabled = False
            .Text1(12).Enabled = False
            .Text1(8).BackColor = Form1.BackColor
            .Text1(9).BackColor = Form1.BackColor
            .Text1(8).ForeColor = QBColor(8)
            .Text1(9).ForeColor = QBColor(8)
            .Text1(11).BackColor = Form1.BackColor
            .Text1(12).BackColor = Form1.BackColor
            .Text1(11).ForeColor = QBColor(8)
            .Text1(12).ForeColor = QBColor(8)
            .Label1(7).Enabled = False
            .Label1(14).Enabled = False
            .Label1(15).Enabled = False
            .Label1(10).Enabled = False
        End If

        xBSStepWin = BSStepWin
        xBSStepSize = BSStepSize
        xBSCutoff = BSCutOff
        xBSBootReps = BSBootReps
        xBSRndNumSeed = BSRndNumSeed
        xBSSubModelFlag = BSSubModelFlag
        xBSTTRatio = BSTTRatio
        xBSStepWin = BSStepWin
        xBSStepSize = BSStepSize
        xBSBootReps = BSBootReps
        xMatPermNo = MatPermNo
        xBSCDecreaseStepFlag = BSCDecreaseStepFlag
        xBSCDStepSize = BSCDStepSize
        xBSStepWin = BSStepWin
        xBSCDSpan = BSCDSpan
        xBSTypeFlag = BSTypeFlag
        xBSFreqFlag = BSFreqFlag
        xMCProportionFlag = MCProportionFlag
        xMCWinFract = MCWinFract
        xMCStripGapsFlag = MCStripGapsFlag
        xBSPValFlag = BSPValFlag
        'store MaxChi variables

        If MCProportionFlag = 0 Then
            .Label1(11) = "Set window size"
            .Label1(27) = "# Variable sites per window"
            .Text1(21) = MCWinSize
        Else
            .Label1(11) = "Variable window size"
            .Label1(27) = "Fraction of variable sites per window"
            'If Nextno > 0 Then
            .Text1(21) = MCWinFract
            'End If
        End If

        If MCTripletFlag = 0 Then
            .Label1(13) = "Scan sequence triplets"
            '.Command28(14).Enabled = True
            '.Label1(16).ForeColor = QBColor(0)
        Else
            .Label1(13) = "Scan sequence pairs"
            '.Command28(14).Enabled = False
            '.Label1(16).Caption = "Use gaps"
            '.Label1(16).ForeColor = QBColor(8)
        End If

        If MCStripGapsFlag = 0 Then
            .Label1(16) = "Use gaps"
        Else
            .Label1(16) = "Strip gaps"
        End If
        
        
        
        
        
                
        
        xMCTripletFlag = MCTripletFlag
        xMCWinSize = MCWinSize
        xMCSteplen = MCSteplen
        xMCStart = MCStart
        xMCEnd = MCEnd
       
        
        
        
        xCWinFract = CWinFract
        xCProportionFlag = CProportionFlag
        xCWinSize = CWinSize
        
        
        If CProportionFlag = 0 Then
            .Label1(55) = "Set window size"
            .Label1(56) = "# Variable sites per window"
            .Text1(36) = CWinSize
        Else
            .Label1(55) = "Variable window size"
            .Label1(56) = "Fraction of variable sites per window"
            'If Nextno > 0 Then
            .Text1(36) = CWinFract
            'End If
        End If
        
        
        
        
        xLRDModel = LRDModel
        
        
        xSSGapFlag = SSGapFlag
        xSSVarPFlag = SSVarPFlag
        xSSOutlyerFlag = SSOutlyerFlag
        xSSRndSeed = SSRndSeed
        xSSWinLen = SSWinLen
        xSSStep = SSStep
        xSSNumPerms = SSNumPerms
        xSSNumPerms2 = SSNumPerms2
        xSSFastFlag = SSFastFlag
        
        .Text24(0) = SSWinLen
        .Text24(1) = SSStep
        .Text24(2) = SSNumPerms
        .Text24(3) = SSRndSeed
        .Text24(4) = SSNumPerms2
                
        
        
        

        If SSGapFlag = 0 Then
            .Label22(3) = "Strip gaps"
        Else
            .Label22(3) = "Use gaps"
        End If
        
        If SSVarPFlag = 0 Then
            .Label22(4) = "Use all positions"
        ElseIf SSVarPFlag = 1 Then
            .Label22(4) = "Use only 1/2/3/4 variable positions"
        Else
            .Label22(4) = "Use only 1/2/3 variable positions"
        End If
        
        If SSOutlyerFlag = 0 Then
            .Label22(5) = "Use randomised sequence"
        ElseIf SSOutlyerFlag = 1 Then
            .Label22(5) = "Use nearest outlyer"
        Else
            .Label22(5) = "Use most divergent sequence "
        End If
        
        If SSFastFlag = 0 Then
            .Label22(6) = "Do slow exhaustive scan"
        Else
            .Label22(6) = "Do fast scan"
        End If
        
        
        'Phylpro Options
        'xPPWinLen = PPWinLen
        xPPStripGaps = PPStripGaps
        xIncSelf = IncSelf
        'xPPSeed = PPSeed
        'xPPPerms = PPPerms
        .Text4(0) = PPWinLen
        .Text4(1) = PPSeed
        .Text4(2) = PPPerms
        
        If IncSelf = 1 Then
            .Label14(2) = "Use self comparrisons"
        Else
            .Label14(2) = "Do not use self comparrisons"
        End If
        
        If PPStripGaps = 0 Then
            .Label14(1) = "Ignor gaps"
        ElseIf PPStripGaps = 1 Then
            .Label14(1) = "Strip gaps"
        ElseIf PPStripGaps = 2 Then
            .Label14(1) = "Use gaps as fith character"
        End If
        
        If LRDModel = 0 Or LRDModel = 1 Then
            .Frame21(2).Enabled = False

            For x = 14 To 19
                .Label21(x).Enabled = False
            Next 'X

            .Label21(12).Enabled = True
            .Text23(11).Enabled = True
            .Text23(11).ForeColor = QBColor(0)
            .Text23(11).BackColor = QBColor(15)

            For x = 12 To 16
                .Text23(x).ForeColor = QBColor(8)
                .Text23(x).BackColor = Form3.BackColor
            Next 'X

        End If

        If LRDModel = 0 Then
            .Label21(0).Caption = "Hasegawa, Kishino and Yano, 1985"
        ElseIf LRDModel = 1 Then
            .Label21(0).Caption = "Falsenstein, 1984"
        ElseIf LRDModel = 2 Then
            .Label21(0).Caption = "Reversible process"
            .Frame21(2).Enabled = True

            For x = 14 To 19
                .Label21(x).Enabled = True
            Next 'X

            .Label21(12).Enabled = False
            .Text23(11).Enabled = False
            .Text23(11).ForeColor = QBColor(8)
            .Text23(11).BackColor = Form3.BackColor

            For x = 12 To 16
                .Text23(x).ForeColor = QBColor(0)
                .Text23(x).BackColor = QBColor(15)
            Next 'X

        End If

        .Text23(5) = LRDCategs
        .Text23(6) = LRDShape
        .Text23(11) = LRDTvRat
        .Text23(13) = LRDACCoeff
        .Text23(14) = LRDAGCoeff
        .Text23(15) = LRDATCoeff
        .Text23(12) = LRDCGCoeff
        .Text23(16) = LRDCTCoeff
        .Text23(17) = "1"
        xLRDBaseFreqFlag = LRDBaseFreqFlag

        If LRDModel = 1 Then
            .Command28(11).Enabled = True
            .Label21(13).Enabled = True
        Else
            .Command28(11).Enabled = False
            .Label21(13).Enabled = False
        End If

        If LRDBaseFreqFlag = 0 And LRDModel = 1 Then
            .Label21(13).Caption = "Estimate from alignment"

            For x = 8 To 11
                .Label21(x).Enabled = False
            Next 'X

            For x = 7 To 10
                .Text23(x).ForeColor = QBColor(8)
                .Text23(x).BackColor = Form3.BackColor
                .Text23(x).Enabled = False
            Next 'X

        ElseIf LRDBaseFreqFlag = 1 Then
            .Label21(13).Caption = "User defined"

            For x = 8 To 11
                .Label21(x).Enabled = True
            Next 'X

            For x = 7 To 10
                .Text23(x).ForeColor = QBColor(0)
                .Text23(x).BackColor = QBColor(15)
            Next 'X

        End If

        .Text23(9) = LRDAFreq
        .Text23(8) = LRDCFreq
        .Text23(7) = LRDGFreq
        .Text23(10) = LRDTFreq
        .Text23(2) = LRDCodon1
        .Text23(3) = LRDCodon2
        .Text23(4) = LRDCodon3
        .Text23(0) = LRDStep
        .Text23(1) = LRDWinLen
        xLRDRegion = LRDRegion
        xLRDWin = LRDWin
        If LRDRegion > 2 Then LRDRegion = 2
        If LRDRegion < 1 Then LRDRegion = 1
        If LRDRegion = 1 Then
            .Label21(2) = "Test one breakpoint"
            If LRDWin = 0 Then
                .Label21(40) = "Moving partition scan"
            End If
        Else
            .Label21(2) = "Test two breakpoints"
            If LRDWin = 0 Then
                .Label21(40) = "Moving partitions scan"
            End If
        End If
        
        If LRDWin = 0 Then
            .Text23(1).Enabled = False
            .Label21(41).Enabled = False
            .Text23(1).BackColor = Form1.BackColor
            '.Text23(1).ForeColor = 0
            .Label21(2).Enabled = True
            .Command28(40).Enabled = True
        Else
            .Label21(40) = "Sliding window scan"
            .Text23(1).Enabled = True
            .Text23(1).BackColor = QBColor(15)
            '.Text23(1).ForeColor = 0
            .Label21(41).Enabled = True
            .Label21(2).Enabled = False
            .Command28(40).Enabled = False
        End If
        
        'Reticulate stuff

        If RetSiteFlag = 1 Then
            .Label1(17) = "Use only binary sites"
        ElseIf RetSiteFlag = 2 Then
            .Label1(17) = "Use as transition/transversions"
        ElseIf RetSiteFlag = 3 Then
            .Label1(17) = "Use all sites"
        End If
        .Text5(0) = MatPermNo
        
        .Text5(1) = MatWinSize
        .Text5(2) = SHWinLen
        .Text5(9) = SHStep
        
        If NextNo > 0 Then
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Label1(19).Enabled = True
            .Combo4.Enabled = True
        Else
            .Label1(22).Enabled = False
            .Combo2.Enabled = False
            .Label1(19).Enabled = False
            .Combo4.Enabled = False
        End If
        xMatPermNo = MatPermNo
        xMatWinSize = MatWinSize
        xSHWinLen = SHWinLen
        xSHStep = SHStep
        If NextNo > 0 Then
            If TypeSeqNumber > NextNo Then TypeSeqNumber = NextNo
            .Combo2.ListIndex = TypeSeqNumber
            .Combo4.ListIndex = TypeSeqNumber
        End If
        For x = 1 To 8
            .Text5(x).Visible = False
        Next x
        
        
        If .Combo1.ListIndex = 0 Then 'Compatibility Matrix
            .Command28(15).Enabled = True
            .Label1(17).Enabled = True
            .Label1(22).Enabled = False
            .Combo2.Enabled = False
            
            .Text5(0).Enabled = True
            .Text5(0).BackColor = RGB(255, 255, 255)
            
            .Text5(1).Enabled = False
            .Text5(1).BackColor = Form1.BackColor
            .Text5(1).BackColor = Form1.BackColor
            
            .Label1(26).Enabled = True
            .Label1(57).Enabled = False
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = False
        ElseIf .Combo1.ListIndex = 1 Then 'Compatibility Matrix (Trevor Bruen)
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = False
            .Text5(0).BackColor = Form1.BackColor
            .Text5(1).Enabled = True
            .Text5(1).BackColor = RGB(255, 255, 255)
            .Label1(26).Enabled = False
            .Label1(57).Enabled = True
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = True
        ElseIf .Combo1.ListIndex = 2 Or .Combo1.ListIndex = 3 Then 'Shimodiara-hasegawa and RF matrix
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = False
            .Text5(0).BackColor = Form1.BackColor
            .Text5(1).Enabled = True
            .Text5(1).BackColor = RGB(255, 255, 255)
            .Label1(26).Enabled = False
            .Label1(57).Enabled = True
            .Text5(2).Visible = True
            .Text5(9).Enabled = True
            .Text5(9).BackColor = RGB(255, 255, 255)
            .Text5(9).ForeColor = 0
            .Label1(73).Enabled = True
            .Command28(19).Enabled = True
        ElseIf .Combo1.ListIndex = 4 Then 'Modularity mastrix
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = False
            .Text5(0).BackColor = Form1.BackColor
            .Text5(1).Enabled = True
            .Text5(1).BackColor = RGB(255, 255, 255)
            .Label1(26).Enabled = False
            .Label1(57).Enabled = True
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = True
        ElseIf .Combo1.ListIndex = 5 Then 'recombination matrix
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = False
            .Text5(0).BackColor = Form1.BackColor
            .Text5(1).Enabled = False
            .Text5(1).BackColor = Form1.BackColor
            .Label1(26).Enabled = False
            .Label1(57).Enabled = False
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = True
        ElseIf .Combo1.ListIndex = 6 Then 'recombination region count matrix
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = False
            .Text5(0).BackColor = Form1.BackColor
            .Text5(1).Enabled = False
            .Text5(1).BackColor = Form1.BackColor
            .Label1(26).Enabled = False
            .Label1(57).Enabled = False
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = True
        ElseIf .Combo1.ListIndex = 7 Then 'Breakpoint matrix
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = False
            .Text5(0).BackColor = Form1.BackColor
            .Text5(1).Enabled = True
            .Text5(1).BackColor = RGB(255, 255, 255)
            .Label1(26).Enabled = False
            .Label1(57).Enabled = True
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = True
        ElseIf .Combo1.ListIndex = 8 Then 'Breakpoint idstribution plot
            .Command28(15).Enabled = False
            .Label1(17).Enabled = False
            .Label1(22).Enabled = True
            .Combo2.Enabled = True
            .Text5(0).Enabled = True
            .Text5(0).BackColor = RGB(255, 255, 255)
            .Text5(1).Enabled = True
            .Text5(1).BackColor = RGB(255, 255, 255)
            .Label1(26).Enabled = True
            .Label1(57).Enabled = True
            .Text5(1).Visible = True
            .Text5(9).Enabled = False
            .Text5(9).BackColor = Form1.BackColor
            .Text5(9).ForeColor = RGB(128, 128, 128)
            .Label1(73).Enabled = False
            .Command28(19).Enabled = False
        End If
        If .Combo1.ListIndex <> 0 Then
            Call DoColourScale
        Else
            Form3.Picture1.BackColor = Form1.BackColor
        End If
        If NextNo = 0 Then
            .Label1(22).Enabled = False
            .Combo2.Enabled = False
            .Label1(19).Enabled = False
            .Combo4.Enabled = False
        End If
        

        'distance plot stuff
        xDPBFreqFlag = DPBFreqFlag
        xDPModelFlag = DPModelFlag
        xDPTVRatio = DPTVRatio
        .Text1(13) = DPWindow
        .Text1(14) = DPStep

        If DPBFreqFlag = 0 Then
            .Label21(20).Caption = "Estimate from alignment"
        Else
            .Label21(20).Caption = "User defined"
        End If

        .Text23(19) = DPBFreqA
        .Text23(20) = DPBFreqC
        .Text23(21) = DPBFreqG
        .Text23(18) = DPBFreqT
        .Text1(29) = DPCoeffVar

        If DPModelFlag = 0 Then
            .Label1(21).Caption = "Jukes and Cantor, 1969"
            .Frame21(3).Enabled = False
            tDbl = 0.5
            .Text1(15).Text = tDbl
            .Text1(15).Enabled = False
            .Text1(15).BackColor = Form1.BackColor
            .Label1(20).Enabled = False
            .Text1(29).Enabled = False
            .Text1(29).BackColor = Form1.BackColor
            .Text1(29).ForeColor = QBColor(8)
            .Label1(40).Enabled = False
            .Label21(20).Enabled = False
            .Command28(17).Enabled = False
            .Text23(18).BackColor = Form1.BackColor
            .Text23(19).BackColor = Form1.BackColor
            .Text23(20).BackColor = Form1.BackColor
            .Text23(21).BackColor = Form1.BackColor
            .Text23(18).Enabled = False
            .Text23(19).Enabled = False
            .Text23(20).Enabled = False
            .Text23(21).Enabled = False
            .Label21(21).Enabled = False
            .Label21(22).Enabled = False
            .Label21(23).Enabled = False
            .Label21(24).Enabled = False
        ElseIf DPModelFlag = 4 Then
            .Label1(21).Caption = "Similarities"
            .Frame21(3).Enabled = False
            tDbl = 0.5
            .Text1(15).Text = tDbl
            .Text1(15).Enabled = False
            .Text1(15).BackColor = Form1.BackColor
            .Label1(20).Enabled = False
            .Text1(29).Enabled = False
            .Text1(29).BackColor = Form1.BackColor
            .Text1(29).ForeColor = QBColor(8)
            .Label1(40).Enabled = False
            .Label21(20).Enabled = False
            .Command28(17).Enabled = False
            .Text23(18).BackColor = Form1.BackColor
            .Text23(19).BackColor = Form1.BackColor
            .Text23(20).BackColor = Form1.BackColor
            .Text23(21).BackColor = Form1.BackColor
            .Text23(18).Enabled = False
            .Text23(19).Enabled = False
            .Text23(20).Enabled = False
            .Text23(21).Enabled = False
            .Label21(21).Enabled = False
            .Label21(22).Enabled = False
            .Label21(23).Enabled = False
            .Label21(24).Enabled = False
        ElseIf DPModelFlag = 1 Then
            .Label1(21).Caption = "Kimura, 1980"
            .Text1(15).Text = DPTVRatio
            .Text1(15).Enabled = True
            .Text1(15).BackColor = QBColor(15)
            .Label1(20).Enabled = True
            .Text1(29).Enabled = False
            .Text1(29).BackColor = Form1.BackColor
            .Text1(29).ForeColor = QBColor(8)
            .Label1(40).Enabled = False
            .Frame21(3).Enabled = False
            .Label21(20).Enabled = False
            .Command28(17).Enabled = False
            .Text23(18).BackColor = Form1.BackColor
            .Text23(19).BackColor = Form1.BackColor
            .Text23(20).BackColor = Form1.BackColor
            .Text23(21).BackColor = Form1.BackColor
            .Text23(18).Enabled = False
            .Text23(19).Enabled = False
            .Text23(20).Enabled = False
            .Text23(21).Enabled = False
            .Label21(21).Enabled = False
            .Label21(22).Enabled = False
            .Label21(23).Enabled = False
            .Label21(24).Enabled = False
        ElseIf DPModelFlag = 2 Then
            .Label1(21).Caption = "Jin  and  Nei, 1990"
            .Text1(15).Text = DPTVRatio
            .Text1(15).Enabled = True
            .Text1(15).BackColor = QBColor(15)
            .Label1(20).Enabled = True
            .Text1(29).Enabled = True
            .Text1(29).BackColor = QBColor(15)
            .Text1(29).ForeColor = QBColor(0)
            .Label1(40).Enabled = True
            .Frame21(3).Enabled = False
            .Label21(20).Enabled = False
            .Command28(17).Enabled = False
            .Text23(18).BackColor = Form1.BackColor
            .Text23(19).BackColor = Form1.BackColor
            .Text23(20).BackColor = Form1.BackColor
            .Text23(21).BackColor = Form1.BackColor
            .Text23(18).Enabled = False
            .Text23(19).Enabled = False
            .Text23(20).Enabled = False
            .Text23(21).Enabled = False
            .Label21(21).Enabled = False
            .Label21(22).Enabled = False
            .Label21(23).Enabled = False
            .Label21(24).Enabled = False
        ElseIf DPModelFlag = 3 Then
            .Label1(21).Caption = "Felsenstein, 1984"
            .Text1(15).Text = DPTVRatio
            .Text1(15).Enabled = True
            .Text1(15).BackColor = QBColor(15)
            .Label1(20).Enabled = True
            .Text1(29).Enabled = False
            .Text1(29).BackColor = Form1.BackColor
            .Text1(29).ForeColor = QBColor(8)
            .Label1(40).Enabled = False
            .Frame21(3).Enabled = True
            .Label21(20).Enabled = True
            .Command28(17).Enabled = True
            .Text23(18).BackColor = QBColor(15)
            .Text23(19).BackColor = QBColor(15)
            .Text23(20).BackColor = QBColor(15)
            .Text23(21).BackColor = QBColor(15)

            If DPBFreqFlag = 1 Then
                .Text23(18).Enabled = True
                .Text23(19).Enabled = True
                .Text23(20).Enabled = True
                .Text23(21).Enabled = True
                .Label21(21).Enabled = True
                .Label21(22).Enabled = True
                .Label21(23).Enabled = True
                .Label21(24).Enabled = True
            Else
                .Text23(18).Enabled = False
                .Text23(19).Enabled = False
                .Text23(20).Enabled = False
                .Text23(21).Enabled = False
                .Label21(21).Enabled = False
                .Label21(22).Enabled = False
                .Label21(23).Enabled = False
                .Label21(24).Enabled = False
            End If

        End If

        'TOPAL stuff
        '    Public TONumSeqs As Integer, TOPFlag As Integer, TORndNum As Integer, TOModel As Integer, TOTreeType As Integer, TOPerms As Integer, TOWinLen As Integer, TOStepSize As Integer, TOSmooth As Integer
        'Public TOHigh As Double, MatAverage As Double, TOPower As Double, TOPValCOff As Double, TOTvTs As Double, TOFreqFlag As Double, TOFreqA As Double, TOFreqC As Double, TOFreqG As Double, TOFreqT As Double
        '          xdpfreqflag = DPBFreqFlag
        '          xDPModelFlag = DPModelFlag
        '          xDPTVRatio = DPTVRatio
        .Text1(22) = TOWinLen
        .Text1(19) = TOStepSize

        If TOFreqFlag = 0 Then
            .Label21(29).Caption = "Estimate from alignment"
        Else
            .Label21(29).Caption = "User defined"
        End If

        .Text23(24) = TOFreqA
        .Text23(23) = TOFreqC
        .Text23(22) = TOFreqG
        .Text23(25) = TOFreqT
        .Text1(30) = TOCoeffVar

        If TOModel = 0 Then
            .Label1(25).Caption = "Jukes and Cantor, 1969"
            .Frame21(4).Enabled = False
            .Text1(16).Text = "0.5"
            .Text1(16).Enabled = False
            .Text1(16).BackColor = Form1.BackColor
            .Label1(28).Enabled = False
            .Text1(30).Enabled = False
            .Text1(30).BackColor = Form1.BackColor
            .Text1(30).ForeColor = QBColor(8)
            .Label1(41).Enabled = False
            .Label21(29).Enabled = False
            .Command28(20).Enabled = False
            .Text23(25).BackColor = Form1.BackColor
            .Text23(24).BackColor = Form1.BackColor
            .Text23(23).BackColor = Form1.BackColor
            .Text23(22).BackColor = Form1.BackColor
            .Text23(25).Enabled = False
            .Text23(24).Enabled = False
            .Text23(23).Enabled = False
            .Text23(22).Enabled = False
            .Label21(28).Enabled = False
            .Label21(27).Enabled = False
            .Label21(26).Enabled = False
            .Label21(25).Enabled = False
        ElseIf TOModel = 1 Then
            .Label1(25).Caption = "Kimura, 1980"
            .Text1(16).Text = TOTvTs
            .Text1(16).Enabled = True
            .Text1(16).BackColor = QBColor(15)
            .Label1(29).Enabled = True
            .Text1(30).Enabled = False
            .Text1(30).BackColor = Form1.BackColor
            .Text1(30).ForeColor = QBColor(8)
            .Label1(41).Enabled = False
            .Frame21(4).Enabled = False
            .Label21(29).Enabled = False
            .Command28(20).Enabled = False
            .Text23(25).BackColor = Form1.BackColor
            .Text23(24).BackColor = Form1.BackColor
            .Text23(23).BackColor = Form1.BackColor
            .Text23(22).BackColor = Form1.BackColor
            .Text23(25).Enabled = False
            .Text23(24).Enabled = False
            .Text23(23).Enabled = False
            .Text23(22).Enabled = False
            .Label21(28).Enabled = False
            .Label21(27).Enabled = False
            .Label21(26).Enabled = False
            .Label21(25).Enabled = False
        ElseIf TOModel = 2 Then
            .Label1(25).Caption = "Jin  and  Nei, 1990"
            .Text1(16).Text = TOTvTs
            .Text1(16).Enabled = True
            .Text1(16).BackColor = QBColor(15)
            .Label1(29).Enabled = True
            .Text1(30).Enabled = True
            .Text1(30).BackColor = QBColor(15)
            .Text1(30).ForeColor = QBColor(0)
            .Label1(41).Enabled = True
            .Frame21(4).Enabled = False
            .Label21(29).Enabled = False
            .Command28(20).Enabled = False
            .Text23(25).BackColor = Form1.BackColor
            .Text23(24).BackColor = Form1.BackColor
            .Text23(23).BackColor = Form1.BackColor
            .Text23(22).BackColor = Form1.BackColor
            .Text23(25).Enabled = False
            .Text23(24).Enabled = False
            .Text23(23).Enabled = False
            .Text23(22).Enabled = False
            .Label21(28).Enabled = False
            .Label21(27).Enabled = False
            .Label21(26).Enabled = False
            .Label21(25).Enabled = False
        ElseIf TOModel = 3 Then
            .Label1(25).Caption = "Felsenstein, 1984"
            .Text1(16).Text = TOTvTs
            .Text1(16).Enabled = True
            .Text1(16).BackColor = QBColor(15)
            .Label1(29).Enabled = True
            .Text1(30).Enabled = False
            .Text1(30).BackColor = Form1.BackColor
            .Text1(30).ForeColor = QBColor(8)
            .Label1(41).Enabled = False
            .Frame21(4).Enabled = True
            .Label21(29).Enabled = True
            .Command28(20).Enabled = True
            .Text23(25).BackColor = QBColor(15)
            .Text23(24).BackColor = QBColor(15)
            .Text23(23).BackColor = QBColor(15)
            .Text23(22).BackColor = QBColor(15)

            If TOFreqFlag = 1 Then
                .Text23(25).Enabled = True
                .Text23(24).Enabled = True
                .Text23(23).Enabled = True
                .Text23(22).Enabled = True
                .Label21(28).Enabled = True
                .Label21(27).Enabled = True
                .Label21(26).Enabled = True
                .Label21(25).Enabled = True
            Else
                .Text23(25).Enabled = False
                .Text23(24).Enabled = False
                .Text23(23).Enabled = False
                .Text23(22).Enabled = False
                .Label21(28).Enabled = False
                .Label21(27).Enabled = False
                .Label21(26).Enabled = False
                .Label21(25).Enabled = False
            End If

        End If

        '  TOTreeType As Integer, TOPerms As Integer, TOWinLen As Integer, TOStepSize As Integer, TOSmooth As Integer
        'Public TOHigh As Double, MatAverage As Double, TOPower As Double, TOPValCOff As Double, TOTvTs As Double, TOFreqFlag As Double, TOFreqA As Double, TOFreqC As Double, TOFreqG As Double, TOFreqT As Double
        .Text1(23) = TOSmooth
        .Text1(26) = TORndNum
        .Text1(25) = TOPower
        .Text1(27) = TOPerms
        .Text1(24) = TOPValCOff

        If TOTreeType = 0 Then
            .Label1(34) = "Construct only LS trees"
        Else
            .Label1(34) = "Construct NJ and LS trees"
        End If

        xTOWinLen = TOWinLen
        xToTreeType = TOTreeType
        xToFreqFlag = TOFreqFlag
        xTOTsTv = TOTvTs
        xTOModel = TOModel
        'Tree Options
        .Text1(33) = TBSReps
        .Text1(34) = TRndSeed
        .Text1(32) = TTVRat


        
        

        If TModel = 0 Then
            .Label1(44).Caption = "Jukes and Cantor, 1969"
            .Frame21(6).Enabled = False
            .Text1(32).Text = "0.5"
            .Text1(32).Enabled = False
            .Text1(32).BackColor = Form1.BackColor
            .Label1(43).Enabled = False
            .Text1(31).Enabled = False
            .Text1(31).BackColor = Form1.BackColor
            .Text1(31).ForeColor = QBColor(8)
            .Label1(42).Enabled = False
            .Label21(35).Enabled = False
            .Command28(26).Enabled = False
            .Text23(30).BackColor = Form1.BackColor
            .Text23(31).BackColor = Form1.BackColor
            .Text23(32).BackColor = Form1.BackColor
            .Text23(33).BackColor = Form1.BackColor
            .Text23(30).Enabled = False
            .Text23(31).Enabled = False
            .Text23(32).Enabled = False
            .Text23(33).Enabled = False
            .Label21(36).Enabled = False
            .Label21(37).Enabled = False
            .Label21(38).Enabled = False
            .Label21(39).Enabled = False
        ElseIf TModel = 1 Then
            .Label1(44).Caption = "Kimura, 1980"
            .Text1(32).Text = TTVRat
            .Text1(32).Enabled = True
            .Text1(32).BackColor = QBColor(15)
            .Label1(43).Enabled = True
            .Text1(31).Enabled = False
            .Text1(31).BackColor = Form1.BackColor
            .Text1(31).ForeColor = QBColor(8)
            .Label1(42).Enabled = False
            .Frame21(6).Enabled = False
            .Label21(35).Enabled = False
            .Command28(26).Enabled = False
            .Text23(30).BackColor = Form1.BackColor
            .Text23(31).BackColor = Form1.BackColor
            .Text23(32).BackColor = Form1.BackColor
            .Text23(33).BackColor = Form1.BackColor
            .Text23(30).Enabled = False
            .Text23(31).Enabled = False
            .Text23(32).Enabled = False
            .Text23(33).Enabled = False
            .Label21(36).Enabled = False
            .Label21(37).Enabled = False
            .Label21(38).Enabled = False
            .Label21(39).Enabled = False
        ElseIf TModel = 2 Then
            .Label1(44).Caption = "Jin  and  Nei, 1990"
            .Text1(32).Text = TTVRat
            .Text1(32).Enabled = True
            .Text1(32).BackColor = QBColor(15)
            .Label1(43).Enabled = True
            .Text1(31).Enabled = True
            .Text1(31).BackColor = QBColor(15)
            .Text1(31).ForeColor = QBColor(0)
            .Label1(42).Enabled = True
            .Frame21(6).Enabled = False
            .Label21(35).Enabled = False
            .Command28(26).Enabled = False
            .Text23(30).BackColor = Form1.BackColor
            .Text23(31).BackColor = Form1.BackColor
            .Text23(32).BackColor = Form1.BackColor
            .Text23(33).BackColor = Form1.BackColor
            .Text23(30).Enabled = False
            .Text23(31).Enabled = False
            .Text23(32).Enabled = False
            .Text23(33).Enabled = False
            .Label21(36).Enabled = False
            .Label21(37).Enabled = False
            .Label21(38).Enabled = False
            .Label21(39).Enabled = False
        ElseIf TModel = 3 Then
            .Label1(44).Caption = "Felsenstein, 1984"
            .Text1(32).Text = TTVRat
            .Text1(32).Enabled = True
            .Text1(32).BackColor = QBColor(15)
            .Label1(43).Enabled = True
            .Text1(31).Enabled = False
            .Text1(31).BackColor = Form1.BackColor
            .Text1(31).ForeColor = QBColor(8)
            .Label1(42).Enabled = False
            .Frame21(6).Enabled = True
            .Label21(35).Enabled = True
            .Command28(26).Enabled = True
            .Text23(30).BackColor = QBColor(15)
            .Text23(31).BackColor = QBColor(15)
            .Text23(32).BackColor = QBColor(15)
            .Text23(33).BackColor = QBColor(15)

            If TBaseFreqFlag = 1 Then
                .Text23(30).BackColor = QBColor(15)
                .Text23(31).BackColor = QBColor(15)
                .Text23(32).BackColor = QBColor(15)
                .Text23(33).BackColor = QBColor(15)
                .Text23(30).Enabled = True
                .Text23(31).Enabled = True
                .Text23(32).Enabled = True
                .Text23(33).Enabled = True
                .Label21(36).Enabled = True
                .Label21(37).Enabled = True
                .Label21(38).Enabled = True
                .Label21(39).Enabled = True
            Else
                .Text23(30).BackColor = Form1.BackColor
                .Text23(31).BackColor = Form1.BackColor
                .Text23(32).BackColor = Form1.BackColor
                .Text23(33).BackColor = Form1.BackColor
                .Text23(30).Enabled = False
                .Text23(31).Enabled = False
                .Text23(32).Enabled = False
                .Text23(33).Enabled = False
                .Label21(36).Enabled = False
                .Label21(37).Enabled = False
                .Label21(38).Enabled = False
                .Label21(39).Enabled = False
            End If

        End If

        .Text1(31) = TCoeffVar
        '     TBaseFreqFlag
        .Text23(31) = TAfreq
        .Text23(32) = TCFreq
        .Text23(33) = TGFreq
        .Text23(30) = TTFreq
        .Text1(35) = TPower
        ' Write #1, TNegBLFlag,

        If TBaseFreqFlag = 0 Then
            .Label21(35).Caption = "Estimate from alignment"
        Else
            .Label21(35).Caption = "User defined"
        End If

        If TNegBLFlag = 0 Then
            .Label1(49) = "Negative branch lengths not allowed"
        Else
            .Label1(49) = "Negative branch lengths allowed"
        End If

        If TSubRepsFlag = 0 Then
            .Label1(50) = "Do not do subreplicates"
        Else
            .Label1(50) = "Do subreplicates"
        End If

        If TGRFlag = 0 Then
            .Label1(51) = "Do not do global rearrangements"
        Else
            .Label1(51) = "Do global rearrangements"
        End If

        If TRndIOrderFlag = 0 Then
            .Label1(52) = "Do not randomise input order"
        Else
            .Label1(52) = "Randomise input order"
        End If
        
        
        xTModel = TModel
        xTBaseFreqFlag = TBaseFreqFlag
        
        xTPModel = TPModel
        xTPBPFEstimate = TPBPFEstimate
        .Text1(17) = TPTVRat
        .Text1(18) = TPInvSites
        .Text23(34) = TPGamma
        .Text23(35) = RAxMLCats
        .Text23(42) = TPAlpha
         xModelTestFlag = ModelTestFlag
        
        Call SetMLModel
       
        If ModelTestFlag = 0 Then
            .Label1(69) = "User specified model"
            
        ElseIf ModelTestFlag = 1 Then
            .Label1(69) = "Automatic model selection (fast with PhyML1)"
            .Label1(24).Caption = "Jukes and Cantor, 1969"
            .Frame21(6).Enabled = False
            
            'Disable Transition transversion ratio option
            .Text1(17).Text = "0.5"
            .Text1(17).Enabled = False
            .Text1(17).BackColor = Form1.BackColor
            .Label1(59).Enabled = False
            
            'Disable base frequency estimate option
            .Label21(46).Enabled = False
            .Command28(44).Enabled = False
            
            
            
            .Text23(30).BackColor = Form1.BackColor
            .Text23(31).BackColor = Form1.BackColor
            .Text23(32).BackColor = Form1.BackColor
            .Text23(33).BackColor = Form1.BackColor
            .Text23(30).Enabled = False
            .Text23(31).Enabled = False
            .Text23(32).Enabled = False
            .Text23(33).Enabled = False
            .Label21(36).Enabled = False
            .Label21(37).Enabled = False
            .Label21(38).Enabled = False
            .Label21(39).Enabled = False
        ElseIf ModelTestFlag = 2 Then
            .Label1(69) = "Automatic model selection (slower with PhyML3)"
            .Label1(24).Caption = "Jukes and Cantor, 1969"
            .Frame21(6).Enabled = False
            
            'Disable Transition transversion ratio option
            .Text1(17).Text = "0.5"
            .Text1(17).Enabled = False
            .Text1(17).BackColor = Form1.BackColor
            .Label1(59).Enabled = False
            
            'Disable base frequency estimate option
            .Label21(46).Enabled = False
            .Command28(44).Enabled = False
            
            
            
            .Text23(30).BackColor = Form1.BackColor
            .Text23(31).BackColor = Form1.BackColor
            .Text23(32).BackColor = Form1.BackColor
            .Text23(33).BackColor = Form1.BackColor
            .Text23(30).Enabled = False
            .Text23(31).Enabled = False
            .Text23(32).Enabled = False
            .Text23(33).Enabled = False
            .Label21(36).Enabled = False
            .Label21(37).Enabled = False
            .Label21(38).Enabled = False
            .Label21(39).Enabled = False
        End If
        
        
        'BSTreeStrat = 0
        
        xBStreeStrat = BSTreeStrat
        xBSupTest = BSupTest
        
        If .Combo3.ListIndex = 1 Then
    
            .Label1(71).Enabled = True
            .Command28(48).Enabled = True
            If BSupTest = 1 Then BSupTest = 2
            If BSupTest = 0 Or BSTreeStrat >= 3 Then
              .Label1(71).Caption = "Bootstrap test"
            
            ElseIf BSupTest = 1 Then  'approximate lr test returning aLRT stats
              .Label1(71).Caption = "Approximate likelihood ratio test (aLRT)"
            ElseIf BSupTest = 2 Then 'approximate lr test returning chi square based stats
              .Label1(71).Caption = "Approximate likelihood ratio test (ChiSq)"
            ElseIf BSupTest = 3 Then  'sh-like branch support test
              .Label1(71).Caption = "SH-like branch support test"
            End If
        
        
            If BSTreeStrat = 0 Then
                If BSupTest = 0 Then
                    .Label1(45).Enabled = False
                    .Label1(46).Enabled = False
                    .Text1(33).Enabled = False
                    .Text1(34).Enabled = False
                    .Text1(33).BackColor = Form1.BackColor
                    .Text1(34).BackColor = Form1.BackColor
                
                End If
                .Label1(72).Caption = "PhyML3 tree search by NNI"
                
            ElseIf BSTreeStrat = 1 Then
                .Label1(72).Caption = "PhyML3 tree search by SPR"
                If BSupTest = 0 Then
                    .Label1(45).Enabled = False
                    .Label1(46).Enabled = False
                    .Text1(33).Enabled = False
                    .Text1(34).Enabled = False
                    .Text1(33).BackColor = Form1.BackColor
                    .Text1(34).BackColor = Form1.BackColor
                
                End If
            ElseIf BSTreeStrat = 2 Then
                .Label1(72).Caption = "PhyML3 tree search by NNI and SPR"
                If BSupTest = 0 Then
                    .Label1(45).Enabled = False
                    .Label1(46).Enabled = False
                    .Text1(33).Enabled = False
                    .Text1(34).Enabled = False
                    .Text1(33).BackColor = Form1.BackColor
                    .Text1(34).BackColor = Form1.BackColor
                
                End If
            ElseIf BSTreeStrat = 3 Then
                .Label1(72).Caption = "Fast PHYML1 search"
                .Label1(45).Enabled = True
                .Label1(46).Enabled = True
                .Text1(33).Enabled = True
                .Text1(34).Enabled = True
                .Text1(33).BackColor = QBColor(15)
                .Text1(34).BackColor = QBColor(15)
                
            ElseIf BSTreeStrat = 4 Then
                .Label1(72).Caption = "Faster RAxML search"
                
                .Label1(71).Caption = "Bootstrap test"
                .Label1(71).Enabled = False
                .Command28(48).Enabled = False
                        
                
                .Label1(45).Enabled = True
                .Label1(46).Enabled = True
                .Text1(33).Enabled = True
                .Text1(34).Enabled = True
                .Text1(33).BackColor = QBColor(15)
                .Text1(34).BackColor = QBColor(15)
                
                .Label1(24).Caption = "GTR-CAT"
                .Label1(69).Enabled = False
                .Label1(59).Enabled = False
                .Label1(60).Enabled = False
                .Label21(46).Enabled = False
                .Label21(52).Enabled = False
                .Label21(42).Enabled = False
                '.Text23(34).Enabled = False
                .Text23(34).Visible = False
                .Text23(35).Visible = True
                .Text23(35).Enabled = False
                .Text23(35).BackColor = Form1.BackColor
                .Text1(17).Enabled = False
                .Text1(18).Enabled = False
                .Command28(43).Enabled = False
                .Command28(47).Enabled = False
                .Text1(17).BackColor = Form1.BackColor
                .Text1(18).BackColor = Form1.BackColor
                .Command28(44).Enabled = False
                .Text23(42).BackColor = Form1.BackColor
                .Text23(42).Enabled = False
            ElseIf BSTreeStrat = 5 Then
                .Label1(72).Caption = "Fastest FastTree search"
                
                .Label1(71).Enabled = True
                .Label1(71).Caption = "SH-like branch support test"
                .Command28(48).Enabled = False
                .Label1(45).Enabled = False
                .Label1(46).Enabled = False
                .Text1(33).Enabled = False
                .Text1(34).Enabled = False
                .Text1(33).BackColor = Form1.BackColor
                .Text1(34).BackColor = Form1.BackColor
                
                .Label1(24).Caption = "GTR-CAT"
                .Label1(69).Enabled = False
                .Label1(59).Enabled = False
                .Label1(60).Enabled = False
                .Label21(42).Enabled = False
                '.Text23(34).Enabled = False
                
                .Label21(46).Enabled = False
                .Label21(52).Enabled = False
                .Text23(34).Visible = False
                .Text23(35).Visible = True
                .Text23(35).Enabled = False
                .Text23(35).BackColor = Form1.BackColor
                
                .Text1(17).Enabled = False
                .Text1(18).Enabled = False
                .Command28(43).Enabled = False
                .Command28(47).Enabled = False
                .Text1(17).BackColor = Form1.BackColor
                .Text1(18).BackColor = Form1.BackColor
                .Command28(44).Enabled = False
                .Text23(42).BackColor = Form1.BackColor
                .Text23(42).Enabled = False
                    
                
                
            End If
        Else
            .Label1(71).Caption = "Bootstrap test"
            .Label1(71).Enabled = False
            .Command28(48).Enabled = False
            .Label1(71).Caption = "Bootstrap test"
        End If
        
            
        
        xTBModel = TBModel
        xTBGamma = TBGamma
        Call SetTBModel
        Call SetTBGamma
        
        
        .Text1(20) = TBGammaCats
        .Text1(39) = TBNGens
        .Text1(40) = TBNChains
        .Text1(38) = TBSampFreq
        .Text1(41) = TBTemp
        .Text1(42) = TBSwapFreq
        .Text1(43) = TBSwapNum
        
        'SCHEMADistCO = 4.5
'SCHEMAPermNo = 1000
        .Text6(11) = SCHEMADistCO
        .Text6(6) = SCHEMAPermNo
        .Text6(7) = MaxTemperature
        ontType = ntType
        
        'SCHEMADistCO,SCHEMAPermNo
        
        xTNegBLFlag = TNegBLFlag
        xTSubRepsFlag = TSubRepsFlag
        xTGRFlag = TGRFlag
        xTRndIOrderFlag = TRndIOrderFlag
        
        If OptionsFlag = 0 Then
            Dim OnIndex As Byte
            
            
            
            If .TabStrip1.SelectedItem.Index = 1 Then
                OnIndex = 1
            ElseIf .TabStrip1.SelectedItem.Index = 2 Then
                OnIndex = 2
            ElseIf .TabStrip1.SelectedItem.Index = 3 Then
                OnIndex = 3
            ElseIf .TabStrip1.SelectedItem.Index = 4 Then
                OnIndex = 4
            ElseIf .TabStrip1.SelectedItem.Index = 5 Then
                OnIndex = 5
            ElseIf .TabStrip1.SelectedItem.Index = 6 Then
                OnIndex = 6
            ElseIf .TabStrip1.SelectedItem.Index = 7 Then
                OnIndex = 7
            ElseIf .TabStrip1.SelectedItem.Index = 8 Then
                OnIndex = 13
            ElseIf .TabStrip1.SelectedItem.Index = 9 Then
                OnIndex = 15
            ElseIf .TabStrip1.SelectedItem.Index = 10 Then
                OnIndex = 8
            ElseIf .TabStrip1.SelectedItem.Index = 11 Then
                OnIndex = 11
            ElseIf .TabStrip1.SelectedItem.Index = 12 Then
                OnIndex = 10
            ElseIf .TabStrip1.SelectedItem.Index = 13 Then
                OnIndex = 14
            ElseIf .TabStrip1.SelectedItem.Index = 14 Then
                OnIndex = 9
                Form3.Combo1.ListIndex = 8
            ElseIf .TabStrip1.SelectedItem.Index = 15 Then
                OnIndex = 9
                Form3.Combo1.ListIndex = 5
            ElseIf .TabStrip1.SelectedItem.Index = 16 Then
                OnIndex = 12
            End If
            
            
            
            
            For x = 0 To 14

                If x = OnIndex - 1 Then
                    .Frame2(x).Visible = True
                    'Else
                    '    Frame2(X).Visible = False
                Else
                    .Frame2(x).Visible = False
                End If

            Next 'X

        End If

    End With
    
    
    xCurSCale = CurScale
    
    xPHIWin = PHIWin
    
End Sub

Public Sub VarRecRates(NextNo, StrainSeq() As String, GCFlag, GCTractLen, BlockPen, StartRho, MCMCUpdates, FreqCo, FreqCoMD)



'MCMCUpdates = 100000
Dim FN As String, SubSample As Long, DoSeqNo As Long, TSeq() As String, HS As Long, DS() As Byte, NewNo As Long, Discard As Long

ReDim Preserve RefCol(0)

Call UnModNextno
Form1.Picture2.Enabled = False

ManFlag = 20

'Exit Sub
    Form1.SSPanel1.Caption = "Loading likelihood lookup"
    
    Rnd (-BSRndNumSeed)
    Discard = MCMCUpdates / 10
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    On Error GoTo 0
    XX = CurDir
    
    Call LoadLikelihoodLookup(1, FN, TSeq())
    
    'load it
    
    
    
    'now do it with the frequency cutoff
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "locs.txt"
    KillFile "loc"
    KillFile "of"
    
    
    Open "convert.bat" For Output As #1
    Print #1, "convert < infile > of"
    Close #1
    On Error GoTo 0
    
    'Make infile for convert
    Open "infile" For Output As #1
    Print #1, "seqs.fas"
    Print #1, "0"
    Print #1, "2"
    Print #1, Str(FreqCo)
    Print #1, Str(FreqCoMD)
    Print #1, "1"
    Print #1, "0"
    Close #1
    'XX = CurDir
    'run convert
    Call ShellAndClose("convert.bat", 0)
    
    
    
    If GCFlag = 1 Then
        Open "locs" For Binary As #1
        Dim WholeFile As String
        WholeFile = String(LOF(1), " ")
        Get #1, , WholeFile
        Close #1
        
        Pos = InStr(1, WholeFile, "L", vbBinaryCompare)
        If Pos > 0 Then
            Mid$(WholeFile, Pos, 1) = "C"
        End If
        Open "locs" For Output As 1
        Print #1, WholeFile
        Close #1
    End If
    
    If VRFlag = 0 Then
        'Make batch file to run "infiles"
        If DebuggingFlag < 2 Then On Error Resume Next
        Open "interval.bat" For Output As #1
        Print #1, "interval < infile"
        Close #1
        On Error GoTo 0
        'Make "infile for interval"
        Open "infile" For Output As #1
        
        Print #1, "sites"
        Print #1, "locs"
        If GCFlag = 1 Then
            Print #1, Trim(Str(GCTractLen))
        End If
        Print #1, FN
        Print #1, "0"
        Print #1, Str(StartRho)
        Print #1, Str(BlockPen)
        Print #1, Str(MCMCUpdates)
        
        If MCMCUpdates / 1000 > 2000 Then
            SubSample = 2000
        Else
            SubSample = CInt(MCMCUpdates / 1000)
            If SubSample < 1 Then SubSample = 1
        End If
        
        Discard = CLng(Discard / SubSample)
        Print #1, Str(SubSample)
        
        Close #1
        
        Form1.SSPanel1.Caption = "0 of " + Trim(Str(MCMCUpdates)) + " MCMC updates completed"
        'Now execute and wait till its finished
        Dim NSites As Long
        
        Open "locs" For Input As #1
        Input #1, NSites
        Close #1
        
        TargetFileSize = NSites
        'set size of rates to 0
        Open "rates.txt" For Output As #1
        Close #1
        
        
        TargetFileSize = (TargetFileSize * 9) * (MCMCUpdates / SubSample)
        
        BatIndex = 8
        PrF = 23
        FullSize = MCMCUpdates
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "rates.txt"
        On Error GoTo 0
        Dim Prob As Byte
        Prob = 0
        Do
            If TargetFileSize > 10000000 Then
                Call ShellAndClose("interval.bat", 1)
            Else
                Call GetCommandOutput("interval.bat", PrF, True, True)
            End If
            Open "rates.txt" For Append As #1
            If LOF(1) > 10 Then
                
                Close #1
                Exit Do
            Else
                If Prob = 0 Then
                'there is probably a problem with the likelihood file
                    Prob = 1
                    If DebuggingFlag < 2 Then On Error Resume Next
                    If FN <> "LF0100" And FN <> "LF1100" And FN <> "LF250" Then
                        Kill FN
                    End If
                    On Error GoTo 0
                    Call LoadLF(FN, DoSeqNo, LFCode)
                    If ErrorFlag = 1 Then
                        ErrorFlag = 0
                        Form1.SSPanel1.Caption = ""
                        Form1.ProgressBar1 = 0
                        Call UpdateF2Prog
                        Exit Sub
                    End If
                Else
                    MsgBox "There has been a problem executing the Interval component of LDHat"
                    Form1.SSPanel1.Caption = ""
                    Form1.ProgressBar1.Value = 0
                    Call UpdateF2Prog
                    Screen.MousePointer = 0
                    Close #1
                    Exit Sub
                End If
            End If
            Close #1
        Loop
        'Make batch file to run "infiles"
        If DebuggingFlag < 2 Then On Error Resume Next
        Open "stat.bat" For Output As #1
        Print #1, "stat < infile"
        Close #1
        Open "stat.bat" For Output As #1
        Print #1, "stat rates.txt " + Trim(Str(Discard))
        Close #1
        On Error GoTo 0
        Call ShellAndClose("stat.bat", 0)
        x = x
    Else
        Open "locs" For Input As #1
        Input #1, NSites
        Close #1
    End If
        'Close #1
        Open "Res.txt" For Input As #1
        'read in results
        Dim Crap As String, CP As Double
        Line Input #1, Crap
        Line Input #1, Crap
        
        Dim PltVals() As Double
        ReDim PltVals(2, NSites + 1)
        For x = 1 To NSites
            Input #1, CP
            Input #1, PltVals(0, x - 1)
            Input #1, CP
            Input #1, CP
            Input #1, PltVals(1, x - 1)
            Input #1, PltVals(2, x - 1)
            
        Next x
        Close #1

    'pltvals 0,1 is where the actual data begins
    
    Dim DPX() As Long, PDX() As Long, Max As Double
    ReDim DPX(Len(TSeq(0))), PDX(Len(TSeq(0)))
    Open "locs" For Input As #1
    Line Input #1, Crap
    For x = 1 To NSites
        Input #1, DPX(x)
        If DPX(x) <= Len(TSeq(0)) Then
            PDX(DPX(x)) = x
        End If
    Next x
    Close #1
    Max = 0
    HS = CLng(Len(StrainSeq(0)) / 2)
    If CircularFlag = 1 Then
        SP = HS
        EP = Len(TSeq(0)) - HS
    Else
        SP = 0
        EP = Len(TSeq(0)) - 1
    End If
    Dim GraphPlt() As Double, PltPos() As Double, LPP As Double, TotSite As Long
    ReDim GraphPlt(2, Len(TSeq(0))), PltPos(Len(TSeq(0))), XDiffPos(Len(TSeq(0)))
    Y = 0
    
    TotSite = 0
    
    
    ZZ = 0
    For x = 1 To NSites
        
        If DPX(x + 1) >= SP And x > 1 Then
            
            
            If PltVals(2, x) > Max Then Max = PltVals(2, x)
            GraphPlt(0, Y) = PltVals(0, x - 1)
            GraphPlt(1, Y) = PltVals(1, x - 1)
            GraphPlt(2, Y) = PltVals(2, x - 1)
            
            PltPos(Y) = (DPX(x) - SP)
            If PltPos(Y) < 1 Then 'PltPos(Y) = 1
                Diff = 1 - (DPX(x + 1) - SP) / (DPX(x + 1) - DPX(x))
                'PltPos (Y)
                GraphPlt(0, Y) = GraphPlt(0, Y) + (PltVals(0, x) - GraphPlt(0, Y)) * Diff
                GraphPlt(1, Y) = GraphPlt(1, Y) + (PltVals(1, x) - GraphPlt(1, Y)) * Diff
                GraphPlt(2, Y) = GraphPlt(2, Y) + (PltVals(2, x) - GraphPlt(2, Y)) * Diff
                'PltPos(Y) = 1
                
            
            End If
            'If Y > 0 Then
                LPP = (DPX(x - 1) - SP)
            'End If
            TotSite = TotSite + (PltPos(Y) - LPP)
            VarRho(0) = VarRho(0) + (PltPos(Y) - LPP) * PltVals(0, x - 1)
            VarRho(1) = VarRho(1) + (PltPos(Y) - LPP) * PltVals(1, x - 1)
            VarRho(2) = VarRho(2) + (PltPos(Y) - LPP) * PltVals(2, x - 1)
            If (DPX(x - 1) - SP) > 0 Then
                ZZ = ZZ + 1
                XDiffPos(ZZ) = (DPX(x - 1) - SP)
            
            End If
            If PltPos(Y) < 1 Then
                Y = 0
                PltPos(Y) = 1
            Else
                PltPos(Y) = LPP + (PltPos(Y) - LPP) / 2
                If PltPos(Y) < 1 Then
                    PltPos(Y) = 1
                End If
            End If
            If x = NSites And x = 12345678 Then
                PltPos(Y) = PltPos(Y - 1) + (PltPos(Y) - LPP) / 2
                If PltPos(Y) > Len(StrainSeq(0)) Then
                    PltPos(Y) = PltPos(Y) - Len(StrainSeq(0))
                    'Move everything over 1
                    Dim TmpPos() As Double
                    ReDim TmpPos(3)
                    TmpPos(0) = PltPos(Y)
                    TmpPos(1) = GraphPlt(0, Y - 1)
                    TmpPos(2) = GraphPlt(1, Y - 1)
                    TmpPos(3) = GraphPlt(2, Y - 1)
                    For Z = NSites - 1 To 1 Step -1
                        PltPos(Z) = PltPos(Z - 1)
                        GraphPlt(0, Z) = GraphPlt(0, Z - 1)
                        GraphPlt(1, Z) = GraphPlt(1, Z - 1)
                        GraphPlt(2, Z) = GraphPlt(2, Z - 1)
                    Next Z
                    PltPos(0) = TmpPos(0)
                    GraphPlt(0, 0) = TmpPos(1)
                    GraphPlt(0, 1) = TmpPos(2)
                    GraphPlt(0, 2) = TmpPos(3)
                End If
            Else
                
                'If Y > 0 Then
                    'PltPos(Y) = LPP + (PltPos(Y) - LPP) / 2
                'Else
                   ' PltPos(Y) = PltPos(Y) / 2
                'End If
                x = x
            End If
            If DPX(x) > EP Then
                If PltPos(Y) > Len(StrainSeq(0)) Then
                    PltPos(Y) = Len(StrainSeq(0))
                End If
                Y = Y + 1
                Exit For
            End If
            Y = Y + 1
        Else
            x = x
        End If
    Next x
    NSites = Y
    Max = 0
    For x = 0 To NSites
        'If (DPX(X + 1) >= SP Or X = NSites) And X > 1 Then
            If GraphPlt(2, x) > Max Then Max = GraphPlt(2, x)
        'End If
    Next x
   ' Max = 1


If Max < 0.03 Then Max = 0.03
 If TotSite = 0 Then
    MsgBox "There Are no sites with a high enough minor allele frequency"
    Form1.SSPanel1.Caption = ""
    Form1.ProgressBar1.Value = 0
    Call UpdateF2Prog
    Screen.MousePointer = 0
    Close #1
    Exit Sub
 End If
For x = 0 To 2
    VarRho(x) = VarRho(x) / TotSite
Next x
VarRho(3) = TotSite
If CircularFlag = 1 Then
    VarRho(4) = VarRho(4) / 2
    VarRho(6) = VarRho(6) / 2
End If
Dim Pict As Long, PntAPI As POINTAPI, YScaleFactor As Double
YScaleFactor = 0.85
PicHeight = Form1.Picture7.Height * YScaleFactor
XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
LenXoverSeq = NSites
Call DoAxes(0, 0, Decompress(Len(StrainSeq(0))), -1, CSng(Max), 0, 1, "Rho(4Ner) per bp")

XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))
Pict = Form1.Picture7.hdc

'get everything into standard save/copy format
ReDim GPrint(1, NSites * 2 + 2), GPrintCol(1), GPrintPos(1, NSites * 2 + 2)

ReDim GVarPos(0, NSites)
For x = 1 To NSites
    GVarPos(0, x) = XDiffPos(x)
Next x
ReDim GCritval(10)
GLegend = "Rho(4Ner) per bp"
GPrintLen = NSites * 2 + 2 '+ 2 'how many points to plot
GPrintCol(0) = 0 'line is black
GPrintCol(1) = RGB(128, 128, 128) 'line is grey
GPrintNum = 1 'two lines
GPrintType = 0 'a normal line plot
GPrintMin(0) = 0 'bottom val
GPrintMin(1) = Max 'upper val

For x = 0 To NSites - 1
    
    GPrint(0, x) = GraphPlt(0, x)
    GPrint(0, NSites * 2 - x) = GraphPlt(0, x)
    GPrintPos(0, x) = PltPos(x)
    GPrintPos(0, NSites * 2 - x) = PltPos(x)
    'GVarPos(0,X) = PltPos(X)
    
Next x
XX = GraphPlt(0, NSites + 1)
GBlockNum = -1



For x = 0 To NSites - 1
    If x = NSites - 1 Then
        x = x
    End If
    GPrint(1, x) = GraphPlt(1, x)
    GPrint(1, NSites * 2 - x) = GraphPlt(2, x)
    GPrintPos(1, x) = PltPos(x)
    GPrintPos(1, NSites * 2 - x) = PltPos(x)
    
Next x

For x = 0 To NSites - 1
    For Y = 0 To 1
    
        If GPrintPos(Y, x) < 1 Then GPrintPos(Y, x) = 1
    Next Y
    
Next x
GExtraTNum = 1
ReDim GExtraText(GExtraTNum)
GExtraText(0) = "Recombination rate"
GExtraText(1) = "95% Confidence interval"

GPrintPos(1, GPrintLen - 1) = GPrintPos(1, 0)
GPrintPos(0, GPrintLen - 1) = GPrintPos(0, 0)

GPrintPos(1, GPrintLen) = GPrintPos(1, 0)
GPrintPos(0, GPrintLen) = GPrintPos(0, 0)
GPrint(0, GPrintLen - 1) = GPrint(0, 0)
GPrint(1, GPrintLen - 1) = GPrint(1, GPrintLen - 2)
GPrint(1, GPrintLen) = GPrint(1, 0)
GPrint(0, GPrintLen) = GPrint(0, GPrintLen - 2)
Form1.Picture7.AutoRedraw = True
Form1.Frame17.Visible = False

If Max > 0 Then
    Form1.Picture7.DrawStyle = 0
    Form1.Picture7.ForeColor = RGB(150, 150, 150)
    'MoveToEx Pict, 30 + PltPos(0) * XFactor, PicHeight - (15 + GraphPlt(1, 0) / Max * (PicHeight - 35)), PntAPI
    'LineTo Pict, 30 + PltPos(X) * XFactor, (PicHeight - (15 + (GraphPlt(2, 0) / Max) * (PicHeight - 35)))
    For x = 0 To NSites - 2
        
        If PltPos(x) > 0 And PltPos(x) <= Len(StrainSeq(0)) Then
            ST = CLng(((GraphPlt(2, x)) / Max) * (PicHeight - 35) - ((GraphPlt(1, x)) / Max) * (PicHeight - 35))
            EN = CLng(((GraphPlt(2, x + 1)) / Max) * (PicHeight - 35) - ((GraphPlt(1, x + 1)) / Max) * (PicHeight - 35))
            
            If ST = 0 Then ST = 1
            If EN = 0 Then EN = 1
            If ST > EN Then
                For Y = 0 To ST
                    MoveToEx Pict, 30 + Decompress(PltPos(x)) * XFactor, PicHeight - ((15 + GraphPlt(1, x) / Max * (PicHeight - 35))) - ST * (Y / ST), PntAPI
                    LineTo Pict, 30 + Decompress(PltPos(x + 1)) * XFactor, (PicHeight - ((15 + (GraphPlt(1, x + 1) / Max) * (PicHeight - 35)))) - EN * (Y / ST)
                Next Y
            Else
                
                For Y = 0 To EN
                
                    MoveToEx Pict, 30 + Decompress(PltPos(x)) * XFactor, PicHeight - ((15 + GraphPlt(1, x) / Max * (PicHeight - 35))) - ST * (Y / EN), PntAPI
                    LineTo Pict, 30 + Decompress(PltPos(x + 1)) * XFactor, (PicHeight - ((15 + (GraphPlt(1, x + 1) / Max) * (PicHeight - 35)))) - EN * (Y / EN)
                    x = x
                Next Y
            End If
        End If
        
    Next 'X
    
    
    
    Form1.Picture7.ForeColor = 0
    Y = 0
    For Z = 0 To NSites - 1
        If PltPos(Z) > 0 Then
            MoveToEx Pict, 30 + Decompress(PltPos(Z)) * XFactor, PicHeight - (15 + GraphPlt(Y, 0) / Max * (PicHeight - 35)), PntAPI
            Exit For
        End If
    Next Z
    For x = 1 To NSites - 1
        
        LineTo Pict, 30 + Decompress(PltPos(x)) * XFactor, (PicHeight - (15 + (GraphPlt(Y, x) / Max) * (PicHeight - 35)))
    Next 'X
    
Else
    If Max > 0 Then
        For Y = 0 To 2
            If Y > 0 Then
                Form1.Picture7.DrawStyle = 2
            Else
                Form1.Picture7.DrawStyle = 0
            End If
            MoveToEx Pict, 30 + Decompress(PltPos(0)) * XFactor, PicHeight - (15 + GraphPlt(Y, 0) / Max * (PicHeight - 35)), PntAPI
            
            For x = 1 To NSites - 1
            
                LineTo Pict, 30 + Decompress(PltPos(x)) * XFactor, (PicHeight - (15 + (GraphPlt(Y, x) / Max) * (PicHeight - 35)))
            Next 'X
        Next Y
    End If
End If
ManFlag = 20
'Call DoLegend
 VRFlag = 1
Form1.Picture7.DrawStyle = 0
Form1.ProgressBar1.Value = 0
Form1.SSPanel1.Caption = ""
Call UpdateF2Prog
If DebuggingFlag < 2 Then On Error Resume Next

ChDrive oDir
ChDir oDir
On Error GoTo 0
Form1.Picture2.Enabled = True
Form1.Picture21.Width = Form1.Picture7.Width + 100
Form1.Picture21.Height = Form1.Picture7.Height + 100
Form1.Picture21.PaintPicture Form1.Picture7.Image, Form1.Picture7.Left, Form1.Picture7.Top + 5
End Sub
Public Sub NumToString(num, SD, OutString As String, Exp As String, ExtraX As String)
Dim TString As String, TempNum As Double, SMod As Byte
TString = Trim(Str(num))
If num < 0 Then SMod = 3 Else SMod = 2
Exp = ""
If num < 1 And num > -1 Then 'ie num is a decimal
    'check if it is a very small number
    Pos = InStr(1, TString, "E", vbBinaryCompare)
    If Pos > 0 Then 'ie its a very small number
        Exp = Mid$(TString, Pos + 1, Len(TString) - Pos)
        If Pos > SD + SMod Then
            TempNum = val(Left(TString, Pos - 1))
            TempNum = TempNum * (10 ^ (SD))
            TempNum = CLng(TempNum)
            TempNum = TempNum / (10 ^ (SD))
            TString = Trim(Str(TempNum))
            Pos = InStr(1, TString, "E", vbBinaryCompare)
            If Pos = 0 Then
                TString = Left$(TString, SD + SMod)
            Else
                TString = Left(TString, Pos - 1)
                
            End If
        Else
            TString = Left(TString, Pos - 1)
        End If
    Else
        'check for a large number of decimal places
        TempNum = num * 10 ^ SD
        If TempNum < 1 And TempNum > -1 Then
            TempNum = num
            TempNum = CLng(-Log10(TempNum))
            tempnum2 = TempNum
            TempNum = num * 10 ^ TempNum
            Exp = Trim(Str(-tempnum2))
            TempNum = TempNum * (10 ^ (SD))
            TempNum = CLng(TempNum)
            TempNum = TempNum / (10 ^ (SD))
            TString = Trim(Str(TempNum))
            x = x
        Else
            Exp = ""
            TString = "0" + TString
        End If
    End If
Else
    
    TempNum = num
    TempNum = TempNum * (10 ^ SD)
    TempNum = CLng(TempNum)
    TempNum = TempNum / (10 ^ SD)
    TString = Trim(Str(TempNum))
End If
If Exp = "" Then ExtraX = "" Else ExtraX = " X 10"
OutString = TString

End Sub
Public Sub MakeAPos(APos() As Long, BPos() As Long)
Dim TypeSeq As Long, OS1 As Long, SSB As Long

'Decompress(posinsubseq) - SeqSpaces(posinsubseq, RecSeq)
ReDim APos(Len(StrainSeq(0))), BPos(Decompress(Len(StrainSeq(0))))
    TypeSeq = TypeSeqNumber
    If TypeSeq > PermNextno Or TypeSeq < 0 Then TypeSeq = 0
    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) And x = 123456 Then 'this x = 123456 forces alignment rather than reference sequence cocords
        
        
        For x = 1 To Len(StrainSeq(0))
           If SeqSpacesInFileFlag = 1 Then
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                FF = FreeFile
               
                OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
                Open "RDP5SSFile" + UFTag For Binary As #FF
                
                Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
                
                
                Close #FF
                ChDrive oDirX
                ChDir oDirX
            Else
                SSB = SeqSpaces(x, TypeSeq)
                'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
            End If
            APos(x) = Decompress(x) - SSB
            BPos(Decompress(x) - SSB) = x
            SSX = Abs(GetTickCount)
            If Abs(SSX - eex) > 500 Then
                eex = SSX
                Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(Len(StrainSeq(0)))) + " sites loaded"
            End If
        Next x
    Else ' if there is compression
        For x = 1 To Len(StrainSeq(0))
           
            APos(x) = x
            BPos(x) = x
        Next x
    End If
    
    
End Sub
Public Sub RMinWin()

Dim ST As Long, EN As Long, Win As Long, STX As Long, ENX As Long, RMP() As Long, MaxBP As Double, UScore As Long, A As Long, b As Long
Win = 200
ReDim RMP(Len(StrainSeq(0)))
Y = 0
Z = 0
If DoneMatX(6) = 0 Then
    'If ButtonScrollFlag = 0 And CurMatrixFlag = 6 Then DoneMatX(6) = 0
    CurMatrixFlag = 6
    Call RMinMat(GCFlag, GCTractLen, FreqCo, FreqCoMD, 6, 0)
    
    Form1.Check1.Enabled = False
    Call DoMatCap
    If (MatZoom(CurMatrixFlag) + 0.5) * Form1.Picture26.ScaleHeight - Form1.Picture26.ScaleHeight <= 32000 Then
        Form1.Command39(1).Enabled = True
    End If
    
    Form1.Command39(0).Enabled = True
End If
For x = Win / 2 + 1 To Len(StrainSeq(0)) - Win / 2
    
    
    ST = x - Win / 2
    EN = x + Win / 2 - 1
    
    Do While VarsitesLD(Y) <= ST
        Y = Y + 1
        If Y > UBound(VarsitesLD) Then Exit For
    Loop
    STX = Y 'VarsitesLD(Y)
    Do While VarsitesLD(Z) <= EN
        Z = Z + 1
        If Z > Mat567Len - 1 Then Z = Mat567Len - 1: Exit Do
        If Z > UBound(VarsitesLD) Then Exit For
    Loop
    Z = Z - 1
    ENX = Z 'VarsitesLD(Z)
    If STX > UBound(MatrixRMin, 1) Then STX = UBound(MatrixRMin, 1)
    If ENX > UBound(MatrixRMin, 2) Then ENX = UBound(MatrixRMin, 2)
 
    RMP(x) = MatrixRMin(CLng((STX / Mat567Len) * UBound(MatrixRMin, 1)), CLng((ENX / Mat567Len) * UBound(MatrixRMin, 1)))
    x = x
    'RMP(X) = MatrixRMin(STX, ENX)
 'If X = X Then
 '       If ST = 1465 Then
 '           X = X
 '       End If
 '
 '       If MatrixRMin(STX, ENX) > 0 Then
 '           X = X
 '       End If
 '   Else
 '       UScore = 0
 '       For A = STX To ENX
 '           For B = STX To ENX
 '               If UScore < MatrixRMin(A, B) Then
 '                   UScore = MatrixRMin(A, B)
 '               End If
 '           Next B
 '
 '       Next A
 '       RMP(X) = UScore
 '   End If
    
Next x

MaxBP = 0
For x = 0 To Len(StrainSeq(0))
    If MaxBP < RMP(x) Then
        MaxBP = RMP(x)
    End If

Next x

If MaxBP = 0 Then Exit Sub

Form1.Picture7.AutoRedraw = True
Form1.Picture7.Picture = LoadPicture()
YScaleFactor = 0.85
PicHeight = Form1.Picture7.Height * YScaleFactor

Dim PntAPI As POINTAPI
Dim Pict As Long

Dim BPos() As Long, TypeSeq
Pict = Form1.Picture7.hdc




Call MakeAPos(APos(), BPos())
XFactor = ((Form1.Picture7.Width - 40) / Decompress(APos(Len(StrainSeq(0)))))
Call DoAxes(0, 1, Decompress(Len(StrainSeq(0))), -1, CSng(MaxBP), 0, 0, "Breakpoints per" + Str(Win) + " nt window")

Form1.Picture7.DrawWidth = 3


Form1.Picture7.ForeColor = RGB(128, 128, 128)
Pict = Form1.Picture7.hdc
MoveToEx Pict, 30 + Decompress(APos((Win / 2 + 1))) * XFactor, PicHeight - 15 - RMP(Win / 2 + 1) / MaxBP * (PicHeight - 35), PntAPI

For x = Win / 2 + 1 To Len(StrainSeq(0)) - Win / 2 - 1
    LineTo Pict, 30 + Decompress(APos(x)) * XFactor, PicHeight - 15 - RMP(x) / MaxBP * (PicHeight - 35)
Next 'X



If RelX > 0 Or RelY > 0 Then

    Call Highlight(0)

End If
Form1.Picture7.DrawWidth = 1
Form1.Picture7.ForeColor = 0
MoveToEx Pict, 30 + Decompress(APos((Win / 2 + 1))) * XFactor, PicHeight - 15 - RMP(Win / 2 + 1) / MaxBP * (PicHeight - 35), PntAPI

For x = Win / 2 + 1 To Len(StrainSeq(0)) - Win / 2 - 1
    LineTo Pict, 30 + Decompress(APos(x)) * XFactor, PicHeight - 15 - RMP(x) / MaxBP * (PicHeight - 35)
Next 'X


Form1.Picture7.Refresh
End Sub
Public Sub RMinMat(GCFlag, GCTractLen, FreqCo, FreqCoMD, MatFlag, RecTest)

Dim Pict As Long, PntAPI As POINTAPI, YScaleFactor As Double, MaxN As Double
Dim FN As String, SubSample As Long, DoSeqNo As Long, TSeq() As String, HS As Long, DS() As Byte, NewNo As Long, Discard As Long
Dim LDMatSmooth() As Single
'Dim RecTest As Long

'change to 0 to avoid the recombination test
'RecTest = 1



Call UnModNextno
Call UnModSeqNum(0)
If DoneMatX(5) = 0 Then
    ReDim Preserve RefCol(0)
    Form1.Picture2.Enabled = False
    ManFlag = 20
    Form1.SSPanel1.Caption = "Loading likelihood lookup"
    MaxSize = 99 'set maxsize according to the max size of the lookup file
    Rnd (-BSRndNumSeed)
    Discard = MCMCUpdates / 10
    If DebuggingFlag < 2 Then On Error Resume Next

    oDir = CurDir
    ChDrive App.Path
    ChDir App.Path
    On Error GoTo 0
    'Get sequences to analyse
    'currently can handle only 100 sequences
    
    
    
    Form1.ProgressBar1.Value = 5
    Call UpdateF2Prog
    Call LoadLikelihoodLookup(0, FN, TSeq())
    
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "convert.bat"
    
    FLen = 0
    Dim FString As String
    On Error Resume Next
    FLen = FileLen("convert.bat")
    On Error GoTo 0
    
    If FLen > 0 Then 'this means that for some reason the file did not get deleted - we need to use another name for it
        Randomize
        FString = "convert" & Trim(Str(Rnd)) & ".bat"
    Else
        FString = "convert.bat"
        
    End If
    
    On Error GoTo 0
    'Make batch file to run "infiles"
    Open FString For Output As #1
    Print #1, "convert < infile" ' > outfilec"
    Print #1, "del " + FString
    Close #1
    'Make infile for convert
    Open "infile" For Output As #1
    Print #1, "seqs.fas"
    Print #1, "0"
    Print #1, "2"
    Print #1, Str(FreqCo)
    Print #1, Str(FreqCoMD)
    Print #1, "1"
    Print #1, "0"
    Close #1
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "locs"
    On Error GoTo 0
    
    Form1.SSPanel1.Caption = "Findig site sets"
    
    'run convert
    Call ShellAndClose(FString, 0)
    
    If GCFlag = 1 Then
        Close #1
        Open "locs" For Binary As #1
        Dim WholeFile As String
        XX = LOF(1)
        WholeFile = String(LOF(1), " ")
        If Len(WholeFile) = 0 Then
            MsgBox ("The LDHat component, CONVERT, has crashed unexpectedly and I'm therefore unable continue")
            Form1.SSPanel1.Caption = ""
            ReDim MatrixLD(1, 1)
            Form1.ProgressBar1 = 0
            Call UpdateF2Prog
            Form1.Picture26.Enabled = True
            Form1.SSPanel6(2).Enabled = True
            Form1.Picture29.Enabled = True
            Exit Sub
        End If
        Get #1, , WholeFile
        Close #1
        
        Pos = InStr(1, WholeFile, "L", vbBinaryCompare)
        Mid$(WholeFile, Pos, 1) = "C"
        Open "locs" For Output As 1
        Print #1, WholeFile
        Close #1
    
    End If
   ' Exit Sub
    'Make batch file to run "infiles"
    If DebuggingFlag < 2 Then On Error Resume Next
    Open "pairwise.bat" For Output As #1
    Print #1, "pairwise < infile > outfilep"
    Close #1
    On Error GoTo 0
    'Make "infile for pairwise"
    Open "infile" For Output As #1
    
    Print #1, "sites"
    Print #1, "locs"
    If GCFlag = 1 Then
        Print #1, Trim(Str(GCTractLen))
    End If
    'If RecTest = 1 Then
    
    'Else
        Print #1, "1"
        Print #1, FN
        Print #1, "0"
    'End If
    Print #1, "0"
    
    Print #1, "0"
    
    Print #1, "2"
    Print #1, "0"
    If RecTest = 1 Then
        Print #1, "1"
    Else
        Print #1, "0" 'change to 1 to test for recombination
    End If
    Print #1, "0"
    Close #1
    
    'Form1.SSPanel1.Caption = "0 of " + Trim(Str(MCMCUpdates)) + " MCMC Updates Completed"
    'Now execute and wait till its finished
    If DebuggingFlag < 2 Then On Error Resume Next
    KillFile "outfilep"
    KillFile "fit.txt"
    On Error GoTo 0
    Form1.ProgressBar1.Value = 30
    Form1.SSPanel1.Caption = "Calculating RMin between sites pairs"
    Call UpdateF2Prog
    BatIndex = 553
    Call ShellAndClose("pairwise.bat", 0)
    
    'XX = Len(StrainSeq(0))
    If DebuggingFlag < 2 Then On Error Resume Next
    LF = 0
    If Dir("fit.txt") <> "" Then
        Open "fit.txt" For Input As #1
    
        Form1.SSPanel1.Caption = "Loading matrices"
        Form1.ProgressBar1.Value = 70
        Call UpdateF2Prog
        LF = LOF(1)
        Close #1
    End If
    On Error GoTo 0
    If LF = 0 Then
        MsgBox ("The LDHat component, PARWISE, has crashed unexpectedly and I'm therefore unable continue")
        Form1.SSPanel1.Caption = ""
        ReDim MatrixLD(1, 1)
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        Form1.Picture26.Enabled = True
        Form1.SSPanel6(2).Enabled = True
        Form1.Picture29.Enabled = True
        Exit Sub
    
    
        
    End If
    Close #1
    
    If RecTest = 1 Then
        Dim Crap2 As String, Crap3 As String, Crap4 As String
        FF = FreeFile
        Open "outfilep" For Binary As #FF
        Crap2 = String(LOF(FF), " ")
        Get #FF, , Crap2
        Pos = InStr(1, Crap2, "Observed LD statistics", vbBinaryCompare)
        Pos = InStr(Pos, Crap2, "Npairs       =", vbBinaryCompare)
        Pos = Pos + 14
        Pos2 = InStr(Pos, Crap2, Chr(10), vbBinaryCompare)
        Crap3 = Trim(Mid(Crap2, Pos, Pos2 - Pos))
        Crap4 = "Number of analysed site pairs = " + Crap3 + Chr(13) + Chr(10)
        Pos = InStr(1, Crap2, "Proportion Lkmax <=", vbBinaryCompare)
        Pos2 = InStr(1, Crap2, "Proportion G4 >=", vbBinaryCompare)
        If Pos > 0 Then
            Crap3 = Mid(Crap2, Pos, (Pos2 - Pos))
        End If
        Crap4 = Crap4 + Crap3
        Pos = InStr(1, Crap2, "Proportion corr(r2,d) <= estimated", vbBinaryCompare)
        Pos2 = InStr(1, Crap2, "Proportion corr(D',d) <= estimated", vbBinaryCompare)
        If Pos > 0 Then
            Crap3 = Mid(Crap2, Pos, (Pos2 - Pos))
        End If
        Crap4 = Crap4 + Crap3
        MsgBox (Crap4)
        Close #FF
        Exit Sub
    
    End If
    Open "locs" For Input As #1
    Input #1, NSites
    Close #1
    Dim tMat() As Single
    If NSites - 1 < 1000 Then
        RSize = 1000
    Else
        RSize = NSites - 1
    End If
    ReDim MatrixLD(RSize + 1, RSize + 1)
    ReDim MatrixRMin(RSize + 1, RSize + 1)
    ReDim MatrixRMinD(RSize + 1, RSize + 1)
    ReDim tMat(RSize + 1, RSize + 1)
    
    'get site positions
    Dim DPX() As Long, PDX() As Long, Max As Double
    ReDim DPX(Len(TSeq(0))), PDX(Len(TSeq(0)))
    Open "locs" For Input As #1
    Line Input #1, Crap
    ReDim VarsitesLD(Len(StrainSeq(0)))
    For x = 1 To NSites
        Input #1, DPX(x)
        PDX(DPX(x)) = x
        VarsitesLD(x) = DPX(x)
    Next x
    
    Close #1
    
    Max = 0
    SP = 1
    EP = Len(TSeq(0))
    
    Dim GraphPlt() As Double, PltPos() As Double
    ReDim GraphPlt(2, Len(TSeq(0))), PltPos(Len(TSeq(0))), XDiffPos(Len(TSeq(0)))
    Y = 0
    For x = 1 To NSites
        If DPX(x) >= SP And DPX(x) <= EP Then
            
            
            PltPos(Y) = DPX(x) - (SP - 1)
            XDiffPos(Y) = PltPos(Y)
            Y = Y + 1
        
        End If
    Next x
    'open LDmatrix
    Close #1
    Form1.SSPanel1.Caption = "Loading LD matrix data"
    Form1.ProgressBar1.Value = 80
    Call UpdateF2Prog
    Open "fit.txt" For Input As #1
        Line Input #1, Crap
        Line Input #1, Crap
        Line Input #1, Crap
        Line Input #1, Crap
        Y = NSites - 2
        
        
        For x = 0 To NSites - 1
            Input #1, CP
            For Z = 0 To Y
                'Input #1, Crap
                
                Input #1, tMat((Z + ((NSites - 1) - Y) + 1), x)
                
                tMat(x, Z + ((NSites - 2) - Y) + 1) = MatrixLD(Z + ((NSites - 2) - Y) + 1, x)
                
            Next Z
            Y = Y - 1
        Next x
    Close #1
    Dim ScaleFact As Double
    ScaleFact = RSize / NSites
    If ScaleFact > 1 Then
        ScaleFact = ScaleFact
    End If
    For Y = 0 To RSize
        b = CLng(Y / ScaleFact)
        For x = Y + 1 To RSize
            A = CLng(x / ScaleFact)
            
            MatrixLD(Y, x) = tMat(A, b)
            MatrixLD(x, Y) = tMat(A, b)
            
        Next x
    Next Y
    ReDim tMat(RSize + 1, RSize + 1)
    Form1.ProgressBar1.Value = 90
    Form1.SSPanel1.Caption = "Loading RMin matrix data"
    Call UpdateF2Prog
    Open "rmin.txt" For Input As #1
        Line Input #1, Crap
        Line Input #1, Crap
        Line Input #1, Crap
        Line Input #1, Crap
        Line Input #1, Crap
        For x = 0 To NSites - 2
            Input #1, CP
            
            For Z = 0 To NSites - 1
                If Z <> x Then
                    Input #1, tMat(Z, x)
                    x = x
                End If
            Next Z
            
        Next x
    Close #1
    
    For Y = 0 To RSize
        b = CLng(Y / ScaleFact)
        For x = Y + 1 To RSize
            A = CLng(x / ScaleFact)
            
            MatrixRMin(Y, x) = tMat(A, b)
            MatrixRMin(x, Y) = tMat(A, b)
            MatrixRMinD(Y, x) = tMat(b, A)
            MatrixRMinD(x, Y) = tMat(b, A)
            x = x
        Next x
    Next Y
    Form1.ProgressBar1.Value = 98
    Call UpdateF2Prog
    MaxN = FindMaxNS(RSize, MatrixLD(0, 0))
    MatBound(5) = MaxN
    
    MaxN = 0
    For x = 0 To RSize
        For Y = x + 1 To RSize
            If MatrixLD(x, Y) < MaxN Then MaxN = MatrixLD(x, Y)
        Next Y
    Next x
    If Abs(MaxN) > MatBound(5) Then MatBound(5) = Abs(MaxN)
    Form1.SSPanel1.Caption = "Loading RMin/D matrix data"
    MaxN = FindMaxNS(RSize, MatrixRMin(0, 0))
    MatBound(6) = MaxN
    'For X = 0 To RSize
    '    For Y = 0 To RSize
    '        If MatrixRMin(X, Y) > 0 Then
    '            X = X
    '        End If
    '    Next Y
    'Next X
    For x = 0 To RSize
        For Y = 0 To RSize
            If MatrixRMinD(x, Y) > 0.5 Then
                MatrixRMinD(x, Y) = 0.5 'Then
             End If
        Next Y
    Next x
    MaxN = FindMaxNS(RSize, MatrixRMinD(0, 0))
    
    'MaxN = 0
    'For X = 0 To NSites
    '    For Y = 0 To NSites
    '        If MatrixRMinD(X, Y) > MaxN Then
    '            MaxN = MatrixRMinD(X, Y)
    '        End If
    '    Next Y
    'Next X
    
    MatBound(7) = MaxN
    DoneMatX(5) = 1
    Mat567Len = NSites
Else

    NSites = Mat567Len
    
    Max = 0
    
    
    If NSites - 1 < 1000 Then
        RSize = 1000
    Else
        RSize = NSites - 1
    End If
   
    
End If

'RSize = NSites - 1
'MatBound(MatFlag) = 0.1
MaxN = MatBound(MatFlag)

Form1.Picture26.Picture = LoadPicture()
    
    
Dim PosS(1) As Single, PosE(1) As Single, DistD As Long
XAddj = (Form1.Picture26.ScaleHeight) / RSize
DistD = RSize / MatZoom(MatFlag)
PosS(0) = MatCoord(MatFlag, 0)
PosE(0) = PosS(0) + DistD
PosS(1) = MatCoord(MatFlag, 1)
PosE(1) = PosS(1) + DistD
Dim Limit As Long
If MatFlag = 5 Then
    Limit = UBound(MatrixLD, 1)
ElseIf MatFlag = 6 Then
    Limit = UBound(MatrixRMin, 1)
ElseIf MatFlag = 7 Then
    Limit = UBound(MatrixRMinD, 1)
End If
    
If PosE(1) > (Limit - 1) - 1 Then PosE(1) = (Limit - 1) - 1
If PosE(0) > (Limit - 1) - 1 Then PosE(0) = (Limit - 1) - 1
       
If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
        
If MatFlag = 6 Then
    If MaxN > 2 Then
        MaxN = CLng((MaxN / 4) + 0.5) * 4
    Else
        MaxN = 2
    End If
End If

Form1.Picture26.Picture = LoadPicture()
Form1.Picture26.ScaleMode = 3
DistD = RSize / MatZoom(MatFlag)
XAddj = (Form1.Picture26.ScaleHeight) / DistD
     

    Dim Rescale As Single, RSCale As Single
If MatFlag = 5 Then
    Rescale = UBound(MatrixLD, 1) / Form1.Picture26.ScaleWidth
    If Rescale > 1 And x = 123456 Then 'bit i'm using to try antialias the matrix
        RSCale = Rescale * Rescale
        ReDim LDMatSmooth(Form1.Picture26.ScaleWidth, Form1.Picture26.ScaleWidth)
        For x = 0 To UBound(MatrixLD, 1)
            For Y = 0 To UBound(MatrixLD, 2)
                A = CInt(x / Rescale)
                b = CInt(Y / Rescale)
                LDMatSmooth(A, b) = LDMatSmooth(A, b) + MatrixLD(x, Y) / RSCale
            Next Y
        Next x
        Call DrawMatsVB(Form1.Picture26, -MaxN, PosE(), PosS(), SX, SY, XAddj, LDMatSmooth(), HeatMap(), CurScale, MaxN)
    Else
        Call DrawMatsVB(Form1.Picture26, -MaxN, PosE(), PosS(), SX, SY, XAddj, MatrixLD(), HeatMap(), CurScale, MaxN)
    End If
    If DontDoKey = 0 Then
        Call DoKey(1, MaxN, -MaxN, MatFlag, "Marginal likelihood ratio", CurScale)
    End If
ElseIf MatFlag = 6 Then
    Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixRMin(), HeatMap(), CurScale, MaxN)
    If DontDoKey = 0 Then
        Call DoKey(1, MaxN, 0, MatFlag, "RMin", CurScale)
    End If
    
ElseIf MatFlag = 7 Then
    Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixRMinD(), HeatMap(), CurScale, MaxN)
    If DontDoKey = 0 Then
        Call DoKey(1, MaxN, 0, MatFlag, "RMin/D", CurScale)
    End If
End If
    Form1.Picture26.Refresh
    Form1.Picture26.Enabled = True
    Form1.SSPanel6(2).Enabled = True
    Form1.Picture29.Enabled = True
    Form1.ProgressBar1 = 0
    Form1.SSPanel1 = ""
    Call UpdateF2Prog
End Sub
Public Sub CentreBP(OBE, oEN, Seq1, Seq2, Seq3, BE, EN, XPosDiff() As Long, XDiffPos() As Long, BWarn, EWarn, LSS, LenXoverSeq)
Dim g As Long, Z As Long
'
'Exit Sub
If OBE = 0 And oEN = 0 Then
    If XPosDiff(BE) - 1 > 0 Then
        BE = BE - CLng(((BE - XDiffPos(XPosDiff(BE) - 1)) / 2) - 0.1)
    Else
        BE = BE - CLng(((BE + Len(StrainSeq(0)) - XDiffPos(LenXoverSeq)) / 2) - 0.1)
    End If
Else
    If OBE - 1 > 0 Then
        
        BE = BE - CLng(((BE - XDiffPos(OBE - 1)) / 2) - 0.1)
    Else
        BE = BE - CLng(((BE + Len(StrainSeq(0)) - XDiffPos(LenXoverSeq)) / 2) - 0.1)
    
    End If
End If

'@'@
If BE = 0 Then
    BE = 1
ElseIf BE < 1 Then
    If CircularFlag = 0 Then 'seqs linear
        BE = 1
    Else
        BE = Len(StrainSeq(0)) + BE
    End If
End If
'$
Z = BE
Dim CycleX As Integer
If SEventNumber > 0 Then
    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
        BWarn = 1
        
'        If X = X Then
'
'            Z = GoRight(Seq1, Seq2, Seq3, CircularFlag, Z, Len(StrainSeq(0)), UBound(MissingData, 1), MissingData(0, 0))
            
'        Else
             Z = GoRightP(Seq1, Seq2, Seq3, CircularFlag, Z, Len(StrainSeq(0)), UBound(MissingData, 1), MissingData(0, 0))
'        End If
    End If
End If



BE = Z


If CircularFlag = 0 Then
'
    
    If OBE = 0 And oEN = 0 Then
        If XPosDiff(BE) < LSS Then
            BWarn = 1
        End If
    Else
        
        'find First pos from right where xdiffpos < en
        For g = 1 To LSS
            If XDiffPos(g) > Z Then
                BWarn = 1
            End If
            
        
        Next g
    End If
End If



'
XPosDiff(Len(StrainSeq(0))) = LenXoverSeq
'XX = XDiffpos(LenXoverSeq)
'EN = 850

If OBE = 0 And oEN = 0 Then
    If XPosDiff(EN) + 1 <= LenXoverSeq Then
        EN = EN + CLng(((XDiffPos(XPosDiff(EN) + 1) - EN) / 2) - 0.1)
    Else
        EN = EN + CLng(((XDiffPos(1) + (Len(StrainSeq(0)) - EN)) / 2) - 0.1)
    End If
Else
    If oEN + 1 <= LenXoverSeq Then
        
        EN = EN + CLng(((XDiffPos(oEN + 1) - EN) / 2) - 0.1)
    Else
        EN = EN + CLng(((XDiffPos(1) + (Len(StrainSeq(0)) - EN)) / 2) - 0.1)
    
    End If
End If


If EN > Len(StrainSeq(0)) Then
                                     
    If CircularFlag = 0 Then 'seqs linear
        EN = Len(StrainSeq(0))
        
    Else
        EN = EN - Len(StrainSeq(0))
    End If
End If
Z = EN
CycleX = 0
If SEventNumber > 0 Then
    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
        EWarn = 1
        
'        If X = 12345 Then
'            Z = GoLeft(Seq1, Seq2, Seq3, CircularFlag, Z, Len(StrainSeq(0)), UBound(MissingData, 1), MissingData(0, 0))
'        Else
            Z = GoLeftP(Seq1, Seq2, Seq3, CircularFlag, Z, Len(StrainSeq(0)), UBound(MissingData, 1), MissingData(0, 0))
'        End If
    End If
    EN = Z
End If
If CircularFlag = 0 Then
    If OBE = 0 And oEN = 0 Then
        If XPosDiff(EN) > LenXoverSeq - LSS Then
            EWarn = 1
        End If
    Else
        
        'find First pos from right where xdiffpos < en
        For g = LenXoverSeq To LenXoverSeq - LSS Step -1
            If XDiffPos(g) < Z Then
                EWarn = 1
            End If
            
        
        Next g
    End If
End If
End Sub
Public Sub CentreBP2(ElementX As Long, OBE, oEN, Seq1, Seq2, Seq3, BE, EN, XPosDiff() As Long, XDiffPos() As Long, BWarn, EWarn, LSS, LenXoverSeq)
Dim g As Long, Z As Long
'@
If OBE = 0 And oEN = 0 Then
    If XPosDiff(BE, ElementX) - 1 > 0 Then
        BE = BE - CLng(((BE - XDiffPos(XPosDiff(BE, ElementX) - 1, ElementX)) / 2) - 0.1)
    Else
        BE = BE - CLng(((BE + Len(StrainSeq(0)) - XDiffPos(LenXoverSeq, ElementX)) / 2) - 0.1)
    End If
Else
    If OBE - 1 > 0 Then
        
        BE = BE - CLng(((BE - XDiffPos(OBE - 1, ElementX)) / 2) - 0.1)
    Else
        BE = BE - CLng(((BE + Len(StrainSeq(0)) - XDiffPos(LenXoverSeq, ElementX)) / 2) - 0.1)
    
    End If
End If
If BE = 0 Then
    BE = 1
ElseIf BE < 1 Then
    If CircularFlag = 0 Then 'seqs linear
        BE = 1
    Else
        BE = Len(StrainSeq(0)) + BE
    End If
End If

Z = BE
Dim CycleX As Integer
If SEventNumber > 0 Then
    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
        BWarn = 1
        
'        If X = X Then
            '@
            Z = GoRight(Seq1, Seq2, Seq3, CircularFlag, Z, Len(StrainSeq(0)), UBound(MissingData, 1), MissingData(0, 0))
            
'        Else
'            CycleX = 0
'            Do
'                Z = Z + 1
'
'                If Z > Len(StrainSeq(0)) Then
'                    If CircularFlag = 0 Then
'                        Z = 1
'                        Exit Do
'                    Else
'                        Z = 1
'                        CycleX = CycleX + 1
'                        If CycleX = 3 Then
'                            Exit Do
'                        End If
'                    End If
'                End If
'                If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
'                    Exit Do
'                End If
'            Loop
'        End If
    End If
End If



BE = Z


If CircularFlag = 0 Then
'
    
    If OBE = 0 And oEN = 0 Then
        If XPosDiff(BE, ElementX) < LSS Then
            BWarn = 1
        End If
    Else
        
        'find First pos from right where xdiffpos < en
        For g = 1 To LSS
            If XDiffPos(g, ElementX) > Z Then
                BWarn = 1
            End If
            
        
        Next g
    End If
End If



'
XPosDiff(Len(StrainSeq(0)), ElementX) = LenXoverSeq
'XX = XDiffpos(LenXoverSeq)
'EN = 850

If OBE = 0 And oEN = 0 Then
    '@
    If XPosDiff(EN, ElementX) + 1 <= LenXoverSeq Then
        EN = EN + CLng(((XDiffPos(XPosDiff(EN, ElementX) + 1, ElementX) - EN) / 2) - 0.1)
    Else
        EN = EN + CLng(((XDiffPos(1, ElementX) + (Len(StrainSeq(0)) - EN)) / 2) - 0.1)
    End If
Else
    If oEN + 1 <= LenXoverSeq Then
        
        EN = EN + CLng(((XDiffPos(oEN + 1, ElementX) - EN) / 2) - 0.1)
    Else
        EN = EN + CLng(((XDiffPos(1, ElementX) + (Len(StrainSeq(0)) - EN)) / 2) - 0.1)
    
    End If
End If


If EN > Len(StrainSeq(0)) Then
                                     
    If CircularFlag = 0 Then 'seqs linear
        EN = Len(StrainSeq(0))
        
    Else
        EN = EN - Len(StrainSeq(0))
    End If
End If
Z = EN
CycleX = 0
'@
If SEventNumber > 0 Then
    If MissingData(Z, Seq1) = 1 Or MissingData(Z, Seq2) = 1 Or MissingData(Z, Seq3) = 1 Then
        EWarn = 1
        
'        If X = X Then
            Z = GoLeft(Seq1, Seq2, Seq3, CircularFlag, Z, Len(StrainSeq(0)), UBound(MissingData, 1), MissingData(0, 0))
'        Else
'
'            Do
'                Z = Z - 1
'
'                If Z < 1 Then
'                    If CircularFlag = 0 Then
'                        Z = Len(StrainSeq(0))
'                        Exit Do
'                    Else
'                        Z = Len(StrainSeq(0))
'                        CycleX = CycleX + 1
'                        If CycleX > 2 Then
'                            Exit Do
'                        End If
'                    End If
'                End If
'                If MissingData(Z, Seq1) = 0 And MissingData(Z, Seq2) = 0 And MissingData(Z, Seq3) = 0 Then
'
'                    Exit Do
'                End If
'            Loop
'        End If
    End If
    EN = Z
End If
If CircularFlag = 0 Then
    If OBE = 0 And oEN = 0 Then
        If XPosDiff(EN, ElementX) > LenXoverSeq - LSS Then
            EWarn = 1
        End If
    Else
        
        'find First pos from right where xdiffpos < en
        For g = LenXoverSeq To LenXoverSeq - LSS Step -1
            If XDiffPos(g, ElementX) < Z Then
                EWarn = 1
            End If
            
        
        Next g
    End If
End If
End Sub
Public Sub DrawCompatMat()
Dim PSize As Long, Pict As Long
Dim x As Long, Y As Long, RelaventSites() As Long, tCnt As Byte, VarNum As Long, BinMat() As Byte, YP As Long, XP As Long
Dim CompSeq As Long, tCMat() As Byte
ssxx = Abs(GetTickCount)
Form1.Command25.Enabled = True
Form1.Command25.ToolTipText = "Stop making the matrix"
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True
Call UnModNextno
Call UnModSeqNum(0)
If DoneMatX(0) = 0 Then
    DoneMatX(0) = 1
    ReDim RelaventSites(100, Len(StrainSeq(0)))
    ReDim VarsitesCM(Len(StrainSeq(0)))
    For Y = 1 To Len(StrainSeq(0))
        For x = 0 To PermNextno
            RelaventSites(SeqNum(Y, x), Y) = RelaventSites(SeqNum(Y, x), Y) + 1
        Next x
    Next Y
    VarNum = 0
    For Y = 1 To Len(StrainSeq(0))
        tCnt = 0
        If RelaventSites(66, Y) > 1 Then
            tCnt = tCnt + 1
        End If
        If RelaventSites(68, Y) > 1 Then
            tCnt = tCnt + 1
        End If
        If RelaventSites(72, Y) > 1 Then
            tCnt = tCnt + 1
        End If
        If RelaventSites(85, Y) > 1 Then
            tCnt = tCnt + 1
        End If
        If tCnt = 2 Then
            VarsitesCM(VarNum) = Y
            VarNum = VarNum + 1
        End If
    Next Y
    VarNum = VarNum - 1
    ReDim BinMat(VarNum, PermNextno)
    For x = 0 To VarNum
        For Y = 0 To PermNextno
            If SeqNum(VarsitesCM(x), Y) <> 46 Then
                CompSeq = Y
                Exit For
            End If
        Next Y
        For Y = 0 To PermNextno
            If SeqNum(VarsitesCM(x), Y) <> 46 Then
                If SeqNum(VarsitesCM(x), Y) <> SeqNum(VarsitesCM(x), CompSeq) Then
                    BinMat(x, Y) = 1
                Else
                    BinMat(x, Y) = 0
                End If
            Else
                BinMat(x, Y) = 2
            End If
        Next Y
    Next x
    ReDim tCMat(1, 1)
    ReDim MatrixC(VarNum, VarNum)
    Dim NTS As Long, NDone As Long
    NTS = (VarNum + 1) * (VarNum) / 2
    SS = Abs(GetTickCount)
    For x = 0 To VarNum
        
        If x = x Then
            NDx = FillMatrixC(NDone, x, VarNum, PermNextno, tCMat(0, 0), BinMat(0, 0), MatrixC(0, 0))
            NDone = NDx
        Else
            For Y = x + 1 To VarNum
                tCMat(0, 0) = 0: tCMat(0, 1) = 0: tCMat(1, 0) = 0: tCMat(1, 1) = 0
                NDone = NDone + 1
                GoOn = 0
                For Z = 0 To PermNextno
                    A = BinMat(x, Z)
                    b = BinMat(Y, Z)
                    'Exit Sub
                    If A < 2 And b < 2 Then
                        If tCMat(A, b) = 0 Then
                            tCMat(A, b) = 1
                            tCnt = tCMat(0, 0) + tCMat(0, 1) + tCMat(1, 0) + tCMat(1, 1)
                            If tCnt = 4 Then GoOn = 1: Exit For
                        End If
                    End If
                Next Z
                'tCnt = tCMat(0, 0) + tCMat(0, 1) + tCMat(1, 0) + tCMat(1, 1)
                If GoOn = 1 Then
                    MatrixC(x, Y) = 1
                    MatrixC(Y, x) = 1
                End If
                
            Next Y
        End If
        
        
        
        
        nt = Abs(GetTickCount)
        
        If Abs(nt - LT) > 200 Then
            
            If AbortFlag = 1 Then
                Form1.Command25.Enabled = False
                Form1.Command25.ToolTipText = ""
                Form1.Picture26.Refresh
                Form1.SSPanel1.Caption = ""
                Form1.ProgressBar1 = 0
                Call UpdateF2Prog
                Exit Sub
            End If
            LT = nt
            Form1.ProgressBar1 = 10 + (NDone / NTS) * 70
            Form1.SSPanel1.Caption = Str(NDone) + " of" + Str(NTS) + " site pairs screened"
            Call UpdateF2Prog
            If DontRefreshFlag = 0 Then
                Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        End If
    Next x
    MatBound(0) = VarNum
    EE = Abs(GetTickCount)
            TT = EE - SS
            '53297
            '656
            '11657 - David robertson HIV results
            '10656
            x = x
Else
    VarNum = MatBound(0)
End If



    
    Dim cAddj As Long, MatPic() As Single, PosS(1) As Single, PosE(1) As Single, DistD As Long
    
    
    DistD = VarNum / MatZoom(0)
    Dim XAD As Single
    Form1.Picture26.ScaleMode = 3
    XAddj = (Form1.Picture26.ScaleHeight) / DistD
    XAD = XAddj
    cAddj = (Int((1 / XAddj) + 1)) ^ 2
    cAddj = Int(255 / cAddj) '(255 * (XAddj ^ 2)) - 1
    
    If cAddj > 255 Then cAddj = 255
    If XAddj <= 1 Then
        PSize = XAddj * VarNum
    Else
        PSize = VarNum
    End If
    If XAddj > 1 Then
        Span = Int(XAddj + 1)
    Else
        Span = 1
    End If
    Dim SpT As Long, SpE As Long
    SpT = CLng(-(Span / 2)) + 1
    SpE = CLng((Span / 2) - 0.00001)
    If SpT > SpE Then SpT = SpE
    
    'if spt=spe
    PosS(0) = MatCoord(0, 0)
    PosE(0) = PosS(0) + DistD
    PosS(1) = MatCoord(0, 1)
    PosE(1) = PosS(1) + DistD
    If PosE(1) > (UBound(MatrixC, 1) - 1) - 1 Then PosE(1) = (UBound(MatrixC, 1) - 1) - 1
    If PosE(0) > (UBound(MatrixC, 1) - 1) - 1 Then PosE(0) = (UBound(MatrixC, 1) - 1) - 1
       
    If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
    If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
    
    SSAa = Abs(GetTickCount)
    
    ReDim MatPic(PSize + 1, PSize + 1)
    
    
    
    'If XAddj < 1 Then
    
    EE = Abs(GetTickCount)
    TT = EE - ssxx
    
    SS = Abs(GetTickCount)
    If XAddj <= 1 Then
        If SpT <> SpE Then
            For Y = SY To PosE(1)
                For x = SX To PosE(0)
                
                    If MatrixC(x, Y) = 1 Then
                        For A = SpT To SpE
                            If CLng(x * XAD) + A >= 0 And CLng(x * XAD) + A <= PSize Then
                                For b = SpT To SpE
                                    If CLng(Y * XAD) + b >= 0 And CLng(Y * XAD) + b <= PSize Then
                                        If MatPic(CLng(x * XAD + 0.001) + A, CLng(Y * XAD + 0.001) + b) + cAddj <= 255 Then
                                            MatPic(CLng(x * XAD + 0.001) + A, CLng(Y * XAD + 0.001) + b) = MatPic(CLng(x * XAD + 0.001) + A, CLng(Y * XAD + 0.001) + b) + cAddj
                                            
                                        End If
                                    End If
                                Next b
                            End If
                        Next A
                    End If
                Next x
            Next Y
        
        
        
        Else
            If x = x Then
                
                MaxN = ModMatPic(cAddj, SY, SX, XAD, PosE(0), PosE(1), UBound(MatPic, 1), UBound(MatrixC, 1), MatPic(0, 0), MatrixC(0, 0))
                x = x
'            Else
'                For Y = SY To PosE(1)
'                    YP = CLng(Y * XAD + 0.001)
'                    For X = SX To PosE(0)
'
'                        If MatrixC(X, Y) = 1 Then
'                            XP = CLng(X * XAD + 0.001)
'                            MatPic(XP, YP) = MatPic(XP, YP) + cAddj
'                        End If
'                    Next X
'                Next Y
            End If
        End If
    Else
'        For X = 0 To VarNum
'            For Y = 0 To VarNum
'                If MatrixC(X, Y) = 1 Then
'                    MatPic(X, Y) = 255
'                End If
'            Next Y
'        Next X
        SSA = Abs(GetTickCount)
        If x = x Then
            MaxN = MatCToMatPic(SX, SY, PosE(0), PosE(1), UBound(MatPic, 1), UBound(MatrixC, 1), MatPic(0, 0), MatrixC(0, 0))
'        Else
'
'            For X = SX To PosE(0)
'                For Y = SY To PosE(1)
'                    If MatrixC(X, Y) = 1 Then
'                        MatPic(X, Y) = 255
'                    End If
'                Next Y
'            Next X
        End If
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS
    x = x
'Else
    
'    SS = Abs(GetTickCount)
'    'SS = Abs(GetTickCount)
'    If X = 123445677 Then 'this is not working for matpic
'        MaxN = FindMaxNS(PSize, MatPic(0, 0))
'
'    ElseIf X = 1234567890 Then
'        MaxN = 0
'        For X = 0 To PSize
'            For Y = 0 To PSize
'                If MatPic(X, Y) > MaxN Then
'                    MaxN = MatPic(X, Y)
'                End If
'            Next Y
'        Next X
'
'    End If
'    MaxN = MaxN / (cAddj)
    
    MaxN = CLng(((1 / XAddj)) ^ 2)
    If MaxN = 0 Then MaxN = 1
    
    
    
    x = x
'Else
'    For X = 0 To VarNum
'        For Y = 0 To VarNum
'            If MatrixC(X, Y) = 1 Then
'                MatPic(CLng(X * XAddj), CLng(Y * XAddj)) = MatPic(CLng(X * XAddj), CLng(Y * XAddj)) + cAddj
'            End If
'        Next Y
'    Next X
'End If


'Form1.Picture26.Picture = LoadPicture()
'Form1.Picture26.ScaleMode = 3
'Form1.Picture26.AutoRedraw = True


'If XAddj > 1 Then
'    Form1.Picture26.DrawWidth = CInt(XAddj + 1)
'End If
'Pict = Form1.Picture26.hdc
'Dim PntAPI As POINTAPI
'If XAddj < 1 Then xaddjx = 1 Else xaddjx = XAddj

Dim PosEx(1) As Single, PosSx(1) As Single

For x = 0 To 1
    PosEx(x) = CLng(PosE(x) * XAD + 0.001)
    PosSx(x) = CLng(PosS(x) * XAD + 0.001)
Next x

eexx = Abs(GetTickCount)


TT = eexx - ssxx
T = eexx - SSAa
tttt = eexx - SSA
ttt = eexx - SS



SSA = Abs(GetTickCount)

If XAddj <= 1 Then
    Call DrawMatsVB(Form1.Picture26, 0, PosEx(), PosSx(), SX * XAddj, SY * XAddj, 1, MatPic(), HeatMap, 1, MaxN * cAddj)
Else
    Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatPic(), HeatMap, 1, 255)
End If
    

 EE = Abs(GetTickCount)
 TT = EE - ssxx
 ttt = EE - SSA
    x = x '0.889,0.422, 0.343
x = x
If DontDoKey = 0 Or x = x Then
    Call DoKey(0, MaxN, 0, 0, "Number of incompatible sites", 1)
End If
Form1.Command25.Enabled = False
Form1.Command25.ToolTipText = ""
Form1.Frame7.Enabled = True
Form1.Picture23(1).Enabled = True
If DontRefreshFlag = 0 Then
    Form1.Picture26.Refresh
End If
Form1.SSPanel1.Caption = ""
Form1.ProgressBar1 = 0
Call UpdateF2Prog
End Sub
Public Sub DoColourScale()
Dim PHeight As Long, XAddj As Single, x As Long
Form3.Picture1.ScaleMode = 3
Form3.Picture1.AutoRedraw = True
PHeight = Form3.Picture1.Height
XAddj = Form3.Picture1.ScaleWidth / 1020
If Form1.SSPanel6(2).Visible = True Then
    oF1T3E = Form1.Timer3.Enabled
    oF1T3I = Form1.Timer3.Interval
    Form1.Timer3.Interval = 24
    Form1.Timer3.Enabled = True
End If
For x = 0 To 1020
    Form3.Picture1.Line (x * XAddj, 0)-(x * XAddj, PHeight), HeatMap(CurScale, x)
Next x
Form3.Picture1.Refresh

End Sub
Public Sub DoAlnAddj(SNNextNo, AdjustAlign() As Long)

Dim TDist() As Double, WinSeq(1) As Long, MaxDist As Double, SeqsIn() As Integer, SeqsOut() As Integer, MaxLen As Long
ReDim TDist(NextNo)
'do a profile aignment of sequences in two separate RDP files

'First work out which sequences have the smallest distance to all others
    


For x = 0 To SNNextNo - 1
    For Y = 0 To SNNextNo - 1
        TDist(x) = TDist(x) + Distance(x, Y)
    Next Y
Next x
For x = SNNextNo To NextNo
    For Y = SNNextNo To NextNo
        TDist(x) = TDist(x) + Distance(x, Y)
    Next Y
Next x
If PermNextno > MemPoc And x = 1234567 Then
    ReDim Distance(0, 0)
End If
MaxDist = 0
For x = 0 To SNNextNo - 1
    If MaxDist < TDist(x) Then
        MaxDist = TDist(x)
        WinSeq(0) = x
    End If
Next x

MaxDist = 0
For x = SNNextNo To NextNo
    If MaxDist < TDist(x) Then
        MaxDist = TDist(x)
        WinSeq(1) = x
    End If
Next x

WinSeq(1) = SNNextNo
WinSeq(0) = 0

MaxLen = Len(StrainSeq(0)) * 2
ReDim SeqsIn(MaxLen, 1), SeqsOut(MaxLen, 1)

For Z = 0 To 1
    Y = 0
    For x = 1 To Len(StrainSeq(0))
        'If SeqNum(X, WinSeq(Z)) <> 46 Then
            Y = Y + 1
            SeqsIn(Y, Z) = SeqNum(x, (WinSeq(Z)))
        'End If
    Next x
Next Z
Form1.SSPanel1.Caption = "Doing profile alignment"

    Call doAlignmentSh(UFTag, 0, SeqsIn(), SeqsOut(), 1, MaxLen, 10, 5, 1)

Dim tSeqnum() As Integer, NonG(1, 1) As Long, NonGSeq()
NonG(0, 0) = 0: NonG(1, 0) = 0: NonG(0, 1) = 0: NonG(1, 1) = 0


ReDim tSeqnum(MaxLen, NextNo), NonGSeq(MaxLen, 1, 1)
For Z = 0 To 1
    For x = 1 To MaxLen
        If x <= UBound(SeqNum, 1) Then
            If SeqNum(x, WinSeq(Z)) <> 46 Then
                NonG(Z, 0) = NonG(Z, 0) + 1
                NonGSeq(NonG(Z, 0), Z, 0) = x
            End If
        End If
        If SeqsOut(x, Z) <> 46 And SeqsOut(x, Z) <> 0 Then
            NonG(Z, 1) = NonG(Z, 1) + 1
            NonGSeq(NonG(Z, 1), Z, 1) = x
        End If
    Next x
Next Z
Dim AddGaps() As Long, SP(1), EP(1)
ReDim AddGaps(MaxLen, 1)

SP(0) = 0: SP(1) = SNNextNo
EP(0) = SNNextNo - 1: EP(1) = NextNo

ReDim AdjustAlign(Len(StrainSeq(0)) * 2, 1)


For Z = 0 To 1
    For x = 1 To NonG(Z, 1)
        If NonGSeq(x + 1, Z, 0) > 0 Then
            A = NonGSeq(x + 1, Z, 0) - NonGSeq(x, Z, 0) - 1
        Else
            A = 0
        End If
        
        For b = 0 To A
            AdjustAlign(NonGSeq(x, Z, 0) + b, Z) = NonGSeq(x, Z, 1) + b
            'tSeqNum(NonGSeq(X, Z, 1) + B, Y) = SeqNum(NonGSeq(X, Z, 0) + B, Y)
        Next b
        For Y = SP(Z) To EP(Z)
            
            For b = 0 To A
                tSeqnum(NonGSeq(x, Z, 1) + b, Y) = SeqNum(NonGSeq(x, Z, 0) + b, Y)
            Next b
        Next Y
    Next x
    
Next Z




Dim EndSeq As Long

For Z = MaxLen To 1 Step -1
    If tSeqnum(Z, 0) <> 0 Then
        For x = Z To 1 Step -1
            GoOn = 1
            For Y = 0 To NextNo
                If tSeqnum(Z, Y) <> 46 Then
                    GoOn = 0
                    Exit For
                End If
            Next Y
            If GoOn = 0 Then
                EndSeq = x
                Exit For
            End If
        Next x
        Exit For
    End If
Next Z

'For Y = 1 To MaxLen
'    If SeqsOut(Y, 0) = 0 Then
'        EndSeq = Y - 1
'        Exit For
'    End If
'Next Y


ReDim SeqNum(EndSeq, NextNo)
For x = 0 To NextNo
    For Y = 1 To EndSeq
        If tSeqnum(Y, x) <> 0 Then
            SeqNum(Y, x) = tSeqnum(Y, x)
        Else
            SeqNum(Y, x) = 46
        End If
    Next Y
Next x

ReDim StrainSeq(NextNo)
Dim TSeq As String
For x = 0 To NextNo
    TSeq = String(EndSeq, " ")
    For Y = 1 To EndSeq
        Mid(TSeq, Y, 1) = Chr(SeqNum(Y, x) - 1)
    Next Y
    StrainSeq(x) = TSeq
Next x
XX = UBound(AdjustAlign, 1)
For Z = 0 To 1
    For x = SP(Z) To EP(Z)
        For Y = 1 To CurrentXOver(x)
            XoverList(x, Y).Beginning = AdjustAlign(XoverList(x, Y).Beginning, Z)
            XoverList(x, Y).Ending = AdjustAlign(XoverList(x, Y).Ending, Z)
        Next Y
        For Y = 1 To BCurrentXoverMa(x)
            BestXOListMa(x, Y).Beginning = AdjustAlign(BestXOListMa(x, Y).Beginning, Z)
            BestXOListMa(x, Y).Ending = AdjustAlign(BestXOListMa(x, Y).Ending, Z)
        Next Y
        For Y = 1 To BCurrentXoverMi(x)
            BestXOListMi(x, Y).Beginning = AdjustAlign(BestXOListMi(x, Y).Beginning, Z)
            BestXOListMi(x, Y).Ending = AdjustAlign(BestXOListMi(x, Y).Ending, Z)
        Next Y
    Next x
Next Z

End Sub
Public Sub RecombMapPermsD(DN As Long, APos() As Long, BPos() As Long, Excl() As Byte, CV() As Double, Win As Long, PermNum As Long, RNDSEED As Long)
    
    Dim SPS As Long, EPS As Long, A As Long, x As Long, MaxPos As Long, MinPos As Long, OffsetX As Long, OffsetY As Long, PPos As Long, Target(1) As Long, MaxV(1) As Double, MaxP(1) As Long, MaxVals() As Long, NewStart As Long, S As Long, NS As Long, NE As Long, LSSeq As Long, RecSize As Long, MaxS As Long, MaP() As Integer, Size As Long, D As Long, P1 As Long, P2 As Long
    Dim tSeqnum() As Integer, tSeqNumORF() As Integer, MaxCycleNo As Long, CycleNo As Long, MapORF() As Integer, MapIR() As Integer
    Dim BestP() As Double, BreakPos() As Long, BreakNum As Long, OKProg(20) As Byte
    Dim xxWin As Double
    Dim SBF As Long
        
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , PermSeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    
    CurrentCheck = 15
    'Call UnModSeqNum(0)
    'SHAPECO = 0.25
    ''XX = SHAPEFlag
    For x = 0 To AddNum - 1
        If DoScans(0, x) = 1 Then OKProg(x) = 1
    Next x
    WinX = Win
    'Dim MinS As Long
    
    If CircularFlag = 0 Then
        
        MinPos = XOverWindowX
    Else
        
        MinPos = 1
    End If
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    b = 0
    C = 0
    Dim PNA As Double
   ' If PermNum < 10000 Then
       PNA = 1
   ' Else
   '     PNA = PermNum / 10000
   ' End If
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    Dim NPX As Long
    If ORFFlag = 1 Then
        If (Len(StrainSeq(0)) * CLng(PermNum / PNA)) > APhys / 16 Then
            
            
            NPX = CLng(PermNum / ((Len(StrainSeq(0)) * CLng(PermNum / PNA)) / (APhys / 16)))
            
            MsgBox ("There is insufficient available memory to run this analysis with " + Trim(Str(PermNum)) + " permutations.  I will use " + Trim(Str(NPX)) + " permutations (the maximum possible) instead.")
            PermNum = NPX
        End If
    Else
        If (Len(StrainSeq(0)) * CLng(PermNum / PNA)) > APhys / 15 Then
            
            
            NPX = CLng(PermNum / ((Len(StrainSeq(0)) * CLng(PermNum / PNA)) / (APhys / 16)))
            
            MsgBox ("There is insufficient available memory to run this analysis with " + Trim(Str(PermNum)) + " permutations.  I will use " + Trim(Str(NPX)) + " permutations (the maximum possible) instead.")
            PermNum = NPX
        End If
    End If
    
    ReDim MaP(Len(StrainSeq(0)), CLng(PermNum / PNA)), MaxVals(1, CLng(PermNum / PNA))
    
    Rnd (-BSRndNumSeed)
    SS = Abs(GetTickCount)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200)
    
    'ExRecFlag = 0
    If ORFFlag = 1 Then
        GlobalMemoryStatus MemSit
        ReDim MapORF(Len(StrainSeq(0)), CLng(PermNum / PNA))
        ReDim MapIR(Len(StrainSeq(0)), CLng(PermNum / PNA))
        Dim GeneMap() As Byte, TestName() As String, LenMap() As Long
        ReDim GeneMap(Len(StrainSeq(0)), GeneNumber * 4), TestName(GeneNumber + 3)
        ReDim LenMap(GeneNumber + 3)
        Y = 0
        For x = 1 To GeneNumber
            ST = GeneList(x).StartInAlign
            EN = GeneList(x).EndInAlign
            EX = GeneList(x).ExonNumber
            
            ORIx = GeneList(x).Orientation
            
            If EX = 1 Or EX = 0 Then
                Y = x 'Y = Y + 1 - it seemed to me that makining y=y+1 could cause problems
                
                Dim PString As String
                PString = GeneList(x).Product
                If PString <> "" And Len(PString) > 40 Then
                    Pos = InStr(1, PString, "protein", vbTextCompare)
                    'If Pos = 0 Then
                    
                    Pos2 = InStr(1, PString, "peptide", vbTextCompare)
                    Pos3 = InStr(1, PString, "subunit", vbTextCompare)
                    If Pos = 0 Then
                        Pos = Po2
                    End If
                    If Pos2 > 0 And Pos2 < Pos Then
                        Pos = Pos2
                    End If
                    If Pos3 > 0 And Pos3 < Pos Then
                        Pos = Pos3
                    End If
                    'End If
                    If Pos > 0 Then
                        PString = Left(PString, Pos + 6)
                    Else
                        PString = Left(PString, 40)
                    End If
                End If
                If Len(PString) > 40 Then
                    PString = Left(PString, 40)
                End If
                If PString <> "" And GeneList(x).Name <> "" Then
                    TestName(Y) = GeneList(x).Name + " (" + PString + ") vs rest of ORFs"
                ElseIf PString <> "" Then
                    TestName(Y) = PString + " vs rest of ORFs"
                ElseIf GeneList(x).Name <> "" Then
                    TestName(Y) = GeneList(x).Name + " vs rest of ORFs"
                Else
                    TestName(Y) = "Gene " + Trim(Str(x)) + " vs rest of ORFs"
                End If
                LenMap(Y) = 0
            Else
                Y = x
            End If
            If ORIx = 2 Then
                Tmp = ST
                ST = EN
                EN = Tmp
            End If
            If ST < EN Then
                For Z = ST To EN
                    GeneMap(Z, Y) = 1
                    GeneMap(Z, 0) = 1
                    'For aa = 0 To Nextno
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(Y) = LenMap(Y) + 1
                    
                    End If
                   ' XX = GeneMap(4, 0)
                Next Z
                x = x
            Else
                
                For Z = ST To Len(StrainSeq(0))
                    GeneMap(Z, x) = 1
                    GeneMap(Z, 0) = 1
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(x) = LenMap(x) + 1
                    End If
                Next Z
                For Z = 1 To EN
                    GeneMap(Z, Y) = 1
                    GeneMap(Z, 0) = 1
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(x) = LenMap(x) + 1
                    End If
                Next Z
                
            End If
        Next x
        TestName(GeneNumber + 1) = "End 50% vs Middle 50%"
        TestName(GeneNumber + 2) = "End 25% vs Middle 75%"
        TestName(GeneNumber + 3) = "End 10% vs Middle 90%"
        Dim COffs(3) As Long
        If SHAPEFlag = 0 Then
            For x = 1 To GeneNumber
                'If X >= 8 Then
                '    X = X
                'End If
                If LenMap(x) > 0 Then
                    COffs(0) = CLng(LenMap(x)) / 4
                    COffs(1) = CLng(LenMap(x)) / 8
                    COffs(2) = CLng(LenMap(x)) / 20
                    
                End If
                C = 0
                For Y = 1 To Len(StrainSeq(0))
                    If GeneMap(Y, x) = 1 Then
                        If SeqNum(Y, 0) <> 46 Then
                            C = C + 1
                        End If
                        If C <= COffs(0) Then
                            GeneMap(Y, x + GeneNumber) = 1
                        End If
                        If C <= COffs(1) Then
                            GeneMap(Y, x + GeneNumber * 2) = 1
                        End If
                        If C <= COffs(2) Then
                            GeneMap(Y, x + GeneNumber * 3) = 1
                        End If
                    End If
                Next Y
                C = 0
                For Y = Len(StrainSeq(0)) To 1 Step -1
                    If GeneMap(Y, x) = 1 Then
                        If SeqNum(Y, 0) <> 46 Then
                            C = C + 1
                        End If
                        If C <= COffs(0) Then
                            GeneMap(Y, x + GeneNumber) = 1
                        End If
                        If C <= COffs(1) Then
                            GeneMap(Y, x + GeneNumber * 2) = 1
                        End If
                        If C <= COffs(2) Then
                            GeneMap(Y, x + GeneNumber * 3) = 1
                        End If
                    End If
                Next Y
            Next x
        Else
            ReDim RefSpaces(Len(StrainSeq(0)))
            'use this to manipulate which sites get tested in the "gene" analyses - I used this to test low shape reactivity-bp association in  the junction sites
            If GeneNumber > 3 Then
                Dim Inscore As Long, OutScore As Long
                For x = 0 To GeneNumber
                     For Y = 0 To Len(StrainSeq(0))
                        GeneMap(Y, x) = 0
                    Next Y
                Next x
                Inscore = 0
                OutScore = 0
                'this is test for the junction regions
                For x = 1 To GeneNumber
                    ST = GeneList(x).StartInAlign
                    EN = GeneList(x).EndInAlign
                    
                   
                    If ST < EN Then
                        For Y = ST To EN
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                GeneMap(Y, 0) = 1
                                Inscore = Inscore + 1
                                'high structure - high similarity -1673 (0.85), 1230 (0.90), 725 (0.925)
                                'high similarity - junction - 1661 (0.85),  860 (0.90), 378 (0.925)
                            Else
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                GeneMap(Y, 0) = 1
                                'low structure - high similarity -6781 (0.85), 4149 (0.90), 2048 (0.925)
                                'low similarity - junction - 370 (0.85),  1171 (0.90), 1653 (0.925)
                            End If
                        Next Y
                    End If
                Next x
                
                x = x
                'Exit Sub
                If x = 12345 Then  'test of non junction sites
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        If GeneMap(Y, 0) = 1 Then
                            GeneMap(Y, 0) = 0
                        Else
                            GeneMap(Y, 0) = 1
                        End If
                        If GeneMap(Y, 1) = 1 Or GeneMap(Y, 2) = 1 Then
                            GeneMap(Y, 1) = 0
                            GeneMap(Y, 2) = 0
                        Else
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                Inscore = Inscore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90), 1031 (0.925)
                                'high similarity - ROG - 6714 (0.85), 4378 (0.90),  2285(0.925)
                            Else
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                'low structure - low similarity - 1019 (0.85), 3651 (0.90), 5752 (0.925)
                                'low similarity - ROG - 812 (0.85), 3148 (0.90), 5241 (0.925)
                            End If
                        End If
                    Next Y
                    x = x
                    'Exit Sub
                ElseIf x = 12345 Then 'test of juncrtion high structure against non-junction high structure
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 0) = 1
                            Inscore = Inscore + 1
                            'high structure - high similarity - 1673 (0.85), 1230 (0.90), 725 (0.925)
                            'high similarity - junction - 1660 (0.85), 860 (0.90), 378 (0.925)
                        ElseIf GeneMap(Y, 2) = 1 Then
                        
                            GeneMap(Y, 2) = 0
                            GeneMap(Y, 0) = 0
                        Else
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90),1031 (0.925)
                                'high similarity - ROG 6714 (0.85), 4378 (0.90), 2285 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                        End If
                    Next Y
                    x = x
                    'Exit Sub
                ElseIf x = 12345 Then 'test the junction low structure with the non-junction lowstructure
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 2) = 1 Then
                            GeneMap(Y, 0) = 1
                            Inscore = Inscore + 1
                            'low structure - high similarity  6781 (0.85), 4149(0.90), 2048 (0.925)
                            'low similarity - junction - 370 (0.85), 1170(0.90), 1652 (0.925)
                        ElseIf GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 1) = 0
                            GeneMap(Y, 0) = 0
                        Else
                            If SHAPEScores(APos(Y)) >= SHAPECO Then
                                GeneMap(Y, 1) = 1
                                OutScore = OutScore + 1
                                'low structure - lowsimilarity - 1019 (0.85), 3651 (0.90), 5752 (0.925)
                                'low similarity - rog - 812 (0.85), 3148 (0.90), 5241 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                            
                            'total:7800 low structure sites split between high and low similarity
                        End If
                    Next Y
                    x = x
                    For Y = 1 To Len(StrainSeq(0))
                        Temp = GeneMap(Y, 1)
                        GeneMap(Y, 1) = GeneMap(Y, 2)
                        GeneMap(Y, 2) = Temp
                    Next Y
                   
                ElseIf x = 1234 Then 'test of junction sites that are above the sahpe cutoff gaainst non-junction sites that are below the shape cutoff
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 0) = 0
                            GeneMap(Y, 1) = 0
                        ElseIf GeneMap(Y, 2) = 1 Then 'i.e. junction sites that are above the shape cutoff
                            Inscore = Inscore + 1
                            'low structure - high similarity - 6781 (0.85), 4149 (0.90), 2048 (0.925)
                            'low similarity - junction 370 (0.85),  1170(0.90), 1652 (0.925)
                            GeneMap(Y, 0) = 1
                        Else 'ie non-junction sites
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                OutScore = OutScore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90), 1031 (0.925)
                                'high similarity - ROG 6714 (0.85), 4378 (0.90), 2285 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                        End If
                       
                    Next Y
                    x = x
                     For Y = 1 To Len(StrainSeq(0))
                        Temp = GeneMap(Y, 1)
                        GeneMap(Y, 1) = GeneMap(Y, 2)
                        GeneMap(Y, 2) = Temp
                    Next Y
                      'Exit Sub
                End If
                
                Open "sitenums.csv" For Append As #22
                    Print #22, Str(Inscore) + "," + Str(OutScore)
                Close #22
                x = x
            End If
        End If
        
        
    End If
    
    
    
    Dim ModnumX() As Double, ModnumY() As Double
    ReDim ModnumX(NextNo), ModnumY(Len(StrainSeq(0)))
    
    If x = x Then
        
        For x = 0 To NextNo
            If InStr(1, OriginalName(x), "parent", vbTextCompare) > 0 Then
                
                    For Y = 1 To Len(StrainSeq(0))
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            ST = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = Len(StrainSeq(0)) To 1 Step -1
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            EN = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = ST To EN
                        
                        ModnumY(Y) = ModnumY(Y) + 1
                        
                    Next Y
                    x = x + 1
            End If
        Next x
        
        
        For x = 0 To NextNo
            'pair_00-85_461A-210C    0,0739
            
            'pair_00-85_859A-914G    0,0654
            'pair_Heather_A115-D89   0,1000
            'pair_Heather_A115-D126  0,0380
            'pair_Heather_A120-D89   0,0440
            'pair_Heather_D126-A120  0,0480
            'pair_90-35_899-122  0,0591
            'pair_90-35_905A-858G    0,0617
            'pair_140-35_461A-210C   0,0568
            'pair_140-35_461A-1033G  0,0617
            'pair_140-35_461A-2116D  0,0573
            'pair_140-35_914-899     0,0620
            'pair_140-35_O5-914G     0,0216
            'pair_140-35_O5-O2   0,0596
            'pair_140-03_899-914     0,0990
            'pair_EPRRE-03_899A-122D     0,0526
            
            'pair_00-85_461A-1033G   0,0761
            If InStr(1, OriginalName(x), "AG00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7610 / 20)
            ElseIf InStr(1, OriginalName(x), "AC00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7390 / 22)
            ElseIf InStr(1, OriginalName(x), "859A-914G00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6540 / 15)
            ElseIf InStr(1, OriginalName(x), "D126-A120", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4800 / 43)
            ElseIf InStr(1, OriginalName(x), "A120-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4400 / 21)
            ElseIf InStr(1, OriginalName(x), "A115-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(10000 / 20)
            ElseIf InStr(1, OriginalName(x), "A115-D126", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(3800 / 20)
            ElseIf InStr(1, OriginalName(x), "A905-G858", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 38)
            ElseIf InStr(1, OriginalName(x), "899A-122D", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5910 / 33)
            ElseIf InStr(1, OriginalName(x), "O32-O35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5960 / 24)
            ElseIf InStr(1, OriginalName(x), "G914-O32", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(2160 / 18)
            ElseIf InStr(1, OriginalName(x), "AG140-35b", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5730 / 25)
            ElseIf InStr(1, OriginalName(x), "AC140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5680 / 26)
            ElseIf InStr(1, OriginalName(x), "AG140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 26)
            ElseIf InStr(1, OriginalName(x), "A899-G914", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(9900 / 24)
            ElseIf InStr(1, OriginalName(x), "914G-899A", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6200 / 24)
            ElseIf InStr(1, OriginalName(x), "A899-D122", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5260 / 14)
            Else
                ModnumX(x) = 1
            End If
            
            
        Next x
        x = x
    Else
        For x = 0 To NextNo
            ModnumX(x) = 1
            
        Next x
        For Y = 1 To Len(StrainSeq(0))
            ModnumY(Y) = 1
        Next Y
    End If
    
    Dim RealTX As Long, PermTX As Long
    RealTX = 0: PermTX = 0
    
    
    If MultBPFlag = 1 Then
        'sort out plant numbers
        Dim TraceHost() As Long, KeepTrack As Long
        Call GetPlantNums(KeepTrack, TraceHost())
        
        Dim IntervalMap() As Long, CountPos As Long
        Call MakeIntervalMap(CountPos, IntervalMap())
        Dim DoneMap() As Byte, DoneMap2() As Byte
        If SHAPEFlag = 1 Then
            
            
            'this averages out the shape scores over regions
            Dim AvSite(), TotSite()
            ReDim AvSite(CountPos), TotSite(CountPos)
            For x = 1 To Len(StrainSeq(0))
                MapPos = IntervalMap(x)
                'CurHost = TraceHost(D)
                AvSite(MapPos) = AvSite(MapPos) + SHAPEScores(x)
                TotSite(MapPos) = TotSite(MapPos) + 1
            Next x
            For x = 0 To CountPos
                AvSite(x) = AvSite(x) / TotSite(x)
                x = x
            Next x
            For x = 1 To Len(StrainSeq(0))
            'If X = Len(StrainSeq(0)) - 23 Then
            '    X = X
            'End If
            
                MapPos = IntervalMap(x)
                'CurHost = TraceHost(D)
                SHAPEScores(x) = AvSite(MapPos)
            Next x
        End If
        
    End If
    
    
    If SHAPEFlag = 1 Then
    
        Dim PolarityFlag As Byte
        Dim SHAPEScore() As Double
        ReDim SHAPEScore(PermNum)
        ReDim DoneMap(CountPos, KeepTrack)
        PolarityFlag = 0
        For x = 1 To Len(StrainSeq(0))
        
            If SHAPEScores(x) < 0 Then PolarityFlag = 1: Exit For
                
           
        Next x
        
        
        For x = 1 To ENumb
            
            
            If Excl(x) = 1 Then
                
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
                    
                    D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                    P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                    P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    SBF = XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag
                    
                    
                    
                    If ExRecFlag = 1 Then
                        GoOn = 0
                        If MultBPFlag = 1 Then
                            MapPos = IntervalMap(ST)
                            CurHost = TraceHost(D)
                            If DoneMap(MapPos, CurHost) = 0 Then
                                DoneMap(MapPos, CurHost) = 1
                               
                                GoOn = 1
                            End If
                        Else
                            GoOn = 1
                        End If
                        If GoOn = 1 Then
                            'S = APos(ST)
                            S = ST
                            If PolarityFlag = 0 Then
                                SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                                RealTX = RealTX + 1
                            Else
                                If P2 = 0 Then ' on the left of the BP is p2 and on the right is p1
                                    SHAPEScore(0) = SHAPEScore(0) - SHAPEScores(S)
                                    RealTX = RealTX + 1
                                Else ' on the left of the BP is p1 and on the right is p2
                                    SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                                    RealTX = RealTX + 1
                                End If
                                
                            End If
                        End If
                    Else
                        If SBF <> 3 And SBF <> 1 Then
                            'S = APos(ST)
                            S = ST
                            SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                            RealTX = RealTX + 1
                        Else
                            x = x
                        End If
                        If SBF <> 3 And SBF <> 2 Then
                            'E = APos(EN)
                            e = EN
                            SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(e)
                            RealTX = RealTX + 1
                        Else
                            x = x
                        End If
                    End If
                End If
            End If
        Next x
    End If
    AAA = Abs(GetTickCount)
    
    
    Dim BEX0 As Long, BEX1 As Long
    
    
    For A = 1 To PermNum
    
        If MultBPFlag = 1 Then
            ReDim DoneMap(CountPos, KeepTrack)
            ReDim DoneMap2(CountPos, KeepTrack)
        End If
        TSX = 0
        PermTX = 0
        ReDim tSeqnum(Len(StrainSeq(0)), NextNo)
        
        If ORFFlag = 1 Then
            ReDim tSeqNumORF(Len(StrainSeq(0)), NextNo)
            
        End If
        If CircularFlag = 0 Then
            For x = 0 To NextNo
            '    For Y = 1 To Len(StrainSeq(0))
                   tSeqnum(1, x) = 1
                   tSeqnum(Len(StrainSeq(0)), x) = 1
            '    Next Y
            Next x
            If ORFFlag = 1 Then
                For x = 0 To NextNo
                '    For Y = 1 To Len(StrainSeq(0))
                       tSeqNumORF(1, x) = 1
                       tSeqNumORF(Len(StrainSeq(0)), x) = 1
                '    Next Y
                Next x
            End If
        End If
        ZZZ = 0
        ggg = 0
        
        onum = 0
        
        For x = 1 To ENumb
            BEX0 = BestEvent(x, 0)
            BEX1 = BestEvent(x, 1)
            
            If Excl(x) = 1 Then
                
                If (BEX0 > 0 Or BEX1 > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BEX0, BEX1).Eventnumber)
                    
                    D = XoverList(BEX0, BEX1).Daughter
                    P1 = XoverList(BEX0, BEX1).MajorP
                    P2 = XoverList(BEX0, BEX1).MinorP
                    ST = XoverList(BEX0, BEX1).Beginning
                    EN = XoverList(BEX0, BEX1).Ending
                    SBF = XoverList(BEX0, BEX1).SBPFlag
                    
                    
                    'pair_00-85_461A-210C    0,0739
                    'pair_00-85_461A-1033G   0,0761
                    'pair_00-85_859A-914G    0,0654
                    'pair_Heather_A115-D89   0,1000
                    'pair_Heather_A115-D126  0,0380
                    'pair_Heather_A120-D89   0,0440
                    'pair_Heather_D126-A120  0,0480
                    'pair_90-35_899-122  0,0591
                    'pair_90-35_905A-858G    0,0617
                    'pair_140-35_461A-210C   0,0568
                    'pair_140-35_461A-1033G  0,0617
                    'pair_140-35_461A-2116D  0,0573
                    'pair_140-35_914-899     0,0620
                    'pair_140-35_O5-914G     0,0216
                    'pair_140-35_O5-O2   0,0596
                    'pair_140-03_899-914     0,0990
                    'pair_EPRRE-03_899A-122D     0,0526
                    
                    
                    If ExRecFlag = 1 Then
                        
                        GoOn = 0
                        If MultBPFlag = 1 Then
                            MapPos = IntervalMap(ST)
                            CurHost = TraceHost(D)
                            If DoneMap(MapPos, CurHost) = 0 Then
                                DoneMap(MapPos, CurHost) = 1
                                GoOn = 1
                            End If
                        Else
                            GoOn = 1
                        End If
                        If GoOn = 1 Then
                            Do
                                NewStart = Int((Len(StrainSeq(0)) * Rnd) + 1)
                                GoOn = 0
                                If SeqNum(NewStart, P1) = SeqNum(NewStart, P2) And SeqNum(NewStart, P1) > 46 And SeqNum(NewStart, P2) > 46 Then
                                    GoOn = 0
                                    If NewStart > 1 Then
                                        For ZZ = NewStart - 1 To 1 Step -1
                                            If SeqNum(ZZ, P1) <> SeqNum(ZZ, P2) Then
                                                GoOn = 1
                                                Exit For
                                            End If
                                        Next ZZ
                                        If GoOn = 1 Then
                                            GoOn = 0
                                            If NewStart < Len(StrainSeq(0)) Then
                                                For ZZ = NewStart + 1 To Len(StrainSeq(0))
                                                    If SeqNum(ZZ, P1) <> SeqNum(ZZ, P2) Then
                                                        GoOn = 1
                                                        Exit For
                                                    End If
                                                Next ZZ
                                            End If
                                        End If
                                        If GoOn = 1 Then
                                            If MultBPFlag = 1 Then
                                                GoOn = 0
                                                MapPos = IntervalMap(NewStart)
                                                CurHost = TraceHost(D)
                                                If DoneMap2(MapPos, CurHost) = 0 Then
                                                    DoneMap2(MapPos, CurHost) = 1
                                                    GoOn = 1
                                                End If
                                                
                                            End If
                                        
                                        End If
                                        
                                        
                                    End If
                                    
                                End If
                                If GoOn = 1 Then Exit Do
                            Loop
                            
                            
                            
                            
                            If ModnumX(D) <> 1 Then
                                For Z = 1 To ModnumX(D)
                                    
                                    
                                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                        Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                    Else
                                        Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                    End If
                                Next Z
                            Else
                                    
                                    
                                    
                                    If x = x Then
                                        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                            Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                        Else
                                            Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                        End If
                                        
                                    Else
                                    
                                        If SBF <> 3 Then
                                            If SBF <> 1 Then
                                                If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                    Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                Else
                                                    Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                                End If
                                                ZZZ = ZZZ + 1
                                            End If
                                            If SBF <> 2 Then
                                                If ST < EN Then
                                                    NewStart = NewStart + (EN - ST)
                                                Else
                                                    NewStart = NewStart + EN + (Len(StrainSeq(0)) - ST)
                                                End If
                                                If NewStart > Len(StrainSeq(0)) Then NewStart = NewStart - Len(StrainSeq(0))
                                                If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                    Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                Else
                                                    Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                                End If
                                                ZZZ = ZZZ + 1
                                            End If
                                        End If
                                    End If
                            End If
                            If ORFFlag = 1 Then
                                MapIR(NewStart, CLng(A / PNA)) = MapIR(NewStart, CLng(A / PNA)) + 1
                            End If
                            If ORFFlag = 1 Then
                                If (GeneMap(ST, 0) = 1 Or GeneMap(EN, 0) = 1) Then 'do tests to see if some orfs have higher rates than ohers
                                    LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                        
                                    If EN > ST Then
                                        RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                                    Else
                                        RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                                    End If
                                    If CircularFlag = 0 Then
                                        MaxS = LSSeq - RecSize - XoverWindow
                                    Else
                                        MaxS = LSSeq
                                    End If
                                    If CircularFlag = 0 Then
                                        MaxS = LSSeq - RecSize - XoverWindow
                                    Else
                                        MaxS = LSSeq
                                    End If
                                    CycleNo = 0
                                    Do
                                        NewStart = Int((MaxS * Rnd) + 1)
                                        GoOn = 0
                                        If NewStart >= MinPos Or SBF = 1 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                        
                                        If GoOn = 1 Then
                                            GoOn = 0
                                            If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                                GoOn = 1
                                            End If
                                        End If
                                        If GoOn = 1 Then
                                            
                                            GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqNumORF(0, 0), NS, NE, XDiffPos(0))
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If GeneMap(NS, 0) = GeneMap(ST, 0) Or (SBF = 1 Or SBF = 3) Then
                                                    GoOn = 1
                                                End If
                                                If GoOn = 1 Then
                                                    GoOn = 0
                                                    If GeneMap(NE, 0) = GeneMap(EN, 0) Or (SBF = 2 Or SBF = 3) Then
                                        
                                                        GoOn = 1
                                                    End If
                                                End If
                                                If GoOn = 1 Then Exit Do
                                            End If
                                            CycleNo = CycleNo + 1
                                            If CycleNo > MaxCycleNo Then
                                                x = x
                                                XX = A
                                                Exit Do
                                            End If
                                        End If
                                    Loop
                                    OffsetY = NS - ST
                                    If SBF <> 3 Then
                                    
                                        For D = 0 To 1
                                            GoOn = 0
                                            If D = 0 Then
                                                
                                                If SBF <> 1 And GeneMap(ST, 0) = 1 Then
                                                    
                                                    S = NS: GoOn = 1
                                                   
                                                End If
                                            Else
                                                If SBF <> 2 And GeneMap(EN, 0) = 1 Then
                                                    S = NE: GoOn = 1
                                                End If
                                            End If
                                        
                                            If GoOn = 1 Then
                                                
                                                'Dummy = AddToMap(CLng(A / PNA), S, 1, Len(StrainSeq(0)), APos(0), MapORF(0, 0))
                                                onum = onum + 1
                                                
                                                
                                                MapORF(S, CLng(A / PNA)) = MapORF(S, CLng(A / PNA)) + 1
                                            End If
                                        Next D
                                    
                                    End If
                                    
                                    'check the start
                                    
                                    'check the end
                                    
                                End If
                            
                            End If
                            If SHAPEFlag = 1 Then
                                'S = APos(NewStart)
                                If PolarityFlag = 0 Then
                                    'TSX = TSX + SHAPEScores(APos(EN))
                                    TSX = TSX + SHAPEScores(EN)
                                    'SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(APos(NewStart))
                                    SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(NewStart)
                                    PermTX = PermTX + 1
                                Else
                                    If P2 = 0 Then
                                        'TSX = TSX + SHAPEScores(APos(EN))
                                        TSX = TSX + SHAPEScores(EN)
                                        'SHAPEScore(A) = SHAPEScore(A) - SHAPEScores(APos(NewStart))
                                        SHAPEScore(A) = SHAPEScore(A) - SHAPEScores(NewStart)
                                        PermTX = PermTX + 1
                                    Else
                                        'TSX = TSX + SHAPEScores(APos(EN))
                                        TSX = TSX + SHAPEScores(EN)
                                        'SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(APos(NewStart))
                                        SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(NewStart)
                                        PermTX = PermTX + 1
                                    End If
                                
                                End If
                            End If
                        End If
                    ElseIf ExRecFlag = 2 Then
                        
                            NewStart = Int(((Len(StrainSeq(0)) - 96) * Rnd) + 1) + 48
                            
                        For Z = 1 To ModnumX(D)
                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                            Else
                                Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                            End If
                        Next Z
                    Else
                        'Make variable sites array
                        
                       
                        
                        LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                        
                        If EN > ST Then
                            RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                        Else
                            RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                        End If
                        If CircularFlag = 0 Then
                            MaxS = LSSeq - RecSize - XoverWindow
                        Else
                            MaxS = LSSeq
                        End If
                        
                        'Make new ending and start for this event
                    
                        'For A = 1 To PermNum
                            MaxCycleNo = LSSeq * 5
                            CycleNo = 0
                            If MaxS <= MinPos Then
                                MaxS = MinPos
                            End If
                            'set up exceptions for single bp recombinants (possible with linear sequences but not with circular ones)
                            Dim EFX As Byte
                            EFX = 0
                            If CircularFlag = 0 Then
                                If SBF = 1 And XPosDiff(ST) < 10 Then
                                    EFX = 1
                                ElseIf SBF = 2 And XPosDiff(EN) > LSSeq - 10 Then
                                    EFX = 2
                                End If
                            End If
                            
                            Do
                                
                                
                                If EFX > 0 Then
                                
                                    NewStart = Int(((LSSeq) * Rnd) + 1)
                                    If LSSeq - NewStart > MinPos And NewStart > MinPos Then
                                        If EFX = 1 Then
                                            NS = 1
                                        Else
                                            NS = XDiffPos(NewStart)
                                        End If
                                        If EFX = 2 Then
                                            NE = Len(StrainSeq(0))
                                        Else
                                            NE = Len(StrainSeq(0)) - XDiffPos(NewStart)
                                        End If
                                        Exit Do
                                    Else
                                        x = x
                                    End If
                                    CycleNo = CycleNo + 1
                                    If CycleNo > MaxCycleNo Then Exit Do
                                 '   RecSize = LSSeq - NewStart
                                 '   If NewStart < RecSize Then RecSize = NewStart
                                 '   GoOn = CheckBPOL(Len(StrainSeq(0)), d, LSSeq, NewStart, RecSize, tSeqNum(0, 0), NS, NE, XDiffpos(0))
                                 '   If GoOn = 1 Then Exit Do
                                Else
                                
                                    NewStart = Int((MaxS * Rnd) + 1)
                                    GoOn = 0
                                    
                                    If NewStart >= MinPos Or SBF = 1 Or SBF = 3 Then
                                        
                                        GoOn = 1
                                    End If
                                    
                                    If GoOn = 1 Then
                                    
                                        GoOn = 0
                                        If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                    End If
                                    If GoOn = 1 Then
                                        
                                        GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqnum(0, 0), NS, NE, XDiffPos(0))
                                        
                                        If GoOn = 1 Then Exit Do
                                        CycleNo = CycleNo + 1
                                        If CycleNo > MaxCycleNo Then Exit Do
                                    End If
                                End If
                            Loop
                            OffsetX = NS - ST
                            
                            If SBF <> 3 Then
                                
                                    For D = 0 To 1
                                        GoOn = 0
                                        If D = 0 Then
                                            
                                            If SBF <> 1 Then
                                                
                                                S = APos(NS): OS = NS: GoOn = 1
                                               
                                                
                                            
                                            End If
                                        Else
                                            If SBF <> 2 Then
                                                S = APos(NE): OS = NE: GoOn = 1
                                            End If
                                        End If
                                    
                                        If GoOn = 1 Then
                                            ZZZ = ZZZ + 1
                                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                Dummy = AddToMap(CLng(A / PNA), S, Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                
                                            Else
                                                Call AddToMapVB(CLng(A / PNA), Decompress(S), Win, MaP())
                                            End If
                                            If ORFFlag = 1 Then
                                                'If SHAPEFlag = 0 Or (SHAPEFlag = 1 And SHAPEScore(A) < SHAPECO) Then
                                                    MapIR(OS, CLng(A / PNA)) = MapIR(OS, CLng(A / PNA)) + 1
                                                'End If
                                            End If
                                            If SHAPEFlag = 1 Then
                                                SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(S)
                                                
                                                
                                                PermTX = PermTX + 1
                                            End If
                                            
                                        End If
                                    Next D
                                
                            End If
                            
                            
                            
                            
                            If ORFFlag = 1 Then
                                If (GeneMap(ST, 0) = 1 Or GeneMap(EN, 0) = 1) Then 'do tests to see if some orfs have higher rates than ohers
                                    CycleNo = 0
                                    Do
                                        NewStart = Int((MaxS * Rnd) + 1)
                                        
                                        GoOn = 0
                                        If NewStart >= MinPos Or SBF = 1 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                        
                                        If GoOn = 1 Then
                                            GoOn = 0
                                            If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                                GoOn = 1
                                                
                                            End If
                                        End If
                                        If GoOn = 1 Then
                                            
                                            GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqNumORF(0, 0), NS, NE, XDiffPos(0))
                                            
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If GeneMap(NS, 0) = GeneMap(ST, 0) Or (SBF = 1 Or SBF = 3) Then
                                                    GoOn = 1
                                                End If
                                                If GoOn = 1 Then
                                                    GoOn = 0
                                                    If GeneMap(NE, 0) = GeneMap(EN, 0) Or (SBF = 2 Or SBF = 3) Then
                                        
                                                        GoOn = 1
                                                        
                                                    End If
                                                End If
                                                If GoOn = 1 Then Exit Do
                                                
                                            End If
                                            CycleNo = CycleNo + 1
                                            If CycleNo > MaxCycleNo Then
                                                x = x
                                                XX = A
                                                Exit Do
                                            End If
                                        End If
                                    Loop
                                    OffsetY = NS - ST
                                    If SBF <> 3 Then
                                    
                                        For D = 0 To 1
                                            GoOn = 0
                                            If D = 0 Then
                                                
                                                If SBF <> 1 And GeneMap(ST, 0) = 1 Then
                                                    
                                                    S = NS: GoOn = 1
                                                   
                                                End If
                                            Else
                                                If SBF <> 2 And GeneMap(EN, 0) = 1 Then
                                                    S = NE: GoOn = 1
                                                End If
                                            End If
                                        
                                            If GoOn = 1 Then
                                                
                                                'Dummy = AddToMap(CLng(A / PNA), S, 1, Len(StrainSeq(0)), APos(0), MapORF(0, 0))
                                                onum = onum + 1
                                                
                                                
                                                MapORF(S, CLng(A / PNA)) = MapORF(S, CLng(A / PNA)) + 1
                                            End If
                                        Next D
                                    
                                    End If
                                    
                                    'check the start
                                    
                                    'check the end
                                    
                                End If
                            
                            End If
                            
                         'Next A
                    
                    End If
                    
                    
                    If ExRecFlag = 1 And ORFFlag = 0 Then
                        'tSeqNum(NewStart, Z) = 1
                    Else
                        'ReDim BestP(1, NextNo), BreakPos(1, 1, NextNo)
                        
                        'mark BPs for all the other events
                        'For Y = 1 To SEventNumber
                            SPS = ST + OffsetX
                            EPS = EN + OffsetX
                            If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                            If SPS > Len(StrainSeq(0)) - 2 Then SPS = SPS - (Len(StrainSeq(0)) - 2)
                            If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                            If EPS > Len(StrainSeq(0)) - 2 Then EPS = EPS - (Len(StrainSeq(0)) - 2)
                            For Z = 0 To PermNextno
                                If Daught(x, Z) > 0 Then
                                    
                                    tSeqnum(SPS, Z) = 1: tSeqnum(SPS + 1, Z) = 1: tSeqnum(SPS + 2, Z) = 1
                                    tSeqnum(EPS, Z) = 1: tSeqnum(EPS + 1, Z) = 1: tSeqnum(EPS + 2, Z) = 1
                                End If
                            Next Z
                            
                            If ORFFlag = 1 Then
                                SPS = ST + OffsetY
                                EPS = EN + OffsetY
                                If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                                If SPS > Len(StrainSeq(0)) - 2 Then SPS = SPS - (Len(StrainSeq(0)) - 2)
                                If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                                If EPS > Len(StrainSeq(0)) - 2 Then EPS = EPS - (Len(StrainSeq(0)) - 2)
                                For Z = 0 To PermNextno
                                    
                                    If Daught(x, Z) > 0 Then
                                        tSeqnum(SPS, Z) = 1: tSeqnum(SPS + 1, Z) = 1: tSeqnum(SPS + 2, Z) = 1
                                        tSeqnum(EPS, Z) = 1: tSeqnum(EPS + 1, Z) = 1: tSeqnum(EPS + 2, Z) = 1
                                    End If
                                Next Z
                            
                            End If
                            
                        'Next Y
                    End If
                    
                    
                End If
            End If
        Next x
        ET = Abs(GetTickCount)
        If Abs(ET - LT) > 500 Then
            LT = ET
            Form1.SSPanel1.Caption = Str(A) + " of" + Str(PermNum) + " permutations completed"
            Form1.ProgressBar1.Value = (A / PermNum) * 80
            Call UpdateF2Prog
            If A / 10 = CLng(A / 10) Then
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Else
                Form1.SSPanel1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        End If
        XXX = ZZZ
        x = onum
        XX = PermTX
    Next A
    EEE = Abs(GetTickCount)
    ttt = EEE - AAA '96.034, 88.172 using sbf'88.203'86.502'85.988 all checkbpol optimizations'46.177 only checking every 3rd site
    
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    End If
    
    
    
    
    Erase tSeqnum
    Erase tSeqNumORF
   If SHAPEFlag = 1 Then
        'count how many are < 0
        Dim NSmaller As Long, SHAPEp As Double
        NSmaller = 0
        For x = 1 To PermNum
            If SHAPEScore(0) > SHAPEScore(x) Then '73.306 -91.123
                NSmaller = NSmaller + 1
            End If
        Next x
        SHAPEp = NSmaller / PermNum '0.055
        XX = 1 - SHAPEp
        XX = PermTX
        If SHAPEp < 0.05 Then
            MsgBox ("There is a detectable association between breakpoint positions and the current siteset (p-val < 0" + Trim(Str((NSmaller + 1) / PermNum)) + ")")
        Else
            If SHAPEp < 0.99 Then
                MsgBox ("There is no detectable association between breakpoint positions and the current siteset (p-val < 0" + Trim(Str((NSmaller + 1) / PermNum)) + ")")
            Else
                MsgBox ("There is no detectable association between breakpoint positions and the current siteset (p-val < 1.0)")
            End If
        End If
        x = x
        
        'Exit Sub
   End If
    
   For x = 1 To PermNum
        For Y = 1 To Len(StrainSeq(0))
            
            If ModnumY(BPos(Y)) > 0 Then
            
                MaP(Y, x) = CLng(MaP(Y, x) / ModnumY(BPos(Y)))
            Else
                x = x
            End If
        Next Y
   Next x
   Erase ModnumY
    'get maxes
   EE = Abs(GetTickCount)
   TT = EE - SS
   '16.141
   x = x
   'Exit Sub
    'DN = 1
    SS = Abs(GetTickCount)
    If x = x Then
        Dummy = FindMaxMapVal(DN, Len(StrainSeq(0)), CLng(PermNum / PNA), MaxVals(0, 0), MaP(0, 0))
    Else
        For x = 1 To PermNum
            For Y = DN To Len(StrainSeq(0)) - DN + 1
                If MaxVals(0, CLng(x / PNA)) < MaP(Y, CLng(x / PNA)) Then MaxVals(0, CLng(x / PNA)) = MaP(Y, CLng(x / PNA))
               
            Next Y
            x = x '9,8,9,9,8,8,8,12,7,8,8,10,10
        Next x
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS
    '3.194
    'XX = MaxVals(0, 5) '16,16,16,19,20
    SS = Abs(GetTickCount)
    
    'sort through the top 5% and get the 99% and 95% highest scores
    
    
    
    '***************Uncomment for normal function
    Target(1) = CLng(0.05 * PermNum) + 1
    Target(0) = CLng(0.01 * PermNum) + 1
    
    'Target(1) = CLng(0.05 * PermNum) + 1
    'Target(0) = CLng(0.1 * PermNum) + 1
    For Z = 0 To 1
        If Target(Z) < 1 Then Target(Z) = 1
    Next Z
    For Z = 1 To Target(1)
        MaxV(0) = 0
        MaxV(1) = 0
        For x = 0 To PermNum
            If MaxV(0) < MaxVals(0, CLng(x / PNA)) Then
                MaxV(0) = MaxVals(0, CLng(x / PNA))
                MaxP(0) = x
            End If
            If MaxV(1) < MaxVals(1, CLng(x / PNA)) Then
                MaxV(1) = MaxVals(1, CLng(x / PNA))
                MaxP(1) = x
            End If
        Next x
        If Z = Target(0) Then
            CV(0, 0) = MaxV(0)
            CV(1, 0) = MaxV(1)
        End If
        If Z = Target(1) Then
            CV(0, 1) = MaxV(0)
            CV(1, 1) = MaxV(1)
        End If
        MaxVals(0, CLng(MaxP(0) / PNA)) = 0
        MaxVals(1, CLng(MaxP(1) / PNA)) = 0
    Next Z
    
    
    
    SS = Abs(GetTickCount)
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    x = x
    'CTNames() As String, CTNumlines As Long, CTBlocks() As Long, CTBlockNum As Long, CTText() As String, CTTextNum As Long
    CTNumlines = -1
    If ORFFlag = 1 Then
    
       'xxxxxxx = bits related to saving and displaying the graphic version of the tests
        
        '0 of ctblocks = xpos1, 1 = ypos1, 2 = xpos2, 3 = ypos2, 4 = colour
        '0 of cttext = xpos1, 1 = ypos1, 2 = xposcolour, 3 = text
        Dim StartP As Long, EndP As Long, BlockCol(2) As Long
        ReDim CTBlocks(4, 100), CTText(3, 100) 'xxxxxxxx
        ReDim CTNames(GeneNumber + 10) 'these are used for permenant storage
        
        
        'Form1.Picture2.DrawMode = 2
        BlockCol(0) = RGB(255, 128, 0)
        BlockCol(1) = RGB(0, 128, 255)
        BlockCol(2) = HalfColour 'quartercolour
        CTTextNum = -1
        CTBlockNum = -1
        
        'Need to make TempGeneMaps for 5% 10%, 25% edges
        Dim TempGeneMap() As Byte
        ReDim TempGeneMap(Len(StrainSeq(0)), GeneNumber + 3)
        For Y = 1 To Len(StrainSeq(0))
            If GeneMap(Y, 0) = 0 Then
                TempGeneMap(Y, 0) = 1
                For x = 1 To GeneNumber + 3
                    TempGeneMap(Y, x) = 2
                Next x
            Else
                For x = 1 To GeneNumber
                    TempGeneMap(Y, x) = GeneMap(Y, x)
                    If GeneMap(Y, x + GeneNumber) = 1 Then TempGeneMap(Y, GeneNumber + 1) = 1
                    If GeneMap(Y, x + GeneNumber * 2) = 1 Then TempGeneMap(Y, GeneNumber + 2) = 1
                    If GeneMap(Y, x + GeneNumber * 3) = 1 Then TempGeneMap(Y, GeneNumber + 3) = 1
                Next x
            End If
            
        Next Y
       
        
        
        'Make the blocks - this info is stored in genemap - note genome-length is scaled to the genome length
       CTBlockNum = -1
        For A = 2 To 0 Step -1
            For x = 0 To GeneNumber + 3
                
                For Y = 1 To Len(StrainSeq(0))
                    If TempGeneMap(Y, x) = A Then
                        StartP = Y
                        For Z = Y + 1 To Len(StrainSeq(0))
                            
                            If (TempGeneMap(Z, x) <> A) Or Z = Len(StrainSeq(0)) Then
                                
                                CTBlockNum = CTBlockNum + 1
                                'If CTBlockNum = 97 Then
                                '    X = X
                                'End If
                                If CTBlockNum > UBound(CTBlocks, 2) Then ReDim Preserve CTBlocks(4, CTBlockNum + 100)
                                CTBlocks(0, CTBlockNum) = StartP
                                CTBlocks(1, CTBlockNum) = x * 2 + 3
                                CTBlocks(2, CTBlockNum) = Z - 1
                                CTBlocks(3, CTBlockNum) = x * 2 + 4
                                CTBlocks(4, CTBlockNum) = BlockCol(A)
                                Exit For
                            End If
                        Next Z
                        
                        Y = Z
                    End If
                
                Next Y
            
            Next x
        Next A
        
        
        'Call DrawCTBlocks
        
        
        
        
        
        
        
        
        Dim TestS() As Double, TestArea() As Long 'these are used for temporary storage
        ReDim TestS(GeneNumber + 10, 3) ' test 0 = IR test
                                        'test 1 =gene1 test
                                        'test n = gene n test
                                        'test n+1 = 25% Gene edge test
                                        'test n+2 = 10% Gene edge test
                                        'test n+3 = 5% Gene edge test
        
       ' Call DrawCTBlocks
        
        
        
        
        
        
        ReDim TestArea(GeneNumber + 10, PermNum, 1) ' perm0 = real data, (1) = inarea
        
        For x = 1 To ENumb
            If Excl(x) = 1 Then
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        If GeneMap(ST, 0) = 0 Then
                            TestArea(0, 0, 0) = TestArea(0, 0, 0) + 1
                        Else
                            TestArea(0, 0, 1) = TestArea(0, 0, 1) + 1
                        End If
                        For Z = 1 To GeneNumber
                            If GeneMap(ST, Z) = 0 Then
                                If GeneMap(ST, 0) = 1 Then 'only count stes that are in some ORF.
                                    TestArea(Z, 0, 0) = TestArea(Z, 0, 0) + 1
                                End If
                            Else
                                TestArea(Z, 0, 1) = TestArea(Z, 0, 1) + 1
                                
                            End If
                        Next Z
                        For Z = 1 To GeneNumber
                            If GeneMap(ST, Z + GeneNumber) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count sites that are in same ORF.
                                    TestArea(GeneNumber + 1, 0, 0) = TestArea(GeneNumber + 1, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 1, 0, 1) = TestArea(GeneNumber + 1, 0, 1) + 1
                                
                            End If
                            If GeneMap(ST, Z + GeneNumber * 2) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 2, 0, 0) = TestArea(GeneNumber + 2, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 2, 0, 1) = TestArea(GeneNumber + 2, 0, 1) + 1
                                
                            End If
                            If GeneMap(ST, Z + GeneNumber * 3) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 3, 0, 0) = TestArea(GeneNumber + 3, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 3, 0, 1) = TestArea(GeneNumber + 3, 0, 1) + 1
                            End If
                        Next Z
                    End If
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        If GeneMap(EN, 0) = 0 Then
                            TestArea(0, 0, 0) = TestArea(0, 0, 0) + 1
                        Else
                            TestArea(0, 0, 1) = TestArea(0, 0, 1) + 1
                        End If
                        For Z = 1 To GeneNumber
                            If GeneMap(EN, Z) = 0 Then
                                If GeneMap(EN, 0) = 1 Then 'only count stes that are in some ORF.
                                    TestArea(Z, 0, 0) = TestArea(Z, 0, 0) + 1
                                End If
                            Else
                                TestArea(Z, 0, 1) = TestArea(Z, 0, 1) + 1
                                
                            End If
                        Next Z
                        For Z = 1 To GeneNumber
                            If GeneMap(EN, Z + GeneNumber) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count sites that are in same ORF.
                                    TestArea(GeneNumber + 1, 0, 0) = TestArea(GeneNumber + 1, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 1, 0, 1) = TestArea(GeneNumber + 1, 0, 1) + 1
                                
                            End If
                            If GeneMap(EN, Z + GeneNumber * 2) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 2, 0, 0) = TestArea(GeneNumber + 2, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 2, 0, 1) = TestArea(GeneNumber + 2, 0, 1) + 1
                                
                            End If
                            If GeneMap(EN, Z + GeneNumber * 3) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 3, 0, 0) = TestArea(GeneNumber + 3, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 3, 0, 1) = TestArea(GeneNumber + 3, 0, 1) + 1
                            End If
                        Next Z
                        x = x
                        'XX = GeneMap(EN, 0)
                    End If
                End If
            End If
            
        Next x
            
        For Z = 1 To Len(StrainSeq(0))
            'IR test
            If GeneMap(Z, 0) = 0 Then
                For A = 1 To PermNum
                    TestArea(0, A, 0) = TestArea(0, A, 0) + MapIR(Z, CLng(A / PNA))
                Next A
            Else
                For A = 1 To PermNum
                    TestArea(0, A, 1) = TestArea(0, A, 1) + MapIR(Z, CLng(A / PNA))
                Next A
            End If
            For x = 1 To GeneNumber
               If x = 12345 Then
                    AA = 0
                    'Open "test.csv" For Output As #1
                    
                    For n = 0 To Len(StrainSeq(0))
                        
                            If GeneMap(n, 8) = 1 Then
                                For M = 0 To PermNum
                                    AA = AA + MapORF(n, M) 'gag=7982, nef=3474;gag=10884; nef=2316
                                Next M
                            End If
                        
                    Next n
                    'Close #1
                End If
                If GeneMap(Z, x) = 1 Then
                    For A = 1 To PermNum
                        If MapORF(Z, A) <> 0 Then
                            TestArea(x, A, 1) = TestArea(x, A, 1) + MapORF(Z, A) ' CLng(A / PNA))
                        End If
                    Next A
                Else
                    For A = 1 To PermNum
                        If MapORF(Z, A) <> 0 Then
                            TestArea(x, A, 0) = TestArea(x, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        End If
                    Next A
                End If
                If GeneMap(Z, x) = 1 Then
                    If GeneMap(Z, x + GeneNumber) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 1, A, 1) = TestArea(GeneNumber + 1, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 1, A, 0) = TestArea(GeneNumber + 1, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                    If GeneMap(Z, x + GeneNumber * 2) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 2, A, 1) = TestArea(GeneNumber + 2, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 2, A, 0) = TestArea(GeneNumber + 2, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                    If GeneMap(Z, x + GeneNumber * 3) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 3, A, 1) = TestArea(GeneNumber + 3, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 3, A, 0) = TestArea(GeneNumber + 3, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                End If
                
            Next x
            eexx = Abs(GetTickCount)
            If Abs(eexx - ssxx) > 500 Then
            
                ssxx = eexx
                Form1.SSPanel1.Caption = Str(CLng((Z / Len(StrainSeq(0))) * 100)) + "% of tests completed"
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        Next Z
        
        Form1.SSPanel1.Caption = "100% of tests completed"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            
            
        For x = 0 To GeneNumber
            'Min = PermNum * 2
            'Max = 0
            
            For A = 1 To Len(StrainSeq(0))
                If GeneMap(A, x) = 1 Then GoOn = 1: Exit For
            Next A
            If GoOn = 1 Then
                For A = 1 To PermNum
                    If TestArea(x, A, 0) > TestArea(x, 0, 0) Then x = x 'Tests(X, 0) = Tests(X, 0) + 1
                    If TestArea(x, A, 0) < TestArea(x, 0, 0) Then x = x 'Tests(X, 1) = Tests(X, 1) + 1
                    
                    
                    If TestArea(x, A, 1) >= TestArea(x, 0, 1) Then
                        TestS(x, 1) = TestS(x, 1) + 1
                        'If X = 1 Then
                        '    X = X
                        'End If
                    End If
                    If TestArea(x, A, 1) <= TestArea(x, 0, 1) Then
                         'If X = 1 Then
                         '   X = X
                        'End If
                        TestS(x, 0) = TestS(x, 0) + 1
                    End If
                Next A
                For A = 0 To 3
                    TestS(x, A) = TestS(x, A) / PermNum
                    
                Next A
            End If
        Next x
        
        For x = GeneNumber + 1 To GeneNumber + 3
                For A = 1 To PermNum
                    If TestArea(x, A, 0) > 0 Then
                        x = x
                    End If
                    If TestArea(x, A, 0) > TestArea(x, 0, 0) Then x = x ' Tests(X, 0) = Tests(X, 0) + 1
                    If TestArea(x, A, 0) < TestArea(x, 0, 0) Then x = x '  Tests(X, 1) = Tests(X, 1) + 1
                    If TestArea(x, A, 1) >= TestArea(x, 0, 1) Then TestS(x, 1) = TestS(x, 1) + 1
                    If TestArea(x, A, 1) <= TestArea(x, 0, 1) Then TestS(x, 0) = TestS(x, 0) + 1
                Next A
                For A = 0 To 1
                    TestS(x, A) = TestS(x, A) / PermNum
                Next A
        Next x
        If DebuggingFlag < 2 Then On Error Resume Next

        oDir = CurDir
        odrv = CurDir
        ChDir App.Path
        ChDrive App.Path
        On Error GoTo 0
        Close #1
        Open "Permutation test.csv" For Append As #1
        Open "TempFile" For Output As #4
        Print #1, ""
        Print #1, FName
        Print #1, Date & "," & Time
        CTNumlines = CTNumlines + 1
        CTTextNum = CTTextNum + 1
        If CTTextNum = 97 Then
            x = x
        End If
        'elemnet 1: 0 = lhs of box, 1 = middle column 1, 2 = middle columns 1+2, 3 = middle column2, 4 = middle column 3, 5 = middle columns 3&4, 6 = middle column 4,
        ' 7 = middle column 5, 8 = middle columns 5&6, 9 = middle column 6
        
        CTText(0, CTTextNum) = 2
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "Breakpoint No"
        
        
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 5
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "Breakpoints/100nts"
        
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 8
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "P-val"
        
        
        
        
        CTNames(CTNumlines) = "Test, Breakpoint # in region, Breakpoint # outside region, breakpoints/100nts in region, breakpoints/100nts outside region, Probability of fewer than expected BPs in region, Probability of more than expected BPs in region"
        Print #1, CTNames(CTNumlines)
        Print #4, CTNames(CTNumlines)
        Dim oSTring As String
        
        Dim PropINOUT(1) As Double, PropBase(1) As Double
        PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
        For x = 1 To Len(StrainSeq(0))
            If GeneMap(x, 0) = 1 Then
                PropINOUT(0) = PropINOUT(0) + 1
                For Y = 0 To NextNo
                    If SeqNum(x, Y) <> 46 Then
                        PropBase(0) = PropBase(0) + 1
                    End If
                    
                Next Y
            Else
                PropINOUT(1) = PropINOUT(1) + 1
                For Y = 0 To NextNo
                    If SeqNum(x, Y) <> 46 Then
                        PropBase(1) = PropBase(1) + 1
                    End If
                Next Y
            End If
        Next x
        
        
        If PropINOUT(1) > 0 Then
            PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
            PropINOUT(1) = (100 * (TestArea(0, 0, 0) / PropINOUT(1))) / PropBase(1)
        Else
            PropINOUT(1) = 0
        End If
        
        If PropINOUT(0) > 0 Then
            PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
            PropINOUT(0) = (100 * TestArea(0, 0, 1) / PropINOUT(0)) / PropBase(0)
        Else
            PropINOUT(0) = 0
        End If
        oSTring = "Intergenic regions vs all ORFs combined"
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 0
        CTText(1, CTTextNum) = 2
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = oSTring
        
        LastX = 0
            
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 1
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(TestArea(0, 0, 0))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 3
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(TestArea(0, 0, 1))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 4
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(PropINOUT(1))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 6
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(PropINOUT(0))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 7
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(TestS(0, 0))
        If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 9
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(TestS(0, 1))
        If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
        
        CTNumlines = CTNumlines + 1
        CTNames(CTNumlines) = oSTring + Str(TestArea(0, 0, 0)) + "," + Str(TestArea(0, 0, 1)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(0, 0)) + "," + Str(TestS(0, 1)) + ","
        Print #1, CTNames(CTNumlines)
        Print #4, CTNames(CTNumlines)
        For x = 1 To GeneNumber
            
            If TestName(x) <> "" Then
                PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
                
                For Z = 1 To Len(StrainSeq(0))
                    If GeneMap(Z, 0) = 1 Then
                        If GeneMap(Z, x) = 0 Then
                            PropINOUT(0) = PropINOUT(0) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(0) = PropBase(0) + 1
                                End If
                            Next Y
                            
                        Else
                            PropINOUT(1) = PropINOUT(1) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(1) = PropBase(1) + 1
                                End If
                            Next Y
                        End If
                    Else
                    x = x '1-3813:5322-end
                    End If
                Next Z
                'PropINOUT(0) = 6781,7800
                'PropINOUT(1) = 1019
                'PropBase(0) = 1193456'1380600
                'PropBase(1) = 179344
                If PropINOUT(1) > 0 Then '1019,
                    PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
                    PropINOUT(1) = (100 * TestArea(x, 0, 1) / PropINOUT(1)) * PropBase(1)
                Else
                    PropINOUT(1) = 0
                End If
                
                If PropINOUT(0) > 0 Then
                    PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
                    PropINOUT(0) = (100 * TestArea(x, 0, 0) / PropINOUT(0)) * PropBase(0)
                Else
                    PropINOUT(0) = 0
                End If
                CTNumlines = CTNumlines + 1
                CTNames(CTNumlines) = TestName(x) + "," + Str(TestArea(x, 0, 1)) + "," + Str(TestArea(x, 0, 0)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(x, 1)) + "," + Str(TestS(x, 0))
                Print #1, CTNames(CTNumlines)
                Print #4, CTNames(CTNumlines)
                CTTextNum = CTTextNum + 1
                If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
                
                CTText(0, CTTextNum) = 0
                CTText(1, CTTextNum) = x * 2 + 2
                CTText(2, CTTextNum) = 0
                CTText(3, CTTextNum) = TestName(x)
                LastX = x
            
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 1
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(TestArea(x, 0, 1))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 3
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(TestArea(x, 0, 0))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 4
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(PropINOUT(1))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 6
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(PropINOUT(0))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 7
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(TestS(x, 1))
               If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 9
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(TestS(x, 0))
               If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
               
                
                
            End If
            
        Next x
        For A = 1 To 3
            PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
            For x = 1 To GeneNumber
                
                For Z = 1 To Len(StrainSeq(0))
                    If GeneMap(Z, x) = 1 Then
                        If GeneMap(Z, x + A * GeneNumber) = 0 Then
                            PropINOUT(0) = PropINOUT(0) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(0) = PropBase(0) + 1
                                End If
                                
                            Next Y
                        Else
                            PropINOUT(1) = PropINOUT(1) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(1) = PropBase(1) + 1
                                End If
                                
                            Next Y
                        End If
                    End If
                Next Z
                
            
            Next x
            
            
            If PropINOUT(1) > 0 Then
                PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
                PropINOUT(1) = (100 * TestArea(GeneNumber + A, 0, 1) / PropINOUT(1)) / PropBase(1)
            Else
                PropINOUT(1) = 0
            End If
            If PropINOUT(0) > 0 Then
                PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
                PropINOUT(0) = (100 * TestArea(GeneNumber + A, 0, 0) / PropINOUT(0)) / PropBase(0)
             Else
                PropINOUT(0) = 0
            End If
            CTNumlines = CTNumlines + 1
            CTNames(CTNumlines) = TestName(GeneNumber + A) + "," + Str(TestArea(GeneNumber + A, 0, 1)) + "," + Str(TestArea(GeneNumber + A, 0, 0)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(GeneNumber + A, 1)) + "," + Str(TestS(GeneNumber + A, 0))
            Print #1, CTNames(CTNumlines)
            Print #4, CTNames(CTNumlines)
            LastX = LastX + 1 'lastx should = GeneNUmber+A
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 0
            CTText(1, CTTextNum) = LastX * 2 + 2
            CTText(2, CTTextNum) = 0
            CTText(3, CTTextNum) = TestName(LastX)
            
         
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 1
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(TestArea(GeneNumber + A, 0, 1))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 3
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(TestArea(GeneNumber + A, 0, 0))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 4
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(PropINOUT(1))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 6
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(PropINOUT(0))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 7
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(TestS(GeneNumber + A, 1))
            If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 9
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(TestS(GeneNumber + A, 0))
            If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
            
        Next A
        Erase GeneMap
        'ostring =
        Close #1
        Close #4
        'This is the file that is saved when the table in picturebox 2 gets saved
        Open "TempFile" For Binary As #1
            ClusteringResult = String(LOF(1), " ")
            Get #1, , ClusteringResult
        Close #1
        
        
        
        ManFlag = 161
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "TempFile"
        ChDir oDir
        ChDrive odrv
        On Error GoTo 0
          'Form1.Picture20.Visible = False
          Call DrawCTBlocks
          x = x
          Erase MapORF
          Erase MapIR
          Erase GeneMap
          Erase TempGeneMap
    End If
    'ReDim MapORF(0, 0)
    'ReDim MapIR(0, 0)
    
    
    Erase TestArea
    If x = x Then
        GlobalMemoryStatus MemSit
        
        APhys = Abs(MemSit.dwAvailPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        If APhys < (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4) Then
            shortfall = (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4) - APhys
            MsgBox ("There is not enough available free memory to complete the permutation test.  You are short of ~" + Trim(Str(Int(shortfall / 1000000)))) + " Megs of RAM. Either free up some memory or try doing the test on a computer with more RAM"
            x = x
            AbortFlag = 1
            Exit Sub
        End If
        
        ReDim PValMap(Len(StrainSeq(0)), CLng(PermNum / PNA))
        'Exit Sub
        EE = Abs(GetTickCount)
        TT = EE - SS
        x = x
        SS = Abs(GetTickCount)
        Form1.ProgressBar1.Value = 90
        Call UpdateF2Prog
        If x = x Then
            Dummy = MakePValMap(DN, Len(StrainSeq(0)), CLng(PermNum / PNA), MaP(0, 0), PValMap(0, 0))
        Else
            Dim TopS As Double, BottomS As Double, DoneNum As Long
            For Y = DN To Len(StrainSeq(0)) - DN + 1
                TopS = 1000000: BottomS = 0
                DoneNum = 0
                For x = 0 To PermNum
                    DoneNum = 0
                    BottomS = 0
                    For Z = 0 To PermNum
                        
                        If MaP(Y, CLng(Z / PNA)) > BottomS And MaP(Y, CLng(Z / PNA)) < TopS Then
                            BottomS = MaP(Y, CLng(Z / PNA))
                            DoneNum = 1
                        End If
                    Next Z
                    If DoneNum = 1 Then
                        DoneNum = 0
                        For Z = 0 To PermNum
                            If MaP(Y, CLng(Z / PNA)) = BottomS Then
                                PValMap(Y, CLng((x + DoneNum) / PNA)) = MaP(Y, CLng(Z / PNA))
                                DoneNum = DoneNum + 1
                            End If
                        Next Z
                        
                        TopS = BottomS
                        
                        If DoneNum > 1 Then x = x + DoneNum - 1
                        LastX = x + 1
                    Else
                        For Z = LastX To PermNum
                            PValMap(Y, CLng(Z / PNA)) = 0
                        Next Z
                        Exit For
                    End If
                Next x
            Next Y
        End If
    End If
    
End Sub
Public Sub MakeMapS(ENumb As Long, APos() As Long, tSeqnum() As Integer, NS As Long, ST As Long, A As Long, MapS() As Single, BPProbDist() As Single, D As Long, P1 As Long, P2 As Long, PermSeqNum() As Integer, LSSeq As Long, XDiffPos() As Long, XPosDiff() As Long, MapBack() As Long)

Dim x As Long, Y As Long, VO As Long, tMapS() As Single, tMapL() As Single, Range As Long, SP As Long, EP As Long, AddVal As Single
'NS and ST here is scaled to the alignment - need to scale these to the subseq, find offset, offset the bpprobdist values, rescale bpoffste values first to the alignment and then to the reference sequence in apos
'find the variable site offset
ReDim tMapS(Len(StrainSeq(0))) ', tMapL(Len(StrainSeq(0)))


If x = x Then
    Dummy = MakeMapSC(Len(StrainSeq(0)), ENumb, APos(0), NS, ST, A, UBound(MapS, 1), MapS(0, 0), UBound(BPProbDist, 1), BPProbDist(0, 0), LSSeq, XPosDiff(0), UBound(MapBack, 1), XDiffPos(0), tMapS(0))
Else

    VO = XPosDiff(NS) - XPosDiff(ST)
    'If VO < 10 And VO > -10 Then
    '    x = x '12,61,75,78,89, 105,108, 155
    'End If
    
    'If VO < 1 Then
    'x = x
    'End If
    
    ''need to fill in blanks in xposdiff
    'For x = 1 To Len(StrainSeq(0))
    '    If XPosDiff(x) = 0 Then
    '        XPosDiff(x) = XPosDiff(x - 1)
    '    End If
    '
    'Next x
    
    ''convertprobdist coordinates to full alignment coordinates and then convert these to xposdiffcoords
    'For X = 1 To UBound(MapBack, 1)
    '    If XDiffpos(X) <> MapBack(X, ENumb) Then
    '        X = X
    '    End If
    '    If XDiffpos(XPosDiff(MapBack(X, ENumb))) > 0 Then
    '        If MapBack(X, ENumb) <> XDiffpos(XPosDiff(MapBack(X, ENumb))) Then
    '            X = X
    '        End If
    '
    '        MapBack(X, ENumb) = XDiffpos(XPosDiff(MapBack(X, ENumb)))
    '    Else
    '        MapBack(X, ENumb) = XDiffpos(X)
    '
    '    End If
    '
    'Next X
    For x = 1 To LSSeq
    '    If X = 706 Or X = 650 Then
    '        X = X
    '    End If
    
        Y = x + VO
        
        If Y < 1 Then Y = LSSeq + Y
        If Y > LSSeq Then
            Y = Y - LSSeq
        End If
    '    If MapBack(X + 1, ENumb) > ST And MapBack(X, ENumb) < ST Then
    '        X = X
    '    End If
        'If MapBack(x, ENumb) > 0 Then
            tMapS(Y) = BPProbDist(x, ENumb)
        'End If
'        If tMapS(Y) > 0.01 Then
'            x = x
'        End If
    Next x
    
    For x = 1 To LSSeq - 1
    '    If A = 11 Then
    '    If APos(MapBack(x, ENumb)) > 1290 Then
    '        x = x
    '    End If
    '    End If
        If tMapS(x) > 0 Then
            EP = APos(XDiffPos(x + 1))
            If EP = 0 Then EP = APos(Len(StrainSeq(0)))
            SP = APos(XDiffPos(x)) '
            If SP = 0 Then SP = 1
            
            'XX = XDiffpos(x)
            Range = EP - SP
    '        If tMapS(X) > 0.5 Then 'peaks at ~55
    '            X = X
    '        End If
            If SP = EP Then
                x = x
               ' tMapS(x + 1) = tMapS(x + 1) + tMapS(x)
            Else
                
                AddVal = tMapS(x) / Range
                For Y = SP To EP - 1
                    MapS(Y, A) = MapS(Y, A) + AddVal
                    
                Next Y
            End If
        End If
        
    Next x
End If
End Sub


Public Sub RecombMapPermsS(DN As Long, APos() As Long, BPos() As Long, Excl() As Byte, CV() As Double, Win As Long, PermNum As Long, RNDSEED As Long, TargetS() As Single)
    
    Dim ST As Long, MapS() As Single, SPS As Long, EPS As Long, A As Long, x As Long, MaxPos As Long, MinPos As Long, OffsetX As Long, OffsetY As Long, PPos As Long, Target(1) As Long, MaxV(1) As Double, MaxP(1) As Long, MaxValsS() As Single, MaxVals() As Single, NewStart As Long, S As Long, NS As Long, NE As Long, LSSeq As Long, RecSize As Long, MaxS As Long, MaP() As Integer, Size As Long, D As Long, P1 As Long, P2 As Long
    Dim tSeqnum() As Integer, tSeqNumORF() As Integer, MaxCycleNo As Long, CycleNo As Long, MapORF() As Integer, MapIR() As Integer
    Dim BestP() As Double, BreakPos() As Long, BreakNum As Long, OKProg(20) As Byte
    Dim xxWin As Double
    Dim SBF As Long
        
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , PermSeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    
    CurrentCheck = 15
    'Call UnModSeqNum(0)
    'SHAPECO = 0.25
    ''XX = SHAPEFlag
    For x = 0 To AddNum - 1
        If DoScans(0, x) = 1 Then OKProg(x) = 1
    Next x
    WinX = Win
    'Dim MinS As Long
    
    If CircularFlag = 0 Then
        Dim LLeft As Long, HRight As Long
        LLeft = Len(StrainSeq(0)): HRight = 0
        For x = 0 To SEventNumber
            If Excl(x) = 1 Then
                Bx = BestEvent(x, 0)
                By = BestEvent(x, 1)
                
                If XoverList(Bx, By).SBPFlag <> 1 And XoverList(Bx, By).SBPFlag <> 3 Then
                    If XoverList(Bx, By).Beginning < LLeft Then LLeft = XoverList(Bx, By).Beginning
                
                End If
                If XoverList(Bx, By).SBPFlag <> 2 And XoverList(Bx, By).SBPFlag <> 3 Then
                    If XoverList(Bx, By).Ending > HRight Then
                        HRight = XoverList(Bx, By).Ending
                    End If
                x = x
                End If
            End If
        Next x
        If LLeft > 90 Then LLeft = 90
        If HRight < (Len(StrainSeq(0)) - 90) Or HRight = 0 Then HRight = Len(StrainSeq(0)) - 90
        MinPos = LLeft
    Else
        LLeft = 1
        HRight = Len(StrainSeq(0))
        MinPos = 1
    End If
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    b = 0
    C = 0
    Dim PNA As Double
   ' If PermNum < 10000 Then
       PNA = 1
   ' Else
   '     PNA = PermNum / 10000
   ' End If
    
    
    'get the likelihood distributions for bps for each event
    Dim oEditSeqFlag As Long, oRelX As Long, oRelY As Long ', MapBack() As Long
    'If GCDimSize * 2 < Len(StrainSeq(0)) Then
        ReDim BPProbDist(GCDimSize * 2, SEventNumber), MapBack(GCDimSize * 2, SEventNumber)
    'Else
    '    ReDim BPProbDist(Len(StrainSeq(0)), SEventNumber), MapBack(Len(StrainSeq(0)), SEventNumber)
    'End If
    oRelX = RelX
    oRelY = RelY
    oEditSeqFlag = EditSeqFlag
    oSeq1 = Seq1
    oSeq2 = Seq2
    oSeq3 = Seq3
    Dim EL As Long
    'XX = Len(StrainSeq(0))
    EL = 0
    For x = SEventNumber To 1 Step -1
'        If X = 1 Then
'            X = X
'        End If
        If Excl(x) = 1 Then
            Bx = BestEvent(x, 0)
            By = BestEvent(x, 1)
            BPProbDistFlag = 1: BPProbDistSE = x
            RelX = Bx
            RelY = By
            EditSeqFlag = 0
            XX = PermNextno
            XX = NextNo
            Seq3 = XoverList(RelX, RelY).Daughter
            Seq1 = XoverList(RelX, RelY).MajorP
            Seq2 = XoverList(RelX, RelY).MinorP
            DontLoadExcludes = 1
            Call ModSeqNum(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, 1)
            
            Call MakeTreeSeqs(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending)
'
'            'Call ModNextno
            Call BenHMM2(3, Seq1, Seq2, Seq3)
            'Call UnModNextno
            Call ModSeqNum(0, 0, 1)
            DontLoadExcludes = 0
            BPProbDistFlag = 0: BPProbDistSE = -1
            EL = EL + 1
        End If
        SSX = Abs(GetTickCount)
        If Abs(SSX - ossx) > 500 Then
            ossx = SSX
            Form1.SSPanel1.Caption = "Breakpoint CIs determined for " + Trim(Str(EL)) + " events"
            
            DoEvents
            Form1.WindowState = Form1.WindowState
            ' covered by currentlyrunning
        End If
    Next x
    RelX = oRelX
    RelY = oRelY
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
    EditSeqFlag = 0
    Call ModSeqNum(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, 0)
    Call MakeTreeSeqs(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending)
    'Call ModNextno
    EditSeqFlag = oEditSeqFlag
    
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    Dim NPX As Long
    If ORFFlag = 1 Then
        If (Len(StrainSeq(0)) * CLng(PermNum / PNA)) > APhys / 16 Then
            
            
            NPX = CLng(PermNum / ((Len(StrainSeq(0)) * CLng(PermNum / PNA)) / (APhys / 16)))
            
            MsgBox ("There is insufficient available memory to run this analysis with " + Trim(Str(PermNum)) + " permutations.  I will use " + Trim(Str(NPX)) + " permutations (the maximum possible) instead.")
            PermNum = NPX
        End If
    Else
        If (Len(StrainSeq(0)) * CLng(PermNum / PNA)) > APhys / 15 Then
            
            
            NPX = CLng(PermNum / ((Len(StrainSeq(0)) * CLng(PermNum / PNA)) / (APhys / 16)))
            
            MsgBox ("There is insufficient available memory to run this analysis with " + Trim(Str(PermNum)) + " permutations.  I will use " + Trim(Str(NPX)) + " permutations (the maximum possible) instead.")
            PermNum = NPX
        End If
    End If
    
    On Error Resume Next
    
    Do
        ReDim MaP(Len(StrainSeq(0)), CLng(PermNum / PNA)), MaxVals(1, CLng(PermNum / PNA))
        ReDim MapS(Len(StrainSeq(0)), CLng(PermNum / PNA)), MaxValsS(1, CLng(PermNum / PNA))
        If ORFFlag = 1 Then
            ReDim MapORF(Len(StrainSeq(0)), CLng(PermNum / PNA))
            ReDim MapIR(Len(StrainSeq(0)), CLng(PermNum / PNA))
        End If
        
        UB = -1
        UB = UBound(MaP, 1)
        UB2 = -1
        UB2 = UBound(MapS, 1)
        If UB = -1 Or UB2 = -1 Then
            PermNum = PermNum * 0.9
        ElseIf ORFFlag = 1 Then
            UB = -1
            UB = UBound(MapORF, 1)
            UB2 = -1
            UB2 = UBound(MapIR, 1)
            If UB = -1 Or UB2 = -1 Then
                PermNum = PermNum * 0.9
            Else
                Exit Do
            End If
        Else
            Exit Do
        End If
        DoEvents
    Loop
    
    On Error GoTo 0
    
    Rnd (-BSRndNumSeed)
    SS = Abs(GetTickCount)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200)
    
    'ExRecFlag = 0
    
    If ORFFlag = 1 Then
        GlobalMemoryStatus MemSit
        
        'Exit Sub
        Dim GeneMap() As Byte, TestName() As String, LenMap() As Long
        ReDim GeneMap(Len(StrainSeq(0)), GeneNumber * 4), TestName(GeneNumber + 3)
        ReDim LenMap(GeneNumber + 3)
        Y = 0
        For x = 1 To GeneNumber
            ST = GeneList(x).StartInAlign
            EN = GeneList(x).EndInAlign
            EX = GeneList(x).ExonNumber
            
            ORIx = GeneList(x).Orientation
            
            If EX = 1 Or EX = 0 Then
                Y = x 'Y = Y + 1 - it seemed to me that makining y=y+1 could cause problems
                
                Dim PString As String
                PString = GeneList(x).Product
                If PString <> "" And Len(PString) > 40 Then
                    Pos = InStr(1, PString, "protein", vbTextCompare)
                    'If Pos = 0 Then
                    
                    Pos2 = InStr(1, PString, "peptide", vbTextCompare)
                    Pos3 = InStr(1, PString, "subunit", vbTextCompare)
                    If Pos = 0 Then
                        Pos = Po2
                    End If
                    If Pos2 > 0 And Pos2 < Pos Then
                        Pos = Pos2
                    End If
                    If Pos3 > 0 And Pos3 < Pos Then
                        Pos = Pos3
                    End If
                    'End If
                    If Pos > 0 Then
                        PString = Left(PString, Pos + 6)
                    Else
                        PString = Left(PString, 40)
                    End If
                End If
                If Len(PString) > 40 Then
                    PString = Left(PString, 40)
                End If
                If PString <> "" And GeneList(x).Name <> "" And Len(GeneList(x).Name) < 30 Then
                    TestName(Y) = GeneList(x).Name + " (" + PString + ") vs rest of ORFs"
                ElseIf PString <> "" Then
                    TestName(Y) = PString + " vs rest of ORFs"
                ElseIf GeneList(x).Name <> "" Then
                    TestName(Y) = GeneList(x).Name + " vs rest of ORFs"
                Else
                    TestName(Y) = "Gene " + Trim(Str(x)) + " vs rest of ORFs"
                End If
                LenMap(Y) = 0
            Else
                Y = x
            End If
            If ORIx = 2 Then
                Tmp = ST
                ST = EN
                EN = Tmp
            End If
            If ST < EN Then
                For Z = ST To EN
                    GeneMap(Z, Y) = 1
                    GeneMap(Z, 0) = 1
                    'For aa = 0 To Nextno
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(Y) = LenMap(Y) + 1
                    
                    End If
                   ' XX = GeneMap(4, 0)
                Next Z
                x = x
            Else
                
                For Z = ST To Len(StrainSeq(0))
                    GeneMap(Z, x) = 1
                    GeneMap(Z, 0) = 1
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(x) = LenMap(x) + 1
                    End If
                Next Z
                For Z = 1 To EN
                    GeneMap(Z, Y) = 1
                    GeneMap(Z, 0) = 1
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(x) = LenMap(x) + 1
                    End If
                Next Z
                
            End If
        Next x
        TestName(GeneNumber + 1) = "End 50% vs Middle 50%"
        TestName(GeneNumber + 2) = "End 25% vs Middle 75%"
        TestName(GeneNumber + 3) = "End 10% vs Middle 90%"
        Dim COffs(3) As Long
        If x = x Then
        
            'need to check for polyproteins that are processed to form subunits and then exclude these
            Dim TGM() As Long
            ReDim TGM(Len(StrainSeq(0)), 6)
            'rank genes by size
            Dim GL() As Long
            Dim FRM As Long
            ReDim GL(GeneNumber)
            For x = 1 To GeneNumber
                
                If GeneList(x).Orientation = 1 Then
                    ST = GeneList(x).StartInAlign
                    EN = GeneList(x).EndInAlign
                Else
                    EN = GeneList(x).StartInAlign
                    ST = GeneList(x).EndInAlign
                End If
                
                FRM = GeneList(x).Frame
                If ST < EN Then
                    GL(x) = EN - ST
                Else
                    GL(x) = Len(StrainSeq(0)) - ST + EN - 1
                End If
            Next x
            For x = 1 To GeneNumber
                If GeneList(x).Orientation = 1 Then
                    ST = GeneList(x).StartInAlign
                    EN = GeneList(x).EndInAlign
                Else
                    EN = GeneList(x).StartInAlign
                    ST = GeneList(x).EndInAlign
                End If
                If EN - ST > 3000 Then '239-13267
                    x = x
                End If
                
                FRM = GeneList(x).Frame
                If ST < EN Then
                    For Y = ST To EN
                        If TGM(Y, FRM) = 0 Or GL(TGM(Y, FRM)) > GL(x) Then
                            TGM(Y, FRM) = x
                        End If
                    Next Y
                Else
                    For Y = ST To Len(StrainSeq(0))
                        If TGM(Y, FRM) = 0 Or GL(TGM(Y, FRM)) > GL(x) Then
                            TGM(Y, FRM) = x
                        End If
                    Next Y
                    For Y = 1 To EN
                        If TGM(Y, FRM) = 0 Or GL(TGM(Y, FRM)) > GL(x) Then
                            TGM(Y, FRM) = x
                        End If
                    Next Y
                End If
            
            Next x
            For x = 1 To GeneNumber
                'If X >= 8 Then
                '    X = X
                'End If
                If LenMap(x) > 0 Then
                    COffs(0) = CLng(LenMap(x)) / 4
                    COffs(1) = CLng(LenMap(x)) / 8
                    COffs(2) = CLng(LenMap(x)) / 20
                    
                End If
                C = 0
                FRM = GeneList(x).Frame
                For Y = 1 To Len(StrainSeq(0))
                    If GeneMap(Y, x) = 1 Then
                        If SeqNum(Y, 0) <> 46 Then
                            C = C + 1
                        End If
                        If TGM(Y, FRM) = x Then
                            If C <= COffs(0) Then
                                GeneMap(Y, x + GeneNumber) = 1
    '                        Else
    '                            If GeneMap(Y, x + GeneNumber) = 1 Then
    '                                x = x
    '                            End If
    '
    '                            GeneMap(Y, x + GeneNumber) = 0
                            End If
                            If C <= COffs(1) Then
                                GeneMap(Y, x + GeneNumber * 2) = 1
    '                        Else
    '                            If GeneMap(Y, x + GeneNumber * 2) = 1 Then
    '                                x = x
    '                            End If
    '                            GeneMap(Y, x + GeneNumber * 2) = 0
                            End If
                            If C <= COffs(2) Then
                                GeneMap(Y, x + GeneNumber * 3) = 1
                                
    '                        Else
    '                            If GeneMap(Y, x + GeneNumber * 3) = 1 Then
    '                                x = x
    '                            End If
    '                            GeneMap(Y, x + GeneNumber * 3) = 0
                            End If
                        End If
                    End If
                Next Y
                C = 0
                For Y = Len(StrainSeq(0)) To 1 Step -1
                    If GeneMap(Y, x) = 1 Then
                        If SeqNum(Y, 0) <> 46 Then
                            C = C + 1
                        End If
                        If TGM(Y, FRM) = x Then
                            If C <= COffs(0) Then
                                GeneMap(Y, x + GeneNumber) = 1
    '                        Else
    '                            If GeneMap(Y, x + GeneNumber) = 1 Then
    '                                x = x
    '                            End If
    '                            GeneMap(Y, x + GeneNumber) = 0
                            End If
                            If C <= COffs(1) Then
                                GeneMap(Y, x + GeneNumber * 2) = 1
                                
                                
    '                        Else
    '                            If GeneMap(Y, x + GeneNumber * 2) = 1 Then
    '                                 x = x
    '                            End If
    '                            GeneMap(Y, x + GeneNumber * 2) = 0
                            End If
                            If C <= COffs(2) Then
                                GeneMap(Y, x + GeneNumber * 3) = 1
    '                        Else
    '                            If GeneMap(Y, x + GeneNumber * 3) = 1 Then
    '                                x = x
    '                            End If
    '                            GeneMap(Y, x + GeneNumber * 3) = 0
                            End If
                        End If
                    End If
                Next Y
            Next x
        Else
            ReDim RefSpaces(Len(StrainSeq(0)))
            'use this to manipulate which sites get tested in the "gene" analyses - I used this to test low shape reactivity-bp association in  the junction sites
            If GeneNumber > 3 And x = 1234567890 Then ' only allow this to be executed under very special conditions
                Dim Inscore As Long, OutScore As Long
                For x = 0 To GeneNumber
                     For Y = 0 To Len(StrainSeq(0))
                        GeneMap(Y, x) = 0
                    Next Y
                Next x
                Inscore = 0
                OutScore = 0
                'this is test for the junction regions
                For x = 1 To GeneNumber
                    ST = GeneList(x).StartInAlign
                    EN = GeneList(x).EndInAlign
                    
                   
                    If ST < EN Then
                        For Y = ST To EN
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                GeneMap(Y, 0) = 1
                                Inscore = Inscore + 1
                                'high structure - high similarity -1673 (0.85), 1230 (0.90), 725 (0.925)
                                'high similarity - junction - 1661 (0.85),  860 (0.90), 378 (0.925)
                            Else
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                GeneMap(Y, 0) = 1
                                'low structure - high similarity -6781 (0.85), 4149 (0.90), 2048 (0.925)
                                'low similarity - junction - 370 (0.85),  1171 (0.90), 1653 (0.925)
                            End If
                        Next Y
                    End If
                Next x
                
                x = x
                'Exit Sub
                If x = 12345 Then  'test of non junction sites
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        If GeneMap(Y, 0) = 1 Then
                            GeneMap(Y, 0) = 0
                        Else
                            GeneMap(Y, 0) = 1
                        End If
                        If GeneMap(Y, 1) = 1 Or GeneMap(Y, 2) = 1 Then
                            GeneMap(Y, 1) = 0
                            GeneMap(Y, 2) = 0
                        Else
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                Inscore = Inscore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90), 1031 (0.925)
                                'high similarity - ROG - 6714 (0.85), 4378 (0.90),  2285(0.925)
                            Else
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                'low structure - low similarity - 1019 (0.85), 3651 (0.90), 5752 (0.925)
                                'low similarity - ROG - 812 (0.85), 3148 (0.90), 5241 (0.925)
                            End If
                        End If
                    Next Y
                    x = x
                    'Exit Sub
                ElseIf x = 12345 Then 'test of juncrtion high structure against non-junction high structure
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 0) = 1
                            Inscore = Inscore + 1
                            'high structure - high similarity - 1673 (0.85), 1230 (0.90), 725 (0.925)
                            'high similarity - junction - 1660 (0.85), 860 (0.90), 378 (0.925)
                        ElseIf GeneMap(Y, 2) = 1 Then
                        
                            GeneMap(Y, 2) = 0
                            GeneMap(Y, 0) = 0
                        Else
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90),1031 (0.925)
                                'high similarity - ROG 6714 (0.85), 4378 (0.90), 2285 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                        End If
                    Next Y
                    x = x
                    'Exit Sub
                ElseIf x = 12345 Then 'test the junction low structure with the non-junction lowstructure
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 2) = 1 Then
                            GeneMap(Y, 0) = 1
                            Inscore = Inscore + 1
                            'low structure - high similarity  6781 (0.85), 4149(0.90), 2048 (0.925)
                            'low similarity - junction - 370 (0.85), 1170(0.90), 1652 (0.925)
                        ElseIf GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 1) = 0
                            GeneMap(Y, 0) = 0
                        Else
                            If SHAPEScores(APos(Y)) >= SHAPECO Then
                                GeneMap(Y, 1) = 1
                                OutScore = OutScore + 1
                                'low structure - lowsimilarity - 1019 (0.85), 3651 (0.90), 5752 (0.925)
                                'low similarity - rog - 812 (0.85), 3148 (0.90), 5241 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                            
                            'total:7800 low structure sites split between high and low similarity
                        End If
                    Next Y
                    x = x
                    For Y = 1 To Len(StrainSeq(0))
                        Temp = GeneMap(Y, 1)
                        GeneMap(Y, 1) = GeneMap(Y, 2)
                        GeneMap(Y, 2) = Temp
                    Next Y
                   
                ElseIf x = 1234 Then 'test of junction sites that are above the sahpe cutoff gaainst non-junction sites that are below the shape cutoff
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 0) = 0
                            GeneMap(Y, 1) = 0
                        ElseIf GeneMap(Y, 2) = 1 Then 'i.e. junction sites that are above the shape cutoff
                            Inscore = Inscore + 1
                            'low structure - high similarity - 6781 (0.85), 4149 (0.90), 2048 (0.925)
                            'low similarity - junction 370 (0.85),  1170(0.90), 1652 (0.925)
                            GeneMap(Y, 0) = 1
                        Else 'ie non-junction sites
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                OutScore = OutScore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90), 1031 (0.925)
                                'high similarity - ROG 6714 (0.85), 4378 (0.90), 2285 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                        End If
                       
                    Next Y
                    x = x
                     For Y = 1 To Len(StrainSeq(0))
                        Temp = GeneMap(Y, 1)
                        GeneMap(Y, 1) = GeneMap(Y, 2)
                        GeneMap(Y, 2) = Temp
                    Next Y
                      'Exit Sub
                End If
                
                Open "sitenums.csv" For Append As #22
                    Print #22, Str(Inscore) + "," + Str(OutScore)
                Close #22
                x = x
            End If
        End If
        
        
    End If
    
   
    
    Dim ModnumX() As Double, ModnumY() As Double
    ReDim ModnumX(NextNo), ModnumY(Len(StrainSeq(0)))
    
    If x = x Then
        
        For x = 0 To NextNo
            If InStr(1, OriginalName(x), "parent", vbTextCompare) > 0 Then
                
                    For Y = 1 To Len(StrainSeq(0))
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            ST = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = Len(StrainSeq(0)) To 1 Step -1
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            EN = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = ST To EN
                        
                        ModnumY(Y) = ModnumY(Y) + 1
                        
                    Next Y
                    x = x + 1
            End If
        Next x
        
        
        For x = 0 To NextNo
            'pair_00-85_461A-210C    0,0739
            
            'pair_00-85_859A-914G    0,0654
            'pair_Heather_A115-D89   0,1000
            'pair_Heather_A115-D126  0,0380
            'pair_Heather_A120-D89   0,0440
            'pair_Heather_D126-A120  0,0480
            'pair_90-35_899-122  0,0591
            'pair_90-35_905A-858G    0,0617
            'pair_140-35_461A-210C   0,0568
            'pair_140-35_461A-1033G  0,0617
            'pair_140-35_461A-2116D  0,0573
            'pair_140-35_914-899     0,0620
            'pair_140-35_O5-914G     0,0216
            'pair_140-35_O5-O2   0,0596
            'pair_140-03_899-914     0,0990
            'pair_EPRRE-03_899A-122D     0,0526
            
            'pair_00-85_461A-1033G   0,0761
            If InStr(1, OriginalName(x), "AG00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7610 / 20)
            ElseIf InStr(1, OriginalName(x), "AC00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7390 / 22)
            ElseIf InStr(1, OriginalName(x), "859A-914G00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6540 / 15)
            ElseIf InStr(1, OriginalName(x), "D126-A120", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4800 / 43)
            ElseIf InStr(1, OriginalName(x), "A120-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4400 / 21)
            ElseIf InStr(1, OriginalName(x), "A115-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(10000 / 20)
            ElseIf InStr(1, OriginalName(x), "A115-D126", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(3800 / 20)
            ElseIf InStr(1, OriginalName(x), "A905-G858", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 38)
            ElseIf InStr(1, OriginalName(x), "899A-122D", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5910 / 33)
            ElseIf InStr(1, OriginalName(x), "O32-O35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5960 / 24)
            ElseIf InStr(1, OriginalName(x), "G914-O32", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(2160 / 18)
            ElseIf InStr(1, OriginalName(x), "AG140-35b", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5730 / 25)
            ElseIf InStr(1, OriginalName(x), "AC140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5680 / 26)
            ElseIf InStr(1, OriginalName(x), "AG140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 26)
            ElseIf InStr(1, OriginalName(x), "A899-G914", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(9900 / 24)
            ElseIf InStr(1, OriginalName(x), "914G-899A", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6200 / 24)
            ElseIf InStr(1, OriginalName(x), "A899-D122", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5260 / 14)
            Else
                ModnumX(x) = 1
            End If
            
            
        Next x
        x = x
    Else
        For x = 0 To NextNo
            ModnumX(x) = 1
            
        Next x
        For Y = 1 To Len(StrainSeq(0))
            ModnumY(Y) = 1
        Next Y
    End If
    
    Dim RealTX As Long, PermTX As Long
    RealTX = 0: PermTX = 0
    
    
    If MultBPFlag = 1 Then
        'sort out plant numbers
        Dim TraceHost() As Long, KeepTrack As Long
        Call GetPlantNums(KeepTrack, TraceHost())
        
        Dim IntervalMap() As Long, CountPos As Long
        Call MakeIntervalMap(CountPos, IntervalMap())
        Dim DoneMap() As Byte, DoneMap2() As Byte
        If SHAPEFlag = 1 Then
            
            
            'this averages out the shape scores over regions
            Dim AvSite(), TotSite()
            ReDim AvSite(CountPos), TotSite(CountPos)
            For x = 1 To Len(StrainSeq(0))
                MapPos = IntervalMap(x)
                'CurHost = TraceHost(D)
                AvSite(MapPos) = AvSite(MapPos) + SHAPEScores(x)
                TotSite(MapPos) = TotSite(MapPos) + 1
            Next x
            For x = 0 To CountPos
                AvSite(x) = AvSite(x) / TotSite(x)
                x = x
            Next x
            For x = 1 To Len(StrainSeq(0))
            'If X = Len(StrainSeq(0)) - 23 Then
            '    X = X
            'End If
            
                MapPos = IntervalMap(x)
                'CurHost = TraceHost(D)
                SHAPEScores(x) = AvSite(MapPos)
            Next x
        End If
        
    End If
    
    
    If SHAPEFlag = 1 Then
    
        Dim PolarityFlag As Byte
        Dim SHAPEScore() As Double
        ReDim SHAPEScore(PermNum)
        ReDim DoneMap(CountPos, KeepTrack)
        PolarityFlag = 0
        For x = 1 To Len(StrainSeq(0))
        
            If SHAPEScores(x) < 0 Then PolarityFlag = 1: Exit For
                
           
        Next x
        
        
        For x = 1 To ENumb
            
            
            If Excl(x) = 1 Then
                
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
                    
                    D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                    P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                    P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    SBF = XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag
                    
                    
                    
                    If ExRecFlag = 1 Then
                        GoOn = 0
                        If MultBPFlag = 1 Then
                            MapPos = IntervalMap(ST)
                            CurHost = TraceHost(D)
                            If DoneMap(MapPos, CurHost) = 0 Then
                                DoneMap(MapPos, CurHost) = 1
                               
                                GoOn = 1
                            End If
                        Else
                            GoOn = 1
                        End If
                        If GoOn = 1 Then
                            'S = APos(ST)
                            S = ST
                            If PolarityFlag = 0 Then
                                SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                                RealTX = RealTX + 1
                            Else
                                If P2 = 0 Then ' on the left of the BP is p2 and on the right is p1
                                    SHAPEScore(0) = SHAPEScore(0) - SHAPEScores(S)
                                    RealTX = RealTX + 1
                                Else ' on the left of the BP is p1 and on the right is p2
                                    SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                                    RealTX = RealTX + 1
                                End If
                                
                            End If
                        End If
                    Else
                        If SBF <> 3 And SBF <> 1 Then
                            'S = APos(ST)
                            S = ST
                            SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                            RealTX = RealTX + 1
                        Else
                            x = x
                        End If
                        If SBF <> 3 And SBF <> 2 Then
                            'E = APos(EN)
                            e = EN
                            SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(e)
                            RealTX = RealTX + 1
                        Else
                            x = x
                        End If
                    End If
                End If
            End If
        Next x
    End If
    AAA = Abs(GetTickCount)
    
    
    Dim BEX0 As Long, BEX1 As Long
    
    Dim BPProbDist2() As Single
    'GCDimSize = 2000
    
    
    ReDim BPProbDist2(UBound(BPProbDist, 1), SEventNumber)
    
    
    Dim TDS As Long, TDS2 As Long
    TDS = 0
    TDS = UBound(BPProbDist2, 1)
    If TDS = 0 Then
        TDS = 6000
        Do
            ReDim BPProbDist2(TDS, SEventNumber)
            TDS2 = 0
            TDS2 = UBound(BPProbDist2, 1)
            If TDS2 > 0 Then
                Exit Do
            Else
                TDS = CLng(TDS * 0.9)
            End If
            DoEvents
        Loop
    End If
    
    On Error GoTo 0
    
    
    
    'GCDimSize = 11276
    For A = 0 To PermNum
    
        If MultBPFlag = 1 Then
            ReDim DoneMap(CountPos, KeepTrack)
            ReDim DoneMap2(CountPos, KeepTrack)
        End If
        TSX = 0
        PermTX = 0
        ReDim tSeqnum(Len(StrainSeq(0)), NextNo)
        
        If ORFFlag = 1 Then
            ReDim tSeqNumORF(Len(StrainSeq(0)), NextNo)
            
        End If
        If CircularFlag = 0 Then
            For x = 0 To NextNo
            '    For Y = 1 To Len(StrainSeq(0))
                   tSeqnum(1, x) = 1
                   tSeqnum(Len(StrainSeq(0)), x) = 1
            '    Next Y
            Next x
            If ORFFlag = 1 Then
                For x = 0 To NextNo
                '    For Y = 1 To Len(StrainSeq(0))
                       tSeqNumORF(1, x) = 1
                       tSeqNumORF(Len(StrainSeq(0)), x) = 1
                '    Next Y
                Next x
            End If
        End If
        ZZZ = 0
        ggg = 0
        aaaa = 0
        onum = 0
        Dim Par1 As Long, Pasr2 As Long
        For x = 1 To ENumb
            BEX0 = BestEvent(x, 0)
            BEX1 = BestEvent(x, 1)
            
            If Excl(x) = 1 Then
                
                If (BEX0 > 0 Or BEX1 > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BEX0, BEX1).Eventnumber)
                    
                    D = XoverList(BEX0, BEX1).Daughter
                    P1 = XoverList(BEX0, BEX1).MajorP
                    P2 = XoverList(BEX0, BEX1).MinorP
                    ST = XoverList(BEX0, BEX1).Beginning
                    EN = XoverList(BEX0, BEX1).Ending
                    SBF = XoverList(BEX0, BEX1).SBPFlag
                    
                    
                    'pair_00-85_461A-210C    0,0739
                    'pair_00-85_461A-1033G   0,0761
                    'pair_00-85_859A-914G    0,0654
                    'pair_Heather_A115-D89   0,1000
                    'pair_Heather_A115-D126  0,0380
                    'pair_Heather_A120-D89   0,0440
                    'pair_Heather_D126-A120  0,0480
                    'pair_90-35_899-122  0,0591
                    'pair_90-35_905A-858G    0,0617
                    'pair_140-35_461A-210C   0,0568
                    'pair_140-35_461A-1033G  0,0617
                    'pair_140-35_461A-2116D  0,0573
                    'pair_140-35_914-899     0,0620
                    'pair_140-35_O5-914G     0,0216
                    'pair_140-35_O5-O2   0,0596
                    'pair_140-03_899-914     0,0990
                    'pair_EPRRE-03_899A-122D     0,0526
                    
                    
                    If ExRecFlag = 1 And A > 0 Then
                        If TraceHost(D) > 0 Then
'                            If Chimaeraflag = 1 Then
'                               Par1 = RefChimaera(PermPlantNum(D), 0)
'                               Par2 = RefChimaera(PermPlantNum(D), 1)
'                            Else
'                               Par1 = ParentSeqs(0)
'                               Par2 = ParentSeqs(1)
'                            End If
                            GoOn = 0
                            If MultBPFlag = 1 Then
                                MapPos = IntervalMap(ST)
                                CurHost = TraceHost(D)
                                
                                If DoneMap(MapPos, CurHost) = 0 Then
                                    DoneMap(MapPos, CurHost) = 1
                                    GoOn = 1
                                End If
                            Else
                                GoOn = 1
                            End If
                            If GoOn = 1 Then
                                Do
                                    NewStart = Int((Len(StrainSeq(0)) * Rnd) + 1)
                                    GoOn = 0
                                    If SeqNum(NewStart, P1) = SeqNum(NewStart, P2) And SeqNum(NewStart, P1) > 46 And SeqNum(NewStart, P2) > 46 Then
                                        GoOn = 0
                                        If NewStart > 1 Then
                                            For ZZ = NewStart - 1 To 1 Step -1
                                                If SeqNum(ZZ, P1) <> SeqNum(ZZ, P2) Then
                                                    GoOn = 1
                                                    Exit For
                                                End If
                                            Next ZZ
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If NewStart < Len(StrainSeq(0)) Then
                                                    For ZZ = NewStart + 1 To Len(StrainSeq(0))
                                                        If SeqNum(ZZ, P1) <> SeqNum(ZZ, P2) Then
                                                            GoOn = 1
                                                            Exit For
                                                        End If
                                                    Next ZZ
                                                End If
                                            End If
                                            If GoOn = 1 Then
                                                If MultBPFlag = 1 Then
                                                    GoOn = 0
                                                    MapPos = IntervalMap(NewStart)
                                                    CurHost = TraceHost(D)
                                                    If DoneMap2(MapPos, CurHost) = 0 Then
                                                        DoneMap2(MapPos, CurHost) = 1
                                                        GoOn = 1
                                                    End If
                                                    
                                                End If
                                            
                                            End If
                                            
                                            
                                        End If
                                        
                                    End If
                                    If GoOn = 1 Then Exit Do
                                Loop
                                
                                
                                aaaa = aaaa + 1
                                
                                If ModnumX(D) <> 1 Then
                                    For Z = 1 To ModnumX(D)
                                        
                                       
                                        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                            Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                            
                                        Else
                                            Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                        End If
                                    Next Z
                                Else
                                        
                                        
                                        
                                        If x = x Then
                                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                            Else
                                                Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                            End If
                                            
                                        Else
                                        
                                            If SBF <> 3 Then
                                                If SBF <> 1 Then
                                                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                        Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                    Else
                                                        Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                                    End If
                                                    ZZZ = ZZZ + 1
                                                End If
                                                If SBF <> 2 Then
                                                    If ST < EN Then
                                                        NewStart = NewStart + (EN - ST)
                                                    Else
                                                        NewStart = NewStart + EN + (Len(StrainSeq(0)) - ST)
                                                    End If
                                                    If NewStart > Len(StrainSeq(0)) Then NewStart = NewStart - Len(StrainSeq(0))
                                                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                        Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                    Else
                                                        Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                                    End If
                                                    ZZZ = ZZZ + 1
                                                End If
                                            End If
                                        End If
                                End If
                                If ORFFlag = 1 Then
                                    MapIR(NewStart, CLng(A / PNA)) = MapIR(NewStart, CLng(A / PNA)) + 1
                                
                                    If (GeneMap(ST, 0) = 1 Or GeneMap(EN, 0) = 1) Then 'do tests to see if some orfs have higher rates than ohers
                                        LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                            
                                        If EN > ST Then
                                            RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                                        Else
                                            RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                                        End If
                                        
                                        If CircularFlag = 0 Then
                                           ' MaxS = LSSeq - RecSize - XOverWindowX
                                            If SBF = 2 Or SBF = 3 Then
                                                MaxS = LSSeq - RecSize
                                            Else
                                                MaxS = XPosDiff(HRight) + 1 - RecSize 'RecSize - XOverWindowX
                                            End If
                                        Else
                                            MaxS = LSSeq
                                        End If
                                        CycleNo = 0
                                        Do
                                            NewStart = Int((MaxS * Rnd) + 1)
                                            GoOn = 0
                                            If NewStart >= XPosDiff(MinPos) - 1 Or SBF = 1 Or SBF = 3 Then
                                                GoOn = 1
                                            End If
                                            
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                                    GoOn = 1
                                                End If
                                            End If
                                            If GoOn = 1 Then
                                                
                                                GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqNumORF(0, 0), NS, NE, XDiffPos(0))
                                                If GoOn = 1 Then
                                                    GoOn = 0
                                                    If GeneMap(NS, 0) = GeneMap(ST, 0) Or (SBF = 1 Or SBF = 3) Then
                                                        GoOn = 1
                                                    End If
                                                    If GoOn = 1 Then
                                                        GoOn = 0
                                                        If GeneMap(NE, 0) = GeneMap(EN, 0) Or (SBF = 2 Or SBF = 3) Then
                                            
                                                            GoOn = 1
                                                        End If
                                                    End If
                                                    If GoOn = 1 Then Exit Do
                                                End If
                                                CycleNo = CycleNo + 1
                                                If CycleNo > MaxCycleNo Then
                                                    x = x
                                                    XX = A
                                                    Exit Do
                                                End If
                                            End If
                                        Loop
                                        OffsetY = NS - ST
                                        If SBF <> 3 Then
                                        
                                            For D = 0 To 1
                                                GoOn = 0
                                                If D = 0 Then
                                                    
                                                    If SBF <> 1 And GeneMap(ST, 0) = 1 Then
                                                        
                                                        S = NS: GoOn = 1
                                                       
                                                    End If
                                                Else
                                                    If SBF <> 2 And GeneMap(EN, 0) = 1 Then
                                                        S = NE: GoOn = 1
                                                    End If
                                                End If
                                            
                                                If GoOn = 1 Then
                                                    
                                                    'Dummy = AddToMap(CLng(A / PNA), S, 1, Len(StrainSeq(0)), APos(0), MapORF(0, 0))
                                                    onum = onum + 1
                                                    
                                                    
                                                    MapORF(S, CLng(A / PNA)) = MapORF(S, CLng(A / PNA)) + 1
                                                End If
                                            Next D
                                        
                                        End If
                                        
                                        'check the start
                                        
                                        'check the end
                                        
                                    End If
                                
                                End If
                                If SHAPEFlag = 1 Then
                                    'S = APos(NewStart)
                                    If PolarityFlag = 0 Then
                                        'TSX = TSX + SHAPEScores(APos(EN))
                                        TSX = TSX + SHAPEScores(EN)
                                        'SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(APos(NewStart))
                                        SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(NewStart)
                                        PermTX = PermTX + 1
                                    Else
                                        If P2 = 0 Then
                                            'TSX = TSX + SHAPEScores(APos(EN))
                                            TSX = TSX + SHAPEScores(EN)
                                            'SHAPEScore(A) = SHAPEScore(A) - SHAPEScores(APos(NewStart))
                                            SHAPEScore(A) = SHAPEScore(A) - SHAPEScores(NewStart)
                                            PermTX = PermTX + 1
                                        Else
                                            'TSX = TSX + SHAPEScores(APos(EN))
                                            TSX = TSX + SHAPEScores(EN)
                                            'SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(APos(NewStart))
                                            SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(NewStart)
                                            PermTX = PermTX + 1
                                        End If
                                    
                                    End If
                                End If
                            End If
                        End If
                    ElseIf ExRecFlag = 2 And A > 0 Then
                        
                            NewStart = Int(((Len(StrainSeq(0)) - 96) * Rnd) + 1) + 48
                            
                        For Z = 1 To ModnumX(D)
                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                            Else
                                Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                            End If
                        Next Z
                    Else
                        'Make variable sites array
                        
                       
                        
                        LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                        
                        Dim PosX As Long
                        If A = 0 Then 'on the first permutation make a version of mapback that maps to xdiffpos and xposdiff
                            For Y = 0 To LSSeq
                                If MapBack(Y, x) > 0 Then
                                    PosX = MapBack(Y, x)
                                    PosX = XPosDiff(PosX)
                                    If PosX > UBound(BPProbDist2, 1) Then PosX = UBound(BPProbDist2, 1)
                                    BPProbDist2(PosX, x) = BPProbDist(Y, x)
                                End If
                            Next Y
                        End If
'                        Dim MaxMapback As Long
'                        For Y = LSSeq To 1 Step -1
'                            If MapBack(Y, x) > 0 Then
'                                MaxMapback = Y
'                                Exit For
'
'                            End If
'                        Next Y
'                        If MaxMapback > LSSeq Then LSSeq = MaxMapback
                        If EN > ST Then
                            RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                        Else
                            RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                        End If
                        If CircularFlag = 0 Then
                            'find maxmapback
'                            For CC = LSSeq To 1 Step -1
'                                If MapBack(CC, x) > 0 Then
'                                    Exit For
'                                End If
'                            Next CC
'                            For CC = 1 To LSSeq
'                                XDiffpos(CC) = MapBack(CC, x)
'                            Next CC
                            If SBF = 2 Or SBF = 3 Then
                                MaxS = LSSeq - RecSize
                            Else
                                MaxS = XPosDiff(HRight) + 1 - RecSize 'RecSize - XOverWindowX
                            End If
                        Else
                            MaxS = LSSeq
                        End If
                        
                        'Make new ending and start for this event
                    
                        'For A = 1 To PermNum
                            MaxCycleNo = LSSeq * 5
                            CycleNo = 0
                            If MaxS <= MinPos Then
                                MaxS = MinPos
                            End If
                            'set up exceptions for single bp recombinants (possible with linear sequences but not with circular ones)
                            Dim EFX As Byte
                            EFX = 0
                            If CircularFlag = 0 Then
                                If SBF = 1 And XPosDiff(ST) < 10 Then
                                    EFX = 1
                                ElseIf SBF = 2 And XPosDiff(EN) > LSSeq - 10 Then
                                    EFX = 2
                                End If
                            End If
                            'make an array of acceptable sites based on mapback
                            
                            Do
                                
                                
                                If EFX > 0 Then 'single breakpoint recombinants
                                    If A = 0 Then
                                        NewStart = XPosDiff(ST)
                                        If NewStart = 0 Then NewStart = 1
                                        If NewStart > MaxS Then
                                            NewStart = MaxS
                                        End If
                                    Else
                                        NewStart = Int(((LSSeq) * Rnd) + 1)
                                    End If
                                    'NewStart = 300
                                    If NewStart > LSSeq - LSSeq Then
                                    
                                        If SBF = 1 Then
                                            If x = x Then
                                            
                                                NE = XDiffPos(NewStart)
    '                                            If NewStart - RecSize > 0 Then
    '                                                NS = XDiffpos(NewStart - RecSize)
    '                                            Else
                                                    NS = NewStart - RecSize
                                                    If NS < 1 Then NS = LSSeq + NS
                                                    NS = XDiffPos(NS)
                                                'End If
                                                'NE = XDiffpos(NewStart + RecSize)
                                                Exit Do
                                            End If
                                        ElseIf SBF = 2 Then
                                            
                                            If NewStart > XPosDiff(MinPos) Then
                                                XX = ST
                                                XX = EN
                                                NS = XDiffPos(NewStart)
                                                NE = NewStart + RecSize - 1
                                                If NE > LSSeq Then NE = NE - LSSeq
                                                NE = XDiffPos(NE)
                                                
                                                Exit Do
                                            End If
                                        Else
                                            Exit Do
                                        End If
                                        CycleNo = CycleNo + 1
                                        If CycleNo > MaxCycleNo Then Exit Do
                                        DoEvents
                                    End If
                                 '   RecSize = LSSeq - NewStart
                                 '   If NewStart < RecSize Then RecSize = NewStart
                                 '   GoOn = CheckBPOL(Len(StrainSeq(0)), d, LSSeq, NewStart, RecSize, tSeqNum(0, 0), NS, NE, XDiffpos(0))
                                 '   If GoOn = 1 Then Exit Do
                                Else
                                
                                    If A = 0 Then
                                        NewStart = XPosDiff(ST)
                                        If NewStart = 0 Then NewStart = 1
                                        If NewStart > MaxS Then
                                            NewStart = MaxS
                                        End If
                                    Else
                                        NewStart = Int((MaxS * Rnd) + 1)  'Int(((LSSeq) * Rnd) + 1)
                                    End If
                                     ''''''''''''''''''''''''''
                                    'NewStart = XPosDiff(ST)
                                    onewstart = NewStart
                                    'NewStart = XPosDiff(ST)
                                    GoOn = 0
                                    
                                    If NewStart >= XPosDiff(MinPos) - 1 Or SBF = 1 Or SBF = 3 Then
                                        
                                        GoOn = 1
                                    End If
                                    
                                    If GoOn = 1 Then
                                    
                                        GoOn = 0
                                        If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                    End If
                                    If GoOn = 1 Then
                                        'XX = XDiffpos(NewStart)
                                        GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqnum(0, 0), NS, NE, XDiffPos(0))
                                        
                                        If GoOn = 1 Then Exit Do
                                        CycleNo = CycleNo + 1
                                        If CycleNo > MaxCycleNo Then Exit Do
                                    End If
                                End If
                                DoEvents
                            Loop
                            XX = NS
                            XX = XPosDiff(NS)
'                            If onewstart <> NewStart Then
'                                x = x
'                            End If
'                            If XPosDiff(NS) <> onewstart Then
'                                x = x
'                            End If
                            'NS = NS - 2
                            'NE = NE - 2
                            OffsetX = NS - ST
'                            If NS < 100 Then
'                                x = x
'                            End If
                            XX = ST
                            XX = EN
                            If SBF <> 3 Then
                                    Dim FirstOne As Byte
                                    FirstOne = 0
                                    For D = 0 To 1 'need to add 2 breakpoints
                                        GoOn = 0
                                        If D = 0 Then
                                            
                                            If SBF <> 1 Then
                                                
                                                S = APos(NS): OS = NS: GoOn = 1
                                               
                                                
                                            
                                            End If
                                        Else
                                            If SBF <> 2 Then
                                                S = APos(NE): OS = NE: GoOn = 1
                                            End If
                                        End If
                                    
                                        If GoOn = 1 Then
                                            
                                            ZZZ = ZZZ + 1
                                            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                            '''''''''need to change this bit if i want to use probability distributions rather than
                                            '''''''''discrete breakpoint sites
                                            '''''''''note this also does the 50 or whatever window
                                            '''''''''I would ideally want to add distributions and then do the window later
                                            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                            
                                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                
                                                Dummy = AddToMap(CLng(A / PNA), S, Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                'NS and ST here is scaled to the alignment - need to scale these to the subseq, find offset, offset the bpprobdist values, rescale bpoffste values first to the alignment and then to the reference sequence in apos
                                                'x=supereventnumber
                                                
                                                If FirstOne = 0 Then
                                                    FirstOne = 1
                                                    'mapback is for mapping the positions in bpprobdist back toBPProbDist the alignment
                                                    Call MakeMapS(x, APos(), tSeqnum(), NS, ST, A, MapS(), BPProbDist2(), D, P1, P2, PermSeqNum(), LSSeq, XDiffPos(), XPosDiff(), MapBack()) 'A=the permutation number; ST = oldstart
                                                End If
                                            Else
                                                Call AddToMapVB(CLng(A / PNA), Decompress(S), Win, MaP())
                                            End If
                                            If ORFFlag = 1 Then
                                                'If SHAPEFlag = 0 Or (SHAPEFlag = 1 And SHAPEScore(A) < SHAPECO) Then
                                                    MapIR(OS, CLng(A / PNA)) = MapIR(OS, CLng(A / PNA)) + 1
                                                'End If
                                            End If
                                            If SHAPEFlag = 1 Then
                                                
                                                
                                                
                                                SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(S)
                                                
                                                
                                                PermTX = PermTX + 1
                                            End If
                                            
                                        End If
                                    Next D
                                
                            End If
                            
                            
                            
                            
                            If ORFFlag = 1 And A > 0 Then
                                If (GeneMap(ST, 0) = 1 Or GeneMap(EN, 0) = 1) Then 'do tests to see if some orfs have higher rates than ohers
                                    CycleNo = 0
                                    Do
                                        
                                        NewStart = Int((MaxS * Rnd) + 1)
                                        'NewStart = XPosDiff(ST)
                                        GoOn = 0
                                        If NewStart >= XPosDiff(MinPos) - 1 Or SBF = 1 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                        
                                        If GoOn = 1 Then
                                            GoOn = 0
                                            If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                                GoOn = 1
                                                
                                            End If
                                        End If
                                        If GoOn = 1 Then
                                            
                                            GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqNumORF(0, 0), NS, NE, XDiffPos(0))
                                            
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If GeneMap(NS, 0) = GeneMap(ST, 0) Or (SBF = 1 Or SBF = 3) Then
                                                    GoOn = 1
                                                End If
                                                If GoOn = 1 Then
                                                    GoOn = 0
                                                    If GeneMap(NE, 0) = GeneMap(EN, 0) Or (SBF = 2 Or SBF = 3) Then
                                        
                                                        GoOn = 1
                                                        
                                                    End If
                                                End If
                                                If GoOn = 1 Then Exit Do
                                                
                                            End If
                                            CycleNo = CycleNo + 1
                                            If CycleNo > MaxCycleNo Then
                                                x = x
                                                XX = A
                                                Exit Do
                                            End If
                                        End If
                                    Loop
                                    OffsetY = NS - ST
                                    If SBF <> 3 Then
                                    
                                        For D = 0 To 1
                                            GoOn = 0
                                            If D = 0 Then
                                                
                                                If SBF <> 1 And GeneMap(ST, 0) = 1 Then
                                                    
                                                    S = NS: GoOn = 1
                                                   
                                                End If
                                            Else
                                                If SBF <> 2 And GeneMap(EN, 0) = 1 Then
                                                    S = NE: GoOn = 1
                                                End If
                                            End If
                                        
                                            If GoOn = 1 Then
                                                
                                                'Dummy = AddToMap(CLng(A / PNA), S, 1, Len(StrainSeq(0)), APos(0), MapORF(0, 0))
                                                onum = onum + 1
                                                
                                                
                                                MapORF(S, CLng(A / PNA)) = MapORF(S, CLng(A / PNA)) + 1
                                            End If
                                        Next D
                                    
                                    End If
                                    
                                    'check the start
                                    
                                    'check the end
                                    
                                End If
                            
                            End If
                            
                         'Next A
                    
                    End If
                    
                    
                    If A > 0 Then
                        If ExRecFlag = 1 And ORFFlag = 0 Then
                            'tSeqNum(NewStart, Z) = 1
                        Else
                            'ReDim BestP(1, NextNo), BreakPos(1, 1, NextNo)
                            
                            'mark BPs for all the other events
                            'For Y = 1 To SEventNumber
                                SPS = ST + OffsetX
                                EPS = EN + OffsetX
                                If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                                If SPS > Len(StrainSeq(0)) - 2 Then SPS = SPS - (Len(StrainSeq(0)) - 2)
                                If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                                If EPS > Len(StrainSeq(0)) - 2 Then EPS = EPS - (Len(StrainSeq(0)) - 2)
                                For Z = 0 To PermNextno
                                    If Daught(x, Z) > 0 Then
                                        
                                        tSeqnum(SPS, Z) = 1: tSeqnum(SPS + 1, Z) = 1: tSeqnum(SPS + 2, Z) = 1
                                        tSeqnum(EPS, Z) = 1: tSeqnum(EPS + 1, Z) = 1: tSeqnum(EPS + 2, Z) = 1
                                    End If
                                Next Z
                                
                                If ORFFlag = 1 Then
                                    SPS = ST + OffsetY
                                    EPS = EN + OffsetY
                                    If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                                    If SPS > Len(StrainSeq(0)) - 2 Then SPS = SPS - (Len(StrainSeq(0)) - 2)
                                    If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                                    If EPS > Len(StrainSeq(0)) - 2 Then EPS = EPS - (Len(StrainSeq(0)) - 2)
                                    For Z = 0 To PermNextno
                                        
                                        If Daught(x, Z) > 0 Then
                                            tSeqnum(SPS, Z) = 1: tSeqnum(SPS + 1, Z) = 1: tSeqnum(SPS + 2, Z) = 1
                                            tSeqnum(EPS, Z) = 1: tSeqnum(EPS + 1, Z) = 1: tSeqnum(EPS + 2, Z) = 1
                                        End If
                                    Next Z
                                
                                End If
                                
                            'Next Y
                        End If
                    End If
                    
                End If
            End If
        Next x
        ET = Abs(GetTickCount)
        If Abs(ET - LT) > 500 Then
            LT = ET
            Form1.SSPanel1.Caption = Str(A) + " of" + Str(PermNum) + " permutations completed"
            Form1.ProgressBar1.Value = (A / PermNum) * 80
            Call UpdateF2Prog
            If A / 10 = CLng(A / 10) Then
                Form1.Refresh
                If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
            Else
                Form1.SSPanel1.Refresh
                If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
            End If
            DoEvents
        End If
        XXX = ZZZ
        x = onum
        XX = PermTX
        
        
        'smooth maps with win
        'do fisrt window
        Dim LAP As Long, TotP As Double, tMapS() As Double
        
        'LAP = APos(Len(StrainSeq(0)))
        LAP = APos(Len(StrainSeq(0)))
        'XX = UBound(MaP, 1)
        ReDim tMapS(LAP)
        Dim hWin As Long
        hWin = CLng(Win / 2)
        If CircularFlag = 1 Then
'        If A = 12 Or A = 61 Or A = 75 Then
'            x = x
'        End If
        
            TotP = 0
            For x = -hWin + 1 To hWin
                
                If x < 1 Then
                    Y = LAP + x
                ElseIf x > LAP Then
                    Y = x - LAP
                Else
                    Y = x
                End If
                If MapS(Y, A) > 0 Then
                    x = x
                End If
                TotP = TotP + MapS(Y, A) '2022,2023,2024
                If MapS(Y, A) < 0 Then
                    x = x
                End If
            Next x
            tMapS(1) = TotP
            x = x
        Else
            TotP = 0
            For x = 1 To hWin
               
                TotP = TotP + MapS(x, A)
            Next x
            tMapS(1) = TotP
            x = x
        End If
        If CircularFlag = 1 Then
            For x = 2 To LAP
                If x = 294 Then
                    x = x
                End If
'                If x = 495 Then
'                    x = x
'                End If
                Y = x - (hWin + 1)
                If Y < 1 Then
                    Y = Y + LAP
                End If
                tMapS(x) = tMapS(x - 1) - MapS(Y, A) '2022,2023,2024
                
                Y = x + (hWin - 1)
                If Y > LAP Then
                    Y = Y - LAP
                End If
                
                tMapS(x) = tMapS(x) + MapS(Y, A) '101,102,103
                If tMapS(x) < 0 Then
                    tMapS(x) = 0
'
'                    For YY = 0 To LAP
'                        If MapS(LAP - 100, A) = Abs(tMapS(x)) Then
'                            x = x
'                        End If
'                    Next YY
                End If
                
                
                
            Next x
            x = x
        Else
            For x = 2 To LAP
                
                tMapS(x) = tMapS(x - 1)
                Y = x - (hWin + 1)
                If Y > 1 Then
                    tMapS(x) = tMapS(x) - MapS(Y, A)
                End If
                
                Y = x + hWin - 1
                If Y <= LAP Then
                    tMapS(x) = tMapS(x) + MapS(Y, A)
                End If
                If tMapS(x) < 0 Then
                    tMapS(x) = 0
                End If
            Next x
        End If
        For x = 0 To LAP
'            If x = 3200 Then
'                x = x
'            End If
            MapS(x, A) = tMapS(x)
            
        Next x
        
    Next A
   
    XX = aaaa '248
    XX = SEventNumber
    EEE = Abs(GetTickCount)
    ttt = EEE - AAA '96.034, 88.172 using sbf'88.203'86.502'85.988 all checkbpol optimizations'46.177 only checking every 3rd site
    
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    End If
    
    
    
    
    Erase tSeqnum
    Erase tSeqNumORF
    
   
    
    
   If SHAPEFlag = 1 Then
        'count how many are < 0
        Dim NSmaller As Long, SHAPEp As Double, NBigger As Long, SHAPEp2 As Double
        Dim ANSmaller As Long, ASHAPEp As Double, ANBigger As Long, ASHAPEp2 As Double
        Dim TotSS() As Double
        ReDim TotSS(PermNum)
        Dim SSMod() As Double
        ReDim SSMod(PermNum)
        For Y = 0 To PermNum
            For x = 0 To UBound(MapS, 1)
                SSMod(Y) = SSMod(Y) + MapS(x, Y) '* SHAPEScores(x)
            Next x
        Next Y
        For Y = 1 To PermNum
            SSMod(Y) = SSMod(Y) / SSMod(0)
            x = x
        Next Y
        
        SSMod(0) = 1
        For Y = 0 To PermNum
            For x = 0 To UBound(MapS, 1)
                TotSS(Y) = TotSS(Y) + (MapS(x, Y) / SSMod(Y)) * SHAPEScores(x)
            Next x
            If Y > 0 Then
                If TotSS(0) > TotSS(Y) Then
                    ANBigger = ANBigger + 1
                End If
                If TotSS(0) < TotSS(Y) Then
                    ANSmaller = ANSmaller + 1
                End If
            End If
            x = x
        Next Y
        
        
        NSmaller = 0
        For x = 1 To PermNum
            If SHAPEScore(0) < SHAPEScore(x) Then '73.306 -91.123
                NSmaller = NSmaller + 1
            End If
        Next x
        NBigger = 0
        For x = 1 To PermNum
            If SHAPEScore(0) > SHAPEScore(x) Then '73.306 -91.123
                NBigger = NBigger + 1
            End If
        Next x
        
        SHAPEp = 1 - NSmaller / PermNum '0.055
        SHAPEp2 = 1 - NBigger / PermNum '0.055
        ASHAPEp = 1 - ANSmaller / PermNum '0.055
        ASHAPEp2 = 1 - ANBigger / PermNum '0.055
        XX = 1 - SHAPEp
        XX = PermTX
        
        If CLine = "" Then
            If SHAPEp < 0.05 Then
                If SHAPEp = 0 Then
                    MsgBox ("When considering only called breakpoint locations there is a detectable association between breakpoint positions and LOWER values of the current siteset (p-val < 0" + Trim(Str(1 / PermNum)) + ")")
                Else
                    MsgBox ("When considering only called breakpoint locations there is a detectable association between breakpoint positions and LOWER values of the current siteset (p-val = 0" + Trim(Str(SHAPEp)) + ")")
                
                End If
            ElseIf SHAPEp2 < 0.05 Then
                If SHAPEp2 = 0 Then
                    MsgBox ("When considering only called breakpoint locations there is a detectable association between breakpoint positions and HIGHER values of the current siteset (p-val < 0" + Trim(Str(1 / PermNum)) + ")")
                Else
                    MsgBox ("When considering only called breakpoint locations there is a detectable association between breakpoint positions and HIGHER values of the current siteset (p-val = 0" + Trim(Str(SHAPEp2)) + ")")
                End If
            Else
                'If SHAPEp <= 0.99 Then
                    MsgBox ("When considering only called breakpoint locations there is no detectable association between breakpoint positions and the current siteset (p-val = 0" + Trim(Str(SHAPEp)) + " for LOWER and p-val = 0" + Trim(Str(SHAPEp2)) + " for HIGHER)")
                'Else
                '    MsgBox ("There is no detectable association between breakpoint positions and the current siteset (p-val < 1.0)")
                'End If
            End If
            
            
            If ASHAPEp < 0.05 Then
                If ASHAPEp = 0 Then
                    MsgBox ("When considering breakpoint probability distrubutions and the analysis window there is a detectable association between breakpoint positions and LOWER values of the current siteset (p-val < 0" + Trim(Str(1 / PermNum)) + ")")
                Else
                    MsgBox ("When considering breakpoint probability distrubutions and the analysis window there is a detectable association between breakpoint positions and LOWER values of the current siteset (p-val = 0" + Trim(Str(ASHAPEp)) + ")")
                
                End If
            ElseIf ASHAPEp2 < 0.05 Then
                If ASHAPEp2 = 0 Then
                    MsgBox ("When considering breakpoint probability distrubutions and the analysis window there is a detectable association between breakpoint positions and HIGHER values of the current siteset (p-val < 0" + Trim(Str(1 / PermNum)) + ")")
                Else
                    MsgBox ("When considering breakpoint probability distrubutions and the analysis window there is a detectable association between breakpoint positions and HIGHER values of the current siteset (p-val = 0" + Trim(Str(ASHAPEp2)) + ")")
                End If
            Else
                'If ASHAPEp <= 0.99 Then
                    MsgBox ("When considering breakpoint probability distrubutions and the analysis window there is no detectable association between breakpoint positions and the current siteset (p-val = 0" + Trim(Str(ASHAPEp)) + " for LOWER and p-val = 0" + Trim(Str(ASHAPEp2)) + " for HIGHER)")
                'Else
                '    MsgBox ("There is no detectable association between breakpoint positions and the current siteset (p-val < 1.0)")
                'End If
            End If
        ElseIf SSOutName <> "" Then
            Dim FFAp As Long
            FFAp = FreeFile
            If SSAppendFlag = 1 Then
                Open SSOutName For Append As #FFAp
            Else
                Open SSOutName For Output As #FFAp
            End If
            Print #FFAp, "Siteset association results for " + SSInName + " against breakpoints found in " + RDPInName
            If ASHAPEp2 = 0 Then
                Print #FFAp, Str(SHAPEScore(0)) + "," + Str(TotSS(0)) + "," + "Probability of no association between breakpoint sites and HIGHER values of the Siteset < " + Trim(Str(1 / PermNum))
            Else
                Print #FFAp, Str(SHAPEScore(0)) + "," + Str(TotSS(0)) + "," + "Probability of no association between breakpoint sites and HIGHER values of the Siteset = " + Trim(Str(ASHAPEp2))
            End If
            If ASHAPEp = 0 Then
                Print #FFAp, Str(SHAPEScore(0)) + "," + Str(TotSS(0)) + "," + "Probability of no association between breakpoint sites and LOWER values of the Siteset < " + Trim(Str(1 / PermNum))
            Else
                Print #FFAp, Str(SHAPEScore(0)) + "," + Str(TotSS(0)) + "," + "Probability of no association between breakpoint sites and LOWER values of the Siteset = " + Trim(Str(ASHAPEp))
            End If
            Print #FFAp, ""
            Close #FFAp
        End If
        x = x
        
        'Exit Sub
   End If
    
   For x = 1 To PermNum
        For Y = 1 To Len(StrainSeq(0))
            
            If ModnumY(BPos(Y)) > 0 Then
            
                MapS(Y, x) = MapS(Y, x) / ModnumY(BPos(Y))
            Else
                x = x
            End If
        Next Y
   Next x
   Erase ModnumY
    'get maxes
   EE = Abs(GetTickCount)
   TT = EE - SS
   '16.141
   x = x
   'Exit Sub
    'DN = 1
    SS = Abs(GetTickCount)
    If x = 12345 Then
       ' Dummy = FindMaxMapVal(DN, Len(StrainSeq(0)), CLng(PermNum / PNA), MaxVals(0, 0), MaP(0, 0))
    Else
        For x = 1 To PermNum
            For Y = DN To Len(StrainSeq(0)) - DN + 1
                If MaxVals(0, CLng(x / PNA)) < MapS(Y, CLng(x / PNA)) Then MaxVals(0, CLng(x / PNA)) = MapS(Y, CLng(x / PNA))
               x = x
            Next Y
            x = x '9,8,9,9,8,8,8,12,7,8,8,10,10
        Next x
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS
    '3.194
    'XX = MaxVals(0, 5) '16,16,16,19,20
    SS = Abs(GetTickCount)
    
    'sort through the top 5% and get the 99% and 95% highest scores
    
    
    
    '***************Uncomment for normal function
    Target(1) = CLng(0.05 * PermNum) + 1
    Target(0) = CLng(0.01 * PermNum) + 1
    
    'Target(1) = CLng(0.05 * PermNum) + 1
    'Target(0) = CLng(0.1 * PermNum) + 1
    For Z = 0 To 1
        If Target(Z) < 1 Then Target(Z) = 1
    Next Z
    For Z = 1 To Target(1)
        MaxV(0) = 0
        MaxV(1) = 0
        For x = 0 To PermNum
            If MaxV(0) < MaxVals(0, CLng(x / PNA)) Then
                MaxV(0) = MaxVals(0, CLng(x / PNA))
                MaxP(0) = x
            End If
            If MaxV(1) < MaxVals(1, CLng(x / PNA)) Then
                MaxV(1) = MaxVals(1, CLng(x / PNA))
                MaxP(1) = x
            End If
        Next x
        If Z = Target(0) Then
            CV(0, 0) = MaxV(0)
            CV(1, 0) = MaxV(1)
        End If
        If Z = Target(1) Then
            CV(0, 1) = MaxV(0)
            CV(1, 1) = MaxV(1)
        End If
        MaxVals(0, CLng(MaxP(0) / PNA)) = 0
        MaxVals(1, CLng(MaxP(1) / PNA)) = 0
    Next Z
    
    
    
    SS = Abs(GetTickCount)
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    'CTNames() As String, CTNumlines As Long, CTBlocks() As Long, CTBlockNum As Long, CTText() As String, CTTextNum As Long
    CTNumlines = -1
    
    If ORFFlag = 1 Then
    
       'xxxxxxx = bits related to saving and displaying the graphic version of the tests
        
        '0 of ctblocks = xpos1, 1 = ypos1, 2 = xpos2, 3 = ypos2, 4 = colour
        '0 of cttext = xpos1, 1 = ypos1, 2 = xposcolour, 3 = text
        Dim StartP As Long, EndP As Long, BlockCol(2) As Long
        ReDim CTBlocks(4, 100), CTText(3, 100) 'xxxxxxxx
        ReDim CTNames(GeneNumber + 10) 'these are used for permenant storage
        
        
        'Form1.Picture2.DrawMode = 2
        BlockCol(0) = RGB(255, 128, 0)
        BlockCol(1) = RGB(0, 128, 255)
        BlockCol(2) = HalfColour 'quartercolour
        CTTextNum = -1
        CTBlockNum = -1
        
        'Need to make TempGeneMaps for 5% 10%, 25% edges
        Dim TempGeneMap() As Byte
        ReDim TempGeneMap(Len(StrainSeq(0)), GeneNumber + 3)
        For Y = 1 To Len(StrainSeq(0))
            If GeneMap(Y, 0) = 0 Then
                TempGeneMap(Y, 0) = 1
                For x = 1 To GeneNumber + 3
                    TempGeneMap(Y, x) = 2
                Next x
            Else
                For x = 1 To GeneNumber
                    TempGeneMap(Y, x) = GeneMap(Y, x)
                    If GeneMap(Y, x + GeneNumber) = 1 Then TempGeneMap(Y, GeneNumber + 1) = 1
                    If GeneMap(Y, x + GeneNumber * 2) = 1 Then TempGeneMap(Y, GeneNumber + 2) = 1
                    If GeneMap(Y, x + GeneNumber * 3) = 1 Then TempGeneMap(Y, GeneNumber + 3) = 1
                Next x
            End If
            
        Next Y
       
        
        
        'Make the blocks - this info is stored in genemap - note genome-length is scaled to the genome length
       CTBlockNum = -1
        For A = 2 To 0 Step -1
            For x = 0 To GeneNumber + 3
                
                For Y = 1 To Len(StrainSeq(0))
                    If TempGeneMap(Y, x) = A Then
                        StartP = Y
                        For Z = Y + 1 To Len(StrainSeq(0))
                            
                            If (TempGeneMap(Z, x) <> A) Or Z = Len(StrainSeq(0)) Then
                                
                                CTBlockNum = CTBlockNum + 1
                                'If CTBlockNum = 97 Then
                                '    X = X
                                'End If
                                If CTBlockNum > UBound(CTBlocks, 2) Then ReDim Preserve CTBlocks(4, CTBlockNum + 100)
                                CTBlocks(0, CTBlockNum) = StartP
                                CTBlocks(1, CTBlockNum) = x * 2 + 3
                                CTBlocks(2, CTBlockNum) = Z - 1
                                CTBlocks(3, CTBlockNum) = x * 2 + 4
                                CTBlocks(4, CTBlockNum) = BlockCol(A)
                                Exit For
                            End If
                        Next Z
                        
                        Y = Z
                    End If
                
                Next Y
            
            Next x
        Next A
        
        
        'Call DrawCTBlocks
        
        
        
        
        
        
        
        
        Dim TestS() As Double, TestArea() As Long 'these are used for temporary storage
        ReDim TestS(GeneNumber + 10, 3) ' test 0 = IR test
                                        'test 1 =gene1 test
                                        'test n = gene n test
                                        'test n+1 = 25% Gene edge test
                                        'test n+2 = 10% Gene edge test
                                        'test n+3 = 5% Gene edge test
        
       ' Call DrawCTBlocks
        
        
        
        
        
        
        ReDim TestArea(GeneNumber + 10, PermNum, 1) ' perm0 = real data, (1) = inarea
        
        For x = 1 To ENumb
            If Excl(x) = 1 Then
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        If GeneMap(ST, 0) = 0 Then
                            TestArea(0, 0, 0) = TestArea(0, 0, 0) + 1
                        Else
                            TestArea(0, 0, 1) = TestArea(0, 0, 1) + 1
                        End If
                        For Z = 1 To GeneNumber
                            If GeneMap(ST, Z) = 0 Then
                                If GeneMap(ST, 0) = 1 Then 'only count stes that are in some ORF.
                                    TestArea(Z, 0, 0) = TestArea(Z, 0, 0) + 1
                                End If
                            Else
                                TestArea(Z, 0, 1) = TestArea(Z, 0, 1) + 1
                                
                            End If
                        Next Z
                        For Z = 1 To GeneNumber
                            If GeneMap(ST, Z + GeneNumber) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count sites that are in same ORF.
                                    TestArea(GeneNumber + 1, 0, 0) = TestArea(GeneNumber + 1, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 1, 0, 1) = TestArea(GeneNumber + 1, 0, 1) + 1
                                
                            End If
                            If GeneMap(ST, Z + GeneNumber * 2) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 2, 0, 0) = TestArea(GeneNumber + 2, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 2, 0, 1) = TestArea(GeneNumber + 2, 0, 1) + 1
                                
                            End If
                            If GeneMap(ST, Z + GeneNumber * 3) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 3, 0, 0) = TestArea(GeneNumber + 3, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 3, 0, 1) = TestArea(GeneNumber + 3, 0, 1) + 1
                            End If
                        Next Z
                    End If
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        If GeneMap(EN, 0) = 0 Then
                            TestArea(0, 0, 0) = TestArea(0, 0, 0) + 1
                        Else
                            TestArea(0, 0, 1) = TestArea(0, 0, 1) + 1
                        End If
                        For Z = 1 To GeneNumber
                            If GeneMap(EN, Z) = 0 Then
                                If GeneMap(EN, 0) = 1 Then 'only count stes that are in some ORF.
                                    TestArea(Z, 0, 0) = TestArea(Z, 0, 0) + 1
                                End If
                            Else
                                TestArea(Z, 0, 1) = TestArea(Z, 0, 1) + 1
                                
                            End If
                        Next Z
                        For Z = 1 To GeneNumber
                            If GeneMap(EN, Z + GeneNumber) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count sites that are in same ORF.
                                    TestArea(GeneNumber + 1, 0, 0) = TestArea(GeneNumber + 1, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 1, 0, 1) = TestArea(GeneNumber + 1, 0, 1) + 1
                                
                            End If
                            If GeneMap(EN, Z + GeneNumber * 2) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 2, 0, 0) = TestArea(GeneNumber + 2, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 2, 0, 1) = TestArea(GeneNumber + 2, 0, 1) + 1
                                
                            End If
                            If GeneMap(EN, Z + GeneNumber * 3) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 3, 0, 0) = TestArea(GeneNumber + 3, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 3, 0, 1) = TestArea(GeneNumber + 3, 0, 1) + 1
                            End If
                        Next Z
                        x = x
                        'XX = GeneMap(EN, 0)
                    End If
                End If
            End If
            
        Next x
            
        For Z = 1 To Len(StrainSeq(0))
            'IR test
            If GeneMap(Z, 0) = 0 Then
                For A = 1 To PermNum
                    TestArea(0, A, 0) = TestArea(0, A, 0) + MapIR(Z, CLng(A / PNA))
                Next A
            Else
                For A = 1 To PermNum
                    TestArea(0, A, 1) = TestArea(0, A, 1) + MapIR(Z, CLng(A / PNA))
                Next A
            End If
            For x = 1 To GeneNumber
               If x = 12345 Then
                    AA = 0
                    'Open "test.csv" For Output As #1
                    
                    For n = 0 To Len(StrainSeq(0))
                        
                            If GeneMap(n, 8) = 1 Then
                                For M = 0 To PermNum
                                    AA = AA + MapORF(n, M) 'gag=7982, nef=3474;gag=10884; nef=2316
                                Next M
                            End If
                        
                    Next n
                    'Close #1
                End If
                If GeneMap(Z, x) = 1 Then
                    For A = 1 To PermNum
                        If MapORF(Z, A) <> 0 Then
                            TestArea(x, A, 1) = TestArea(x, A, 1) + MapORF(Z, A) ' CLng(A / PNA))
                        End If
                    Next A
                Else
                    For A = 1 To PermNum
                        If MapORF(Z, A) <> 0 Then
                            TestArea(x, A, 0) = TestArea(x, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        End If
                    Next A
                End If
                If GeneMap(Z, x) = 1 Then
                    If GeneMap(Z, x + GeneNumber) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 1, A, 1) = TestArea(GeneNumber + 1, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 1, A, 0) = TestArea(GeneNumber + 1, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                    If GeneMap(Z, x + GeneNumber * 2) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 2, A, 1) = TestArea(GeneNumber + 2, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 2, A, 0) = TestArea(GeneNumber + 2, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                    If GeneMap(Z, x + GeneNumber * 3) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 3, A, 1) = TestArea(GeneNumber + 3, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 3, A, 0) = TestArea(GeneNumber + 3, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                End If
                
            Next x
            eexx = Abs(GetTickCount)
            If Abs(eexx - ssxx) > 500 Then
            
                ssxx = eexx
                Form1.SSPanel1.Caption = Str(CLng((Z / Len(StrainSeq(0))) * 100)) + "% of tests completed"
                Form1.Refresh
                DoEvents
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        Next Z
        
        Form1.SSPanel1.Caption = "100% of tests completed"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            
            
        For x = 0 To GeneNumber
            'Min = PermNum * 2
            'Max = 0
            
            For A = 1 To Len(StrainSeq(0))
                If GeneMap(A, x) = 1 Then GoOn = 1: Exit For
            Next A
            If GoOn = 1 Then
                For A = 1 To PermNum
                    If TestArea(x, A, 0) > TestArea(x, 0, 0) Then x = x 'Tests(X, 0) = Tests(X, 0) + 1
                    If TestArea(x, A, 0) < TestArea(x, 0, 0) Then x = x 'Tests(X, 1) = Tests(X, 1) + 1
                    
                    
                    If TestArea(x, A, 1) >= TestArea(x, 0, 1) Then
                        TestS(x, 1) = TestS(x, 1) + 1
                        'If X = 1 Then
                        '    X = X
                        'End If
                    End If
                    If TestArea(x, A, 1) <= TestArea(x, 0, 1) Then
                         'If X = 1 Then
                         '   X = X
                        'End If
                        TestS(x, 0) = TestS(x, 0) + 1
                    End If
                Next A
                For A = 0 To 3
                    TestS(x, A) = TestS(x, A) / PermNum
                    
                Next A
            End If
        Next x
        
        For x = GeneNumber + 1 To GeneNumber + 3
                For A = 1 To PermNum
                    If TestArea(x, A, 0) > 0 Then
                        x = x
                    End If
                    If TestArea(x, A, 0) > TestArea(x, 0, 0) Then x = x ' Tests(X, 0) = Tests(X, 0) + 1
                    If TestArea(x, A, 0) < TestArea(x, 0, 0) Then x = x '  Tests(X, 1) = Tests(X, 1) + 1
                    If TestArea(x, A, 1) >= TestArea(x, 0, 1) Then TestS(x, 1) = TestS(x, 1) + 1
                    If TestArea(x, A, 1) <= TestArea(x, 0, 1) Then TestS(x, 0) = TestS(x, 0) + 1
                Next A
                For A = 0 To 1
                    TestS(x, A) = TestS(x, A) / PermNum
                Next A
        Next x
        
        
        
        If DebuggingFlag < 2 Then On Error Resume Next

        oDir = CurDir
        odrv = CurDir
        ChDir App.Path
        ChDrive App.Path
        On Error GoTo 0
        Close #1
        Open "Permutation test.csv" For Append As #1
        Open "TempFile" For Output As #4
        Print #1, ""
        Print #1, FName
        Print #1, Date & "," & Time
        CTNumlines = CTNumlines + 1
        CTTextNum = CTTextNum + 1
        
        'elemnet 1: 0 = lhs of box, 1 = middle column 1, 2 = middle columns 1+2, 3 = middle column2, 4 = middle column 3, 5 = middle columns 3&4, 6 = middle column 4,
        ' 7 = middle column 5, 8 = middle columns 5&6, 9 = middle column 6
        
        CTText(0, CTTextNum) = 2
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "Breakpoint #"
        
        
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 5
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "Breakpoints/100nts"
        
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 8
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "P-val"
        
        
        
        
        CTNames(CTNumlines) = "Test, Breakpoints No in region, Breakpoint No outside region, breakpoints/100nts in region, breakpoints/100nts outside region, Probability of fewer than expected BPs in region, Probability of more than expected BPs in region"
        Print #1, CTNames(CTNumlines)
        Print #4, CTNames(CTNumlines)
        Dim oSTring As String
        
        Dim PropINOUT(1) As Double, PropBase(1) As Double
        PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
        For x = 1 To Len(StrainSeq(0))
            If GeneMap(x, 0) = 1 Then
                PropINOUT(0) = PropINOUT(0) + 1
                For Y = 0 To NextNo
                    If SeqNum(x, Y) <> 46 Then
                        PropBase(0) = PropBase(0) + 1
                    End If
                    
                Next Y
            Else
                PropINOUT(1) = PropINOUT(1) + 1
                For Y = 0 To NextNo
                    If SeqNum(x, Y) <> 46 Then
                        PropBase(1) = PropBase(1) + 1
                    End If
                Next Y
            End If
        Next x
        
        
        If PropINOUT(1) > 0 Then
            PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
            PropINOUT(1) = (100 * (TestArea(0, 0, 0) / PropINOUT(1))) / PropBase(1)
        Else
            PropINOUT(1) = 0
        End If
        
        If PropINOUT(0) > 0 Then
            PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
            PropINOUT(0) = (100 * TestArea(0, 0, 1) / PropINOUT(0)) / PropBase(0)
        Else
            PropINOUT(0) = 0
        End If
        oSTring = "Intergenic regions vs all ORFs combined"
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 0
        CTText(1, CTTextNum) = 2
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = oSTring
        
        LastX = 0
            
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 1
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(TestArea(0, 0, 0))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 3
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(TestArea(0, 0, 1))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 4
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(PropINOUT(1))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 6
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(PropINOUT(0))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 7
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(TestS(0, 0))
        If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 9
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(TestS(0, 1))
        If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
        
        CTNumlines = CTNumlines + 1
        
        CTNames(CTNumlines) = oSTring + "," + Str(TestArea(0, 0, 0)) + "," + Str(TestArea(0, 0, 1)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(0, 0)) + "," + Str(TestS(0, 1)) + ","
        Print #1, CTNames(CTNumlines)
        Print #4, CTNames(CTNumlines)
        For x = 1 To GeneNumber
            
            If TestName(x) <> "" Then
                Pos = 0
                'replace commas in the test name with semi colons
                Do
                    Pos = InStr(Pos + 1, TestName(x), ",", vbBinaryCompare)
                    If Pos = 0 Then
                        Exit Do
                    Else
                        Mid(TestName(x), Pos, 1) = ";"
                    End If
                Loop
                PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
                
                For Z = 1 To Len(StrainSeq(0))
                    If GeneMap(Z, 0) = 1 Then
                        If GeneMap(Z, x) = 0 Then
                            PropINOUT(0) = PropINOUT(0) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(0) = PropBase(0) + 1
                                End If
                            Next Y
                            
                        Else
                            PropINOUT(1) = PropINOUT(1) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(1) = PropBase(1) + 1
                                End If
                            Next Y
                        End If
                    Else
                    x = x '1-3813:5322-end
                    End If
                Next Z
                'PropINOUT(0) = 6781,7800
                'PropINOUT(1) = 1019
                'PropBase(0) = 1193456'1380600
                'PropBase(1) = 179344
                If PropINOUT(1) > 0 Then '1019,
                    PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
                    PropINOUT(1) = (100 * TestArea(x, 0, 1) / PropINOUT(1)) * PropBase(1)
                Else
                    PropINOUT(1) = 0
                End If
                
                If PropINOUT(0) > 0 Then
                    PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
                    PropINOUT(0) = (100 * TestArea(x, 0, 0) / PropINOUT(0)) * PropBase(0)
                Else
                    PropINOUT(0) = 0
                End If
                CTNumlines = CTNumlines + 1
                CTNames(CTNumlines) = TestName(x) + "," + Str(TestArea(x, 0, 1)) + "," + Str(TestArea(x, 0, 0)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(x, 1)) + "," + Str(TestS(x, 0))
                Print #1, CTNames(CTNumlines)
                Print #4, CTNames(CTNumlines)
                CTTextNum = CTTextNum + 1
                If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
                
                CTText(0, CTTextNum) = 0
                CTText(1, CTTextNum) = x * 2 + 2
                CTText(2, CTTextNum) = 0
                CTText(3, CTTextNum) = TestName(x)
                LastX = x
            
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 1
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(TestArea(x, 0, 1))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 3
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(TestArea(x, 0, 0))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 4
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(PropINOUT(1))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 6
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(PropINOUT(0))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 7
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(TestS(x, 1))
               If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 9
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(TestS(x, 0))
               If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
               
                
                
            End If
            
        Next x
        
        
        For A = 1 To 3
            PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
            For x = 1 To GeneNumber
                
                For Z = 1 To Len(StrainSeq(0))
                    If GeneMap(Z, x) = 1 Then
                        If GeneMap(Z, x + A * GeneNumber) = 0 Then
                            PropINOUT(0) = PropINOUT(0) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(0) = PropBase(0) + 1
                                End If
                                
                            Next Y
                        Else
                            PropINOUT(1) = PropINOUT(1) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(1) = PropBase(1) + 1
                                End If
                                
                            Next Y
                        End If
                    End If
                Next Z
                
            
            Next x
            
            
            If PropINOUT(1) > 0 Then
                PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
                PropINOUT(1) = (100 * TestArea(GeneNumber + A, 0, 1) / PropINOUT(1)) / PropBase(1)
            Else
                PropINOUT(1) = 0
            End If
            If PropINOUT(0) > 0 Then
                PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
                PropINOUT(0) = (100 * TestArea(GeneNumber + A, 0, 0) / PropINOUT(0)) / PropBase(0)
             Else
                PropINOUT(0) = 0
            End If
            CTNumlines = CTNumlines + 1
            CTNames(CTNumlines) = TestName(GeneNumber + A) + "," + Str(TestArea(GeneNumber + A, 0, 1)) + "," + Str(TestArea(GeneNumber + A, 0, 0)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(GeneNumber + A, 1)) + "," + Str(TestS(GeneNumber + A, 0))
            Print #1, CTNames(CTNumlines)
            Print #4, CTNames(CTNumlines)
            LastX = LastX + 1 'lastx should = GeneNUmber+A
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 0
            CTText(1, CTTextNum) = LastX * 2 + 2
            CTText(2, CTTextNum) = 0
            CTText(3, CTTextNum) = TestName(LastX)
            
         
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 1
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(TestArea(GeneNumber + A, 0, 1))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 3
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(TestArea(GeneNumber + A, 0, 0))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 4
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(PropINOUT(1))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 6
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(PropINOUT(0))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 7
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(TestS(GeneNumber + A, 1))
            If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 9
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(TestS(GeneNumber + A, 0))
            If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
            
        Next A
        
        
        
        Erase GeneMap
        'ostring =
        Close #1
        Close #4
        'This is the file that is saved when the table in picturebox 2 gets saved
        Open "TempFile" For Binary As #1
            ClusteringResult = String(LOF(1), " ")
            Get #1, , ClusteringResult
        Close #1
        
        
        
        ManFlag = 161
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "TempFile"
        ChDir oDir
        ChDrive odrv
        On Error GoTo 0
          'Form1.Picture20.Visible = False
          Call DrawCTBlocks
          x = x
          Erase MapORF
          Erase MapIR
          Erase GeneMap
          Erase TempGeneMap
    End If
    'ReDim MapORF(0, 0)
    'ReDim MapIR(0, 0)
    
    
    Erase TestArea
    If x = x Then
        GlobalMemoryStatus MemSit
        
        APhys = Abs(MemSit.dwAvailPhys)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        If APhys < (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4) Then
            shortfall = (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4) - APhys
            MsgBox ("There is not enough available free memory to complete the permutation test.  You are short of ~" + Trim(Str(Int(shortfall / 1000000)))) + " Megs of RAM. Either free up some memory or try doing the test on a computer with more RAM"
            x = x
            AbortFlag = 1
            Exit Sub
        End If

        oPermNum = PermNum
        PermNum = CLng(TargetS(1) * PermNum * 2) + 4 '100
        ReDim PValMap(Len(StrainSeq(0)), CLng(PermNum / PNA))
        'Exit Sub
        SS = Abs(GetTickCount)
        Form1.ProgressBar1.Value = 90
        Call UpdateF2Prog
        Dim TopS As Single, BottomS As Single, DoneNum As Long, ZDP As Long
        If x = 12348885 Then
            Dummy = MakePValMap(DN, Len(StrainSeq(0)), CLng(PermNum / PNA), MaP(0, 0), PValMap(0, 0))
        ElseIf x = x Then
            'this just sorts the best and worst
            'first sort the best
            Dim TargetNum As Long, WinPos As Long, UBMS As Long, UBPVM As Long
            UBMS = UBound(MapS, 1)
            UBPVM = UBound(PValMap, 1)
            TargetNum = oPermNum * TargetS(1) + 2 'the number of best/worst that need to be put into pvalmap
            
            For Y = DN To APos(Len(StrainSeq(0))) - DN + 1
                
                
                If x = x Then
                    Dummy = MakeLowCI(Y, TargetNum, oPermNum, PNA, UBMS, MapS(0, 0), UBPVM, PValMap(0, 0))
                Else
                    For x = 0 To TargetNum
                        TopS = 0
                        For Z = 1 To oPermNum
                            ZDP = CLng(Z / PNA)
                            If MapS(Y, ZDP) >= TopS Then
                                TopS = MapS(Y, ZDP)
                                WinPos = ZDP
                            End If
                        Next Z
                        PValMap(Y, x) = MapS(Y, WinPos)
                        MapS(Y, WinPos) = (-MapS(Y, WinPos) - 1)
                    Next x
                End If
                XX = PValMap(Y, 2)
                SS = Abs(GetTickCount)
                If Abs(SS - LSS) > 500 Then
                    LSS = SS
                    Form1.SSPanel1.Caption = "Lower confidence intervals determined at " + Trim(Str(Y - DN)) + " of " + Trim(Str(Len(StrainSeq(0)) - DN + 1)) + " sites"
                    DoEvents
                End If
            
            Next Y
            
            'second sort the worst
            For Y = DN To APos(Len(StrainSeq(0))) - DN + 1
                
                If x = x Then
                    Dummy = MakeHighCI(PermNum, Y, TargetNum, oPermNum, PNA, UBMS, MapS(0, 0), UBPVM, PValMap(0, 0))
                Else
                    For x = PermNum To PermNum - TargetNum Step -1
                        TopS = 1000000
                        For Z = 1 To oPermNum
                            ZDP = CLng(Z / PNA)
                            If MapS(Y, ZDP) <= TopS Then
                                If MapS(Y, ZDP) >= 0 Then
                                    TopS = MapS(Y, ZDP)
                                    WinPos = ZDP
                                End If
                            End If
                        Next Z
                        PValMap(Y, x) = MapS(Y, WinPos)
                        MapS(Y, WinPos) = -MapS(Y, WinPos) - 1
                    Next x
                End If
'                XX = PValMap(Y, 40)
'                PValMap(Y, 40) = 0
                SS = Abs(GetTickCount)
                If Abs(SS - LSS) > 500 Then
                    LSS = SS
                    Form1.SSPanel1.Caption = "Upper confidence intervals determined at " + Trim(Str(Y - DN)) + " of " + Trim(Str(Len(StrainSeq(0)) - DN + 1)) + " sites"
                    DoEvents
                End If
            Next Y
            
        
        Else
            'This does a full sort
            
            
            For Y = DN To APos(Len(StrainSeq(0))) - DN + 1
'                If Y = 3200 Then
'                    x = x
'                End If
                'DoEvents
                TopS = 1000000: BottomS = 0
                DoneNum = 0
                For x = 0 To PermNum
                
                    DoneNum = 0
                    BottomS = 0
                    For Z = 0 To PermNum
                        ZDP = CLng(Z / PNA)
                        If MapS(Y, ZDP) > BottomS Then
                            If MapS(Y, ZDP) < TopS Then
                                BottomS = MapS(Y, ZDP)
                                DoneNum = 1
                            End If
                        End If
                    Next Z
                    If DoneNum = 1 Then
                        DoneNum = 0
                        'find how many are equal to bottoms and add to pvalmap
                        For Z = 0 To PermNum
                            ZDP = CLng(Z / PNA)
                            If MapS(Y, ZDP) = BottomS Then
                                PValMap(Y, CLng((x + DoneNum) / PNA)) = MapS(Y, ZDP)
                                DoneNum = DoneNum + 1
                            End If
                        Next Z
                        
                        TopS = BottomS
                        
                        If DoneNum > 1 Then x = x + DoneNum - 1
                        LastX = x + 1
                    Else
                        For Z = LastX To PermNum
                            PValMap(Y, CLng(Z / PNA)) = 0
                        Next Z
                        Exit For
                    End If
                   ' DoEvents
                Next x
            Next Y
        End If
    End If
    PermNum = oPermNum
    x = x
End Sub
Public Sub RecombMapPermsB(DN As Long, APos() As Long, BPos() As Long, Excl() As Byte, CV() As Double, Win As Long, PermNum As Long, RNDSEED As Long)
    
    Dim SPS As Long, EPS As Long, A As Long, x As Long, MaxPos As Long, MinPos As Long, OffsetX As Long, OffsetY As Long, PPos As Long, Target(1) As Long, MaxV(1) As Double, MaxP(1) As Long, MaxVals() As Long, NewStart As Long, S As Long, NS As Long, NE As Long, LSSeq As Long, RecSize As Long, MaxS As Long, MaP() As Integer, Size As Long, D As Long, P1 As Long, P2 As Long
    Dim tSeqnum() As Integer, tSeqNumORF() As Integer, MaxCycleNo As Long, CycleNo As Long, MapORF() As Integer, MapIR() As Integer
    Dim BestP() As Double, BreakPos() As Long, BreakNum As Long, OKProg(20) As Byte
    Dim xxWin As Double
    Dim SBF As Long
        
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , PermSeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    
    CurrentCheck = 15
    'Call UnModSeqNum(0)
    'SHAPECO = 0.25
    ''XX = SHAPEFlag
    For x = 0 To AddNum - 1
        If DoScans(0, x) = 1 Then OKProg(x) = 1
    Next x
    WinX = Win
    'Dim MinS As Long
    
    If CircularFlag = 0 Then
        
        MinPos = XOverWindowX
    Else
        
        MinPos = 1
    End If
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    b = 0
    C = 0
    Dim PNA As Double
   ' If PermNum < 10000 Then
       PNA = 1
   ' Else
   '     PNA = PermNum / 10000
   ' End If
    
    
'    'get the likelihood distributions for bps for each event
'    Dim oEditSeqFlag As Long, oRelX As Long, oRelY As Long
'    ReDim BPProbDist(GCDimSize * 2, SEventNumber)
'    oRelX = RelX
'    oRelY = RelY
'    oEditSeqFlag = EditSeqFlag
'    EditSeqFlag = 0
'    For X = SEventNumber To 1 Step -1
'        If Excl(X) = 1 Then
'            Bx = BestEvent(X, 0)
'            By = BestEvent(X, 1)
'            BPProbDistFlag = 1: BPProbDistSE = X
'            RelX = Bx
'            RelY = By
'            Call ModSeqNum(XOverlist(RelX, RelY).Beginning, XOverlist(RelX, RelY).Ending, 0)
'
'
'            Call BenHMM2(3, XOverlist(Bx, By).Daughter, XOverlist(Bx, By).MajorP, XOverlist(Bx, By).MinorP)
'            Call UnModNextno
'            Call UnModSeqNum(0)
'            BPProbDistFlag = 0: BPProbDistSE = -1
'        End If
'    Next X
'    RelX = oRelX
'    RelY = oRelY
'    EditSeqFlag = oEditSeqFlag
    
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 500000000
    Dim NPX As Long
    If ORFFlag = 1 Then
        If (Len(StrainSeq(0)) * CLng(PermNum / PNA)) > APhys / 16 Then
            
            
            NPX = CLng(PermNum / ((Len(StrainSeq(0)) * CLng(PermNum / PNA)) / (APhys / 16)))
            
            MsgBox ("There is insufficient available memory to run this analysis with " + Trim(Str(PermNum)) + " permutations.  I will use " + Trim(Str(NPX)) + " permutations (the maximum possible) instead.")
            PermNum = NPX
        End If
    Else
        If (Len(StrainSeq(0)) * CLng(PermNum / PNA)) > APhys / 15 Then
            
            
            NPX = CLng(PermNum / ((Len(StrainSeq(0)) * CLng(PermNum / PNA)) / (APhys / 16)))
            
            MsgBox ("There is insufficient available memory to run this analysis with " + Trim(Str(PermNum)) + " permutations.  I will use " + Trim(Str(NPX)) + " permutations (the maximum possible) instead.")
            PermNum = NPX
        End If
    End If
    
    ReDim MaP(Len(StrainSeq(0)), CLng(PermNum / PNA)), MaxVals(1, CLng(PermNum / PNA))
    
    Rnd (-BSRndNumSeed)
    SS = Abs(GetTickCount)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200)
    
    'ExRecFlag = 0
    
    If ORFFlag = 1 Then
        GlobalMemoryStatus MemSit
        ReDim MapORF(Len(StrainSeq(0)), CLng(PermNum / PNA))
        ReDim MapIR(Len(StrainSeq(0)), CLng(PermNum / PNA))
        Dim GeneMap() As Byte, TestName() As String, LenMap() As Long
        ReDim GeneMap(Len(StrainSeq(0)), GeneNumber * 4), TestName(GeneNumber + 3)
        ReDim LenMap(GeneNumber + 3)
        Y = 0
        For x = 1 To GeneNumber
            ST = GeneList(x).StartInAlign
            EN = GeneList(x).EndInAlign
            EX = GeneList(x).ExonNumber
            
            ORIx = GeneList(x).Orientation
            
            If EX = 1 Or EX = 0 Then
                Y = x 'Y = Y + 1 - it seemed to me that makining y=y+1 could cause problems
                
                Dim PString As String
                PString = GeneList(x).Product
                If PString <> "" And Len(PString) > 40 Then
                    Pos = InStr(1, PString, "protein", vbTextCompare)
                    'If Pos = 0 Then
                    
                    Pos2 = InStr(1, PString, "peptide", vbTextCompare)
                    Pos3 = InStr(1, PString, "subunit", vbTextCompare)
                    If Pos = 0 Then
                        Pos = Po2
                    End If
                    If Pos2 > 0 And Pos2 < Pos Then
                        Pos = Pos2
                    End If
                    If Pos3 > 0 And Pos3 < Pos Then
                        Pos = Pos3
                    End If
                    'End If
                    If Pos > 0 Then
                        PString = Left(PString, Pos + 6)
                    Else
                        PString = Left(PString, 40)
                    End If
                End If
                If Len(PString) > 40 Then
                    PString = Left(PString, 40)
                End If
                If PString <> "" And GeneList(x).Name <> "" Then
                    TestName(Y) = GeneList(x).Name + " (" + PString + ") vs rest of ORFs"
                ElseIf PString <> "" Then
                    TestName(Y) = PString + " vs rest of ORFs"
                ElseIf GeneList(x).Name <> "" Then
                    TestName(Y) = GeneList(x).Name + " vs rest of ORFs"
                Else
                    TestName(Y) = "Gene " + Trim(Str(x)) + " vs rest of ORFs"
                End If
                LenMap(Y) = 0
            Else
                Y = x
            End If
            If ORIx = 2 Then
                Tmp = ST
                ST = EN
                EN = Tmp
            End If
            If ST < EN Then
                For Z = ST To EN
                    GeneMap(Z, Y) = 1
                    GeneMap(Z, 0) = 1
                    'For aa = 0 To Nextno
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(Y) = LenMap(Y) + 1
                    
                    End If
                   ' XX = GeneMap(4, 0)
                Next Z
                x = x
            Else
                
                For Z = ST To Len(StrainSeq(0))
                    GeneMap(Z, x) = 1
                    GeneMap(Z, 0) = 1
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(x) = LenMap(x) + 1
                    End If
                Next Z
                For Z = 1 To EN
                    GeneMap(Z, Y) = 1
                    GeneMap(Z, 0) = 1
                    If SeqNum(Z, TypeSeqNumber) <> 46 Then
                        LenMap(x) = LenMap(x) + 1
                    End If
                Next Z
                
            End If
        Next x
        TestName(GeneNumber + 1) = "End 50% vs Middle 50%"
        TestName(GeneNumber + 2) = "End 25% vs Middle 75%"
        TestName(GeneNumber + 3) = "End 10% vs Middle 90%"
        Dim COffs(3) As Long
        If x = x Then
            For x = 1 To GeneNumber
                'If X >= 8 Then
                '    X = X
                'End If
                If LenMap(x) > 0 Then
                    COffs(0) = CLng(LenMap(x)) / 4
                    COffs(1) = CLng(LenMap(x)) / 8
                    COffs(2) = CLng(LenMap(x)) / 20
                    
                End If
                C = 0
                For Y = 1 To Len(StrainSeq(0))
                    If GeneMap(Y, x) = 1 Then
                        If SeqNum(Y, 0) <> 46 Then
                            C = C + 1
                        End If
                        If C <= COffs(0) Then
                            GeneMap(Y, x + GeneNumber) = 1
                        End If
                        If C <= COffs(1) Then
                            GeneMap(Y, x + GeneNumber * 2) = 1
                        End If
                        If C <= COffs(2) Then
                            GeneMap(Y, x + GeneNumber * 3) = 1
                        End If
                    End If
                Next Y
                C = 0
                For Y = Len(StrainSeq(0)) To 1 Step -1
                    If GeneMap(Y, x) = 1 Then
                        If SeqNum(Y, 0) <> 46 Then
                            C = C + 1
                        End If
                        If C <= COffs(0) Then
                            GeneMap(Y, x + GeneNumber) = 1
                        End If
                        If C <= COffs(1) Then
                            GeneMap(Y, x + GeneNumber * 2) = 1
                        End If
                        If C <= COffs(2) Then
                            GeneMap(Y, x + GeneNumber * 3) = 1
                        End If
                    End If
                Next Y
            Next x
        Else
            ReDim RefSpaces(Len(StrainSeq(0)))
            'use this to manipulate which sites get tested in the "gene" analyses - I used this to test low shape reactivity-bp association in  the junction sites
            If GeneNumber > 3 And x = 1234567890 Then ' only allow this to be executed under very special conditions
                Dim Inscore As Long, OutScore As Long
                For x = 0 To GeneNumber
                     For Y = 0 To Len(StrainSeq(0))
                        GeneMap(Y, x) = 0
                    Next Y
                Next x
                Inscore = 0
                OutScore = 0
                'this is test for the junction regions
                For x = 1 To GeneNumber
                    ST = GeneList(x).StartInAlign
                    EN = GeneList(x).EndInAlign
                    
                   
                    If ST < EN Then
                        For Y = ST To EN
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                GeneMap(Y, 0) = 1
                                Inscore = Inscore + 1
                                'high structure - high similarity -1673 (0.85), 1230 (0.90), 725 (0.925)
                                'high similarity - junction - 1661 (0.85),  860 (0.90), 378 (0.925)
                            Else
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                GeneMap(Y, 0) = 1
                                'low structure - high similarity -6781 (0.85), 4149 (0.90), 2048 (0.925)
                                'low similarity - junction - 370 (0.85),  1171 (0.90), 1653 (0.925)
                            End If
                        Next Y
                    End If
                Next x
                
                x = x
                'Exit Sub
                If x = 12345 Then  'test of non junction sites
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        If GeneMap(Y, 0) = 1 Then
                            GeneMap(Y, 0) = 0
                        Else
                            GeneMap(Y, 0) = 1
                        End If
                        If GeneMap(Y, 1) = 1 Or GeneMap(Y, 2) = 1 Then
                            GeneMap(Y, 1) = 0
                            GeneMap(Y, 2) = 0
                        Else
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                Inscore = Inscore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90), 1031 (0.925)
                                'high similarity - ROG - 6714 (0.85), 4378 (0.90),  2285(0.925)
                            Else
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                'low structure - low similarity - 1019 (0.85), 3651 (0.90), 5752 (0.925)
                                'low similarity - ROG - 812 (0.85), 3148 (0.90), 5241 (0.925)
                            End If
                        End If
                    Next Y
                    x = x
                    'Exit Sub
                ElseIf x = 12345 Then 'test of juncrtion high structure against non-junction high structure
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 0) = 1
                            Inscore = Inscore + 1
                            'high structure - high similarity - 1673 (0.85), 1230 (0.90), 725 (0.925)
                            'high similarity - junction - 1660 (0.85), 860 (0.90), 378 (0.925)
                        ElseIf GeneMap(Y, 2) = 1 Then
                        
                            GeneMap(Y, 2) = 0
                            GeneMap(Y, 0) = 0
                        Else
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 2) = 1
                                OutScore = OutScore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90),1031 (0.925)
                                'high similarity - ROG 6714 (0.85), 4378 (0.90), 2285 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                        End If
                    Next Y
                    x = x
                    'Exit Sub
                ElseIf x = 12345 Then 'test the junction low structure with the non-junction lowstructure
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 2) = 1 Then
                            GeneMap(Y, 0) = 1
                            Inscore = Inscore + 1
                            'low structure - high similarity  6781 (0.85), 4149(0.90), 2048 (0.925)
                            'low similarity - junction - 370 (0.85), 1170(0.90), 1652 (0.925)
                        ElseIf GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 1) = 0
                            GeneMap(Y, 0) = 0
                        Else
                            If SHAPEScores(APos(Y)) >= SHAPECO Then
                                GeneMap(Y, 1) = 1
                                OutScore = OutScore + 1
                                'low structure - lowsimilarity - 1019 (0.85), 3651 (0.90), 5752 (0.925)
                                'low similarity - rog - 812 (0.85), 3148 (0.90), 5241 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                            
                            'total:7800 low structure sites split between high and low similarity
                        End If
                    Next Y
                    x = x
                    For Y = 1 To Len(StrainSeq(0))
                        Temp = GeneMap(Y, 1)
                        GeneMap(Y, 1) = GeneMap(Y, 2)
                        GeneMap(Y, 2) = Temp
                    Next Y
                   
                ElseIf x = 1234 Then 'test of junction sites that are above the sahpe cutoff gaainst non-junction sites that are below the shape cutoff
                    Inscore = 0
                    OutScore = 0
                    For Y = 1 To Len(StrainSeq(0))
                        GeneMap(Y, 0) = 0
                            
                        If GeneMap(Y, 1) = 1 Then
                            GeneMap(Y, 0) = 0
                            GeneMap(Y, 1) = 0
                        ElseIf GeneMap(Y, 2) = 1 Then 'i.e. junction sites that are above the shape cutoff
                            Inscore = Inscore + 1
                            'low structure - high similarity - 6781 (0.85), 4149 (0.90), 2048 (0.925)
                            'low similarity - junction 370 (0.85),  1170(0.90), 1652 (0.925)
                            GeneMap(Y, 0) = 1
                        Else 'ie non-junction sites
                            If SHAPEScores(APos(Y)) < SHAPECO Then
                                GeneMap(Y, 1) = 1
                                OutScore = OutScore + 1
                                'high structure - low similarity - 83 (0.85), 526 (0.90), 1031 (0.925)
                                'high similarity - ROG 6714 (0.85), 4378 (0.90), 2285 (0.925)
                                GeneMap(Y, 0) = 1
                            
                            End If
                        End If
                       
                    Next Y
                    x = x
                     For Y = 1 To Len(StrainSeq(0))
                        Temp = GeneMap(Y, 1)
                        GeneMap(Y, 1) = GeneMap(Y, 2)
                        GeneMap(Y, 2) = Temp
                    Next Y
                      'Exit Sub
                End If
                
                Open "sitenums.csv" For Append As #22
                    Print #22, Str(Inscore) + "," + Str(OutScore)
                Close #22
                x = x
            End If
        End If
        
        
    End If
    
   
    
    Dim ModnumX() As Double, ModnumY() As Double
    ReDim ModnumX(NextNo), ModnumY(Len(StrainSeq(0)))
    
    If x = x Then
        
        For x = 0 To NextNo
            If InStr(1, OriginalName(x), "parent", vbTextCompare) > 0 Then
                
                    For Y = 1 To Len(StrainSeq(0))
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            ST = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = Len(StrainSeq(0)) To 1 Step -1
                        
                        If SeqNum(Y, x) > 46 Or SeqNum(Y, x + 1) > 46 Then
                            EN = Y: Exit For
                            
                        End If
                    Next Y
                    For Y = ST To EN
                        
                        ModnumY(Y) = ModnumY(Y) + 1
                        
                    Next Y
                    x = x + 1
            End If
        Next x
        
        
        For x = 0 To NextNo
            'pair_00-85_461A-210C    0,0739
            
            'pair_00-85_859A-914G    0,0654
            'pair_Heather_A115-D89   0,1000
            'pair_Heather_A115-D126  0,0380
            'pair_Heather_A120-D89   0,0440
            'pair_Heather_D126-A120  0,0480
            'pair_90-35_899-122  0,0591
            'pair_90-35_905A-858G    0,0617
            'pair_140-35_461A-210C   0,0568
            'pair_140-35_461A-1033G  0,0617
            'pair_140-35_461A-2116D  0,0573
            'pair_140-35_914-899     0,0620
            'pair_140-35_O5-914G     0,0216
            'pair_140-35_O5-O2   0,0596
            'pair_140-03_899-914     0,0990
            'pair_EPRRE-03_899A-122D     0,0526
            
            'pair_00-85_461A-1033G   0,0761
            If InStr(1, OriginalName(x), "AG00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7610 / 20)
            ElseIf InStr(1, OriginalName(x), "AC00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(7390 / 22)
            ElseIf InStr(1, OriginalName(x), "859A-914G00-85", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6540 / 15)
            ElseIf InStr(1, OriginalName(x), "D126-A120", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4800 / 43)
            ElseIf InStr(1, OriginalName(x), "A120-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(4400 / 21)
            ElseIf InStr(1, OriginalName(x), "A115-D89", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(10000 / 20)
            ElseIf InStr(1, OriginalName(x), "A115-D126", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(3800 / 20)
            ElseIf InStr(1, OriginalName(x), "A905-G858", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 38)
            ElseIf InStr(1, OriginalName(x), "899A-122D", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5910 / 33)
            ElseIf InStr(1, OriginalName(x), "O32-O35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5960 / 24)
            ElseIf InStr(1, OriginalName(x), "G914-O32", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(2160 / 18)
            ElseIf InStr(1, OriginalName(x), "AG140-35b", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5730 / 25)
            ElseIf InStr(1, OriginalName(x), "AC140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5680 / 26)
            ElseIf InStr(1, OriginalName(x), "AG140-35", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6170 / 26)
            ElseIf InStr(1, OriginalName(x), "A899-G914", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(9900 / 24)
            ElseIf InStr(1, OriginalName(x), "914G-899A", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(6200 / 24)
            ElseIf InStr(1, OriginalName(x), "A899-D122", vbTextCompare) > 0 Then
                ModnumX(x) = CLng(5260 / 14)
            Else
                ModnumX(x) = 1
            End If
            
            
        Next x
        x = x
    Else
        For x = 0 To NextNo
            ModnumX(x) = 1
            
        Next x
        For Y = 1 To Len(StrainSeq(0))
            ModnumY(Y) = 1
        Next Y
    End If
    
    Dim RealTX As Long, PermTX As Long
    RealTX = 0: PermTX = 0
    
    
    If MultBPFlag = 1 Then
        'sort out plant numbers
        Dim TraceHost() As Long, KeepTrack As Long
        Call GetPlantNums(KeepTrack, TraceHost())
        
        Dim IntervalMap() As Long, CountPos As Long
        Call MakeIntervalMap(CountPos, IntervalMap())
        Dim DoneMap() As Byte, DoneMap2() As Byte
        If SHAPEFlag = 1 Then
            
            
            'this averages out the shape scores over regions
            Dim AvSite(), TotSite()
            ReDim AvSite(CountPos), TotSite(CountPos)
            For x = 1 To Len(StrainSeq(0))
                MapPos = IntervalMap(x)
                'CurHost = TraceHost(D)
                AvSite(MapPos) = AvSite(MapPos) + SHAPEScores(x)
                TotSite(MapPos) = TotSite(MapPos) + 1
            Next x
            For x = 0 To CountPos
                AvSite(x) = AvSite(x) / TotSite(x)
                x = x
            Next x
            For x = 1 To Len(StrainSeq(0))
            'If X = Len(StrainSeq(0)) - 23 Then
            '    X = X
            'End If
            
                MapPos = IntervalMap(x)
                'CurHost = TraceHost(D)
                SHAPEScores(x) = AvSite(MapPos)
            Next x
        End If
        
    End If
    
    
    If SHAPEFlag = 1 Then
    
        Dim PolarityFlag As Byte
        Dim SHAPEScore() As Double
        ReDim SHAPEScore(PermNum)
        ReDim DoneMap(CountPos, KeepTrack)
        PolarityFlag = 0
        For x = 1 To Len(StrainSeq(0))
        
            If SHAPEScores(x) < 0 Then PolarityFlag = 1: Exit For
                
           
        Next x
        
        
        For x = 1 To ENumb
            
            
            If Excl(x) = 1 Then
                
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
                    
                    D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                    P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                    P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    SBF = XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag
                    
                    
                    
                    If ExRecFlag = 1 Then
                        GoOn = 0
                        If MultBPFlag = 1 Then
                            MapPos = IntervalMap(ST)
                            CurHost = TraceHost(D)
                            If DoneMap(MapPos, CurHost) = 0 Then
                                DoneMap(MapPos, CurHost) = 1
                               
                                GoOn = 1
                            End If
                        Else
                            GoOn = 1
                        End If
                        If GoOn = 1 Then
                            'S = APos(ST)
                            S = ST
                            If PolarityFlag = 0 Then
                                SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                                RealTX = RealTX + 1
                            Else
                                If P2 = 0 Then ' on the left of the BP is p2 and on the right is p1
                                    SHAPEScore(0) = SHAPEScore(0) - SHAPEScores(S)
                                    RealTX = RealTX + 1
                                Else ' on the left of the BP is p1 and on the right is p2
                                    SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                                    RealTX = RealTX + 1
                                End If
                                
                            End If
                        End If
                    Else
                        If SBF <> 3 And SBF <> 1 Then
                            'S = APos(ST)
                            S = ST
                            SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(S)
                            RealTX = RealTX + 1
                        Else
                            x = x
                        End If
                        If SBF <> 3 And SBF <> 2 Then
                            'E = APos(EN)
                            e = EN
                            SHAPEScore(0) = SHAPEScore(0) + SHAPEScores(e)
                            RealTX = RealTX + 1
                        Else
                            x = x
                        End If
                    End If
                End If
            End If
        Next x
    End If
    AAA = Abs(GetTickCount)
    
    
    Dim BEX0 As Long, BEX1 As Long
    
    
    For A = 1 To PermNum
    
        If MultBPFlag = 1 Then
            ReDim DoneMap(CountPos, KeepTrack)
            ReDim DoneMap2(CountPos, KeepTrack)
        End If
        TSX = 0
        PermTX = 0
        ReDim tSeqnum(Len(StrainSeq(0)), NextNo)
        
        If ORFFlag = 1 Then
            ReDim tSeqNumORF(Len(StrainSeq(0)), NextNo)
            
        End If
        If CircularFlag = 0 Then
            For x = 0 To NextNo
            '    For Y = 1 To Len(StrainSeq(0))
                   tSeqnum(1, x) = 1
                   tSeqnum(Len(StrainSeq(0)), x) = 1
            '    Next Y
            Next x
            If ORFFlag = 1 Then
                For x = 0 To NextNo
                '    For Y = 1 To Len(StrainSeq(0))
                       tSeqNumORF(1, x) = 1
                       tSeqNumORF(Len(StrainSeq(0)), x) = 1
                '    Next Y
                Next x
            End If
        End If
        ZZZ = 0
        ggg = 0
        aaaa = 0
        onum = 0
        Dim Par1 As Long, Pasr2 As Long
        For x = 1 To ENumb
            BEX0 = BestEvent(x, 0)
            BEX1 = BestEvent(x, 1)
            
            If Excl(x) = 1 Then
                
                If (BEX0 > 0 Or BEX1 > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BEX0, BEX1).Eventnumber)
                    
                    D = XoverList(BEX0, BEX1).Daughter
                    P1 = XoverList(BEX0, BEX1).MajorP
                    P2 = XoverList(BEX0, BEX1).MinorP
                    ST = XoverList(BEX0, BEX1).Beginning
                    EN = XoverList(BEX0, BEX1).Ending
                    SBF = XoverList(BEX0, BEX1).SBPFlag
                    
                    
                    'pair_00-85_461A-210C    0,0739
                    'pair_00-85_461A-1033G   0,0761
                    'pair_00-85_859A-914G    0,0654
                    'pair_Heather_A115-D89   0,1000
                    'pair_Heather_A115-D126  0,0380
                    'pair_Heather_A120-D89   0,0440
                    'pair_Heather_D126-A120  0,0480
                    'pair_90-35_899-122  0,0591
                    'pair_90-35_905A-858G    0,0617
                    'pair_140-35_461A-210C   0,0568
                    'pair_140-35_461A-1033G  0,0617
                    'pair_140-35_461A-2116D  0,0573
                    'pair_140-35_914-899     0,0620
                    'pair_140-35_O5-914G     0,0216
                    'pair_140-35_O5-O2   0,0596
                    'pair_140-03_899-914     0,0990
                    'pair_EPRRE-03_899A-122D     0,0526
                    
                    
                    If ExRecFlag = 1 Then
                        If TraceHost(D) > 0 Then
'                            If Chimaeraflag = 1 Then
'                               Par1 = RefChimaera(PermPlantNum(D), 0)
'                               Par2 = RefChimaera(PermPlantNum(D), 1)
'                            Else
'                               Par1 = ParentSeqs(0)
'                               Par2 = ParentSeqs(1)
'                            End If
                            GoOn = 0
                            If MultBPFlag = 1 Then
                                MapPos = IntervalMap(ST)
                                CurHost = TraceHost(D)
                                
                                If DoneMap(MapPos, CurHost) = 0 Then
                                    DoneMap(MapPos, CurHost) = 1
                                    GoOn = 1
                                End If
                            Else
                                GoOn = 1
                            End If
                            If GoOn = 1 Then
                                Do
                                    NewStart = Int((Len(StrainSeq(0)) * Rnd) + 1)
                                    GoOn = 0
                                    If SeqNum(NewStart, P1) = SeqNum(NewStart, P2) And SeqNum(NewStart, P1) > 46 And SeqNum(NewStart, P2) > 46 Then
                                        GoOn = 0
                                        If NewStart > 1 Then
                                            For ZZ = NewStart - 1 To 1 Step -1
                                                If SeqNum(ZZ, P1) <> SeqNum(ZZ, P2) Then
                                                    GoOn = 1
                                                    Exit For
                                                End If
                                            Next ZZ
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If NewStart < Len(StrainSeq(0)) Then
                                                    For ZZ = NewStart + 1 To Len(StrainSeq(0))
                                                        If SeqNum(ZZ, P1) <> SeqNum(ZZ, P2) Then
                                                            GoOn = 1
                                                            Exit For
                                                        End If
                                                    Next ZZ
                                                End If
                                            End If
                                            If GoOn = 1 Then
                                                If MultBPFlag = 1 Then
                                                    GoOn = 0
                                                    MapPos = IntervalMap(NewStart)
                                                    CurHost = TraceHost(D)
                                                    If DoneMap2(MapPos, CurHost) = 0 Then
                                                        DoneMap2(MapPos, CurHost) = 1
                                                        GoOn = 1
                                                    End If
                                                    
                                                End If
                                            
                                            End If
                                            
                                            
                                        End If
                                        
                                    End If
                                    If GoOn = 1 Then Exit Do
                                Loop
                                
                                
                                aaaa = aaaa + 1
                                
                                If ModnumX(D) <> 1 Then
                                    For Z = 1 To ModnumX(D)
                                        
                                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                        '''''''''need to change this bit if i want to use probability distributions rather than
                                        '''''''''discrete breakpoint sites
                                        '''''''''note this also does the 50 or whatever window
                                        '''''''''I would ideally want to add distributions and then do the window later
                                        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                        If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                            Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                        Else
                                            Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                        End If
                                    Next Z
                                Else
                                        
                                        
                                        
                                        If x = x Then
                                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                            Else
                                                Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                            End If
                                            
                                        Else
                                        
                                            If SBF <> 3 Then
                                                If SBF <> 1 Then
                                                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                        Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                    Else
                                                        Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                                    End If
                                                    ZZZ = ZZZ + 1
                                                End If
                                                If SBF <> 2 Then
                                                    If ST < EN Then
                                                        NewStart = NewStart + (EN - ST)
                                                    Else
                                                        NewStart = NewStart + EN + (Len(StrainSeq(0)) - ST)
                                                    End If
                                                    If NewStart > Len(StrainSeq(0)) Then NewStart = NewStart - Len(StrainSeq(0))
                                                    If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                        Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                    Else
                                                        Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                                                    End If
                                                    ZZZ = ZZZ + 1
                                                End If
                                            End If
                                        End If
                                End If
                                If ORFFlag = 1 Then
                                    MapIR(NewStart, CLng(A / PNA)) = MapIR(NewStart, CLng(A / PNA)) + 1
                                
                                    If (GeneMap(ST, 0) = 1 Or GeneMap(EN, 0) = 1) Then 'do tests to see if some orfs have higher rates than ohers
                                        LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                            
                                        If EN > ST Then
                                            RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                                        Else
                                            RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                                        End If
                                        If CircularFlag = 0 Then
                                            MaxS = LSSeq - RecSize - XoverWindow
                                        Else
                                            MaxS = LSSeq
                                        End If
                                        If CircularFlag = 0 Then
                                            MaxS = LSSeq - RecSize - XoverWindow
                                        Else
                                            MaxS = LSSeq
                                        End If
                                        CycleNo = 0
                                        Do
                                            NewStart = Int((MaxS * Rnd) + 1)
                                            GoOn = 0
                                            If NewStart >= MinPos Or SBF = 1 Or SBF = 3 Then
                                                GoOn = 1
                                            End If
                                            
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                                    GoOn = 1
                                                End If
                                            End If
                                            If GoOn = 1 Then
                                                
                                                GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqNumORF(0, 0), NS, NE, XDiffPos(0))
                                                If GoOn = 1 Then
                                                    GoOn = 0
                                                    If GeneMap(NS, 0) = GeneMap(ST, 0) Or (SBF = 1 Or SBF = 3) Then
                                                        GoOn = 1
                                                    End If
                                                    If GoOn = 1 Then
                                                        GoOn = 0
                                                        If GeneMap(NE, 0) = GeneMap(EN, 0) Or (SBF = 2 Or SBF = 3) Then
                                            
                                                            GoOn = 1
                                                        End If
                                                    End If
                                                    If GoOn = 1 Then Exit Do
                                                End If
                                                CycleNo = CycleNo + 1
                                                If CycleNo > MaxCycleNo Then
                                                    x = x
                                                    XX = A
                                                    Exit Do
                                                End If
                                            End If
                                        Loop
                                        OffsetY = NS - ST
                                        If SBF <> 3 Then
                                        
                                            For D = 0 To 1
                                                GoOn = 0
                                                If D = 0 Then
                                                    
                                                    If SBF <> 1 And GeneMap(ST, 0) = 1 Then
                                                        
                                                        S = NS: GoOn = 1
                                                       
                                                    End If
                                                Else
                                                    If SBF <> 2 And GeneMap(EN, 0) = 1 Then
                                                        S = NE: GoOn = 1
                                                    End If
                                                End If
                                            
                                                If GoOn = 1 Then
                                                    
                                                    'Dummy = AddToMap(CLng(A / PNA), S, 1, Len(StrainSeq(0)), APos(0), MapORF(0, 0))
                                                    onum = onum + 1
                                                    
                                                    
                                                    MapORF(S, CLng(A / PNA)) = MapORF(S, CLng(A / PNA)) + 1
                                                End If
                                            Next D
                                        
                                        End If
                                        
                                        'check the start
                                        
                                        'check the end
                                        
                                    End If
                                
                                End If
                                If SHAPEFlag = 1 Then
                                    'S = APos(NewStart)
                                    If PolarityFlag = 0 Then
                                        'TSX = TSX + SHAPEScores(APos(EN))
                                        TSX = TSX + SHAPEScores(EN)
                                        'SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(APos(NewStart))
                                        SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(NewStart)
                                        PermTX = PermTX + 1
                                    Else
                                        If P2 = 0 Then
                                            'TSX = TSX + SHAPEScores(APos(EN))
                                            TSX = TSX + SHAPEScores(EN)
                                            'SHAPEScore(A) = SHAPEScore(A) - SHAPEScores(APos(NewStart))
                                            SHAPEScore(A) = SHAPEScore(A) - SHAPEScores(NewStart)
                                            PermTX = PermTX + 1
                                        Else
                                            'TSX = TSX + SHAPEScores(APos(EN))
                                            TSX = TSX + SHAPEScores(EN)
                                            'SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(APos(NewStart))
                                            SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(NewStart)
                                            PermTX = PermTX + 1
                                        End If
                                    
                                    End If
                                End If
                            End If
                        End If
                    ElseIf ExRecFlag = 2 Then
                        
                            NewStart = Int(((Len(StrainSeq(0)) - 96) * Rnd) + 1) + 48
                            
                        For Z = 1 To ModnumX(D)
                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                Dummy = AddToMap(CLng(A / PNA), APos(NewStart), Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                            Else
                                Call AddToMapVB(CLng(A / PNA), Decompress(NewStart), Win, MaP())
                            End If
                        Next Z
                    Else
                        'Make variable sites array
                        
                       
                        
                        LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                        
                        If EN > ST Then
                            RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                        Else
                            RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                        End If
                        If CircularFlag = 0 Then
                            MaxS = LSSeq - RecSize - XoverWindow
                        Else
                            MaxS = LSSeq
                        End If
                        
                        'Make new ending and start for this event
                    
                        'For A = 1 To PermNum
                            MaxCycleNo = LSSeq * 5
                            CycleNo = 0
                            If MaxS <= MinPos Then
                                MaxS = MinPos
                            End If
                            'set up exceptions for single bp recombinants (possible with linear sequences but not with circular ones)
                            Dim EFX As Byte
                            EFX = 0
                            If CircularFlag = 0 Then
                                If SBF = 1 And XPosDiff(ST) < 10 Then
                                    EFX = 1
                                ElseIf SBF = 2 And XPosDiff(EN) > LSSeq - 10 Then
                                    EFX = 2
                                End If
                            End If
                            
                            Do
                                
                                
                                If EFX > 0 Then 'if the breakpoint is close to the ends of the sequence
                                
                                    NewStart = Int(((LSSeq) * Rnd) + 1)
                                    If LSSeq - NewStart > MinPos And NewStart > MinPos Then
                                        If EFX = 1 Then
                                            NS = 1
                                        Else
                                            NS = XDiffPos(NewStart)
                                        End If
                                        If EFX = 2 Then
                                            NE = Len(StrainSeq(0))
                                        Else
                                            NE = Len(StrainSeq(0)) - XDiffPos(NewStart)
                                        End If
                                        Exit Do
                                    Else
                                        x = x
                                    End If
                                    CycleNo = CycleNo + 1
                                    If CycleNo > MaxCycleNo Then Exit Do
                                 '   RecSize = LSSeq - NewStart
                                 '   If NewStart < RecSize Then RecSize = NewStart
                                 '   GoOn = CheckBPOL(Len(StrainSeq(0)), d, LSSeq, NewStart, RecSize, tSeqNum(0, 0), NS, NE, XDiffpos(0))
                                 '   If GoOn = 1 Then Exit Do
                                Else
                                
                                    NewStart = Int((MaxS * Rnd) + 1)
                                    GoOn = 0
                                    
                                    If NewStart >= MinPos Or SBF = 1 Or SBF = 3 Then
                                        
                                        GoOn = 1
                                    End If
                                    
                                    If GoOn = 1 Then
                                    
                                        GoOn = 0
                                        If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                    End If
                                    If GoOn = 1 Then
                                        
                                        GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqnum(0, 0), NS, NE, XDiffPos(0))
                                        
                                        If GoOn = 1 Then Exit Do
                                        CycleNo = CycleNo + 1
                                        If CycleNo > MaxCycleNo Then Exit Do
                                    End If
                                End If
                            Loop
                            OffsetX = NS - ST
                            
                            If SBF <> 3 Then
                                
                                    For D = 0 To 1
                                        GoOn = 0
                                        If D = 0 Then
                                            
                                            If SBF <> 1 Then
                                                
                                                S = APos(NS): OS = NS: GoOn = 1
                                               
                                                
                                            
                                            End If
                                        Else
                                            If SBF <> 2 Then
                                                S = APos(NE): OS = NE: GoOn = 1
                                            End If
                                        End If
                                    
                                        If GoOn = 1 Then
                                        '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                        '''''''''need to change this bit if i want to use probability distributions rather than
                                        '''''''''discrete breakpoint sites
                                        '''''''''note this also does the 50 or whatever window
                                        '''''''''I would ideally want to add distributions and then do the window later
                                        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                                        'Call MakeSMap(APos(), tSeqNum(), ST, NewStart, A, MapS(), BPProbDist(), D, P1, P2) 'A=the permutation number; ST = oldstart
                                            ZZZ = ZZZ + 1
                                            If Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) Then
                                                Dummy = AddToMap(CLng(A / PNA), S, Win, Len(StrainSeq(0)), APos(0), MaP(0, 0))
                                                
                                            Else
                                                Call AddToMapVB(CLng(A / PNA), Decompress(S), Win, MaP())
                                            End If
                                            If ORFFlag = 1 Then
                                                'If SHAPEFlag = 0 Or (SHAPEFlag = 1 And SHAPEScore(A) < SHAPECO) Then
                                                    MapIR(OS, CLng(A / PNA)) = MapIR(OS, CLng(A / PNA)) + 1
                                                'End If
                                            End If
                                            If SHAPEFlag = 1 Then
                                                SHAPEScore(A) = SHAPEScore(A) + SHAPEScores(S)
                                                
                                                
                                                PermTX = PermTX + 1
                                            End If
                                            
                                        End If
                                    Next D
                                
                            End If
                            
                            
                            
                            
                            If ORFFlag = 1 Then
                                If (GeneMap(ST, 0) = 1 Or GeneMap(EN, 0) = 1) Then 'do tests to see if some orfs have higher rates than ohers
                                    CycleNo = 0
                                    Do
                                        NewStart = Int((MaxS * Rnd) + 1)
                                        
                                        GoOn = 0
                                        If NewStart >= MinPos Or SBF = 1 Or SBF = 3 Then
                                            GoOn = 1
                                        End If
                                        
                                        If GoOn = 1 Then
                                            GoOn = 0
                                            If NewStart <= MaxS Or SBF = 2 Or SBF = 3 Then
                                                GoOn = 1
                                                
                                            End If
                                        End If
                                        If GoOn = 1 Then
                                            
                                            GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqNumORF(0, 0), NS, NE, XDiffPos(0))
                                            
                                            If GoOn = 1 Then
                                                GoOn = 0
                                                If GeneMap(NS, 0) = GeneMap(ST, 0) Or (SBF = 1 Or SBF = 3) Then
                                                    GoOn = 1
                                                End If
                                                If GoOn = 1 Then
                                                    GoOn = 0
                                                    If GeneMap(NE, 0) = GeneMap(EN, 0) Or (SBF = 2 Or SBF = 3) Then
                                        
                                                        GoOn = 1
                                                        
                                                    End If
                                                End If
                                                If GoOn = 1 Then Exit Do
                                                
                                            End If
                                            CycleNo = CycleNo + 1
                                            If CycleNo > MaxCycleNo Then
                                                x = x
                                                XX = A
                                                Exit Do
                                            End If
                                        End If
                                    Loop
                                    OffsetY = NS - ST
                                    If SBF <> 3 Then
                                    
                                        For D = 0 To 1
                                            GoOn = 0
                                            If D = 0 Then
                                                
                                                If SBF <> 1 And GeneMap(ST, 0) = 1 Then
                                                    
                                                    S = NS: GoOn = 1
                                                   
                                                End If
                                            Else
                                                If SBF <> 2 And GeneMap(EN, 0) = 1 Then
                                                    S = NE: GoOn = 1
                                                End If
                                            End If
                                        
                                            If GoOn = 1 Then
                                                
                                                'Dummy = AddToMap(CLng(A / PNA), S, 1, Len(StrainSeq(0)), APos(0), MapORF(0, 0))
                                                onum = onum + 1
                                                
                                                
                                                MapORF(S, CLng(A / PNA)) = MapORF(S, CLng(A / PNA)) + 1
                                            End If
                                        Next D
                                    
                                    End If
                                    
                                    'check the start
                                    
                                    'check the end
                                    
                                End If
                            
                            End If
                            
                         'Next A
                    
                    End If
                    
                    
                    If ExRecFlag = 1 And ORFFlag = 0 Then
                        'tSeqNum(NewStart, Z) = 1
                    Else
                        'ReDim BestP(1, NextNo), BreakPos(1, 1, NextNo)
                        
                        'mark BPs for all the other events
                        'For Y = 1 To SEventNumber
                            SPS = ST + OffsetX
                            EPS = EN + OffsetX
                            If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                            If SPS > Len(StrainSeq(0)) - 2 Then SPS = SPS - (Len(StrainSeq(0)) - 2)
                            If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                            If EPS > Len(StrainSeq(0)) - 2 Then EPS = EPS - (Len(StrainSeq(0)) - 2)
                            For Z = 0 To PermNextno
                                If Daught(x, Z) > 0 Then
                                    
                                    tSeqnum(SPS, Z) = 1: tSeqnum(SPS + 1, Z) = 1: tSeqnum(SPS + 2, Z) = 1
                                    tSeqnum(EPS, Z) = 1: tSeqnum(EPS + 1, Z) = 1: tSeqnum(EPS + 2, Z) = 1
                                End If
                            Next Z
                            
                            If ORFFlag = 1 Then
                                SPS = ST + OffsetY
                                EPS = EN + OffsetY
                                If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                                If SPS > Len(StrainSeq(0)) - 2 Then SPS = SPS - (Len(StrainSeq(0)) - 2)
                                If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                                If EPS > Len(StrainSeq(0)) - 2 Then EPS = EPS - (Len(StrainSeq(0)) - 2)
                                For Z = 0 To PermNextno
                                    
                                    If Daught(x, Z) > 0 Then
                                        tSeqnum(SPS, Z) = 1: tSeqnum(SPS + 1, Z) = 1: tSeqnum(SPS + 2, Z) = 1
                                        tSeqnum(EPS, Z) = 1: tSeqnum(EPS + 1, Z) = 1: tSeqnum(EPS + 2, Z) = 1
                                    End If
                                Next Z
                            
                            End If
                            
                        'Next Y
                    End If
                    
                    
                End If
            End If
        Next x
        ET = Abs(GetTickCount)
        If Abs(ET - LT) > 500 Then
            LT = ET
            Form1.SSPanel1.Caption = Str(A) + " of" + Str(PermNum) + " permutations completed"
            Form1.ProgressBar1.Value = (A / PermNum) * 80
            Call UpdateF2Prog
            If A / 10 = CLng(A / 10) Then
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            Else
                Form1.SSPanel1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        End If
        XXX = ZZZ
        x = onum
        XX = PermTX
    Next A
    XX = aaaa '248
    XX = SEventNumber
    EEE = Abs(GetTickCount)
    ttt = EEE - AAA '96.034, 88.172 using sbf'88.203'86.502'85.988 all checkbpol optimizations'46.177 only checking every 3rd site
    
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    End If
    
    
    
    
    Erase tSeqnum
    Erase tSeqNumORF
   If SHAPEFlag = 1 Then
        'count how many are < 0
        Dim NSmaller As Long, SHAPEp As Double
        NSmaller = 0
        For x = 1 To PermNum
            If SHAPEScore(0) > SHAPEScore(x) Then '73.306 -91.123
                NSmaller = NSmaller + 1
            End If
        Next x
        SHAPEp = NSmaller / PermNum '0.055
        XX = 1 - SHAPEp
        XX = PermTX
        If SHAPEp < 0.05 Then
            MsgBox ("There is a detectable association between breakpoint positions and LOWER values of the current siteset (p-val < 0" + Trim(Str((NSmaller + 1) / PermNum)) + ")")
        ElseIf SHAPEp > 0.95 Then
            If 1 - (NSmaller / PermNum) = 0 Then
                MsgBox ("There is a detectable association between breakpoint positions and HIGHER values of the current siteset (p-val < 0" + Trim(Str(1 / PermNum)) + ")")
            Else
                MsgBox ("There is a detectable association between breakpoint positions and HIGHER values of the current siteset (p-val = " + Trim(Str(1 - ((NSmaller) / PermNum))) + ")")
            End If
        Else
            'If SHAPEp <= 0.99 Then
                MsgBox ("There is no detectable association between breakpoint positions and the current siteset (p-val = 0" + Trim(Str((NSmaller + 1) / PermNum)) + ")")
            'Else
            '    MsgBox ("There is no detectable association between breakpoint positions and the current siteset (p-val < 1.0)")
            'End If
        End If
        x = x
        
        'Exit Sub
   End If
    
   For x = 1 To PermNum
        For Y = 1 To Len(StrainSeq(0))
            
            If ModnumY(BPos(Y)) > 0 Then
            
                MaP(Y, x) = CLng(MaP(Y, x) / ModnumY(BPos(Y)))
            Else
                x = x
            End If
        Next Y
   Next x
   Erase ModnumY
    'get maxes
   EE = Abs(GetTickCount)
   TT = EE - SS
   '16.141
   x = x
   'Exit Sub
    'DN = 1
    SS = Abs(GetTickCount)
    If x = x Then
        Dummy = FindMaxMapVal(DN, Len(StrainSeq(0)), CLng(PermNum / PNA), MaxVals(0, 0), MaP(0, 0))
    Else
        For x = 1 To PermNum
            For Y = DN To Len(StrainSeq(0)) - DN + 1
                If MaxVals(0, CLng(x / PNA)) < MaP(Y, CLng(x / PNA)) Then MaxVals(0, CLng(x / PNA)) = MaP(Y, CLng(x / PNA))
               
            Next Y
            x = x '9,8,9,9,8,8,8,12,7,8,8,10,10
        Next x
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS
    '3.194
    'XX = MaxVals(0, 5) '16,16,16,19,20
    SS = Abs(GetTickCount)
    
    'sort through the top 5% and get the 99% and 95% highest scores
    
    
    
    '***************Uncomment for normal function
    Target(1) = CLng(0.05 * PermNum) + 1
    Target(0) = CLng(0.01 * PermNum) + 1
    
    'Target(1) = CLng(0.05 * PermNum) + 1
    'Target(0) = CLng(0.1 * PermNum) + 1
    For Z = 0 To 1
        If Target(Z) < 1 Then Target(Z) = 1
    Next Z
    For Z = 1 To Target(1)
        MaxV(0) = 0
        MaxV(1) = 0
        For x = 0 To PermNum
            If MaxV(0) < MaxVals(0, CLng(x / PNA)) Then
                MaxV(0) = MaxVals(0, CLng(x / PNA))
                MaxP(0) = x
            End If
            If MaxV(1) < MaxVals(1, CLng(x / PNA)) Then
                MaxV(1) = MaxVals(1, CLng(x / PNA))
                MaxP(1) = x
            End If
        Next x
        If Z = Target(0) Then
            CV(0, 0) = MaxV(0)
            CV(1, 0) = MaxV(1)
        End If
        If Z = Target(1) Then
            CV(0, 1) = MaxV(0)
            CV(1, 1) = MaxV(1)
        End If
        MaxVals(0, CLng(MaxP(0) / PNA)) = 0
        MaxVals(1, CLng(MaxP(1) / PNA)) = 0
    Next Z
    
    
    
    SS = Abs(GetTickCount)
    
    EE = Abs(GetTickCount)
    TT = EE - SS
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    'CTNames() As String, CTNumlines As Long, CTBlocks() As Long, CTBlockNum As Long, CTText() As String, CTTextNum As Long
    CTNumlines = -1
    
     
    If ORFFlag = 1 Then
    
       'xxxxxxx = bits related to saving and displaying the graphic version of the tests
        
        '0 of ctblocks = xpos1, 1 = ypos1, 2 = xpos2, 3 = ypos2, 4 = colour
        '0 of cttext = xpos1, 1 = ypos1, 2 = xposcolour, 3 = text
        Dim StartP As Long, EndP As Long, BlockCol(2) As Long
        ReDim CTBlocks(4, 100), CTText(3, 100) 'xxxxxxxx
        ReDim CTNames(GeneNumber + 10) 'these are used for permenant storage
        
        
        'Form1.Picture2.DrawMode = 2
        BlockCol(0) = RGB(255, 128, 0)
        BlockCol(1) = RGB(0, 128, 255)
        BlockCol(2) = HalfColour 'quartercolour
        CTTextNum = -1
        CTBlockNum = -1
        
        'Need to make TempGeneMaps for 5% 10%, 25% edges
        Dim TempGeneMap() As Byte
        ReDim TempGeneMap(Len(StrainSeq(0)), GeneNumber + 3)
        For Y = 1 To Len(StrainSeq(0))
            If GeneMap(Y, 0) = 0 Then
                TempGeneMap(Y, 0) = 1
                For x = 1 To GeneNumber + 3
                    TempGeneMap(Y, x) = 2
                Next x
            Else
                For x = 1 To GeneNumber
                    TempGeneMap(Y, x) = GeneMap(Y, x)
                    If GeneMap(Y, x + GeneNumber) = 1 Then TempGeneMap(Y, GeneNumber + 1) = 1
                    If GeneMap(Y, x + GeneNumber * 2) = 1 Then TempGeneMap(Y, GeneNumber + 2) = 1
                    If GeneMap(Y, x + GeneNumber * 3) = 1 Then TempGeneMap(Y, GeneNumber + 3) = 1
                Next x
            End If
            
        Next Y
       
        
        
        'Make the blocks - this info is stored in genemap - note genome-length is scaled to the genome length
       CTBlockNum = -1
        For A = 2 To 0 Step -1
            For x = 0 To GeneNumber + 3
                
                For Y = 1 To Len(StrainSeq(0))
                    If TempGeneMap(Y, x) = A Then
                        StartP = Y
                        For Z = Y + 1 To Len(StrainSeq(0))
                            
                            If (TempGeneMap(Z, x) <> A) Or Z = Len(StrainSeq(0)) Then
                                
                                CTBlockNum = CTBlockNum + 1
                                'If CTBlockNum = 97 Then
                                '    X = X
                                'End If
                                If CTBlockNum > UBound(CTBlocks, 2) Then ReDim Preserve CTBlocks(4, CTBlockNum + 100)
                                CTBlocks(0, CTBlockNum) = StartP
                                CTBlocks(1, CTBlockNum) = x * 2 + 3
                                CTBlocks(2, CTBlockNum) = Z - 1
                                CTBlocks(3, CTBlockNum) = x * 2 + 4
                                CTBlocks(4, CTBlockNum) = BlockCol(A)
                                Exit For
                            End If
                        Next Z
                        
                        Y = Z
                    End If
                
                Next Y
            
            Next x
        Next A
        
        
        'Call DrawCTBlocks
        
        
        
        
        
        
        
        
        Dim TestS() As Double, TestArea() As Long 'these are used for temporary storage
        ReDim TestS(GeneNumber + 10, 3) ' test 0 = IR test
                                        'test 1 =gene1 test
                                        'test n = gene n test
                                        'test n+1 = 25% Gene edge test
                                        'test n+2 = 10% Gene edge test
                                        'test n+3 = 5% Gene edge test
        
       ' Call DrawCTBlocks
        
        
        
        
        
        
        ReDim TestArea(GeneNumber + 10, PermNum, 1) ' perm0 = real data, (1) = inarea
        
        For x = 1 To ENumb
            If Excl(x) = 1 Then
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                    EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 1 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        If GeneMap(ST, 0) = 0 Then
                            TestArea(0, 0, 0) = TestArea(0, 0, 0) + 1
                        Else
                            TestArea(0, 0, 1) = TestArea(0, 0, 1) + 1
                        End If
                        For Z = 1 To GeneNumber
                            If GeneMap(ST, Z) = 0 Then
                                If GeneMap(ST, 0) = 1 Then 'only count stes that are in some ORF.
                                    TestArea(Z, 0, 0) = TestArea(Z, 0, 0) + 1
                                End If
                            Else
                                TestArea(Z, 0, 1) = TestArea(Z, 0, 1) + 1
                                
                            End If
                        Next Z
                        For Z = 1 To GeneNumber
                            If GeneMap(ST, Z + GeneNumber) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count sites that are in same ORF.
                                    TestArea(GeneNumber + 1, 0, 0) = TestArea(GeneNumber + 1, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 1, 0, 1) = TestArea(GeneNumber + 1, 0, 1) + 1
                                
                            End If
                            If GeneMap(ST, Z + GeneNumber * 2) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 2, 0, 0) = TestArea(GeneNumber + 2, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 2, 0, 1) = TestArea(GeneNumber + 2, 0, 1) + 1
                                
                            End If
                            If GeneMap(ST, Z + GeneNumber * 3) = 0 Then
                                If GeneMap(ST, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 3, 0, 0) = TestArea(GeneNumber + 3, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 3, 0, 1) = TestArea(GeneNumber + 3, 0, 1) + 1
                            End If
                        Next Z
                    End If
                    If XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 2 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag <> 3 Then
                        If GeneMap(EN, 0) = 0 Then
                            TestArea(0, 0, 0) = TestArea(0, 0, 0) + 1
                        Else
                            TestArea(0, 0, 1) = TestArea(0, 0, 1) + 1
                        End If
                        For Z = 1 To GeneNumber
                            If GeneMap(EN, Z) = 0 Then
                                If GeneMap(EN, 0) = 1 Then 'only count stes that are in some ORF.
                                    TestArea(Z, 0, 0) = TestArea(Z, 0, 0) + 1
                                End If
                            Else
                                TestArea(Z, 0, 1) = TestArea(Z, 0, 1) + 1
                                
                            End If
                        Next Z
                        For Z = 1 To GeneNumber
                            If GeneMap(EN, Z + GeneNumber) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count sites that are in same ORF.
                                    TestArea(GeneNumber + 1, 0, 0) = TestArea(GeneNumber + 1, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 1, 0, 1) = TestArea(GeneNumber + 1, 0, 1) + 1
                                
                            End If
                            If GeneMap(EN, Z + GeneNumber * 2) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 2, 0, 0) = TestArea(GeneNumber + 2, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 2, 0, 1) = TestArea(GeneNumber + 2, 0, 1) + 1
                                
                            End If
                            If GeneMap(EN, Z + GeneNumber * 3) = 0 Then
                                If GeneMap(EN, Z) = 1 Then  'only count stes that are in same ORF.
                                    TestArea(GeneNumber + 3, 0, 0) = TestArea(GeneNumber + 3, 0, 0) + 1
                                End If
                            Else
                                TestArea(GeneNumber + 3, 0, 1) = TestArea(GeneNumber + 3, 0, 1) + 1
                            End If
                        Next Z
                        x = x
                        'XX = GeneMap(EN, 0)
                    End If
                End If
            End If
            
        Next x
            
        For Z = 1 To Len(StrainSeq(0))
            'IR test
            If GeneMap(Z, 0) = 0 Then
                For A = 1 To PermNum
                    TestArea(0, A, 0) = TestArea(0, A, 0) + MapIR(Z, CLng(A / PNA))
                Next A
            Else
                For A = 1 To PermNum
                    TestArea(0, A, 1) = TestArea(0, A, 1) + MapIR(Z, CLng(A / PNA))
                Next A
            End If
            For x = 1 To GeneNumber
               If x = 12345 Then
                    AA = 0
                    'Open "test.csv" For Output As #1
                    
                    For n = 0 To Len(StrainSeq(0))
                        
                            If GeneMap(n, 8) = 1 Then
                                For M = 0 To PermNum
                                    AA = AA + MapORF(n, M) 'gag=7982, nef=3474;gag=10884; nef=2316
                                Next M
                            End If
                        
                    Next n
                    'Close #1
                End If
                If GeneMap(Z, x) = 1 Then
                    For A = 1 To PermNum
                        If MapORF(Z, A) <> 0 Then
                            TestArea(x, A, 1) = TestArea(x, A, 1) + MapORF(Z, A) ' CLng(A / PNA))
                        End If
                    Next A
                Else
                    For A = 1 To PermNum
                        If MapORF(Z, A) <> 0 Then
                            TestArea(x, A, 0) = TestArea(x, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        End If
                    Next A
                End If
                If GeneMap(Z, x) = 1 Then
                    If GeneMap(Z, x + GeneNumber) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 1, A, 1) = TestArea(GeneNumber + 1, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 1, A, 0) = TestArea(GeneNumber + 1, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                    If GeneMap(Z, x + GeneNumber * 2) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 2, A, 1) = TestArea(GeneNumber + 2, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 2, A, 0) = TestArea(GeneNumber + 2, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                    If GeneMap(Z, x + GeneNumber * 3) = 1 Then
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 3, A, 1) = TestArea(GeneNumber + 3, A, 1) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    Else
                        For A = 1 To PermNum
                            TestArea(GeneNumber + 3, A, 0) = TestArea(GeneNumber + 3, A, 0) + MapORF(Z, A) 'CLng(A / PNA))
                        Next A
                    End If
                End If
                
            Next x
            eexx = Abs(GetTickCount)
            If Abs(eexx - ssxx) > 500 Then
            
                ssxx = eexx
                Form1.SSPanel1.Caption = Str(CLng((Z / Len(StrainSeq(0))) * 100)) + "% of tests completed"
                Form1.Refresh
                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            End If
        Next Z
        
        Form1.SSPanel1.Caption = "100% of tests completed"
        Form1.Refresh
        If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            
            
        For x = 0 To GeneNumber
            'Min = PermNum * 2
            'Max = 0
            
            For A = 1 To Len(StrainSeq(0))
                If GeneMap(A, x) = 1 Then GoOn = 1: Exit For
            Next A
            If GoOn = 1 Then
                For A = 1 To PermNum
                    If TestArea(x, A, 0) > TestArea(x, 0, 0) Then x = x 'Tests(X, 0) = Tests(X, 0) + 1
                    If TestArea(x, A, 0) < TestArea(x, 0, 0) Then x = x 'Tests(X, 1) = Tests(X, 1) + 1
                    
                    
                    If TestArea(x, A, 1) >= TestArea(x, 0, 1) Then
                        TestS(x, 1) = TestS(x, 1) + 1
                        'If X = 1 Then
                        '    X = X
                        'End If
                    End If
                    If TestArea(x, A, 1) <= TestArea(x, 0, 1) Then
                         'If X = 1 Then
                         '   X = X
                        'End If
                        TestS(x, 0) = TestS(x, 0) + 1
                    End If
                Next A
                For A = 0 To 3
                    TestS(x, A) = TestS(x, A) / PermNum
                    
                Next A
            End If
        Next x
        
        For x = GeneNumber + 1 To GeneNumber + 3
                For A = 1 To PermNum
                    If TestArea(x, A, 0) > 0 Then
                        x = x
                    End If
                    If TestArea(x, A, 0) > TestArea(x, 0, 0) Then x = x ' Tests(X, 0) = Tests(X, 0) + 1
                    If TestArea(x, A, 0) < TestArea(x, 0, 0) Then x = x '  Tests(X, 1) = Tests(X, 1) + 1
                    If TestArea(x, A, 1) >= TestArea(x, 0, 1) Then TestS(x, 1) = TestS(x, 1) + 1
                    If TestArea(x, A, 1) <= TestArea(x, 0, 1) Then TestS(x, 0) = TestS(x, 0) + 1
                Next A
                For A = 0 To 1
                    TestS(x, A) = TestS(x, A) / PermNum
                Next A
        Next x
        
        
        
        If DebuggingFlag < 2 Then On Error Resume Next

        oDir = CurDir
        odrv = CurDir
        ChDir App.Path
        ChDrive App.Path
        On Error GoTo 0
        Close #1
        Open "Permutation test.csv" For Append As #1
        Open "TempFile" For Output As #4
        Print #1, ""
        Print #1, FName
        Print #1, Date & "," & Time
        CTNumlines = CTNumlines + 1
        CTTextNum = CTTextNum + 1
        
        'elemnet 1: 0 = lhs of box, 1 = middle column 1, 2 = middle columns 1+2, 3 = middle column2, 4 = middle column 3, 5 = middle columns 3&4, 6 = middle column 4,
        ' 7 = middle column 5, 8 = middle columns 5&6, 9 = middle column 6
        
        CTText(0, CTTextNum) = 2
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "Breakpoint No"
        
        
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 5
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "Breakpoints/100nts"
        
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 8
        CTText(1, CTTextNum) = 1
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = "P-val"
        
        
        
        
        CTNames(CTNumlines) = "Test, Breakpoints No in region, Breakpoint No outside region, breakpoints/100nts in region, breakpoints/100nts outside region, Probability of fewer than expected BPs in region, Probability of more than expected BPs in region"
        Print #1, CTNames(CTNumlines)
        Print #4, CTNames(CTNumlines)
        Dim oSTring As String
        
        Dim PropINOUT(1) As Double, PropBase(1) As Double
        PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
        For x = 1 To Len(StrainSeq(0))
            If GeneMap(x, 0) = 1 Then
                PropINOUT(0) = PropINOUT(0) + 1
                For Y = 0 To NextNo
                    If SeqNum(x, Y) <> 46 Then
                        PropBase(0) = PropBase(0) + 1
                    End If
                    
                Next Y
            Else
                PropINOUT(1) = PropINOUT(1) + 1
                For Y = 0 To NextNo
                    If SeqNum(x, Y) <> 46 Then
                        PropBase(1) = PropBase(1) + 1
                    End If
                Next Y
            End If
        Next x
        
        
        If PropINOUT(1) > 0 Then
            PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
            PropINOUT(1) = (100 * (TestArea(0, 0, 0) / PropINOUT(1))) / PropBase(1)
        Else
            PropINOUT(1) = 0
        End If
        
        If PropINOUT(0) > 0 Then
            PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
            PropINOUT(0) = (100 * TestArea(0, 0, 1) / PropINOUT(0)) / PropBase(0)
        Else
            PropINOUT(0) = 0
        End If
        oSTring = "Intergenic regions vs all ORFs combined"
        CTTextNum = CTTextNum + 1
        CTText(0, CTTextNum) = 0
        CTText(1, CTTextNum) = 2
        CTText(2, CTTextNum) = 0
        CTText(3, CTTextNum) = oSTring
        
        LastX = 0
            
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 1
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(TestArea(0, 0, 0))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 3
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(TestArea(0, 0, 1))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 4
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(PropINOUT(1))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 6
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(PropINOUT(0))
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 7
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(1)
        CTText(3, CTTextNum) = Str(TestS(0, 0))
        If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
        
        CTTextNum = CTTextNum + 1
        If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
        CTText(0, CTTextNum) = 9
        CTText(1, CTTextNum) = LastX * 2 + 3
        CTText(2, CTTextNum) = BlockCol(0)
        CTText(3, CTTextNum) = Str(TestS(0, 1))
        If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
        
        CTNumlines = CTNumlines + 1
        CTNames(CTNumlines) = oSTring + Str(TestArea(0, 0, 0)) + "," + Str(TestArea(0, 0, 1)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(0, 0)) + "," + Str(TestS(0, 1)) + ","
        Print #1, CTNames(CTNumlines)
        Print #4, CTNames(CTNumlines)
        For x = 1 To GeneNumber
            
            If TestName(x) <> "" Then
                PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
                
                For Z = 1 To Len(StrainSeq(0))
                    If GeneMap(Z, 0) = 1 Then
                        If GeneMap(Z, x) = 0 Then
                            PropINOUT(0) = PropINOUT(0) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(0) = PropBase(0) + 1
                                End If
                            Next Y
                            
                        Else
                            PropINOUT(1) = PropINOUT(1) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(1) = PropBase(1) + 1
                                End If
                            Next Y
                        End If
                    Else
                    x = x '1-3813:5322-end
                    End If
                Next Z
                'PropINOUT(0) = 6781,7800
                'PropINOUT(1) = 1019
                'PropBase(0) = 1193456'1380600
                'PropBase(1) = 179344
                If PropINOUT(1) > 0 Then '1019,
                    PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
                    PropINOUT(1) = (100 * TestArea(x, 0, 1) / PropINOUT(1)) * PropBase(1)
                Else
                    PropINOUT(1) = 0
                End If
                
                If PropINOUT(0) > 0 Then
                    PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
                    PropINOUT(0) = (100 * TestArea(x, 0, 0) / PropINOUT(0)) * PropBase(0)
                Else
                    PropINOUT(0) = 0
                End If
                CTNumlines = CTNumlines + 1
                CTNames(CTNumlines) = TestName(x) + "," + Str(TestArea(x, 0, 1)) + "," + Str(TestArea(x, 0, 0)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(x, 1)) + "," + Str(TestS(x, 0))
                Print #1, CTNames(CTNumlines)
                Print #4, CTNames(CTNumlines)
                CTTextNum = CTTextNum + 1
                If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
                
                CTText(0, CTTextNum) = 0
                CTText(1, CTTextNum) = x * 2 + 2
                CTText(2, CTTextNum) = 0
                CTText(3, CTTextNum) = TestName(x)
                LastX = x
            
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 1
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(TestArea(x, 0, 1))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 3
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(TestArea(x, 0, 0))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 4
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(PropINOUT(1))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 6
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(PropINOUT(0))
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 7
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(1)
               CTText(3, CTTextNum) = Str(TestS(x, 1))
               If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
               
               CTTextNum = CTTextNum + 1
               If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
               CTText(0, CTTextNum) = 9
               CTText(1, CTTextNum) = LastX * 2 + 3
               CTText(2, CTTextNum) = BlockCol(0)
               CTText(3, CTTextNum) = Str(TestS(x, 0))
               If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
               
                
                
            End If
            
        Next x
        
        
        For A = 1 To 3
            PropINOUT(0) = 0: PropINOUT(1) = 0: PropBase(0) = 0: PropBase(1) = 0
            For x = 1 To GeneNumber
                
                For Z = 1 To Len(StrainSeq(0))
                    If GeneMap(Z, x) = 1 Then
                        If GeneMap(Z, x + A * GeneNumber) = 0 Then
                            PropINOUT(0) = PropINOUT(0) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(0) = PropBase(0) + 1
                                End If
                                
                            Next Y
                        Else
                            PropINOUT(1) = PropINOUT(1) + 1
                            For Y = 0 To NextNo
                                If SeqNum(Z, Y) <> 46 Then
                                    PropBase(1) = PropBase(1) + 1
                                End If
                                
                            Next Y
                        End If
                    End If
                Next Z
                
            
            Next x
            
            
            If PropINOUT(1) > 0 Then
                PropBase(1) = PropBase(1) / ((NextNo + 1) * PropINOUT(1))
                PropINOUT(1) = (100 * TestArea(GeneNumber + A, 0, 1) / PropINOUT(1)) / PropBase(1)
            Else
                PropINOUT(1) = 0
            End If
            If PropINOUT(0) > 0 Then
                PropBase(0) = PropBase(0) / ((NextNo + 1) * PropINOUT(0))
                PropINOUT(0) = (100 * TestArea(GeneNumber + A, 0, 0) / PropINOUT(0)) / PropBase(0)
             Else
                PropINOUT(0) = 0
            End If
            CTNumlines = CTNumlines + 1
            CTNames(CTNumlines) = TestName(GeneNumber + A) + "," + Str(TestArea(GeneNumber + A, 0, 1)) + "," + Str(TestArea(GeneNumber + A, 0, 0)) + "," + Str(PropINOUT(1)) + "," + Str(PropINOUT(0)) + "," + Str(TestS(GeneNumber + A, 1)) + "," + Str(TestS(GeneNumber + A, 0))
            Print #1, CTNames(CTNumlines)
            Print #4, CTNames(CTNumlines)
            LastX = LastX + 1 'lastx should = GeneNUmber+A
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 0
            CTText(1, CTTextNum) = LastX * 2 + 2
            CTText(2, CTTextNum) = 0
            CTText(3, CTTextNum) = TestName(LastX)
            
         
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 1
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(TestArea(GeneNumber + A, 0, 1))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 3
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(TestArea(GeneNumber + A, 0, 0))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 4
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(PropINOUT(1))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 6
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(PropINOUT(0))
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 7
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(1)
            CTText(3, CTTextNum) = Str(TestS(GeneNumber + A, 1))
            If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
            
            CTTextNum = CTTextNum + 1
            If CTTextNum > UBound(CTText, 2) Then ReDim Preserve CTText(3, CTTextNum + 100)
            CTText(0, CTTextNum) = 9
            CTText(1, CTTextNum) = LastX * 2 + 3
            CTText(2, CTTextNum) = BlockCol(0)
            CTText(3, CTTextNum) = Str(TestS(GeneNumber + A, 0))
            If val(CTText(3, CTTextNum)) = 1 And val(CTText(3, CTTextNum - 2)) = 0 Then CTText(3, CTTextNum) = "--"
            
        Next A
        
        
        
        Erase GeneMap
        'ostring =
        Close #1
        Close #4
        'This is the file that is saved when the table in picturebox 2 gets saved
        Open "TempFile" For Binary As #1
            ClusteringResult = String(LOF(1), " ")
            Get #1, , ClusteringResult
        Close #1
        
        
        
        ManFlag = 161
        If DebuggingFlag < 2 Then On Error Resume Next
        KillFile "TempFile"
        ChDir oDir
        ChDrive odrv
        On Error GoTo 0
          'Form1.Picture20.Visible = False
          Call DrawCTBlocks
          x = x
          Erase MapORF
          Erase MapIR
          Erase GeneMap
          Erase TempGeneMap
    End If
    'ReDim MapORF(0, 0)
    'ReDim MapIR(0, 0)
    
    
    Erase TestArea
    If x = x Then
        'GlobalMemoryStatus MemSit
        
        'APhys = Abs(MemSit.dwAvailPhys)
        APhys = 100000000
        If APhys < (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4) Then
            shortfall = (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4) - APhys
            MsgBox ("There is not enough available free memory to complete the permutation test.  You are short of ~" + Trim(Str(Int(shortfall / 1000000)))) + " Megs of RAM. Either free up some memory or try doing the test on a computer with more RAM"
            'PermNum = 75
            PermNum = PermNum * (APhys / (Len(StrainSeq(0)) * CLng(PermNum / PNA) * 4))
            'x = x
            'AbortFlag = 1
            'Exit Sub
        End If
        
        ReDim PValMap(Len(StrainSeq(0)), CLng(PermNum / PNA))
        'Exit Sub
        SS = Abs(GetTickCount)
        Form1.ProgressBar1.Value = 90
        Call UpdateF2Prog
        If x = x Then
            Dummy = MakePValMap(DN, Len(StrainSeq(0)), CLng(PermNum / PNA), MaP(0, 0), PValMap(0, 0))
        Else
            Dim TopS As Double, BottomS As Double, DoneNum As Long
            For Y = DN To Len(StrainSeq(0)) - DN + 1
                TopS = 1000000: BottomS = 0
                DoneNum = 0
                For x = 0 To PermNum
                    DoneNum = 0
                    BottomS = 0
                    For Z = 0 To PermNum
                        
                        If MaP(Y, CLng(Z / PNA)) > BottomS And MaP(Y, CLng(Z / PNA)) < TopS Then
                            BottomS = MaP(Y, CLng(Z / PNA))
                            DoneNum = 1
                        End If
                    Next Z
                    If DoneNum = 1 Then
                        DoneNum = 0
                        For Z = 0 To PermNum
                            If MaP(Y, CLng(Z / PNA)) = BottomS Then
                                PValMap(Y, CLng((x + DoneNum) / PNA)) = MaP(Y, CLng(Z / PNA))
                                DoneNum = DoneNum + 1
                            End If
                        Next Z
                        
                        TopS = BottomS
                        
                        If DoneNum > 1 Then x = x + DoneNum - 1
                        LastX = x + 1
                    Else
                        For Z = LastX To PermNum
                            PValMap(Y, CLng(Z / PNA)) = 0
                        Next Z
                        Exit For
                    End If
                Next x
            Next Y
        End If
    End If
    
End Sub
Public Sub RecombMapPermsC(Excl() As Byte, PermNum As Long, RNDSEED As Long, SCArray() As Long, ITots() As Single, SConvert As Single)
    Dim MatMinMax() As Long, MatrixRX() As Single, RSize As Long, SPS As Long, EPS As Long, A As Long, x As Long, OffsetX As Long, PPos As Long, Target(1) As Long, MaxV(1) As Double, MaxP(1) As Long, MaxVals() As Long, NewStart As Long, S As Long, NS As Long, NE As Long, LSSeq As Long, RecSize As Long, MaxS As Long, MaP() As Integer, Size As Long, D As Long, P1 As Long, P2 As Long, RecMapSmooth() As Double
    Dim tSeqnum() As Integer, MaxCycleNo As Long, CycleNo As Long
    Dim BestP() As Double, BreakPos() As Long, BreakNum As Long, OKProg(20) As Byte
    Dim xxWin As Double
    
    Dim Segbound() As Byte
    ReDim Segbound(Len(StrainSeq(0)))
    If ReassortmentFlag = 1 Then
        For x = 0 To RBPNum
            'XX = UBound(RBPPos, 1)
            tBP = RBPPos(x)
            Segbound(RBPPos(x)) = 1
        Next x
    End If
    
    ReDim RecMap(Len(StrainSeq(0)))
    ReDim RecMapSmooth(Len(StrainSeq(0)))
    For x = 0 To AddNum - 1
        If DoScans(0, x) = 1 Then OKProg(x) = 1
    Next x
    RSize = Len(StrainSeq(0))
    If RSize > 1000 Then RSize = 1000
    'SConvert = RSize / Len(StrainSeq(0))
    
    If PermSeqNumInFile = 1 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim PermSeqNum(Len(StrainSeq(0)), PermNextno)
        Open "RDP5PSNFile" + UFTag For Binary As #FF
        Get #FF, , PermSeqNum
        Close #FF
        ChDrive oDirX
        ChDir oDirX
    End If
    
    
    
    
    ReDim MatrixRRP(RSize + 1, RSize + 1, 1)
    'Dim MinS As Long
    
    Form1.Command25.Enabled = True
    Form1.Command25.ToolTipText = "Stop the test"
    Form1.Frame7.Enabled = True
    Form1.Picture23(1).Enabled = True
    
    If LongWindedFlag = 0 Then
        ENumb = Eventnumber
    Else
        ENumb = SEventNumber
    End If
    b = 0
    C = 0
    ReDim MaP(Len(StrainSeq(0)), PermNum), MaxVals(1, PermNum)
    Rnd (-BSRndNumSeed)
    SS = Abs(GetTickCount)
    ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200)
    For A = 1 To PermNum
        ReDim tSeqnum(Len(StrainSeq(0)), PermNextno)
        If CircularFlag = 0 Then
            For x = 0 To NextNo
            '    For Y = 1 To Len(StrainSeq(0))
                   tSeqnum(1, x) = 1
                  ' Exit Sub
                   tSeqnum(Len(StrainSeq(0)), x) = 1
            '    Next Y
            Next x
        End If
        ZZZ = 0
        ggg = 0
        
        ReDim MatrixRX(RSize + 1, RSize + 1)
        
        For x = 1 To ENumb
            
            
            If Excl(x) = 1 Then
                ZZZ = ZZZ + 1
                If (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
                    
                    CNum = 0
                    SEN = SuperEventList(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Eventnumber)
                    
                    
                    
                    If x = x Then
                        D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                        P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                        P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                        ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                        EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                        
'                        If ReassortmentFlag = 1 Then
'                            Do
'                                GoOn = 0
'                                If Segbound(ST) = 1 Then
'                                    If ST < Len(StrainSeq(0)) Then
'                                        ST = ST + 1
'                                    Else
'                                        ST = 1
'                                    End If
'                                Else
'                                    GoOn = GoOn + 1
'                                End If
'                                If Segbound(EN) = 1 Then
'                                    If EN > 1 Then
'                                        EN = EN - 1
'                                    Else
'                                        EN = Len(StrainSeq(0))
'                                    End If
'                                Else
'                                    GoOn = GoOn + 1
'                                End If
'                                If GoOn = 2 Then Exit Do
'                            Loop
'
'                        End If
                        'Make variable sites array
                        
                        
                        LSSeq = MakeSubSeqPerm(Len(StrainSeq(0)), D, P1, P2, PermSeqNum(0, 0), XDiffPos(0), XPosDiff(0))
                        
                        If EN > ST Then
                            RecSize = XPosDiff(EN) - XPosDiff(ST) + 1
                        Else
                            RecSize = LSSeq - XPosDiff(ST) + XPosDiff(EN)
                        End If
                        If CircularFlag = 0 Then
                            MaxS = LSSeq - RecSize
                        Else
                             MaxS = LSSeq
                        End If
                        
                        'Make new ending and start for this event
                        If (Segbound(ST) = 0 And Segbound(EN) = 0) Or ReassortmentFlag = 0 Then
                        'For A = 1 To PermNum
                            MaxCycleNo = LSSeq * 5
                            CycleNo = 0
                            Do
                                NewStart = Int((MaxS * Rnd) + 1)
                               
                                GoOn = CheckBPOL(Len(StrainSeq(0)), D, LSSeq, NewStart, RecSize, tSeqnum(0, 0), NS, NE, XDiffPos(0))
                                If GoOn = 1 Then Exit Do
                                CycleNo = CycleNo + 1
                                If CycleNo > MaxCycleNo Then Exit Do
                                
                            Loop
                            
                            x = x
                        Else
                            NS = Int(((RBPNum - 2) * Rnd) + 1)
                            NE = RBPPos(NS + 1)
                            NS = RBPPos(NS)
                            x = x
                        End If
                        
                        OffsetX = NS - ST
                            
                        Dummy = MakeRecCMatrix(Len(StrainSeq(0)), RSize, NS, NE, SCArray(0), MatrixRX(0, 0))
                        
                            'Exit Sub
                            
                         'Next A
                    
                   
                        
        
                    End If
                    If x = x Then
                        'ReDim BestP(1, NextNo), BreakPos(1, 1, NextNo)
                        
                        'mark BPs for all the other events
                        'For Y = 1 To SEventNumber
                            SPS = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning + OffsetX
                            EPS = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending + OffsetX
                            If SPS < 1 Then SPS = Len(StrainSeq(0)) + SPS
                            If SPS > Len(StrainSeq(0)) Then SPS = SPS - Len(StrainSeq(0))
                            If EPS < 1 Then EPS = Len(StrainSeq(0)) + EPS
                            If EPS > Len(StrainSeq(0)) Then EPS = EPS - Len(StrainSeq(0))
                            For Z = 0 To PermNextno
                                If Daught(x, Z) > 0 Then
                                    tSeqnum(SPS, Z) = 1
                                    tSeqnum(EPS, Z) = 1
                                End If
                            Next Z
                        'Next Y
                    End If
                    
                    
                End If
            End If
        Next x
        
        
        
        ET = Abs(GetTickCount)
        
        
        If x = x Then
            Dummy = UpdateMatrixRRP(RSize, MatrixRRP(0, 0, 0), MatrixRX(0, 0), MatrixRR(0, 0))
           
        Else
            For x = 0 To RSize
                For Y = x + 1 To RSize
                    
                    If MatrixRX(x, Y) >= MatrixRR(x, Y) Then
                        MatrixRRP(x, Y, 0) = MatrixRRP(x, Y, 0) + 1
                        MatrixRRP(Y, x, 0) = MatrixRRP(x, Y, 0)
                    End If
                    If MatrixRX(x, Y) <= MatrixRR(x, Y) Then
                        MatrixRRP(x, Y, 1) = MatrixRRP(x, Y, 1) + 1
                        MatrixRRP(Y, x, 1) = MatrixRRP(x, Y, 1)
                        
                    End If
                Next Y
            Next x
        
        End If
        If InteractListLen >= 0 Then
            For x = 0 To InteractListLen
                For Y = CLng(InteractList(0, x) * SConvert) To CLng(InteractList(1, x) * SConvert)
                    For Z = CLng(InteractList(2, x) * SConvert) To CLng(InteractList(3, x) * SConvert)
                        ITots(x, A) = ITots(x, A) + MatrixRX(Y, Z)
                        ITots(InteractListLen + 1, A) = ITots(InteractListLen + 1, A) + MatrixRX(Y, Z)
                    Next Z
                Next Y
            Next x
        
        End If
        
        
        ET = Abs(GetTickCount)
        If Abs(ET - LT) > 500 Then
            LT = ET
            Form1.SSPanel1.Caption = Str(A) + " of" + Str(PermNum) + " permutations completed"
            Form1.ProgressBar1.Value = (A / PermNum) * 80
            Call UpdateF2Prog
            'Form1.Command25.Enabled = True: Form1.Frame7.Enabled = True
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
            DoEvents
            If AbortFlag = 1 Then
                Form1.Command25.Enabled = False
                Form1.Command25.ToolTipText = ""
                AbortFlag = 0
                PermNum = A - 1
                'Form1.Picture26.Refresh
                'Form1.SSPanel1.Caption = ""
                'Form1.ProgressBar1 = 0
                Exit Sub
            End If
            
            If A / 10 = CLng(A / 10) Then
                Form1.Refresh
            Else
                Form1.SSPanel1.Refresh
            End If
        End If
        XXX = ZZZ
    Next A
    
    If PermSeqNumInFile = 1 Then
        ReDim PermSeqNum(0, 0)
    End If
    
    
    
    'get maxes
   EE = Abs(GetTickCount)
   TT = EE - SS
   '16.141
   x = x
   'Exit Sub
    'DN = 1
   Form1.Command25.Enabled = True
   Form1.Command25.ToolTipText = "Stop the test"
   Form1.Frame7.Enabled = True
  Form1.Picture23(1).Enabled = True
    EE = Abs(GetTickCount)
    TT = EE - SS
    Form1.ProgressBar1.Value = 100
    Call UpdateF2Prog
    x = x
End Sub
Public Sub DoMatCap()
    Form1.Label4.Left = Form1.Picture26.Left
    Form1.Label4.Width = Form1.Picture26.Width
    If CurMatrixFlag = 0 Then
        Form1.Label4.Caption = "Compatibility matrix (Ingrid Jakobsen; " + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 14 Then
        Form1.Label4.Caption = "Compatibility matrix (Trevor Bruen; " + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 1 Then
        Form1.Label4.Caption = "Recombination matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 2 Then
        Form1.Label4.Caption = "Modulatrity matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 3 Then
        Form1.Label4.Caption = "Region count matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 4 Then
        Form1.Label4.Caption = "Breakpoint pair matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 5 Then
        Form1.Label4.Caption = "McVean's linkage disequilibrium Matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 6 Then
        Form1.Label4.Caption = "Hudson and Kaplan's RMin matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 7 Then
        Form1.Label4.Caption = "Hudson and Kaplan's RMin/distance matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 8 Then
        Form1.Label4.Caption = "MaxChi breakpoint matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 11 Then
        Form1.Label4.Caption = "LARD breakpoint matrix (" + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 12 Then
        Form1.Label4.Caption = "Compatibility matrix (Shimodaira-Hasegwa; " + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    ElseIf CurMatrixFlag = 13 Then
        Form1.Label4.Caption = "Compatibility matrix (Robinson-Foulds; " + Trim(Left(Str(MatZoom(CurMatrixFlag) + 0.000001), 5)) + " X zoom)"
    End If
    Form1.Command39(0).ZOrder
    Form1.Command39(1).ZOrder
    If CurMatrixFlag < 255 Then
        If MatZoom(CurMatrixFlag) = 1 Then
            Form1.HScroll4.Enabled = False
            Form1.VScroll5.Enabled = False
        Else
            Form1.HScroll4.Enabled = True
            Form1.VScroll5.Enabled = True
        End If
    End If
End Sub
Public Sub ClearMatrix()
Dim Z As Long

CurMatrixFlag = 255
Form1.Picture26.Picture = LoadPicture()
Form1.Picture18.Picture = LoadPicture()
Form1.Picture17.Picture = LoadPicture()
Form1.Label4.Caption = ""
                        
For Z = 0 To 4
    Form1.Line1(Z).Visible = False
    Form1.Label6(Z) = ""
Next Z
For Z = 0 To 2
    Form1.Label7(Z) = ""
Next Z
Form1.VScroll5.Enabled = False
Form1.HScroll4.Enabled = False
End Sub

Public Sub DoHeatMaps()
Dim Y As Long, x As Long
    'If X = X Then
        Y = -1
        For x = 128 To 255
            Y = Y + 1
            HeatMap(0, Y) = RGB(0, 0, x)
        Next x
        
        
        For x = 0 To 255
            
            HeatMap(0, x + 128) = RGB(0, x, 255)
        Next x
        
        Y = -1
        For x = 0 To 255 Step 2
            Y = Y + 1
            HeatMap(0, Y + 383) = RGB(0, 255, 255 - x)
        Next x
        Y = -1
        For x = 0 To 255 Step 2
            Y = Y + 1
            HeatMap(0, Y + 510) = RGB(x, 255, 0)
        Next x
        For x = 1 To 255
            HeatMap(0, x + 637) = RGB(255, 255 - x, 0)
        Next x
        Y = -1
        For x = 0 To 128
            Y = Y + 1
            HeatMap(0, Y + 893) = RGB(255 - x, 0, 0)
        Next x
        'X = X
'    Else
'        For X = 0 To 255
'            HeatMap(0, X) = RGB(0, X, 255)
'        Next X
'
'        For X = 1 To 255
'            HeatMap(0, X + 255) = RGB(0, 255, 255 - X)
'        Next X
'
'        For X = 1 To 255
'            HeatMap(0, X + 510) = RGB(X, 255, 0)
'        Next X
'        For X = 1 To 255
'            HeatMap(0, X + 765) = RGB(255, 255 - X, 0)
'        Next X
'    End If

'greyscale
    For x = 0 To 1020
        HeatMap(1, x) = RGB(255 - Int(x / 4), 255 - Int(x / 4), 255 - Int(x / 4))
    Next x
    For x = 0 To 1020
        HeatMap(2, x) = RGB(Int(x / 4), Int(x / 4), Int(x / 4))
    Next x
    'redscale
    For x = 0 To 510
        HeatMap(3, x) = RGB(Int(x / 2), 0, 0)
    Next x
    For x = 511 To 1020
        HeatMap(3, x) = RGB(255, 255 - (510 - x / 2), 255 - (510 - x / 2))
    Next x
    'greenscale
    For x = 0 To 510
        HeatMap(4, x) = RGB(0, Int(x / 2), 0)
    Next x
    For x = 511 To 1020
        HeatMap(4, x) = RGB(255 - (510 - x / 2), 255, 255 - (510 - x / 2))
    Next x
    'bluescale
    For x = 0 To 510
        HeatMap(5, x) = RGB(0, 0, Int(x / 2))
    Next x
    For x = 511 To 1020
        HeatMap(5, x) = RGB(255 - (510 - x / 2), 255 - (510 - x / 2), 255)
    Next x
    
    For x = 0 To 255
        HeatMap(6, x) = RGB(x, 0, 0)
    Next x
    For x = 0 To 510
        HeatMap(6, 256 + x) = RGB(255, x / 2, 0)
    Next x
    For x = 0 To 255
        HeatMap(6, 766 + x) = RGB(255, 255, x)
    Next x
End Sub
Public Sub DrawRecMatrix(PWFlag)

Dim Addj(1) As Single, AdjDst As Single, TParDist As Single, PairDist() As Single, PairValid As Single, PairDiff As Single, RegionMat() As Single, RSize As Long, SConvert As Single, ST As Long, EN As Long
Dim UseAll As Byte, MetTheCriteria As Long

    
SSS = Abs(GetTickCount)

RSize = Len(StrainSeq(0))
If RSize > 2000 Then RSize = 2000
SConvert = RSize / Len(StrainSeq(0))

'Response = msg()






ReDim RegionMat(RSize + 1, RSize + 1)
    
If (PWFlag = 0 And DoneMatX(2) = 0) Or (PWFlag = 1 And DoneMatX(1) = 0) Then
    If PWFlag = 0 Then
        Form1.SSPanel1.Caption = "Constructing recombination matrix"
    Else
        Form1.SSPanel1.Caption = "Constructing modularity matrix"
    End If
    Dim AccX As Byte, NAccX As Byte
    AccX = 0
    NAccX = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            
            If XoverList(x, Y).Accept = 1 Then
                AccX = 1
                If NAccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            ElseIf XoverList(x, Y).Accept = 0 Then
                NAccX = 1
                If AccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            End If
            
        Next Y
        
    Next x
    
    
    If AccX = 1 And NAccX = 1 Then
        If CLine = "" Or CLine = " " Then
            If ReassortmentFlag = 1 Then
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination/reassortment events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a matrix")
            Else
                Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a matrix")
            End If
        Else
            Response = 7 'No
        End If
        If Response = 6 Then 'yes
            UseAll = 0
        Else
            UseAll = 1
        End If
    Else
        UseAll = 1
    End If
    
    Dim OnlyReassortmentFlag As Byte '0 = consider both recombination and reassortment, 1 = only reassortment, 2 = only recombination
    
    If ReassortmentFlag > 0 Then
        Dim Segbound() As Byte
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                tBP = RBPPos(x)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
        
        Dim ReassortmentNo As Long, RecombinationNo As Long
        
        For x = 0 To SEventNumber
            
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or UseAll = 1 Then
                If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
                    ReassortmentNo = ReassortmentNo + 1
                Else
                    RecombinationNo = RecombinationNo + 1
                End If
                If RecombinationNo > 0 And ReassortmentNo > 0 Then
                    Exit For
                End If
            End If
        Next x
        If RecombinationNo > 0 And ReassortmentNo > 0 Then
            Response = MsgBox("Both reassortment and recombination events have been detected. Would you like to only consider the reassortment events (i.e. the recombination events will be ignored)?", vbYesNo, "Construct a matrix")
            If Response = 7 Then
                Response = MsgBox("OK. So would you like to only consider the recombination events then? If you press 'no' then both the recombination and reassortment events will be considered.", vbYesNo, "Construct a matrix")
                If Response = 7 Then
                    OnlyReassortmentFlag = 0
                Else
                    OnlyReassortmentFlag = 2
                End If
            Else
                OnlyReassortmentFlag = 1
            End If
        Else
            OnlyReassortmentFlag = 0
        End If
    Else
        OnlyReassortmentFlag = 0
    End If
    
    
    ssxx = Abs(GetTickCount)
    Dim SCArray() As Long
    ReDim SCArray(Len(StrainSeq(0)))
    For x = 0 To Len(StrainSeq(0))
        SCArray(x) = CInt(x * SConvert)
        
    Next x
    
    
    
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, Win As Long
        
    
    Dim PermutationX As Long
    PermutationX = 1000
    ENumb = SEventNumber
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
        
    Dim BPV() As Single
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
        
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).Accept <> 2 And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                    BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                End If
            End If
        Next Y
    Next x
    
    Dim PValCon As Single
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
        
        
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Enu = SuperEventList(XoverList(x, Y).Eventnumber)
            
            NC = 0
            
            For Z = 0 To AddNum - 1
                If BPV(Enu, Z) < LowestProb Then
                    NC = NC + 1
                End If
            Next Z
            
            
                
            If XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                If OnlyReassortmentFlag = 0 Then
                    Excl(Enu) = 1
                ElseIf OnlyReassortmentFlag = 1 Then 'only reassortment
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) = 1 Then
                        Excl(Enu) = 1
                    End If
                ElseIf OnlyReassortmentFlag = 2 Then 'only recombination
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) <> 1 And Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) <> 1 Then
                        Excl(Enu) = 1
                    End If
                End If
            End If
        Next Y
    Next x
        
        
    Dim BPos() As Long, APos() As Long, TypeSeq
    ReDim APos(Len(StrainSeq(0))), BPos(Len(StrainSeq(0)))
    
    
    
    TypeSeq = 0
    If TypeSeq > PermNextno Then TypeSeq = 0
    Dim OS1 As Long, SSB As Long
    For x = 1 To Len(StrainSeq(0))
        If SeqSpacesInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
           
            OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
            Open "RDP5SSFile" + UFTag For Binary As #FF
            
            Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
            
            
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            SSB = SeqSpaces(x, TypeSeq)
            'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
        End If
        APos(x) = x - SSB
        BPos(x - SSB) = x
        SSX = Abs(GetTickCount)
        If Abs(SSX - eex) > 500 Then
            eex = SSX
            Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(Len(StrainSeq(0)))) + " sites loaded"
            Form1.Refresh
        End If
    Next x
    Form1.SSPanel1.Caption = Trim(Str(Len(StrainSeq(0)))) + " of " + Trim(Str(Len(StrainSeq(0)))) + " sites loaded"
    Form1.Refresh
    Win = 200
    If x = 12345 Then
        
        b = 0
        C = 0
        If BPCvalFlag = 0 Or x = x Then
            BPCvalFlag = 1
            ReDim BPCVal(1, 1)
            Dim DN As Long
            DN = 1
            Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
            
        End If
    End If
    
    ZZ = 0
    If AbortFlag = 1 Then
        Screen.MousePointer = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        AbortFlag = 0
        Exit Sub
    End If

    'Make exclusions
    Dim Age As Single, Tot(2) As Single, RS1 As Long, LS1 As Long, RS2 As Long, LS2 As Long, ID() As Single, NS(1) As Long, ParDist As Single
    xSeq1 = Seq1
    xSeq2 = Seq2
    xSeq3 = Seq3
    xRelX = RelX
    xRelY = RelY
    xnjflag = NJFlag
    'NJFlag = 0
    EditSeqFlag = 0
    MetTheCriteria = 0
    DontRefreshFlag = 1
    For g = 1 To ENumb
        
        If Excl(g) = 1 And (BestEvent(g, 0) > 0 Or BestEvent(g, 1) > 0) Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
               
                
            D = XoverList(BestEvent(g, 0), BestEvent(g, 1)).Daughter
            P1 = XoverList(BestEvent(g, 0), BestEvent(g, 1)).MajorP
            P2 = XoverList(BestEvent(g, 0), BestEvent(g, 1)).MinorP
            ST = XoverList(BestEvent(g, 0), BestEvent(g, 1)).Beginning
            EN = XoverList(BestEvent(g, 0), BestEvent(g, 1)).Ending
            
            If XoverList(BestEvent(g, 0), BestEvent(g, 1)).Accept = 1 Or (UseAll = 1 And XoverList(BestEvent(g, 0), BestEvent(g, 1)).Accept <> 2) Then
                If PWFlag = 0 Or (PWFlag = 1 And (XoverList(BestEvent(g, 0), BestEvent(g, 1)).MissIdentifyFlag = 0 Or XoverList(BestEvent(g, 0), BestEvent(g, 1)).MissIdentifyFlag = 10)) Then
                    MetTheCriteria = MetTheCriteria + 1
                    Seq1 = P1
                    Seq2 = P2
                    Seq3 = D
                    RelX = BestEvent(g, 0)
                    RelY = BestEvent(g, 1)
                    DontRefreshFlag = 1
                    Call ModSeqNum(ST, EN, 1)
                    
                    Call MakeTreeSeqs(ST, EN)
    
                    P1 = Seq1
                    P2 = Seq2
                    D = Seq3
                    'Work out the maximum identity of parental sequences at the time when the recombination event occured
                    
                    
                    ReDim ID(1, 2)
                    ID(0, 0) = FMat(D, P1): ID(0, 1) = FMat(D, P2): ID(0, 2) = FMat(P1, P2)
                    If DebuggingFlag < 2 Then On Error Resume Next
                    UB = 0
                    UB = UBound(SMat, 1)
                    On Error GoTo 0
                    If UB > 0 Then
                        ID(1, 0) = SMat(D, P1): ID(1, 1) = SMat(D, P2): ID(1, 2) = SMat(P1, P2)
                    Else
                        ID(1, 0) = FMat(D, P1): ID(1, 1) = FMat(D, P2): ID(1, 2) = FMat(P1, P2)
                    End If
                    'Work out the distance modifyer for each region
                    Tot(0) = 0: Tot(1) = 0: Tot(2) = 0
                    
                    If UB > 0 Then
                        TParDist = MakeDistModPar(NextNo, UBound(FMat, 1), UBound(PermDIffs, 1), Tot(0), FMat(0, 0), SMat(0, 0), PermDIffs(0, 0), PermValid(0, 0))
                        
                    Else
                        For x = 0 To NextNo
                            For Y = x + 1 To NextNo
                                If FMat(x, Y) < 3 Then
                                    Tot(0) = Tot(0) + FMat(x, Y)
                                    Tot(1) = Tot(1) + FMat(x, Y)
                                    TParDist = 1 - PermDIffs(x, Y) / PermValid(x, Y)
                                    If TParDist > 0.25 Then
                                        TParDist = (4# * TParDist - 1#) / 3#
                                        TParDist = Log(TParDist)
                                        TParDist = -0.75 * TParDist
                                       
                                    Else
                                        TParDist = 1
                                    End If
                                    Tot(2) = Tot(2) + TParDist
                                End If
                            Next Y
                        Next x
                    End If
                    
                    If Tot(0) > 0 And Tot(2) > 0 Then '42.6091706,18.498428
                        Addj(0) = Tot(0) / Tot(2)
                    Else
                        Addj(0) = 1
                    End If
                    If Tot(1) > 0 And Tot(2) > 0 Then '42.6091706,18.498428
                        Addj(1) = Tot(1) / Tot(2)
                    Else
                        Addj(1) = 1
                    End If
                    'Modify the recombinant region dists
                    For x = 0 To 2
                        ID(0, x) = ID(0, x) / Addj(0)
                        ID(1, x) = ID(1, x) / Addj(1)
                        x = x
                    Next x
                    
                    ParDist = 0: Age = 1000
                    For x = 0 To 1
                        For Y = 0 To 2
                            If Age > ID(x, Y) Then Age = ID(x, Y)
                            If ParDist < ID(x, Y) Then ParDist = ID(x, Y)
                            
                        Next Y
                    Next x
                    ParDist = ParDist - Age
                    If ParDist < 0 Then ParDist = 0
                    If PWFlag = 1 Then
                        Dim PUse() As Long
                        ReDim PUse(Len(StrainSeq(0)))
                        If ST < EN Then
                            For Z = 1 To ST - 1
                                PUse(Z) = P2
                            Next Z
                            For Z = ST To EN
                                PUse(Z) = P1
                            Next Z
                            For Z = EN + 1 To Len(StrainSeq(0))
                                PUse(Z) = P2
                            Next Z
                        Else
                            For Z = 1 To EN
                                PUse(Z) = P1
                            Next Z
                            For Z = EN + 1 To ST - 1
                                PUse(Z) = P2
                            Next Z
                            For Z = ST To Len(StrainSeq(0))
                                PUse(Z) = P1
                            Next Z
                        End If
                        
                        pwin = MatWinSize
                        ReDim PairDist(Len(StrainSeq(0)))
                        PairValid = 0: PairDiff = 0
                        For Z = 1 - pwin To pwin + 1
                            
                            If Z < 1 Then
                                x = Z + Len(StrainSeq(0))
                            ElseIf Z > Len(StrainSeq(0)) Then
                                x = Z - Len(StrainSeq(0))
                            Else
                                x = Z
                            End If
                            If SeqNum(x, D) <> 46 And SeqNum(x, PUse(x)) <> 46 Then
                                PairValid = PairValid + 1
                                If SeqNum(x, D) <> SeqNum(x, PUse(x)) Then
                                    PairDiff = PairDiff + 1
                                End If
                                
                            End If
                        Next Z
                        If PairValid > 0 Then
                            PairDist(1) = PairDiff / PairValid
                        Else
                            PairDist(1) = 0
                        End If
                        For Y = 2 To Len(StrainSeq(0))
                            Z = Y - pwin
                            If Z < 1 Then
                                x = Z + Len(StrainSeq(0))
                            ElseIf Z > Len(StrainSeq(0)) Then
                                x = Z - Len(StrainSeq(0))
                            Else
                                x = Z
                            End If
                            If SeqNum(x, D) <> 46 And SeqNum(x, PUse(x)) <> 46 Then
                                
                                PairValid = PairValid - 1
                                If SeqNum(x, D) <> SeqNum(x, PUse(x)) Then
                                    PairDiff = PairDiff - 1
                                End If
                            
                            End If
                            
                            Z = Y + pwin
                            If Z < 1 Then
                                x = Z + Len(StrainSeq(0))
                            ElseIf Z > Len(StrainSeq(0)) Then
                                x = Z - Len(StrainSeq(0))
                            Else
                                x = Z
                            End If
                            
                            If SeqNum(x, D) <> 46 And SeqNum(x, PUse(x)) <> 46 Then
                                
                                PairValid = PairValid + 1
                                If SeqNum(x, D) <> SeqNum(x, PUse(x)) Then
                                    PairDiff = PairDiff + 1
                                End If
                            
                            End If
                            If PairValid > 0 Then
                                PairDist(Y) = PairDiff / PairValid '1194,1195,1196,1197,1198 =3/12; 1199,1200 = 4/12
                                
                            Else
                                PairDist(Y) = 0
                            End If
                        Next Y
                        XX = UBound(PermValid, 1)
                        If P1 <= UBound(PermValid, 1) And P2 <= UBound(PermValid, 1) Then
                            If PermValid(P1, P2) + SubValid(P1, P2) > 0 Then
                                TParDist = 1 - PermDIffs(P1, P2) / PermValid(P1, P2)
                                If TParDist > 0.25 Then
                                    TParDist = (4# * TParDist - 1#) / 3#
                                    TParDist = Log(TParDist)
                                    TParDist = -0.75 * TParDist
                                   
                                Else
                                    TParDist = 1
                                End If
                            Else
                                TParDist = 0
                            End If
                        Else
                            TParDist = 0
                        End If
                        If TParDist > 0 Then
                            AdjDst = ParDist / TParDist
                            If AdjDst > 1 Then
                                AdjDst = 1
                               
                            End If
                            For x = 1 To Len(StrainSeq(0))
                                
                                PairDist(x) = PairDist(x) * AdjDst
                                
                                If PairDist(x) > 0.5 Then PairDist(x) = 0.5
                            Next x
                        Else
                            AdjDst = 0
                        End If
                        If x = x Then
                            XX = UBound(RegionMat, 2)
                            Dummy = FillRegionMatX(Len(StrainSeq(0)), RSize, ST, EN, SCArray(0), PairDist(0), RegionMat(0, 0))
                            
                        Else
                            LS1 = -1: LS2 = -1
                            If ST < EN Then
                                For A = 1 To ST - 1
                                    RS1 = SCArray(A)
                                    If LS1 <> RS1 Then
                                        LS1 = RS1
                                    
                                        For b = ST To EN
                                            RS2 = SCArray(b)
                                            If LS2 <> RS2 Then
                                                LS2 = RS2
                                                
                                                If PairDist(A) > PairDist(b) Then
                                                    mdst = PairDist(b)
                                                Else
                                                    mdst = PairDist(A)
                                                End If
                                                If mdst > RegionMat(RS2, RS1) Then
                                                    RegionMat(RS2, RS1) = mdst
                                                    RegionMat(RS1, RS2) = RegionMat(RS2, RS1)
                                                End If
                                                
                                            End If
                                        Next b
                                        
                                    End If
                                Next A
                                For A = EN + 1 To Len(StrainSeq(0))
                                    RS1 = SCArray(A)
                                    If LS1 <> RS1 Then
                                        LS1 = RS1
                                    
                                        For b = ST To EN
                                            RS2 = SCArray(b) 'CInt(B * SConvert)
                                            If LS2 <> RS2 Then
                                                LS2 = RS2
                                                If PairDist(A) > PairDist(b) Then
                                                    mdst = PairDist(b)
                                                Else
                                                    mdst = PairDist(A)
                                                End If
                                                If mdst > RegionMat(RS2, RS1) Then
                                                    RegionMat(RS2, RS1) = mdst
                                                    RegionMat(RS1, RS2) = RegionMat(RS2, RS1)
                                                End If
                                                
                                            End If
                                        Next b
                                        
                                    End If
                                Next A
                            Else
                                For A = EN + 1 To ST - 1
                                    RS1 = SCArray(A)
                                    If LS1 <> RS1 Then
                                        LS1 = RS1
                                    
                                        For b = 1 To EN
                                            RS2 = SCArray(b)
                                            If LS2 <> RS2 Then
                                                LS2 = RS2
                                                If PairDist(A) > PairDist(b) Then
                                                    mdst = PairDist(b)
                                                Else
                                                    mdst = PairDist(A)
                                                End If
                                                If mdst > RegionMat(RS2, RS1) Then
                                                    RegionMat(RS2, RS1) = mdst
                                                    RegionMat(RS1, RS2) = RegionMat(RS2, RS1)
                                                End If
                                                'If (PairDist(A) + PairDist(B)) / 2 > RegionMat(RS2, RS1) Then
                                                '    RegionMat(RS2, RS1) = (PairDist(A) + PairDist(B)) / 2
                                                '    RegionMat(RS1, RS2) = RegionMat(RS2, RS1)
                                                'End If
                                            End If
                                        Next b
                                        For b = ST To Len(StrainSeq(0))
                                            RS2 = SCArray(b)
                                            If LS2 <> RS2 Then
                                                LS2 = RS2
                                                If PairDist(A) > PairDist(b) Then
                                                    mdst = PairDist(b)
                                                Else
                                                    mdst = PairDist(A)
                                                End If
                                                If mdst > RegionMat(RS2, RS1) Then
                                                    RegionMat(RS2, RS1) = mdst
                                                    RegionMat(RS1, RS2) = RegionMat(RS2, RS1)
                                                End If
                                                'If (PairDist(A) + PairDist(B)) / 2 > RegionMat(RS2, RS1) Then
                                                '    RegionMat(RS2, RS1) = (PairDist(A) + PairDist(B)) / 2
                                                '    RegionMat(RS1, RS2) = RegionMat(RS2, RS1)
                                                'End If
                                            End If
                                        Next b
                                    End If
                                Next A
                                
                            End If
                        End If
                    Else
                    
                    
                        If ParDist > 0 Then
                            
                            If x = x Then
                                Dummy = AddToRegionMat(Len(StrainSeq(0)), ST, EN, RSize, SConvert, ParDist, RegionMat(0, 0))
                            Else
                                LS1 = -1: LS2 = -1
                                If ST < EN Then
                                    
                                    For A = 1 To ST - 1
                                        RS1 = CInt(A * SConvert)
                                        If LS1 <> RS1 Then
                                            LS1 = RS1
                                            
                                            For b = ST To EN
                                                RS2 = CInt(b * SConvert)
                                                If LS2 <> RS2 Then
                                                    LS2 = RS2
                                                    
                                                    If ParDist > RegionMat(RS2, RS1) Then
                                                        RegionMat(RS2, RS1) = ParDist
                                                        RegionMat(RS1, RS2) = ParDist
                                                    End If
                                                End If
                                            Next b
                                        End If
                                    Next A
                                   
                                    For A = EN + 1 To Len(StrainSeq(0))
                                        RS1 = CInt(A * SConvert)
                                        If LS1 <> RS1 Then
                                            LS1 = RS1
                                        
                                            For b = ST To EN
                                                RS2 = CInt(b * SConvert)
                                                If LS2 <> RS2 Then
                                                    LS2 = RS2
                                                    
                                                    If ParDist > RegionMat(RS2, RS1) Then
                                                        RegionMat(RS2, RS1) = ParDist
                                                        RegionMat(RS1, RS2) = ParDist
                                                    End If
                                                End If
                                            Next b
                                        End If
                                    Next A
                                Else
                                    
                                    For A = EN + 1 To ST - 1
                                        RS1 = CInt(A * SConvert)
                                        If LS1 <> RS1 Then
                                            LS1 = RS1
                                        
                                            For b = 1 To EN
                                                RS2 = CInt(b * SConvert)
                                                If LS2 <> RS2 Then
                                                    LS2 = RS2
                                                    
                                                    If ParDist > RegionMat(RS2, RS1) Then
                                                        RegionMat(RS2, RS1) = ParDist
                                                        RegionMat(RS1, RS2) = ParDist
                                                    End If
                                                End If
                                            Next b
                                            For b = ST To Len(StrainSeq(0))
                                                RS2 = CInt(b * SConvert)
                                                If LS2 <> RS2 Then
                                                    LS2 = RS2
                                                    If ParDist > RegionMat(RS2, RS1) Then
                                                        RegionMat(RS2, RS1) = ParDist
                                                        RegionMat(RS1, RS2) = ParDist
                                                    End If
                                                End If
                                            Next b
                                        End If
                                    Next A
                                    
                                End If
                            End If
                        End If
                    End If
                    Call UnModSeqNum(0)
                End If
            End If
    
            
        End If
        EE = Abs(GetTickCount)
        If Abs(EE - SS) > 500 Then
            SS = EE
            Form1.SSPanel1.Caption = Trim(Str(g)) + " of " + Trim(Str(SEventNumber)) + " events mapped"
            Form1.SSPanel1.Refresh
            Form1.ProgressBar1 = (g / SEventNumber) * 70
            Call UpdateF2Prog
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    Next g
    
    DontRefreshFlag = 0
    
    Seq1 = xSeq1
    Seq2 = xSeq2
    Seq3 = xSeq3
    RelX = xRelX
    RelY = xRelY
    NJFlag = xnjflag
    eexx = Abs(GetTickCount)
    TT = eexx - ssxx
Else
    SS = Abs(GetTickCount)
    If x = 12345 Then
        If PWFlag = 1 Then
            For x = 0 To RSize + 1
                For Y = 0 To RSize + 1
                    RegionMat(x, Y) = MatrixM(x, Y)
                Next Y
            Next x
        Else
            For x = 0 To RSize + 1
                For Y = 0 To RSize + 1
                    RegionMat(x, Y) = MatrixR(x, Y)
                Next Y
            Next x
        End If
    End If
    EE = Abs(GetTickCount)
    TT = EE - SS
    x = x

    
End If

'74219
'33343 - with fillregionmatx
'33156 - change to nest order in quickdist
x = x
Dim MaxN As Single, MinN As Single






If (PWFlag = 0 And DoneMatX(2) = 0) Or (PWFlag = 1 And DoneMatX(1) = 0) Then
    MaxN = FindMaxNS(RSize, RegionMat(0, 0))
    If PWFlag = 0 Then
        MatBound(1) = MaxN
        ReDim MatrixR(RSize + 1, RSize + 1)
        If x = x Then
            UB1 = UBound(RegionMat, 1): UB2 = UBound(RegionMat, 2)
            UB3 = UBound(MatrixR, 1): UB4 = UBound(MatrixR, 2)
            
            Dummy = CopySingleArray(RSize + 1, RSize + 1, UB1, UB2, UB3, UB4, RegionMat(0, 0), MatrixR(0, 0))
        Else
        
            For x = 0 To RSize + 1
                For Y = 0 To RSize + 1
                    MatrixR(x, Y) = RegionMat(x, Y)
                Next Y
            Next x
        End If
    Else
        MatBound(2) = MaxN
        
        
        ReDim MatrixM(RSize + 1, RSize + 1)
        If x = x Then
            UB1 = UBound(RegionMat, 1): UB2 = UBound(RegionMat, 2)
            UB3 = UBound(MatrixM, 1): UB4 = UBound(MatrixM, 2)
            
            Dummy = CopySingleArray(RSize + 1, RSize + 1, UB1, UB2, UB3, UB4, RegionMat(0, 0), MatrixM(0, 0))
        Else
        
            For x = 0 To RSize + 1
                For Y = 0 To RSize + 1
                    MatrixM(x, Y) = RegionMat(x, Y)
                Next Y
            Next x
        End If
    End If

    If MaxN = 0 Then
        If MetTheCriteria = 0 Then
            If UseAll = 0 Then
                If OnlyReassortmentFlag = 0 Then
                    If ReassortmentFlag = 0 Then
                        MsgBox ("None of the accepted recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
                    Else
                        MsgBox ("None of the accepted recombination/reassortment events could be plotted on the matrix. Only recombination/reassortment events where both parents have been identified can be plotted.")
                    End If
                ElseIf OnlyReassortmentFlag = 1 Then
                    MsgBox ("None of the accepted reassortment events could be plotted on the matrix. Only reassortment events where both parents have been identified can be plotted.")
                ElseIf OnlyReassortmentFlag = 2 Then
                    MsgBox ("None of the accepted recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
                End If
            Else
                If OnlyReassortmentFlag = 0 Then
                    If ReassortmentFlag = 0 Then
                        MsgBox ("None of the detected recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
                    Else
                        MsgBox ("None of the detected recombination/reassortment events could be plotted on the matrix. Only recombination/reassortment events where both parents have been identified can be plotted.")
                    End If
                ElseIf OnlyReassortmentFlag = 1 Then
                    MsgBox ("None of the detected reassortment events could be plotted on the matrix. Only reassortment events where both parents have been identified can be plotted.")
                ElseIf OnlyReassortmentFlag = 2 Then
                    MsgBox ("None of the detected recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
                End If
            End If
            Form1.Picture26.Picture = LoadPicture()
        End If
        Form1.ProgressBar1 = 0
        Form1.SSPanel1 = ""
        Call UpdateF2Prog
        Exit Sub
    End If

    Form1.SSPanel1.Caption = "Drawing matrix"
Else
    If PWFlag = 0 Then
        MaxN = MatBound(1)
    Else
        MaxN = MatBound(2)
    End If
End If




    Form1.Picture26.ScaleMode = 3
    Form1.Picture26.AutoRedraw = True
    
    Dim XAddj As Single, PosS(1) As Single, PosE(1) As Single, DistD As Long
    If PWFlag = 0 Then
        DistD = RSize / MatZoom(1)
        PosS(0) = MatCoord(1, 0)
        PosE(0) = PosS(0) + DistD
        PosS(1) = MatCoord(1, 1)
        PosE(1) = PosS(1) + DistD
        If PosE(1) > (UBound(MatrixR, 1) - 1) - 1 Then PosE(1) = (UBound(MatrixR, 1) - 1) - 1
        If PosE(0) > (UBound(MatrixR, 1) - 1) - 1 Then PosE(0) = (UBound(MatrixR, 1) - 1) - 1
       
        If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
        If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
    Else
        DistD = RSize / MatZoom(2)
        PosS(0) = MatCoord(2, 0)
        PosE(0) = PosS(0) + DistD
        PosS(1) = MatCoord(2, 1)
        PosE(1) = PosS(1) + DistD
        If PosE(1) > (UBound(MatrixM, 1) - 1) - 1 Then PosE(1) = (UBound(MatrixM, 1) - 1) - 1
        If PosE(0) > (UBound(MatrixM, 1) - 1) - 1 Then PosE(0) = (UBound(MatrixM, 1) - 1) - 1
       
        If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
        If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
        
    End If
    Form1.Picture26.Picture = LoadPicture()
    XAddj = (Form1.Picture26.ScaleHeight) / DistD
    
    'For B = 1 To 20
        Pict = Form1.Picture26.hdc
        
        If x = 1234 Then
            'Dummy = DrawMats(Pict, MaxN, CurScale, XAddj, UBound(RegionMat, 1), PosS(0), PosE(0), RegionMat(0, 0), HeatMap(0, 0))
            
        Else
            If PWFlag = 0 Then
                Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixR(), HeatMap(), CurScale, MaxN)
            Else
                Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixM(), HeatMap(), CurScale, MaxN)
            End If
        End If
        
    'Next B
    Form1.Picture26.Refresh
    Form1.ProgressBar1 = 0
    Form1.SSPanel1 = ""
    Call UpdateF2Prog
    If PWFlag = 0 Then
        DoneMatX(2) = 1
        If DontDoKey = 0 Then
            Call DoKey(0, MaxN, MinN, 1, "Average parental genetic distance", CurScale) ', "relatedness")
        End If
    Else
        DoneMatX(1) = 1
        If DontDoKey = 0 Then
            
            Call DoKey(0, MaxN, MinN, 2, "Parental genetic distance", CurScale) ', "relatedness")
        End If
    End If
    
    Call UnModNextno
    EE = Abs(GetTickCount)
    TT = EE - SSS
    x = x
    
'    If MetTheCriteria = 0 Then
'        If UseAll = 0 Then
'            If OnlyReassortmentFlag = 0 Then
'                If ReassortmentFlag = 0 Then
'                    MsgBox ("None of the accepted recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
'                Else
'                    MsgBox ("None of the accepted recombination/reassortment events could be plotted on the matrix. Only recombination/reassortment events where both parents have been identified can be plotted.")
'                End If
'            ElseIf OnlyReassortmentFlag = 1 Then
'                MsgBox ("None of the accepted reassortment events could be plotted on the matrix. Only reassortment events where both parents have been identified can be plotted.")
'            ElseIf OnlyReassortmentFlag = 2 Then
'                MsgBox ("None of the accepted recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
'            End If
'        Else
'            If OnlyReassortmentFlag = 0 Then
'                If ReassortmentFlag = 0 Then
'                    MsgBox ("None of the detected recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
'                Else
'                    MsgBox ("None of the detected recombination/reassortment events could be plotted on the matrix. Only recombination/reassortment events where both parents have been identified can be plotted.")
'                End If
'            ElseIf OnlyReassortmentFlag = 1 Then
'                MsgBox ("None of the detected reassortment events could be plotted on the matrix. Only reassortment events where both parents have been identified can be plotted.")
'            ElseIf OnlyReassortmentFlag = 2 Then
'                MsgBox ("None of the detected recombination events could be plotted on the matrix. Only recombination events where both parents have been identified can be plotted.")
'            End If
'        End If
'        Picture26.Picture = LoadPicture()
'    End If
    
    '121 seconds
    '95 seconds
    '50.104 seconds
    '31.8 seconds
    '30.844
    '28.547
    '26.531
    '22.625
    '20.812
    '19.063
    
End Sub
Public Sub DrawmatsVB2(Drawbox As PictureBox, Min, PosE() As Single, PosS() As Single, SX, SY, XAddj, RegionMat() As Single, HeatMap() As Long, CurScale, MaxN)
    Dim StS As Long, RM As Single, PntAPI As POINTAPI, YP As Long, Z As Long, x As Long, Y As Long, Pict As Long, StSX As Long, XAD As Single
    Dim Band As Single, SYP As Long, EYP As Long, XDP As Long, ZDP As Long
    XAD = XAddj
    
   
    
    Drawbox.ScaleMode = 3
    Drawbox.Picture = LoadPicture()
    'XAddj = (drawbox.ScaleHeight) / DistD
    Drawbox.AutoRedraw = True
    
    
    Pict = Drawbox.hdc
    StS = (1 / XAddj) - 1
    If StS < 1 Then StS = 1
    StSX = StS
    
    Dim MR As Single
    MR = MaxN - Min
    Dim YPX As Long, XM As Long
    Dim XD As Single, ZD As Single, ColPix As Long
    'XM = Pos(0) * XAD
    SSX = Abs(GetTickCount)
     
    If XAD <= 1 Then
        'For Y = SY To PosE(1) Step StS
        '
        'Next Y
        
       
        For Y = SY To PosE(1) Step StS
                YP = Int((Y - PosS(1)) * XAD)
                For x = SX To PosE(0) Step StSX
                        
                        If x = x Then
                        
                            Z = GetColPix(CurScale, MR, Y, Pict, PosS(0), PosS(1), XAD, PosE(0), StSX, x, UBound(RegionMat, 1), UBound(HeatMap, 1), Min, RegionMat(0, 0), ColPix, HeatMap(0, 0))
                            
                            If Z <> x Then
                                'SetPixelV Pict, Int((X - PosS(0)) * XAD), Int((Y - PosS(1)) * XAD), ColPix
                            'Else
                                
                                Drawbox.ForeColor = ColPix
                                Dummy = MoveToEx(Pict, Int((x - PosS(0)) * XAD), YP, PntAPI)
                                Dummy = LineTo(Pict, Int((Z - PosS(0)) * XAD) + 1, YP)
                                
                            
                                x = Z
                            End If
                            
                        Else

                            Z = x + StSX
                            RM = RegionMat(x, Y)
                            Do While Z <= PosE(0)
                                If RegionMat(Z, Y) <> RM Then
                                    Exit Do
                                End If
                                Z = Z + StSX
                            Loop
                            Z = Z - StSX

                            If RM >= Min Then
                                If (RM - Min) / MR < 1 Then
                                    ColPix = HeatMap(CurScale, CInt(((RM - Min) / MR) * 1020))
                                Else
                                    ColPix = HeatMap(CurScale, 1020)
                                End If
                            Else
                                ColPix = RGB(128, 128, 128)
                            End If
                            If Z = x Then 'and Then ' And X = 12345 Then

                                SetPixelV Pict, Int((x - PosS(0)) * XAD), Int((Y - PosS(1)) * XAD), ColPix
                            'ElseIf Abs(X - Z) < 2 Then
                            '    SetPixelV Pict, Int((X - PosS(0)) * XAddj), Int((Y - PosS(1)) * XAddj), ColPix
                            '    SetPixelV Pict, Int((Z - PosS(0)) * XAddj), Int((Y - PosS(1)) * XAddj), ColPix
                            Else
                                YP = Int((Y - PosS(1)) * XAddj)

                                Drawbox.ForeColor = ColPix
                                Dummy = MoveToEx(Pict, Int((x - PosS(0)) * XAD), YP, PntAPI)
                                Dummy = LineTo(Pict, Int((Z - PosS(0)) * XAD) + 1, YP)
                                x = Z
                            End If
                        End If
'
                Next x
        Next Y
        'XX = RGB(128, 128, 128)
        'X = X
    Else
        Band = ((Int(XAD) + 1) / 2)
        Dim YPP As Long
        
        ZDP = 0
        ZDP = 0
        For Y = SY To PosE(1)
                
                'YPP =
                SYP = Int((Y - PosS(1)) * XAD - (((XAD) + 1) / 2))
                EYP = Int((Y - PosS(1)) * XAD + (((XAD) + 1) / 2))
                For x = SX To PosE(0)
                        
                        If x = x Then
                        
                            Z = GetColPix2(Band, XDP, ZDP, CurScale, MR, Y, Pict, PosS(0), PosS(1), XAD, PosE(0), StSX, x, UBound(RegionMat, 1), UBound(HeatMap, 1), Min, RegionMat(0, 0), ColPix, HeatMap(0, 0))
                        'XDP = XDP - Band * 2
                        'ZDP = ZDP - 1
                        Else
                            Z = GetColPix2(Band, XDP, ZDP, CurScale, MR, Y, Pict, PosS(0), PosS(1), XAD, PosE(0), StSX, x, UBound(RegionMat, 1), UBound(HeatMap, 1), Min, RegionMat(0, 0), ColPix, HeatMap(0, 0))

                            Z = x + StSX
                            RM = RegionMat(x, Y)
                            Do While Z <= PosE(0)
                                If RegionMat(Z, Y) <> RM Then Exit Do
                                Z = Z + StSX
                            Loop
                            Z = Z - StSX
                            ZD = Z + 0.5
                            XD = x - 0.5



                            
                            XDP = CLng((XD - PosS(0)) * XAD + Band)
                            ZDP = CLng((ZD - PosS(0)) * XAD + 1 + Band)




                            If RM >= Min Then
                                If RM > MR Then RM = MR
                                ColPix = HeatMap(CurScale, CInt(((RM - Min) / MR) * 1020))
                            Else
                                ColPix = RGB(128, 128, 128)
                            End If
                        End If
                        
                        
                     If x = x Then
                        
                        
                        Drawbox.ForeColor = ColPix
                        For YP = SYP To EYP
                            'HeatMap(CurScale, CInt(((RegionMat(X, Y) - Min) / MR) * 1020))
                            YPX = YP + Int(Band)
                            Dummy = MoveToEx(Pict, XDP, YPX, PntAPI)
                            Dummy = LineTo(Pict, ZDP, YPX)
 '
                        Next YP
                        
                       
                     Else
                        Dummy = MoveToEx(Pict, XDP, YPP, PntAPI)
                        Dummy = LineTo(Pict, ZDP, YPP)
                    
                     End If
                       
                        
                        x = Z
                        
                        'End If
                        
                Next x
        Next Y
    End If
    
    Form1.SSPanel6(2).Enabled = True
    
    EE = Abs(GetTickCount)
    TT = EE - SSX '0.219,0.203, 0.172,0.141'first routine
    '0.360, 0.328, 0.312, 0.297, 0.265 second one
    
    '0.249
    '0.515 second one pvy, 0.483,0.343,281
    '1401,795,531,390,281,266,406,218,141,109
    x = x
    '121.500
    '95.828
    '172
    Dim ImageData() As Byte, bm As BITMAP
    
End Sub
Public Sub DrawMatsVB(Drawbox As PictureBox, Min, PosE() As Single, PosS() As Single, SX, SY, XAddj, RegionMat() As Single, HeatMap() As Long, CurScale, MaxN)
    Dim StS As Long, RM As Single, PntAPI As POINTAPI, YP As Long, Z As Long, x As Long, Y As Long, Pict As Long, StSX As Long, XAD As Single
    Dim Band As Single, SYP As Long, EYP As Long, XDP As Long, ZDP As Long
    Dim ImageData() As Byte, bm As BITMAP
    XAD = XAddj
    SSX = Abs(GetTickCount)
   
    Dim SXa As Long, SYa As Long, MinX As Single
    SXa = SX
    SYa = SY
    MinX = Min
    Drawbox.ScaleMode = 3
    Drawbox.Picture = LoadPicture()
    Drawbox.AutoRedraw = True
    GetObject Drawbox.Image, Len(bm), bm
    ReDim ImageData(0 To (bm.bmBitsPixel \ 8) - 1, 0 To bm.bmWidth - 1, 0 To bm.bmHeight - 1)
    
    Pict = Drawbox.hdc
    StS = (1 / XAddj) - 1
    If StS < 1 Then StS = 1
    StSX = StS
    
    Dim MR As Single
    MR = MaxN - Min
    Dim YPX As Long, XM As Long
    Dim XD As Single, ZD As Single, ColPix As Long
    'XM = Pos(0) * XAD
    
     
     
     
'     For X = 0 To UBound(ImageData, 2)
'        For Y = 0 To UBound(ImageData, 3)
'            ImageData(0, X, Y) = 255 - 255 * (ScratchPatch2(X, Y) / MaxV)
'            ImageData(1, X, Y) = 255 - 255 * (ScratchPatch2(X, Y) / MaxV)
'            ImageData(2, X, Y) = 255 - 255 * (ScratchPatch2(X, Y) / MaxV)
'            'If ScratchPatch2(X, Y) <> 0 Then
'            '    X = X
'            'End If
'            X = X
'        Next Y
'    Next X
    Dim b As Long, g As Long, r As Long, XP As Long, H3 As Single, PosE1 As Long, PosE0 As Long, PosS1 As Long, PosS0 As Long, CurScaleX As Long
     PosE1 = PosE(1)
     PosE0 = PosE(0)
     PosS1 = PosS(1)
     PosS0 = PosS(0)
     CurScaleX = CurScale
     SS = Abs(GetTickCount)
    If XAD <= 1 Or x = x Then
        'For Y = SY To PosE(1) Step StS
        '
        'Next Y
        If x = x Then
            If x = 123456 Then
                Dummy = MakeImageData(128, 128, 128, SXa, SYa, PosE1, PosE0, PosS1, PosS0, StS, StSX, CurScaleX, XAD, MinX, MR, UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), UBound(RegionMat, 1), UBound(HeatMap, 1), HeatMap(0, 0), RegionMat(0, 0), ImageData(0, 0, 0))
            Else
                Dummy = MakeImageDataP(128, 128, 128, SXa, SYa, PosE1, PosE0, PosS1, PosS0, StS, StSX, CurScaleX, XAD, MinX, MR, UBound(ImageData, 1), UBound(ImageData, 2), UBound(ImageData, 3), UBound(RegionMat, 1), UBound(HeatMap, 1), HeatMap(0, 0), RegionMat(0, 0), ImageData(0, 0, 0))
            End If
            
            If DebuggingFlag < 2 Then On Error Resume Next
            XAD = CDbl(XAD)
            On Error GoTo 0
        Else
       
            For Y = SY To PosE(1) Step StS
                    YP = Int((Y - PosS(1)) * XAD)
                    If YP <= UBound(ImageData, 3) Then
                        For x = SX To PosE(0) Step StSX
                            XP = Int((x - PosS(0)) * XAD)
                            If XP <= UBound(ImageData, 2) Then
                                'Z = GetColPix(CurScale, MR, Y, Pict, PosS(0), PosS(1), XAD, PosE(0), StSX, X, UBound(RegionMat, 1), UBound(HeatMap, 1), Min, RegionMat(0, 0), ColPix, HeatMap(0, 0))
                                RM = RegionMat(x, Y)
                                If RM >= Min Then
                                    H3 = (RM - Min) / MR
                                    If H3 <= 1 Then
                                        H3 = CLng(H3 * 1020)
                                    Else
                                        H3 = 1020
                                    End If
                                    ColPix = HeatMap(CurScale, H3)
                                    r = Int(ColPix / 65536)
                                    g = Int((ColPix - r * 65536) / 256)
                                    b = Int(ColPix - r * 65536 - g * 256)
                                Else
                                    r = 0
                                    g = 0
                                    b = 0
                                End If
                                ImageData(0, XP, YP) = r
                                ImageData(1, XP, YP) = g
                                ImageData(2, XP, YP) = b
                                x = x
                            End If
                        Next x
                    End If
            Next Y
        
        
        
        
        End If
        
        If ReassortmentFlag = 1 Then
'            Addj = (UBound(RegionMat, 1) / Picture26.ScaleHeight)
'
'            AddonX = (MatCoord(CurMatrixFlag, 0) * MatZoom(CurMatrixFlag)) / Addj
'            AddonY = (MatCoord(CurMatrixFlag, 1) * MatZoom(CurMatrixFlag)) / Addj
'            'XX = MatCoord(CurMatrixFlag, 0)
'            XC = (X + AddonX) / ((Picture26.ScaleHeight) * MatZoom(CurMatrixFlag)) 'CLng((X / Picture26.ScaleHeight) * ((UBound(MatrixM, 1)-1) - 1))
'            YC = (Y + AddonY) / ((Picture26.ScaleHeight) * MatZoom(CurMatrixFlag)) 'CLng((Y / Picture26.ScaleWidth) * ((UBound(MatrixM, 1)-1) - 1))
'
'            XP = CLng((XC * UB) - 0.5)
'            YP = CLng((YC * UB) - 0.5)
            Dim tBP As Single, tBPx As Single, Addj2 As Single, Addj3 As Single, RangeX As Long
            'If XAD >= 2 Then
                RangeX = CLng(XAD / 2)
            'Else
            '    RangeX = 1
            'End If
            For x = 1 To RBPNum - 1
                'XX = UBound(RBPPos, 1)
                If CurMatrixFlag = 13 Or CurMatrixFlag = 12 Then
                    'V1 = XP * SHStep + SHWinLen / 2
                    Addj2 = CLng((SHWinLen / SHStep) / 2) 'accounts for missing windows on the ends
                    'Addj2 = (SHWinLen / 2 / SHStep)
                    Addj3 = Addj2 / 2
                    addj4 = SHWinLen / 2
                    tBPx = RBPPos(x) * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                ElseIf CurMatrixFlag = 0 Then
                    If Z > -1 Then
                        For Z = Z To UBound(VarsitesCM, 1)
                            If VarsitesCM(Z) >= RBPPos(x) Then
                                Z = Z - 1
                                Exit For
                            End If
                            If Z < 0 Then Exit For
                         Next Z
                     End If
                     Addj2 = 0
                     Addj3 = 0
                     'TBP = Z * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                     tBP = (Z / UBound(RegionMat, 1)) * Len(StrainSeq(0))
                     tBPx = tBP * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                     x = x
                ElseIf CurMatrixFlag = 8 Then
                    For Z = Z To UBound(VarsitesMC, 1)
                        If VarsitesMC(Z) >= RBPPos(x) Then
                            Z = Z - 1
                            Exit For
                        End If
                     Next Z
                     Addj2 = 0
                     Addj3 = 0
                     'TBP = Z * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                     tBP = (Z / UBound(RegionMat, 1)) * Len(StrainSeq(0))
                     tBPx = tBP * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                x = x
                ElseIf CurMatrixFlag = 6 Or CurMatrixFlag = 7 Or CurMatrixFlag = 5 Then
                    'varsitesld()y
                    'VarsitesMC() As Long, VarsitesCM() As Long, VarsitesLD() As Long,
                     'XX = UBound(VarsitesLD, 1)
                     'XX = VarsitesLD(100)
                     For Z = Z To UBound(VarsitesLD, 1)
                        If VarsitesLD(Z) >= RBPPos(x) Then
                            Z = Z - 1
                            Exit For
                        End If
                     Next Z
                     Addj2 = 0
                     Addj3 = 0
                     'TBP = Z * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                     tBP = (Z / UBound(RegionMat, 1)) * Len(StrainSeq(0))
                     tBPx = tBP * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                     x = x
                Else
                    Addj2 = 0
                    Addj3 = 0
                    tBPx = RBPPos(x) * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                End If
                If CurMatrixFlag = 3 And Form1.Check1 = 1 Then
                    Dim BkRx As Byte, BkGx As Byte, BkBx As Byte
                    'If XAD >= 2 Then
                        RangeX = CLng(XAD / 2) + 2
                    'Else
                    '    RangeX = 2
                    'End If
                    BkRx = BkR
                    BkGx = BkG
                    BkBx = BkB
                    
                Else
                    
                    BkRx = BkR
                    BkGx = BkG
                    BkBx = BkB
                
                End If
                
                
                tBP = tBPx
                'TBP = RBPPos(X) * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                If tBP >= SX And tBP <= PosE(0) Then
                    tBP = ((tBP - PosS(0)) * XAD)
                    If CLng(tBP) < UBound(ImageData, 2) Then
                        tBP = CLng(tBP)
                        For Y = 0 To UBound(ImageData, 3)
                            For A = tBP - RangeX To tBP + RangeX
                                If A < 0 Then
                                    b = 0
                                ElseIf A > UBound(ImageData, 2) Then
                                    b = UBound(ImageData, 2)
                                Else
                                    b = A
                                End If
                                'YP = Int((Y - PosS(1)) * XAD)
                                'MatrixRR(tbpB, Y) = 0
                                ImageData(0, b, Y) = BkRx
                                ImageData(1, b, Y) = BkGx
                                ImageData(2, b, Y) = BkBx
                            Next A
                        Next Y
                    End If
                End If
                tBP = tBPx 'RBPPos(X) * ((UBound(RegionMat, 1) + Addj3) / (Len(StrainSeq(0)))) - Addj2
                If tBP >= SY And tBP <= PosE(1) Then
                    tBP = ((tBP - PosS(1)) * XAD)
                    If CLng(tBP) < UBound(ImageData, 3) Then
                        tBP = CLng(tBP)
                        For Y = 0 To UBound(ImageData, 2)
                            For A = tBP - RangeX To tBP + RangeX
                                If A < 0 Then
                                    b = 0
                                ElseIf A > UBound(ImageData, 3) Then
                                    b = UBound(ImageData, 3)
                                Else
                                    b = A
                                End If
                                'YP = Int((Y - PosS(1)) * XAD)
                                'MatrixRR(tbpB, Y) = 0
                                ImageData(0, Y, b) = BkRx
                                ImageData(1, Y, b) = BkGx
                                ImageData(2, Y, b) = BkBx
                            Next A
                        Next Y
                    End If
                End If
            Next x
        
        End If
        
        'XX = RGB(128, 128, 128)
        'X = X
    Else
        Band = ((Int(XAD) + 1) / 2)
        Dim YPP As Long
        
        ZDP = 0
        ZDP = 0
        For Y = SY To PosE(1)
                
                'YPP =
                SYP = Int((Y - PosS(1)) * XAD - (((XAD) + 1) / 2))
                EYP = Int((Y - PosS(1)) * XAD + (((XAD) + 1) / 2))
                For x = SX To PosE(0)
                        
                        If x = x Then
                        
                        Z = GetColPix2(Band, XDP, ZDP, CurScale, MR, Y, Pict, PosS(0), PosS(1), XAD, PosE(0), StSX, x, UBound(RegionMat, 1), UBound(HeatMap, 1), Min, RegionMat(0, 0), ColPix, HeatMap(0, 0))
                        'XDP = XDP - Band * 2
                        'ZDP = ZDP - 1
                        Else
                            Z = GetColPix2(Band, XDP, ZDP, CurScale, MR, Y, Pict, PosS(0), PosS(1), XAD, PosE(0), StSX, x, UBound(RegionMat, 1), UBound(HeatMap, 1), Min, RegionMat(0, 0), ColPix, HeatMap(0, 0))

                            Z = x + StSX
                            RM = RegionMat(x, Y)
                            Do While Z <= PosE(0)
                                If RegionMat(Z, Y) <> RM Then Exit Do
                                Z = Z + StSX
                            Loop
                            Z = Z - StSX
                            ZD = Z + 0.5
                            XD = x - 0.5



                            
                            XDP = CLng((XD - PosS(0)) * XAD + Band)
                            ZDP = CLng((ZD - PosS(0)) * XAD + 1 + Band)




                            If RM >= Min Then
                                If RM > MR Then RM = MR
                                ColPix = HeatMap(CurScale, CInt(((RM - Min) / MR) * 1020))
                            Else
                                ColPix = RGB(128, 128, 128)
                            End If
                        End If
                        
                        
                     If x = x Then
                        
                        
                        Drawbox.ForeColor = ColPix
                        For YP = SYP To EYP
                            'HeatMap(CurScale, CInt(((RegionMat(X, Y) - Min) / MR) * 1020))
                            YPX = YP + Int(Band)
                            Dummy = MoveToEx(Pict, XDP, YPX, PntAPI)
                            Dummy = LineTo(Pict, ZDP, YPX)
 '
                        Next YP
                        
                       
                     Else
                        Dummy = MoveToEx(Pict, XDP, YPP, PntAPI)
                        Dummy = LineTo(Pict, ZDP, YPP)
                    
                     End If
                       
                        
                        x = Z
                        
                        'End If
                        
                Next x
        Next Y
    End If
    
    SetBitmapBits Drawbox.Image, bm.bmWidthBytes * bm.bmHeight, ImageData(0, 0, 0)
    Drawbox.Refresh
    'Drawbox.Refresh
    
    Form1.SSPanel6(2).Enabled = True
    EE = Abs(GetTickCount)
    
    
    
    
    TT = EE - SS '0.219,0.203, 0.172,0.141'first routine
    '0.360, 0.328, 0.312, 0.297, 0.265 second one
    
    '0.249
    '0.515 second one pvy, 0.483,0.343,281
    
    '873,592,343,265,187,187,374,187,141
    
    x = x
    '121.500
    '95.828
    '172
End Sub
Public Sub DrawBPMatrix()
Dim RSize As Long, SConvert As Single

RSize = Len(StrainSeq(0))
If RSize > 1000 Then RSize = 1000
SConvert = RSize / Len(StrainSeq(0))

Dim UseAll As Byte

If DoneMatX(4) = 0 Then
    Dim AccX As Byte, NAccX As Byte
    AccX = 0
    NAccX = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            
            If XoverList(x, Y).Accept = 1 Then
                AccX = 1
                If NAccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            ElseIf XoverList(x, Y).Accept = 0 Then
                NAccX = 1
                If AccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            End If
            
        Next Y
        
    Next x
    
    
    If AccX = 1 And NAccX = 1 Then
        If CLine = "" Or CLine = " " Then
            Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a matrix")
        Else
            Response = 7
        End If
        If Response = 6 Then
            UseAll = 0
        Else
            UseAll = 1
        End If
    Else
        UseAll = 1
    End If
    
    If ReassortmentFlag > 0 Then
        Dim Segbound() As Byte
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                tBP = RBPPos(x)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
        
        Dim ReassortmentNo As Long, RecombinationNo As Long
        
        For x = 0 To SEventNumber
            
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or UseAll = 1 Then
                If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
                    ReassortmentNo = ReassortmentNo + 1
                Else
                    RecombinationNo = RecombinationNo + 1
                End If
                If RecombinationNo > 0 And ReassortmentNo > 0 Then
                    Exit For
                End If
            End If
        Next x
        If RecombinationNo > 0 And ReassortmentNo > 0 Then
            Response = MsgBox("Both reassortment and recombination events have been detected. Would you like to only consider the reassortment events (i.e. the recombination events will be ignored)?", vbYesNo, "Construct a matrix")
            If Response = 7 Then
                Response = MsgBox("OK. So would you like to only consider the recombination events then? If you press 'no' then both the recombination and reassortment events will be considered.", vbYesNo, "Construct a matrix")
                If Response = 7 Then
                    OnlyReassortmentFlag = 0
                Else
                    OnlyReassortmentFlag = 2
                End If
            Else
                OnlyReassortmentFlag = 1
            End If
        Else
            OnlyReassortmentFlag = 0
        End If
    Else
        OnlyReassortmentFlag = 0
    End If
    ReDim MatrixBP(RSize + 1, RSize + 1)
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, Win As Long
        
    
    Dim PermutationX As Long
    PermutationX = 1000
    ENumb = SEventNumber
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
        
    Dim BPV() As Single
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
        
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                    BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                End If
            End If
        Next Y
    Next x
    
    Dim PValCon As Single
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
        
        
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Enu = SuperEventList(XoverList(x, Y).Eventnumber)
           ' If Enu = 2 Then
           '     X = X
           ' End If
            NC = 0
            For Z = 0 To AddNum - 1
                If BPV(Enu, Z) < LowestProb Then
                    NC = NC + 1
                End If
            Next Z
                
            If XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And (XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13) And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                If OnlyReassortmentFlag = 0 Then
                    Excl(Enu) = 1
                ElseIf OnlyReassortmentFlag = 1 Then 'only reassortment
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) = 1 Then
                        Excl(Enu) = 1
                    End If
                ElseIf OnlyReassortmentFlag = 2 Then 'only recombination
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) <> 1 And Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) <> 1 Then
                        Excl(Enu) = 1
                    End If
                End If
            
            End If
            x = x
        Next Y
    Next x
        
        
    Dim BPos() As Long, APos() As Long, TypeSeq
    ReDim APos(Len(StrainSeq(0))), BPos(Len(StrainSeq(0)))
    
    TypeSeq = 0
    If TypeSeq > PermNextno Then TypeSeq = 0
        
    Dim OS1 As Long, SSB As Long
    ltx = Abs(GetTickCount)
    For x = 1 To Len(StrainSeq(0))
        If SeqSpacesInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
           
            OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
            Open "RDP5SSFile" + UFTag For Binary As #FF
            
            Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
            
            
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            SSB = SeqSpaces(x, TypeSeq)
            'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
        End If
        APos(x) = x - SSB
        BPos(x - SSB) = x
        ctx = Abs(GetTickCount)
        If Abs(ctx - ltx) > 500 Then
            ltx = ctx
            Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(Len(StrainSeq(0)))) + " sites mapped to reference sequence (" + OriginalName(TypeSeq) + ")"
            
        End If
    Next x
    If x = 12345567890# Then
        Win = 200
        b = 0
        C = 0
        If BPCvalFlag = 0 Or x = x Then
            BPCvalFlag = 1
            ReDim BPCVal(1, 1)
            Dim DN As Long
            DN = 1
            Call RecombMapPermsB(DN, APos(), BPos(), Excl(), BPCVal(), Win, PermutationX, 3)
            Z = Z
        End If
    End If
    If AbortFlag = 1 Then
        Screen.MousePointer = 0
        Form1.SSPanel1.Caption = ""
        Form1.ProgressBar1 = 0
        Call UpdateF2Prog
        AbortFlag = 0
        Exit Sub
    End If
    ZZ = 0
    Win = MatWinSize / 2
    'Make exclusions
    Dim RS1 As Long, LS1 As Long, RS2 As Long, LS2 As Long
    For x = 1 To ENumb
        
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) And XoverList(BestEvent(x, 0), BestEvent(x, 1)).SBPFlag = 0 Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
               
                
            D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
            P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
            P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
            ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
            EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
            LS1 = -1: LS2 = -1
            For A = EN - Win + 1 To EN + Win
                    
                    RS1 = CInt(A * SConvert)
                    
                    If RS1 < 1 Then RS1 = RSize + RS1
                    If RS1 > RSize Then RS1 = RS1 - RSize
                    If LS1 <> RS1 Then
                        
                        LS1 = RS1
                    
                        For b = ST - Win + 1 To ST + Win
                            If Sqr((A - EN) ^ 2 + (b - ST) ^ 2) <= Win Then
                                RS2 = CInt(b * SConvert)
                                If RS2 < 1 Then RS2 = RSize + RS2
                                If RS2 > RSize Then RS2 = RS2 - RSize
                                If LS2 <> RS2 Then
                                    
                                    LS2 = RS2
                                    MatrixBP(RS2, RS1) = MatrixBP(RS2, RS1) + 1
                                    MatrixBP(RS1, RS2) = MatrixBP(RS1, RS2) + 1
                                End If
                            End If
                        Next b
                    End If
            Next A
                
            
    
            
        End If
        
        Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(SEventNumber)) + " breakpoints mapped"
        Form1.ProgressBar1 = (x / SEventNumber) * 100
        Call UpdateF2Prog
    Next x
    Form1.ProgressBar1 = 100
    Call UpdateF2Prog
    DoneMatX(4) = 1
    
     
        Form1.Picture26.ScaleMode = 3
        'Form1.Picture26.Picture = LoadPicture()
        Form1.Picture26.AutoRedraw = True
       ' Form1.Picture26.ScaleHeight = Form1.Picture26.ScaleWidth
        
        Dim XAddj As Single
        
        
        Dim MaxN As Single
            MaxN = FindMaxNS(RSize, MatrixBP(0, 0))
            'MaxN = MaxN + 1
            MatBound(4) = MaxN
        Form1.SSPanel1.Caption = "Drawing matrix"
    Else
        MaxN = MatBound(4)
    End If
    Form1.Picture26.Picture = LoadPicture()
    
    
    Dim PosS(1) As Single, PosE(1) As Single, DistD As Long
        XAddj = (Form1.Picture26.ScaleHeight) / RSize
        DistD = RSize / MatZoom(4)
        PosS(0) = MatCoord(4, 0)
        PosE(0) = PosS(0) + DistD
        PosS(1) = MatCoord(4, 1)
        PosE(1) = PosS(1) + DistD
        If PosE(1) > (UBound(MatrixBP, 1) - 1) - 1 Then PosE(1) = (UBound(MatrixBP, 1) - 1) - 1
        If PosE(0) > (UBound(MatrixBP, 1) - 1) - 1 Then PosE(0) = (UBound(MatrixBP, 1) - 1) - 1
       
        If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
        If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
        
        If MaxN > 4 Then
            MaxN = CLng((MaxN / 4) + 0.5) * 4
        ElseIf MaxN >= 4 Then
            MaxN = CLng((MaxN / 2) + 0.5) * 2
        Else
            MaxN = 2
        End If
        Form1.Picture26.Picture = LoadPicture()
    XAddj = (Form1.Picture26.ScaleHeight) / DistD
    If x = 12345 Then
        
    Else
        If x = x Then
            Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixBP(), HeatMap(), CurScale, MaxN)
        Else
    
            RangeN = MaxN - MinN
        'For B = 1 To 20
            SS = Abs(GetTickCount)
            Pict = Form1.Picture26.hdc
            For x = 1 To RSize 'Step 20
                For Y = x To RSize 'Step 20
                    'Form1.Picture26.PSet (CInt(X * XAddj), CInt(Y * XAddj)), heatmap(curscale,CInt((matrixbp(X, Y) / MaxN) * 1020))
                    'Form1.Picture26.PSet (CInt(Y * XAddj), CInt(X * XAddj)), heatmap(curscale,CInt((matrixbp(X, Y) / MaxN) * 1020))
                    SetPixelV Pict, CInt(x * XAddj), CInt(Y * XAddj), HeatMap(CurScale, CInt((MatrixBP(x, Y) / MaxN) * 1020))
                    SetPixelV Pict, CInt(Y * XAddj), CInt(x * XAddj), HeatMap(CurScale, CInt((MatrixBP(x, Y) / MaxN) * 1020))
                Next Y
                Form1.Picture26.Refresh
                Form1.ProgressBar1 = 20 + (x / RSize) * 80
                Call UpdateF2Prog
            Next x
        End If
    End If
    If DontDoKey = 0 Then
        Call DoKey(0, MaxN, MinN, 4, "Number of breakpoints", CurScale)
    End If
    Form1.Picture26.Refresh
        EE = Abs(GetTickCount)
        TT = EE - SS
        x = x
    'Next B
    Form1.ProgressBar1 = 0
    Form1.SSPanel1 = ""
    Call UpdateF2Prog
End Sub
Public Sub DoKey(DiscF, MaxN, MinN, TF, Cap1 As String, CScale)

Dim PH As Long, LongCap As Long, ML As Long


For x = 0 To 4
    'XX = Form1.Line1(X).Visible
    Form1.Line1(x).Visible = False
Next x

'Form1.Picture17.Top = Form1.Picture29.Top + 10 * Screen.TwipsPerPixelY
'Exit Sub


Dim tMaxN As Long
tMaxN = MaxN

'MaxN = 1
If DiscF = 3 Then
        Form1.Label6(0).Caption = "Hot p < 0.01"
        Form1.Label6(1).Caption = "Hot p < 0.05"
        Form1.Label6(2).Caption = "p > 0.05"
        Form1.Label6(3).Caption = "Cold p < 0.05"
        Form1.Label6(4).Caption = "Cold p < 0.01"
        For x = 0 To 4
            Form1.Line1(x).Visible = True
        Next x

Else
    If MaxN >= 3 Or TF = 1 Or TF = 2 Or DiscF = 1 Then
        Form1.Label6(0).Caption = CLng((MaxN) * 1000) / 1000
        Form1.Label6(1).Caption = CLng((MaxN - (MaxN - MinN) / 4) * 1000) / 1000
        Form1.Label6(2).Caption = CLng((MaxN - (MaxN - MinN) / 2) * 1000) / 1000
        Form1.Label6(3).Caption = CLng((MinN + (MaxN - MinN) / 4) * 1000) / 1000
        Form1.Label6(4).Caption = CLng(MinN * 1000) / 1000
        For x = 0 To 4
            Form1.Line1(x).Visible = True
        Next x
    
    ElseIf MaxN = 2 Then
        Form1.Label6(0).Caption = CLng((MaxN) * 1000) / 1000
        Form1.Label6(1).Caption = "" 'CLng((MaxN - (MaxN - MinN) / 4) * 1000) / 1000
        Form1.Label6(2).Caption = CLng((MaxN - (MaxN - MinN) / 2) * 1000) / 1000
        Form1.Label6(3).Caption = "" 'CLng((MinN + (MaxN - MinN) / 4) * 1000) / 1000
        Form1.Label6(4).Caption = CLng(MinN * 1000) / 1000
        
        Form1.Line1(0).Visible = True
        Form1.Line1(2).Visible = True
        Form1.Line1(4).Visible = True
        
    ElseIf MaxN = 1 Then
        Form1.Label6(0).Caption = ""
        Form1.Label6(1).Caption = "1"
        Form1.Label6(2).Caption = ""
        Form1.Label6(3).Caption = "0"
        Form1.Label6(4).Caption = ""
        
        Form1.Line1(1).Visible = True
        Form1.Line1(3).Visible = True
    End If
End If
ML = 0: LongCap = 0
For x = 0 To 4
    If Len(Form1.Label6(x).Caption) > ML Then
        ML = Len(Form1.Label6(x).Caption)
        LongCap = x
        
    End If
Next x
'
If Form1.Picture17.Top <> Form1.Picture29.Top + 10 * Screen.TwipsPerPixelY Then
    Diff = Form1.Picture17.Top - (Form1.Picture29.Top + 10 * Screen.TwipsPerPixelY)
    Form1.Picture17.Top = Form1.Picture17.Top - Diff
    For x = 0 To 4
        Form1.Line1(x).Y1 = Form1.Line1(x).Y1 - Diff
        Form1.Line1(x).Y2 = Form1.Line1(x).Y2 - Diff
        Form1.Label6(x).Top = Form1.Label6(x).Top - Diff
    Next x
    
End If


Form1.Picture18.AutoRedraw = 1
Form1.Picture18.Picture = LoadPicture()

Form1.Picture18.ScaleMode = 3
Form1.Picture18.CurrentX = 11 '(Form1.Picture18.Width / Screen.TwipsPerPixelY) - 5
Form1.Picture18.FontSize = 5
TW = ((Form1.Picture18.TextWidth(Cap1) * 1.3) / Screen.TwipsPerPixelX) * Screen.TwipsPerPixelY
Form1.Picture18.Height = TW * Screen.TwipsPerPixelY
'If TW > Form1.Picture18.Height / Screen.TwipsPerPixelY Then
'    Form1.Picture18.Height = TW * Screen.TwipsPerPixelY
'
'End If
Form1.Picture18.Height = Form1.Picture17.Height
Form1.Picture18.Top = Form1.Picture18.Top - (Form1.Picture18.Height - Form1.Picture17.Height) / 2
Form1.Picture18.CurrentY = ((Form1.Picture18.Height / Screen.TwipsPerPixelY) - TW) / 2
Form1.Picture18.Left = Form1.Label6(LongCap).Left + Form1.Label6(LongCap).Width + 50 '+ ((Form1.SSPanel6(2).Width - 50)-(Form1.Label6(LongCap).left + Form1.Label6(LongCap).Width + 50)/2 '((Form1.SSPanel6(2).Width - 50 - Form1.Picture18.Width) - Form1.Label6(LongCap).left + Form1.Label6(LongCap).Width) / 2
If Form1.Picture18.Top < Form1.Picture29.Top Then
    Diff = Form1.Picture29.Top - Form1.Picture18.Top
    Form1.Picture17.Top = Form1.Picture17.Top + Diff
    Form1.Picture18.Top = Form1.Picture18.Top + Diff
    For x = 0 To 4
        Form1.Line1(x).Y1 = Form1.Line1(x).Y1 + Diff
        Form1.Line1(x).Y2 = Form1.Line1(x).Y2 + Diff
        Form1.Label6(x).Top = Form1.Label6(x).Top + Diff
    Next x
End If
If F1MDF = 0 Then
    Form1.Check1.Top = Form1.Picture17.Top + Form1.Picture17.Height + 50
    Form1.VScroll5.Top = Form1.Check1.Top + Form1.Check1.Height + 50
    If (Form1.Picture29.Top + Form1.Picture29.Height - Form1.VScroll5.Top) > 0 Then
        Form1.VScroll5.Height = (Form1.Picture29.Top + Form1.Picture29.Height - Form1.VScroll5.Top)
    Else
        Form1.VScroll5.Height = 1
    End If
    If Form1.VScroll5.Top > Form1.Picture18.Top + Form1.Picture18.Height + 50 Then
        Form1.SSPanel15.Top = Form1.VScroll5.Top
    Else
        Form1.SSPanel15.Top = Form1.Picture18.Top + Form1.Picture18.Height + 50
    End If
    If Form1.Picture29.Top + Form1.Picture29.Height - Form1.SSPanel15.Top > 0 Then
        Form1.SSPanel15.Height = Form1.Picture29.Top + Form1.Picture29.Height - Form1.SSPanel15.Top
    Else
        Form1.SSPanel15.Height = 1
    End If
End If
Dim LOSpace As Single, Extra As Single
LOSpace = Form1.SSPanel15.Height - ((Form1.Label7(0).Height - 50) * 3)
LOSpace = LOSpace / 4
'XX = Form1.Label7(0).Height
If LOSpace < 0 Then
    Extra = (LOSpace * 4) / 2
    LOSpace = 0
    
Else
    Extra = 0
End If
For x = 0 To 2
    'Form1.Label7(X).Top = 100 + ((Form1.SSPanel15.Height - 100) / 3) * (X)
    Form1.Label7(x).Top = ((Form1.Label7(0).Height - 50) * (x)) + (Extra * x) + LOSpace * (x + 1)
    
Next x

Call DoText(Form1.Picture18, Form1.Picture18.Font, Cap1, 270)

Form1.Picture17.ScaleMode = 3
Form1.Picture17.AutoRedraw = True

PH = Form1.Picture17.ScaleHeight

If DiscF = 3 Then
    Form1.Picture17.Line (0, 0)-(Form1.Picture17.Width, PH / 5), HeatMap(CScale, 1020), BF
    Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, 0)-(Form1.Picture26.ScaleWidth, PH / 5), HeatMap(CScale, 1020), BF
    
    Form1.Picture17.Line (0, (PH / 5))-(Form1.Picture17.Width, (PH / 5) * 2), HeatMap(CScale, (CInt(MaxN * 0.95) - 1) / MaxN * 1020), BF
    Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, PH / 5)-(Form1.Picture26.ScaleWidth, (PH / 5) * 2), HeatMap(CScale, (CInt(MaxN * 0.95) - 1) / MaxN * 1020), BF
    
    Form1.Picture17.Line (0, (PH / 5) * 2)-(Form1.Picture17.Width, (PH / 5) * 3), RGB(128, 128, 128), BF
    Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, (PH / 5) * 2)-(Form1.Picture26.ScaleWidth, (PH / 5) * 3), RGB(128, 128, 128), BF
    
    Form1.Picture17.Line (0, (PH / 5) * 3)-(Form1.Picture17.Width, (PH / 5) * 4), HeatMap(CScale, (CInt(MaxN * 0.05) + 1) / MaxN * 1020), BF
    Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, (PH / 5) * 3)-(Form1.Picture26.ScaleWidth, (PH / 5) * 4), HeatMap(CScale, (CInt(MaxN * 0.05) + 1) / MaxN * 1020), BF
    
    Form1.Picture17.Line (0, (PH / 5) * 4)-(Form1.Picture17.Width, (PH / 5) * 5), HeatMap(CScale, 0), BF
    Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, (PH / 5) * 4)-(Form1.Picture26.ScaleWidth, (PH / 5) * 5), HeatMap(CScale, 0), BF
Else
    If MaxN >= 3 Or TF = 1 Or TF = 2 Or DiscF = 1 Or TF = 12 Then
        For x = 0 To PH
            Form1.Picture17.Line (0, x)-(Form1.Picture17.Width, x), HeatMap(CScale, 1020 - CInt((x / PH) * 1020))
            Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, x)-(Form1.Picture26.ScaleWidth, x), HeatMap(CScale, 1020 - CInt((x / PH) * 1020))
            If DiscF = 1 Then
                Form2.Picture1.Line (Form1.Picture26.ScaleWidth - 15, x)-(Form1.Picture26.ScaleWidth, x), HeatMap(CScale, 1020 - CInt((x / PH) * 1020))

            End If
        Next x
    ElseIf MaxN = 2 Then
        For x = 0 To PH / 3
            Form1.Picture17.Line (0, x)-(Form1.Picture17.Width, x), HeatMap(CScale, 1020)
            Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, x)-(Form1.Picture26.ScaleWidth, x), HeatMap(CScale, 1020)
        Next x
        For x = PH / 3 To (PH / 3) * 2
            Form1.Picture17.Line (0, x)-(Form1.Picture17.Width, x), HeatMap(CScale, 510)
            Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, x)-(Form1.Picture26.ScaleWidth, x), HeatMap(CScale, 510)
        Next x
        For x = (PH / 3) * 2 To PH
            Form1.Picture17.Line (0, x)-(Form1.Picture17.Width, x), HeatMap(CScale, 0)
            Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, x)-(Form1.Picture26.ScaleWidth, x), HeatMap(CScale, 0)
        Next x
    ElseIf MaxN = 1 Then
        Form1.Picture17.Line (0, 0)-(Form1.Picture17.Width, PH / 2), HeatMap(CScale, 1020), BF
        Form1.Picture17.Line (0, PH / 2)-(Form1.Picture17.Width, PH), HeatMap(CScale, 0), BF
        Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, 0)-(Form1.Picture26.ScaleWidth, PH / 2), HeatMap(CScale, 1020), BF
        Form1.Picture26.Line (Form1.Picture26.ScaleWidth - 15, PH / 2)-(Form1.Picture26.ScaleWidth, PH), HeatMap(CScale, 0), BF
    End If
End If
Form1.Picture17.ScaleMode = 1
Form1.Picture17.Refresh

For x = 0 To 4
    Form1.Label6(x).Visible = True
Next x
MaxN = tMaxN
End Sub

Public Function GetCritChi(Target, DF As Integer)
hPrb = Target * 1.000000001
lPrb = Target * 0.999999999
Dim HMChi As Double
'Calculate critical Chi
HMChi = 5
LastChi = 1
TPVal = 10
Do While TPVal > lPrb
   HMChi = HMChi * 2
   oHMChi = HMChi
   TPVal = chi2(HMChi, DF)
   HMChi = oHMChi
   If TPVal = 10 ^ -20 Then
      lPrb = TPVal
      Exit Do
    End If
    
Loop
LastLoChi = 0
LastHiChi = HMChi * 2
x = x
Do
    oHMChi = HMChi
    TPVal = chi2(HMChi, DF)
     HMChi = oHMChi
    If TPVal < lPrb Then
        TempChi = HMChi
        HMChi = HMChi - (HMChi - LastLoChi) / 2
        
        If HMChi = TempChi Then Exit Do
        LastHiChi = TempChi
    ElseIf TPVal > hPrb Then
        TempChi = HMChi
        HMChi = HMChi + (LastHiChi - HMChi) / 2
        oHMChi = HMChi
        If HMChi = TempChi Then Exit Do
        LastLoChi = TempChi
    Else
        Exit Do
    End If
    
Loop

'XX = chi2(1.5, 4)
x = x
GetCritChi = HMChi

End Function

Public Sub DrawRegionMatrix()
Dim RSize As Long, SConvert As Single, MatrixRRX() As Single, LegendType As Byte, CoV1 As Single, CoV2 As Single, ITots() As Single
Dim UseAll As Byte
ssxx = Abs(GetTickCount)
RSize = Len(StrainSeq(0))
If RSize > 1000 Then RSize = 1000
SConvert = RSize / Len(StrainSeq(0))


Call UnModNextno
Call UnModSeqNum(0)

ReDim MatrixRRX(RSize + 1, RSize + 1)

Dim PermutationX As Long
    
PermutationX = MatPermNo

If DoneMatX(3) = 0 Then
    Form1.SSPanel1.Caption = "Making recombinant region count matrix"
    Dim AccX As Byte, NAccX As Byte
    AccX = 0
    NAccX = 0
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            
            If XoverList(x, Y).Accept = 1 Then
                AccX = 1
                If NAccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            ElseIf XoverList(x, Y).Accept = 0 Then
                NAccX = 1
                If AccX = 1 Then
                    x = NextNo + 1
                    Exit For
                End If
            End If
            
        Next Y
        
    Next x
    
    
    If AccX = 1 And NAccX = 1 Then
        Form1.Refresh
        If CLine = "" Or CLine = " " Then
            Response = MsgBox("Would you like to only consider the manually 'accepted' recombination events (i.e. those represented by coloured blocks surrounded with a red border in the bottom right panel)? Pressing 'Yes' will result in the matrix being constructed based only on accepted recombination events. Pressing 'No' will result in the matrix being constructed based only on all recombination events.", vbYesNo, "Construct a matrix")
        Else
            Response = 7
        End If
        If Response = 6 Then
            UseAll = 0
        Else
            UseAll = 1
        End If
    Else
        UseAll = 1
    End If
    
    
    If ReassortmentFlag > 0 Then
        Dim Segbound() As Byte
        ReDim Segbound(Len(StrainSeq(0)))
        If ReassortmentFlag = 1 Then
            For x = 0 To RBPNum
                'XX = UBound(RBPPos, 1)
                tBP = RBPPos(x)
                Segbound(RBPPos(x)) = 1
            Next x
        End If
        
        Dim ReassortmentNo As Long, RecombinationNo As Long
        
        For x = 0 To SEventNumber
            
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or UseAll = 1 Then
                If Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning) = 1 Then
                    ReassortmentNo = ReassortmentNo + 1
                Else
                    RecombinationNo = RecombinationNo + 1
                End If
                If RecombinationNo > 0 And ReassortmentNo > 0 Then
                    Exit For
                End If
            End If
        Next x
        If RecombinationNo > 0 And ReassortmentNo > 0 Then
            Response = MsgBox("Both reassortment and recombination events have been detected. Would you like to only consider the reassortment events (i.e. the recombination events will be ignored)?", vbYesNo, "Construct a matrix")
            If Response = 7 Then
                Response = MsgBox("OK. So would you like to only consider the recombination events then? If you press 'no' then both the recombination and reassortment events will be considered.", vbYesNo, "Construct a matrix")
                If Response = 7 Then
                    OnlyReassortmentFlag = 0
                Else
                    OnlyReassortmentFlag = 2
                End If
            Else
                OnlyReassortmentFlag = 1
            End If
        Else
            OnlyReassortmentFlag = 0
        End If
    Else
        OnlyReassortmentFlag = 0
    End If
    
    ReDim MatrixRR(RSize + 1, RSize + 1)
    Dim Size As Long, D As Long, P1 As Long, P2 As Long, Win As Long
        
    
    
    'PermutationX = 100
    ENumb = SEventNumber
    
    Dim Excl() As Byte, Enu As Long, NC As Long
    ReDim Excl(SEventNumber), PCount(SEventNumber, AddNum)
        
    Dim BPV() As Single
    ReDim BPV(SEventNumber, AddNum)
    For x = 1 To SEventNumber
        For Y = 0 To AddNum
            BPV(x, Y) = LowestProb
        Next Y
    Next x
        
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            If XoverList(x, Y).ProgramFlag <= AddNum - 1 Then
                If BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0 Then
                    BPV(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = XoverList(x, Y).Probability
                End If
            End If
        Next Y
    Next x
    
    Dim PValCon As Single
    For x = 1 To SEventNumber
        For Y = 0 To AddNum - 1
            If BPV(x, Y) = LowestProb And Confirm(x, Y) > 0 Then
                
                PValCon = ConfirmP(x, Y) / Confirm(x, Y)
                PValCon = 10 ^ (-PValCon)
                
                'ConfirmP(X, Y) = PValCon
                If BPV(x, Y) > PValCon Then
                    BPV(x, Y) = PValCon
                End If
            End If
        Next Y
    Next x
        
        
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
            Enu = SuperEventList(XoverList(x, Y).Eventnumber)
                
            NC = 0
            For Z = 0 To AddNum - 1
                If BPV(Enu, Z) < LowestProb Then
                        
                    NC = NC + 1
                        
                End If
            Next Z
            
            If XoverList(x, Y).Probability > 0 And XoverList(x, Y).Probability < LowestProb And NC > ConsensusProg And XoverList(x, Y).Accept <> 2 And XoverList(x, Y).ProgramFlag <= AddNum - 1 And XoverList(x, Y).MissIdentifyFlag <> 3 And XoverList(x, Y).MissIdentifyFlag <> 13 And (XoverList(x, Y).Accept = 1 Or UseAll = 1) Then
                If OnlyReassortmentFlag = 0 Then
                    Excl(Enu) = 1
                ElseIf OnlyReassortmentFlag = 1 Then 'only reassortment
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) = 1 Or Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) = 1 Then
                        Excl(Enu) = 1
                    End If
                ElseIf OnlyReassortmentFlag = 2 Then 'only recombination
                    If Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Ending) <> 1 And Segbound(XoverList(BestEvent(Enu, 0), BestEvent(Enu, 1)).Beginning) <> 1 Then
                        Excl(Enu) = 1
                    End If
                End If
            
            End If
        Next Y
    Next x
        
        
    Dim BPos() As Long, APos() As Long, TypeSeq
    ReDim APos(Len(StrainSeq(0))), BPos(Len(StrainSeq(0)))
    
    TypeSeq = 0
    If TypeSeq > PermNextno Then TypeSeq = 0
        
    Dim OS1 As Long, SSB As Long
    For x = 1 To Len(StrainSeq(0))
        If SeqSpacesInFileFlag = 1 Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
           
            OS1 = TypeSeq * (Len(StrainSeq(0)) + 3)
            Open "RDP5SSFile" + UFTag For Binary As #FF
            
            Get #FF, (((x + OS1) - 1) * 4) + 1, SSB
            
            
            Close #FF
            ChDrive oDirX
            ChDir oDirX
        Else
            SSB = SeqSpaces(x, TypeSeq)
            'SSE = SeqSpaces(XOverlist(X, Y).Ending, X)
        End If
        APos(x) = x - SSB
        BPos(x - SSB) = x
        SSX = Abs(GetTickCount)
        If Abs(SSX - eex) > 500 Then
            eex = SSX
            Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(Len(StrainSeq(0)))) + " sites loaded"
            Form1.Refresh
        End If
        
    Next x
    
    ZZ = 0
        
    'Make exclusions
    Dim RS1 As Long, LS1 As Long, RS2 As Long, LS2 As Long
    SS = Abs(GetTickCount)
    Dim LastTick As Long, CurTick As Long
    LastTick = 0
    
    Dim SCArray() As Long
    ReDim SCArray(Len(StrainSeq(0)))
    For x = 0 To Len(StrainSeq(0))
        SCArray(x) = CInt(x * SConvert)
        
    Next x
    
    For x = 1 To ENumb
        
        If Excl(x) = 1 And (BestEvent(x, 0) > 0 Or BestEvent(x, 1) > 0) Then
            ZZ = ZZ + 1
            CNum = 0
            SEN = x 'SuperEventlist(XOverList(BestEvent(X, 0), BestEvent(X, 1)).Eventnumber)
               
            If XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept = 1 Or (UseAll = 1 And XoverList(BestEvent(x, 0), BestEvent(x, 1)).Accept <> 2) Then
                D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
                P1 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
                P2 = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
                ST = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
                EN = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
                If ReassortmentFlag = 1 Then
                    Do
                        GoOn = 0
                        If Segbound(ST) = 1 Then
                            If ST < Len(StrainSeq(0)) Then
                                ST = ST + 1
                            Else
                                ST = 1
                            End If
                        Else
                            GoOn = GoOn + 1
                        End If
                        If Segbound(EN) = 1 Then
                            If EN > 1 Then
                                EN = EN - 1
                            Else
                                EN = Len(StrainSeq(0))
                            End If
                        Else
                            GoOn = GoOn + 1
                        End If
                        If GoOn = 2 Then Exit Do
                    Loop
                End If
                If x = x Then
               
                    
                    Dummy = MakeRecCMatrix(Len(StrainSeq(0)), RSize, ST, EN, SCArray(0), MatrixRR(0, 0))
                   
                Else
                    LS1 = -1: LS2 = -1
                    If ST < EN Then
                        For A = 1 To ST - 1
                            RS1 = CInt(A * SConvert)
                            If LS1 <> RS1 Then
                                LS1 = RS1
                            
                                For b = ST To EN
                                    RS2 = CInt(b * SConvert)
                                    If LS2 <> RS2 Then
                                        LS2 = RS2
                                        MatrixRR(RS2, RS1) = MatrixRR(RS2, RS1) + 1
                                        MatrixRR(RS1, RS2) = MatrixRR(RS1, RS2) + 1
                                    End If
                                Next b
                            End If
                        Next A
                        For A = EN + 1 To Len(StrainSeq(0))
                            RS1 = CInt(A * SConvert)
                            If LS1 <> RS1 Then
                                LS1 = RS1
                            
                                For b = ST To EN
                                    RS2 = CInt(b * SConvert)
                                    If LS2 <> RS2 Then
                                        LS2 = RS2
                                        MatrixRR(RS2, RS1) = MatrixRR(RS2, RS1) + 1
                                        MatrixRR(RS1, RS2) = MatrixRR(RS1, RS2) + 1
                                    End If
                                Next b
                            End If
                        Next A
                    Else
                        For A = EN + 1 To ST - 1
                            RS1 = CInt(A * SConvert)
                            If LS1 <> RS1 Then
                                LS1 = RS1
                            
                                For b = 1 To EN
                                    RS2 = CInt(b * SConvert)
                                    If LS2 <> RS2 Then
                                        LS2 = RS2
                                        MatrixRR(RS2, RS1) = MatrixRR(RS2, RS1) + 1
                                        MatrixRR(RS1, RS2) = MatrixRR(RS1, RS2) + 1
                                    End If
                                Next b
                                For b = ST To Len(StrainSeq(0))
                                    RS2 = CInt(b * SConvert)
                                    If LS2 <> RS2 Then
                                        LS2 = RS2
                                        MatrixRR(RS2, RS1) = MatrixRR(RS2, RS1) + 1
                                        MatrixRR(RS1, RS2) = MatrixRR(RS1, RS2) + 1
                                    End If
                                Next b
                            End If
                        Next A
                        
                    
                    End If
                End If
            End If
        End If
        CurTick = Abs(GetTickCount)
        If Abs(CurTick - LastTick) > 200 Then
            LastTick = CurTick
            Form1.SSPanel1.Caption = Trim(Str(x)) + " of " + Trim(Str(SEventNumber)) + " events mapped"
            Form1.ProgressBar1 = (x / SEventNumber) * 100
            Call UpdateF2Prog
            Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
    Next x
    
    If PermutationX > 0 And InteractListLen >= 0 Then
    
        ReDim ITots(InteractListLen + 1, PermutationX)
        For x = 0 To InteractListLen
            For Y = CLng(InteractList(0, x) * SConvert) To CLng(InteractList(1, x) * SConvert)
                For Z = CLng(InteractList(2, x) * SConvert) To CLng(InteractList(3, x) * SConvert)
                    ITots(x, 0) = ITots(x, 0) + MatrixRR(Y, Z)
                    ITots(InteractListLen + 1, 0) = ITots(InteractListLen + 1, 0) + MatrixRR(Y, Z)
                Next Z
            Next Y
        Next x
    End If
    
    If ReassortmentFlag = 1 And Form1.Check1 = 0 Then
        For x = 1 To RBPNum - 1
            'XX = UBound(RBPPos, 1)
            tBP = SCArray(RBPPos(x))
            For A = tBP - 1 To tBP + 1
                If A < 0 Then
                    b = 0
                ElseIf A > UBound(MatrixRR, 1) Then
                    b = UBound(MatrixRR, 1)
                Else
                    b = A
                End If
                For Y = 0 To UBound(MatrixRR, 1)
                    MatrixRR(b, Y) = 0
                    MatrixRR(Y, b) = 0
                Next Y
            Next A
        Next x
    End If
    'Test for significance and mace matrixrrp
    If PermutationX > 0 Then
    
       
        LegendType = 3
        BPCvalFlag = 1
        
        MaxN = FindMaxNS(RSize, MatrixRR(0, 0))
        
        SS = Abs(GetTickCount)
        Call RecombMapPermsC(Excl(), PermutationX, 3, SCArray(), ITots(), SConvert)
        EE = Abs(GetTickCount)
        TT = EE - SS
        '78000
        '18000 - updatematrixrrp
        '17031
        '16906
        '9125 - better management of variables in Make RecC matrix
        '9156
        '8563
        '5547
        '5687 - but now it is right
        If Form1.Check1.Value = 1 Then
            CoV1 = PermutationX * 0.01
            CoV2 = PermutationX * 0.05
            
            If x = x Then
                Dummy = MakeMatrixRRX(RSize, UBound(MatrixRRX, 1), UBound(MatrixRRP, 1), MaxN, CoV1, CoV2, MatrixRRP(0, 0, 0), MatrixRRX(0, 0))
            Else
                For x = 1 To RSize
                    For Y = 1 To RSize
                        If x <> Y Then
                            If MatrixRRP(x, Y, 0) > CoV2 And MatrixRRP(x, Y, 1) > CoV2 Then
                                MatrixRRX(x, Y) = -1
                            ElseIf MatrixRRP(x, Y, 0) <= CoV1 Then
                                MatrixRRX(x, Y) = MaxN
                            ElseIf MatrixRRP(x, Y, 0) <= CoV2 Then
                                MatrixRRX(x, Y) = CInt(MaxN * 0.95) - 1
                            ElseIf MatrixRRP(x, Y, 1) <= CoV1 Then
                                MatrixRRX(x, Y) = 0
                            ElseIf MatrixRRP(x, Y, 1) <= CoV2 Then
                                MatrixRRX(x, Y) = CInt(MaxN * 0.05) + 1
                            Else
                                MatrixRRX(x, Y) = -1
                            End If
                        Else
                            MatrixRRX(x, Y) = -1
                        End If
                    Next Y
                Next x
            End If
        Else
            LegendType = 0
            For x = 1 To RSize
                For Y = 1 To RSize
                    MatrixRRX(x, Y) = MatrixRR(x, Y)
                Next Y
            Next x
        End If
    Else
        LegendType = 0
        For x = 1 To RSize
            For Y = 1 To RSize
                MatrixRRX(x, Y) = MatrixRR(x, Y)
            Next Y
        Next x
    End If
    
   
    
    If PermutationX > 0 And InteractListLen >= 0 Then
        Dim PPValInteract() As Single, TallyH As Long, TallyL As Long
        ReDim PPValInteract(InteractListLen + 1, 1)
        For A = 0 To InteractListLen + 1
            TallyH = 0: TallyL = 0
            For x = 1 To PermutationX
                If ITots(A, 0) > ITots(A, x) Then
                    TallyH = TallyH + 1
                ElseIf ITots(A, 0) < ITots(A, x) Then
                    TallyL = TallyL + 1
                End If
            Next x
            PPValInteract(A, 0) = TallyH / PermutationX
            PPValInteract(A, 1) = TallyL / PermutationX
            x = x
        Next A
    End If
    
    
    Form1.ProgressBar1 = 100
    Call UpdateF2Prog
    EE = Abs(GetTickCount)
    TT = EE - SS '2.687,2.704
    '3.77,2.766, 2.797
    MaxN = FindMaxNS(RSize, MatrixRR(0, 0))
    MatBound(3) = MaxN
    Form1.SSPanel1.Caption = "Drawing matrix"
Else
    MaxN = MatBound(3)
    If PermutationX > 0 And Form1.Check1.Value = 1 Then 'this need sto be speeded up in c++
        LegendType = 3
        BPCvalFlag = 1
        CoV1 = PermutationX * 0.01
        CoV2 = PermutationX * 0.05
        If x = x Then
            Dummy = MakeMatrixRRX(RSize, UBound(MatrixRRX, 1), UBound(MatrixRRP, 1), MaxN, CoV1, CoV2, MatrixRRP(0, 0, 0), MatrixRRX(0, 0))
        Else
            For x = 1 To RSize
                For Y = 1 To RSize
                    If x <> Y Then
                        If MatrixRRP(x, Y, 0) > CoV2 And MatrixRRP(x, Y, 1) > CoV2 Then
                            MatrixRRX(x, Y) = -1
                        ElseIf MatrixRRP(x, Y, 0) <= CoV1 Then
                            MatrixRRX(x, Y) = MaxN
                        ElseIf MatrixRRP(x, Y, 0) <= CoV2 Then
                            MatrixRRX(x, Y) = CInt(MaxN * 0.95) - 1
                        ElseIf MatrixRRP(x, Y, 1) <= CoV1 Then
                            MatrixRRX(x, Y) = 0
                        ElseIf MatrixRRP(x, Y, 1) <= CoV2 Then
                            MatrixRRX(x, Y) = CInt(MaxN * 0.05) + 1
                        Else
                            MatrixRRX(x, Y) = -1
                        End If
                    Else
                        MatrixRRX(x, Y) = -1
                    End If
                Next Y
            Next x
        End If
    Else
        LegendType = 0
        For x = 1 To RSize
            For Y = 1 To RSize
                MatrixRRX(x, Y) = MatrixRR(x, Y)
            Next Y
        Next x
    End If
    
End If
SS = Abs(GetTickCount)


    Form1.Picture26.ScaleMode = 3
    Form1.Picture26.AutoRedraw = True
    Dim XAddj As Single, PosS(1) As Single, PosE(1) As Single, DistD As Long
        
        DistD = RSize / MatZoom(3)
        PosS(0) = MatCoord(3, 0)
        PosE(0) = PosS(0) + DistD
        PosS(1) = MatCoord(3, 1)
        PosE(1) = PosS(1) + DistD
        If PosE(1) > (UBound(MatrixRR, 1) - 1) - 1 Then PosE(1) = (UBound(MatrixRR, 1) - 1) - 1
        If PosE(0) > (UBound(MatrixRR, 1) - 1) - 1 Then PosE(0) = (UBound(MatrixRR, 1) - 1) - 1
       
        If PosS(0) < 0 Then SX = 0 Else SX = PosS(0)
        If PosS(1) < 0 Then SY = 0 Else SY = PosS(1)
        'MaxN = 5
        If LegendType <> 3 Then
            If MaxN > 2 Then
                MaxN = CLng(MaxN + 0.49)
                
            Else
                MaxN = 2
            End If
        End If
        
        Form1.Picture26.Picture = LoadPicture()
        XAddj = (Form1.Picture26.ScaleHeight) / DistD
        Pict = Form1.Picture26.hdc
        
        If x = 12345 Then
            'MakeHeatPlot MaxN, UBound(HeatMap, 1), CurScale, Pict, RSize, XAddj, HeatMap(0, 0), MatrixRR(0, 0)
        Else
            If x = x Then
                Call DrawMatsVB(Form1.Picture26, 0, PosE(), PosS(), SX, SY, XAddj, MatrixRRX(), HeatMap(), CurScale, MaxN)
            Else
                RangeN = MaxN - MinN
                For x = 1 To RSize 'Step 20
                    For Y = x To RSize 'Step 20
                        SetPixelV Pict, CInt(x * XAddj), CInt(Y * XAddj), HeatMap(CurScale, CInt((MatrixRR(x, Y) / MaxN) * 1020))
                        SetPixelV Pict, CInt(Y * XAddj), CInt(x * XAddj), HeatMap(CurScale, CInt((MatrixRR(x, Y) / MaxN) * 1020))
                    Next Y
                    Form1.Picture26.Refresh
                    Form1.ProgressBar1 = 70 + (x / RSize) * 30
                    Call UpdateF2Prog
                Next x
            End If
        End If
        ZZZ = Form1.Label6(0).Caption
        If DontDoKey = 0 Or (LegendType = 3 And Form1.Label6(0).Caption <> "Hot p < 0.01") Or (LegendType = 0 And Form1.Label6(0).Caption <> Str(MaxN)) Then
            If LegendType = 3 Then
                Call DoKey(LegendType, MaxN, MinN, 3, "Local p-value", CurScale)
            Else
                Call DoKey(LegendType, MaxN, MinN, 3, "Number of events", CurScale)
            End If
        End If
        DoneMatX(3) = 1
        
        Form1.Picture26.Refresh
    Form1.ProgressBar1 = 0
    Form1.SSPanel1 = ""
    Call UpdateF2Prog
    EE = Abs(GetTickCount)
    TT = EE - ssxx '46.234 pvy test with 1000 perms
    '37.547 using singles instead of doubles
    x = x
    
End Sub


Public Sub CheckDrop(ActualSeqSize() As Long, Steps() As Long, SEventNumber As Long, StepNo As Long, NextNo As Long, oNextno As Long, NumRecsI() As Long, RedoListSize As Long, RedoList() As Long)

Dim UB As Long, x As Long, Z As Long, A As Long, NumDrop As Long, Smallest As Long, Win As Long

If SEventNumber >= 1109 Then
    x = x
End If
Dim ASS() As Long
ReDim ASS(NextNo)
For x = 0 To NextNo
    ASS(x) = ActualSeqSize(x)
Next x

If NextNo * Len(StrainSeq(0)) > MemPoc * 10000 Then
    NumDrop = NextNo * Len(StrainSeq(0)) - MemPoc * 10000
    NumDrop = NumDrop / Len(StrainSeq(0)) + 1
    If NumDrop > (NextNo - oNextno) Then
        'NumDrop = NextNo - oNextno
        For x = oNextno + 1 To NextNo
            NumRecsI(x) = 0
        Next x
    Else
        For x = 1 To NumDrop
            'find smallest
            Smallest = Len(StrainSeq(0)) + 1
            Win = -1
            For Z = oNextno To NextNo
                If ASS(Z) < Smallest Then
                    Smallest = ASS(Z)
                    Win = Z
                End If
            Next Z
            If Win > -1 Then
                NumRecsI(Win) = 0
                ASS(Win) = Len(StrainSeq(0)) + 1
                ActualSeqSize(Win) = 0
            Else
                Exit For
            End If
        Next x
    End If
End If


'x = NextNo
'
''@
'Do While x > oNextno
'
'    If NumRecsI(x) = 0 Then
'        If RedoListSize > 0 Then
'            'port this code to c++
'            Z = 0
'            Do While Z <= RedoListSize
'                For A = 1 To 3
'
'                    If RedoList(A, Z) = x Then
'                        Exit For
'                    End If
'                Next A
'                If A < 4 Then
'                    For A = 0 To 3
'                        RedoList(A, Z) = RedoList(A, RedoListSize)
'                    Next A
'                    RedoListSize = RedoListSize - 1
'                Else
'                    Z = Z + 1
'                End If
'            Loop
'
'            x = x
'
'        End If
'
'        If x = NextNo Then
'            Steps(0, StepNo) = 3 'ie delete a sequence ....
'            Steps(1, StepNo) = NextNo 'this is the seqence.....
'            Steps(4, StepNo) = SEventNumber + 1
'            StepNo = StepNo + 1
'
'            UB = UBound(Steps, 2)
'            If StepNo > UB Then
'                ReDim Preserve Steps(4, UB + 100)
'            End If
'            NextNo = NextNo - 1
'        Else
'            Steps(0, StepNo) = 4 'ie replace a sequence with nextno....
'            Steps(1, StepNo) = x 'this is the seqence.....
'            Steps(4, StepNo) = SEventNumber + 1
'            StepNo = StepNo + 1
'            UB = UBound(Steps, 2)
'            If StepNo > UB Then
'                ReDim Preserve Steps(4, UB + 100)
'            End If
'            Steps(0, StepNo) = 3 'ie delete a sequence
'            Steps(1, StepNo) = x 'this is the seqence.....
'            Steps(4, StepNo) = SEventNumber + 1
'            StepNo = StepNo + 1
'
'            UB = UBound(Steps, 2)
'            If StepNo > UB Then
'                ReDim Preserve Steps(4, UB + 100)
'            End If
'        End If
'
'
'
'    Else
'        If x = oNextno + 1 Then Exit Do
'    End If
'    x = x - 1
'Loop
x = x
End Sub

Public Sub CalcMatchY(ISeqs() As Long, CompMat() As Long, OKSeq() As Double, ABPos As Long, AEPos As Long)


'Find left boun1
Dim A As Long, SSFlag As Long, Dummy As Long, Epos As Long, BPos As Long, TargetWin As Long, BoundX() As Long, LenFrag As Long, x As Long, Y As Long, LenVarSeq As Long, BCycle(3) As Long
Dim b As Long, Z As Long
ReDim BoundX(3)
BCycle(0) = 0
BCycle(1) = 0
BCycle(2) = 0
BCycle(3) = 0

x = ABPos
LenVarSeq = 0
LenFrag = 0

'what is the distance between the breakpoints?
Do
    LenFrag = LenFrag + 1
    If SeqNum(x, ISeqs(0)) <> 46 Then
        If SeqNum(x, ISeqs(1)) <> 46 Then
            If SeqNum(x, ISeqs(2)) <> 46 Then
                If SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(1)) Or SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(2)) Then
                    LenVarSeq = LenVarSeq + 1
                    'If LenVarSeq = 40 Then Exit Do
                End If
            End If
        End If
    End If
    x = x + 1
    If x = AEPos Then
        Exit Do
    End If
    
    If x > Len(StrainSeq(0)) Then
        x = 1
        If x = AEPos Then
            Exit Do
        End If
    End If
    
    
Loop

If LenVarSeq >= 30 Then
    TargetWin = 15
Else
    TargetWin = CLng(LenVarSeq / 2)
End If

If TargetWin < 2 Then Exit Sub

x = ABPos
LenFrag = 0
LenVarSeq = 0

Do
    LenFrag = LenFrag + 1
    If SeqNum(x, ISeqs(0)) <> 46 Then
        If SeqNum(x, ISeqs(1)) <> 46 Then
            If SeqNum(x, ISeqs(2)) <> 46 Then
                If SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(1)) Or SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(2)) Then
                    LenVarSeq = LenVarSeq + 1
                    If LenVarSeq = 40 Then Exit Do
                End If
            End If
        End If
    End If
    x = x - 1
    
    If x < 1 Then
        x = Len(StrainSeq(0))
        BCycle(0) = BCycle(0) + 1
        If BCycle(0) > 40 Then
            Exit Do
        ElseIf BCycle(0) > 2 And LenVarSeq = 0 Then
            Exit Do
        End If
    End If
Loop
BoundX(0) = x
'right bound l
If LenFrag > Len(StrainSeq(0)) * 3 Then GoTo ClearOKseq

BPos = LenFrag
x = ABPos + 1
If x > Len(StrainSeq(0)) Then
    x = 1
    BCycle(1) = BCycle(1) + 1
End If
LenVarSeq = 0
Do
    LenFrag = LenFrag + 1
    If SeqNum(x, ISeqs(0)) <> 46 Then
        If SeqNum(x, ISeqs(1)) <> 46 Then
            If SeqNum(x, ISeqs(2)) <> 46 Then
                If SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(1)) Or SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(2)) Then
                    LenVarSeq = LenVarSeq + 1
                    If LenVarSeq = 40 Then Exit Do
                End If
            End If
        End If
    End If
    x = x + 1
    If x > Len(StrainSeq(0)) Then
        x = 1
        BCycle(1) = BCycle(1) + 1
        If BCycle(1) > 40 Then
            Exit Do
        ElseIf BCycle(1) > 2 And LenVarSeq = 0 Then
            Exit Do
        End If
    End If
Loop
BoundX(1) = x

x = AEPos
LenVarSeq = 0
Do
    LenFrag = LenFrag + 1
    If SeqNum(x, ISeqs(0)) <> 46 Then
        If SeqNum(x, ISeqs(1)) <> 46 Then
            If SeqNum(x, ISeqs(2)) <> 46 Then
                If SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(1)) Or SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(2)) Then
                    LenVarSeq = LenVarSeq + 1
                    If LenVarSeq = 40 Then Exit Do
                End If
            End If
        End If
    End If
    x = x - 1
    If x < 1 Then
        x = Len(StrainSeq(0))
        BCycle(2) = BCycle(2) + 1
        If BCycle(2) > 40 Then
            Exit Do
        ElseIf BCycle(2) > 2 And LenVarSeq = 0 Then
            Exit Do
        End If
    End If
Loop
BoundX(2) = x


If LenFrag > Len(StrainSeq(0)) * 3 Then GoTo ClearOKseq


'right bound l
Epos = LenFrag
x = AEPos + 1
If x > Len(StrainSeq(0)) Then
    x = 1
    BCycle(3) = BCycle(3) + 1
End If
LenVarSeq = 0
Do
    LenFrag = LenFrag + 1
    If SeqNum(x, ISeqs(0)) <> 46 Then
        If SeqNum(x, ISeqs(1)) <> 46 Then
            If SeqNum(x, ISeqs(2)) <> 46 Then
                If SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(1)) Or SeqNum(x, ISeqs(0)) <> SeqNum(x, ISeqs(2)) Then
                    LenVarSeq = LenVarSeq + 1
                    If LenVarSeq = 40 Then Exit Do
                End If
            End If
        End If
    End If
    x = x + 1
    If x > Len(StrainSeq(0)) Then
        x = 1
        BCycle(3) = BCycle(3) + 1
        If BCycle(3) > 40 Then
            Exit Do
        ElseIf BCycle(3) > 2 And LenVarSeq = 0 Then
            Exit Do
        End If
    End If
Loop
BoundX(3) = x


Dim SeqNum2() As Integer


If LenFrag > Len(StrainSeq(0)) * 3 Then GoTo ClearOKseq

'remake seqnum
 On Error Resume Next
ReDim SeqNum2(LenFrag + 1, NextNo)
Dim UBLF As Long
UBLF = 0
UBLF = UBound(SeqNum2, 1)


If UBLF < LenFrag + 1 Then
    GoTo ClearOKseq
End If

On Error GoTo 0

If x = x Then
    LenFrag = MakeLenFrag(Len(StrainSeq(0)), NextNo, ABPos, AEPos, BCycle(0), BoundX(0), UBound(SeqNum2, 1), SeqNum2(0, 0), UBound(SeqNum, 1), SeqNum(0, 0))
Else
    x = BoundX(0)
    LenFrag = 0
    '@'$
    Do
        LenFrag = LenFrag + 1
        For Y = 0 To NextNo
            SeqNum2(LenFrag, Y) = SeqNum(x, Y)
        Next Y
        x = x + 1
        If x = ABPos And BCycle(0) <= 0 Then Exit Do
        If x > Len(StrainSeq(0)) Then
            x = 1
            BCycle(0) = BCycle(0) - 1
            If x = ABPos And BCycle(0) <= 0 Then Exit Do
        End If
    Loop
    '@
    Do
        LenFrag = LenFrag + 1
    
        For Y = 0 To NextNo
    
            SeqNum2(LenFrag, Y) = SeqNum(x, Y)
        Next Y
        x = x + 1
        If x = BoundX(1) And BCycle(1) <= 0 Then Exit Do
        If x > Len(StrainSeq(0)) Then
            x = 1
            BCycle(1) = BCycle(1) - 1
            If x = BoundX(1) And BCycle(1) <= 0 Then Exit Do
        End If
    Loop
    
    
    
    
    x = BoundX(2)
    '$
    Do
        LenFrag = LenFrag + 1
        For Y = 0 To NextNo
            SeqNum2(LenFrag, Y) = SeqNum(x, Y)
        Next Y
        x = x + 1
        If x = AEPos And BCycle(2) = 0 Then Exit Do
        If x > Len(StrainSeq(0)) Then
            x = 1
            BCycle(2) = BCycle(2) - 1
            If x = AEPos And BCycle(2) = 0 Then Exit Do
        End If
    Loop
    'XX = UBound(Seqnum2, 1)
    '@'@'@'@'$'$'$
    Do
        LenFrag = LenFrag + 1
        For Y = 0 To NextNo
            SeqNum2(LenFrag, Y) = SeqNum(x, Y)
        Next Y
        x = x + 1
        If x = BoundX(3) And BCycle(3) = 0 Then Exit Do
        If x > Len(StrainSeq(0)) Then
            x = 1
            BCycle(3) = BCycle(3) - 1
            If x = BoundX(3) And BCycle(3) = 0 Then Exit Do
        End If
    Loop
End If

If LenFrag > Len(StrainSeq(0)) * 3 Then GoTo ClearOKseq


Dim VarSiteSmooth() As Single, VarSiteMap() As Integer, VXPos() As Long, SWin As Long, Tot As Double
Dim LSS As Long
LSS = Len(StrainSeq(0))
On Error GoTo FAI 'this is needed because there are memeory problems with very big sequences - if it bugs out it goes with the most conservative grouping
On Error GoTo 0
Dim VRPos() As Long, UBSN2 As Long, UBVSM As Long
UBSN2 = UBound(SeqNum2, 1)

UBVSM = 160 'the number of sites that are used for the query

ReDim VXPos(UBSN2)
ReDim VarSiteMap(2, UBVSM, NextNo)

SWin = TargetWin
If SWin < 5 Then
    SWin = 5
End If

'Exit Sub
LenVarSeq = 0

ReDim VRPos(UBSN2 + 1)
VRPos(UBSN2 + 1) = UBSN2 + 1

Dim CntHit() As Double, NCnt As Long
ReDim CntHit(2, 1, NextNo)
LenVarSeq = 0

'@
'If X = X Then
    LenVarSeq = MakeVarMap2(NextNo, UBSN2, UBVSM, SeqNum2(0, 0), VarSiteMap(0, 0, 0), VRPos(0), VXPos(0), ISeqs(0), CompMat(0, 0))
    x = x
'Else
'    LenVarSeq = 0
'    For X = 0 To UBSN2
'
'        VRPos(X) = LenVarSeq
'        If Seqnum2(X, ISeqs(0)) <> 46 Then
'            If Seqnum2(X, ISeqs(1)) <> 46 Then
'                If Seqnum2(X, ISeqs(2)) <> 46 Then
'                    If Seqnum2(X, ISeqs(0)) <> Seqnum2(X, ISeqs(1)) Or Seqnum2(X, ISeqs(0)) <> Seqnum2(X, ISeqs(2)) Then
'                        LenVarSeq = LenVarSeq + 1
'                        VXPos(LenVarSeq) = X
'                        For Y = 0 To 2
'                            For Z = 0 To Nextno
''                                If Z = 26 And ISeqs(Y) = 37 And SEventNumber = 15 Then
''                                       X = X
''                                       FF = FreeFile
''                                       Open "varsites" For Append As #FF
''                                       Print #FF, Trim(Str(X + BoundX(0))) + "," + Trim(Str(Seqnum2(X, Z))) + "," + Trim(Str(Seqnum2(X, ISeqs(0)))) + "," + Trim(Str(Seqnum2(X, ISeqs(1)))) + "," + Trim(Str(Seqnum2(X, ISeqs(2))))
''                                       Close #FF
''                                   End If
'                                If Seqnum2(X, ISeqs(Y)) = Seqnum2(X, Z) Then
'                                    VarSiteMap(Y, LenVarSeq, Z) = 2 ' it is the same as iseq(y)
''                                    If Z = 242 And Y = 0 Then
''                                       X = X
''                                   End If
'                                ElseIf Seqnum2(X, Z) <> Seqnum2(X, ISeqs(CompMat(Y, 0))) And Seqnum2(X, Z) <> Seqnum2(X, ISeqs(CompMat(Y, 1))) Then 'it is different from all of the  sequences
'                                    VarSiteMap(Y, LenVarSeq, Z) = 1
''                                    If Z = 242 And Y = 0 Then
''                                       X = X
''                                   End If
''                                Else
''                                    If Z = 242 And Y = 0 Then
''                                    X = X
''                                End If
'                                End If
'                            Next Z        '    VarSiteMap(LenVarSeq) = 1
'                        Next Y                'End If
'                    End If
'                End If
'            End If
'        End If
'    Next X
'End If
Erase SeqNum2

'On Error GoTo SlowAndSteady
ReDim VarSiteSmooth(2, LenVarSeq, NextNo)
'XX = UBound(CntHit, 1)
'smooth varsitemap
 '******************************The window that will be searched will contain 30 nucleotides

'If SEventNumber = 7 Then
'    X = X '284 (253)
'End If
If x = x Then ' I'm getting some errors in this routine
    '&
    Dummy = MakeCntHit2(BPos, Epos, SWin, NextNo, LenVarSeq, UBSN2, UBVSM, CntHit(0, 0, 0), VarSiteMap(0, 0, 0), VarSiteSmooth(0, 0, 0), VRPos(0))
    SSFlag = 0
Else
SlowAndSteady: 'there was a problem diming the varsitesmooth array
    SSFlag = 1
    Dim VSS() As Single
    On Error GoTo FAI
    ReDim VSS(2, Len(StrainSeq(0)) / 4 + 1, NextNo)
    For A = 0 To 2
        For b = 0 To NextNo
            Tot = 0
            For x = 1 - SWin To 1 + SWin
            
                If x < 1 Then
                    Z = (LenVarSeq + x) '2450
                ElseIf x > LenVarSeq Then
                    Z = x - LenVarSeq
                Else
                    Z = x
                End If
                Tot = Tot + VarSiteMap(A, Z, b)
            Next x
            
            VSS(A, 1, b) = Tot / ((SWin * 2 + 1) * 2)
            For x = 2 To LenVarSeq
                Z = x - SWin - 1
                If Z < 1 Then
                    Tot = Tot - VarSiteMap(A, (LenVarSeq + Z), b)
                ElseIf Z > LenVarSeq Then
                    Tot = Tot - VarSiteMap(A, Z - LenVarSeq, b)
                Else
                    Tot = Tot - VarSiteMap(A, Z, b)
                End If
                Z = x + SWin
                If Z > LenVarSeq Then
                    Tot = Tot + VarSiteMap(A, Z - LenVarSeq, b)
                Else
                    Tot = Tot + VarSiteMap(A, Z, b)
                End If
                VSS(A, CLng(x / 4), b) = Tot / ((SWin * 2 + 1) * 2)
                
            Next x
        Next b
    Next A

'End If

    If BPos > 1 Then
        ST = BPos - 1
    Else
        ST = BPos
    End If
    
    
    NCnt = 0
    If BPos < Epos Then
        If VRPos(ST - 1) > 0 Then
            For x = 1 To VRPos(ST - 1)
                NCnt = NCnt + 1
                For Y = 0 To 2
                    For Z = 0 To NextNo
                        If VSS(Y, CLng(x / 4), Z) > 0.6 Then
                           CntHit(Y, 0, Z) = CntHit(Y, 0, Z) + (VSS(Y, CLng(x / 4), Z) - 0.6) / 0.4
                           
                        End If
                    Next Z
                Next Y
                
            Next x
        
        End If
        For x = VRPos(Epos + 1) To VRPos(Len(StrainSeq(0)))
            NCnt = NCnt + 1
            For Y = 0 To 2
                For Z = 0 To NextNo
                    If VSS(Y, CLng(x / 4), Z) > 0.6 Then
                        CntHit(Y, 0, Z) = CntHit(Y, 0, Z) + (VSS(Y, CLng(x / 4), Z) - 0.6) / 0.4
                    End If
                Next Z
            Next Y
        Next x
        If NCnt = 0 Then NCnt = 1
        For Y = 0 To 2
            For Z = 0 To NextNo
                CntHit(Y, 0, Z) = CntHit(Y, 0, Z) / NCnt
            Next Z
        Next Y
        NCnt = 0
        For x = VRPos(BPos) To VRPos(Epos)
            NCnt = NCnt + 1
            For Y = 0 To 2
                For Z = 0 To NextNo
                    If VSS(Y, CLng(x / 4), Z) > 0.6 Then
                        CntHit(Y, 1, Z) = CntHit(Y, 1, Z) + (VSS(Y, CLng(x / 4), Z) - 0.6) / 0.4
                    End If
                Next Z
            Next Y
        Next x
        For Y = 0 To 2
            For Z = 0 To NextNo
                CntHit(Y, 1, Z) = CntHit(Y, 1, Z) / NCnt
            Next Z
        Next Y
    Else
        For x = 1 To VRPos(Epos)
            NCnt = NCnt + 1
            For Y = 0 To 2
                For Z = 0 To NextNo
                    If VSS(Y, CLng(x / 4), Z) > 0.6 Then
                       CntHit(Y, 1, Z) = CntHit(Y, 1, Z) + (VSS(Y, CLng(x / 4), Z) - 0.6) / 0.4
                    End If
                Next Z
            Next Y
            
        Next x
        For x = VRPos(BPos) To VRPos(UBSN2)
            NCnt = NCnt + 1
            For Y = 0 To 2
                For Z = 0 To NextNo
                    If VSS(Y, CLng(x / 4), Z) > 0.6 Then
                        CntHit(Y, 1, Z) = CntHit(Y, 1, Z) + (VSS(Y, CLng(x / 4), Z) - 0.6) / 0.4
                    End If
                Next Z
            Next Y
        Next x
        For Y = 0 To 2
            For Z = 0 To NextNo
                CntHit(Y, 1, Z) = CntHit(Y, 1, Z) / NCnt
            Next Z
        Next Y
        NCnt = 0
        For x = VRPos(Epos + 1) To VRPos(BPos - 1)
            NCnt = NCnt + 1
            For Y = 0 To 2
                For Z = 0 To NextNo
                    If VSS(Y, CLng(x / 4), Z) > 0.6 Then
                        CntHit(Y, 0, Z) = CntHit(Y, 0, Z) + (VSS(Y, CLng(x / 4), Z) - 0.6) / 0.4
                    End If
                Next Z
            Next Y
        Next x
        For Y = 0 To 2
            For Z = 0 To NextNo
                If NCnt > 0 Then
                    CntHit(Y, 0, Z) = CntHit(Y, 0, Z) / NCnt
                Else
                    CntHit(Y, 0, Z) = 0
                End If
            Next Z
        Next Y
    End If
    
    
End If

On Error GoTo ClearOKseq 'this needed to control for there soemtimes being a divison by zero error in MakeCntHit
For Y = 0 To 2
    For Z = 0 To NextNo
        
        OKSeq(Y, 17, Z) = CntHit(Y, 0, Z) * CntHit(Y, 1, Z)
        
        
    Next Z
Next Y
'If SEventNumber = 5 Then
'    X = X
'End If
'ConservativeGroup = 0
On Error GoTo 0

'If SEventNumber = 18 Then '17-r,20
'    X = X
'    XX = ISeqs(0)
'    XX = ISeqs(1)
'    XX = ISeqs(2)
'
'End If

If SSFlag = 0 Then 'i.e do the groupings as realistically as possible
'Scan accross the breakpoints
'do beginning Bp left

    Dim KeepTrack() As Single
    ReDim KeepTrack(2, 5, NextNo)
'    If SEventNumber = 3 Or SEventNumber = 4 Then
'        X = X
'    End If

    If x = x Then
        For Y = 0 To 2
            
            x = VRPos(BPos) - SWin '/ 2
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Z = 0 To NextNo
                
                KeepTrack(Y, 0, Z) = (VarSiteSmooth(Y, A, Z)) '0.97
                
            Next Z
            x = VRPos(BPos) + SWin '/ 2
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Z = 0 To NextNo
                KeepTrack(Y, 1, Z) = (VarSiteSmooth(Y, A, Z)) '0.91
'                If Y = 2 And Z = 881 Then
'                    X = X
'                End If
            Next Z
            
            x = VRPos(BPos)
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Z = 0 To NextNo
                
                KeepTrack(Y, 4, Z) = (VarSiteSmooth(Y, A, Z)) '0.97
                
            Next Z
            
            
            x = VRPos(Epos) - SWin ' / 2
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
           ' KeepTrack(Y, 2, Z) = (VarSiteSmooth(Y, A, Z))
            For Z = 0 To NextNo
                KeepTrack(Y, 2, Z) = (VarSiteSmooth(Y, A, Z)) '0.95
'                If Y = 2 And Z = 881 Then
'                    X = X
'                End If
            Next Z
            x = VRPos(Epos) + SWin ' / 2
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Z = 0 To NextNo
                KeepTrack(Y, 3, Z) = (VarSiteSmooth(Y, A, Z)) '0.97
'                If Y = 2 And Z = 881 Then
'                    X = X
'                End If
            Next Z
            
            x = VRPos(Epos) ' / 2
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
           ' KeepTrack(Y, 2, Z) = (VarSiteSmooth(Y, A, Z))
            For Z = 0 To NextNo
                KeepTrack(Y, 5, Z) = (VarSiteSmooth(Y, A, Z)) '0.95
'                If Y = 2 And Z = 881 Then
'                    X = X
'                End If
            Next Z
            
        Next Y
'        XX = ISeqs(0)
'        XX = ISeqs(1)
'        XX = ISeqs(2)
'        If SEventNumber = 6 Then
'            X = X
'        End If
        
        ReDim BreaksExist(2, 1, NextNo)
        If ReassortmentFlag = 1 Or ConservativeGroup = 0 Then
            For Y = 0 To 2
                For Z = 0 To NextNo '2 ~0.7 on ending BP, 3 ~0.70 on ending BP
'                    If ISeqs(Y) = 45 And Z = 35 And SEventNumber = 25 Then '34,35,16, 17
'
'                        X = X
'                    End If
    'XX = ISeqs(0)
                    If (KeepTrack(Y, 0, Z) > 0.8 And KeepTrack(Y, 1, Z) > 0.8 And KeepTrack(Y, 4, Z) > 0.8) Or (KeepTrack(Y, 2, Z) > 0.8 And KeepTrack(Y, 3, Z) > 0.8 And KeepTrack(Y, 5, Z) > 0.8) Then   ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = 1 '73,85,80,74
                    ElseIf KeepTrack(Y, 4, Z) > 0.9 Or KeepTrack(Y, 5, Z) > 0.9 Then     ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = 1
                    ElseIf KeepTrack(Y, 4, Z) > 0.8 Or KeepTrack(Y, 5, Z) > 0.8 Then         ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = 2
                    ElseIf (KeepTrack(Y, 4, Z) > 0.75 Or KeepTrack(Y, 5, Z) > 0.75) And (KeepTrack(Y, 1, Z) > 0.75 Or KeepTrack(Y, 2, Z) > 0.75) And (KeepTrack(Y, 0, Z) > 0.75 Or KeepTrack(Y, 3, Z) > 0.75) Then
                        If ((((KeepTrack(Y, 0, Z) + KeepTrack(Y, 1, Z) + KeepTrack(Y, 4, Z)) / 3) > 0.75) Or ((KeepTrack(Y, 2, Z) + KeepTrack(Y, 3, Z) + KeepTrack(Y, 5, Z)) / 3 > 0.75)) Then
                            OKSeq(Y, 18, Z) = 2 ' 14.45, 15.97, 15.57, 16.785
                        ElseIf (KeepTrack(Y, 0, Z) > 0.75 And KeepTrack(Y, 1, Z) > 0.75 And KeepTrack(Y, 4, Z) > 0.75) Or (KeepTrack(Y, 2, Z) > 0.75 And (KeepTrack(Y, 3, Z)) > 0.75 And (KeepTrack(Y, 5, Z)) > 0.75) Then   ''37.90476,21.57143,x,x,21.19,34.523
                            OKSeq(Y, 18, Z) = 2 '73,85,80,74
                        ElseIf (KeepTrack(Y, 0, Z) > 0.7 And KeepTrack(Y, 1, Z) > 0.7 And KeepTrack(Y, 4, Z) > 0.7) And (KeepTrack(Y, 2, Z) > 0.7 And (KeepTrack(Y, 3, Z)) > 0.7 And (KeepTrack(Y, 5, Z)) > 0.7) Then         ''37.90476,21.57143,x,x,21.19,34.523
                            OKSeq(Y, 18, Z) = 2 '73,85,80,74
                        End If
                    ElseIf (KeepTrack(Y, 4, Z) < 0.65 And KeepTrack(Y, 5, Z) < 0.65) Then
                        OKSeq(Y, 18, Z) = -1
                    ElseIf (KeepTrack(Y, 1, Z) < 0.65 And KeepTrack(Y, 2, Z) < 0.65) Then
                        OKSeq(Y, 18, Z) = -1
                    ElseIf (KeepTrack(Y, 0, Z) < 0.65 And KeepTrack(Y, 3, Z) < 0.65) Then
                        OKSeq(Y, 18, Z) = -1
                    ElseIf (KeepTrack(Y, 0, Z) < 0.7 And KeepTrack(Y, 1, Z) < 0.7 And KeepTrack(Y, 4, Z) < 0.7) And (KeepTrack(Y, 2, Z) < 0.7 And (KeepTrack(Y, 3, Z)) < 0.7 And (KeepTrack(Y, 5, Z)) < 0.7) Then         ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = -1 '73,85,80,74
                    ElseIf (((KeepTrack(Y, 0, Z) + KeepTrack(Y, 1, Z) + KeepTrack(Y, 4, Z)) / 3 < 0.7) And ((KeepTrack(Y, 2, Z) + KeepTrack(Y, 3, Z) + KeepTrack(Y, 5, Z)) / 3 < 0.7)) Then
                        OKSeq(Y, 18, Z) = -1 ' 14.45, 15.97, 15.57, 16.785
                    Else
                        OKSeq(Y, 18, Z) = 0
                    End If
                    
                    If (KeepTrack(Y, 0, Z) > 0.75 Or KeepTrack(Y, 1, Z) > 0.75 Or KeepTrack(Y, 4, Z) > 0.75) Then
                        BreaksExist(Y, 0, Z) = 1
                    Else
                        BreaksExist(Y, 0, Z) = 0
                    End If
                    If (KeepTrack(Y, 2, Z) > 0.75 Or KeepTrack(Y, 3, Z) > 0.75 Or KeepTrack(Y, 5, Z) > 0.75) Then
                        BreaksExist(Y, 1, Z) = 1
                    Else
                        BreaksExist(Y, 1, Z) = 0
                    End If
                Next Z
            Next Y
            x = x
        Else
            For Y = 0 To 2
                For Z = 0 To NextNo '2 ~0.7 on ending BP, 3 ~0.70 on ending BP
'                If SEventNumber = 1 And (Z = 8 Or Z = 14) Then
'                            X = X
'                        End If
                
                    If (KeepTrack(Y, 0, Z) > 0.75 And KeepTrack(Y, 1, Z) > 0.75 And KeepTrack(Y, 4, Z) > 0.75) Or (KeepTrack(Y, 2, Z) > 0.75 And KeepTrack(Y, 3, Z) > 0.75 And KeepTrack(Y, 5, Z) > 0.75) Then
                        OKSeq(Y, 18, Z) = 1 '20.6667, 18.952, 17.523,9.642
                    ElseIf KeepTrack(Y, 4, Z) > 0.85 Or KeepTrack(Y, 5, Z) > 0.85 Then       ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = 1
                    ElseIf KeepTrack(Y, 4, Z) > 0.75 Or KeepTrack(Y, 5, Z) > 0.75 Then        ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = 2
                    ElseIf (KeepTrack(Y, 4, Z) > 0.7 Or KeepTrack(Y, 5, Z) > 0.7) And (KeepTrack(Y, 1, Z) > 0.7 Or KeepTrack(Y, 2, Z) > 0.7) And (KeepTrack(Y, 0, Z) > 0.7 Or KeepTrack(Y, 3, Z) > 0.7) Then
                        If (((KeepTrack(Y, 0, Z) + KeepTrack(Y, 1, Z) + KeepTrack(Y, 4, Z)) / 3 > 0.75) Or ((KeepTrack(Y, 2, Z) + KeepTrack(Y, 3, Z) + KeepTrack(Y, 5, Z)) / 3 > 0.75)) Then
                            OKSeq(Y, 18, Z) = 2 ' 14.45, 15.97, 15.57, 16.785
                        ElseIf (KeepTrack(Y, 0, Z) > 0.7 And KeepTrack(Y, 1, Z) > 0.7 And KeepTrack(Y, 4, Z) > 0.7) Or (KeepTrack(Y, 2, Z) > 0.7 And KeepTrack(Y, 3, Z) > 0.7 And KeepTrack(Y, 5, Z) > 0.7) Then
                            OKSeq(Y, 18, Z) = 2 '20.6667, 18.952, 17.523,9.642
                        ElseIf (KeepTrack(Y, 0, Z) > 0.65 And KeepTrack(Y, 1, Z) > 0.65 And KeepTrack(Y, 4, Z) > 0.65) And (KeepTrack(Y, 2, Z) > 0.65 And KeepTrack(Y, 3, Z) > 0.65 And KeepTrack(Y, 5, Z) > 0.65) Then
                            OKSeq(Y, 18, Z) = 2 '20.6667, 18.952, 17.523,9.642
                        End If
                    ElseIf (KeepTrack(Y, 4, Z) < 0.6 And KeepTrack(Y, 5, Z) < 0.6) Then
                        OKSeq(Y, 18, Z) = -1
                    ElseIf (KeepTrack(Y, 1, Z) < 0.6 And KeepTrack(Y, 2, Z) < 0.6) Then
                        OKSeq(Y, 18, Z) = -1
                    ElseIf (KeepTrack(Y, 0, Z) < 0.6 And KeepTrack(Y, 3, Z) < 0.6) Then
                        OKSeq(Y, 18, Z) = -1
                    ElseIf (KeepTrack(Y, 0, Z) < 0.65 And KeepTrack(Y, 1, Z) < 0.65 And KeepTrack(Y, 4, Z) < 0.65) And (KeepTrack(Y, 2, Z) < 0.65 And (KeepTrack(Y, 3, Z)) < 0.65 And (KeepTrack(Y, 5, Z)) < 0.65) Then         ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = -1 '73,85,80,74
                    ElseIf (((KeepTrack(Y, 0, Z) + KeepTrack(Y, 1, Z) + KeepTrack(Y, 4, Z)) / 3 < 0.6) And ((KeepTrack(Y, 2, Z) + KeepTrack(Y, 3, Z) + KeepTrack(Y, 5, Z)) / 3 < 0.6)) Then
                        OKSeq(Y, 18, Z) = -1 ' 14.45, 15.97, 15.57, 16.785
                    Else
                        OKSeq(Y, 18, Z) = 0
                    End If
                    If (KeepTrack(Y, 0, Z) > 0.7 Or KeepTrack(Y, 1, Z) > 0.7 Or KeepTrack(Y, 4, Z) > 0.7) Then
                        BreaksExist(Y, 0, Z) = 1
                    Else
                        BreaksExist(Y, 0, Z) = 0
                    End If
                    If (KeepTrack(Y, 2, Z) > 0.7 Or KeepTrack(Y, 3, Z) > 0.7 Or KeepTrack(Y, 5, Z) > 0.7) Then
                        BreaksExist(Y, 1, Z) = 1
                    Else
                        BreaksExist(Y, 1, Z) = 0
                    End If
                Next Z
            Next Y
        End If

    Else
        For x = VRPos(BPos) - 30 To VRPos(BPos) - 10
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Y = 0 To 2
                For Z = 0 To NextNo
                    
                    
                    KeepTrack(Y, 0, Z) = KeepTrack(Y, 0, Z) + (VarSiteSmooth(Y, A, Z))
                    
                Next Z
            Next Y
        Next x
        
        'do beginning Bp right
        For x = VRPos(BPos) + 10 To VRPos(BPos) + 30
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Y = 0 To 2
                For Z = 0 To NextNo
                        
                        KeepTrack(Y, 1, Z) = KeepTrack(Y, 1, Z) + (VarSiteSmooth(Y, A, Z))
                    
                Next Z
            Next Y
        Next x
        
    'do ending Bp left

    
    
    
        For x = VRPos(Epos) - 30 To VRPos(Epos) - 10
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Y = 0 To 2
                For Z = 0 To NextNo
                    
                        KeepTrack(Y, 2, Z) = KeepTrack(Y, 2, Z) + (VarSiteSmooth(Y, A, Z))
                    
                Next Z
            Next Y
        Next x
        
        'do ending Bp right
        For x = VRPos(Epos) + 10 To VRPos(Epos) + 30
            If x < 0 Then
                A = x + VRPos(UBSN2)
            ElseIf x > VRPos(UBSN2) Then
                A = x - VRPos(UBSN2)
            Else
                A = x
            End If
            For Y = 0 To 2
                For Z = 0 To NextNo
                    KeepTrack(Y, 3, Z) = KeepTrack(Y, 3, Z) + (VarSiteSmooth(Y, A, Z))
                Next Z
            Next Y
        Next x
        If ReassortmentFlag = 1 Or ConservativeGroup = 0 Then
            For Y = 0 To 2
                For Z = 0 To NextNo '2 ~0.7 on ending BP, 3 ~0.70 on ending BP
    '                If Z = 242 Then
    '                    X = X
    '                End If
                    If (KeepTrack(Y, 0, Z) / 21 > 0.8 And KeepTrack(Y, 1, Z) / 21 > 0.8) Or (KeepTrack(Y, 2, Z) / 21 > 0.8 And (KeepTrack(Y, 3, Z) / 21) > 0.8) Then ''37.90476,21.57143,x,x,21.19,34.523
                        OKSeq(Y, 18, Z) = 1 '20.6667, 18.952, 17.523,9.642
                    ElseIf ((KeepTrack(Y, 0, Z) / 21 > 0.75 And KeepTrack(Y, 1, Z) / 21 > 0.75) Or ((KeepTrack(Y, 2, Z) / 21) > 0.75 And (KeepTrack(Y, 3, Z) / 21) > 0.75)) Then
                        OKSeq(Y, 18, Z) = 2 ' 14.45, 15.97, 15.57, 16.785
                    Else
                        OKSeq(Y, 18, Z) = 0
                    End If
                Next Z
            Next Y
        Else
            For Y = 0 To 2
                For Z = 0 To NextNo '2 ~0.7 on ending BP, 3 ~0.70 on ending BP
                'If SEventNumber = 1 And (Z = 8 Or Z = 14) Then
                '            X = X
                '        End If
                
                    If (KeepTrack(Y, 0, Z) / 21 > 0.7 And KeepTrack(Y, 1, Z) / 21 > 0.7) Or ((KeepTrack(Y, 2, Z) / 21) > 0.7 And (KeepTrack(Y, 3, Z) / 21) > 0.7) Then
                        OKSeq(Y, 18, Z) = 1 '20.6667, 18.952, 17.523,9.642
                    ElseIf (KeepTrack(Y, 0, Z) / 21 > 0.65 And KeepTrack(Y, 1, Z) / 21 > 0.65) Or ((KeepTrack(Y, 2, Z) / 21) > 0.65 And (KeepTrack(Y, 3, Z) / 21) > 0.65) Then
                        OKSeq(Y, 18, Z) = 2 ' 14.45, 15.97, 15.57, 16.785
                    Else
                        OKSeq(Y, 18, Z) = 0
                    End If
                Next Z
            Next Y
        End If
    End If
    
Else 'do the groupings as conservatively as possible
    x = x

End If



x = x



'scan accross breakpoints

'For Y = 0 To 2
'    For Z = 0 To Nextno
'        OKSeq(Y, 18, Z) = 0
'    Next Z
'    OKSeq(Y, 18, ISeqs(Y)) = 1
'Next Y
'

Exit Sub
ClearOKseq:
For Y = 0 To 2
    For Z = 0 To NextNo
        OKSeq(Y, 17, Z) = 0
    Next Z
Next Y
'Call SmoothIt(VarsiteSmooth(), VarSiteSmooth2(), 3, LenVarSeq, 0.25)
'Form1.Picture7.AutoRedraw = True
Exit Sub
FAI:
For Y = 0 To 2
        For Z = 0 To NextNo
            OKSeq(Y, 17, Z) = 0
            OKSeq(Y, 18, Z) = 1
        Next Z
    Next Y
End Sub




Public Sub DrawHorstInterval(ST, lP)

HorstFlag = 1
Dim Score As Double, ScoreTable() As Double
ReDim ScoreTable(255, 255, 255)
ScoreTable(66, 66, 66) = 1.92 'AAA
ScoreTable(66, 66, 68) = 2.42 'AAC
ScoreTable(66, 66, 72) = 2.42 'AAG
ScoreTable(66, 66, 85) = 1.25 'AAT


ScoreTable(66, 68, 66) = 3.46 '
ScoreTable(66, 68, 68) = 3.94 'ACC
ScoreTable(66, 68, 72) = 4.3 '
ScoreTable(66, 68, 85) = 3.46 'ACT


ScoreTable(66, 72, 66) = 3.46
ScoreTable(66, 72, 68) = 4.3
ScoreTable(66, 72, 72) = 3.94
ScoreTable(66, 72, 85) = 3.46

ScoreTable(66, 85, 66) = 0.04 'ATA
ScoreTable(66, 85, 68) = 1.13
ScoreTable(66, 85, 72) = 1.13 'ATG
ScoreTable(66, 85, 85) = 0.61


ScoreTable(68, 66, 66) = 2.95
ScoreTable(68, 66, 68) = 3.46
ScoreTable(68, 66, 72) = 3.46
ScoreTable(68, 66, 85) = 2.3

ScoreTable(68, 68, 66) = 4.43
ScoreTable(68, 68, 68) = 4.91
ScoreTable(68, 68, 72) = 5.27
ScoreTable(68, 68, 85) = 4.43

ScoreTable(68, 72, 66) = 5.14
ScoreTable(68, 72, 68) = 5.98
ScoreTable(68, 72, 72) = 5.63
ScoreTable(68, 72, 85) = 5.14

ScoreTable(68, 85, 66) = 2.3
ScoreTable(68, 85, 68) = 3.46
ScoreTable(68, 85, 72) = 3.46
ScoreTable(68, 85, 85) = 2.95


ScoreTable(72, 66, 66) = 2.95
ScoreTable(72, 66, 68) = 3.46
ScoreTable(72, 66, 72) = 3.46
ScoreTable(72, 66, 85) = 2.3

ScoreTable(72, 68, 66) = 5.14
ScoreTable(72, 68, 68) = 5.63
ScoreTable(72, 68, 72) = 5.98
ScoreTable(72, 68, 85) = 5.14

ScoreTable(72, 72, 66) = 4.43
ScoreTable(72, 72, 68) = 5.27
ScoreTable(72, 72, 72) = 4.91
ScoreTable(72, 72, 85) = 4.43

ScoreTable(72, 85, 66) = 2.3
ScoreTable(72, 85, 68) = 3.46
ScoreTable(72, 85, 72) = 3.46
ScoreTable(72, 85, 85) = 2.95

ScoreTable(85, 66, 66) = 0.61
ScoreTable(85, 66, 68) = 1.13
ScoreTable(85, 66, 72) = 1.13
ScoreTable(85, 66, 85) = 0.04 'TAT

ScoreTable(85, 68, 66) = 3.46
ScoreTable(85, 68, 68) = 3.94
ScoreTable(85, 68, 72) = 4.3
ScoreTable(85, 68, 85) = 3.46

ScoreTable(85, 72, 66) = 3.46
ScoreTable(85, 72, 68) = 4.3
ScoreTable(85, 72, 72) = 3.94
ScoreTable(85, 72, 85) = 3.46

ScoreTable(85, 85, 66) = 1.25
ScoreTable(85, 85, 68) = 2.42
ScoreTable(85, 85, 72) = 2.42
ScoreTable(85, 85, 85) = 1.92


Score = 0
Dim ScorePlot() As Double, Pos(2)
ReDim ScorePlot(2, Len(StrainSeq(0)))
For Z = 0 To 2
    For x = ST + Z To ST + lP - 6 Step 3
        'XX = SeqNum(X, 0) ' ='a=66,c=68, g=72, t=85
        Y = 0
        Pos(0) = 0: Pos(1) = 0: Pos(2) = 0
        Do
            If SeqNum(Z + Y, 0) <> 46 Then
                Pos(Y) = x + Y
                Y = Y + 1
                If Y = 3 Then Exit Do
                If Y + x > ST + lP Then Exit For
                If Y + x > Len(StrainSeq(0)) Then Exit For
            End If
        Loop
        ScorePlot(Z, Pos(0)) = ScoreTable(SeqNum(Pos(0), 0), SeqNum(Pos(1), 0), SeqNum(Pos(2), 0))
        ScorePlot(Z, Pos(1)) = ScoreTable(SeqNum(Pos(0), 0), SeqNum(Pos(1), 0), SeqNum(Pos(2), 0))
        ScorePlot(Z, Pos(2)) = ScoreTable(SeqNum(Pos(0), 0), SeqNum(Pos(1), 0), SeqNum(Pos(2), 0))
    Next x
Next Z



    Dim YScaleFactor As Double

    Form1.Picture7.Picture = LoadPicture()
    
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    Form1.Picture7.Cls
    'Draw homology plot in picturebox 7

    Dim PntAPI As POINTAPI
    Dim Pict As Long

    
    XFactor = ((Form1.Picture7.Width - 40) / Decompress((lP)))
    Call DoAxes(0, 0, Decompress(ST + lP), -1, 6, 0, 0, "Energy")
    XFactor = ((Form1.Picture7.Width - 40) / (lP))
    Pict = Form1.Picture7.hdc
    For Z = 0 To 2
        If Z = 0 Then
            Form1.Picture7.ForeColor = RGB(255, 0, 0)
        ElseIf Z = 1 Then
            Form1.Picture7.ForeColor = RGB(0, 255, 0)
        ElseIf Z = 2 Then
            Form1.Picture7.ForeColor = RGB(0, 0, 255)
        End If
        MoveToEx Pict, 30 + Decompress(1) * XFactor, PicHeight - (15 + (ScorePlot(Z, 1) / 6) * (PicHeight - 35)), PntAPI

        For x = ST + 1 To ST + lP - 1 'Len(StrainSeq(0))
            LineTo Pict, 30 + Decompress((x - (ST - 1))) * XFactor, PicHeight - (15 + (ScorePlot(Z, x) / 6) * (PicHeight - 35))
        Next x
    Next Z
    Form1.Picture7.Refresh
End Sub


Public Sub CalcMatch(TreeTrace() As Long, DoPic, SeqNum() As Integer, SX, SY, sa, SB, BPos As Long, Epos As Long)
Dim TargetWin As Long, VSiteNum As Long, LenVarSeq As Long, VarSiteMap() As Integer, SWin As Long, VarSiteSmooth2() As Single, VarSiteSmooth() As Single, Tot As Double
'@
ReDim VarSiteMap(Len(StrainSeq(0))), VXPos(Len(StrainSeq(0)))
'6816 2011
LenVarSeq = 0
oSA = sa
oSB = SB
OSX = SX
oSY = SY
sa = TreeTrace(sa)
SX = TreeTrace(SX)
SY = TreeTrace(SY)
SB = TreeTrace(SB)
'Exit Sub
'Call ModSeqNum(1)

x = BPos
VSiteNum = 0

If LongWindedFlag = 1 And AllCheckFlag = 0 And DoPic = 1 Then
   Call ModSeqNum(0, 0, 0)
End If
'@
If x = x Then
    VSiteNum = CountVSites(x, Len(StrainSeq(0)), sa, SB, SX, Epos, UBound(SeqNum, 1), SeqNum(0, 0))
Else

    Do
        
        If SeqNum(x, sa) <> 46 Then
            If SeqNum(x, SB) <> 46 Then
                If SeqNum(x, SX) <> 46 Then
                    If SeqNum(x, sa) <> SeqNum(x, SB) Or SeqNum(x, sa) <> SeqNum(x, SX) Then
                        VSiteNum = VSiteNum + 1
                    End If
                End If
            End If
        End If
    
        x = x + 1
        If x = Epos Then Exit Do
        If x > Len(StrainSeq(0)) Then
            x = 1
            If x = Epos Then Exit Do
        End If
        
    Loop
End If
If VSiteNum > 30 Then
    TargetWin = 15
Else
    TargetWin = CLng(VSiteNum / 2)
End If
'XX = SWin
If SB > NextNo Or SY > NextNo Or SX > NextNo Or sa > NextNo Then
    Exit Sub
End If


Dim VSBE(1) As Long
'@


If x = x Then
    '@'@'&
    LenVarSeq = MakeVarSites(Len(StrainSeq(0)), BPos, Epos, sa, SB, SX, SY, UBound(SeqNum, 1), SeqNum(0, 0), VXPos(0), VarSiteMap(0), VSBE(0))
    x = x
Else
    LenVarSeq = 0
    For x = 0 To Len(StrainSeq(0))
                If SeqNum(x, sa) <> 46 Then
                    If SeqNum(x, SB) <> 46 Then
                        If SeqNum(x, SX) <> 46 Then
                                If SeqNum(x, sa) <> SeqNum(x, SB) Or SeqNum(x, sa) <> SeqNum(x, SX) Then
                                    
                                    LenVarSeq = LenVarSeq + 1
                                    
                                    VXPos(LenVarSeq) = x
                                    If SeqNum(x, SX) = SeqNum(x, SY) Then
                                        VarSiteMap(LenVarSeq) = 2 '330 (40),393,396,429,435,450,481,483,492,520,521,523,528,531,*****537****,560,579,636,673,674,690
                                                                    '693,696,702,726,732
                                    ElseIf SeqNum(x, SY) <> 46 Then
                                        If (SeqNum(x, SY) = SeqNum(x, SB) And SeqNum(x, SX) = SeqNum(x, sa)) Or (SeqNum(x, SX) = SeqNum(x, SB) And SeqNum(x, SY) = SeqNum(x, sa)) Then  'And SeqNum(X, SY) <> 46 Then
                                            VarSiteMap(LenVarSeq) = -1 '549(57),564,591
                                        ElseIf (SeqNum(x, SY) = SeqNum(x, SB) And SeqNum(x, SY) <> SeqNum(x, sa)) Or (SeqNum(x, SY) <> SeqNum(x, SB) And SeqNum(x, SY) = SeqNum(x, sa)) Then  'And SeqNum(X, SY) <> 46 Then
                                            VarSiteMap(LenVarSeq) = 0 '603
                                        ElseIf SeqNum(x, SY) <> SeqNum(x, SB) And SeqNum(x, SY) <> SeqNum(x, sa) And SeqNum(x, SY) <> SeqNum(x, sa) Then 'And SeqNum(X, SY) <> 46 Then
                                            VarSiteMap(LenVarSeq) = 1
                                        End If
                                    End If
                                    x = x
                                End If
                        End If
                    End If
                End If
                If x = BPos Then
                    VSBE(0) = LenVarSeq
                End If
                If x = Epos Then
                    VSBE(1) = LenVarSeq
                End If
    Next x
End If
'Call UnModSeqNum(1)
ReDim VarSiteSmooth(Len(StrainSeq(0)))
ReDim VarSiteSmooth2(Len(StrainSeq(0)))
'smooth varsitemap
SWin = TargetWin
If x = x Then
    '&
    Dummy = MakeVarSiteMap(SWin, LenVarSeq, VarSiteMap(0), VarSiteSmooth(0))
Else

    Tot = 0
    XX = 0
    For x = 1 - SWin To 1 + SWin
    
        If x < 1 Then
            Z = (LenVarSeq + x) '2450
        ElseIf x > LenVarSeq Then
            Z = x - LenVarSeq
        Else
            Z = x
        End If
        Tot = Tot + VarSiteMap(Z) '4,5,6,8,9,10,11,12,13,14,15,16
'        If VarSiteMap(Z) <> 2 Then
'            ZZ = VXPos(Z) '18,19,21,22,25
'        End If
    Next x
    
    VarSiteSmooth(1) = Tot / ((SWin * 2 + 1) * 2)
    '@'@'@'@'@'@
    For x = 2 To LenVarSeq
    '    If X = 589 Then
    '        X = X
    '    End If
    
        Z = x - SWin - 1
        If Z < 1 Then
            Tot = Tot - VarSiteMap((LenVarSeq + Z))
        ElseIf Z > LenVarSeq Then
            Tot = Tot - VarSiteMap(Z - LenVarSeq)
        Else
            Tot = Tot - VarSiteMap(Z)
        End If
        Z = x + SWin
        If Z > LenVarSeq Then
            Tot = Tot + VarSiteMap(Z - LenVarSeq)
        Else
            Tot = Tot + VarSiteMap(Z)
        End If
        VarSiteSmooth(x) = Tot / ((SWin * 2 + 1) * 2)
        x = x
    Next x
End If


If DoPic = 0 Then
    BEVSS(0) = VarSiteSmooth(VSBE(0))
    BEVSS(1) = VarSiteSmooth(VSBE(1))
    Exit Sub
End If

If x = x Then
    For x = 0 To UBound(VarSiteSmooth, 1)
        VarSiteSmooth2(x) = VarSiteSmooth(x)
    Next x
Else
    Call SmoothIt(VarSiteSmooth(), VarSiteSmooth2(), 3, LenVarSeq, 0.25)
End If
'Form1.Picture7.AutoRedraw = True

sa = oSA
SB = oSB
SX = OSX
SY = oSY
If DoPic = 1 Then
    YScaleFactor = 0.85
    PicHeight = Form1.Picture7.Height * YScaleFactor
    
    XFactor = ((Form1.Picture7.Width - 40) / Decompress(Len(StrainSeq(0))))


    Dim Pict As Long, PntAPI As POINTAPI
    'XX = VXPos(1209) '1208-1209
    'XX = VarSiteSmooth2(1208) '0.506
    ' MoveToEx pict, 30 + XDiffPos(1) * XFactor, PicHeight - (15 + (((XOverHomologyNum(LenXOverSeq, Y) - RDPLD) / (RDPUD - RDPLD))) * (PicHeight - 35)), PntAPI
    Form1.Picture7.ForeColor = RGB(170, 170, 170)
    Form1.Picture7.DrawWidth = 3
    Pict = Form1.Picture7.hdc
    MoveToEx Pict, 30 + Decompress(VXPos(1)) * XFactor, 6, PntAPI
    'LineTo Pict, 30 + Decompress(VXPos(1)) * XFactor, 9
    'MoveToEx pict, 30 + VXPos(1) * XFactor, PicHeight - (15 + VarSiteSmooth2(1) * (PicHeight - 35)), PntAPI
    ReDim GVSS(LenVarSeq)
    
    GLVS = LenVarSeq
    For x = 0 To LenVarSeq
        GVSS(x) = VarSiteSmooth2(x)
        
    Next x
    For x = 2 To LenVarSeq
            
            If x = x Then
                If (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.55 Then
                    Form1.Picture7.ForeColor = HeatMap(0, 1020 - CLng((((VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 - 0.55) / 0.45) * 1020))
                Else
                    Form1.Picture7.ForeColor = HeatMap(0, 1020)
                End If
                Pict = Form1.Picture7.hdc
            Else
                
                
                If (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.95 Then
                    Form1.Picture7.ForeColor = RGB(0, 0, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.9375 Then
                    Form1.Picture7.ForeColor = RGB(0, 32, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.925 Then
                    Form1.Picture7.ForeColor = RGB(0, 64, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.9125 Then
                    Form1.Picture7.ForeColor = RGB(0, 92, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.9 Then
                    Form1.Picture7.ForeColor = RGB(0, 128, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.875 Then
                    Form1.Picture7.ForeColor = RGB(0, 160, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.875 Then
                    Form1.Picture7.ForeColor = RGB(0, 192, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.8625 Then
                    Form1.Picture7.ForeColor = RGB(0, 224, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.85 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 255)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.8375 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 224)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.825 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 198)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.8125 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 160)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.8 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 128)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.7875 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 96)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.775 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 64)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.7625 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 32)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.75 Then
                    Form1.Picture7.ForeColor = RGB(0, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.7375 Then
                    Form1.Picture7.ForeColor = RGB(32, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.725 Then
                    Form1.Picture7.ForeColor = RGB(64, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.7125 Then
                    Form1.Picture7.ForeColor = RGB(96, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.7 Then
                    Form1.Picture7.ForeColor = RGB(128, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.6875 Then
                    Form1.Picture7.ForeColor = RGB(160, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.675 Then
                    Form1.Picture7.ForeColor = RGB(192, 255, 0)
                    Pict = Form1.Picture7.hdc
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.6625 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(224, 255, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.65 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 255, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.6375 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 224, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.625 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 192, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.6125 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 160, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.6 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 128, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.5875 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 96, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.575 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 64, 0)
                ElseIf (VarSiteSmooth2(x) + VarSiteSmooth2(x - 1)) / 2 > 0.5625 Then
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 32, 0)
                Else
                    Pict = Form1.Picture7.hdc
                    Form1.Picture7.ForeColor = RGB(255, 0, 0)
                End If
            End If
            
            LineTo Pict, 30 + Decompress(VXPos(x)) * XFactor, 6
            'LineTo Pict, 30 + Decompress(VXPos(X)) * XFactor, 9
            'LineTo pict, (30 + VXPos(X) * XFactor), (PicHeight - (15 + VarSiteSmooth2(X) * (PicHeight - 35)))
    Next x
    Form1.Picture7.DrawWidth = 1
    Form1.Picture7.Refresh
End If
End Sub
Public Sub SmoothIt(VarSiteSmooth() As Single, VarSiteSmooth2() As Single, SWin, LenVarSeq, MinNo)
Dim Tot As Double
Tot = 0
For x = 1 - SWin To 1 + SWin

    If x < 1 Then
        Z = (LenVarSeq + x) '2450
    ElseIf x > LenVarSeq Then
        Z = x - LenVarSeq
    Else
        Z = x
    End If
    Tot = Tot + VarSiteSmooth(Z)
Next x

VarSiteSmooth2(1) = ((Tot / ((SWin * 2 + 1))) - MinNo) / (1 - MinNo)
If VarSiteSmooth2(1) < 0 Then VarSiteSmooth2(1) = 0
For x = 2 To LenVarSeq
    Z = x - SWin - 1
    If Z < 1 Then
        Tot = Tot - VarSiteSmooth((LenVarSeq + Z))
    ElseIf Z > LenVarSeq Then
        Tot = Tot - VarSiteSmooth(Z - LenVarSeq)
    Else
        Tot = Tot - VarSiteSmooth(Z)
    End If
    Z = x + SWin
    If Z > LenVarSeq Then
        Tot = Tot + VarSiteSmooth(Z - LenVarSeq)
    Else
        Tot = Tot + VarSiteSmooth(Z)
    End If
    VarSiteSmooth2(x) = ((Tot / ((SWin * 2 + 1))) - MinNo) / (1 - MinNo)
    If VarSiteSmooth2(x) < 0 Then VarSiteSmooth2(x) = 0
    
Next x
End Sub
Public Sub SmoothIt2D(VarSiteSmooth() As Single, VarSiteSmooth2() As Single, SWin, LenVarSeq, MinNo, NumE)
Dim Tot As Double


For Y = 0 To NumE
    Tot = 0
    For x = 1 - SWin To 1 + SWin
    
        If x < 1 Then
            Z = (LenVarSeq + x) '2450
        ElseIf x > LenVarSeq Then
            Z = x - LenVarSeq
        Else
            Z = x
        End If
        Tot = Tot + VarSiteSmooth(Y, Z)
    Next x
    
    VarSiteSmooth2(Y, 1) = ((Tot / ((SWin * 2 + 1))) - MinNo) / (1 - MinNo)
    If VarSiteSmooth2(Y, 1) < 0 Then VarSiteSmooth2(Y, 1) = 0
    For x = 2 To LenVarSeq
        Z = x - SWin - 1
        If Z < 1 Then
            Tot = Tot - VarSiteSmooth(Y, (LenVarSeq + Z))
        ElseIf Z > LenVarSeq Then
            Tot = Tot - VarSiteSmooth(Y, Z - LenVarSeq)
        Else
            Tot = Tot - VarSiteSmooth(Y, Z)
        End If
        Z = x + SWin
        If Z > LenVarSeq Then
            Tot = Tot + VarSiteSmooth(Y, Z - LenVarSeq)
        Else
            Tot = Tot + VarSiteSmooth(Y, Z)
        End If
        VarSiteSmooth2(Y, x) = ((Tot / ((SWin * 2 + 1))) - MinNo) / (1 - MinNo)
        If VarSiteSmooth2(Y, x) < 0 Then VarSiteSmooth2(Y, x) = 0
        
    Next x
Next Y
End Sub
Public Sub RCheckWithOther(CC, S1, s2, S3)
        oSeq1 = Seq1
        oSeq2 = Seq2
        oSeq3 = Seq3
        Seq1 = S1 '24
        Seq2 = s2 '2
        Seq3 = S3 '20-29
'If DontDoComboFlag = 0 Then
        Dim tSeqnum() As Integer
        If LongWindedFlag = 1 And AllCheckFlag = 0 Then
           Call ModSeqNum(0, 0, 0)
           
        End If
        'XX = Nextno
        
        'Form1.Refresh
        Form1.Picture7.ScaleMode = 3
If CC = -1 Then
        
        
        If XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum) And pGCTripletflag = 1) Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Or XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or ((XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum) And MCTripletFlag = 0) Then
            If Form1.Combo1.ListIndex = 2 Then
            
                ods = DoScans(0, 2)
                DoScans(0, 2) = 0
                CurrentCheck = 2
                
            ElseIf Form1.Combo1.ListIndex < 5 Then
                CurrentCheck = Form1.Combo1.ListIndex
            ElseIf Form1.Combo1.ListIndex = 5 Then
                CurrentCheck = 10
            ElseIf Form1.Combo1.ListIndex = 6 Then
                CurrentCheck = 5
            ElseIf Form1.Combo1.ListIndex = 9 Then
                CurrentCheck = 13
            ElseIf Form1.Combo1.ListIndex = 13 Then
                CurrentCheck = 8
            ElseIf Form1.Combo1.ListIndex = 15 Then
                CurrentCheck = 11
            ElseIf Form1.Combo1.ListIndex = 16 Then
                CurrentCheck = 12
            ElseIf Form1.Combo1.ListIndex = 17 Or Form1.Combo1.ListIndex = 18 Then
                CurrentCheck = 15
            ElseIf Form1.Combo1.ListIndex = 18 Then
                CurrentCheck = 15
            ElseIf Form1.Combo1.ListIndex = 7 Then
                CurrentCheck = 16
            ElseIf Form1.Combo1.ListIndex = 8 Then
                CurrentCheck = 55
            Else
                CurrentCheck = Form1.Combo1.ListIndex - 2
            End If
        Else 'If CurrentCheck > -1 Then
            If Form1.Combo1.ListIndex = 0 Then
                CurrentCheck = 20
            ElseIf Form1.Combo1.ListIndex = 1 Then
                CurrentCheck = 21
            ElseIf Form1.Combo1.ListIndex = 2 Then
                CurrentCheck = 25
            ElseIf Form1.Combo1.ListIndex = 3 Then
                CurrentCheck = 22
                
            ElseIf Form1.Combo1.ListIndex = 4 Then
                CurrentCheck = 23
            ElseIf Form1.Combo1.ListIndex = 5 Then
                CurrentCheck = 24
            End If
            'CurrentCheck = form1.Combo1.ListIndex + 20
            
            If Form1.Combo1.ListIndex = -1 Then
            End If

        End If
Else
    CurrentCheck = CC
End If
        ExeCheckFlag = 1
        If CurrentCheck = 1 Or (XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum) Or AllCheckFlag = 1 Then
            GCSeq1 = Seq1
                    GCSeq2 = Seq2
                    GCSeq3 = Seq3
            
            If XoverList(RelX, RelY).ProgramFlag = 3 And MCTripletFlag = 1 Then
            
            Else
                If AllCheckFlag = 0 Then
                    Call ModSeqNum(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, 0)
                End If
                Call GCCompare
            End If
        End If
        If XoverList(RelX, RelY).ProgramFlag = 0 Or XoverList(RelX, RelY).ProgramFlag = 0 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 0) = 1) Then

            Call RDPChecking
        End If
        If XoverList(RelX, RelY).ProgramFlag = 8 Or XoverList(RelX, RelY).ProgramFlag = 8 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 8) = 1) Then

            Call TSChecking
        End If
        If XoverList(RelX, RelY).ProgramFlag = 1 Or XoverList(RelX, RelY).ProgramFlag = 1 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 1) = 1) Then
            
            
            If pGCTripletflag = 0 Then
                Call GCChecking
            Else
                Call GCChecking2
            End If
        End If
        'XX = MissingData(1000, Seq3)
        'XX = Seq3
        If XoverList(RelX, RelY).ProgramFlag = 2 Or XoverList(RelX, RelY).ProgramFlag = 2 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 2) = 1) Then

            Call BootscanChecking
        End If
        If XoverList(RelX, RelY).ProgramFlag = 4 Or XoverList(RelX, RelY).ProgramFlag = 4 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 4) = 1) Then

            Call ChimaeraChecking
        End If
        If XoverList(RelX, RelY).ProgramFlag = 5 Or XoverList(RelX, RelY).ProgramFlag = 5 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 5) = 1) Then

            Call SiScanChecking
        End If
        If XoverList(RelX, RelY).ProgramFlag = 6 Or XoverList(RelX, RelY).ProgramFlag = 6 + AddNum Then

            Call PhylProChecking
        End If
        If XoverList(RelX, RelY).ProgramFlag = 3 Or XoverList(RelX, RelY).ProgramFlag = 3 + AddNum Or (AllCheckFlag = 1 And DoScans(0, 3) = 1) Then

            If MCTripletFlag = 0 Then

                Call MaxChiChecking

            Else

                Call MaxChiCheckingII

            End If
        End If
        If CurrentCheck = 55 And (AllCheckFlag = 0) Then
            Dummy = BenHMM2(NUMXY, Seq1, Seq2, Seq3)
        End If

        Dim LineStart As Double
        Dim LineEnd As Double

        If ORFFlag = 1 Then
            Form1.Picture20.BorderStyle = 0
            LineStart = (Form1.Picture20.ScaleWidth / Len(StrainSeq(0))) * RecStart
            LineEnd = (Form1.Picture20.ScaleWidth / Len(StrainSeq(0))) * RecEnd

            If LineEnd > LineStart Then
                Form1.Picture20.DrawMode = 15
                Form1.Picture20.Line (LineStart, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(192, 64, 64), BF
                Form1.Picture20.DrawMode = 13
            Else
                Form1.Picture20.DrawMode = 15
                Form1.Picture20.Line (0, 0)-(LineEnd, Form1.Picture20.ScaleHeight), RGB(192, 64, 64), BF
                Form1.Picture20.Line (LineStart, 0)-(Form1.Picture20.ScaleWidth, Form1.Picture20.ScaleHeight), RGB(192, 64, 64), BF
                Form1.Picture20.DrawMode = 13
            End If

        End If
        If AllCheckFlag = 0 Then
            If LongWindedFlag = 1 Then
                Call UnModNextno
                Call UnModSeqNum(0)
               x = x
                'Seq1 = TreeTraceSeqs(0, Seq1)
                'Seq2 = TreeTraceSeqs(0, Seq2)
                'Seq3 = TreeTraceSeqs(0, Seq3)
                
                'For X = 1 To Len(StrainSeq(0))
                '    SeqNum(X, Seq1) = tSeqNum(X, 0)
                '    SeqNum(X, Seq2) = tSeqNum(X, 1)
                '    SeqNum(X, Seq3) = tSeqNum(X, 2)
                'Next X
            End If
        Else
            Exit Sub
        End If
    ' End If
    
    
    Seq1 = oSeq1
    Seq2 = oSeq2
    Seq3 = oSeq3
        
     If XoverList(RelX, RelY).ProgramFlag <> 1 And XoverList(RelX, RelY).ProgramFlag <> 1 + AddNum Then
            GCSeq1 = Seq1
                    GCSeq2 = Seq2
                    GCSeq3 = Seq3
            
            If XoverList(RelX, RelY).ProgramFlag = 3 And MCTripletFlag = 1 Then
            
            Else
                Call GCCompare
            End If
        End If
        
    If CC = -1 And Form1.Combo1.ListIndex = 2 Then
            DoScans(0, 2) = ods
     End If
        
    Form1.Combo1.Enabled = True
    If CurrentCheck <> 20 And CurrentCheck <> 6 And CurrentCheck <> -1 And CurrentCheck <> 21 And CurrentCheck <> 22 And CurrentCheck <> 24 Then
         Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    End If
    ExeCheckFlag = 0
    Form1.ProgressBar1 = 0
    Form1.SSPanel1.Caption = ""
    Call UpdateF2Prog

End Sub

Public Sub DisableInterface()
    Form1.Combo1.Enabled = False
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    Form1.SSPanel2.Enabled = False
    Form1.Picture8.Enabled = False
    Form1.Picture10.Enabled = False
    Form1.Picture5.Enabled = False
    Form1.Command6(0).Enabled = False
    'Form1.Command25.Enabled = False
    Form1.Command25.ToolTipText = ""
    Form1.Picture7.Enabled = False
    Form1.SSPanel2.Enabled = False
    Form1.SSPanel3.Enabled = False
    Form1.SSPanel4.Enabled = False
    Form1.SSPanel5.Enabled = False
    Form1.SSPanel6(0).Enabled = False
    Form1.SSPanel6(1).Enabled = False
    Form1.SSPanel6(2).Enabled = False
    Form2.Enabled = False
    
    
End Sub
Public Sub EnableInterface()
    Form1.Combo1.Enabled = True
     Form1.Command29(0).Enabled = True: Form1.Command29(1).Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.Picture8.Enabled = True
    Form1.Picture10.Enabled = True
    Form1.Picture5.Enabled = True
    Form1.Command6(0).Enabled = True
    'Form1.Command25.Enabled = True
    Form1.Picture7.Enabled = True
    Form1.SSPanel2.Enabled = True
    Form1.SSPanel3.Enabled = True
    Form1.SSPanel4.Enabled = True
    Form1.SSPanel5.Enabled = True
    Form1.SSPanel6(0).Enabled = True
    Form1.SSPanel6(1).Enabled = True
    Form1.SSPanel6(2).Enabled = True
    Form2.Enabled = True
    
End Sub
Public Sub RescanBest(DF)

Dim rCircularflag As Byte, WeightMod() As Long, Scratch() As Integer, SStart As Long, SEnd As Long
'XX = UBound(MaxXOP, 1)
'XX = AddNum
'Exit Sub
rCircularflag = 1
Form1.Timer1.Enabled = False
Form1.Picture6.Enabled = False
Form1.SSPanel5.Enabled = False
TManFlag = -1
If DF = 0 Then
    SStart = 1
    SEnd = SEventNumber
    SPF = 1
Else
    SStart = DF
    SEnd = DF
    SPF = 1
End If
oRelX = RelX
oRelY = RelY
SPF = 0
For x = SStart To SEnd

   

    Form1.SSPanel1.Caption = "Rescanning" + Str(x) + " of" + Str(SEventNumber) + " detected events"
    RelX = BestEvent(x, 0)
    RelY = BestEvent(x, 1)
    
    If ((XoverList(RelX, RelY).MissIdentifyFlag <> 3 And XoverList(RelX, RelY).MissIdentifyFlag <> 13 And XoverList(RelX, RelY).Accept <> 2) Or (XoverList(RelX, RelY).Accept = 1)) Or XX = XX Then
        
        xMCTripletFlag = MCTripletFlag
        xMCProportionFlag = MCProportionFlag
        xMCStart = MCStart
        xMCEnd = MCEnd
        xMCMaxP = MCMaxP
        xMCSteplen = MCSteplen
        xMCWinSize = MCWinSize
        xMCWinFract = MCWinFract
        xMCStripGapsFlag = MCStripGapsFlag
        xMCFlag = MCFlag
        xXOverWindowX = XOverWindowX
        xCircularFlag = CircularFlag
        xSpacerFlag = SpacerFlag
        xLowestProb = LowestProb
        xBSTypeFlag = BSTypeFlag
        xBSStepSize = BSStepSize
        xBSStepWin = BSStepWin
        xBSBootReps = BSBootReps
        xBSCutoff = BSCutOff
        xBSPValFlag = BSPValFlag
        xSSGapFlag = SSGapFlag
        xSSVarPFlag = SSVarPFlag
        xSSOutlyerFlag = SSOutlyerFlag
        xSSRndSeed = SSRndSeed
        xSSWinLen = SSWinLen
        xSSStep = SSStep
        xSSNumPerms = SSNumPerms
        xGCMissmatchPen = GCMissmatchPen
        xGCIndelFlag = GCIndelFlag
        xGCMinFragLen = GCMinFragLen
        xGCMinPolyInFrag = GCMinPolyInFrag
        xGCMinPairScore = GCMinPairScore
        xGCMaxOverlapFrags = GCMaxOverlapFrags
        xGCTripletFlag = GCtripletflag
        xPPStripGaps = PPStripGaps
        Dim A As Integer
        If NextNo > UBound(pMaskSeq, 1) Then
            ReDim Preserve pMaskSeq(NextNo)
        End If
        For A = 0 To NextNo
            MaskSeq(A) = pMaskSeq(A)
        Next 'A
        
        MCTripletFlag = pMCTripletFlag
        MCProportionFlag = pMCProportionFlag
        MCStart = pMCStart
        MCEnd = pMCEnd
        MCMaxP = pMCMaxP
        MCSteplen = pMCSteplen
        MCWinSize = pMCWinSize
        MCWinFract = pMCWinFract
        MCStripGapsFlag = pMCStripGapsFlag
        MCFlag = pMCFlag
        XOverWindowX = pXOverWindowX
        CircularFlag = pCircularFlag
        SpacerFlag = pSpacerFlag
        LowestProb = pLowestProb
        BSTypeFlag = pBSTypeFlag
        BSStepSize = pBSStepSize
        BSStepWin = pBSStepWin
        BSBootReps = pBSBootReps
        BSCutOff = pBSCutoff
        BSPValFlag = pBSPValFlag
        
        SSGapFlag = pSSGapFlag
        SSVarPFlag = pSSVarPFlag
        SSOutlyerFlag = pSSOutlyerFlag
        SSRndSeed = pSSRndSeed
        SSWinLen = pSSWinLen
        SSStep = pSSStep
        SSNumPerms = pSSNumPerms
        PPStripGaps = pPPStripGaps
        
        Seq1 = XoverList(RelX, RelY).MajorP
        Seq2 = XoverList(RelX, RelY).MinorP
        Seq3 = XoverList(RelX, RelY).Daughter
        
        ReDim tSeqnum(Len(StrainSeq(0)), 2)
        EN = XoverList(RelX, RelY).Eventnumber
                    
        EditSeqFlag = 0
        Call ModSeqNum(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SPF)
                        
        Form1.SSPanel1.Caption = "Rescanning" + Str(x) + " of" + Str(SEventNumber) + " detected events"
        Call MakeTreeSeqs(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending)
                        
        GCSeq1 = Seq1
        GCSeq2 = Seq2
        GCSeq3 = Seq3
        'If X >= 17 Then
        '    X = X
        'End If
        
        If AbortFlag = 1 Then
            
            Exit Sub
        End If
        If rCircularflag = 1 Then
            For Z = 0 To NextNo
                MissingData(1, Z) = 1
                MissingData(Len(StrainSeq(0)), Z) = 1
            Next Z
        End If
           
        Call GCCompare
        
        Dim XPS As Long, YPS As Long
        XPS = BestEvent(x, 0)
        YPS = BestEvent(x, 1)
'        Call ModNextno
'        Seq1 = TreeTraceSeqs(0, Seq1)
'        Seq2 = TreeTraceSeqs(0, Seq2)
'        Seq3 = TreeTraceSeqs(0, Seq3)
        
        If RIMode = 1 Then
            'tCurE = X
            xRelX = RelX
            xRelY = RelY
            RecSeq = BestEvent(x, 0)
            PAVal = BestEvent(x, 1)
            RelX = 0
            RelY = 0
            Call MakeSummary
            RelX = xRelX
            RelY = xRelY
        End If
        For CurrentCheck = 0 To 10
            GoOn = 200
            XX = NextNo
            'Call ModNextno
            
            Call ModSeqNum(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending, SPF)
                        
            'Form1.SSPanel1.Caption = "Rescanning" + Str(X) + " of" + Str(SEventNumber) + " detected events"
            Call MakeTreeSeqs(XoverList(RelX, RelY).Beginning, XoverList(RelX, RelY).Ending)
            'Form1.Picture7.Picture = LoadPicture()
            If CurrentCheck = 0 And (Confirm(x, 0) = 0 Or XoverList(XPS, YPS).ProgramFlag = 0) Then
                If XoverList(XPS, YPS).ProgramFlag = 0 Then
                    GoOn = 0
                End If
                xSpacerFlag = SpacerFlag
                XOverWindowX = CDbl(Form3.Text2.Text)
                
                Call XOverIII(SPF)
                If SPF = 0 Then Form1.Picture7.Refresh
                SpacerFlag = xSpacerFlag
            ElseIf CurrentCheck = 1 And (Confirm(x, 1) = 0 Or XoverList(XPS, YPS).ProgramFlag = 1) Then
                    If XoverList(XPS, YPS).ProgramFlag = 1 Then
                        GoOn = 1
                    End If
                    Call GCCheck(SPF)
                    If SPF = 0 Then Form1.Picture7.Refresh
                x = x
            
            ElseIf CurrentCheck = 2 And (Confirm(x, 2) = 0 Or XoverList(XPS, YPS).ProgramFlag = 2) Then
                If XoverList(XPS, YPS).ProgramFlag = 2 Then
                    GoOn = 2
                End If
                Call FindSubSeqBS
                
                If DoScans(0, 2) = 1 And UBound(BSFilePos, 2) > 0 Then
                    
                    Call BSXoverl(SPF)
                    If SPF = 0 Then Form1.Picture7.Refresh
                Else
                    ReDim Preserve MaxXOP(AddNum - 1, NextNo)
                    Call ResetMaxPVCO(NextNo)
                    
                        '
                        s1col = Yellow
                        s1colb = LYellow
                        s2col = Purple
                        s2colb = LPurple
                        s3col = Green
                        s2colb = LGreen
                        Call FindSubSeqBS
                        
                        ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
                        Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
                        Call BSXoverM(SPF, 0, WeightMod())
                        If SPF = 0 Then Form1.Picture7.Refresh
                        
                    
        
                End If
                
            
                
            ElseIf CurrentCheck = 4 And (Confirm(x, 3) = 0 Or XoverList(XPS, YPS).ProgramFlag = 3) Then
                If XoverList(XPS, YPS).ProgramFlag = 3 Then
                    GoOn = 3
                End If
                Call MCXoverG(SPF)
                If SPF = 0 Then Form1.Picture7.Refresh
                
            ElseIf CurrentCheck = 5 And (Confirm(x, 5) = 0 Or XoverList(XPS, YPS).ProgramFlag = 5) Then
                If XoverList(XPS, YPS).ProgramFlag = 5 Then
                    GoOn = 5
                End If
                Call SSXoverB(SPF)
               If SPF = 0 Then Form1.Picture7.Refresh
               
            ElseIf CurrentCheck = 6 And (Confirm(x, 6) = 0) And (DoScans(0, 7) = 1 Or DoScans(1, 7) = 1) Then
               Call LXoverB(1, 1)
            ElseIf CurrentCheck = 10 And (Confirm(x, 4) = 0 Or XoverList(XPS, YPS).ProgramFlag = 4) Then
                If XoverList(XPS, YPS).ProgramFlag = 4 Then
                    GoOn = 4
                End If
                Call CXoverC(SPF)
                
                If SPF = 0 Then Form1.Picture7.Refresh
            End If
            If GoOn < 200 Then
                Dim RL As Long, LS As Long, BPos As Long, Epos As Long
                If GoOn = 0 Then
                    RL = XoverWindow
                    
                ElseIf GoOn = 1 Then
                    RL = 10
                ElseIf GoOn = 2 Then
                    RL = 10
                ElseIf GoOn = 3 Then
                    RL = MCWinSize / 2
                ElseIf GoOn = 4 Then
                    RL = CWinSize / 2
                ElseIf GoOn = 5 Then
                    RL = 10
                End If
                LS = LenXoverSeq
                BPos = XoverList(XPS, YPS).Beginning
                Epos = XoverList(XPS, YPS).Ending
                
                Warn = 0
                Call CheckEndsVB(0, 0, RL, Warn, LS, 0, CircularFlag, Seq1, Seq2, Seq3, BPos, Epos, SeqNum(), XPosDiff(), XDiffPos())
                
                If Warn = 1 Then
                    If XoverList(XPS, YPS).SBPFlag = 0 Then
                        XoverList(XPS, YPS).SBPFlag = 1
                    ElseIf XoverList(XPS, YPS).SBPFlag = 2 Then
                        XoverList(XPS, YPS).SBPFlag = 3
                    
                    End If
                'Else
                '    XOverList(XPS, YPS).SBPFlag = 0
                End If
                
                Warn = 0
                Call CheckEndsVB(0, 0, RL, Warn, LS, 1, CircularFlag, Seq1, Seq2, Seq3, BPos, Epos, SeqNum(), XPosDiff(), XDiffPos())

                
                If Warn = 1 Then
                    If XoverList(XPS, YPS).SBPFlag = 0 Then
                        XoverList(XPS, YPS).SBPFlag = 2
                    ElseIf XoverList(XPS, YPS).SBPFlag = 1 Then
                        XoverList(XPS, YPS).SBPFlag = 3
                    End If
                
                'Else
                '    XOverList(XPS, YPS).SBPFlag = 0
                End If
            End If
            
            
        Next CurrentCheck
        
        Call UnModNextno
        Call UnModSeqNum(0)
        'Retrieve variable states saved before analysis began
        MCTripletFlag = xMCTripletFlag
        MCProportionFlag = xMCProportionFlag
        MCStart = xMCStart
        MCEnd = xMCEnd
        MCMaxP = xMCMaxP
        MCSteplen = xMCSteplen
        MCWinSize = xMCWinSize
        MCWinFract = xMCWinFract
        MCStripGapsFlag = xMCStripGapsFlag
        MCFlag = xMCFlag
        XOverWindowX = xXOverWindowX
        CircularFlag = xCircularFlag
        SpacerFlag = xSpacerFlag
        LowestProb = xLowestProb
        SpacerNo = SpacerNo
        BSTypeFlag = xBSTypeFlag
        BSStepSize = xBSStepSize
        BSStepWin = xBSStepWin
        BSBootReps = xBSBootReps
        BSCutOff = xBSCutoff
        BSPValFlag = xBSPValFlag
        SSGapFlag = xSSGapFlag
        SSVarPFlag = xSSVarPFlag
        SSOutlyerFlag = xSSOutlyerFlag
        SSRndSeed = xSSRndSeed
        SSWinLen = xSSWinLen
        SSStep = xSSStep
        SSNumPerms = xSSNumPerms
        GCMissmatchPen = xGCMissmatchPen
        GCIndelFlag = xGCIndelFlag
        GCMinFragLen = xGCMinFragLen
        GCMinPolyInFrag = xGCMinPolyInFrag
        GCMinPairScore = xGCMinPairScore
        GCMaxOverlapFrags = xGCMaxOverlapFrags
        GCtripletflag = xGCTripletFlag
        PPStripGaps = xPPStripGaps
        
    End If
    
    Form1.ProgressBar1.Value = (x / SEventNumber) * 100
    Call UpdateF2Prog
    Form1.Refresh
    Form1.Refresh: If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Next x

Call IntegrateXOvers(0)

RelX = oRelX
RelY = oRelY

If RIMode = 1 Then
    Call MakeSummary
    x = x
End If

Form1.SSPanel1.Caption = ""
Form1.ProgressBar1.Value = 0
Call UpdateF2Prog
Screen.MousePointer = 0
Form1.Timer1.Enabled = True
Form1.Picture6.Enabled = True
Form1.SSPanel5.Enabled = True
End Sub

Public Sub UpdateEvents(SE)

Dim BestP, AProg() As Byte
ReDim AProg(AddNum * 2)

If DoScans(0, 0) = 1 Then AProg(0) = 1: AProg(0 + AddNum) = 1
If DoScans(0, 1) = 1 Then AProg(1) = 1: AProg(1 + AddNum) = 1
If DoScans(0, 2) = 1 Then AProg(2) = 1: AProg(2 + AddNum) = 1
If DoScans(0, 3) = 1 Then AProg(3) = 1: AProg(3 + AddNum) = 1
If DoScans(0, 4) = 1 Then AProg(4) = 1: AProg(4 + AddNum) = 1
If DoScans(0, 5) = 1 Then AProg(5) = 1: AProg(5 + AddNum) = 1
If DoScans(0, 6) = 1 Then AProg(6) = 1: AProg(6 + AddNum) = 1
If DoScans(0, 7) = 1 Then AProg(7) = 1: AProg(7 + AddNum) = 1
If DoScans(0, 8) = 1 Then AProg(8) = 1: AProg(8 + AddNum) = 1
'XX = UBound(BestP, 1)
'ReDim BestP(SEventNumber)
'For Y = 0 To SEventNumber
    For x = 0 To AddNum - 1
        Confirm(SE, x) = 0
        ConfirmP(SE, x) = 0
    Next x
'Next Y
BestP = 100000
    For x = 0 To PermNextno
        For Y = 1 To CurrentXOver(x)
            If SuperEventList(XoverList(x, Y).Eventnumber) = SE Then
                PF = XoverList(x, Y).ProgramFlag
                If PF <= AddNum - 1 Then
                    If XoverList(x, Y).Probability > 0 And (XoverList(x, Y).Probability < BestP Or BestP = 0) Then
                        If AProg(XoverList(x, Y).ProgramFlag) = 1 Then
                            BestP = XoverList(x, Y).Probability
                            BestEvent(SE, 0) = x
                            BestEvent(SE, 1) = Y
                        End If
                    End If
                    Confirm(SE, PF) = Confirm(SE, PF) + 1
                    ConfirmP(SE, PF) = ConfirmP(SE, PF) + -Log10(XoverList(x, Y).Probability)
                End If
            End If
        Next Y
    Next x
    If BestP = 100000 Then
        For x = 0 To PermNextno
            For Y = 1 To CurrentXOver(x)
                If SuperEventList(XoverList(x, Y).Eventnumber) = SE Then
                    PF = XoverList(x, Y).ProgramFlag
                    If PF > AddNum - 1 Then
                        If XoverList(x, Y).Probability > 0 And (XoverList(x, Y).Probability < BestP Or BestP = 0) Then
                            XX = UBound(AProg, 1)
                            If XoverList(x, Y).ProgramFlag <= 18 Then
                                If AProg(XoverList(x, Y).ProgramFlag) = 1 Then
                                    BestP = XoverList(x, Y).Probability
                                    BestEvent(SE, 0) = x
                                    BestEvent(SE, 1) = Y
                                End If
                            End If
                        End If
                    
                        PF = PF - AddNum
                        If PF <= 8 Then
                            Confirm(SE, PF) = Confirm(SuperEventList(XoverList(x, Y).Eventnumber), PF) + 1
                            ConfirmP(SE, PF) = ConfirmP(SuperEventList(XoverList(x, Y).Eventnumber), PF) + -Log10(XoverList(x, Y).Probability)
                        End If
                    End If
                End If
            Next Y
        Next x
    End If
End Sub

Public Sub CheckDists(SeqNum() As Integer, PermValid() As Single)

Dim PVA() As Long
    ReDim PVA(NextNo, NextNo)
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            For Z = 1 To Len(StrainSeq(0))
                If SeqNum(Z, x) <> 46 And SeqNum(Z, Y) <> 46 Then
                    PVA(x, Y) = PVA(x, Y) + 1
                End If
            Next Z
            PVA(Y, x) = PVA(x, Y)
        Next Y
        
    Next x
    For x = 0 To NextNo
        For Y = x + 1 To NextNo
            If PVA(x, Y) <> PermValid(x, Y) Then
                x = x
            End If
        Next Y
    Next x
End Sub

Public Sub FindBestRecSignalVB(TotalNoRecombinants, LowP As Double, Trace() As Long, PCurrentXover() As Integer, DoneSeq() As Byte, PXOList() As XOverDefine)
pvalsearch = 0
If pvalsearch = 1 Then
        For x = 0 To NextNo
            TotalNoRecombinants = TotalNoRecombinants + PCurrentXover(x)
           
            For Y = 1 To PCurrentXover(x)
                
             '   If SEventNumber > 68 And X = X Then
             '
             '       If PXOList(X, Y).Daughter = 16 Or PXOList(X, Y).Daughter = 29 Or PXOList(X, Y).Daughter = 15 Then
             '       If PXOList(X, Y).MinorP = 16 Or PXOList(X, Y).MinorP = 29 Or PXOList(X, Y).MinorP = 15 Then
              ''      If PXOList(X, Y).MajorP = 16 Or PXOList(X, Y).MajorP = 29 Or PXOList(X, Y).MajorP = 15 Then
             '           X = X
             '
             '       End If
             '       End If
             '       End If
             '   End If
                If DoneSeq(x, Y) = DoneTarget Then
                    CPVal = PXOList(x, Y).Probability
                    
                    If CPVal > 0 And CPVal < LowP Then ' And (PXOList(X, Y).ProgramFlag <> 5 Or OnlySiScan = 1) Then
                        If PXOList(x, Y).Beginning <> PXOList(x, Y).Ending Then
                            LowP = CPVal
                            Trace(0) = x
                            Trace(1) = Y
                            
                       End If
                    
                       ' XX = PXOList(Trace(0), Trace(1)).Daughter
                       ' XX = PXOList(Trace(0), Trace(1)).MinorP
                       ' XX = PXOList(Trace(0), Trace(1)).MajorP
                       ' XX = PXOList(Trace(0), Trace(1)).Beginning
                       ' XX = PXOList(Trace(0), Trace(1)).Ending
                    End If
                End If
            Next Y
        Next x
    Else 'use a distance search
        Dim DistA() As Single, DistB() As Single, Sites() As Double, LowDist As Double, S(2) As Long, SubDiffs() As Single, SubValid() As Single
        LowDist = 1000
        'LowP = 100000
        ReDim DistA(NextNo, NextNo), DistB(NextNo, NextNo), SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo)
        For x = 0 To NextNo
            TotalNoRecombinants = TotalNoRecombinants + PCurrentXover(x)
           
            For Y = 1 To PCurrentXover(x)
                
                If DoneSeq(x, Y) = DoneTarget Then
                    S(0) = PXOList(x, Y).Daughter
                    S(1) = PXOList(x, Y).MajorP
                    S(2) = PXOList(x, Y).MinorP
                    BE = PXOList(x, Y).Beginning
                    EN = PXOList(x, Y).Ending
                    
                    
                    Dummy = vQuickDist(Len(StrainSeq(0)), NextNo, NextNo, BE, EN, DistA(0, 0), DistB(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0), S(0))
                    
                    
                    
                    
                    For b = 0 To 2
                        For C = b + 1 To 2
                            If DistA(S(b), S(C)) < LowDist Then
                                LowDist = DistA(S(b), S(C))
                                Trace(0) = x
                                Trace(1) = Y
                                LowP = PXOList(x, Y).Probability
                            ElseIf DistA(S(b), S(C)) = LowDist Then
                                If PXOList(x, Y).Probability < LowP Then
                                    LowDist = DistA(S(b), S(C))
                                    Trace(0) = x
                                    Trace(1) = Y
                                    LowP = PXOList(x, Y).Probability
                                End If
                            End If
                            If DistB(S(b), S(C)) < LowDist Then
                                LowDist = DistB(S(b), S(C))
                                Trace(0) = x
                                Trace(1) = Y
                                LowP = PXOList(x, Y).Probability
                            ElseIf DistB(S(b), S(C)) = LowDist Then
                                If PXOList(x, Y).Probability < LowP Then
                                    LowDist = DistB(S(b), S(C))
                                    Trace(0) = x
                                    Trace(1) = Y
                                    LowP = PXOList(x, Y).Probability
                                End If
                            End If
                        Next C
                    Next b
                   
                    
                End If
            Next Y
        Next x
        'LowP = PXOList(Trace(0), Trace(1)).Probability
    End If
End Sub
'Declare Function FindActualEvents Lib "dna.dll" (RSize As Long, ByRef Don As Byte, ByRef BPMatch As Long,  ByRef OKSeq As Double, ByRef FoundOne As Long, ByRef SP As Long, ByRef EP As Long, ByRef RCorr As Double, ByRef OLSeq As Long, ByRef OLSeqB As Long, ByRef OLSeqE As Long, ByRef CSeq As LoInvS As Byte, ByRef TrS As Long, ByRef TMatch As Double, ByRef PXOList As XOverDefine, ByRef PCurrentXOver As Integer, ByRef SQ As Long, ByRef tDon As Byte, ByRef ISeqs As Long, ByRef TList As Byte, ByRef CompMat As Long) As Long

Public Sub FindActualEventsVB(RLScore() As Double, UNF() As Byte, InvList() As Long, NextNo As Long, RSize() As Long, BPMatch() As Long, BMatch() As Single, OKSeq() As Double, FoundOne() As Long, SP() As Long, EP() As Long, RCorr() As Single, OLSeq() As Long, OLSeqB() As Long, OLSeqE() As Long, CSeq() As Long, RNum() As Long, RList() As Long, InvS() As Byte, tMatch() As Double, PXOList() As XOverDefine, PCurrentXover() As Integer, SQ() As Long, tDon() As Byte, ISeqs() As Long, CompMat() As Long)
    Dim otMatch As Double, OLSize As Long, EPos2 As Long, BPos2 As Long, GoOn As Long, A As Long, ZZZX As Long, ZZX As Long, oldY As Long, Dummy As Long, WinPP As Long, TList() As Byte, Don() As Byte, TrS(2) As Long, Y As Long, x As Long
'  XX = InvList(0, 0)
'    XX = InvList(1, 0) '1
'    XX = InvList(2, 0)
'    XX = InvList(0, 1)
'    XX = InvList(1, 1) '1
'    XX = InvList(2, 1)
'    XX = InvList(0, 2)
'    XX = InvList(1, 2) '1
'    XX = InvList(2, 2)
'    XX = InvList(0, 3)
'    XX = InvList(1, 3)
'    XX = InvList(2, 3)
'    XX = InvList(0, 4)
'    XX = InvList(1, 4) '1
'    XX = InvList(2, 4)
'    XX = InvList(0, 5)
'    XX = InvList(1, 5) '1
'    XX = InvList(2, 5)
        
  '      If X = 12345 Then ' use this if all must be compared against all
  '          ReDim TList(2, NextNo)
  '          For X = 0 To 2
  '              For Y = 0 To RNum(X)
  '                  TList(X, RList(X, Y)) = 1
  '              Next Y
  '          Next X
  '      End If
        
        'If SEventNumber = 24 Then
        '    For X = 0 To NextNo
        '        For Y = 1 To PCurrentXOver(X)
        '            If PXOList(X, Y).Daughter = ISeqs(0) Or PXOList(X, Y).MinorP = ISeqs(0) Or PXOList(X, Y).MajorP = ISeqs(0) Then
        '            If PXOList(X, Y).Daughter = ISeqs(1) Or PXOList(X, Y).MinorP = ISeqs(1) Or PXOList(X, Y).MajorP = ISeqs(1) Then
        '            'If PXOList(X, Y).MajorP = ISeqs(0) Or PXOList(X, Y).MajorP = ISeqs(1) Or PXOList(X, Y).MajorP = 13 Then
        '                X = X
        '            'End If
        '            End If
        '            End If
        '        Next Y
        '    Next X
        '    X = X
        'End If
        'X = X
        'For X = 0 To 2
        '    XX = RNum(X) '23,15,15:15,15,23
        '    XX = InPen(X) '1(dug),1(10cd),0(cin)
        '    For Y = 0 To RNum(X)
        '
        '        XX = originalname(RList(X, Y))
        '        'dug,dug
        '        '10cd
        '        'cin,08bc,ges,cza,cbr
        '    Next Y
        'Next X
    'End If
        
        ReDim Don(2, NextNo)
        
        ReDim tDon(5)
        'XX = Trace(1)
        For WinPP = 0 To 2
            
            'If X = X Then 'use this to only screen against iseqs
                ReDim TList(2, NextNo)
                TList(CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 0))) = 1
                TList(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 1))) = 1
                For Y = 0 To RNum(WinPP)
                    TList(WinPP, RList(WinPP, Y)) = 1
                Next Y
            'End If
            
            ReDim FoundOne(NextNo)
            If x = x Then
                Dummy = FindActualEvents(Len(StrainSeq(0)), WinPP, NextNo, UBound(PXOList, 1), RSize(0), Don(0, 0), BPMatch(0, 0, 0), BMatch(0, 0), OKSeq(0, 0, 0), FoundOne(0), SP(0), EP(0), RCorr(0, 0, 0), OLSeq(0), OLSeqB(0), OLSeqE(0), CSeq(0), RNum(0), RList(0, 0), InvS(0, 0), TrS(0), tMatch(0), PXOList(0, 0), PCurrentXover(0), SQ(0), tDon(0), ISeqs(0), TList(0, 0), CompMat(0, 0))
                
            Else
                For x = 0 To NextNo
                    
                    If TList(WinPP, x) = 1 Or ISeqs(CompMat(WinPP, 0)) = x Or ISeqs(CompMat(WinPP, 1)) = x Then
                        oldY = -1
                        For Y = 1 To PCurrentXover(x)
                            If oldY <> Y Then
                                tDon(0) = 0: tDon(1) = 0: tDon(2) = 0: tDon(3) = 0: tDon(4) = 0: tDon(5) = 0
                                oldY = Y
                                ZZX = 0
                            Else
                                ZZX = ZZX + 1
                                If ZZX > 6 Then
                                    ReDim tDon(5)
                                    oldY = Y
                                    Y = Y + 1
                                    ZZX = 0
                                    If Y > PCurrentXover(x) Then Exit For
                                    
                                End If
                                If Y = oldY Then
                                    ZZZX = 0
                                    For A = 0 To 5
                                        ZZZX = ZZZX + tDon(A)
                                    Next A
                                    If ZZZX = 6 Then
                                        Y = Y + 1
                                        ReDim tDon(5)
                                        oldY = Y
                                        ZZX = 0
                                        ZZZX = 0
                                        If Y > PCurrentXover(x) Then Exit For
                                    End If
                                    
                                End If
                            End If
                            SQ(1) = PXOList(x, Y).MajorP
                            If TList(WinPP, SQ(1)) = 1 Or ISeqs(CompMat(WinPP, 0)) = SQ(1) Or ISeqs(CompMat(WinPP, 1)) = SQ(1) Then
                                GoOn = 0
                                SQ(2) = PXOList(x, Y).MinorP
                                If x = 1234 Then
                                        
                                   ' Dummy = tester1(X, Y, GoOn, Len(StrainSeq(0)), WinPP, NextNo, UBound(PXOList, 1), RSize(0), Don(0, 0), BPMatch(0, 0, 0), BMatch(0, 0), OKSeq(0, 0, 0), FoundOne(0), SP(0), EP(0), RCorr(0, 0, 0), OLSeq(0), OLSeqB(0), OLSeqE(0), CSeq(0), RNum(0), RList(0, 0), InvS(0, 0), TrS(0), TMatch(0), PXOList(0, 0), PCurrentXOver(0), SQ(0), tDon(0), ISeqs(0), TList(0, 0), CompMat(0, 0))
                                Else
                                    If (TList(WinPP, SQ(2)) = 1 Or ISeqs(CompMat(WinPP, 0)) = SQ(2) Or ISeqs(CompMat(WinPP, 1)) = SQ(2)) Then
                                        SQ(0) = x
                                        
                                     '   If SEventNumber = 24 Then
                                     '   'XX = RNum(1)
                                     '   'XX = originalname(ISeqs(WinPP))
                                     '       If SQ(0) = ISeqs(0) Or SQ(0) = ISeqs(1) Or SQ(0) = 33 Then
                                     '       If SQ(1) = ISeqs(0) Or SQ(1) = ISeqs(1) Or SQ(1) = 33 Then
                                     '       If SQ(2) = ISeqs(0) Or SQ(2) = ISeqs(1) Or SQ(2) = 33 Then
                                     '           X = X
                                     '       End If
                                     '       End If
                                     '       End If
                                     '   End If
                                        tMatch(0) = 0
                                        If tDon(0) = 0 And ((WinPP = 0 And Don(0, SQ(0)) = 0) Or (WinPP = 1 And Don(1, SQ(1)) = 0) Or (WinPP = 2 And Don(2, SQ(2)) = 0)) And TList(0, SQ(0)) = 1 And TList(1, SQ(1)) = 1 And TList(2, SQ(2)) = 1 Then
                                            tDon(0) = 1: TrS(0) = SQ(0): TrS(1) = SQ(1): TrS(2) = SQ(2): tMatch(0) = 3
                                        ElseIf tDon(1) = 0 And ((WinPP = 0 And Don(0, SQ(0)) = 0) Or (WinPP = 1 And Don(1, SQ(2)) = 0) Or (WinPP = 2 And Don(2, SQ(1)) = 0)) And TList(0, SQ(0)) = 1 And TList(1, SQ(2)) = 1 And TList(2, SQ(1)) = 1 Then
                                            tDon(1) = 1: TrS(0) = SQ(0): TrS(1) = SQ(2): TrS(2) = SQ(1): tMatch(0) = 3
                                        ElseIf tDon(2) = 0 And ((WinPP = 0 And Don(0, SQ(1)) = 0) Or (WinPP = 1 And Don(1, SQ(2)) = 0) Or (WinPP = 2 And Don(2, SQ(0)) = 0)) And TList(0, SQ(1)) = 1 And TList(1, SQ(2)) = 1 And TList(2, SQ(0)) = 1 Then
                                            tDon(2) = 1: TrS(0) = SQ(1): TrS(1) = SQ(2): TrS(2) = SQ(0): tMatch(0) = 3
                                        ElseIf tDon(3) = 0 And ((WinPP = 0 And Don(0, SQ(1)) = 0) Or (WinPP = 1 And Don(1, SQ(0)) = 0) Or (WinPP = 2 And Don(2, SQ(2)) = 0)) And TList(0, SQ(1)) = 1 And TList(1, SQ(0)) = 1 And TList(2, SQ(2)) = 1 Then
                                            tDon(3) = 1: TrS(0) = SQ(1): TrS(1) = SQ(0): TrS(2) = SQ(2): tMatch(0) = 3
                                        ElseIf tDon(4) = 0 And ((WinPP = 0 And Don(0, SQ(2)) = 0) Or (WinPP = 1 And Don(1, SQ(1)) = 0) Or (WinPP = 2 And Don(2, SQ(0)) = 0)) And TList(0, SQ(2)) = 1 And TList(1, SQ(1)) = 1 And TList(2, SQ(0)) = 1 Then
                                            tDon(4) = 1: TrS(0) = SQ(2): TrS(1) = SQ(1): TrS(2) = SQ(0): tMatch(0) = 3
                                        ElseIf tDon(5) = 0 And ((WinPP = 0 And Don(0, SQ(2)) = 0) Or (WinPP = 1 And Don(1, SQ(0)) = 0) Or (WinPP = 2 And Don(2, SQ(1)) = 0)) And TList(0, SQ(2)) = 1 And TList(1, SQ(0)) = 1 And TList(2, SQ(1)) = 1 Then
                                            tDon(5) = 1: TrS(0) = SQ(2): TrS(1) = SQ(0): TrS(2) = SQ(1): tMatch(0) = 3
                                        End If
                                        
                                        If tMatch(0) = 3 Then
                                        
                                            For A = 0 To 2
                                                If TrS(WinPP) = SQ(A) Then
                                                    
                                                    Exit For
                                                End If
                                            Next A
                                        
                                        
                                            If InvS(CompMat(WinPP, 0), TrS(CompMat(WinPP, 0))) = 0 And InvS(CompMat(WinPP, 1), TrS(CompMat(WinPP, 1))) = 0 Then
                                                For A = 0 To RNum(WinPP)
                                                    If RList(WinPP, A) = TrS(WinPP) Then
                                                        Exit For
                                                    End If
                                                Next A
                                                
                                                If A > RNum(WinPP) Then
                                                    tMatch(0) = 0
                                                Else
                                                    CSeq(1) = A
                                                    GoOn = 1
                                                    'If FoundOne(CSeq(1)) = 1 Then TMatch(0) = 0
                                                End If
                                            Else
                                                tMatch(0) = 0
                                            End If
                                            
                                            'ie an event involving a potentially recombinant sequence is found.
                                                            
                                                If tMatch(0) = 3 And GoOn = 1 Then
                                                    'check for region overlap
                                                    
                                                    BPos2 = PXOList(x, Y).Beginning
                                                    EPos2 = PXOList(x, Y).Ending
                                                    OLSize = FindOverlap(Len(StrainSeq(0)), BPos2, EPos2, RSize(0), OLSeq(0))
                                                    If OLSize > 0 Then
                                                        tMatch(1) = (OLSize * 2) / (RSize(0) + RSize(1))
                                                    Else
                                                        tMatch(1) = 0
                                                    End If
                                                    otMatch = tMatch(1)
                                                    If tMatch(0) * tMatch(1) > 1 Then
                                                       
                                                            'its in the right region but is it the same event?
                                                            If RCorr(WinPP, 2, RList(WinPP, CSeq(1))) > 0.83 And tMatch(1) > 0.6 Then
                                                                tMatch(0) = 1
                                                            End If
                                                            
                                                            If RCorr(WinPP, 2, RList(WinPP, CSeq(1))) > 0.83 Or RCorr(WinPP, 0, RList(WinPP, CSeq(1))) > 0.83 Then
                                                                OLSize = FindOverlap(Len(StrainSeq(0)), SP(0), EP(1), RSize(2), OLSeqB(0))
                                                                If OLSize > 0 Then
                                                                    tMatch(1) = (OLSize * 2) / (RSize(2) + RSize(3))
                                                                Else
                                                                    tMatch(1) = 0
                                                                End If
                                                                If tMatch(1) > 0.2 Then
                                                                    tMatch(0) = tMatch(0) + 1
                                                                ElseIf RCorr(WinPP, 0, RList(WinPP, CSeq(1))) > 0.83 Then
                                                                    If tMatch(1) = 0 Or OLSize = RSize(2) Then
                                                                        tMatch(0) = tMatch(0) - 0.5
                                                                    End If
                                                                End If
                                                                
                                                            End If
                                                            
                                                            If RCorr(WinPP, 2, RList(WinPP, CSeq(1))) > 0.83 Or RCorr(WinPP, 1, RList(WinPP, CSeq(1))) > 0.83 Then
                                                                OLSize = FindOverlap(Len(StrainSeq(0)), SP(2), EP(3), RSize(4), OLSeqE(0))
                                                                If OLSize > 0 Then
                                                                    tMatch(1) = (OLSize * 2) / (RSize(4) + RSize(5))
                                                                Else
                                                                    tMatch(1) = 0
                                                                End If
                                                                
                                                                If tMatch(1) > 0.2 Then
                                                                    tMatch(0) = tMatch(0) + 1
                                                                ElseIf RCorr(WinPP, 0, RList(WinPP, CSeq(1))) > 0.83 Then
                                                                    If tMatch(1) = 0 Or OLSize = RSize(4) Then
                                                                        tMatch(0) = tMatch(0) - 0.5
                                                                    End If
                                                                End If
                                                                
                                                            End If
                                                            'swap around parents and recombinants later (after the next detection step)
                                                            If tMatch(0) >= 1 Then
                                                                
                                                                FoundOne(CSeq(1)) = 1
                                                                'If RList(0, CSeq(1)) = 20 Then
                                                                '    X = X
                                                                'End If
                                                                If BMatch(WinPP, RList(WinPP, CSeq(1))) < otMatch Then
                                                                    OKSeq(WinPP, 1, RList(WinPP, CSeq(1))) = otMatch
                                                                    BMatch(WinPP, RList(WinPP, CSeq(1))) = otMatch
                                                                    BPMatch(WinPP, 0, RList(WinPP, CSeq(1))) = BPos2
                                                                    BPMatch(WinPP, 1, RList(WinPP, CSeq(1))) = EPos2
                                                                End If
                                                                Y = Y - 1
                                                            End If
                                                        
                                                        
                                                       
                                                    End If
                                                Else
                                                    Y = Y - 1
                                                End If
                                        End If
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                Next x
            End If
            
            For x = 0 To RNum(WinPP)
                If FoundOne(x) = 0 Or InvList(WinPP, x) = 1 Then
                    UNF(WinPP, RList(WinPP, x)) = 1
                End If
            Next x
            
            Dummy = StripUnfound(WinPP, RNum(0), RList(0, 0), InvList(0, 0), FoundOne(0), RCorr(0, 0, 0), RLScore(0, 0))
           
        Next WinPP
        
        
    
        
        
End Sub

Public Sub SignalCount(XoverList() As XOverDefine, CurrentXOver() As Integer)

Dim Dummy As Long, UB As Long, TotE() As Long, PR As Integer, Prob As Double
ReDim TotE(30), oRecombNo(100)
 
UB = UBound(CurrentXOver, 1)

If UB < NextNo Then ReDim Preserve CurrentXOver(NextNo)

'If X = X Then
    '
    Dummy = SignalCountC(NextNo, UBound(XoverList, 1), UBound(XoverList, 2), AddNum, LowestProb, CurrentXOver(0), XoverList(0, 0), oRecombNo(0))
'Else
'    For X = 0 To Nextno
'        For Y = 1 To CurrentXOver(X)
'            If Y <= UBound(XOverlist, 2) Then
'                Pr = XOverlist(X, Y).ProgramFlag
'                Prob = XOverlist(X, Y).Probability
'                If Prob < LowestProb And Prob > 0 Then
'                    oRecombNo(Pr) = oRecombNo(Pr) + 1
'                End If
'            Else
'                CurrentXOver(X) = CurrentXOver(X) - 1
'            End If
'        Next Y
'    Next X
'    For X = 0 To AddNum - 1
'        oRecombNo(100) = oRecombNo(100) + oRecombNo(X)
'    Next X
'End If
End Sub
Public Sub Finalise(BCurrentXOver() As Integer, BestXOList() As XOverDefine)
Dim g As Long, H As Long, Loser As Long, LSeq As Long, FF As Long, oDir As String, Dummy As Long, oDirX As String, XOSize As Long, SO As String, MXOSize As Long, x As Long, Y As Long
XX = TotASET

'29.017 seconds spent iterating through second scan for loop - implies a total af ~45 seconds finding triplets to screen in addsomeexcludes.

'x = x
'
'For x = 0 To Nextno
'    For Y = 1 To BCurrentXOver(x)
'        If BestXOList(x, Y).Daughter <= PermNextno And BestXOList(x, Y).Daughter <> x And BestXOList(x, Y).BeginP >= 0 Then
'            x = x
'            XX = BestXOList(x, Y).BeginP
'            XX = BestXOList(x, Y).Daughter
'            XX = BestXOList(x, Y).MinorP
'            XX = BestXOList(x, Y).MajorP
'            XX = SuperEventList(BestXOList(x, Y).Eventnumber)
'        End If
'    Next Y
'
''event 55, (15,1), d=86, mi=16, ma = 224
'Next x
'XX = Steps(4, 123)

ReDim SMat(0, 0)
ReDim FMat(0, 0)
ReDim SAMat(0, 0)
ReDim FAMat(0, 0)
ReDim SCMat(0, 0)
ReDim FCMat(0, 0)
'XX = StrainSeq(1)
If PermNextno * (Len(StrainSeq(0))) > 10000000 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    'Erase SBlockBak
    'redim permarray(0,0)
    'Dim UBSB1 As Long, UBSB2 As Long, UBPA1 As Long, UBPA2 As Long
    'UBSB1 = UBound(SBlockBak, 1)
    'UBSB2 = UBound(SBlockBak, 2)
    
    
    FF = FreeFile
'    If StrainSeqOnDisk = 1 Then
'        ReDim Preserve StrainSeq(Nextno + 1)
'
'        For x = 1 To Nextno
'            StrainSeq(x) = String(Len(StrainSeq(0)), " ")
'        Next x
'
'
'        '@
'        Open "RDP5Strainseq" + UFTag For Binary As #FF
'        '
'        Get #FF, , StrainSeq()
'        Close #FF
'    End If
    If UBSB1 > -1 Then
        ReDim SBlockBak(UBSB1, UBSB2)
        Open "SBlockBak" + UFTag For Binary As #FF
        Get #FF, , SBlockBak()
        Close #FF
    End If
    'UBPA1 = UBound(PermArray, 1)
    'UBPA2 = UBound(PermArray, 2)
    If UBPA1 > 0 Then
        FF = FreeFile
        ReDim PermArray(UBPA1, UBPA2)
        Open "PermArray" + UFTag For Binary As #FF
        Get #FF, , PermArray()
        Close #FF
    End If
    KillFile "PermArray" + UFTag
    KillFile "SBlockBak" + UFTag
    
    ChDir oDir
    ChDrive oDir

End If


If ProbEstimateInFileFlag = 1 Then
    Erase ProbEstimate
End If
Erase Scores
Erase Winscores
Erase Chivals
Erase SmoothChi
Erase ScoresX
Erase WinScoresX
Erase ChiValsX
Erase SmoothChiX


NextNo = oNextno
AbortFlag = 0
MXOSize = 0
For x = 0 To NextNo
    If MXOSize < BCurrentXOver(x) Then MXOSize = BCurrentXOver(x)
Next x

XOSize = MXOSize + 10
'XX = UBound(XoverList, 1)

If (NextNo * XOSize) > 500000 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    Open "BestXOList" + UFTag For Binary As #FF
    UB1 = UBound(BestXOList, 1)
    UB2 = UBound(BestXOList, 2)
    Put #FF, , BestXOList
    Close #FF
    Erase BestXOList
    ReDim XoverList(UB1, UB2)
    ReDim CurrentXOver(NextNo)
    Open "BestXOList" + UFTag For Binary As #FF
    Put #FF, , BestXOList
    Close #FF
    For x = 0 To NextNo
        CurrentXOver(x) = BCurrentXOver(x)
    Next x
Else

ReDim CurrentXOver(NextNo), XoverList(NextNo, XOSize)



For x = 0 To NextNo
    CurrentXOver(x) = BCurrentXOver(x)
    If UBound(BestXOList, 2) < CurrentXOver(x) Then
        ReDim Preserve BestXOList(UBound(BestXOList, 1), CurrentXOver(x) + 10)
    End If
    For Y = 1 To CurrentXOver(x)
        XoverList(x, Y) = BestXOList(x, Y)
    Next Y
Next x

End If

If ForcePhylE = 1 And ExRecFlag <> 203 Then
    Dim ProgS() As Byte, TotP As Long, MinPV() As Double
    ReDim ProgS(SEventNumber, AddNum * 2), MinPV(SEventNumber)
    
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
'            If SuperEventList(XOverlist(x, Y).Eventnumber) = 74 Then
'                x = x
'            End If
            
            ProgS(SuperEventList(XoverList(x, Y).Eventnumber), XoverList(x, Y).ProgramFlag) = 1
            If (MinPV(SuperEventList(XoverList(x, Y).Eventnumber)) > XoverList(x, Y).Probability And XoverList(x, Y).Probability > 0) Or MinPV(SuperEventList(XoverList(x, Y).Eventnumber)) = 0 Then
                MinPV(SuperEventList(XoverList(x, Y).Eventnumber)) = XoverList(x, Y).Probability
            End If
        Next Y
    Next x
    For x = 0 To NextNo
        For Y = 1 To CurrentXOver(x)
           
          
            If YannWarn(SuperEventList(XoverList(x, Y).Eventnumber)) <> 0 And XoverList(x, Y).Accept <> 1 Then
'                If SuperEventList(XOverlist(x, Y).Eventnumber) = 74 Then
'                    x = x
'                End If
                TotP = 0
                For Z = 0 To AddNum
                    TotP = TotP + ProgS(SuperEventList(XoverList(x, Y).Eventnumber), Z)
                Next Z
                If (TotP < 5 And MinPV(SuperEventList(XoverList(x, Y).Eventnumber)) > 10 ^ -5) Or (TotP < 4 And MinPV(SuperEventList(XoverList(x, Y).Eventnumber)) > 10 ^ -6) Then
                
                    XoverList(x, Y).Accept = 2
                    
                    If XoverList(x, Y).ProgramFlag < AddNum Then
                        XoverList(x, Y).ProgramFlag = XoverList(x, Y).ProgramFlag + AddNum
                    End If
                End If
            End If
        Next Y
        
        For Y = 1 To BCurrentXoverMi(x)
           
            If YannWarn(SuperEventList(BestXOListMi(x, Y).Eventnumber)) <> 0 And BestXOListMi(x, Y).Accept <> 1 Then
                TotP = 0
                For Z = 0 To AddNum
                    TotP = TotP + ProgS(SuperEventList(BestXOListMi(x, Y).Eventnumber), Z)
                Next Z
                If (TotP < 5 And MinPV(SuperEventList(BestXOListMi(x, Y).Eventnumber)) > 10 ^ -5) Or (TotP < 4 And MinPV(SuperEventList(BestXOListMi(x, Y).Eventnumber)) > 10 ^ -6) Then
                    BestXOListMi(x, Y).Accept = 2
                    
                    If BestXOListMi(x, Y).ProgramFlag < AddNum Then
                        BestXOListMi(x, Y).ProgramFlag = BestXOListMi(x, Y).ProgramFlag + AddNum
                    End If
                End If
            End If
        Next Y
        For Y = 1 To BCurrentXoverMa(x)
           
            If YannWarn(SuperEventList(BestXOListMa(x, Y).Eventnumber)) <> 0 And BestXOListMa(x, Y).Accept <> 1 Then
                TotP = 0
                For Z = 0 To AddNum
                    TotP = TotP + ProgS(SuperEventList(BestXOListMa(x, Y).Eventnumber), Z)
                Next Z
                If (TotP < 5 And MinPV(SuperEventList(BestXOListMa(x, Y).Eventnumber)) > 10 ^ -5) Or (TotP < 4 And MinPV(SuperEventList(BestXOListMa(x, Y).Eventnumber)) > 10 ^ -6) Then
                    BestXOListMa(x, Y).Accept = 2
                    If BestXOListMa(x, Y).ProgramFlag < AddNum Then
                        BestXOListMa(x, Y).ProgramFlag = BestXOListMa(x, Y).ProgramFlag + AddNum
                    End If
                End If
            End If
        Next Y
        
    Next x
    
        
    
End If




Call SignalCount(XoverList(), CurrentXOver())
Call UpdateRecNums(SEventNumber)


For x = 0 To NextNo
    OriginalName(x) = PermOriginalName(x)
Next x

If PermSeqNumInFile = 1 Then
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    ReDim SeqNum(Len(StrainSeq(0)), PermNextno)
    Open "RDP5PSNFile" + UFTag For Binary As #FF
    Get #FF, , SeqNum
    Close #FF
    ChDrive oDirX
    ChDir oDirX
    If DebuggingFlag < 3 Then On Error Resume Next
    ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo + 1)
    On Error GoTo 0
Else
    If DebuggingFlag < 2 Then On Error Resume Next
    ReDim SeqNum(Len(StrainSeq(0)), NextNo + 1)
    On Error GoTo 0
    Dummy = CopySeqs(Len(StrainSeq(0)), UBound(PermSeqNum, 2), PermSeqNum(0, 0), SeqNum(0, 0))
End If
    




If UBound(SeqCol) < NextNo Then
    ReDim Preserve SeqCol(NextNo), FFillCol(NextNo)

End If

If UBound(XCord, 3) < NextNo + 2 Then
    ReDim Preserve XCord(4, 3, NextNo + 2), YCord(4, 3, NextNo + 2), RYCord(4, 3, NextNo + 2)
End If

If UBound(OriginalName, 1) <= NextNo Then
ReDim Preserve OriginalName(NextNo)
End If

Udst = PermUDst
AvDst = PermAvDst


ReDim Distance(PermNextno, PermNextno)
ReDim TreeDistance(PermNextno, PermNextno)
oDir = CurDir
ChDir App.Path
ChDrive App.Path
FF = FreeFile
Open "RDP5PermDistance" + UFTag For Binary As #FF
Get #FF, , Distance()
Close #FF

Open "RDP5PermTreeDistance" + UFTag For Binary As #FF
Get #FF, , TreeDistance()
Close #FF

ReDim PermValid(PermNextno, PermNextno)
ReDim PermDIffs(PermNextno, PermNextno)

Open "RDP5PPermValid" + UFTag For Binary As #FF
Get #FF, , PermValid()
Close #FF

Open "RDP5PPermDiffs" + UFTag For Binary As #FF
Get #FF, , PermDIffs()
Close #FF


ChDir oDir
ChDrive oDir

LSeq = Len(StrainSeq(0))

TreeDistFlag = 1
NJFlag = 1
'GCIndelFlag = oGCIndelFlag
Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 0)
Call DrawTree
If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
    TreeXUB = UBound(TreeX, 1)
    TreeXInFileFlag = 1
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    FF = FreeFile
    Open "RDP5TreeX" + UFTag For Binary As #FF
    Put #FF, , TreeX()
    Close #FF
    ChDir oDir
    ChDrive oDir
    Erase TreeX
End If
        

Call SetUpEvents


'XX = XoverList(BestEvent(181, 0), BestEvent(181, 1)).Daughter



Dim L1 As Long, L2 As Long, i As Long, BE0 As Long, BE1 As Long, BE2 As Long, BE3 As Long, EVPos() As Long, DoneE() As Long, BP As Long, EP As Long, RL As Long, R0 As Long
Dim DV0 As Long, DV1 As Long, DV2 As Long, DV3 As Long, D1 As Long, D2 As Long, OLDaught As Long, OL1 As Long, OL2 As Long, CC As Long, DD As Long
If ExcludedEventNum > 0 Then
    ReDim DoneE(SEventNumber)
    For i = 0 To 2 ' Need to do three passes to pick up the stragglers.
        For x = 0 To SEventNumber
'            If x = 110 Or x = 530 Or x = 719 Or x = 858 Then '858,719,110,530 2178-3000
'                x = x
'            End If
'            If x = 433 Or x = 781 Then
'                x = x
'            End If
            If DoneE(x) = 0 Then
                BE0 = BestEvent(x, 0)
                BE1 = BestEvent(x, 1)
'                If XoverList(BE0, BE1).BeginP < 0 Then
'                    Call SplitP(-XoverList(BE0, BE1).BeginP, DV0, DV1)
'
'                    If XoverList(BE0, BE1).EndP < 0 Then
'                        Call SplitP(-XoverList(BE0, BE1).BeginP, DV0, DV1)
'                    End If
'                Else
'                    D1 = XoverList(BE0, BE1).Daughter
'                End If
                
                'Call SplitP(-XoverList(BE0, BE1).BeginP, DV0, DV1)
                If XoverList(BE0, BE1).BeginP < 0 And (XoverList(BE0, BE1).Daughter = BE0 Or Daught(x, BE0) > 0) Then
                
                    
                'this event will probably have been detected multiple times in different addsomeextras cycles'need to find the one with the bestp-value and "delete" all the rest
                    BP = XoverList(BE0, BE1).Beginning
                    EP = XoverList(BE0, BE1).Ending
    '                If Daught(x, 21) > 0 Then
    '                    x = x
    '                End If
                    ReDim EVPos(Len(StrainSeq(0)))
                    RL = 0
                    If BP < EP Then
                        L1 = EP - BP + 1
                        For Y = BP To EP
                            EVPos(Y) = 1
                            RL = RL + 1
                        Next Y
                    Else
                        L1 = Len(StrainSeq(0)) - BP + 1 + EP
                        For Y = BP To Len(StrainSeq(0))
                            EVPos(Y) = 1
                            RL = RL + 1
                        Next Y
                        For Y = 1 To EP
                            EVPos(Y) = 1
                            RL = RL + 1
                        Next Y
                    End If
                    For Y = x + 1 To SEventNumber
'                        If Y = 110 Or Y = 530 Or Y = 719 Or Y = 858 Or Y = 781 Then '858,719,110,530 2178-3000
'                            x = x
'                        End If
                        BE2 = BestEvent(Y, 0)
                        BE3 = BestEvent(Y, 1)
                        If DoneE(Y) = 0 Then
'                        OLDaught = 0: OL1 = 0: OL2 = 0
'                        For CC = 0 To PermNextno
'                            If Daught(x, CC) > 0 And Daught(Y, CC) > 0 Then
'                                OLDaught = OLDaught + 1
'                            ElseIf Daught(x, CC) > 0 Then
'                                OL1 = OL1 + 1
'                             ElseIf Daught(Y, CC) > 0 Then
'                                OL2 = OL2 + 1
'                            End If
'                        Next CC
                        'Dim G As Long
                        'or (oldaught/(oldaught+ol1+ol2)>0.5) or (ol1=0 and oldaught>0) or (ol2=0 and oldaught>0))
                            If XoverList(BE2, BE3).BeginP < 0 And ((Daught(x, BE2) > 0 Or Daught(Y, BE0) > 0)) And XoverList(BE2, BE3).Daughter = BE2 Then
                                BP = XoverList(BE2, BE3).Beginning
                                EP = XoverList(BE2, BE3).Ending
                                RO = 0
                                
        '                        If Daught(Y, 21) > 0 Then
        '                            x = x
        '                            XX = DoneE(181)
        '                            XX = DoneE(185)
        '                            XX = DoneE(206)
        '                        End If
                                If BP < EP Then
                                    L2 = EP - BP + 1
                                    For Z = BP To EP
                                        RO = RO + EVPos(Z)
                                        
                                    Next Z
                                Else
                                    L2 = Len(StrainSeq(0)) - BP + 1 + EP
                                    For Z = BP To Len(StrainSeq(0))
                                        RO = RO + EVPos(Z)
                                    Next Z
                                    For Z = 1 To EP
                                        RO = RO + EVPos(Z)
                                    Next Z
                                End If
                                If RO > 0 Then
                                    XX = (RO / RL)
                                    If (((L1 - RO) + (L2 - RO)) / RO) < 0.6 And ((L2 - RO) / RO) < 0.4 And ((L1 - RO) / RO) < 0.4 Then 'overlap region between compared frags must be av >70% of the two frag lens                                If (RO / RL) > 0.4 Then
                                            If XoverList(BE0, BE1).Probability < XoverList(BE2, BE3).Probability Then
                                                BestEvent(Y, 0) = 0: BestEvent(Y, 1) = 0
                                                
                '                                If Y = 181 Or Y = 185 Or Y = 206 Then
                '                                    x = x
                '                                End If
                                                
                                                DoneE(Y) = 1
                                                Winner = x
                                                Loser = Y
                                            Else
                                                BestEvent(x, 0) = 0: BestEvent(x, 1) = 0
                                                DoneE(x) = 1
                                                Winner = Y
                                                Loser = x
                                            End If
                                            
                                            For g = 0 To NextNo
                                                For H = 1 To CurrentXOver(g)
                                                    If SuperEventList(XoverList(g, H).Eventnumber) = Loser Then
                                                        
                                                        
                                                        'The result cannot simply be transferred to the winner because that would create lots of excludedlist and steps conflicts
                                                        'It needs to be erased from xoverlist, and the mi and ma versions of xoverlist
                                                        If H < CurrentXOver(g) Then
                                                            XoverList(g, H) = XoverList(g, CurrentXOver(g))
                                                        End If
                                                        CurrentXOver(g) = CurrentXOver(g) - 1
                                                        
                                                        'SuperEventList(XoverList(g, H).Eventnumber) = Winner
                                                        'If XoverList(g, H).Daughter <= PermNextno Then
                                                        '    If Daught(Winner, XoverList(g, H).Daughter) = 0 Or Daught(Winner, XoverList(g, H).Daughter) > Daught(Loser, XoverList(g, H).Daughter) Then
                                                        '        Daught(Winner, XoverList(g, H).Daughter) = Daught(Loser, XoverList(g, H).Daughter)
                                                        '    End If
                                                        'End If
                                                    End If
                                                Next H
                                                For H = 1 To BCurrentXoverMa(g)
                                                    If SuperEventList(BestXOListMa(g, H).Eventnumber) = Loser Then
                                                        If H < BCurrentXoverMa(g) Then
                                                            BestXOListMa(g, H) = BestXOListMa(g, BCurrentXoverMa(g))
                                                        End If
                                                        BCurrentXoverMa(g) = BCurrentXoverMa(g) - 1
                                                    End If
                                                Next H
                                                For H = 1 To BCurrentXoverMi(g)
                                                    If SuperEventList(BestXOListMi(g, H).Eventnumber) = Loser Then
                                                        If H < BCurrentXoverMi(g) Then
                                                            BestXOListMi(g, H) = BestXOListMi(g, BCurrentXoverMi(g))
                                                        End If
                                                        BCurrentXoverMi(g) = BCurrentXoverMi(g) - 1
                                                    End If
                                                Next H
                                            Next g
                                            If Loser = x Then Exit For
                                        End If
'                                    Else
'                                        x = x
                                    End If
                            End If
                        End If
                    Next Y
                    
                    
                Else
                    x = x
                End If
            End If
        Next x
        ZZ = 0
        Dim AE As Long
        AE = 0
        For x = 1 To SEventNumber
            If DoneE(x) = 1 Then
                ZZ = ZZ + 1
                For Y = 0 To NextNo
                    For Z = 1 To CurrentXOver(Y)
                        If x = SuperEventList(XoverList(Y, Z).Eventnumber) Then
                            XoverList(Y, Z).Daughter = 0
                            XoverList(Y, Z).MajorP = 0
                            XoverList(Y, Z).MinorP = 0
                            XoverList(Y, Z).Beginning = 0
                            XoverList(Y, Z).Ending = 0
                            XoverList(Y, Z).Eventnumber = 0
                        End If
                    Next Z
                Next Y
                For Y = 0 To NextNo
                    For Z = 1 To BCurrentXoverMi(Y)
                        If x = SuperEventList(BestXOListMi(Y, Z).Eventnumber) Then
                            BestXOListMi(Y, Z).Daughter = 0
                            BestXOListMi(Y, Z).MajorP = 0
                            BestXOListMi(Y, Z).MinorP = 0
                            BestXOListMi(Y, Z).Beginning = 0
                            BestXOListMi(Y, Z).Ending = 0
                            BestXOListMi(Y, Z).Eventnumber = 0
                        End If
                    Next Z
                Next Y
                For Y = 0 To NextNo
                    For Z = 1 To BCurrentXoverMa(Y)
                        If x = SuperEventList(BestXOListMa(Y, Z).Eventnumber) Then
                            BestXOListMa(Y, Z).Daughter = 0
                            BestXOListMa(Y, Z).MajorP = 0
                            BestXOListMa(Y, Z).MinorP = 0
                            BestXOListMa(Y, Z).Beginning = 0
                            BestXOListMa(Y, Z).Ending = 0
                            BestXOListMa(Y, Z).Eventnumber = 0
                        End If
                    Next Z
                Next Y
            
            
            Else
    '            AE = AE + 1
    '            If AE <> x Then
    '                For Y = 0 To UBound(SuperEventList)
    '                    If SuperEventList(Y) = x Then
    '                        SuperEventList(Y) = AE
    '                    End If
    '                Next Y
    '            End If
            End If
        Next x
        
        
        XX = SEventNumber - ZZ
        x = x
    Next i
    'Call SetUpEvents
End If
'SEventNumber = AE

Dim LenR As Long, TLen As Long, Tpar As Long
TLen = Len(StrainSeq(0))
For x = 0 To PermNextno
    For Y = 1 To CurrentXOver(x)
        BE = XoverList(x, Y).Beginning
        EN = XoverList(x, Y).Ending
        If BE < EN Then
            LenR = EN - BE
        Else
            LenR = TLen - BE + EN
        End If
        If LenR / TLen > 0.7 Then
            If EN < TLen Then
                XoverList(x, Y).Beginning = EN + 1
            Else
                XoverList(x, Y).Beginning = 1
            End If
            If BE > 1 Then
                XoverList(x, Y).Ending = BE - 1
            Else
                XoverList(x, Y).Ending = TLen
            End If
            Tpar = XoverList(x, Y).MajorP
            XoverList(x, Y).MajorP = XoverList(x, Y).MinorP
            XoverList(x, Y).MinorP = Tpar
        
        End If
        
        
    Next Y
    
    For Y = 1 To BCurrentXoverMi(x)
        BE = BestXOListMi(x, Y).Beginning
        EN = BestXOListMi(x, Y).Ending
        If BE < EN Then
            LenR = EN - BE
        Else
            LenR = TLen - BE + EN
        End If
        If LenR / TLen > 0.7 Then
            If EN < TLen Then
                BestXOListMi(x, Y).Beginning = EN + 1
            Else
                BestXOListMi(x, Y).Beginning = 1
            End If
            If BE > 1 Then
                BestXOListMi(x, Y).Ending = BE - 1
            Else
                BestXOListMi(x, Y).Ending = TLen
            End If
            Tpar = BestXOListMi(x, Y).MajorP
            BestXOListMi(x, Y).MajorP = BestXOListMi(x, Y).MinorP
            BestXOListMi(x, Y).MinorP = Tpar
        
        End If
        
        
    Next Y
    
    For Y = 1 To BCurrentXoverMa(x)
        BE = BestXOListMa(x, Y).Beginning
        EN = BestXOListMa(x, Y).Ending
        If BE < EN Then
            LenR = EN - BE
        Else
            LenR = TLen - BE + EN
        End If
        If LenR / TLen > 0.7 Then
            If EN < TLen Then
                BestXOListMa(x, Y).Beginning = EN + 1
            Else
                BestXOListMa(x, Y).Beginning = 1
            End If
            If BE > 1 Then
                BestXOListMa(x, Y).Ending = BE - 1
            Else
                BestXOListMa(x, Y).Ending = TLen
            End If
            Tpar = BestXOListMa(x, Y).MajorP
            BestXOListMa(x, Y).MajorP = BestXOListMa(x, Y).MinorP
            BestXOListMa(x, Y).MinorP = Tpar
        
        End If
        
        
    Next Y
    
Next x


If (PermNextno > MemPoc And x = 1234567 And SEventNumber > 300) Or XOMiMaInFileFlag = 1 Then
            'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
    XOMiMaInFileFlag = 1
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    UBXOMi = UBound(BestXOListMi, 2)
    UBXoMa = UBound(BestXOListMa, 2)
    Open "RDP5BestXOListMi" + UFTag For Binary As #FF
    Put #FF, , BestXOListMi()
    Close #FF
    Open "RDP5BestXOListMa" + UFTag For Binary As #FF
    Put #FF, , BestXOListMa()
    Close #FF
    MaRec = O
    MiRec = 0
    ChDrive oDirX
    ChDir oDirX
    Erase BestXOListMi
    Erase BestXOListMa
End If
    
If ExcludedEventNum > 0 Then
            
    Call MakeELLite(ELLite(), EventsInExcludeds(), Daught())
    
End If


If ExRecFlag = 210 Then
    Dim SMap() As Long
    Dim BestMatchScore() As Single
    ReDim BestMatchScore(1, SEventNumber)
    ReDim SMap(Len(StrainSeq(0)), NextNo)
    For x = NumActualEvents To 0 Step -1
        If ActualEventList(3, x) <> 0 Or ActualEventList(4, x) <> 0 Then
            If ActualEventList(1, x) < ActualEventList(2, x) Then
                For Z = ActualEventList(1, x) + 1 To ActualEventList(2, x)
                    SMap(Z, ActualEventList(3, x) - 1) = ActualEventList(0, x)
                Next Z
            Else '
                For Z = ActualEventList(1, x) + 1 To Len(StrainSeq(0))
                    SMap(Z, ActualEventList(3, x) - 1) = ActualEventList(0, x)
                Next Z
                
                For Z = 1 To ActualEventList(2, x)
                    SMap(Z, ActualEventList(3, x) - 1) = ActualEventList(0, x)
                Next Z
            End If
        End If
    Next x
    Dim RMap() As Long
    For x = 1 To SEventNumber 'match detected events with events in actualeventlist
        Dim A As Long, b As Long, C As Long, D As Long, e As Long, F As Long
        Dim Tot As Long, TotH As Long
        
        
        ReDim RMap(Len(StrainSeq(0)))
        D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
        e = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
        F = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
        g = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
        H = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
        If g < H Then
            For Y = g To H
                RMap(Y) = 1
            Next Y
        Else
            For Y = g To Len(StrainSeq(0))
                RMap(Y) = 1
            Next Y
            For Y = 1 To H
                RMap(Y) = 1
            Next Y
        End If
        Dim MM As Single, MMI As Single, CM As Single, WinMM As Long, WinMMI As Long, TotHI As Long
        MM = 0: MMI = 0
        WinMM = -1
        For Y = 0 To NumActualEvents
            If D = ActualEventList(3, Y) - 1 Or e = ActualEventList(3, Y) - 1 Or F = ActualEventList(3, Y) - 1 Then
                C = ActualEventList(0, Y)
                A = ActualEventList(1, Y)
                b = ActualEventList(2, Y)
                
                TotH = 0
                TotHI = 0
                Tot = 0
                toti1 = 0
                tot0 = 0
                toti0 = 0
                For Z = 1 To Len(StrainSeq(0))
                    
                    If C = SMap(Z, D) Or C = SMap(Z, e) Or C = SMap(Z, F) Then
                        
                        'TotH = TotH + RMap(Z)
                        If RMap(Z) = 0 Then
                            TotHI = TotHI + 1
                            tot0 = tot0 + 1
                        Else
                            TotH = TotH + 1
                            Tot = Tot + 1
                        End If
                    ElseIf RMap(Z) = 1 Then
                        TotHI = TotHI + 1
                        toti1 = toti1 + 1
                    Else
                        TotH = TotH + 1
                        toti0 = toti0 + 1
                    End If
                Next Z
                     
                If Tot > toti1 Then
'                    CM = TotH / Len(StrainSeq(0))
                    CM = Tot / (tot0 + Tot) - toti1 / (toti1 + toti0)
                    If CM > MM Then
                        MM = CM
                        WinMM = Y
                    End If
                Else
'                    CM = TotHI / Len(StrainSeq(0))
                    CM = toti1 / (toti1 + toti0) - Tot / (tot0 + Tot)
                    If CM > MM Then
                        MM = CM
                        WinMM = Y
                    End If
                End If
                
            End If
        Next Y
        BestMatchScore(1, x) = MM
        BestMatchScore(0, x) = WinMM
        XX = CurDir
        x = x
    Next x
    Open InFileX + "SimVSRealCompare.csv" For Output As #1
    Print #1, "RDPEvent,ActualRecomb,PredictRecomb,MatchNo,Matchscore,SimEVentNo,SimBPStart,SimBPEnd, PredBPStart, PredBPEnd"
    For x = 1 To SEventNumber
        If BestMatchScore(1, x) > 0.8 Then
            ZZ = BestMatchScore(0, x)
            D = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Daughter
            e = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MajorP
            F = XoverList(BestEvent(x, 0), BestEvent(x, 1)).MinorP
            g = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Beginning
            H = XoverList(BestEvent(x, 0), BestEvent(x, 1)).Ending
            Print #1, Str(x) + "," + Str(ActualEventList(3, ZZ)) + "," + Str(D + 1) + "," + Str(BestMatchScore(0, x)) + "," + Str(BestMatchScore(1, x)) + "," + Str(ActualEventList(0, ZZ)) + "," + Str(ActualEventList(1, ZZ)) + "," + Str(ActualEventList(2, ZZ)) + "," + Str(g) + "," + Str(H)
        
        Else
            For Y = 0 To SDNum
                If StatsDump(0, 50, Y) = x Then '5,13,15,17,20,21,27,28,29
                    StatsDump(0, 49, Y) = 0
                    StatsDump(1, 49, Y) = 0
                    StatsDump(2, 49, Y) = 0
                End If
            Next Y
        End If
    Next x
    
    Close #1
   ' Call DumpStatsToFile(InFileX & "RecombIdentifyStats.csv")
    x = x
End If

oRecombNo(100) = 0
UpdateRecNums (SEventNumber)
ET = Abs(GetTickCount)
Form1.Label50(12).Caption = DoTimeII(Abs(ET - ST))
oRecombNo(100) = SEventNumber
End Sub

Public Sub Rewind(TestC() As Long, BCurrentXOver() As Integer, BestXOList() As XOverDefine)
Dim x As Long, Y As Long
Call Finalise(BCurrentXOver(), BestXOList())
For x = 0 To NextNo
    For Y = 1 To CurrentXOver(x)
        If TestC(SuperEventList(XoverList(x, Y).Eventnumber)) <> 1 Or SuperEventList(XoverList(x, Y).Eventnumber) = SEventNumber Then
            If XoverList(x, Y).Accept <> 1 Then
                XoverList(x, Y).Accept = 3
            End If
        End If
    Next Y
Next x
For x = 0 To NextNo
    For Y = 1 To BCurrentXoverMi(x)
        If TestC(SuperEventList(BestXOListMi(x, Y).Eventnumber)) <> 1 Or SuperEventList(BestXOListMi(x, Y).Eventnumber) = SEventNumber Then
            If BestXOListMi(x, Y).Accept <> 1 Then
                BestXOListMi(x, Y).Accept = 3
            End If
        End If
    Next Y
Next x
For x = 0 To NextNo
    For Y = 1 To BCurrentXoverMa(x)
        If TestC(SuperEventList(BestXOListMa(x, Y).Eventnumber)) <> 1 Or SuperEventList(BestXOListMa(x, Y).Eventnumber) = SEventNumber Then
            If BestXOListMa(x, Y).Accept <> 1 Then
                BestXOListMa(x, Y).Accept = 3
            End If
        End If
    Next Y
Next x
End Sub
Public Sub RemoveAccepts(BCurrentXOver() As Integer, BestXOList() As XOverDefine)
Dim x As Long, Y As Long
For x = 0 To PermNextno
    For Y = 1 To BCurrentXOver(x)
        If BestXOList(x, Y).Accept = 3 Then
            If BestXOList(x, Y).ProgramFlag < AddNum Then
                BestXOList(x, Y).Accept = 0
            Else
                BestXOList(x, Y).Accept = 2
            End If
        End If
    Next Y
Next x
For x = 0 To PermNextno
    For Y = 1 To BCurrentXoverMi(x)
        If BestXOListMi(x, Y).Accept = 3 Then
            If BestXOListMi(x, Y).ProgramFlag < AddNum Then
                BestXOListMi(x, Y).Accept = 0
            Else
                BestXOListMi(x, Y).Accept = 2
            End If
        End If
    Next Y
Next x
For x = 0 To PermNextno
    For Y = 1 To BCurrentXoverMa(x)
        If BestXOListMa(x, Y).ProgramFlag < AddNum Then
                BestXOListMa(x, Y).Accept = 0
            Else
                BestXOListMa(x, Y).Accept = 2
            End If
    Next Y
Next x
End Sub

Public Sub TestConflict(TestC() As Long, WinPP, CurAge As Double, Fail, BPos, Epos, TraceSub() As Long, AgeEvent() As Double, AgeScore() As Single, EventScore() As Long, ISeqs() As Long, BestXOList() As XOverDefine, BCurrentXOver() As Integer)
Dim GoOn As Long, MinR As Single, EPos2 As Long, BPos2 As Long, x As Long, Y As Long, Z As Long, ProbPar As Long, EarliestEvent As Long
Dim A As Long, b As Long
'curage = ageevent(1)
Fail = 0
EarliestEvent = SEventNumber

ReDim TestC(SEventNumber)
Dim TestB()
ReDim TestB(SEventNumber)
For x = 0 To PermNextno
    For Y = 1 To BCurrentXOver(x)
'        XX = SuperEventList(BestXOList(X, Y).Eventnumber)
        
        If BestXOList(x, Y).DHolder < 0 Then
            ''If XX = 7 Then
            '    X = X
            'End If
            'If EarliestEvent > SuperEventList(BestXOList(X, Y).Eventnumber) Then
                EarliestEvent = SuperEventList(BestXOList(x, Y).Eventnumber)
                If BestXOList(x, Y).MinorP = ISeqs(WinPP) Or BestXOList(x, Y).MajorP = ISeqs(WinPP) Then
                    If BestXOList(x, Y).MinorP = ISeqs(WinPP) Then
                        ProbPar = BestXOList(x, Y).MinorP
                    Else
                        ProbPar = BestXOList(x, Y).MajorP
                    End If
                    BPos2 = BestXOList(x, Y).Beginning
                    EPos2 = BestXOList(x, Y).Ending
                    If BPos2 < EPos2 Then
                        For Z = BPos2 To EPos2
                            If AgeScore(Z, ProbPar) > -1 Then
                                ' AgeEvent(1, SEventNumber)
                                If AgeScore(Z, ProbPar) <= CurAge Then
                                    TestC(EarliestEvent) = TestC(EarliestEvent) + 1
                                Else
                                    TestB(EarliestEvent) = TestB(EarliestEvent) + 1
                                End If
                            End If
                        Next Z
                    Else
                        For Z = 1 To EPos2
                            If AgeScore(Z, ProbPar) > -1 Then
                                If AgeScore(Z, ProbPar) <= CurAge Then
                                     TestC(EarliestEvent) = TestC(EarliestEvent) + 1
                                Else
                                    TestB(EarliestEvent) = TestB(EarliestEvent) + 1
                                End If
                            End If
                        Next Z
                        For Z = BPos2 To Len(StrainSeq(0))
                            If AgeScore(Z, ProbPar) > -1 Then
                                If AgeScore(Z, ProbPar) < CurAge Then
                                     TestC(EarliestEvent) = TestC(EarliestEvent) + 1
                                Else
                                    TestB(EarliestEvent) = TestB(EarliestEvent) + 1
                                End If
                            End If
                        Next Z
                    End If
                End If
            'End If
        End If
    Next Y
Next x


'For X = 0 To PermNextNo
'    For Y = 1 To BCurrentXOver(X)
'        If BestXOList(X, Y).DHolder < 0 Then
'            If SuperEventList(BestXOList(X, Y).Eventnumber) = 7 Then
'                XX = BestXOList(X, Y).Beginning '58-1065
'                XX = BestXOList(X, Y).Ending
'                XX = BPos
'                XX = EPos
'            End If
'        End If
'    Next Y
'Next X

'maybe handle events that overlap the edges of recombinant regions separately
'44-1512,2066-2182,1204-1262,1263-1281,1498-1512,1377-1985
If BPos < Epos Then
    MinR = (Epos - BPos) / 2
Else
    MinR = (Len(StrainSeq(0)) - BPos + Epos) / 2
End If
MinR = 0 'any overlap of a newer event is not allowed
EarliestEvent = SEventNumber + 1
GoOn = 0
For x = 1 To SEventNumber
    If TestC(x) > 0 Then
        If TestC(x) > MinR Or (TestC(x) / (TestB(x) + TestC(x))) > 0.5 Then
            TestC(x) = 1
            GoOn = 1
            If x < EarliestEvent Then
                EarliestEvent = x
            End If
        Else
            TestC(x) = 0
        End If
    End If

Next x

If GoOn = 0 Then Exit Sub
'For X = EarliestEvent To SEventNumber - 1
'    TestC(X) = 1
'Next X

Dim ExtremeTrim As Byte, DE() As Long, CP As Long, BPos3 As Long, EPos3 As Long, FragReg() As Byte, CTE As Long
ReDim DE(SEventNumber)
DE(SEventNumber) = 1
Dim EE As Long
EE = EarliestEvent
ExtremeTrim = 1 'remove all later events with reference to any sequence in which an event has been removed.
Dim YH As Long



For x = 0 To PermNextno
    For Y = 1 To BCurrentXOver(x)
        
        If BestXOList(x, Y).DHolder < 0 Then
            CTE = SuperEventList(BestXOList(x, Y).Eventnumber)
            If CTE >= EE Then '5
                If DE(CTE) = 0 Then
                    If TestC(CTE) = 1 Then
                        YH = BCurrentXOver(x)
                        'DE(CTE) = 1
                        CP = BestXOList(x, Y).Daughter
                        
                        If ExtremeTrim = 0 Then
                            BPos3 = BestXOList(x, Y).Beginning
                            EPos3 = BestXOList(x, Y).Ending
                            ReDim FragReg(Len(StrainSeq(0)))
                            If BPos3 < EPos3 Then
                                For Z = BPos3 To EPos3
                                    FragReg(Z) = 1
                                Next Z
                            Else
                                For Z = 1 To EPos3
                                    FragReg(Z) = 1
                                Next Z
                                For Z = BPos3 To Len(StrainSeq(0))
                                    FragReg(Z) = 1
                                Next Z
                            End If
                        End If
                        CurAge = AgeEvent(1, CTE)
                        For A = 0 To PermNextno
                            For b = 1 To BCurrentXOver(A)
                                If DE(SuperEventList(BestXOList(A, b).Eventnumber)) = 0 Then
                                    'If BestXOList(A, B).DHolder < 0 Then
                                        If SuperEventList(BestXOList(A, b).Eventnumber) > CTE Then
                                            If TestC(SuperEventList(BestXOList(A, b).Eventnumber)) = 0 Then
                                                
                                                If (ExtremeTrim = 1 And BestXOList(A, b).Daughter = CP) Or BestXOList(A, b).MinorP = CP Or BestXOList(A, b).MajorP = CP Then
                                                    If ExtremeTrim = 1 Then
                                                        'ie remove this event if a an earlier triplet involved sequence x,y
                                                        TestC(SuperEventList(BestXOList(A, b).Eventnumber)) = 1
                                                        Y = YH
                                                        x = -1
                                                    Else
                                                        If BestXOList(A, b).MinorP = CP Then
                                                            ProbPar = BestXOList(A, b).MinorP
                                                        Else
                                                            ProbPar = BestXOList(A, b).MajorP
                                                        End If
                                                        
                                                        BPos2 = BestXOList(A, b).Beginning
                                                        EPos2 = BestXOList(A, b).Ending
                                                        If BPos2 < EPos2 Then
                                                            For Z = BPos2 To EPos2
                                                                If FragReg(Z) > 0 Then
                                                                    If AgeEvent(1, SuperEventList(BestXOList(A, b).Eventnumber)) < CurAge Then
                                                                        TestC(SuperEventList(BestXOList(A, b).Eventnumber)) = 1
                                                                        'A = PermNextNo
                                                                        'B = BCurrentXOver(PermNextNo)
                                                                        Y = YH
                                                                        x = -1
                                                                    
                                                                        Exit For
                                                                    End If
                                                                End If
                                                            Next Z
                                                        Else
                                                            For Z = 1 To EPos2
                                                                If FragReg(Z) > 0 Then
                                                                    If AgeEvent(1, SuperEventList(BestXOList(A, b).Eventnumber)) < CurAge Then
                                                                        TestC(SuperEventList(BestXOList(A, b).Eventnumber)) = 1
                                                                        'A = PermNextNo
                                                                        'B = BCurrentXOver(PermNextNo)
                                                                        Y = YH
                                                                        x = -1
                                                                    
                                                                        Exit For
                                                                    End If
                                                                End If
                                                            Next Z
                                                            If Z = Epos + 1 Then
                                                                For Z = BPos2 To Len(StrainSeq(0))
                                                                    If FragReg(Z) > 0 Then
                                                                        If AgeEvent(1, SuperEventList(BestXOList(A, b).Eventnumber)) < CurAge Then
                                                                            TestC(SuperEventList(BestXOList(A, b).Eventnumber)) = 1
                                                                            'A = PermNextNo
                                                                            'B = BCurrentXOver(PermNextNo)
                                                                            Y = YH
                                                                            x = -1
                                                                        
                                                                            Exit For
                                                                        End If
                                                                    End If
                                                                Next Z
                                                            End If
                                                        End If
                                                    End If
                                                End If
                                            End If
                                        End If
                                    'End If
                                End If
                            Next b
                        Next A
                    End If
                End If
            End If
        End If
    Next Y
Next x
If EarliestEvent <= SEventNumber Then
    Fail = EarliestEvent
End If
End Sub
Public Sub WriteTextNum(TP As PictureBox, S1 As String, s2)
Dim NumX As String, PowX As String, ExtraX As String, OS As String, OY As Long, OF As Double, NY As Long
Call NumToString(s2, 3, NumX, PowX, ExtraX)
OS = S1 + NumX + ExtraX

OY = TP.CurrentY
TP.CurrentX = 5
TP.Print OS
NY = TP.CurrentY
TP.CurrentY = OY
TP.CurrentX = 5 + TP.TextWidth(OS)
OF = TP.FontSize
TP.FontSize = 5
TP.Print PowX
TP.FontSize = OF
TP.CurrentY = NY
End Sub




Public Sub DoRDP(SPX As Byte, CPermNo As Long)

Dim GoodCall203 As Long, ELT As Long, x As Long, SSSS As Long, TotT As Long, LT As Long, oGCIndelFlag As Long, Dummy As Long, LSeq As Long, WinNum As Long, TXOS As Long
Dim PBV As Single, C As Long, TT As Long, GoOn As Long, oSeq1 As Long, oSeq2 As Long, oSeq3 As Long, tSeq1 As Long, tSeq2 As Long, tSeq3 As Long
Dim Fail As Long, Response As Long, Z As Long, ZZ As Long, CPVal As Double, A As Long, FF As Long, UB1 As Long, UB2 As Long, UB3 As Long
Dim SS As Long, oAbortFlag As Long, ReduceX As Double, b As Long, MXOSize As Long, PermResponse As Long, TLen As Long
Dim oDir As String, RankF(2, 1) As Long
GlobalTimer = Abs(GetTickCount)

'Free up as much memory as possible
ReDim SMat(0, 0)
ReDim FMat(0, 0)
ReDim SAMat(0, 0)
ReDim FAMat(0, 0)
ReDim SCMat(0, 0)
ReDim FCMat(0, 0)
ReDim FubValid(0, 0)
ReDim SubValid(0, 0)
ReDim SubDiffs(0, 0)


If ColDistInFile = 1 Then
    ReDim ColDist2(0)
End If

On Error Resume Next
UB1 = -1
UB1 = UBound(Analysislist, 2)
On Error GoTo 0

If MaxAnalNo < MCCorrection Then
    If TripListLen = 0 Then
        If UB1 = UBound(Worthwhilescan, 1) Then
            TripListLen = UBound(Worthwhilescan, 1)
        Else
            Call MakeAnalysisList
        End If
    End If
    UseALFlag = 1
ElseIf QvRFlag = 1 Then
    If TripListLen = 0 Then
        Call MakeAnalysisListQvR
    End If
    UseALFlag = 1
End If

'do phitest
Dim PV As Double


ModSeqNumFlag = 1

Form1.SSPanel1.Caption = "Doing PHITest"
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
PV = PHITest(MatrixTB(), SeqNum(), NextNo, Len(StrainSeq(0)), 0, PHIWin, 0)
If PV > 0.05 And PV < 1 Then
    PHIWarn = 1
Else
    PHIWarn = 0
End If
If PermNextno > MemPoc Then Erase MatrixTB

Dim PropPX As Single, PropP As Single, PropC As Single, TempMax As Long, TempMax2 As Long, WorstP As Double, WorstOne As Long, MaxSize As Long
Dim STime As Long, SAll As Long
SAbortFlag = 0
MaxRepeatCycles = 2
Dim tDaught() As Byte, OSX As String
DoQuick = 0
Dim NoRes As Byte
NoRes = 1
Dim tDon() As Byte
Dim TotP() As Double, TVal() As Double, TPVal() As Double, PScores() As Double, RLScore() As Double


Dim tDscores() As Double, ZPScoreHolder() As Double, ZSScoreHolder() As Double

Dim Consensus() As Double

Dim LastLowP As Double, AgeScore() As Single, EventScore() As Long, Y As Long, otMatch As Double, OKSeq() As Double, RFF As Byte, RList2() As Long, RNum2() As Long
Dim PhPrScore() As Double, PhPrScore2() As Double, tPhPrScore2() As Double, SubPhPrScore2() As Double, SubScore2() As Double
Dim MeanPScore() As Double, SDPScore() As Double
Dim RetrimFlag As Byte
Dim PhPrScore3() As Double, tPhPrScore3() As Double, SubPhPrScore3() As Double, SubScore3() As Double
Dim NuminGroup() As Long, BPlots() As Single, tRCorr() As Single, RCorr() As Single, RInv() As Single, ListCorr3() As Single, ListCorr() As Single, ListCorr2() As Single, tListCorr() As Single, BadDists() As Single, SSDist(2) As Double, TDiffs() As Single, TValid() As Single
Dim oRNumX(2), SimScore() As Byte, SimScoreB() As Double, UNF() As Byte, INList() As Byte, OUList() As Byte, AAF As Byte, MiF As Byte, MaxBP(1) As Double, oPMax As Single, oPMin As Single, RWinPP As Byte, NPh As Long, SetTot() As Long, TotD As Double, RCorrWarn() As Byte, DontRedo() As Byte
Dim oXOSize As Long, JumpFlag As Byte, tEventAdd As Long, Epos As Long, BPos As Long, DMatS() As Single, LDst(1) As Double, AVSN(3) As Double, LowP As Double, RedoCycle As Byte, SLS As Long, UBX As Long
Dim InvS() As Byte, DoneProg() As Byte, TempDone() As Byte, DoneSeq() As Byte
Dim Outlyer(3) As Byte, SeqPair(2) As Byte, MinPair(1) As Byte
Dim DoneTarget As Byte, MissIDFlag As Byte
Dim Relevant2() As Byte, PDist(2, 3) As Single, tMatch(1) As Double, TrpScore(3) As Double, SubScore(3) As Double, SubPhPrScore(2) As Double
Dim MinDist(1) As Double, LDist(2) As Double, LDist2(2) As Double, LDist3(2) As Double, LDist4(2) As Double, LDistB(2) As Double, LDistB2(2) As Double, LDistB3(2) As Double, LDistB4(2) As Double, TtX(1) As Double, IntVal(1) As Double, MinDistZ(2) As Double

Dim TmF As Double, AvDst As Double

Dim ActualSeqSize() As Long, TraceSub() As Long, Uninvolved() As Long, LowP2 As Double
Dim dMax(2) As Single, RCompatC(2) As Long, RCompatD(2) As Long, RCompatB(2) As Long, RCompat(2) As Long, BPosLR(3) As Long, RSize(5) As Long, CSeq(1) As Long, CompMat(2, 1) As Long, ISeqs(2) As Long, Trace(1) As Long, TraceB(1) As Long
Dim NScoresX() As Long, WinnerPos() As Long, WinnerPosMa() As Long, WinnerPosMi() As Long, SLookup() As Long, SLookupNum() As Long, DoPairs() As Byte, RListX() As Long, RNumX() As Long, RList() As Long, RNum() As Long, oRNum() As Long
Dim OuCheck() As Long, oBreaks() As Long, oRList() As Long, tMatchX() As Long, FoundOne() As Long, SQ() As Long, OLSeq() As Long, OLSeqB() As Long, OLSeqE() As Long, GoodC() As Long, MinSeq() As Long, MaxSeq() As Long, GroupSeq() As Long, DoneOne() As Long, Breaks() As Long, InvListX() As Long, InvList() As Long, InPen() As Long, InPenX() As Long
Dim NumD As Long, Mi As Long, DA As Long, Ma As Long, UB As Long
Dim OLSize As Long, TWinner As Long, BPos2 As Long, EPos2 As Long, tWinPP As Long, OS As Long, OE As Long, WinPP As Long, ActualE As Long, BXOSize As Long
Dim xNextno As Long, WinPPY As Long, EventAdd As Long, SP(5) As Long, EP(5) As Long, VSN As Long, tSN As Long, oldY As Long, XOSize As Long, WinRL As Long, oTotRecs As Long, sNextno As Long
Dim PhylCheck As Byte

Dim CAcList() As Integer, AcList() As Integer, tSeqnum() As Integer
Dim tBXOListMa() As XOverDefine, tBXOListMi() As XOverDefine, CollectEvents() As XOverDefine, CollectEventsMi() As XOverDefine, CollectEventsMa() As XOverDefine, PXOList() As XOverDefine, TempXOList() As XOverDefine, BestXOList() As XOverDefine
Dim tBcurrentxoverma() As Integer, tBcurrentxovermi() As Integer, DoneX() As Long, RCats() As Long, NRNum() As Long, NRList() As Long, NRNum2() As Long, NRList2() As Long, Relevant() As Long, PCurrentXover() As Integer, tCurrentxover() As Integer, BCurrentXOver() As Integer

If PermNextno <> NextNo Then
    Call UnModNextno
End If


If DebuggingFlag < 2 Then On Error Resume Next
UB = 0
UB = UBound(BPCIs, 2)
On Error GoTo 0
If UB = 0 Then
    ReDim BPCIs(9, 100)
End If
Dim Segbound() As Byte
ReDim Segbound(Len(StrainSeq(0)))
If ReassortmentFlag = 1 Then
    
    For x = 0 To RBPNum
        'TBP = RBPPos(X)
        Segbound(RBPPos(x)) = 1
    Next x
End If


oTotRecs = oRecombNo(100)

Call MakeTotX(AddNum, TotT, MethodTime(), TimeFract())

'reDim UsedPar(Len(StrainSeq(0)), NextNo)
If ShowPlotFlag = 1 Then ShowPlotFlag = 2
If ShowPlotFlag = 2 And (CLine = "" Or CLine = " ") Then
        Call SetUpAxes(NextNo, XoverList(), CurrentXOver(), BPlots(), MaxBP(), oPMax, oPMin)
End If

Form1.SSPanel1.Caption = "Looking For Unique Events"

LT = Abs(GetTickCount)
TmF = 10 ^ -14
BXOSize = 10

Rnd (-BSRndNumSeed)
CHEvFlag = -1

RedoCycle = 0
ReDim SQ(2), RecombNo(AddNum)
ReDim ExtraHits(PermNextno, 1), ExtraHitsMa(PermNextno, 1), ExtraHitsMi(PermNextno, 1)





If NextNo < 3 Then
    ForcePhylE = 0
End If

If DoQuick = 0 Then
    PhylCheck = 1
Else
    PhylCheck = 0
End If
'xxx = CurDir
'Open "Scores.csv" For Output As #1
'Close #1
oGCIndelFlag = GCIndelFlag
    
    
    'RDP arrays
    ReDim XDiffPos(Len(StrainSeq(0)) + 200), XPosDiff(Len(StrainSeq(0)) + 200)
    ReDim XoverSeqNum(Len(StrainSeq(0)), 2)
    ReDim ValidSpacer(NextNo), SpacerSeqs(NextNo)
    ReDim XoverSeqNumW(Len(StrainSeq(0)) + Int(XOverWindowX / 2) * 2, 2)
    If ProbEstimateInFileFlag = 1 Then
        GetBinProbs
    End If
    ReDim XOverHomologyNum(Len(StrainSeq(0)) + XoverWindow * 2, 2)

    'Genconv Arrays
    If GCtripletflag = 1 Then
        ReDim SubSeq(Len(StrainSeq(0)), 6)
        ReDim FragMaxScore(GCDimSize, 5), MaxScorePos(GCDimSize, 5)
        ReDim PVals(GCDimSize, 5), FragSt(GCDimSize, 6), FragEn(GCDimSize, 6), FragScore(GCDimSize, 6)
        ReDim DeleteArray(Len(StrainSeq(0)) + 1)
    End If

    'MaxChi Arrays
    If MCTripletFlag = 0 Then
            HWindowWidth = CLng(MCWinSize / 2)
            ReDim Scores(Len(StrainSeq(0)), 2)  ' 0=s1,s2Matches etc
            ReDim Winscores(Len(StrainSeq(0)) + HWindowWidth * 2, 2) ' 0=s1,s2Matches etc
            ReDim Chivals(Len(StrainSeq(0)), 2), SmoothChi(Len(StrainSeq(0)), 2)
            ReDim MDMap(Len(StrainSeq(0))), BanWin(Len(StrainSeq(0)) + HWindowWidth * 2)
            If MCProportionFlag = 0 Then
                
                Call GetCriticalDiff(0)
                
                If MCWinSize <> HWindowWidth * 2 And MCProportionFlag = 0 Then
                    MCWinSize = HWindowWidth * 2
                End If
            End If
    End If

    
    HWindowWidth = CLng(CWinSize / 2)
    
    ReDim ScoresX(Len(StrainSeq(0)))  ' 0=s1,s2Matches etc
    ReDim WinScoresX(Len(StrainSeq(0)) + HWindowWidth * 2) ' 0=s1,s2Matches etc
    ReDim ChiValsX(Len(StrainSeq(0))), SmoothChiX(Len(StrainSeq(0)))
    
    'Chimaera arrays
    Call GetCriticalDiff(1)
    If CWinSize <> HWindowWidth * 2 And CProportionFlag = 0 Then
        CWinSize = HWindowWidth * 2
    End If
    
    'SisCan arrays


        Dim WeightMod() As Long, Scratch() As Integer
        ReDim Scratch(BSStepWin), WeightMod(BSBootReps, BSStepWin - 1)
        Dummy = SEQBOOT2(BSRndNumSeed, BSBootReps, BSStepWin, Scratch(0), WeightMod(0, 0))
        

        Dim OnlySiScan As Byte
        If DoScans(0, 0) = 0 And DoScans(0, 1) = 0 And DoScans(0, 2) = 0 And DoScans(0, 3) = 0 And DoScans(0, 4) = 0 Then
            OnlySiScan = 1
        Else
            OnlySiScan = 0
        End If
        CurrentCorrect = 5
        Dim VRandTemplate() As Byte, HRandTemplate() As Long, TakenPos() As Byte
        '
        'Dimension horizontal randomisation array if necessary
        'If SSOutlyerFlag = 0 Or SSOutlyerFlag = 1 Or X = X Then 'new
            ReDim HRandTemplate(SSWinLen)
            ReDim TakenPos(SSWinLen)
        'End If
        ReDim VRandTemplate(0, 0)
        Call CheckSisMem
        'Dimension vertical randomisation array
        If DoScans(0, 5) <> 0 Or DoScans(1, 5) <> 0 Then
            ReDim VRandTemplate(Len(StrainSeq(0)), SSNumPerms)
            '
            Dim DoGroupS() As Byte, DoGroupP() As Byte, DG1() As Byte, DG2() As Byte, VRandConv(15, 12) As Byte, Seq34Conv() As Byte
            ReDim DoGroupP(1, 3), DoGroupS(1, 3), DG1(15), DG2(14), Seq34Conv(5, 5)
            
            Call SetUpSiScan(Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
            LSeq = Len(StrainSeq(0))
            WinNum = CLng(Len(StrainSeq(0)) / SSStep + 1)
            Dim CorrectP As Double, TSub() As Long, oSeq As Long, PermSScores() As Long, PScoreHolder() As Long, SScoreHolder() As Long, PermPScores() As Long, SeqScore3() As Integer
            ReDim SeqScore3(Len(StrainSeq(0))), MeanPScore(15), SDPScore(15)
            ReDim PermSScores(SSNumPerms, 15), PermPScores(SSNumPerms, 15), SScoreHolder(WinNum, 14), PScoreHolder(WinNum, 15)
            
            Dim SeqMap() As Byte
            ReDim SeqMap(Len(StrainSeq(0)))
            ReDim ZPScoreHolder(WinNum, 15)
            ReDim ZSScoreHolder(WinNum, 14)
            
            'ReDim PermPScores(SSNumPerms, 15)
            If SSOutlyerFlag = 2 Then
                Call GetOutie
                oSeq = Outie
            End If
            ReDim TSub(NextNo)
            For x = 0 To NextNo
                TSub(x) = x
            Next x
        End If
        
        If MCFlag = 0 Then
            CorrectP = LowestProb / MCCorrection
        Else
            CorrectP = LowestProb
        End If


ReDim Scores(Len(StrainSeq(0)), 2)
SDNum = 0
'xxxxzzzz ReDim EventSeq(3, Len(StrainSeq(0)), 1)

Eventnumber = 0

'Make permanent copy of xoverlist
XOSize = UBound(XoverList, 2)


ReDim TraceSub(NextNo)
If NextNo > PermNextno Then
    ReDim Preserve PermOriginalName(NextNo)
End If

For x = 0 To NextNo
    TraceSub(x) = x
Next x

If PermNextno > NextNo Then
    For x = 0 To NextNo
        PermOriginalName(x) = OriginalName(TraceSub(x))
    Next x
ElseIf NextNo > PermNextno Then
    For x = PermNextno + 1 To NextNo
        TraceSub(x) = S2TraceBack(x)
        PermOriginalName(x) = OriginalName(TraceSub(x))
    Next x
End If


'ReDim SimSeqNum(Len(StrainSeq(0)), Nextno)


ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)

TXOS = NextNo
'PermNextNo = NextNo
oNextno = NextNo
'Dummy = CopySeqs(Len(StrainSeq(0)), Nextno, SeqNum(0, 0), SimSeqNum(0, 0))

CompMat(0, 0) = 1: CompMat(0, 1) = 2: CompMat(1, 0) = 0: CompMat(1, 1) = 2: CompMat(2, 0) = 0: CompMat(2, 1) = 1

STime = Abs(ST)


If XOMiMaInFileFlag = 1 Then
        'XOMiMaInFileFlag As Byte, UBXOMi As Long, UBXoMa As Long
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    ReDim BestXOListMi(PermNextno, UBXOMi)
    ReDim BestXOListMa(PermNextno, UBXoMa)
    UBXoMa = UBound(BestXOListMa, 2)
    If MiRec < 1 Then
        Open "RDP5BestXOListMi" + UFTag For Binary As #FF
        Get #FF, , BestXOListMi()
        Close #FF
        MiRec = 1
    End If
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    If DebuggingFlag < 2 Then Form2.WindowState = Form2.WindowState
    
    If MaRec < 1 Then
        Open "RDP5BestXOListMa" + UFTag For Binary As #FF
        Get #FF, , BestXOListMa()
        Close #FF
        MaRec = 1
    End If
    ChDrive oDirX
    ChDir oDirX
    
    Call UpdateF2Prog
    
    
End If


Call BuildFirstXOList(0, SPX, AgeScore(), EventScore(), MinSeqSize, JumpFlag, MissingData(), TraceSub(), NextNo, StepNo, Steps(), ExtraHits(), ExtraHitsMa(), ExtraHitsMi(), NOPINI(), Eventnumber, SEventNumber, BestXOList(), BCurrentXOver(), XoverList(), CurrentXOver(), BestXOListMi(), BCurrentXoverMi(), BestXOListMa(), BCurrentXoverMa(), Daught(), MinorPar(), MajorPar())


If AbortFlag = 1 Then

        Call DoUndo
        
        Exit Sub
End If


If PermNextno * (Len(StrainSeq(0))) > 10000000 Then
    oDir = CurDir
    ChDir App.Path
    ChDrive App.Path
    
    'Erase SBlockBak
    'redim permarray(0,0)
    Dim UBSB1 As Long, UBSB2 As Long, UBPA1 As Long, UBPA2 As Long
    If DebuggingFlag < 3 Then On Error Resume Next
    UBSB1 = -1
    UBSB2 = -1
    UBSB1 = UBound(SBlockBak, 1)
    UBSB2 = UBound(SBlockBak, 2)
    On Error GoTo 0
    If UBSB1 > -1 Then
        FF = FreeFile
        Open "SBlockBak" + UFTag For Binary As #FF
        Put #FF, , SBlockBak()
        Close #FF
        Erase SBlockBak
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    UBPA1 = 0: UBPA2 = 0
    UBPA1 = UBound(PermArray, 1)
    UBPA2 = UBound(PermArray, 2)
    On Error GoTo 0
    If UBPA1 > 0 Then
        FF = FreeFile
        Open "PermArray" + UFTag For Binary As #FF
        Put #FF, , PermArray()
        Close #FF
        ReDim PermArray(0, 0)
    End If
    
    
    If StrainSeqOnDisk = 0 Then
        Open "RDP5Strainseq" + UFTag For Binary As #FF
        Put #FF, , StrainSeq()
        Close #FF
        StrainSeqOnDisk = 1
    End If
    ReDim Preserve StrainSeq(0)
    
    
        
    ChDir oDir
    ChDrive oDir

End If



If JumpFlag = 0 Then
    ReDim BCurrentXoverMa(NextNo), BCurrentXoverMi(NextNo), BestXOListMa(NextNo, 10), BestXOListMi(NextNo, 10)
    ReDim BCurrentXOver(NextNo)
    ReDim BestXOList(NextNo, BXOSize), BestXOListMa(NextNo, BXOSize), BestXOListMi(NextNo, BXOSize)
End If

ReDim RepeatCycles(1000)
RestartX:
If SAbortFlag = 1 And AbortFlag = 0 Then
    AbortFlag = 1
    SAbortFlag = 0
End If
ReDim Relevant(NextNo), Uninvolved(NextNo)
ReDim PCurrentXover(NextNo), TempXOList(NextNo, XOSize), PXOList(NextNo, XOSize)
ReDim DoneSeq(NextNo, UBound(PXOList, 2)), StepSEn(100)
ReDim NumRecsI(NextNo), Relevant2(2, NextNo)

'MSize = GetMSize(XOverlist())


Call CopyXOLists(XOSize, DoneSeq(), TempXOList(), PXOList(), PCurrentXover(), XoverList(), CurrentXOver(), NumRecsI())
'XX = PXOList(0, 4).Probability
'Make permanent copy of seqnum


ReDim XoverList(UBound(XoverList, 1), 0)

'Work out actual sequence sizes at the start
ReDim ActualSeqSize(NextNo)
For x = 0 To NextNo
    For Y = 1 To Len(StrainSeq(0))
        If SeqNum(Y, x) > 46 Then
            ActualSeqSize(x) = ActualSeqSize(x) + 1
        End If
    Next Y
Next x

oDirX = CurDir
ChDrive App.Path
ChDir App.Path
If Dir("RDP5ExcludeList" + UFTag) <> "" Then
    DoExcludes = 1
    ReDim DoneExcludes(PermNextno)
    
End If
ChDrive oDirX
ChDir oDirX
XX = ExcludedEventNum
Dim Last0 As Long, Last1 As Long
Dim SkipLoRCA As Byte
SkipLoRCA = 0

BusyWithExcludes = 0
FirstAddSome = 0: BPTime = 1: TreeTime = 1: FBD = 1: LoopENum = 1


Dim TestPVs() As Double


If ExRecFlag = 203 Then
    Dim bPXOlist() As XOverDefine
    ReDim bPXOlist(UBound(PXOList, 1), UBound(PXOList, 2))
    For x = 0 To UBound(PXOList, 1)
        For Y = 0 To UBound(PXOList, 2)
            bPXOlist(x, Y) = PXOList(x, Y)
        Next Y
    Next x
End If

Do 'loop until everything is completed from best to worst
    
    ssillystart = GetTickCount
    sNextno = NextNo
    DoneTarget = 0
    C = 0
    LowestProb = pLowestProb
    Call SetupDoneTests(NextNo, TestPVs(), PXOList(), PCurrentXover(), DoneSeq())
    
    
    Do
       
        'find the best P-value
        'start Section 2
        LastLowP = LowP
        LowP = LowestProb
        'LowP2 = LowestProb
        oRecombNo(100) = 0
        Do
ERF203:
            Trace(0) = 0
            Trace(1) = 0
            LowP = LowestProb
            'TraceB(0) = 0
            'TraceB(1) = 0
            'ReDim TestPVs(UBound(PXOList, 2), UBound(PXOList, 1))
'             If UBound(TestPVs, 2) <> NextNo Then
'                x = x
'             End If
'             If UBound(TestPVs, 1) <> UBound(PXOList, 1) Then
'                x = x
'             End If
            'oRecombNo(100) = FindBestRecSignal(DoneTarget, NextNo, UBound(PXOList, 1), LowP, DoneSeq(0, 0), Trace(0), PCurrentXover(0), PXOList(0, 0))
            
            If ExRecFlag = 203 Then
                oRecombNo(100) = FindBestRecSignalP(DoneTarget, NextNo, UBound(PXOList, 1), UBound(PXOList, 2), LowP, DoneSeq(0, 0), Trace(0), PCurrentXover(0), PXOList(0, 0))
'            t1x = Trace(0) '44,339
'            t2x = Trace(1)
'
'
'            Trace(0) = 0
'            Trace(1) = 0
'            lowpx = LowP
'            LowP = LowestProb
''            XX = UBound(PXOList, 2)
            Else
                oRecombNo(100) = FindBestRecSignalP2(DoneTarget, NextNo, UBound(TestPVs, 1), UBound(TestPVs, 2), LowP, DoneSeq(0, 0), Trace(0), PCurrentXover(0), TestPVs(0, 0))
            End If
            
            'X = X
'            If PXOList(Trace(0), Trace(1)).Daughter = 0 And PXOList(Trace(0), Trace(1)).MinorP = 0 Then
                
                
'                XX = SEventNumber '7, 8
'            End If
            'Call CheckNums(PXOList(), PCurrentXover())
'            If t1x <> Trace(0) Or t2x <> Trace(1) Then
'                x = x
'                XXX = PXOList(Trace(0), Trace(1)).Probability
'                XXX = PXOList(t1x, t2x).Probability
'            End If
'            If PXOList(t1x, t2x).Probability <> LowP And t1x > 0 And t2x > 0 Then
'                x = x
'            End If
'
            
            
            'XX = PCurrentXOver(55)
'            If Trace(0) <> TraceB(0) Or Trace(1) <> TraceB(1) Then
'                x = x
'            End If
            'XX = PXOList(93, 12).Probability
            'XX = DoneSeq(93, 12)
'            For x = 0 To UBound(TestPVs, 1)
'                For Y = 0 To UBound(TestPVs, 2)
'                    If TestPVs(x, Y) = LowP Then
'                        x = x
'                        XX = DoneSeq(Y, x)
'                        XX = PXOList(Y, x).Probability
'                    End If
'                Next Y
'            Next x
            'XX = CurrentXOver(52)
'            If LowP <> TestPVs(Trace(1), Trace(0)) And LowP < 0.05 Then
'                x = x
'            End If
            'XX = UBound(DoneSeq, 1)

            If DoneSeq(Trace(0), Trace(1)) = 1 Then
                LowP = LowestProb
            End If
            
            If LowP = LowestProb Then Exit Do
'            For x = 0 To NextNo
'                For Y = 1 To PCurrentXOver(x)
'                    XX = PXOList(x, Y).Probability
'                Next Y
'            Next x
            'XX = PXOList(Trace(0), Trace(1)).Probability
            If PXOList(Trace(0), Trace(1)).MajorP = PXOList(Trace(0), Trace(1)).MinorP Or PXOList(Trace(0), Trace(1)).MajorP = PXOList(Trace(0), Trace(1)).Daughter Or PXOList(Trace(0), Trace(1)).Daughter = PXOList(Trace(0), Trace(1)).MinorP Then
                LowP = LowestProb
                'LowP2 = LowestProb
                PXOList(Trace(0), Trace(1)).Probability = 1
                If ExRecFlag <> 203 Then
                    If Trace(1) <= UBound(TestPVs, 1) And Trace(0) <= UBound(TestPVs, 2) Then
                        TestPVs(Trace(1), Trace(0)) = 1
                    End If
                End If
                DoneSeq(Trace(0), Trace(1)) = 1
            ElseIf DoScans(0, PXOList(Trace(0), Trace(1)).ProgramFlag) = 0 Then
                If Last0 = Trace(0) And Last1 = Trace(1) Then
                    LowP = LowestProb
                    Exit Do
                End If
                LowP = LowestProb
                'LowP2 = LowestProb
                PXOList(Trace(0), Trace(1)).Probability = 1
                If ExRecFlag = 203 Then
                    bPXOlist(Trace(0), Trace(1)).Probability = 1
                Else
                    TestPVs(Trace(1), Trace(0)) = 1
                End If
                Last0 = Trace(0)
                Last1 = Trace(1)
                
            Else
                Exit Do
            End If
            
        Loop
        
'            XX = PXOList(Trace(0), Trace(1)).Daughter '0
'            XX = PXOList(Trace(0), Trace(1)).MajorP '12
'            XX = PXOList(Trace(0), Trace(1)).MinorP '1
'            XX = PXOList(Trace(0), Trace(1)).Probability
            'XX = PXOList(22, 240).MinorP '22,21,24
'            X = X
'        Else
'            Call FindBestRecSignalVB(oRecombNo(100), LowP, Trace(), PCurrentXOver(), DoneSeq(), PXOList())
'        End If
'        If SEventNumber > 13 Then
'                    X = X
'                End If
        '248,3: 2,8: 149,6: 10,5: 149,2: 40,2: 40,1: 193,1: 184,1: 163,1: 210,1: 7,1: 258,1: 185,1: 251,1: 259,1: 9,1 :181,1 :196,1: 100,1: 63,1: 139,1: 137,1
        '
        ' 14                                                                                                       81,1:181,1:196,1:139,1:261,1
        
'        ET = Abs(GetTickCount)
'
'        If Abs(ET - GlobalTimer) > 500 Then
'            GlobalTimer = ET
'            Call SignalCount(PXOList(), PCurrentXOver())
'            UpdateRecNums (SEventNumber)
'            Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
'            If Abs(ET - ELT) > 2000 Then
'                ELT = ET
'                If oTotRecs > 0 Then
'                    PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
'                    If PBV > Form1.ProgressBar1 Then
'                        Form1.ProgressBar1 = PBV
'                        Call UpdateF2Prog
'                    End If
'                End If
'
'            End If
'        End If
        
'        If PXOList(Trace(0), Trace(1)).Daughter = 258 Or PXOList(Trace(0), Trace(1)).MajorP = 258 Or PXOList(Trace(0), Trace(1)).MinorP = 258 Then
'            x = x
            'XX = PXOList(Trace(0), Trace(1)).Ending
            'XX = PXOList(Trace(0), Trace(1)).Beginning
          ' XX = PXOList(93, 3).Probability
'        End If
'        If LowP = LowestProb And RedoListSize = 0 Then
'            ZZ = 0
'            If RedoListSize < 1 Then
'                Do While ZZ < 100
'                    If Dir("RDP5Redolist" + Str(Iter) + UFTag) <> "" Then
'                        oDirX = CurDir
'                        ChDrive App.Path
'                        ChDir App.Path
'                        FF = FreeFile
'                        Open "RDP5Redolist" + Str(ZZ) + UFTag For Binary As #FF
'                        Get #FF, , RedoListSize
'                        ReDim RedoList(3, RedoListSize)
'                        Get #FF, , RedoList()
'                        Close #FF
'                        Kill "RDP5Redolist" + Str(ZZ) + UFTag
'                        RedoCycle = 0
'                        ChDrive oDirX
'                        ChDir oDirX
'
'                    Else
'                        ZZ = ZZ + 1
'                    End If
'                Loop
'                x = x
'            Else
'               ' RedoListSize = 0
'            End If
'        End If

'XX = Trace(0) '217,407;108,119;359,186;238,485
'XX = Trace(1)
''1.05x10-21,1.075x10-21
        If LowP = LowestProb And RedoListSize <= 0 Then
            Call CheckForOldRedolIst
        End If
        If LowP = LowestProb And RedoListSize > 0 And RedoCycle = 0 Then
            
            If PermNextno > MemPoc Then
                GetDistance
            End If
            
            RedoCycle = 0
            ReDim CurrentXOver(NextNo)
            ReDim MaxXOP(AddNum - 1, NextNo)
            Call ResetMaxPVCO(NextNo)
            ReDim SubSeq(Len(StrainSeq(0)), 6)
            ReDim Chivals(Len(StrainSeq(0)), 2)
REDOREDO:
            
            x = RedoListSize
            SLS = RedoListSize
            Dim tRedolistSize As Long, tRedoList() As Long
            ReDim tRedoList(3, RedoListSize)
            tRedolistSize = RedoListSize
            For Y = 0 To 3
                For Z = 0 To RedoListSize
                    tRedoList(Y, Z) = RedoList(Y, Z)
                Next Z
            Next Y
            RedoListSize = 0
            ReDim RedoList(3, 10)
            Call SignalCount(PXOList(), PCurrentXover())
            TT = Abs(GetTickCount)
            If Abs(TT - GlobalTimer) > 500 Then
                GlobalTimer = TT
                Call UpdateRecNums(SEventNumber)
            End If
            If PermNextno > MemPoc Then
                GetPermDiffs
                
            End If
            Do While x >= 0
                GoOn = 1
                
                If GoOn = 1 Then
                    Seq1 = tRedoList(1, x)
                    Seq2 = tRedoList(2, x)
                    Seq3 = tRedoList(3, x)
                    
                    If Seq1 <= NextNo And Seq2 <= NextNo And Seq3 <= NextNo Then
                       
                        If tRedoList(0, x) = 0 Then
                            Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                            'x = x
                        ElseIf tRedoList(0, x) = 1 Then
                            Call GCXoverD(0)
                            'X = X
                        ElseIf tRedoList(0, x) = 2 Then
                             'Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                        ElseIf tRedoList(0, x) = 3 Then
                            Call MCXoverF(1, 0, 0) 'the "1" in the first position tells RDP to all ow windows to overlap missing data
                            'x = x
                        ElseIf tRedoList(0, x) = 4 Then
                            tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                        
                            Call CXoverA(0, 0, 0)
                                                        
                            Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                        
                            Call CXoverA(0, 0, 0)
                                                        
                            Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                        
                            Call CXoverA(0, 0, 0)
                                                        
                            Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                        
                        ElseIf tRedoList(0, x) = 5 Then
                            oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                            Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                            Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                        ElseIf tRedoList(0, x) = 6 Then
                        
                        End If
                    End If
                    If x > UBound(tRedoList, 2) Then
                        Exit Do
                    End If
                    If x >= 0 Then
                        'XX = UBound(RedoList, 2)
                        tRedoList(0, x) = -1
                    End If
                
                End If
                x = x - 1
                TT = Abs(GetTickCount)
                If Abs(TT - GlobalTimer) > 500 Then
                    GlobalTimer = TT
                    Form1.SSPanel1.Caption = Trim(Str(SLS - x)) & " of " & Trim(Str(SLS + 1)) & " triplets reexamined"
                    UpdateRecNums (SEventNumber)
                    Form1.Label50(12).Caption = DoTimeII(Abs(TT - ST))
                    
                    For ZZ = 0 To AddNum - 1
                        MethodTime(ZZ) = MethodTime(ZZ) + Abs(TT - GlobalTimer) * TimeFract(ZZ)
                        'X = X
                    Next ZZ
                    Call UpdateTimeCaps(TT, SAll)
                    GlobalTimer = TT
                    'Form1.Refresh
                    DoEvents
                End If
                
            Loop
            'Erase NumSeq
            Erase ISeq4
            'clean up redolist
            'XX = NextNo
            Dummy = CleanRedoList(RedoListSize, RedoList(0, 0))
            
            Call CopyXOLists(XOSize, DoneSeq(), TempXOList(), PXOList(), PCurrentXover(), XoverList(), CurrentXOver(), NumRecsI())
           
            ReDim XoverList(UBound(XoverList, 1), 0)
            FF = FreeFile
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            Dim Iter As Long
            Iter = 0
            'If RedoListSize < 1 Then
                Do While Iter < 100
                    If Dir("RDP5Redolist" + Str(Iter) + UFTag) <> "" Then
                        Open "RDP5Redolist" + Str(Iter) + UFTag For Binary As #FF
                        Get #FF, , RedoListSize
                        ReDim RedoList(3, RedoListSize)
                        Get #FF, , RedoList()
                        Close #FF
                        Kill "RDP5Redolist" + Str(Iter) + UFTag
                        RedoCycle = 0
                        ChDrive oDirX
                        ChDir oDirX
                        GoTo REDOREDO
                    Else
                        Iter = Iter + 1
                    End If
                Loop
                'X = X
            'Else
               ' RedoListSize = 0
            'End If
            ChDrive oDirX
            ChDir oDirX
            If ExRecFlag <> 203 Then
                Call SetupDoneTests(NextNo, TestPVs(), PXOList(), PCurrentXover(), DoneSeq())
            End If
        ElseIf DoExcludes = 1 And LowP = LowestProb And SEventNumber > 0 Then
'            Open "progress.txt" For Append As #20
'            Print #20, SEventNumber, "addexcludes"
'            Close #20
'            For ZZ = PermNextno + 1 To Nextno
'                'XX = BCurrentXoverMa(ZZ) = 0
'
'            Next ZZ
'            If SEventNumber > 100 Then
'                GoTo FAI
'            End If
            Call SignalCount(PXOList(), PCurrentXover())
            
            Call AddSomeExcludes(TraceSub(), MinSeqSize, NextNo, SeqNum(), ActualSeqSize(), PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), BackUpNextno, MissingData(), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, BestXOList(), BCurrentXOver())
            
            If DoExcludes = 1 Then
                'reDim tDoneSeq(Nextno, UBound(PXOList, 2))
                ReDim PCurrentXover(NextNo)
                ReDim PXOList(NextNo, UBound(PXOList, 2))
                ReDim DoneSeq(NextNo, UBound(PXOList, 2))
                ReDim NumRecsI(NextNo)
                Call CopyXOLists(XOSize, DoneSeq(), TempXOList(), PXOList(), PCurrentXover(), XoverList(), CurrentXOver(), NumRecsI())
                
                ReDim XoverList(UBound(XoverList, 1), 0)
                
                DoEvents
                SkipLoRCA = 1
            End If
            If AbortFlag = 1 Then GoTo FAI
            
        
            If ExRecFlag <> 203 Then
                Call SetupDoneTests(NextNo, TestPVs(), PXOList(), PCurrentXover(), DoneSeq())
            End If
            'DoExcludes = 1
        ElseIf LowP = LowestProb Or AbortFlag = 1 Or (LastLowP = LowP And LowP > 10) Then
            If DoneTarget = 1 Or ForcePhylE = 1 Or AbortFlag = 1 Then
                If x = 12345 Then
            
FAI:
                    'X = X
                End If
                
                If AbortFlag = 0 And x = 12345 Then
                    Response = MsgBox("There is not enough memory remaining to continue with the scan right now.  You should save the analysis up till this point in .rdp format.  if you would like to continue scanning for recombination in this alignment you should save the alignment 'with recombinant regions removed' and rescan - This will identify the remaining signals of recombination. When you save the ersults of the rescan in .rdp format you can merge the two .rdp files by simply sequentially loading both files and choosing the 'merge files' option that will be offered.")
                    
                End If
                
                Form1.ProgressBar1.Value = 100
                Call UpdateF2Prog
                '2.797 old treedistances
                '2.766 new treedistances not in C
                '2.641 ints in RDP's Findseq and better nesting
                '2.328 ints in xohomol
                '2.265 not using pointers in xohomol
                '2.187 discalcx optimised quickdist
                '2.157 not using distance pointer in neighbor
                '2.141 better iterations in neighbour
                '1.863 using dopairs (but on laptop)
                '1.609 dopairs and optimised section 1.
                '1.578 - improvements in section 5
                '1.312 - improvements in section 9
                '1.250 - improvements in section 11/xover
                '1.142 (laptop) inprovements in section 6
                '0.941 (laptop) improvements in sections 16 - 19
                '0.871 (laptop) improvements in sections 10 and 12
                '0.801 (laptop)getting rid of section 9
                '0.781 (laptop) improvements in section 4
                '0.721 (laptop) improvements in section 6 & 7 using "relevant" array
                '0.500 (dsktop) even with using missing data
                '0.469 (dsktop) using checksplits & findmissing
                '0.590 (laptop)
                '0.581 -(laptop) maketrpgroups
                '0.551 - (laptop) makebposlr
                '0.422 (dsktop) -better dims in dordp
                '0.406 (dsktop) improvements in section 7
                '0.421
                '0.501 (laptop)
                '0.375 (dsktop)
                '0.359 using copyseq
                
                '7.515 no MC
                '7.020 (laptop no mc)
                '3.896
                '3.815 - makephprscore
                '3.605 - maketrpgroups
                '3.595 - makebposlr
                '3.956
                '3.825
                '3.535 - improvements in UPGMA
                '3.250 -improvements in dimentioning
                '3.047 - using makerlist
                '2.969 - using testrlist
                '3.365 (laptop)
                '2.735 (dsktop)
                '2.703 - makesplit
                '2.625 - stripunfound
                '2.610
                
                '1.522 (all evidence)
                '0.931 (forcephyle)
                '0.752 using highenough
                '0.721 calckmax
                '0.691 distributing hits accross xolist
                
                
                '2.584 (no correction)
                
                
                'maxchi results
                
                '0.681 laptop(correction)
                '0.541 lptop
                '0.531 laptop findhiseqs
                '0.511 using vquickdist
                
                '79.711 (no correction)
                '2.964 (laptop) wo quickdist
                '2.664 - using vquickdist
                '18.672 - maxxolistsize = 3 RGC no correct
                '17.750 - maxxolistsize = 6 RGC no correct
                '14.456 - maxxolistsize = 12 RGC no correct
                '9.578 - no maxxolistsize restriction
                
                '1.072
                '0.751
                '0.741
                '0.701
                
                
                
                
                Erase tBXOListMa
                Erase tBXOListMi
                Erase CollectEvents
                Erase CollectEventsMi
                Erase CollectEventsMa
                Erase PXOList
                Erase TempXOList
                
                
                Call Finalise(BCurrentXOver(), BestXOList())
                Form1.ProgressBar1.Value = 0
                Call UpdateF2Prog
                ModSeqNumFlag = 0
                Call FilterSteps
                'findallflag=0
                '69 (912)-old inner
                '68 (1078)-new inner
                'findallflag=1
                '79 (777)-old inner
                '80 (947)-new inner
                '80 929 (new no costrains)
                '79 777 fixtish
'                XX = TotMCCycles '99172662 new maxchi,99053056 old maxchi
'                XX = TotMCCycles2
                Exit Sub
            Else
                DoneTarget = 1
            End If
        Else
            
            XX = SEventNumber
            Epos = PXOList(Trace(0), Trace(1)).Ending '1401
            BPos = PXOList(Trace(0), Trace(1)).Beginning '617
            If BPos = 0 Then BPos = 1
            If Epos = 0 Then Epos = 1
            ISeqs(0) = PXOList(Trace(0), Trace(1)).Daughter '1223
            ISeqs(1) = PXOList(Trace(0), Trace(1)).MinorP '1213
            ISeqs(2) = PXOList(Trace(0), Trace(1)).MajorP '2774
            XX = PXOList(Trace(0), Trace(1)).Probability
            '27,46,38: pos 27,50, bp 1013, 1328
            
            'x = x
            'XX = PXOList(Trace(0), Trace(1)).ProgramFlag

           '23,374,359;23,389,373
            
            LongFlag = DoneTarget
            
            'start Section 1***********************************************
            
            ''''''''''''''''''''''''''''''''''''''''''''''''''''
            'Thid may need to be reinstated for large datasets
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''
'            If PermNextno > MemPoc And x = 1234567 And UBound(Distance, 1) = NextNo Then
'                oDir = CurDir
'                ChDir App.Path
'                ChDrive App.Path
'
'                FF = FreeFile
'                UBDistance = UBound(Distance, 1)
'                Open "RDP5Distance" + UFTag For Binary As #FF
'                Put #FF, , Distance()
'                Close #FF
'                DistanceInFileFlag = 1
'                ReDim Distance(0, 0)
'                ChDir oDir
'                ChDrive oDir
'            End If
            
            'SS = Abs(GetTickCount)
            'For I = 0 To 100
            'If PolishBPFlag = 1 Or ReassortmentFlag = 1 Or AllowConflict = 0 Then
'            Open "progress.txt" For Append As #20
'        Print #20, SEventNumber, "testmoveintree"
'        Close #20
           ' SSSS = abs(gettickcount)
            Dim oMP0 As Long, oMP1 As Long, FTF As Long, CIOut() As Long, FreePass As Byte, TDone As Byte
            ReDim CIOut(9)
            FreePass = 0
            TDone = 0
            GoOn = 1
            FTF = 0
            If BPTime = 0 Then BPTime = 1
            
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'note: need to reinstate this checkpoint at some point - it can save a lot of time
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'If X = X Then 'Or BPTime > TreeTime / ((BPTime / FBD) / (TreeTime / LoopENum)) Then
                SS = Abs(GetTickCount)
                Call TestMoveInTreeAlt(1, 0, 1, BPos, Epos, SeqPair(), MinPair(), ISeqs(), SeqNum())
                TDone = 1
                EE = Abs(GetTickCount)
                TT = Abs(EE - SS)
                If TT = 0 Then TT = 7
                LoopENum = LoopENum + 1
                TreeTime = TreeTime + TT
                If MinPair(0) = MinPair(1) Then
                    GoOn = 0
                    FTF = 0
                    oMP0 = 0
                    oMP1 = 0
                Else
                    FTF = 1
                    oMP0 = MinPair(0)
                    oMP1 = MinPair(1)
                End If
            
            'End If
            
            If GoOn = 1 And (PolishBPFlag = 1 Or ReassortmentFlag = 1) And Len(StrainSeq(0)) = Decompress(Len(StrainSeq(0))) And AbortFlag = 0 Then ' does BensHMM polish and CIs
                SS = Abs(GetTickCount)
                If SS - GlobalTimer > 500 Then
                  GlobalTimer = SS
                  Form1.SSPanel1.Caption = "Determining breakpoint confidence intervals"
                End If
                oB = BPos
                OE = Epos
                GoOn = 0
                FBD = FBD + 1
                
                'If ExRecFlag <> 203 Then
                
                    Call PolishBP(20, 0, BPos, Epos, ISeqs(0), ISeqs(1), ISeqs(2), CIOut())
                 'x = x
                'End If
                
                 
                 'XX = CIOut(9) '0:2711 (L), 1:2721(R), 2:2718(M), 3:3822(L),4:3822(R),5:3822(M),6:2711(L99),7:2721(R99), 8:3822(L99), 9:3822(R99)
                
                
                'timing stuff
'                EE = Abs(GetTickCount)
'                TT = Abs(EE - SS) 'IP7 - 6375,3844
'                If TT = 0 Then TT = 7
'                BPTime = BPTime + TT
                
                
                
                'If Abs(PXOList(Trace(0), Trace(1)).Ending - EPos) + Abs(PXOList(Trace(0), Trace(1)).Beginning - BPos) > 5 Then  'if breakpoint positions have changed then the trees need to be remade.
                
                  
                  If ExRecFlag = 203 Then
                    GoodCall203 = 0
                    If (Abs(CIOut(6)) - 20 < PXOList(Trace(0), Trace(1)).Beginning And Abs(CIOut(7)) + 20 > PXOList(Trace(0), Trace(1)).Beginning) Or (Abs(CIOut(8)) - 20 < PXOList(Trace(0), Trace(1)).Ending And Abs(CIOut(9)) + 20 > PXOList(Trace(0), Trace(1)).Ending) Then
                        'x = x '2,3,4,5,6,7,8,9,10,11,14,15,16,17,18,19,20,21,23,24,25,27,37
                        GoodCall203 = 1
'                    Else
'                        XX = (SEventNumber + 1) '1,12,13,22,26,28,29,30,31,32,33,34,35,36
                    End If
                    Epos = PXOList(Trace(0), Trace(1)).Ending
                    BPos = PXOList(Trace(0), Trace(1)).Beginning
                  Else
                    PXOList(Trace(0), Trace(1)).Ending = Epos
                    PXOList(Trace(0), Trace(1)).Beginning = BPos
                  End If
                  
                   If TDone = 1 And (oB <> BPos Or OE <> Epos) Then
                        TDone = 0
                   Else
                        TDone = 0
                   End If
                    
            End If
            
            If TDone = 0 Then
                SS = Abs(GetTickCount)
                'omp0 = MinPair(0)
                'omp1 = MinPair(1)
                Call TestMoveInTreeAlt(1, 0, 1, BPos, Epos, SeqPair(), MinPair(), ISeqs(), SeqNum())
                
                TDone = 1
'                If FTF = 1 Then
'                    MinPair(0) = oMP0
'                    MinPair(1) = oMP1
'                End If
                
                EE = Abs(GetTickCount)
                TT = Abs(EE - SS)
                If TT = 0 Then TT = 7
                LoopENum = LoopENum + 1
                TreeTime = TreeTime + TT
            End If
            
            
            
            DoEvents 'this is needed to avoid the (not responding) warning - covered by currentlyrunningflag
            'Form1.WindowState = Form1.WindowState
            'Next I
            'ee = Abs(GetTickCount)
            'tt = ee - SS
            
            'X = X
            '16.944 total
            '9.834
            '8.913
            '5.608, 5.338, 5.408, 5.548
            '5.638, 5.828,5.408,5.358
            
            
            'XX = TraceSub(33)
            'end section 1*************************************************
            '12.749 5K perms
            '9.894 (9.814 without array dimentioning)
            '3.329 5K perms
            
            'if this doesn't move go back and find one that does
            'Erase PermsXOverList
'            If SEventNumber >= 34 Then
'        x = x
'        XX = UBound(SubDiffs, 2)
'    End If
                
            If (MinPair(0) <> MinPair(1) Or DoneTarget = 1 Or (ForcePhylE = 0 And UBound(SubDiffs, 1) >= NextNo) Or ExRecFlag = 203) Then 'And ReassortmentFlag = 0 Then
                  If ReassortmentFlag = 1 Then
                        If Segbound(BPos) = 1 Or Segbound(Epos = 1) Then
                            FreePass = 1
                        End If
                  End If
                  
                  'this is where I should do the minimum rank change test and, if necessary, change Iseqs to avoid recombinants of recombinants
                  Dim ExBPos As Long, ExEPos As Long
                  ExBPos = BPos: ExEPos = Epos: oi0 = ISeqs(0): oi1 = ISeqs(1): oi2 = ISeqs(2)
                  
                  If AllowConflict = 0 And SkipLoRCA = 0 Then
                        If PermNextno > MemPoc Then
                              GetFMat
                              GetSMat
                        End If
                        
                        'Call FindLoRCA(BPos, EPos, ISeqs(), Smat(), FMat(), PCurrentXOver(), PXOList(), Trace(), DoneSeq())
                        'Call FindMiCon(BPos, EPos, ISeqs(), Smat(), FMat(), PCurrentXOver(), PXOList(), Trace(), DoneSeq(), TraceSub())
                        
                        Call FindMiConB(BPos, Epos, ISeqs(), SMat(), FMat(), PCurrentXover(), PXOList(), Trace(), DoneSeq(), TraceSub())
                        
                        If PermNextno > MemPoc Then '2758:3199 : 3199,2720
                              ReDim FMat(0, 0)
                              ReDim SMat(0, 0)
                        End If
                  End If
                  
                 ' XX = ISeqs(0)
                  
                  
                  
                  
'                  If ExBPos <> BPos Or ExEPos <> Epos Or oi0 <> ISeqs(0) Or oi1 <> ISeqs(1) Or oi2 <> ISeqs(2) Then
'                    Call TestMoveInTree(1, 0, 1, BPos, Epos, SeqPair(), MinPair(), ISeqs(), SeqNum())
'
'                  End If
                  If ReassortmentFlag = 1 Then 'have to revoke the freepass if there is no overlap between the iseqs
                            
                            If PermNextno > MemPoc Then
                                GetFMat
                            End If
                            If FMat(ISeqs(0), ISeqs(1)) > 2 Or FMat(ISeqs(0), ISeqs(2)) > 2 Or FMat(ISeqs(1), ISeqs(2)) > 2 Then
                                FreePass = 0
                            End If
                            If PermNextno > MemPoc Then
                                ReDim FMat(0, 0)
                                GetSMat
                            End If
                            If SMat(ISeqs(0), ISeqs(1)) > 2 Or SMat(ISeqs(0), ISeqs(2)) > 2 Or SMat(ISeqs(1), ISeqs(2)) > 2 Then
                                FreePass = 0
                            End If
                            If PermNextno > MemPoc Then
                                ReDim SMat(0, 0)
                            End If
                            If PermNextno > MemPoc Then
                                If MinPair(0) = MinPair(1) And UBFAMat = 0 Then
                                    FreePass = 0
                                End If
                            Else
                                If MinPair(0) = MinPair(1) And UBound(FAMat, 1) = 0 Then
                                    FreePass = 0
                                End If
                            End If
                            
                  End If
                  
                  'X = X
            End If
'            If ISeqs(0) = 45 Then
'                x = x
'                XX = EPos
'                XX = BPos
'            End If
            'now do the tree with bootstrap replicates
            'Call TestMoveInTree(1, 10, 1, BPos, Epos, SeqPair(), MinPair(), ISeqs(), SeqNum())
            If AbortFlag = 0 And ((MinPair(0) <> MinPair(1)) Or FreePass = 1 Or DoneTarget = 1 Or (ForcePhylE = 0 And UBound(SubDiffs, 1) >= NextNo)) Then
                
                
                TT = Abs(GetTickCount)
                If (TT - GlobalTimer) > 500 Or x = x Then
                  GlobalTimer = TT
                  Form1.SSPanel1.Caption = "Finding recombinant sequence"
                  
                  ET = Abs(GetTickCount)
                  
                 If oTotRecs > 0 Then
                    If DoExcludes = 1 And BusyWithExcludes = 0 Then
                        PBV = (1 / PermNextno) * 100
                    ElseIf BusyWithExcludes = 0 Then
                        PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                    End If
                    If PBV > Form1.ProgressBar1 Then
                        Form1.ProgressBar1 = PBV
                        Call UpdateF2Prog
                    End If
                    
                End If
'        If Abs(ET - GlobalTimer) > 500 Then
'            GlobalTimer = ET
'            Call SignalCount(PXOList(), PCurrentXOver())
'            UpdateRecNums (SEventNumber)
'            Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
'            If Abs(ET - ELT) > 2000 Then
'                ELT = ET
'                If oTotRecs > 0 Then
'                    PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
'                    If PBV > Form1.ProgressBar1 Then
'                        Form1.ProgressBar1 = PBV
'                        Call UpdateF2Prog
'                    End If
'                End If
'
'            End If
'        End If
                End If
                
                'is the diff in minpair translatable to a change in tree shape?
                MinDist(0) = 1000000
                MinDist(1) = 1000000
                
                Outlyer(0) = 2
                Outlyer(1) = 1
                Outlyer(2) = 0
                Z = 0
                
                'Eventnumber = Eventnumber
                'Nextno = Nextno
                
                 
                RedoCycle = 0
                Eventnumber = Eventnumber + 1
                SEventNumber = SEventNumber + 1
                
                'add breakpoint CIs to the list
                If SEventNumber > UBound(BPCIs, 2) Then
                    ReDim Preserve BPCIs(9, SEventNumber + 100)
                End If
                For ZZ = 0 To 9
                    BPCIs(ZZ, SEventNumber) = CIOut(ZZ)
                Next ZZ
                
'                Open "BPs21.csv" For Append As #48
'                Print #48, Str(PXOList(Trace(0), Trace(1)).Beginning) + "," + Str(PXOList(Trace(0), Trace(1)).Ending) + "," + Str(CircularFlag)
'                Close #48
                
                'Mark this specific example as the for this event.
                
                PXOList(Trace(0), Trace(1)).DHolder = (PXOList(Trace(0), Trace(1)).DHolder + 0.00000001) * -1
                 
                UB = UBound(StepSEn, 1)
                If SEventNumber > UB Then
                    ReDim Preserve StepSEn(UB + 100)
                End If
                
                'XX = UBound(SubDiffs, 2)
                Exit Do
                
            Else

                C = C + 1
                ET = Abs(GetTickCount)
                If Abs(ET - GlobalTimer) > 500 Then
                    GlobalTimer = ET
                    
                    Form1.SSPanel1.Caption = Trim(Str(C)) & " of " & Trim(Str(oRecombNo(100))) & " rejected (no phylogenetic evidence)"
                    If Abs(ET - ELT) > 2000 Then
                        ELT = ET
                        If oTotRecs > 0 Then
'                            PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
'                            If PBV > Form1.ProgressBar1 Then
'                                Form1.ProgressBar1 = PBV
'                                Call UpdateF2Prog
'                            End If
                            If DoExcludes = 1 And BusyWithExcludes = 0 Then
                                PBV = (1 / PermNextno) * 100
                            ElseIf BusyWithExcludes = 0 Then
                                PBV = (1 - (oRecombNo(100) ^ 0.4 / oTotRecs ^ 0.4)) * 100
                            End If
                            If PBV > Form1.ProgressBar1 Then
                                Form1.ProgressBar1 = PBV
                                Call UpdateF2Prog
                            End If
                        End If
                                        
                    End If
                    'Form1.ProgressBar1 = 1
                    UpdateRecNums (SEventNumber)
                    DoEvents
                    Form1.Label50(12).Caption = DoTimeII(Abs(ET - STime))
                End If
                
                DoneSeq(Trace(0), Trace(1)) = 1
                Dim OverlapAB As Long, A1 As Long, A2 As Long, A3 As Long, b1 As Long, b2 As Long, b3 As Long, MatchesX As Byte, STA As Long, STB As Long, ENA As Long, ENB As Long
                A1 = PXOList(Trace(0), Trace(1)).Daughter
                A2 = PXOList(Trace(0), Trace(1)).MinorP
                A3 = PXOList(Trace(0), Trace(1)).MajorP
                STA = PXOList(Trace(0), Trace(1)).Beginning
                ENA = PXOList(Trace(0), Trace(1)).Ending '
                
                C = C + MarkDones(NextNo, Len(StrainSeq(0)), STA, ENA, A1, A2, A3, UBound(DoneSeq, 1), UBound(PXOList, 1), DoneSeq(0, 0), PCurrentXover(0), PXOList(0, 0))
                'XX = CurrentXOver(51)
                
'    x = x
'                For x = 0 To Nextno
'
'                    For Y = 1 To PCurrentXOver(x)
'
'
'                        If DoneSeq(x, Y) <> 1 Then ' DoneTarget Then
'                            CPVal = PXOList(x, Y).Probability
'
'                            If CPVal > 0 Then  ' And (PXOList(X, Y).ProgramFlag <> 5 Or OnlySiScan = 1) Then
'                                If PXOList(x, Y).Beginning <> PXOList(x, Y).Ending Then
'                                    b1 = PXOList(x, Y).Daughter
'                                    '@
'                                    b2 = PXOList(x, Y).MinorP
'                                    b3 = PXOList(x, Y).MajorP
'                                    MatchesX = 0
'                                    '@
'                                    If A1 = b1 Or A1 = b2 Or A1 = b3 Then
'                                        MatchesX = MatchesX + 1
'                                    End If
'                                    If A2 = b1 Or A2 = b2 Or A2 = b3 Then
'                                        MatchesX = MatchesX + 1
'                                    End If
'                                    If A3 = b1 Or A3 = b2 Or A3 = b3 Then
'                                        MatchesX = MatchesX + 1
'                                    End If
'                                    '@
'                                    If MatchesX > 1 Then
'                                        STB = PXOList(x, Y).Beginning
'                                        ENB = PXOList(x, Y).Ending
'                                        If STA < ENA Then
'                                            If STB < ENB Then
'                                                If Abs(STB - STA) + Abs(ENA - ENB) < 20 Then
'                                                    DoneSeq(x, Y) = 1
'                                                    C = C + 1
'                                                End If
'                                            Else
'                                                If Abs(Len(StrainSeq(0)) - STB + STA) + Abs(Len(StrainSeq(0)) - ENA + ENB) < 20 Then
'                                                    DoneSeq(x, Y) = 1
'                                                    C = C + 1
'                                                End If
'                                            End If
'                                        Else
'                                            If STB < ENB Then
'                                                If Abs(Len(StrainSeq(0)) - STA + STB) + Abs(Len(StrainSeq(0)) - ENB + ENA) < 20 Then
'                                                    DoneSeq(x, Y) = 1
'                                                    C = C + 1
'                                                End If
'                                            Else
'                                                If Abs(STB - STA) + Abs(ENA - ENB) < 20 Then
'                                                    DoneSeq(x, Y) = 1
'                                                    C = C + 1
'                                                End If
'                                            End If
'                                        End If
'                                    End If
'                               End If
'                            Else
'
'                                DoneSeq(x, Y) = 1
'                            End If
'                        End If
'                    Next Y
'                Next x
                
            End If
        End If
       ' x = x
    Loop
    '$
'    If SEventNumber >= 34 Then
'        x = x
'        XX = UBound(SubDiffs, 2)
'    End If
    Dummy = MarkOutsides(UBound(DoneSeq, 1), DoneSeq(0, 0), NextNo, UBound(PXOList, 1), PCurrentXover(0), PXOList(0, 0))
    
'    For x = 0 To NextNo
'        For Y = 1 To PCurrentXOver(x)
'            If DoneSeq(x, Y) = 1 Then
'                PXOList(x, Y).OutsideFlag = 1
'
'            End If
'        Next Y
'    Next x
    
    esillystart = GetTickCount
    sillystart = sillystart + esillystart - ssillystart
    'Form1.Caption = Str(RedoListSize) + Str(RedoCycle) + Str(LoopENum) + Str(TreeTime) + Str(FBD) + Str(BPTime) + Str(sillystart) + Str(totsilly) + Str(silly2) + Str(silly4) + Str(silly5)
   ' Form1.Caption = Str(sillystart) + Str(totsilly) + Str(silly2) + Str(silly3) + Str(silly4) + Str(silly5)
                    
      gtxsilly = GetTickCount
                    
                    
                    
'    Open "progress.txt" For Append As #20
'        Print #20, SEventNumber, "findrecomb"
'        Close #20
    If PermNextno > MemPoc Then
        GetPermValid
        GetPermDiffs
    End If
    
    TT = Abs(GetTickCount)
    'Call UpdateTimeCaps(SS, STartT)
    Form1.Label50(12).Caption = DoTimeII(Abs(TT - STime))
    
    Call MakeSmallArrays(ISeqs(), PermValid(), PermValidSmall())
    Call MakeSmallArrays(ISeqs(), PermDIffs(), PermDiffsSmall())
    
    'Call TestArrays(ISeqs)
    
    If PermNextno > MemPoc Then
        ReDim PermValid(0, 0), PermDIffs(0, 0)
    End If
    
    
    Dim LD(1, 2, 1) As Double, TraceInvolvedBak() As Long, DoneThis() As Long, tPhPrScore(2) As Double
    ReDim TraceInvolvedBak(NextNo)
    ReDim DoneThis(1, NextNo)
    
    
    
    
   
    'Make donethis
    'Dummy = MakeDoneThis(Nextno, FMat(0, 0), FAMat(0, 0), SAMat(0, 0), LD(0, 0, 0), DoneThis(0, 0), ISeqs(0))
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'This should be able to use small versions of fmat and smat
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Dummy = MakeDoneThis2(Nextno, FMat(0, 0), FMat(0, 0), SMat(0, 0), DoneThis(0, 0), ISeqs(0))
    Dummy = MakeDoneThis3(NextNo, FMatSmall(0, 0), FMatSmall(0, 0), SMatSmall(0, 0), DoneThis(0, 0), ISeqs(0))
    
    'XX = UBound(SubValid, 2)
    'XX = SEventNumber
'    If UBound(SubDiffs, 2) < NextNo Then
'        GetSubDiffs
'    End If
    For x = 0 To NextNo
        If DoneThis(0, x) = 0 Or DoneThis(1, x) = 0 Then
            If SubValid(0, x) > 0 And SubValid(1, x) > 0 And SubValid(2, x) > 0 Then 'are there some valid sites
                If (SubDiffs(0, x) / SubValid(0, x)) > 0.6 Or SubDiffs(1, x) / SubValid(1, x) > 0.6 Or SubDiffs(2, x) / SubValid(2, x) > 0.6 Then ' are the regions likely to be well aligned
                    DoneThis(0, x) = 1: DoneThis(1, x) = 1
                End If
            End If
            If PermValidSmall(0, x) > 0 And PermValidSmall(1, x) > 0 And PermValidSmall(2, x) > 0 Then
                If PermDiffsSmall(0, x) / PermValidSmall(0, x) > 0.6 Or PermDiffsSmall(1, x) / PermValidSmall(1, x) > 0.6 Or PermDiffsSmall(2, x) / PermValidSmall(2, x) > 0.6 Then
                    DoneThis(0, x) = 1: DoneThis(1, x) = 1
                End If
            End If
        End If
    Next x
   
   x = x
    
    
    For x = 0 To 1
        For Y = x + 1 To 2
            If FAMatSmall(x, ISeqs(Y)) < MinDist(0) Then
                MinDist(0) = FAMatSmall(x, ISeqs(Y))
                MinPair(0) = Z
                SeqPair(0) = x
                SeqPair(1) = Y
                SeqPair(2) = Outlyer(Z)
            End If
            If SAMatSmall(x, ISeqs(Y)) < MinDist(1) Then
                MinDist(1) = SAMatSmall(x, ISeqs(Y))
                MinPair(1) = Z
            End If
            Z = Z + 1
        Next Y
    Next x
    
'    Open "progress.txt" For Append As #20
'        Print #20, SEventNumber, "findrecomb"
'        Close #20
    'Needs FMat and SMat
    If PermNextno > MemPoc Then
        GetFMat
        GetSMat
    End If
    Call MakeSSDistB(ISeqs(), SSDist(), FAMatSmall(), FMat(), SMat(), NextNo, DoneThis())
    
    'Phylpro correlation check - this uses all sites and not just variable sites
    'I must see if a variable sites version will work better
    ReDim PhPrScore(2)
    
    Dummy = MakePhPrScore(NextNo, TmF, TraceInvolvedBak(0), DoneThis(0, 0), ISeqs(0), PhPrScore(0), FMat(0, 0), SMat(0, 0), tPhPrScore(0), SubPhPrScore(0), SubScore(0))
    
    ReDim PhPrScore2(2), tPhPrScore2(2), SubScore2(3), SubPhPrScore2(2)
    If PermNextno > MemPoc Then
        ReDim FMat(0, 0)
        ReDim SMat(0, 0)
        Call GetSAMat
        Call GetFAMat
    End If
    
    'Call PhylProChecks(NextNo, SubPhPrScore2(), SubScore2(), PhPrScore2(), SubValid(), SubDiffs(), PermValid(), PermDiffs(), FAMat(), SAMat(), FAMat(), SAMat(), Iseqs())
    Dummy = MakePhPrScore(NextNo, TmF, TraceInvolvedBak(0), DoneThis(0, 0), ISeqs(0), PhPrScore2(0), FAMat(0, 0), SAMat(0, 0), tPhPrScore2(0), SubPhPrScore2(0), SubScore2(0))
    
    If PermNextno > MemPoc Then
        ReDim SAMat(0, 0)
        ReDim FAMat(0, 0)
        GetSCMat
        GetFCMat
    End If
    ReDim PhPrScore3(2), tPhPrScore3(2), SubScore3(3), SubPhPrScore3(2), DoneThis(1, NextNo)
    If DebuggingFlag < 2 Then On Error Resume Next
        UB = 0
        UB = UBound(SCMat, 1)
    On Error GoTo 0
    If UB > 0 Then
        For x = 0 To NextNo
            FCMat(x, x) = 0
            SCMat(x, x) = 0
            
        Next x
    
        'Dummy = MakeDoneThis(Nextno, FMat(0, 0), FCMat(0, 0), SCMat(0, 0), LD(0, 0, 0), DoneThis(0, 0), ISeqs(0))
        Dummy = MakeDoneThis3(NextNo, FMatSmall(0, 0), FMatSmall(0, 0), SMatSmall(0, 0), DoneThis(0, 0), ISeqs(0))
        
'XX = SEventNumber
        For x = 0 To NextNo
            If DoneThis(0, x) = 0 Then
                If SubValid(0, x) > 0 And SubValid(1, x) > 0 And SubValid(2, x) > 0 Then
                    If (SubDiffs(0, x) / SubValid(0, x)) > 0.6 Or SubDiffs(1, x) / SubValid(1, x) > 0.6 Or SubDiffs(2, x) / SubValid(2, x) > 0.6 Then
                        DoneThis(0, x) = 1 '0,2,3,4,6
                        DoneThis(1, x) = 1
                    End If
                End If
                If PermValidSmall(0, x) > 0 And PermValidSmall(1, x) > 0 And PermValidSmall(2, x) > 0 Then
                    If PermDiffsSmall(0, x) / PermValidSmall(0, x) > 0.6 Or PermDiffsSmall(1, x) / PermValidSmall(1, x) > 0.6 Or PermDiffsSmall(2, x) / PermValidSmall(2, x) > 0.6 Then
                        DoneThis(0, x) = 1
                        DoneThis(1, x) = 1
                    End If
                End If
            End If
        Next x
        
        Dummy = MakePhPrScore(NextNo, TmF, TraceInvolvedBak(0), DoneThis(0, 0), ISeqs(0), PhPrScore3(0), FCMat(0, 0), SCMat(0, 0), tPhPrScore3(0), SubPhPrScore3(0), SubScore3(0))
    End If
    
    If PermNextno > MemPoc Then
        ReDim SCMat(0, 0)
        ReDim FCMat(0, 0)
        
    End If
    
    
    
    
    'end make phprscore
    
    'end section3******************************************
    
    'begin section 4**********************************************
    'More direct tree check for recombination
    'test for associations that have changed between the
    'famat and samat matrices for the sequence triplet in question
                
    'go down tree from closest to furthest away for each of the seqs
    '-Scores for all seqs on all branches of FAMat are averaged over the whole
    'branch
      
   'uses famatsmall and samatsmall
   '&
   For x = 0 To 2
                    
        ReDim DoneOne(NextNo), GroupSeq(NextNo), NuminGroup(NextNo)
        TrpScore(x) = 0
        'Dummy = MakeTrpGroups(x, NextNo, NumInGroup(0), CompMat(0, 0), ISeqs(0), DoneOne(0), GroupSeq(0), MinDistZ(0), FAMat(0, 0))
        Dummy = MakeTrpGroups2(x, NextNo, NuminGroup(0), CompMat(0, 0), ISeqs(0), DoneOne(0), GroupSeq(0), MinDistZ(0), FAMatSmall(0, 0))
                
        'Dummy = MakeTrpScore(x, NextNo, FAMat(0, 0), SAMat(0, 0), TrpScore(0), NumInGroup(0), ISeqs(0), GroupSeq(0))
        Dummy = MakeTrpScore2(x, NextNo, FAMatSmall(0, 0), SAMatSmall(0, 0), TrpScore(0), NuminGroup(0), ISeqs(0), GroupSeq(0))
                    
        
    Next x
    
    
    'end section 4*************************************
    '0.110 5k perms
    '(1) find NO, PI and NI
    Call MakeINList(INList(), OUList(), MinPair())
        
    
    'begin section 5 ***************************************************
    'begin section 5.1 ***************************************************
    
    
    'Check for similar ddetected events with other sequences
    'do this first by looking accross each of the breakpoints and looking
    'for correlation between a potential recombinant sequenence and other sequences
    '(1) Each breakpoint is tested independantly using a simple distance scan
    'of sequences spanning the breakpoint
    '(2) Existing evidence of recombination is scanned for potential "co-recombinants"
    'identified in (1)
    
    '(1) independant testing of bps
    
    'Find VSN vriable sites on either side of two breakpoints
    
    tSN = 0: VSN = 60 '(XOverWindowX * 3) + mcwin
    
    Dummy = MakeBPosLR(VSN, tSN, Len(StrainSeq(0)), BPos, Epos, SeqNum(0, 0), ISeqs(0), BPosLR(0), AVSN(0))
    
    'end section 5.1 ****************************************************************
    '1.432 5K perms
    '0.040
    
    'begin section 5.2 ****************************************************************
    ReDim tRCorr(2, 2, 4, NextNo), InvS(2, NextNo), RCorr(2, 2, NextNo), RInv(2, 2, NextNo)
    'RInv is used to collect information on the polarity of the correlation - ie
    'whether, if you switch the parent groups in the triplet correlation scan across
    'the breakpoints you get a correlation or not
    
    
    SP(0) = BPosLR(0): EP(0) = BPos - 1
    SP(1) = BPos: EP(1) = BPosLR(1)
    SP(2) = BPosLR(2): EP(2) = Epos
    SP(3) = Epos + 1: EP(3) = BPosLR(3)
    SP(4) = BPos: EP(4) = Epos
    For x = 0 To 3
        If SP(x) > Len(StrainSeq(0)) Then
            SP(x) = SP(x) - Len(StrainSeq(0))
        ElseIf SP(x) < 1 Then
            SP(x) = SP(x) + Len(StrainSeq(0))
        End If
            
        If EP(x) > Len(StrainSeq(0)) Then
            EP(x) = EP(x) - Len(StrainSeq(0))
        ElseIf EP(x) < 1 Then
            EP(x) = EP(x) + Len(StrainSeq(0))
        End If
    Next x
    
    ReDim RCorrWarn(2)
  
   
    Call MakeProperRCorr(INList(), MissingData(), RCorrWarn(), RInv(), tRCorr(), RCorr(), CompMat(), Len(StrainSeq(0)), ISeqs(), SP(), EP(), SeqNum())
    If RCorrWarn(0) = 1 And RCorrWarn(1) = 1 Then RCorrWarn(2) = 0
   
    Call MakeDMatS(NextNo, SP(), EP(), SeqNum(), DMatS(), ISeqs())
    'check for possible rcorr problems
    
    'If X = X Then
        For x = 0 To 3
        
            TotD = DMatS(x, 0, ISeqs(1)) + DMatS(x, 0, ISeqs(2)) + DMatS(x, 2, ISeqs(1))
            If TotD > 0 Then
                TotD = 2 / TotD
                If (1 - DMatS(x, 0, ISeqs(1)) * TotD) < 0.4 And (1 - DMatS(x, 0, ISeqs(2)) * TotD) < 0.4 And (1 - DMatS(x, 2, ISeqs(1)) * TotD) < 0.4 Then
                    If x < 2 Then
                        RCorrWarn(0) = 1
                    Else
                        RCorrWarn(1) = 1
                    End If
                End If
            Else
                TotD = 0
                If x < 2 Then
                    RCorrWarn(0) = 1
                Else
                    RCorrWarn(1) = 1
                End If
                'make a warning
            End If
        Next x
        If RCorrWarn(0) = 1 And RCorrWarn(1) = 1 Then
            RCorrWarn(2) = 0
        ElseIf RCorrWarn(0) = 1 Or RCorrWarn(1) = 1 Then
            RCorrWarn(2) = 1
        End If
    'End If
    
   
    
    'Find out how many steps needed if each of Iseqs were recombinant and
    'put into rcompat.
    'Do this by
    '(1) collecting all R values greater that 0.83 (r2 = 0.7)
    '(on either side of bp)
    '(2) finding most distant common ancestor of the group.
    '(3) Find offspring of the MRCA
    '(4) subtract potential recombinants from the offspring group
    '(5) go through the recombinant group and count the number of distance
    'categories between each recombinant and non-recombinants: rcompat = the
    'highest number of categories.
    
    'begin section 6 ***************************************************************
    'begin section 6.1 ***************************************************************
    
   
    'ss = Abs(GetTickCount)
    'For i = 0 To 5000
    ReDim GoodC(NextNo, 1)
    ReDim InPenX(2), InPen(2)
    ReDim NRList(2, NextNo)
    ReDim oRNum(2), NRNum2(2), NRNum(2), RNum(2)
    ReDim NRList2(2, NextNo)
    ReDim RLScore(2, NextNo)
    ReDim RListX(2, NextNo, 9)
    ReDim RNumX(2, 9)
    ReDim InvListX(2, NextNo)
    ReDim RList(2, NextNo)
    ReDim InvList(2, NextNo)
    ReDim TVal(2, NextNo, 2)
    ReDim TPVal(2, NextNo, 2)
    ReDim PScores(2, NextNo, 2)
    ReDim TotP(2, NextNo, 1)
    
    'Find valid comparisons - anything with 10 or more overlapping nts is valid
    Dummy = MakeGoodC(NextNo, Len(StrainSeq(0)), GoodC(0, 0), BPosLR(0), SeqNum(0, 0))
    
    
    

   
   ' XX = GoodC(11, 0): XX = GoodC(11, 1)

    '10.615 5K perms
    '0.187 5K perms
    
   
    'TotPTarget = 1
    'I must port this to C++ when I'm done debugging
    

    'Take another look at ssdist
    '@
    Dim OUIndexA(2) As Byte
    If SSDist(INList(0)) > SSDist(INList(1)) And SSDist(INList(0)) > SSDist(INList(2)) Then
        OUIndexA(INList(0)) = 1: OUIndexA(INList(1)) = 0: OUIndexA(INList(2)) = 0
    ElseIf SSDist(INList(0)) < SSDist(INList(1)) And SSDist(INList(0)) < SSDist(INList(2)) Then
        OUIndexA(INList(0)) = 0: OUIndexA(INList(1)) = 1: OUIndexA(INList(2)) = 1
    Else
        OUIndexA(INList(0)) = 0: OUIndexA(INList(1)) = 0: OUIndexA(INList(2)) = 0
    End If
    Dim AcceptableCoR() As Byte
   
    ReDim AcceptableCoR(2, NextNo)
    For x = 0 To NextNo
       
        If FAMatSmall(INList(0), x) < FAMatSmall(INList(2), ISeqs(INList(0))) Or SAMatSmall(INList(1), x) < SAMatSmall(INList(1), ISeqs(INList(0))) Then
            AcceptableCoR(INList(0), x) = 1 '0,1,2,3,4,9,10,11,12,13,14,16,18,19
            AcceptableCoR(INList(1), x) = 1
        End If
        
        If FAMatSmall(INList(2), x) < FAMatSmall(INList(2), ISeqs(INList(0))) Or SAMatSmall(INList(2), x) < SAMatSmall(INList(2), ISeqs(INList(0))) Then
            AcceptableCoR(INList(2), x) = 1 '0,1,2,3,12,13,15,18,19
        End If
    Next x
    
    'This doesnt do anything exept redimention the dontredo array
    ReDim DontRedo(2, NextNo)
    'Call MakeDontRedo(Nextno, ISeqs(), RList(), RNum(), FAMatSmall(), SAMatSmall(), INList(), RCorr(), DontRedo())

    'with makedontredo being meaningless so too is this little loop
    For x = 0 To 2
    '5,1,5
        'RNumX(X) = RNum(X)
        For Y = 0 To RNum(x)
        
            For Z = 0 To 9
                RListX(x, Y, Z) = RList(x, Y)
            Next Z
        Next Y
    Next x
    
    
    'XX = RInv(0, 1, 17)

    Dummy = MakeRList(NextNo, GoodC(0, 0), ISeqs(0), RListX(0, 0, 0), InvListX(0, 0), RNumX(0, 0), RList(0, 0), InvList(0, 0), RNum(0), RInv(0, 0, 0), RCorr(0, 0, 0), PScores(0, 0, 0), TPVal(0, 0, 0), TVal(0, 0, 0), TotP(0, 0, 0), RLScore(0, 0), DontRedo(0, 0), AcceptableCoR(0, 0), RCorrWarn(0))
    
    
   
       
   
    oRNumX(0) = RNum(0) '200
    oRNumX(1) = RNum(1) '55
    oRNumX(2) = RNum(2) '129
    
    ReDim OKSeq(2, 18, NextNo)

    'if there are contradictions go with the no inversion option.

    For Y = 0 To 2
        For x = 0 To RNum(Y) '14
        
            If InvList(Y, x) = 1 Then
                For Z = 0 To 2
                    If RCorr(Y, Z, RList(Y, x)) > 0.83 And RInv(Y, Z, RList(Y, x)) = 0 Then
                        InvList(Y, x) = 0 '4,0,3:1,0,3:
                        For A = 0 To 2
                            If RInv(Y, A, RList(Y, x)) > 0 Then
                            'the syntax here is strange - this may have been a
                                RCorr(Y, A, RList(Y, x)) = 0 And RInv(Y, A, RList(Y, x)) = 0
                            End If
                        Next A
                    End If
                Next Z
            End If
        Next x
    Next Y
    
    'OKseq 4 is the correlation
    For x = 0 To 2
        For Y = 0 To RNum(x)
            OKSeq(x, 4, RList(x, Y)) = 1
        Next Y
    Next x
   

    Call AddOK1(PermNextno, DontRedo(), RCorr(), RList(), RNum(), OKSeq(), TPVal(), RInv())
    
    
    If MinPair(0) <> MinPair(1) Then
        
        
        
        'Make ListCorr
        'this is where I compare rcorrs and rinvs for evidence that each of the iseqs is recombinant
        '(1) find NO, PI and NI
        '(2) find expected lists for NO, PI and NI: NO=0, PI=1, NI=2
        '(3) for each rcor (left, right and middle or 0,1,2) work out which list fits the observed
        'correlations best
        
        

        Call MakeOUCheck(NextNo, ISeqs(), MinPair(), INList(), FAMatSmall(), SAMatSmall(), OuCheck())
        'Call MakeOUCheck(NextNo, ISeqs(), MinPair(), INList(), FCMat(), SCMat(), OuCheckB(), OuCheck2B(), OuCheck3B())
        
         '(2) find expected lists for NO, PI and NI: NO=0, PI=1, NI=2
         Dim EList() As Integer
         ReDim EList(2, 2, NextNo)
         Call MakeEList(NextNo, EList(), ISeqs(), INList(), SAMatSmall(), FAMatSmall())

         
         '(3) for each rcor (left, right and middle or 0,1,2) work out which list fits the observed
         'correlations best
         'first build AcList
         ReDim AcList(2, 2, NextNo)
         'note that the 2nd dimention here refers to the beginning, end and middle
         'recombinant region
        
         ReDim ListCorr3(2), ListCorr2(2), ListCorr(2), tListCorr(2, 2)
          
         Call MakeListCorr(ISeqs(), INList(), EList(), tRCorr(), RNum(), RList(), RInv(), AcList(), ListCorr3(), ListCorr2(), ListCorr(), tListCorr(), RCorrWarn())
         'Call MakeListCorr(ISeqs(), INList(), EList(), tRCorr(), RNum(), RList(), RInv(), AcList(), ListCorr3(), ListCorr2(), ListCorr(), tListCorr())
         Erase EList
    Else
        ReDim ListCorr3(2), ListCorr2(2), ListCorr(2), tListCorr(2, 2)
        ReDim OuCheck(2)

    
    End If
    
                   
    For x = 0 To 2
        For Y = 0 To RNum(x)
            If InvList(x, Y) = 1 Then
                InvS(x, RList(x, Y)) = 1 '13:1
            End If
        Next Y
    Next x
    
    
    'end of section 6.1******************************************************
    
    'Set up array for region overlap
    
    ReDim Relevant(NextNo)
    Dummy = MakeRelevant(NextNo, Relevant(0), RNum(0), RList(0, 0))
     
    Dim BMatch() As Single, BPMatch() As Long
    ReDim BMatch(2, NextNo), BPMatch(2, 1, NextNo)
    'BMatch(0) = 0: BMatch(1) = 0: BMatch(2) = 0
    '1.412
    ReDim SQ(3), UNF(2, NextNo)
    
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'This part may be a nightmare for big datasets
    'Needs to use pervalid, distance and treedistance arrays - these may need to be setup
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
       'only do this if there was a proper balanced search for recombination
        
    ReDim OLSeq(Len(StrainSeq(0))), OLSeqB(Len(StrainSeq(0))), OLSeqE(Len(StrainSeq(0)))
    Dummy = MakeOLSeq(Len(StrainSeq(0)), SP(0), EP(1), RSize(2), OLSeqB(0))
    Dummy = MakeOLSeq(Len(StrainSeq(0)), SP(2), EP(3), RSize(4), OLSeqE(0))
    Dummy = MakeOLSeq(Len(StrainSeq(0)), BPos, Epos, RSize(0), OLSeq(0))
  
    
    
    If IndividualA = -1 And BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 And ExRecFlag <> 203 Then
        If RedoListSize > 0 Then  'Need to see if any events in redolist need to be repeated
            
            ReDim CurrentXOver(NextNo), MaxXOP(AddNum - 1, NextNo)
            Call ResetMaxPVCO(NextNo)
            Call SignalCount(PXOList(), PCurrentXover())
            TT = Abs(GetTickCount)
            If Abs(TT - GlobalTimer) > 500 Then
                GlobalTimer = TT
                Call UpdateRecNums(SEventNumber)
            End If
            
            For x = 0 To UBound(Relevant2, 2)
                Relevant2(0, x) = 0: Relevant2(1, x) = 0: Relevant2(2, x) = 0
            Next x
            For x = 0 To 2
                For Y = 0 To RNum(x)
                    Relevant2(x, RList(x, Y)) = 1
                Next Y
            Next x
            x = RedoListSize
            
            SLS = RedoListSize
            
            If PermNextno > MemPoc Then
                GetPermValid
                GetPermDiffs
            End If
            ReDim SubSeq(Len(StrainSeq(0)), 6)
            
            
            Do While x >= 0
'                If MCCorrection > MaxAnalNo Then
'                    For Dummy = X To 0 Step -1
'                        Seq1 = AnalysisList(0, Dummy)
'                        Seq2 = AnalysisList(1, Dummy)
'                        Seq3 = AnalysisList(2, Dummy)
'                        For X = 0 To RNum(WinPP)
'                            If Seq1 = RList(WinPP, X) Or Seq2 = RList(WinPP, X) Or Seq3 = RList(WinPP, X) Then Exit For
'                        Next X
'                    Next Dummy
'                Else\
                    '@
                    Dummy = FindNextRedo(x, Relevant2(0, 0), RedoList(0, 0), ISeqs(0), Relevant(0))
                    If Dummy > 0 Then
                        Seq1 = RedoList(1, x): Seq2 = RedoList(2, x): Seq3 = RedoList(3, x)
                    End If
'                End If
                If Dummy > 0 Then
                    x = Dummy
                    
                    If Seq1 <= UBound(PermValid, 2) And Seq2 <= UBound(PermValid, 2) And Seq3 <= UBound(PermValid, 2) Then
                    If PermValid(Seq1, Seq2) > MinSeqSize And PermValid(Seq1, Seq3) > MinSeqSize And PermValid(Seq2, Seq3) > MinSeqSize Then
                        'If SubValid(Seq1, Seq2) > 20 And SubValid(Seq1, Seq3) > 20 And SubValid(Seq2, Seq3) > 20 Then
                            If Seq1 <= NextNo And Seq2 <= NextNo And Seq3 <= NextNo Then
                                 
                                If RedoList(0, x) = 0 Then
                                                
                                    Call XOver(Distance(), XPosDiff(), XDiffPos(), CurrentXOver(), XoverList(), SeqNum(), Seq1, Seq2, Seq3, 0)
                                     x = x
                                ElseIf RedoList(0, x) = 1 Then
                                    Call GCXoverD(0)
                                ElseIf RedoList(0, x) = 2 Then
                                    'Call BSXoverS(BackUpNextno, Seq1, Seq2, Seq3, TraceSub(), MissingData())
                                ElseIf RedoList(0, x) = 3 Then
                                    Call MCXoverF(0, 0, 0)
                                    'x = x
                                ElseIf RedoList(0, x) = 4 Then
                                    tSeq1 = Seq1: tSeq2 = Seq2: tSeq3 = Seq3
                                                                
                                    Call CXoverA(0, 0, 0)
                                                                
                                    Seq1 = tSeq2: Seq2 = tSeq3: Seq3 = tSeq1
                                                                
                                    Call CXoverA(0, 0, 0)
                                                                
                                    Seq1 = tSeq3: Seq2 = tSeq1: Seq3 = tSeq2
                                                                
                                    Call CXoverA(0, 0, 0)
                                                                
                                    Seq1 = tSeq1: Seq2 = tSeq2: Seq3 = tSeq3
                                ElseIf RedoList(0, x) = 5 Then
                                    oSeq1 = Seq1: oSeq2 = Seq2: oSeq3 = Seq3
                                    Call SSXoverC(CLng(0), CLng(WinNum), SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), TraceSub(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP())
                                    Seq1 = oSeq1: Seq2 = oSeq2: Seq3 = oSeq3
                                ElseIf RedoList(0, x) = 6 Then
                                
                                End If
                               
                                
                            End If
                        'End If
                    End If
                    End If
                    If x >= 0 Then
                        RedoList(0, x) = -1
                    End If
                Else
                    Exit Do
                End If
                x = x - 1
                TT = Abs(GetTickCount)
                If Abs(TT - LT) > 500 Then
                
                    LT = TT
                    Form1.SSPanel1.Caption = Trim(Str(SLS - x)) & " of " & Trim(Str(SLS + 1)) & " triplets reexamined"
                    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
                    If CurrentlyRunningFlag = 1 Then
                        DoEvents
                    End If
                    If AbortFlag = 1 Then
                        Exit Do
                    End If
                End If
                
            Loop
            
            
            
            
            'totsilly = 0
            If PermNextno > MemPoc Then
                ReDim PermValid(0, 0)
                ReDim PermDIffs(0, 0)
            End If
'            TT = Abs(GetTickCount)
'            If TT - GlobalTimer > 500 Then
'                  GlobalTimer = TT
'                Form1.SSPanel1.Caption = Trim(Str(SLS + 1)) & " of " & Trim(Str(SLS + 1)) & " triplets reexamined"
'
'                If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'            End If
            'Form1.Refresh
            
            'clean up redolist
            
            Dummy = CleanRedoList(RedoListSize, RedoList(0, 0))
            
            
            'Add new events to pxolist
            Call CopyXOLists(XOSize, DoneSeq(), TempXOList(), PXOList(), PCurrentXover(), XoverList(), CurrentXOver(), NumRecsI())
            '$
            ReDim XoverList(UBound(XoverList, 1), 0)

            Call SignalCount(PXOList(), PCurrentXover())
            TT = Abs(GetTickCount)
            If Abs(TT - GlobalTimer) > 500 Then
                GlobalTimer = TT
                Call UpdateRecNums(SEventNumber)
            End If
           
            'Erase NumSeq
            'Erase Iseq4
        End If
        
      
    
        Call FindActualEventsVB(RLScore(), UNF(), InvList(), NextNo, RSize(), BPMatch(), BMatch(), OKSeq(), FoundOne(), SP(), EP(), RCorr(), OLSeq(), OLSeqB(), OLSeqE(), CSeq(), RNum(), RList(), InvS(), tMatch(), PXOList(), PCurrentXover(), SQ(), tDon(), ISeqs(), CompMat())
    
        
    ElseIf BusyWithExcludes = 0 Or Len(StrainSeq(0)) >= 100000 Then
        For x = 0 To 2
            For Y = 0 To RNum(x)
                UNF(x, Y) = 1
            Next Y
        Next x
    
    End If
     
     
    gtx2 = GetTickCount
    TT = gtx2 - gtxsilly
    totsilly = totsilly + TT
    
    stxxsilly3 = GetTickCount
     
     
    ReDim RList2(2, NextNo), RNum2(2)
    
       
    Call FindSets(TraceSub(), OKSeq(), SetTot(), NextNo, BPos, Epos, ISeqs(), RList2(), RNum2(), PXOList(), PCurrentXover())
    
    Dummy = StripDupInv(NextNo, RCorr(0, 0, 0), RLScore(0, 0), InPen(0), RNum(0), RList(0, 0), InvList(0, 0))
    
   
    Dim RCompat2(2) As Long, RCompatB2(2) As Long, RCompat3(2) As Long, RCompatB3(2) As Long, RCompat4(2) As Long, RCompatB4(2) As Long
    Dim RCompatS(2) As Long, RCompatBS(2) As Long, RCompatS2(2) As Long, RCompatBS2(2) As Long, RCompatS3(2) As Long, RCompatBS3(2) As Long, RCompatS4(2) As Long, RCompatBS4(2) As Long
    

   SSSS = Abs(GetTickCount)
   For WinPP = 0 To 2
        
        RCompat(WinPP) = 0: RCompatB(WinPP) = 0: RCompat2(WinPP) = 0: RCompatB2(WinPP) = 0
        RCompat3(WinPP) = 0: RCompatB3(WinPP) = 0: RCompat4(WinPP) = 0: RCompatB4(WinPP) = 0
        
        RCompatS(WinPP) = 0: RCompatBS(WinPP) = 0: RCompatS2(WinPP) = 0: RCompatBS2(WinPP) = 0
        RCompatS3(WinPP) = 0: RCompatBS3(WinPP) = 0: RCompatS4(WinPP) = 0: RCompatBS4(WinPP) = 0
    Next WinPP
    
    
    'this finds the root node of all the sequences in Rlist
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'It requires FAMat and SAMat - wont work with famatsmall or samatsmall
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'FAMat
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    
    If PermNextno > MemPoc Then
        Call GetFAMat
    End If
    Dummy = MakeLDist(NextNo, LDist(0), FAMat(0, 0), RNum(0), RList(0, 0))
   
    For WinPP = 0 To 2
        ReDim DoneX(NextNo), RCats(NextNo * 3)
        'makercmpat Requires SAMat and FAMat - wont work with SAMatSmall or FAMatsmall
        'XX = UBound(RCompatB, 1)
        Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat(0), RCompatB(0), InPen(0), RCats(0), RNum(0), NRNum(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList(0, 0), FAMat(0, 0), LDist(0))
    Next WinPP
     
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'SAMat
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If PermNextno > MemPoc Then
        ReDim FAMat(0, 0)
        Call GetSAMat
    End If
    
    Dummy = MakeLDist(NextNo, LDist3(0), SAMat(0, 0), RNum(0), RList(0, 0))
    For WinPP = 0 To 2
        ReDim DoneX(NextNo), RCats(NextNo * 3)
        'Using SMat
        ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
        '&
        Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS(0), RCompatBS(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), SAMat(0, 0), LDist3(0))
    Next WinPP
    If PermNextno > MemPoc Then
        ReDim SAMat(0, 0)
    End If
    
    If RCompat(0) <> RCompat(1) Or RCompat(0) <> RCompat(2) Then
        
    Else 'only bother moving on with looking for sequence set with fewest SPR moves if there is a tie using famat
        If NextNo > 2 Then
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'FCMat
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            
            If PermNextno > MemPoc Then
                GetFCMat
            End If
    
            If DebuggingFlag < 2 Then On Error Resume Next
                UB = 0
                UB = UBound(FCMat, 1)
            On Error GoTo 0
            
            If UB > 0 Then
                Dummy = MakeLDist(NextNo, LDist2(0), FCMat(0, 0), RNum(0), RList(0, 0))
                
                For WinPP = 0 To 2
                    ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                    Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat2(0), RCompatB2(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), FCMat(0, 0), LDist2(0))
                Next WinPP
            End If
            If PermNextno > MemPoc Then
                ReDim FCMat(0, 0)
            End If
    
        End If
        
        If RCompat2(0) <> RCompat2(1) Or RCompat2(0) <> RCompat2(2) Then
        Else
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'FAMat (again but with a different rlist this time)
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            If PermNextno > MemPoc Then
                Call GetFAMat
            End If
            
            Dummy = MakeLDist(NextNo, LDistB(0), FAMat(0, 0), RNum2(0), RList2(0, 0))
            
            For WinPP = 0 To 2
                'setsRcompat with non-BS tree
                ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat3(0), RCompatB3(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), FAMat(0, 0), LDistB(0))
            Next WinPP
            If PermNextno > MemPoc Then
                ReDim FAMat(0, 0)
            End If
            If RCompat3(0) <> RCompat3(1) Or RCompat3(0) <> RCompat3(2) Then
            Else
                If NextNo > 2 Then
                    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                    'FCMat (again but with a different rlist this time)
                    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                    If PermNextno > MemPoc Then
                        GetFCMat
                       
                    End If
    
                    If DebuggingFlag < 2 Then On Error Resume Next
                        UB = 0
                        UB = UBound(FCMat, 1)
                    On Error GoTo 0
                    If UB > 0 Then
                        Dummy = MakeLDist(NextNo, LDistB2(0), FCMat(0, 0), RNum2(0), RList2(0, 0))
                        For WinPP = 0 To 2
                            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompat4(0), RCompatB4(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), FCMat(0, 0), LDistB2(0))
                        Next WinPP
                    End If
                    If PermNextno > MemPoc Then
                        ReDim FCMat(0, 0)
                    End If
    
                End If
            End If
        End If
    End If
    
    If RCompatS(0) <> RCompatS(1) Or RCompatS(0) <> RCompatS(2) Then
    
    Else 'only bother moving on with looking for sequence set with fewest SPR moves if there is a tie using samat
        
    
        If NextNo > 2 Then
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'SCMat (again but with a different rlist this time)
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            If PermNextno > MemPoc Then
                GetSCMat
            End If
            If DebuggingFlag < 2 Then On Error Resume Next
                UB = 0
                UB = UBound(SCMat, 1)
            On Error GoTo 0
            If UB > 0 Then
                Dummy = MakeLDist(NextNo, LDist4(0), SCMat(0, 0), RNum(0), RList(0, 0))
                For WinPP = 0 To 2
                    'normal rcompats with BS tree
                    ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                    Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS2(0), RCompatBS2(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), SCMat(0, 0), LDist4(0))
                Next WinPP
            End If
            If PermNextno > MemPoc Then
                ReDim SCMat(0, 0)
            End If
        End If
        If RCompatS2(0) <> RCompatS2(1) Or RCompatS2(0) <> RCompatS2(2) Then
        Else
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'SAMat (again but with a different rlist this time)
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            If PermNextno > MemPoc Then
                Call GetSAMat
            End If
            Dummy = MakeLDist(NextNo, LDistB3(0), SAMat(0, 0), RNum2(0), RList2(0, 0))
            For WinPP = 0 To 2
                'setsrcompats with non-BS tree
                ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS3(0), RCompatBS3(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), SAMat(0, 0), LDistB3(0))
            Next WinPP
             If PermNextno > MemPoc Then
                ReDim SAMat(0, 0)
            End If
            If RCompatS3(0) <> RCompatS3(1) Or RCompatS3(0) <> RCompatS3(2) Then
            Else
                If NextNo > 2 Then
                    If PermNextno > MemPoc Then
                        GetSCMat
                    End If
                    If DebuggingFlag < 2 Then On Error Resume Next
                        UB = 0
                        UB = UBound(SCMat, 1)
                    On Error GoTo 0
                    If UB > 0 Then
                        Dummy = MakeLDist(NextNo, LDistB4(0), SCMat(0, 0), RNum2(0), RList2(0, 0))
                        'setsrcompats with BS tree
                        For WinPP = 0 To 2
                            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
                            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatS4(0), RCompatBS4(0), InPen(0), RCats(0), RNum2(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList2(0, 0), NRList2(0, 0), SCMat(0, 0), LDistB4(0))
                        Next WinPP
                    End If
                    If PermNextno > MemPoc Then
                        ReDim SCMat(0, 0)
                    End If
                End If
            End If
        End If
    End If
    
    
    'Clean up rlistx
'    Dim FEntry() As Byte
  
    
'    For x = 0 To 2
'    'XX = ISeqs(0)
'        ReDim FEntry(NextNo)
'        For Y = 0 To RNum(x)
'            FEntry(RList(x, Y)) = 1
'        Next Y
'        For Y = 1 To 9 'ie leave 0 alone
'            Z = 0
'            Do While Z <= RNumX(x, Y)
'                If FEntry(RListX(x, Z, Y)) = 0 Then
'                    If Z < RNumX(x, Y) Then
'                        RListX(x, Z, Y) = RListX(x, RNumX(x, Y), Y)
'                    End If
'                    RNumX(x, Y) = RNumX(x, Y) - 1
'                Else
'                    Z = Z + 1
'                End If
'            Loop
'
'        Next Y
'    Next x
    
'    Dim txLDist(2) As Double, txRNum(2) As Long, txRList() As Long
'    ReDim txRList(2, NextNo)
'    If PermNextno > MemPoc Then
'        Call GetFAMat
'        Call GetSAMat
'    End If
    
'    SS = abs(gettickcount)
'    For x = 0 To 9
''        For WinPP = 0 To 2
''             RCompatXS(WinPP) = 0:  RCompatBXS(WinPP) = 0
''        Next WinPP
'
'        txLDist(0) = 0: txLDist(1) = 0: txLDist(2) = 0
'
'
'        For Y = 0 To 2
'            txRNum(Y) = RNumX(Y, x)
'            For Z = 0 To RNumX(Y, x)
'                txRList(Y, Z) = RListX(Y, Z, x)
'            Next Z
'        Next Y
'        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'        'FAMat (again but with a different rlist this time)
'        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''        Dummy = MakeLDist(NextNo, txLDist(0), FAMat(0, 0), txRNum(0), txRList(0, 0))
''        '@'@'@'@'@'@'@'@'@'@'@'@'@
''        For WinPP = 0 To 2
''            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo), InPenX(2)
''            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatXF(0), RCompatBXF(0), InPenX(0), RCats(0), txRNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), txRList(0, 0), NRList2(0, 0), FAMat(0, 0), txLDist(0))
''        Next WinPP
'
'
'        txLDist(0) = 0: txLDist(1) = 0: txLDist(2) = 0
'        'ReDim txRList(2, Nextno)
'
'        For Y = 0 To 2
'            txRNum(Y) = RNumX(Y, x)
'            For Z = 0 To RNumX(Y, x)
'                txRList(Y, Z) = RListX(Y, Z, x)
'            Next Z
'        Next Y
'        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'        'SAMat (again but with a different rlist this time)
'        ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''        Dummy = MakeLDist(NextNo, txLDist(0), SAMat(0, 0), txRNum(0), txRList(0, 0))
''        For WinPP = 0 To 2
''            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo), InPenX(2)
''            '@'@'@'@'@'@''@'@'@'@'@
''            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), WinPP, NextNo, RCompatXS(0), RCompatBXS(0), InPenX(0), RCats(0), txRNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), txRList(0, 0), NRList2(0, 0), SAMat(0, 0), txLDist(0))
''
''        Next WinPP
'
'        'XX = RNum(2)
'
'    Next x
'       42     seconds Total
'    If PermNextno > MemPoc Then
'        ReDim SAMat(0, 0)
'        ReDim FAMat(0, 0)
'    End If
    'AbortFlag = 1
    
   
    
'    For WinPP = 0 To 2
'         RCompatBXS(WinPP) = 0
'    Next WinPP
    
  
   
    
    ReDim SimScore(2)
    'needs FMat and SMat
    If PermNextno > MemPoc Then
        GetFMat
        GetSMat
    End If
    
    Call SimpleDist(RankF(), NextNo, SimScore(), SimScoreB(), RList(), RNum(), INList(), ISeqs(), FMat(), SMat())
    If PermNextno > MemPoc Then
        ReDim FMat(0, 0)
        ReDim SMat(0, 0)
    End If
    'work out baddists
    Call GetBadDists(NextNo, RCorr(), FAMatSmall(), CompMat(), DMatS(), ISeqs(), BadDists(), UNF(), RList(), RNum())
   
    
    'draw trees with regions centred on the breakpoints
    
    'need to check availability of memory because bpMat can get VERY big
    GlobalMemoryStatus MemSit
    APhys = Abs(MemSit.dwTotalPhys)
    If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
    If ((NextNo + 1) * (NextNo + 1) * 4 * 8) < APhys / 10 And x = 1234567 Then
        If PhylCheck = 1 Then
            Dim BPMat() As Single
            ReDim BPMat(3, NextNo, NextNo)
            'Call MakeBPMatX(Nextno, BPMat(), FMat(), DMatS(), GoodC())
        End If
    Else
        PhylCheck = 0 'phylogenetic evidence will still be used, just not in the proximity of the breakpoints
        If DebuggingFlag < 2 Then On Error Resume Next
        ReDim BPMat(0, 0, 0)
        On Error GoTo 0
    End If
    'X = X
   
    
    ReDim Consensus(2, 3), tDscores(25, 2)
        
    'Call MakeConsensus(TDScores(), Consensus(), INList(), CompMat(), SubScore2(), SubPhPrScore2(), OuCheck2(), OuCheck3(), ListCorr3(), SubScore(), PhPrScore2(), ListCorr(), ListCorr2(), TrpScore(), PhPrScore(), SubPhPrScore(), OuCheck(), BadDists(),  RCompat(), tListCorr())
    
    
    RetrimFlag = 0
    If RCompat(0) > 0 And RCompat(1) > 0 And RCompat(2) > 0 And RCompatS(0) > 0 And RCompatS(1) > 0 And RCompatS(2) > 0 Then
        RetrimFlag = 1
    End If
    For x = 0 To 2
        RCompatC(x) = 0: RCompatD(x) = 0
    Next x
     
  
  
  
  
  
  
  'Start trimming sequences out of Rlist
  
  
    
  
  
  
    Call CheckPattern(OKSeq(), ISeqs(), RList(), SP(), EP(), CompMat(), RNum(), SeqNum(), RInv(), InvList(), RCorrWarn())
     'XX = Nextno
   If DistanceInFileFlag = 1 And PermNextno > MemPoc And x = 1234567 Then
        oDir = CurDir
        ChDir App.Path
        ChDrive App.Path
        
        FF = FreeFile
        'UBDistance = UBound(Distance, 1)
        ReDim Distance(UBDistance, UBDistance)
        Open "RDP5Distance" + UFTag For Binary As #FF
        Get #FF, , Distance()
        Close #FF
        'DistanceInFileFlag = 0
        'Erase Distance
        ChDir oDir
        ChDrive oDir
    End If
    
           
    MissIDFlag = 0
    RFF = 0
     
     
    If RetrimFlag = 1 And ExRecFlag <> 203 Then
        RWinPP = 4
        RFF = 1
        DontDoScansFlag = 0
        
        Call FinalTrim(WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), LowP, 0, WeightMod(), OKSeq(), BMatch(), BPMatch(), MinPair(), INList(), RInv(), BPos, Epos, RWinPP, MissIDFlag, PhylCheck, BackUpNextno, NextNo, CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), XoverList(), CurrentXOver(), PCurrentXover(), PXOList(), MissingData(), TraceSub(), Trace(), DMatS(), CompMat(), BPMat(), RCorrWarn(), UNF(), RCorr(), ISeqs(), FCMatSmall(), SCMatSmall(), FAMatSmall(), SAMatSmall(), NRNum(), NRList(), RNum(), RList())
        'AbortFlag = 1
        If PermNextno > MemPoc Then
            Call GetFAMat
        End If
        For x = 0 To 2
            RCompatB(x) = 0
            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
            'Requires FAMat (wont work with FAmatSmall)
            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), x, NextNo, RCompatC(0), RCompatB(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), FAMat(0, 0), LDist(0))
        'do RCompatC
        Next x
        
        If PermNextno > MemPoc Then
            ReDim FAMat(0, 0)
            Call GetSAMat
        End If
        '@
        For x = 0 To 2
            RCompatB(x) = 0
            ReDim DoneX(NextNo), RCats(NextNo * 3), NRNum2(2), NRList2(2, NextNo)
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'Requires SAMat (wont work with SAmatSmall)
            Dummy = MakeRCompat(ISeqs(0), CompMat(0, 0), x, NextNo, RCompatD(0), RCompatB(0), InPen(0), RCats(0), RNum(0), NRNum2(0), GoodC(0, 0), DoneX(0), RList(0, 0), NRList2(0, 0), SAMat(0, 0), LDist3(0))
        'do RCompatC
        Next x
         If PermNextno > MemPoc Then
            ReDim SAMat(0, 0)
        End If
    End If
    
    
    ''event 55, (15,1), d=86, mi=16, ma = 224
        
    
    
    'after this point FAMat and SAMat might be accesible from disk
    'finally, do visrd dmax
    
    
    Call CalcMaxD(ISeqs(), dMax(), BPos, Epos)
   'x = x
    'Dim ConsensusB() As Double
    'ReDim ConsensusB(2, 2)
    
    'Call MakeConsensusB(RCompatC(), RCompatD(), RCompat2(), RCompat3(), RCompat4(), RCompatS(), RCompatS2(), RCompatS3(), RCompatS4(), SSDist(), OUIndexA(), TDScores(), ConsensusB(), INList(), CompMat(), SubScore2(), SubPhPrScore2(), ListCorr3(), SubScore(), PhPrScore2(), ListCorr(), ListCorr2(), TrpScore(), PhPrScore(), SubPhPrScore(), OuCheck(), BadDists(),  RCompat(), tListCorr())
   
'   If SEventNumber = 13 Then
'
'        For A = 0 To 2
'
'            RCompat(A) = 0: RCompatB(A) = 0: RCompat2(A) = 0: RCompatB2(A) = 0
'            RCompat3(A) = 0: RCompatB3(A) = 0: RCompat4(A) = 0: RCompatB4(A) = 0
'
'            RCompatS(A) = 0: RCompatBS(A) = 0: RCompatS2(A) = 0: RCompatBS2(A) = 0
'            RCompatS3(A) = 0: RCompatBS3(A) = 0: RCompatS4(A) = 0: RCompatBS4(A) = 0
'        Next A
'    End If
   
    
    Call MakeConsensusC(SetTot(), OUList(), RankF(), dMax(), SimScore(), SimScoreB(), PhPrScore3(), RCompatC(), RCompatD(), RCompat2(), RCompat3(), RCompat4(), RCompatS(), RCompatS2(), RCompatS3(), RCompatS4(), SSDist(), OUIndexA(), tDscores(), Consensus(), INList(), CompMat(), SubScore2(), SubPhPrScore2(), ListCorr3(), SubScore(), PhPrScore2(), ListCorr(), ListCorr2(), TrpScore(), PhPrScore(), SubPhPrScore(), OuCheck(), BadDists(), RCompat(), tListCorr())

'************************************************************************************
'uncomment this block if you want the scores printed out
    
'    If X = 12345 Then
'
'        If SEventNumber = 1 Then
'            Open "Scores.csv" For Output As #1
'            Close #1
'        End If
'
'        Open "scores.csv" For Append As #1
'        Write #1, SEventNumber
'        Dim ccon(2) As Byte
'
'        Dim NNumb() As Long
'        ReDim NNumb(2)
'        For A = 0 To 2
'            For C = 1 To Len(OriginalName(ISeqs(A)))
'                NNumb(A) = NNumb(A) + Asc(Mid(OriginalName(ISeqs(A)), C, 1)) * 2 ^ (Len(OriginalName(ISeqs(A))) - C)
'            Next C
'        Next
'
'        'B,A,03:1252,1202,1271
'        'b,03,a:1252,1271,1202
'        If NNumb(0) < NNumb(1) And NNumb(0) < NNumb(2) Then
'            ccon(0) = 0
'            If NNumb(1) < NNumb(2) Then
'                ccon(1) = 1
'                ccon(2) = 2
'            Else
'                ccon(2) = 1
'                ccon(1) = 2
'            End If
'        ElseIf NNumb(1) < NNumb(2) Then
'            ccon(0) = 1
'            If NNumb(0) < NNumb(2) Then
'                ccon(1) = 0
'                ccon(2) = 2
'            Else
'                ccon(2) = 0
'                ccon(1) = 2
'            End If
'
'        Else
'            ccon(0) = 2
'            If NNumb(0) < NNumb(1) Then
'                ccon(1) = 0
'                ccon(2) = 1
'            Else
'                ccon(2) = 0
'                ccon(1) = 1
'            End If
'            X = X
'        End If
'        For A = 0 To 2
'
'            C = ccon(A)
'
'            If PermNextno > 2 Then
'                Write #1, OriginalName(TraceSub(ISeqs(C))), oRNumX(C), RNum(C) + 1, ListCorr(C), NPh, SimScoreB(C), SimScore(C), PhPrScore(C), PhPrScore2(C), PhPrScore3(C), SubScore(C), SSDist(C), OUIndexA(C), SubPhPrScore(C), SubScore2(C), SubPhPrScore2(C), SRCompatF(C), SRCompatS(C), RCompat(C), RCompat2(C), RCompat3(C), RCompat4(C), RCompatS(C), RCompatS2(C), RCompatS3(C), RCompatS4(C), RCompatXF(C), RCompatXS(C), RCompatC(C), RCompatD(C), TrpScore(C), BadDists(C), OUList(C), ListCorr2(C), ListCorr3(C), Consensus(C, 0), Consensus(C, 1), Consensus(C, 2), OuCheck(C), SetTot(0, C), SetTot(1, C)    ', PhPrScore3(C), SubScore3(C), SubPhPrScore3(C),   TrpScore2(C), RCompat2(C) ', SubScore2(C), SubPhPrScore2(C), ListCorr4(C), tListCorr2(C, 0), tListCorr2(C, 1), tListCorr2(C, 2), ListCorr5(C), ListCorr6(C)
'            Else
'                Write #1, OriginalName(TraceSub(ISeqs(C))), RNum(C) + 1, ListCorr(C), NPh, PhPrScore(C), PhPrScore2(C), SubScore(C), SubPhPrScore(C), SubScore2(C), SubPhPrScore2(C), RCompat(C), RCompat2(C), RCompat3(C), RCompat4(C), RCompatS(C), RCompatS2(C), RCompatS3(C), RCompatS4(C), TrpScore(C), BadDists(C), OUList(C), ListCorr2(C), ListCorr3(C), Consensus(C, 0), Consensus(C, 1), Consensus(C, 2), OuCheck(C), SetTot(0, C), SetTot(1, C)   ', PhPrScore3(C), SubScore3(C), SubPhPrScore3(C), OuCheckB(C),  TrpScore2(C), RCompat2(C) ', SubScore2(C), SubPhPrScore2(C), ListCorr4(C), tListCorr2(C, 0), tListCorr2(C, 1), tListCorr2(C, 2), ListCorr5(C), ListCorr6(C)
'            End If
'        Next A
'        Write #1, ""
'
'        Close #1
'    End If
    
'***************************************************************************************************
    
    'Now guestimate which are winpp (ie the whole list if necessary)
    
    
    
        
    'Else
    If ExRecFlag = 203 Then
            WinPP = 0
        
    Else
        If BusyWithExcludes = 1 Then
            
            If PXOList(Trace(0), Trace(1)).BeginP < 0 And PXOList(Trace(0), Trace(1)).EndP >= 0 Then 'if the signal comes from the scan with just one extra then must assume
                                                                                                    'that the includes are less likely recombinant
                                                        
                For x = 0 To 2
                    If ISeqs(x) <= PermNextno Then '= CurSeedExtras Then
                        
                        Consensus(x, 2) = Consensus(x, 2) * 0.7
                    End If
                Next x
                
            End If
        End If
        For x = 0 To 2
            
                If Consensus(x, 2) >= Consensus(CompMat(x, 0), 2) And Consensus(x, 2) >= Consensus(CompMat(x, 1), 2) Then
                    
                    WinPP = x
                    
                End If
            
        Next x
    'End If
    
    
    
        If Consensus(0, 2) = Consensus(1, 2) And Consensus(0, 2) = Consensus(2, 2) Then 'not a clue which is recombinant
            If (PhPrScore(0) <> -1 And PhPrScore(0) <> 1) Or (PhPrScore(1) <> -1 And PhPrScore(1) <> 1) Or (PhPrScore(2) <> -1 And PhPrScore(2) <> 1) Then
                Dim TBreak(2) As Double
                For x = 0 To 2
                    TBreak(x) = PhPrScore(x) - TrpScore(x) + RCompat(x) + RCompatS(x)
                Next x
                If Consensus(WinPP, 2) = Consensus(CompMat(WinPP, 0), 2) And Consensus(WinPP, 2) = Consensus(CompMat(WinPP, 1), 2) Then
                    If TBreak(0) < TBreak(1) And TBreak(0) < TBreak(2) Then
                        WinPP = 0
                    ElseIf TBreak(1) < TBreak(0) And TBreak(1) < TBreak(2) Then
                        WinPP = 1
                    Else
                        WinPP = 2
                    End If
                ElseIf Consensus(WinPP, 2) = Consensus(CompMat(WinPP, 0), 2) Then
                    If TBreak(WinPP) > TBreak(CompMat(WinPP, 0)) Then
                        WinPP = CompMat(WinPP, 0)
                    
                    End If
                ElseIf Consensus(WinPP, 2) = Consensus(CompMat(WinPP, 1), 2) Then
                    If TBreak(WinPP) > TBreak(CompMat(WinPP, 1)) Then
                        WinPP = CompMat(WinPP, 1)
                    
                    End If
                End If
            Else
        
                Call GetWinPPfromDists(WinPP, ISeqs(), FMatSmall(), SMatSmall())
            
            End If
            
        End If
    End If
    'XX = SEventNumber
    'XX = StraiName(ISeqs(2))
    'XX = SigmoidX(WinPP) '13(A),16(B), 18(B), 19(V),20(O)
    If (Consensus(WinPP, 2) / (Consensus(0, 2) + Consensus(1, 2) + Consensus(2, 2))) < 0.6 Then
        MissIDFlag = MissIDFlag + 10
    End If
    
    
    If BusyWithExcludes = 1 Then 'unminus the seed sequence's consensus score
            
        For x = 0 To 2
            If ISeqs(x) <= PermNextno Then '= CurSeedExtras Then
                
                Consensus(x, 2) = Consensus(x, 2) / 0.7
            End If
        Next x
                
            
    End If
    
    'Up till this point the RLists have been used to decide which of the sequences is recombinant
    'The sequences in rlist have been over-grouped.
    'If we are dealing with recombinants of recombinants we will ned up with a lot of sequences in the rlists that do not actually
    'contain eny evidence of the recombination event recorded in the iseqs triplet
    'need to either conservatively or realistically trim sequences from the rlists
    
   ' XX = UBound(PermValid, 1)
    'First check to see if one of the sequences is very poorly aligned with the others
    'free up some files
    
    If DebuggingFlag < 2 Then On Error Resume Next
    FF = FreeFile
    If FF > 1 Then
        For FF = 1 To 200
            Close #FF
        Next FF
    End If
    On Error GoTo 0
    If ExRecFlag <> 203 And ExRecFlag <> 210 Then
        Call QTestAlign(WinPP, LDst(), ISeqs(), PermDiffsSmall(), PermValidSmall(), SubDiffs(), SubValid())
    End If
    AAF = 0
    'MissIDFlag = 0
    Dim DoFT As Long
    DoFT = 0
    If LDst(1) > 0.6 And CPermNo = 0 And x = 12345 Then
        MissIDFlag = MissIDFlag + 3
        For x = 0 To 2
            RNum(x) = 0
            RList(x, 0) = ISeqs(x)
        Next x
        'Call DelSeq(BPos, EPos, ISeqs(WinPP))
        AAF = 1
    Else
        'XX = SEventNumber
        If CPermNo = 0 And (RealignFlag = 1 And Decompress(Len(StrainSeq(0))) = Len(StrainSeq(0))) And LDst(1) > 0.25 And ExRecFlag <> 203 And ExRecFlag <> 210 Then
            If Trace(1) <= UBound(PXOList, 2) Then
                
                Call RAlignAndRecheck(PXOList(Trace(0), Trace(1)).ProgramFlag, SeqNum(), ISeqs(), BPos, Epos, AAF)
                DoEvents
            End If
'            If AAF <> 1 Then
'                zzztX = zzztX + 1
'            Else
'                zzzt = zzzt + 1
'            End If
        End If
        
        If AAF = 1 Then
            
            MissIDFlag = MissIDFlag + 3
            For x = 0 To 2
                RNum(x) = 0
                RList(x, 0) = ISeqs(x)
            Next x
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            If Dir("RDP5ExcludeList" + UFTag) <> "" Then
                DoFT = 1
            End If
            ChDrive oDirX
            ChDir oDirX
         Else
             If LDst(1) > 0.5 Or AAF = 2 Then
                 MissIDFlag = MissIDFlag + 2
                 
             Else
                 MissIDFlag = MissIDFlag + 0
             End If
             
             'find lowest rcompat
            
             
             
        End If
    End If
    
    
     
        
        tWinPP = WinPP
        Dim tListX() As Byte
        ReDim NRList(2, NextNo)
        For WinPP = 0 To 2
        
            
            ReDim tListX(NextNo)
            
            For x = 0 To RNum(WinPP)
                tListX(RList(WinPP, x)) = 1
            Next x
            NRNum(WinPP) = 0
            For x = 0 To NextNo
                If tListX(x) = 0 Then
                    NRList(WinPP, NRNum(WinPP)) = x
                    NRNum(WinPP) = NRNum(WinPP) + 1
                End If
            Next x
            NRNum(WinPP) = NRNum(WinPP) - 1
        Next WinPP
        WinPP = tWinPP
   
    'edit RList to contain only those sequences that are not separated by
    'non-recombinants from the original hit - ie iseqs(winpp)
    'This is probably where the identity check should be included....
    
    
'************* Got to expand NRList to include all sequences not in RList**************
    'AbortFlag = 1
'    Open "progress.txt" For Append As #20
'        Print #20, SEventNumber, "finaltrim"
'        Close #20
'    If SEventNumber = 382 Then
'        XX = RNum(0)
'    End If
     
    If AAF <> 1 Or DoFT = 1 Or ExRecFlag = 203 Then 'need the doft=1 for large datasets with misalignment
        RWinPP = WinPP
        DontDoScansFlag = 0
'        If SEventNumber = 197 Then
'            XX = RNum(1)
'        End If
        Call FinalTrim(WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), LowP, RFF, WeightMod(), OKSeq(), BMatch(), BPMatch(), MinPair(), INList(), RInv(), BPos, Epos, RWinPP, MissIDFlag, PhylCheck, BackUpNextno, NextNo, CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), XoverList(), CurrentXOver(), PCurrentXover(), PXOList(), MissingData(), TraceSub(), Trace(), DMatS(), CompMat(), BPMat(), RCorrWarn(), UNF(), RCorr(), ISeqs(), FCMatSmall(), SCMatSmall(), FAMatSmall(), SAMatSmall(), NRNum(), NRList(), RNum(), RList())
        'Call FinalTrim2(RCorr(), MinPair(), FCMat(), SCMat(), INList(), ISeqs(), RNum(), RList())
        WinPP = RWinPP
    End If
    
    
   'GoTo FAI
     '********************Fails from here********************
    Erase DMatS
    ReDim SCMat(0, 0)
    ReDim FCMat(0, 0)
   
    'Keep a note of which sequences have been used as parents and where
     
     'For X = 0 To RNum(0)
     '   XX = RList(0, X) '19,31,32,33,34,37,38,40,46,47,48,50,52,54,55,56,57,58,59,60,61,62,63,65
     'Next X
    'Call CheckUsedPar(WinPP, SEventNumber, BPos, EPos, Compmat(), UsedPar(), MissingData())
    
    
  ' XX = TraceSub(62)
    
    
    'begin section 7*****************************************************
    'Find events most closely resembling the RList events in PXOList
    '(1) scan for best P-value for events with identical parents and method
    '(2) scan for "worse" events for other methods but with highest P-value
    'For X = 0 To 2
    '    BackRNum2(X) = RNum(X)
    '    For Y = 0 To RNum(X)
    '        BackRlist2(X, Y) = RList(X, Y)
    '    Next Y
    'Next X
    
    
   
    
    Dummy = MakeRelevant(NextNo, Relevant(0), RNum(0), RList(0, 0))
    
    
    
    
    'XX = RNum(2)
    '6.360
    ReDim CollectEvents(NextNo, AddNum), CollectEventsMa(NextNo, AddNum), CollectEventsMi(NextNo, AddNum)
    'XX = ISeqs(CompMat(WinPP, 0))
   'Make sure there is an entry in PXOList for the events in rlist winpp
    Dim PXO2 As Long, PXO3 As Long
    Dim TranSeq As Long
    
    
    For x = 0 To RNum(WinPP)
'        If RList(WinPP, X) = 881 And SEventNumber = 4 Then
'            X = X
'        End If
        
        If RList(WinPP, x) <> ISeqs(WinPP) And OKSeq(WinPP, 18, RList(WinPP, x)) > 1 Then
            PXO2 = RList(WinPP, x)
            If PCurrentXover(PXO2) = UBound(PXOList, 2) Then
                ReDim Preserve PXOList(UBound(PXOList, 1), PCurrentXover(PXO2) + 10)
            End If
            PCurrentXover(PXO2) = PCurrentXover(PXO2) + 1
            PXO3 = PCurrentXover(PXO2)
            PXOList(PXO2, PXO3) = PXOList(Trace(0), Trace(1))
            PXOList(PXO2, PXO3).Probability = 1
            If PXOList(PXO2, PXO3).Daughter = ISeqs(WinPP) Then
                PXOList(PXO2, PXO3).Daughter = PXO2
            ElseIf PXOList(PXO2, PXO3).MajorP = ISeqs(WinPP) Then
                
                PXOList(PXO2, PXO3).MajorP = PXO2
            ElseIf PXOList(PXO2, PXO3).MinorP = ISeqs(WinPP) Then
                PXOList(PXO2, PXO3).MinorP = PXO2
            End If
            
            PXOList(PXO2, PXO3).DHolder = Abs(PXOList(PXO2, PXO3).DHolder)
        End If
    Next x
    QvRRejectFlag = 0
    If QvRFlag = 1 Then
        If ReferenceList(ISeqs(WinPP)) <> 0 Then
            QvRRejectFlag = 1
        End If
'        If ReferenceList(ISeqs(0)) = 0 Then
'            WinPP = 0
'        ElseIf ReferenceList(ISeqs(1)) = 0 Then
'            WinPP = 1
'        ElseIf ReferenceList(ISeqs(2)) = 0 Then
'            WinPP = 2
'        End If
    
        
    End If
    
'    If SEventNumber = 17 Then
'        x = x
'    End If
    If AllowConflict = 0 Or ExRecFlag = 203 Then
        'this forces this event to be the bestevent (it keeps the breakpoint CIs consistent)
        If PXOList(Trace(0), Trace(1)).PermPVal = 0 Then
            PXOList(Trace(0), Trace(1)).PermPVal = -100
        Else
            PXOList(Trace(0), Trace(1)).PermPVal = -PXOList(Trace(0), Trace(1)).PermPVal
        End If
    End If
    'event 55, (15,1), d=86, mi=16, ma = 224
    If AAF <> 1 Then
            Call MakeCollecteventsX(Trace(), SMat(), ISeqs(), LowP, WinPP, Epos, BPos, OLSeq(), RSize(), CompMat(), Relevant(), PCurrentXover(), CollectEvents(), PXOList(), RNum(), RList())

         'Dummy = MakeCollecteventsC(NextNo, Len(StrainSeq(0)), WinPP, RSize(0), OLSeq(0), UBound(CompMat, 1), CompMat(0, 0), UBound(RList, 1), RList(0, 0), RNum(0), AddNum, UBound(SMatSmall, 1), SMatSmall(0, 0), ISeqs(0), Trace(0), PCurrentXOver(0), UBound(PXOList, 1), PXOList(0, 0), UBound(CollectEvents, 1), CollectEvents(0, 0))
         Dummy = MakeCollecteventsC(NextNo, Len(StrainSeq(0)), CompMat(WinPP, 0), RSize(0), OLSeq(0), UBound(CompMat, 1), CompMat(0, 0), UBound(RList, 1), RList(0, 0), RNum(0), AddNum, UBound(SMatSmall, 1), SMatSmall(0, 0), ISeqs(0), Trace(0), PCurrentXover(0), UBound(PXOList, 1), PXOList(0, 0), UBound(CollectEventsMa, 1), CollectEventsMa(0, 0))
         Dummy = MakeCollecteventsC(NextNo, Len(StrainSeq(0)), CompMat(WinPP, 1), RSize(0), OLSeq(0), UBound(CompMat, 1), CompMat(0, 0), UBound(RList, 1), RList(0, 0), RNum(0), AddNum, UBound(SMatSmall, 1), SMatSmall(0, 0), ISeqs(0), Trace(0), PCurrentXover(0), UBound(PXOList, 1), PXOList(0, 0), UBound(CollectEventsMi, 1), CollectEventsMi(0, 0))
       
'        Call MakeCollecteventsX(Trace(), SMat(), ISeqs(), LowP, CompMat(WinPP, 0), Epos, BPos, OLSeq(), RSize(), CompMat(), Relevant(), PCurrentXOver(), CollectEventsMa(), PXOList(), RNum(), RList())
'        Call MakeCollecteventsX(Trace(), SMat(), ISeqs(), LowP, CompMat(WinPP, 1), Epos, BPos, OLSeq(), RSize(), CompMat(), Relevant(), PCurrentXOver(), CollectEventsMi(), PXOList(), RNum(), RList())
       
    Else
        CollectEvents(0, PXOList(Trace(0), Trace(1)).ProgramFlag) = PXOList(Trace(0), Trace(1))
        CollectEventsMa(0, PXOList(Trace(0), Trace(1)).ProgramFlag) = PXOList(Trace(0), Trace(1))
        CollectEventsMi(0, PXOList(Trace(0), Trace(1)).ProgramFlag) = PXOList(Trace(0), Trace(1))
    End If
   ' x = x
    
    
    '55,1
   
     
    'end section 7********************************************
    '4.727 5K perms
    '3.835 using olsize
    '2.864 with relevant
    '2.375 (dsktop)
    '1.750 with maketmatch2
    '1.7641 - taking out unnecessary crap
    '1.062 - with tetsrlist
   ' Next i
    
    'ee = Abs(GetTickCount)
    'tt = ee - ss
    'X = X
    '22.762 10 times more events
    '21.892
    '14.331 with relevant
    '9.109 (dsktop) with testrlist
    
    'begin section 8*****************************************************
    
    If RNum(WinPP) = -1 Then RNum(WinPP) = 0
    If RNum(CompMat(WinPP, 0)) = -1 Then RNum(CompMat(WinPP, 0)) = 0
    If RNum(CompMat(WinPP, 1)) = -1 Then RNum(CompMat(WinPP, 1)) = 0
    ReDim tSeqnum(Len(StrainSeq(0)), RNum(WinPP)), WinnerPos(RNum(WinPP), AddNum), WinnerPosMa(RNum(CompMat(WinPP, 0)), AddNum), WinnerPosMi(RNum(CompMat(WinPP, 1)), AddNum)
    UB1 = UBound(ExtraHits, 1)
    UB2 = UBound(ExtraHitsMa, 1)
    UB3 = UBound(ExtraHitsMi, 1)
    
    
    ReDim Preserve ExtraHits(UB1, SEventNumber), ExtraHitsMa(UB2, SEventNumber), ExtraHitsMi(UB3, SEventNumber)
    
    If ShowPlotFlag = 2 And CLine = "" Then
        
        Dim DistX As Double
        If MissIDFlag = 13 Or MissIDFlag = 3 Then
            Mi = 1
        Else
            Mi = 0
            If Trace(1) <= UBound(PXOList, 2) Then
                Call UpdatePlotsF(BPlots(), BPos, Epos, MaxBP(), PXOList(Trace(0), Trace(1)).SBPFlag)
            End If
        End If
        
        DistX = 10
        For x = 0 To 2
            For Y = x + 1 To 2
                If FMatSmall(x, ISeqs(Y)) < SMatSmall(x, ISeqs(Y)) Then
                    If DistX > FMatSmall(x, ISeqs(Y)) Then
                        DistX = FMatSmall(x, ISeqs(Y))
                    End If
                Else
                    If DistX > SMatSmall(x, ISeqs(Y)) Then
                        DistX = SMatSmall(x, ISeqs(Y))
                    End If
                End If
            Next Y
        Next x
        If Trace(1) <= UBound(PXOList, 2) Then
            Call UpdatePlotE(BPos, Epos, PXOList(Trace(0), Trace(1)).Probability, oPMax, oPMin, DistX, Mi, MaxBP(), BPlots())
        End If
    End If
    
    
    PXOList(Trace(0), Trace(1)).Probability = 1
    
'    If SEventNumber >= 271 Then
'        x = x
'        XX = RNum(WinPP)
'    End If
'    If SEventNumber = 170 Then
'        x = x
'        XX = RNum(0)
'    End If

    
    Call MakeBestXOList(EventAdd, BXOSize, WinPP, RCorr(), ExtraHits(), SuperEventList(), TraceSub(), WinnerPos(), RList(), RNum(), BCurrentXOver(), BestXOList(), CollectEvents())
    
    ReDim tBXOListMa(NextNo, AddNum - 1), tBXOListMi(NextNo, AddNum - 1), tBcurrentxoverma(NextNo), tBcurrentxovermi(NextNo)
    'XX = SEventNumber
    Dim tEHitsMa() As Byte, tEHitsMi() As Byte
    XX = PermNextno
    ReDim tEHitsMa(NextNo), tEHitsMi(NextNo)
    Call MakeNextBestXOLists(1, RCorr(), tEHitsMa(), tEventAdd, CompMat(WinPP, 0), SuperEventList(), TraceSub(), WinnerPosMa(), RList(), RNum(), tBcurrentxoverma(), tBXOListMa(), CollectEventsMa())
    If tEventAdd > EventAdd Then EventAdd = tEventAdd
    Call MakeNextBestXOLists(2, RCorr(), tEHitsMi(), tEventAdd, CompMat(WinPP, 1), SuperEventList(), TraceSub(), WinnerPosMi(), RList(), RNum(), tBcurrentxovermi(), tBXOListMi(), CollectEventsMi())
    If tEventAdd > EventAdd Then EventAdd = tEventAdd
    'XX = RNum(1)
    Erase CollectEvents
    Erase CollectEventsMi
    Erase CollectEventsMa
    'end section 8********************************************
    '9.994 5K perms
    '9.794 - incorrect because of SEventnumber going too high
    '0.503 = actual time
    
    'save info on the exact sequences used
    
    '10.194 10 times more events
    
    'begin section 9*******************************************
'xxxxzzzz    ReDim Preserve EventSeq(3, Len(StrainSeq(0)), Eventnumber + EventAdd)
    
 ' XX = oRNum(WinPP)
    Dim SwapFlag As Byte
    ReDim Preserve NOPINI(2, SEventNumber)
    Dim DMiMa(2) As Long
    
    If ExRecFlag = 203 Then
        SwapFlag = 0
    Else
    
        If INList(0) <> INList(1) And INList(0) <> INList(2) And INList(1) <> INList(2) Then
            If INList(0) = WinPP Then 'NO recombinant
                NOPINI(0, SEventNumber) = 0: NOPINI(1, SEventNumber) = 1: NOPINI(2, SEventNumber) = 2
                DMiMa(INList(0)) = 0: DMiMa(INList(1)) = 1: DMiMa(INList(2)) = 2
                
                If INList(1) = CompMat(WinPP, 0) Then
                    SwapFlag = 0
                Else
                    SwapFlag = 1
                End If
            ElseIf INList(1) = WinPP Then 'PI recombinant
                
                NOPINI(0, SEventNumber) = 1: NOPINI(1, SEventNumber) = 0: NOPINI(2, SEventNumber) = 2
                DMiMa(INList(0)) = 1: DMiMa(INList(1)) = 0: DMiMa(INList(2)) = 2
                If INList(0) = CompMat(WinPP, 0) Then
                    SwapFlag = 0
                Else
                    SwapFlag = 1
                End If
            Else 'NI recombinant
                NOPINI(0, SEventNumber) = 2: NOPINI(1, SEventNumber) = 1: NOPINI(2, SEventNumber) = 0
                DMiMa(INList(0)) = 2: DMiMa(INList(1)) = 1: DMiMa(INList(2)) = 0
                If INList(0) = CompMat(WinPP, 0) Then
                    SwapFlag = 0
                Else
                    SwapFlag = 1
                End If
            End If
        Else 'there has been no change in the relative tree positions of the three sequences
             NOPINI(0, SEventNumber) = WinPP
             DMiMa(WinPP) = 0
             If FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < FAMatSmall(CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Or FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) < FAMatSmall(CompMat(WinPP, 0), ISeqs(CompMat(WinPP, 1))) Then 'if winpp is inlyer
                If FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) < FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) Then
                    'compmat 0 the other inlyer
                    NOPINI(1, SEventNumber) = CompMat(WinPP, 1) 'minor parent the outlyer
                    NOPINI(2, SEventNumber) = CompMat(WinPP, 0) 'major parent the other inlyer
                    DMiMa(CompMat(WinPP, 1)) = 1
                    DMiMa(CompMat(WinPP, 0)) = 2
                    If SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) > 0 Or SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) > 0 Or SAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) > 0 Then
                        If FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) > 0 Or FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) > 0 Or FAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) > 0 Then
    
                            If FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) / (FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + FAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) < SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) / (SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + SAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) Then
                            'the sequences are further apart in the recombinant region
                                'minor parent actually unknown
                                MiF = 2
                            Else 'the sequences are closer together in the recombinant region
                                'major parent actually unknown
                                MiF = 1
                            End If
                        Else
                            MiF = 2
                        End If
                    Else
                        MiF = 2
                    End If
                Else
                    'compmat 1 the other inlyer
                    NOPINI(1, SEventNumber) = CompMat(WinPP, 0) 'minor parent the outlyer
                    NOPINI(2, SEventNumber) = CompMat(WinPP, 1) 'major parent the other inlyer
                    DMiMa(CompMat(WinPP, 1)) = 2
                    DMiMa(CompMat(WinPP, 0)) = 1
                    If SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) > 0 Or SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) > 0 Or SAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) > 0 Then
                        If FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) > 0 Or FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) > 0 Or FAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0))) > 0 Then
                            If FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) / (FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + FAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) < SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) / (SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + SAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) Then
                            'the sequences are further apart in the recombinant region
                                'minor parent actually unknown
                                MiF = 2
                            Else 'the sequences are closer together in the recombinant region
                                'major parent actually unknown
                                MiF = 1
                            End If
                        Else
                            MiF = 2
                        End If
                    Else
                        MiF = 1
                    End If
                End If
             Else 'if winpp is outlyer
                NOPINI(1, SEventNumber) = CompMat(WinPP, 0) 'minor parent one inlyer
                NOPINI(2, SEventNumber) = CompMat(WinPP, 1) 'major parent the other inlyer
                DMiMa(CompMat(WinPP, 1)) = 2
                DMiMa(CompMat(WinPP, 0)) = 1
                If (SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + SAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) > 0 Then
                    If (FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + FAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) > 0 Then
                        If ((FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))) / 2) / (FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + FAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + FAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) < ((SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1)))) / 2) / (SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 0))) + SAMatSmall(WinPP, ISeqs(CompMat(WinPP, 1))) + SAMatSmall(CompMat(WinPP, 1), ISeqs(CompMat(WinPP, 0)))) Then
                            'outlyer further in the recombinant region than it is in bKg
                            'minor parent actually unknown
                            MiF = 2
                        Else
                             'outlyer closer in the recombinant region than it is in bKg
                             'major parent actually unknown
                             MiF = 1
                        End If
                    Else
                       MiF = 2
                    
                    End If
                Else 'all the sequences are identical in the recombinant region
                    MiF = 1
                End If
             End If
             If NOPINI(1, SEventNumber) = CompMat(WinPP, 0) Then
                SwapFlag = 0
             Else
                SwapFlag = 1
             End If
            
        End If
        'Call MakeRange(0, WinPP, RNum(), RList, WinnerPos, StartPos, EndPos)
        'Call CBrother(NextNo, SeqNum(), StrainSeq(), ISeqs(), FMat(), FAMat(), SAMat(), NumSeqs, StartPos, EndPos)
        
        If RNum(WinPP) = -1 Then RNum(WinPP) = 0
        ReDim Breaks(1, RNum(WinPP))
        
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''
        'FAMat and SAMat needed for this - may be able to access directly from disk
        '''''''''''''''''''''''''''''''''''''''''''''''''''''
        If PermNextno > MemPoc Then
            Call GetSAMat
            Call GetFAMat
        End If
        Call MakeBreaks(BPos, Epos, DMiMa(), MiF, SwapFlag, MissIDFlag, CompMat(), WinPP, ISeqs(), FMatSmall(), SMatSmall(), FAMat(), SAMat(), RecombNo(), MinPair(), Breaks(), BestXOList(), RNum(), TraceSub(), RList(), WinnerPos())
        
        
    '    If SEventNumber = 3 Then
    '        x = x
    '    End If
        
        If BestXOList(TraceSub(ISeqs(WinPP)), BCurrentXOver(TraceSub(ISeqs(WinPP)))).MinorP <= UBound(tEHitsMi, 1) Then
            If SwapFlag = 0 Then
                If tEHitsMi(BestXOList(TraceSub(ISeqs(WinPP)), BCurrentXOver(TraceSub(ISeqs(WinPP)))).MinorP) = 0 Then
                    SwapFlag = 1 'this checks to see if thereis a mismatch between tehitsma/tehistmi and bcurrentxover
                End If
    '        Else
    '            If tEHitsMa(BestXOList(TraceSub(ISeqs(WinPP)), BCurrentXOver(TraceSub(ISeqs(WinPP)))).MinorP) = 1 Then
    '                SwapFlag = 0 'this checks to see if thereis a mismatch between tehitsma/tehistmi and bcurrentxover
    '            End If
            End If
        End If
        '''''''''''''''''''''''''''''''''''''''''''''''''''''''
        'FAMat and SAMat needed for this - may be able to access directly from disk
        '''''''''''''''''''''''''''''''''''''''''''''''''''''
        Call MakeAlternative(BPos, Epos, tEHitsMa(), DMiMa(), MiF, SwapFlag, MissIDFlag, CompMat(), CompMat(WinPP, 0), ISeqs(), FMatSmall(), SMatSmall(), FAMat(), SAMat(), MinPair(), tBXOListMa(), RNum(), TraceSub(), RList(), WinnerPosMa())
        Call MakeAlternative(BPos, Epos, tEHitsMi(), DMiMa(), MiF, SwapFlag, MissIDFlag, CompMat(), CompMat(WinPP, 1), ISeqs(), FMatSmall(), SMatSmall(), FAMat(), SAMat(), MinPair(), tBXOListMi(), RNum(), TraceSub(), RList(), WinnerPosMi())
        '$
        ReDim FAMat(0, 0)
        ReDim SAMat(0, 0)
    '    If BusyWithExcludes = 1 Then
    '        For x = ExcludedEventNum To 0 Step -1
    '           If EventsInExcludeds(1, x) <> -SEventNumber Then
    '                Exit For
    '           ElseIf EventsInExcludeds(0, x) = 3 Then
    '                GoOn = 1
    '                For Y = 0 To RNum(WinPP)
    '                    If RList(WinPP, Y) = EventsInExcludeds(2, x) Then
    '                        GoOn = 0
    '                        Exit For
    '                    End If
    '                Next Y
    '                If GoOn = 1 Then
    '                    RNum(WinPP) = RNum(WinPP) + 1
    '                    RList(WinPP, RNum(WinPP)) = EventsInExcludeds(2, x)
    '                End If
    '            End If
    '
    '        Next x
    '    End If
        If SwapFlag = 0 Then
            Call CopyBXOList(TraceSub(), BestXOListMa(), BCurrentXoverMa(), tBXOListMa(), tBcurrentxoverma())
            Call CopyBXOList(TraceSub(), BestXOListMi(), BCurrentXoverMi(), tBXOListMi(), tBcurrentxovermi())
            Call CopyExtraHits(SEventNumber, ExtraHitsMi(), tEHitsMi())
            Call CopyExtraHits(SEventNumber, ExtraHitsMa(), tEHitsMa())
            
        Else
            'XX = SEventNumber '1,4,5
            Call CopyBXOList(TraceSub(), BestXOListMi(), BCurrentXoverMi(), tBXOListMa(), tBcurrentxoverma())
            Call CopyBXOList(TraceSub(), BestXOListMa(), BCurrentXoverMa(), tBXOListMi(), tBcurrentxovermi())
            Call CopyExtraHits(SEventNumber, ExtraHitsMi(), tEHitsMa())
            Call CopyExtraHits(SEventNumber, ExtraHitsMa(), tEHitsMi())
    '        Dim TempP As Long
    '        For x = 0 To NextNo
    '            For Y = 1 To BCurrentXOver(x)
    '                If SuperEventList(BestXOList(x, Y).Eventnumber) = SEventNumber Then
    '                    TempP = BestXOList(x, Y).MinorP
    '                    BestXOList(x, Y).MinorP = BestXOList(x, Y).MajorP
    '                    BestXOList(x, Y).MajorP = TempP
    '                End If
    '            Next Y
    '        Next x
        End If
    End If
    Erase tBXOListMa
    Erase tBXOListMi
    On Error GoTo 0
    
    ReDim Preserve DScores(25, 2, SEventNumber)
    
    For x = 0 To 2
        tDscores(25, x) = TraceSub(ISeqs(x)) '8,19,16
    Next x
    
    For x = 0 To 25
        DScores(x, 0, SEventNumber) = tDscores(x, WinPP)
    Next x
    
    
    
    
    If SwapFlag = 0 Then
       ' XX = ISeqs(CompMat(WinPP, 0)) '19 becomes minorp
       ' XX = ISeqs(CompMat(WinPP, 1)) '16 becomes majorp
        For x = 0 To 25
            
            DScores(x, 2, SEventNumber) = tDscores(x, CompMat(WinPP, 1))
            DScores(x, 1, SEventNumber) = tDscores(x, CompMat(WinPP, 0))
            
        Next x
        

    Else
        For x = 0 To 25
            DScores(x, 1, SEventNumber) = tDscores(x, CompMat(WinPP, 1))
            DScores(x, 2, SEventNumber) = tDscores(x, CompMat(WinPP, 0))
        Next x
    End If

'   XX = DScores(25, 2, SEventNumber)'8,16,19
'   XX = DScores(25, 0, SEventNumber)
'   XX = DScores(25, 0, SEventNumber)
   'StatsDumpFlag = 1
    If StatsDumpFlag = 1 Or ExRecFlag = 203 Or ExRecFlag = 210 Then
        SDNum = SDNum + 1
        If SDNum > UBound(StatsDump, 3) Then ReDim Preserve StatsDump(2, 51, SDNum + 100)
        If ExRecFlag <> 203 Or GoodCall203 = 1 Then
            For A = 2 To 0 Step -1
                If A = 2 Then
                    C = WinPP
                Else
                    C = CompMat(WinPP, A)
                    
                End If
                StatsDump(A, 49, SDNum) = 1
                StatsDump(A, 50, SDNum) = SEventNumber
                StatsDump(A, 51, SDNum) = TraceSub(ISeqs(C))
                StatsDump(A, 0, SDNum) = TraceSub(ISeqs(C))
                StatsDump(A, 1, SDNum) = ListCorr(C)
                StatsDump(A, 2, SDNum) = SimScoreB(C)
                StatsDump(A, 3, SDNum) = SimScore(C)
                StatsDump(A, 4, SDNum) = PhPrScore(C)
                StatsDump(A, 5, SDNum) = PhPrScore2(C)
                StatsDump(A, 6, SDNum) = PhPrScore3(C)
                StatsDump(A, 7, SDNum) = SubScore(C)
                StatsDump(A, 8, SDNum) = SSDist(C)
                StatsDump(A, 9, SDNum) = OUIndexA(C)
                StatsDump(A, 10, SDNum) = SubPhPrScore(C)
                StatsDump(A, 11, SDNum) = SubScore2(C)
                StatsDump(A, 12, SDNum) = SubPhPrScore2(C)
                'StatsDump(A, 13, SDNum) = SRCompatF(C)
                'StatsDump(A, 14, SDNum) = SRCompatS(C)
                StatsDump(A, 15, SDNum) = RCompat(C)
                StatsDump(A, 16, SDNum) = RCompat2(C)
                StatsDump(A, 17, SDNum) = RCompat3(C)
                StatsDump(A, 18, SDNum) = RCompat4(C)
                StatsDump(A, 19, SDNum) = RCompatS(C)
                StatsDump(A, 20, SDNum) = RCompatS2(C)
                StatsDump(A, 21, SDNum) = RCompatS3(C)
                StatsDump(A, 22, SDNum) = RCompatS4(C)
                'StatsDump(A, 23, SDNum) = RCompatXF(C)
                'StatsDump(A, 24, SDNum) = RCompatXS(C)
                StatsDump(A, 25, SDNum) = RCompatC(C)
                StatsDump(A, 26, SDNum) = RCompatD(C)
                StatsDump(A, 27, SDNum) = TrpScore(C)
                StatsDump(A, 28, SDNum) = BadDists(C)
                StatsDump(A, 29, SDNum) = OUList(C)
                StatsDump(A, 30, SDNum) = ListCorr2(C)
                StatsDump(A, 31, SDNum) = ListCorr3(C)
                StatsDump(A, 32, SDNum) = Consensus(C, 0)
                StatsDump(A, 33, SDNum) = Consensus(C, 1)
                StatsDump(A, 34, SDNum) = Consensus(C, 2)
                StatsDump(A, 35, SDNum) = OuCheck(C)
                StatsDump(A, 36, SDNum) = SetTot(0, C)
                StatsDump(A, 37, SDNum) = SetTot(1, C)    ', PhPrScore3(C), SubScore3(C), SubPhPrScore3(C),   TrpScore2(C), RCompat2(C) ', SubScore2(C), SubPhPrScore2(C), ListCorr4(C), tListCorr2(C, 0), tListCorr2(C, 1), tListCorr2(C, 2), ListCorr5(C), ListCorr6(C)
                StatsDump(A, 38, SDNum) = RankF(C, 0)
                StatsDump(A, 39, SDNum) = RankF(C, 1)
                StatsDump(A, 40, SDNum) = dMax(C) '1.01,0.488 (19), 0.435(16)
            Next A
        ElseIf ExRecFlag = 203 And GoodCall203 = 0 Then
            SDNum = SDNum - 1
        End If
    End If
       
    
    If UBound(YannWarn, 1) < SEventNumber Then
        ReDim Preserve YannWarn(SEventNumber + 10)
    End If
    YannWarn(SEventNumber) = CheckYann(PHIWarn, SEventNumber, ISeqs(), BPos, Epos, SeqNum(), ExtraHits(), ExtraHitsMi(), ExtraHitsMa(), TraceSub())
    
    
    'find best event in rlist
    For x = 0 To RNum(WinPP)
        If RList(WinPP, x) = ISeqs(WinPP) Then Exit For
    Next x
    
    
    ActualE = x
    
    ReDim tDaught(0, NextNo)
    
    For x = 0 To RNum(WinPP)
        tDaught(0, RList(WinPP, x)) = 1
    Next x
   
    'XX = AgeScore(1000, ISeqs(WinPP))
'    If AllowConflict = 0 And AbortFlag = 0 Then
'        'needs fmat,smat permdiffs and pervalid
'
'        If PermNextno > MemPoc Then
'            GetPermValid
'            GetPermDiffs
'            GetFMat
'            GetSMat
'        End If
'
'
'
'        Call GetAge(SEventNumber, tDaught(), 0, ISeqs(WinPP), ISeqs(CompMat(WinPP, 1)), ISeqs(CompMat(WinPP, 0)), FMat(), SMat(), PermDiffs(), PermValid(), AgeEvent())
'        If PermNextno > MemPoc Then
'            ReDim PermValid(0, 0)
'            ReDim PermDiffs(0, 0)
'            ReDim FMat(0, 0)
'            ReDim SMat(0, 0)
'        End If
'        Call UpdateAgeScore(TraceSub(ISeqs(WinPP)), AgeEvent(1, SEventNumber), SEventNumber, BPos, EPos, AgeScore(), EventScore())
'        If SEventNumber >= UBound(RepeatCycles, 1) Then
'            UB = UBound(RepeatCycles, 1)
'            ReDim Preserve RepeatCycles(UB + 1000)
'        End If
'        RepeatCycles(SEventNumber) = RepeatCycles(SEventNumber) + 1
'
'
'        Dim TestC() As Long
'        Call TestConflict(TestC(), WinPP, AgeEvent(0, SEventNumber), Fail, BPos, EPos, TraceSub(), AgeEvent(), AgeScore(), EventScore(), ISeqs(), BestXOList(), BCurrentXOver())
'        If Fail > 0 Then '2,1,3,2,1,3,2,4,3,3,3,3,3,3,3,3,3,3,3,3
'            'oSEventNumber = SEventNumber
'            If RepeatCycles(Fail) <= MaxRepeatCycles Then
'
'                Call Rewind(TestC(), BCurrentXOver(), BestXOList())
'                ReDim MissingData(Len(StrainSeq(0)), NextNo)
'                If ReassortmentFlag = 1 Then
'                    Dim tBP As Long
'                    If UBound(RBPPos, 1) < RBPNum Then
'                        ReDim Preserve RBPPos(RBPNum)
'                    End If
'                    For X = 0 To RBPNum
'                        tBP = RBPPos(X)
'                        For Y = 0 To NextNo
'                            MissingData(tBP, Y) = 1
'                        Next Y
'                    Next X
'                End If
'                oAbortFlag = AbortFlag
'
'                Call BuildFirstXOList(1, SPX, AgeScore(), EventScore(), MinSeqSize, JumpFlag, MissingData(), TraceSub(), NextNo, StepNo, Steps(), ExtraHits(), ExtraHitsMa(), ExtraHitsMi(), NOPINI(), Eventnumber, SEventNumber, BestXOList(), BCurrentXOver(), XOverList(), CurrentXOver(), BestXOListMi(), BCurrentXoverMi(), BestXOListMa(), BCurrentXoverMa(), Daught(), MinorPar(), MajorPar())
'                AbortFlag = oAbortFlag
'                Call RemoveAccepts(BCurrentXOver(), BestXOList())
'                'If AbortFlag = 0 Then
'                    GoTo RestartX
'                'End If
'            Else
'
'                'ADD WARNING OF POSSIBLE CONFLICT IF YOURE JUST PUSHING ON
'            '    'SEventNumber = oSEventNumber
'            '    For X = SEventNumber + 1 To UBound(RepeatCycles, 1)
'            '        RepeatCycles(X) = 0
'            '    Next X
'            End If
''        Else
''            X = X
'        End If
'
'
'
'    End If
    
    'begin section 10****************************************************************
   ReDim FMat(0, 0)
   ReDim SMat(0, 0)
   ReDim SubValid(0, 0)
'   If SEventNumber >= 34 Then
'    x = x
'   End If
   ReDim SubDiffs(0, 0)
    
      
      'erase bits from recombinants
     
   'For X = 0 To RNum(WinPP)
   '     Breaks(0, X) = BPos
   '     Breaks(1, X) = EPos
   '
   'Next X
'    If SEventNumber = 33 Then
'        x = x
'        XX = RNum(WinPP)
''        XX = RList(WinPP, 1)
''        XX = SeqNum(1750, 0)
'    End If
    
    If ExRecFlag = 203 Then
        bPXOlist(Trace(0), Trace(1)).Probability = 1
        ReDim PXOList(UBound(bPXOlist, 1), UBound(bPXOlist, 2))
        For x = 0 To UBound(bPXOlist, 1)
            For Y = 0 To UBound(bPXOlist, 2)
                PXOList(x, Y) = bPXOlist(x, Y)
            Next Y
            
        Next x
        Eventnumber = Eventnumber + EventAdd
        GoTo ERF203
    Else
    
        Dummy = ModSeqNumY(BPos, Epos, Len(StrainSeq(0)), WinPP, RNum(0), Breaks(0, 0), RList(0, 0), SeqNum(0, 0), tSeqnum(0, 0), MissingData(0, 0))
         
        
        ' 0.190
       
        ReDim DoPairs(NextNo, NextNo), tCurrentxover(NextNo), TempDone(NextNo + RNum(WinPP) + 1, UBound(PXOList, 2))
       
        
        'place all evidence of non winners from pxolist in tempxolist
        oRecombNo(100) = 0
        '*****************************************************************************************
        'must set up code to redim preserve tempxolist
        
        MaxSize = 0
        For x = 0 To NextNo
            If PCurrentXover(x) > UBound(PXOList, 2) Then
                PCurrentXover(x) = UBound(PXOList, 2)
            End If
            If PCurrentXover(x) > MaxSize Then
                MaxSize = PCurrentXover(x)
            End If
            
        Next x
        XOSize = MaxSize + 1
        
        Dim TestSize As Variant
        TestSize = (UBound(TempXOList, 1) + 1) * (XOSize + 1) * 55
        
        If TestSize > 40000000 Or XOSize > MaxXOListSize Then 'limit to 40 megs
                            
            ReduceX = (TestSize - 40000000) / 55 'the number of signals that must be removed per sequence
            ReduceX = CLng(ReduceX / NextNo)
            If (XOSize - MaxXOListSize) < ReduceX Then 'choose whichever is the lowest number
                ReduceX = CLng(XOSize - MaxXOListSize)
            End If
            
            TempMax = XOSize - ReduceX
            TempMax2 = TempMax
            If TempMax2 > 32760 Then TempMax2 = 32760
            
            'need to shed some signals
            'XX = PXOList(93, 12).Probability
            'Do
            For x = 0 To NextNo
                XX = PCurrentXover(x)
                XX = XX + CurrentXOver(x)
                If XX < 32760 Then
                    If PCurrentXover(x) + CurrentXOver(x) > TempMax2 Then 'this one is over the max
                        If PCurrentXover(x) > 0 Then
                            PropP = 1
                            PropC = 0
                        End If
                        
                        PropP = PCurrentXover(x) - TempMax2
                        
                        
                        If PropP > 0 Then
                            For Z = 1 To PropP
                                WorstP = 0
                                WorstOne = -1
                                For Y = 1 To PCurrentXover(x)
                                    '$
                                    If PXOList(x, Y).Probability > WorstP And PXOList(x, Y).Accept <> 1 Then
                                        WorstP = PXOList(x, Y).Probability
                                        WorstOne = Y
                                    End If
                                Next Y
                                If WorstOne > -1 Then
                                    If WorstOne <> PCurrentXover(x) Then
                                        Call AddToRedoList(PXOList(x, WorstOne).ProgramFlag, PXOList(x, WorstOne).Daughter, PXOList(x, WorstOne).MajorP, PXOList(x, WorstOne).MinorP)
                                        PXOList(x, WorstOne) = PXOList(x, PCurrentXover(x))
                                    End If
                                    PCurrentXover(x) = PCurrentXover(x) - 1
                                End If
                                If PCurrentXover(x) + CurrentXOver(x) < TempMax2 Then Exit For
                            Next Z
                        End If
                        
                        
                        
                        
                    End If
                End If
            Next x
        End If
        
        
        MaxSize = 0
        For x = 0 To NextNo
            If PCurrentXover(x) > UBound(PXOList, 2) Then
                PCurrentXover(x) = UBound(PXOList, 2)
            End If
            If PCurrentXover(x) > MaxSize Then
                MaxSize = PCurrentXover(x)
            End If
            
        Next x
        XOSize = MaxSize + 1
        
        ReDim TempXOList(UBound(TempXOList, 1), XOSize)
        '223,245,234
         
        
        '@
        
        Dim UBTS As Long
        UBTS = UBound(TraceSub, 1)
        
        If UBound(TempXOList, 1) < NextNo Then
            ReDim TempXOList(NextNo, UBound(TempXOList, 2))
        End If
        
        'If x = x Then
            Dummy = AddjustCXO(NextNo, WinPP, LowestProb, UBound(DoneSeq, 1), UBound(DoneSeq, 2), DoneSeq(0, 0), UBound(TempDone, 1), UBound(TempDone, 2), TempDone(0, 0), oRecombNo(0), RNum(0), RList(0, 0), DoPairs(0, 0), UBound(TraceSub, 1), TraceSub(0), tCurrentxover(0), UBound(TempXOList, 1), UBound(TempXOList, 2), TempXOList(0, 0), PCurrentXover(0), UBound(PXOList, 1), UBound(PXOList, 2), PXOList(0, 0))
    
            'Call AddjustCXOVB(NextNo, WinPP, LowestProb, DoneSeq(), TempDone(), oRecombNo(), RNum(), RList(), DoPairs(), TraceSub(), tCurrentxover(), TempXOList(), PCurrentXover(), PXOList())
    
    
    'XX = TempXOList(27, 50).Ending '  1328
     '           XX = TempXOList(27, 50).Beginning '1013
      '          XX = TempXOList(27, 50).Daughter '27
       '         XX = TempXOList(27, 50).MinorP '46
        '        XX = TempXOList(27, 50).MajorP '38
    
    
    '    Else
    '        Dim PCXO As Long
    '        '@'@'@'@'@'@'$
    '        For x = 0 To NextNo
    '            PCXO = PCurrentXOver(x)
    '            For Y = 1 To PCXO
    '              If Y <= UBound(PXOList, 2) Then
    '                DA = PXOList(x, Y).Daughter
    '                Mi = PXOList(x, Y).MinorP
    '                Ma = PXOList(x, Y).MajorP
    '                If DA > NextNo Then
    '                    DA = TraceSub(PXOList(x, Y).Daughter)
    '                End If
    '                If Mi > UBTS Then
    '                    Mi = 0
    '                End If
    '                If Ma > UBTS Then
    '                    Ma = 0
    '                End If
    '                'XX = UBound(TraceSub, 1)
    '                If Mi > NextNo Then
    '
    '                    Mi = TraceSub(Mi)
    '                End If
    '                If Ma > NextNo Then
    '                    Ma = TraceSub(Ma)
    '                End If
    '                WinPPY = MakePairsP(NextNo, DA, Ma, Mi, WinPP, RNum(0), RList(0, 0), DoPairs(0, 0))
    '                '@
    '                If PXOList(x, Y).Probability <= LowestProb Then
    '                    If WinPPY = RNum(WinPP) + 1 Then
    '                        If tCurrentxover(DA) <= tCurrentxover(Mi) And tCurrentxover(DA) <= tCurrentxover(Ma) Then
    '                            tCurrentxover(x) = tCurrentxover(x) + 1
    '                            If tCurrentxover(x) < UBound(TempXOList, 2) Then
    '
    '                                TempXOList(x, tCurrentxover(x)) = PXOList(x, Y)
    '                                If tCurrentxover(x) <= UBound(TempDone, 2) And Y <= UBound(DoneSeq, 2) Then
    '                                    TempDone(x, tCurrentxover(x)) = DoneSeq(x, Y)
    '                                End If
    '                            Else
    '                                tCurrentxover(x) = tCurrentxover(x) - 1
    '                            End If
    '                        ElseIf tCurrentxover(Mi) <= tCurrentxover(DA) And tCurrentxover(Mi) <= tCurrentxover(Ma) Then
    '                            tCurrentxover(Mi) = tCurrentxover(Mi) + 1
    '                            If tCurrentxover(Mi) <= UBound(TempXOList, 2) Then
    '                                '@
    '                                TempXOList(Mi, tCurrentxover(Mi)) = PXOList(x, Y)
    '                                TempXOList(Mi, tCurrentxover(Mi)).Daughter = Mi
    '                                TempXOList(Mi, tCurrentxover(Mi)).MinorP = DA
    '                                If tCurrentxover(Mi) <= UBound(TempDone, 2) And Y <= UBound(DoneSeq, 2) Then
    '                                    TempDone(Mi, tCurrentxover(Mi)) = DoneSeq(x, Y)
    '                                End If
    '                            Else
    '                                tCurrentxover(Mi) = tCurrentxover(Mi) - 1
    '                            End If
    '
    '                        Else
    '                            '@
    '                            tCurrentxover(Ma) = tCurrentxover(Ma) + 1
    '                            If tCurrentxover(Ma) <= UBound(TempXOList, 2) Then
    '                                TempXOList(Ma, tCurrentxover(Ma)) = PXOList(x, Y)
    '                                TempXOList(Ma, tCurrentxover(Ma)).Daughter = Ma
    '                                TempXOList(Ma, tCurrentxover(Ma)).MajorP = DA
    '                                If tCurrentxover(Ma) <= UBound(TempDone, 2) And Y <= UBound(DoneSeq, 2) Then
    '                                    TempDone(Ma, tCurrentxover(Ma)) = DoneSeq(x, Y)
    '                                End If
    '                            Else
    '                                tCurrentxover(Ma) = tCurrentxover(Ma) - 1
    '                            End If
    '                        End If
    '                        oRecombNo(100) = oRecombNo(100) + 1
    '                        oRecombNo(PXOList(x, Y).ProgramFlag) = oRecombNo(PXOList(x, Y).ProgramFlag) + 1
    '                    End If
    '                End If
    '                PCurrentXOver(x) = PCurrentXOver(x) - 1
    '              End If
    '            Next Y
    '        Next x
    '    End If
        
    '     If X = 123456789 Then
    '            XX = TCurrentXOver(29)
    '        End If
    '
        'XX = UBound(DoPairs, 2)
        For Z = 0 To NextNo
            For x = 0 To RNum(WinPP)
                If DoPairs(RList(WinPP, x), Z) = 1 Then
                    For Y = 0 To RNum(WinPP)
                        DoPairs(RList(WinPP, Y), Z) = 1
                        DoPairs(Z, RList(WinPP, Y)) = 1
                    Next Y
                    Exit For
                    'exit dot
                End If
            Next x
            
        Next Z
        
        
        'erase all rescans from redolist
        If RedoListSize > 0 And BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            'mark removals
            'If X = X Then
                Dummy = MarkRemovalsP(NextNo, WinPP, RedoListSize, RedoList(0, 0), RNum(0), RList(0, 0), DoPairs(0, 0))
            'Else
            '    For X = 0 To Redolistsize
            '        For Y = 1 To 3
            '            For Z = 0 To RNum(WinPP)
            '                If Rlist(WinPP, Z) = RedoList(Y, X) Then
            '                    If Y = 1 Then
            '                        If DoPairs(RedoList(2, X), RedoList(3, X)) = 1 Then Exit For
            '                    ElseIf Y = 2 Then
            '                        If DoPairs(RedoList(1, X), RedoList(3, X)) = 1 Then Exit For
            '                    ElseIf Y = 3 Then
            '                         If DoPairs(RedoList(1, X), RedoList(2, X)) = 1 Then Exit For
            '                    End If
            '
            '                End If
            '            Next Z
            '            If Z <= RNum(WinPP) Then
            '                RedoList(0, X) = -1
            '                Exit For
            '            End If
            '        Next Y
            '    Next X
            'End If
            'clean up redolist
            Dummy = CleanRedoList(RedoListSize, RedoList(0, 0))
        End If
        
        
        'end section 10************************************************
        '9.844 5k perms
        '1.041
        '0.34 with makepairs
        'begin section 11************************************************
         
        '5.708 10 times more events
        '3.525 with makepairs
         
         'SSS = Abs(GetTickCount)
        
        ' For i = 0 To 500
         'begin section 11.1************************************************
         
        
        ReDim CurrentXOver(NextNo), SLookup(1, NextNo + 1), SLookupNum(1)
        ReDim MaxXOP(AddNum - 1, NextNo)
        Call ResetMaxPVCO(NextNo)
        
        
        
        
         If IndividualB > -1 Then
                
                Seq1 = ISeqs(WinPP)
                
                If MaskSeq(Seq1) = 0 Then
                    SLookupNum(1) = 1
                    For x = 0 To NextNo
                        
                        If x <> Seq1 And MaskSeq(x) < 2 And ActualSeqSize(x) > MinSeqSize Then
                            If TraceSub(x) <> IndividualA And TraceSub(x) <> IndividualB Then
                                SLookupNum(1) = SLookupNum(1) + 1
                                SLookup(1, SLookupNum(1)) = x
                            Else
                                If x = IndividualA Or x = IndividualB Then
                                    SLookupNum(0) = 1
                                    If TraceSub(Seq1) = IndividualA Then
                                        SLookup(0, 1) = IndividualB
                                    Else
                                        SLookup(0, 1) = IndividualA
                                    End If
                                End If
                            End If
                        End If
                    Next x
                Else
                    SLookupNum(0) = 1
                    SLookup(0, 1) = IndividualA
                    SLookupNum(1) = 2
                    SLookup(1, 2) = IndividualB
                End If
            
         ElseIf IndividualA > -1 Then
            
                Seq1 = TraceSub(ISeqs(WinPP))
                If MaskSeq(Seq1) = 0 Then
                    For x = 0 To NextNo
                        
                        If TraceSub(x) <> Seq1 And MaskSeq(x) < 2 And ActualSeqSize(x) > MinSeqSize Then
                            SLookupNum(0) = SLookupNum(0) + 1
                            SLookup(0, SLookupNum(0)) = x
                            SLookupNum(1) = SLookupNum(1) + 1
                            SLookup(1, SLookupNum(1)) = x
                        End If
                    Next x
                Else
                    For x = 0 To NextNo
                        If TraceSub(x) = IndividualA Then
                            SLookupNum(0) = SLookupNum(0) + 1
                            SLookup(0, 1) = x
                        End If
                    Next x
                    
                    SLookupNum(1) = 1
                    For x = 0 To NextNo
                        If x <> Seq1 And MaskSeq(x) < 2 And TraceSub(x) <> IndividualA And ActualSeqSize(x) > MinSeqSize Then
                            SLookupNum(1) = SLookupNum(1) + 1
                            SLookup(1, SLookupNum(1)) = x
                        End If
                    Next x
                End If
         Else
            For x = 0 To NextNo
                If MaskSeq(x) = 0 Then
                    SLookupNum(0) = SLookupNum(0) + 1
                    SLookup(0, SLookupNum(0)) = x
                    SLookupNum(1) = SLookupNum(1) + 1
                    SLookup(1, SLookupNum(1)) = x
                End If
            Next x
         End If
         
         'end section 11.1 ************************************************
         '0.060 5K perms
         Dim MCCorrectX As Double
         Dim VarA As Variant
         
         VarA = (NextNo + 1)
         VarA = VarA * (NextNo) / 2
         VarA = VarA * (RNum(WinPP) + 1)
         
         MCCorrectX = VarA
         If SSOutlyerFlag = 2 Then
            Call GetOutie
            oSeq = Outie
         End If
         ReDim TSub(NextNo)
         For x = 0 To NextNo
            TSub(x) = x
         Next x
         b = 0
         'XX = originalname(ISeqs(WinPP))
         'Dim SAll As Long
         SAll = Abs(GetTickCount)
         
         'Call SetUpNumSeq
    '    If UBound(Steps, 2) >= 4969 Then
    '     If Steps(1, 4969) = 159 Then
    '        x = x '420-799 (171),1740-2329(184)
    '        'y=4457, 5020
    '        XX = StepNo
    '        XX = SEventNumber
    '    End If
    '    End If
         'XX = PermNextno
         
         
         
        
        etxx = GetTickCount
        silly3 = silly3 + (etxx - stxxsilly3)
         
        stxx = GetTickCount
            
        
         
         Call InnerScan2(MCCorrectX, STime, SAll, WinPP, SLookup(), ISeqs(), RNum(), RList(), TraceSub(), ActualSeqSize(), SLookupNum(), DoPairs(), CLng(0), WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), BackUpNextno, MissingData())
        
         etxx = GetTickCount
        silly2 = silly2 + etxx - stxx
        
        
        stxxsilly4 = GetTickCount
        
    '     Open "progress.txt" For Append As #20
    '        Print #20, SEventNumber, "innerscanpost"
    '        Close #20
         
        'Erase NumSeq
        'Erase Iseq4
        ET = Abs(GetTickCount)
        For x = 0 To AddNum - 1
            MethodTime(x) = Abs(MethodTime(x))
        Next x
        Call UpdateTimeCaps(ET, SAll)
        For x = 0 To AddNum - 1
            MethodTime(x) = MethodTime(x) + Abs(ET - SAll) * TimeFract(x)
            'X = X
        Next x
        'X = X
        'If doscans(0,5) = 1 Then
        '    Call SSXoverD(0, WinPP, MinSeqSize, ActualSeqSize(), RList(), RNum(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), TraceSub(), SimSeqNum())
        ''    SSOutlyerFlag = pSSOutlyerFlag
        'End If
        'Form1.SSPanel1.Caption = Trim(Str(mccorrectx)) & " of " & Trim(Str(mccorrectx)) & " triplets reexamined"
        TT = Abs(GetTickCount)
        If Abs(TT - GlobalTimer) > 500 Then
            GlobalTimer = TT
            Call UpdateRecNums(SEventNumber)
        End If
       
        'X = X
       'Next i
     'ee = Abs(GetTickCount)
      '  tt = ee - SSS
      '  X = X
        
        'maxchi
        '14.46 500 perms
        '7.860 (dsktop)
        '5.828 with growmchiwin
        '5.172 - not bothering with twins
        '5.878 (laptop) - rearranging xolist less
        '2.874 (laptop) - stopping when mpv doesn't make the cut - there may be a screwup
        '6.269 - more events
        '5.799 - destroy peaks
        '5.168 - findside
        '5.138 - != findsubseq
        '5.017 improvements in findsubseqc
        '4.837 improvements in winscorecalc
        '4.637 - taking out a criticaldiff test in winscorecalc.
        '4.376 - using criticalval in chipvals
        '10.212 with looking for overlapping missing data
        '9.835 only scrubbing negative peaks (ie not the whole region)
        '4.126 using banwins
        '3.906 using destroypeak
        '3.805 more efficient calculation chivals in growmchiwin
        '3.710
        '3.495 with hiseqs
        
        'X = X
      '  '24.986 500 perms
        '12.378 500 perms (using highenough)
        '11.647
        '11.186
        '14.801 with splits
        '11.707 with makesubprob
        'end section 11********************************************
        'GENECONV results
        '41.375 5K perms ignor indels (desktop)
        '55.109 (laptop)
        '53.397 (laptop) better array dimentioning
        '250.801 -use indels (laptop)
        
        
        '8.250 1k perms
        
        
        '326.439
        '115.005 screening only "relevant" pairs
        '86.704 - Improvement to findsubseq and rearrangement of ifs etc in the main loop
        '82.672 - inclusion of corrcetprob in probcalc
        '62.219 - improvements in xover
        '61.248 - taking out pointless cycles
        '60.938 - not using pointers in findnext
        
        '19.907 1K perms (0.282 without callinq xover)
        '19.094 1K perms - slight improvement in findsubseq
        '17.438 1K perms - rearrangement of ifs etc in main loop.
        '16.406 1K perms - inclusion of corrcetprob in probcalc
        '14.594 1K perms - only accessing xoverlist at the end after p-val is confirmed
        '12.859 1K perms - xoverwin and lenstrainseq calculated outside loop
        
        
        'Begin section 12*****************************************
        
        'Replace the missing bits
        
        
        oRNum(WinPP) = RNum(WinPP)
        ReDim oRList(RNum(WinPP)), oBreaks(1, RNum(WinPP))
        For x = 0 To RNum(WinPP)
            oRList(x) = RList(WinPP, x)
            oBreaks(0, x) = Breaks(0, x)
            oBreaks(1, x) = Breaks(1, x)
        Next x
        
        ReDim Uninvolved(NextNo)
        Dummy = MakeUninvolved(WinPP, NextNo, Uninvolved(0), RNum(0), RList(0, 0))
        
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            Dummy = RebuildSeqNum(Len(StrainSeq(0)), WinPP, RNum(0), Breaks(0, 0), RList(0, 0), SeqNum(0, 0), tSeqnum(0, 0))
            'remove events that were not actually detected
            Dummy = StripUnfound2(WinPP, AddNum, RNum(0), WinnerPos(0, 0), RList(0, 0), Breaks(0, 0))
        End If
            'End section 12*********************************************
            '9.163 5K perms
            '0.010
            
            'Befor removing any events from RList it is very important to
            'first take note of which distances do and do not need to be recalculated.
            'distances between any sequence and all sequences in rlist at this point must
            'all be recalculated.
            
            'begin section 13*********************************************
        
        
        
        
         
        'end section 13*********************************************
        '0.110
        '0.007
         
        'begin section 14*********************************************
     
        'ReDim TCurrentXOver(Nextno)
        'place evidence in xoverlist into tempxolist
        
        GlobalMemoryStatus MemSit
        APhys = Abs(MemSit.dwTotalPhys)
        'APhys = Abs(MemSit.dwAvailVirtual)
        If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
        
         
               'End If
        
        MaxSize = 0
        For x = 0 To NextNo
            If tCurrentxover(x) > UBound(TempXOList, 2) Then
                tCurrentxover(x) = UBound(TempXOList, 2)
            End If
            If tCurrentxover(x) + CurrentXOver(x) > MaxSize Then
                MaxSize = tCurrentxover(x) + CurrentXOver(x)
            End If
           
        Next x
        'XX = UBound(TempXOList, 1)
        XOSize = MaxSize + 1
        UB = UBound(TempXOList, 1)
        
        
        
        
        TestSize = (UB + 1) * (XOSize + 1) * 55
        
        If TestSize > 40000000 Or XOSize > MaxXOListSize Then 'limit to 40 megs (55=the number of bytes per entry in an xoverdefine array
                            
            ReduceX = (TestSize - 40000000) / 55 'the number of signals that must be removed per sequence
            ReduceX = CLng(ReduceX / NextNo)
            If (XOSize - MaxXOListSize) < ReduceX Then 'choose whichever is the lowest number
                ReduceX = CLng(XOSize - MaxXOListSize)
            End If
            
            TempMax = XOSize - ReduceX
            TempMax2 = TempMax
            
            
            'need to shed some signals
            
            'Do
            For x = 0 To NextNo
               
                If tCurrentxover(x) + CurrentXOver(x) > TempMax2 Then 'this one is over the max
                    If tCurrentxover(x) + CurrentXOver(x) > 0 Then
                        PropP = (tCurrentxover(x)) / (tCurrentxover(x) + CurrentXOver(x))
                        PropC = (CurrentXOver(x)) / (tCurrentxover(x) + CurrentXOver(x))
                    End If
                    PropPX = (tCurrentxover(x) + CurrentXOver(x) - TempMax2)
                    PropP = PropP * PropPX
                    PropC = PropC * (tCurrentxover(x) + CurrentXOver(x) - TempMax2)
                    
                    If PropP > 0 Then
                        For Z = 1 To PropP
                            WorstP = 0
                            WorstOne = -1
                            For Y = 1 To tCurrentxover(x)
                                If TempXOList(x, Y).Probability > WorstP And TempXOList(x, Y).Accept <> 1 Then
                                    WorstP = TempXOList(x, Y).Probability
                                    WorstOne = Y
                                End If
                            Next Y
                            If WorstOne > -1 Then
                                If WorstOne <> tCurrentxover(x) Then
                                    Call AddToRedoList(TempXOList(x, WorstOne).ProgramFlag, TempXOList(x, WorstOne).Daughter, TempXOList(x, WorstOne).MajorP, TempXOList(x, WorstOne).MinorP)
                                    TempXOList(x, WorstOne) = TempXOList(x, tCurrentxover(x))
                                End If
                                tCurrentxover(x) = tCurrentxover(x) - 1
                            End If
                            If tCurrentxover(x) + CurrentXOver(x) < TempMax2 Then Exit For
                        Next Z
                    End If
                    
                    If PropC > 0 Then
                        For Z = 1 To PropC
                            WorstP = 0
                            WorstOne = -1
                            For Y = 1 To CurrentXOver(x)
                                If XoverList(x, Y).Probability > WorstP And XoverList(x, Y).Accept <> 1 Then
                                    WorstP = XoverList(x, Y).Probability
                                    WorstOne = Y
                                End If
                            Next Y
                            If WorstOne > -1 Then
                                If WorstOne <> CurrentXOver(x) Then
                                    Call AddToRedoList(XoverList(x, WorstOne).ProgramFlag, XoverList(x, WorstOne).Daughter, XoverList(x, WorstOne).MajorP, XoverList(x, WorstOne).MinorP)
                                    XoverList(x, WorstOne) = XoverList(x, CurrentXOver(x))
                                End If
                                CurrentXOver(x) = CurrentXOver(x) - 1
                            End If
                            If tCurrentxover(x) + CurrentXOver(x) < TempMax2 Then Exit For
                        Next Z
                    End If
                    
                    
                End If
            Next x
            'Loop
            
            
            MaxSize = 0
            For x = 0 To NextNo
                If tCurrentxover(x) + CurrentXOver(x) > MaxSize Then
                    MaxSize = tCurrentxover(x) + CurrentXOver(x)
                End If
            Next x
            XOSize = MaxSize + 10
        End If
        '$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'
        '$Make this more efficient
        '$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$
    '    If SEventNumber = 40 Then
    '        x = x
    '    End If
    '
    '    Call CheckNums(XoverList(), CurrentXOver())
    '
        For x = 0 To NextNo
               'If x = 27 Then
               ' x = x
                
               
               For Y = 1 To CurrentXOver(x)
               
                    tCurrentxover(x) = tCurrentxover(x) + 1
                    If tCurrentxover(x) > UBound(TempXOList, 2) Then
                        
                        XOSize = tCurrentxover(x) + 10
                        
                        If DebuggingFlag < 2 Then On Error Resume Next
                        TXOS = UBound(TempXOList, 1)
                        On Error GoTo 0
                        ''@'@'@'$'$'$
                        ReDim Preserve TempXOList(TXOS, XOSize)
                        UB = UBound(TempDone, 1)
                        ReDim Preserve TempDone(UB, XOSize)
                    
                    End If
                    
                    TempXOList(x, tCurrentxover(x)) = XoverList(x, Y)
                    
                                            
               Next Y
        Next x
        
         
        ReDim XoverList(UBound(XoverList, 1), 0)
        ReDim MaxXOP(AddNum - 1, NextNo)
        Call ResetMaxPVCO(NextNo)
        MXOSize = 0
        For x = 0 To NextNo
            If tCurrentxover(x) > MXOSize Then
                MXOSize = tCurrentxover(x)
            End If
        Next x
        XOSize = MXOSize
        'end section 14*********************************************
        '0.140
        
        '0.721 10 times more events
        'begin section 15*********************************************
        
        'now redim permxover and copy tempxover to permxover
        '
        XOSize = XOSize + 1
        
        
        '$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$
        ''$Check and see if this can be cleaned rather than redimmed?
        '$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$'$
        
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            '$'$
            ReDim PXOList(NextNo + RNum(WinPP) + 1, XOSize), PCurrentXover(NextNo + RNum(WinPP) + 1), NumRecsI(NextNo)
        Else
            ReDim PXOList(NextNo, XOSize), PCurrentXover(NextNo), NumRecsI(NextNo)
        End If
        '@
        Dim UBNRI As Long, UBTS2 As Long
        UBTS2 = UBound(TraceSub, 1)
        UBNRI = UBound(NumRecsI, 1)
        '@'@'@
        
        
        For x = 0 To NextNo
            PCurrentXover(x) = tCurrentxover(x)
            
            For Y = 1 To tCurrentxover(x)
                
                 
                
                PXOList(x, Y) = TempXOList(x, Y)
               
               
                
               
               
                DA = PXOList(x, Y).Daughter
                
                If DA > UBNRI Then
                    If DA <= UBTS2 Then
                        DA = TraceSub(DA)
                    Else
                        DA = -1
                    End If
                End If
                If DA > -1 Then
                    NumRecsI(DA) = NumRecsI(DA) + 1
                End If
                
                Ma = PXOList(x, Y).MajorP
                '$
                If Ma > UBNRI Then
                    If Ma <= UBTS2 Then
                        Ma = TraceSub(Ma)
                    Else
                        Ma = -1
                    End If
                End If
                
                
                Mi = PXOList(x, Y).MinorP
                If Mi > UBNRI Then
                    If Mi <= UBTS2 Then
                        Mi = TraceSub(Mi)
                    Else
                        Mi = -1
                    End If
                End If
                If Mi > -1 Then
                    NumRecsI(Mi) = NumRecsI(Mi) + 1
                End If
                
            Next Y
        Next x
        
        
        
        
        ReDim TempXOList(UBound(TempXOList, 1), 0)
        
        
        'end section 15*********************************************
        '0.531 5K perms
        '0.906
        
        '3.258 10X more events
        
        'Remove recombinant region from winner and make extra sequences
        
        'Find out whether it is necessary to redo former events in light of the fact that
        'the current event was previously used as a parent in the recombinant region.
        
        
        
        ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
        
        xNextno = NextNo
        
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            If PermNextno > 3000 Then 'need to do this to cut down on memory usage
                NextNo = NextNo + 1
                RNum(WinPP) = 0
                RList(WinPP, 0) = ISeqs(WinPP)
            Else
                NextNo = NextNo + RNum(WinPP) + 1
            End If
        
            GlobalMemoryStatus MemSit
            
            APhys = Abs(MemSit.dwTotalPhys)
            If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
            If DebuggingFlag < 2 Then On Error Resume Next
            ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
            'This is where I did a memory check - maybe resurrect at some point
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        '    If x = 1234567 Then
        '        If (Nextno * Len(StrainSeq(0)) * 40) > APhys Then
        '            If (NoRes <> 1) Then
        '                If CLine = "" Or CLine = " " Then
        '                    Response = MsgBox("Memory is running low.  Would you like to stop the exploratory so as to ensure that the program does not crash.  You can press the rescan button to finish the scan either after you free up more memory, or on another computer with more RAM.  If you press 'No' the scan will continue and RDP may/may not crash.", vbYesNo)
        '                Else
        '                    Response = 7
        '                End If
        '                PermResponse = Response
        '                If Response <> 7 Then
        '                    Nextno = xNextno
        '                    RNum(WinPP) = 1
        '                    RList(WinPP, 1) = ISeqs(WinPP)
        '                    Nextno = Nextno + RNum(WinPP) + 1
        '                    'Response = MsgBox("Memory is running low.  Would you like to stop the exploratory so as to ensure that the program does not crash.  You can press the rescan button to finish the scan either after you free up more memory, or on another computer with more RAM.  If you press 'No' the scan will continue and RDP may/may not crash.", vbYesNo)
        '                    AbortFlag = 1
        '                Else
        '                    NoRes = 1
        '                End If
        '            End If
        '        End If
        '    End If
            'begin section 16*********************************************
            On Error GoTo 0
        
            'On Error GoTo FAI
            '
            
            ReDim Preserve GrpMaskSeq(NextNo), TraceSub(NextNo), NumRecsI(NextNo)
            If UBound(SeqNum, 2) <> NextNo Then
                ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo)
            End If
            '$
            If UBound(MissingData, 2) <> NextNo Then
                ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
            End If
            ReDim Preserve SubMaskSeq(NextNo), ActualSeqSize(NextNo) ',SimSeqNum(Len(StrainSeq(0)), Nextno)
            
            If QvRFlag = 1 Then
                ReDim Preserve ReferenceList(NextNo)
            End If
            If NextNo > UBound(Relevant2, 2) Then
                ReDim Preserve Relevant2(2, NextNo)
            End If
        
            On Error GoTo 0
        
            For x = 0 To RNum(WinPP)
                TraceSub(NextNo - RNum(WinPP) + x) = TraceSub(RList(WinPP, x))
            Next x
        
            'Make extra sequences and delete bits from recombinants
            Dummy = ModSN(NextNo, Len(StrainSeq(0)), BPos, Epos, WinPP, RNum(0), RList(0, 0), Breaks(0, 0), SeqNum(0, 0), MissingData(0, 0))
            Dummy = ModSeqNumZ(NextNo, Len(StrainSeq(0)), BPos, Epos, WinPP, oRNum(0), oRList(0), oBreaks(0, 0), SeqNum(0, 0), MissingData(0, 0))
        Else
            ReDim Preserve GrpMaskSeq(NextNo), TraceSub(NextNo), NumRecsI(NextNo), SeqNum(Len(StrainSeq(0)), NextNo)
            ReDim Preserve SubMaskSeq(NextNo), ActualSeqSize(NextNo)   ',SimSeqNum(Len(StrainSeq(0)), Nextno)
            ReDim Preserve MissingData(Len(StrainSeq(0)), NextNo)
            If QvRFlag = 1 Then
                ReDim Preserve ReferenceList(NextNo)
            End If
            If NextNo > UBound(Relevant2, 2) Then
                ReDim Preserve Relevant2(2, NextNo)
            End If
        End If
        
        
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            If BPos < Epos Then
                TLen = Epos - BPos
            Else
                TLen = Len(StrainSeq(0)) - BPos + Epos
            End If
            'Dim DontAddSeqFlag As Byte
            'DontAddSeqFlag = 0
            'I should make it so that the extra sequences are not even made at the moment its easier to just erase these after they are made if they are either too small or the reassorment flag = 1
            If TLen / Len(StrainSeq(0)) < 0.01 Then
                'DontAddSeqFlag = 1
                For Y = xNextno + 1 To NextNo
                    For x = 0 To Len(StrainSeq(0))
                      SeqNum(x, Y) = 46
                    Next x
                Next Y
            End If
        End If
        'add to steps
        
        'If DontAddSeqFlag = 0 Then
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then 'dont make an extra sequence for extrahits or long sequences
            For x = 0 To RNum(WinPP)
                GoOn = 0
                For A = 0 To AddNum - 1
                    If WinnerPos(x, A) > 0 Then
                        
                        Steps(0, StepNo) = 1 'ie create a new sequence ....
                        Steps(1, StepNo) = RList(WinPP, x) 'using this seqence.....
                        Steps(2, StepNo) = Breaks(0, x) 'from this position....
                        Steps(3, StepNo) = Breaks(1, x) 'to this position....
                        Steps(4, StepNo) = SEventNumber + 1
                        StepNo = StepNo + 1
                        
                        UB = UBound(Steps, 2)
                        If StepNo > UB Then
                            ReDim Preserve Steps(4, UB + 100)
                        End If
                        GoOn = 1
                        Exit For
                    End If
                Next A
                If GoOn = 0 Or x = 12345 Then
                    Steps(0, StepNo) = 1 'ie create a new sequence ....
                    Steps(1, StepNo) = RList(WinPP, x) 'using this seqence.....
                    Steps(2, StepNo) = Breaks(0, x) 'from this position....
                    Steps(3, StepNo) = Breaks(1, x) 'to this position....
                    Steps(4, StepNo) = SEventNumber + 1
                    StepNo = StepNo + 1
                    
                    UB = UBound(Steps, 2)
                    If StepNo > UB Then
                        ReDim Preserve Steps(4, UB + 100)
                    End If
                End If
            Next x
        End If
        
        'End If
       ' XX = PermNextno
        'XX = RNum(WinPP)
        For x = 0 To oRNum(WinPP)
    '        If StepNo = 4969 Then
    '            x = x
    '            XX = SEventNumber
    '        End If
    '123
            Steps(0, StepNo) = 2 'ie delete a bit of sequence ....
            Steps(1, StepNo) = oRList(x)  'from this seqence.....
            Steps(2, StepNo) = oBreaks(0, x) 'from this position....
            Steps(3, StepNo) = oBreaks(1, x) 'to this position....
            Steps(4, StepNo) = SEventNumber + 1
            StepNo = StepNo + 1
            
            UB = UBound(Steps, 2)
            If StepNo > UB Then
                ReDim Preserve Steps(4, UB + 100)
            End If
        Next x
        
       
        'end section 16*********************************************
        '8.953 5K perms
        '0.090
        
        'Update Actualseqsize
        'begin section 17*********************************************
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            Dummy = MakeActualSeqSize(Len(StrainSeq(0)), NextNo, WinPP, RNum(0), RList(0, 0), ActualSeqSize(0), SeqNum(0, 0))
        Else
            Dim CurR As Long
            '@
            For x = 0 To RNum(WinPP)
                CurR = RList(WinPP, x)
                ActualSeqSize(CurR) = 0
                For Y = 1 To Len(StrainSeq(0))
                    If SeqNum(Y, CurR) <> 46 Then ActualSeqSize(CurR) = ActualSeqSize(CurR) + 1
                Next Y
            Next x
            
        End If
        'If X = X And SEventNumber = 70 Then
        '    Open "seqsize.csv" For Output As #1
        '    For X = 0 To PermNextNo
        '    'For X = PermNextNo To 0 Step -1
        '        Print #1, ActualSeqSize(X)
        '    Next X
        '    Close #1
        '    X = X
        'End If
        'end section 17*********************************************
        '25.486 5K perms
        '12.228 better array use
        '0.190 - using make actualseqsize
        
        'Make sure that
        '(1) ISeqs(rlist(winpp,winppy)) and nextno are not below the minimum acceptable
        'size setting - if it does don't add it
        '(2) nextno does not exceed the maxseqnum setting
        '    If it does boot out the smallest current seq
        'GoOn = 1
        
        'begin section 18*********************************************
        '@
        If BackUpNextno < NextNo Then
            ReDim Preserve SeqNum(Len(StrainSeq(0)), NextNo), TraceSub(NextNo), OriginalName(NextNo), MaskSeq(NextNo)
            If QvRFlag = 1 Then
                ReDim Preserve ReferenceList(NextNo)
            End If
            'Update the treedistance used for RDP and SiScan
            'If UBound(TreeDistance, 1) > 0 Then
            ReDim TreeDistance(NextNo, NextNo)
            'End If
        End If
        
        
       
        '0.040
        '1.828 500K reps
        
        'Update distances
        'we have values already calculated for:
        '(1) a set fo sequences that are uninvolved in recombination - ie sequences outside rlist
        'and sequences =< xnextno
        
        
        
        
        If PermNextno > MemPoc Then
        
            GetPermDiffs
            
            ReDim TDiffs(NextNo, NextNo)
            Dummy = MakeTDiffs2(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), PermDIffs(0, 0), Uninvolved(0), ActualSeqSize(0))
            
            ReDim PermDIffs(0, 0)
            
            GetPermValid
            
            ReDim TValid(NextNo, NextNo)
            Dummy = MakeTDiffs3(NextNo, UBound(PermValid, 1), TValid(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
            ReDim PermValid(0, 0)
        Else
            ReDim TDiffs(NextNo, NextNo), TValid(NextNo, NextNo)
             
            Dummy = MakeTDiffs(NextNo, UBound(PermDIffs, 1), TDiffs(0, 0), TValid(0, 0), PermDIffs(0, 0), PermValid(0, 0), Uninvolved(0), ActualSeqSize(0))
        
        End If
        'Why does his take so long? - it could be quicker (but more complicated) to
        'use sebdiffs and subvalids for sequences > last nexto with
        'sequences < lastnextno
        'I could also speed things up by keeping trackof the first and
        'last characters in the sequence strings and only looking between these
        
        ReDim Preserve Uninvolved(NextNo)
        
        For x = xNextno + 1 To NextNo
            Uninvolved(x) = 0
        Next x
        
        
        ReDim Distance(NextNo, NextNo)
        
        'ss = Abs(GetTickCount)
        'For X = 0 To 5000
        AvDst = 0
        TT = Abs(GetTickCount)
        If TT - GlobalTimer > 500 Then
          GlobalTimer = TT
          Form1.SSPanel1.Caption = "Modifying distances"
        'Form1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
        End If
        '**************************************************Try to further optimise this**********************************
        SS = Abs(GetTickCount)
        
        'If X = X Then
            Dim tRedoDist() As Integer, Invert(1) As Byte
            Invert(0) = 1
            Invert(1) = 0
            ReDim tRedoDist(NextNo)
            For x = 0 To NextNo
                tRedoDist(x) = Invert(Uninvolved(x))
                
            Next x
            
            
            Call FastDistanceCalcZ(1, 0, 1, Len(StrainSeq(0)), NextNo, TDiffs(), TValid(), SeqNum(), Distance(), AvDst, Udst, tRedoDist())
            
            ReDim PermDIffs(NextNo, NextNo), PermValid(NextNo, NextNo)
            'If X = X Then
                Dummy = FinishDists2(NextNo, PermValid(0, 0), PermDIffs(0, 0), TValid(0, 0), TDiffs(0, 0), Distance(0, 0))
    '        Else
    
    '        If PermNextno > MemPoc And x = 1234567 Then
    '            oDir = CurDir
    '            ChDir App.Path
    '            ChDrive App.Path
    '
    '            FF = FreeFile
    '            UBDistance = UBound(Distance, 1)
    '            Open "RDP5Distance" + UFTag For Binary As #FF
    '            Put #FF, , Distance()
    '            Close #FF
    '            DistanceInFileFlag = 1
    '            ReDim Distance(0, 0)
    '            ChDir oDir
    '            ChDrive oDir
    '        End If
            
            
            If PermNextno > MemPoc Then
                Call PutPermValid
                Call PutPermDiffs
            End If
            
    
    
        
        Erase TDiffs
        Erase TValid
        
         '*****************************************it can take up to 30 seconds**********************************
        
        DistanceFlag = 1
        
        'AbortFlag = 1
        
        
        'Next X
        'ee = Abs(GetTickCount)
        'tt = ee - ss
        'X = X
        '6.549
        
        
       
        'end section 18*********************************************
        '13.189
        '7.010 using distancecacw
        '6.870
        '7.291
        '7.011 - using maketdist
        '6.589 - uing makepermvalid
        '5.703 -dsktop
        
       
        'begin section 19*********************************************
      '  ss = Abs(GetTickCount)
      '  For X = 0 To 5000
        
        TreeDistFlag = 0
        
        Call UPGMA(StraiName(), TempNHF, SeqNum(), CLng(DistanceFlag), NodeLength(), TreeX(), TreeY(), AvDst, Decompress(), PermDIffs(), PermValid(), NextNo, Distance(), 0, 1)
        'XX = TreeDistance(1, 0)
        
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            If UBound(TreeDistance, 1) > 0 Then
                
                UBTD1 = UBound(TreeDistance, 1)
                Open "RDP5TreeDistance" + UFTag For Binary As #FF
                Put #FF, , TreeDistance
                Close #FF
                ReDim TreeDistance(0, 0)
                TempTreeDistanceDumpFlag = 1
            
                
            End If
            If TreeXInFileFlag = 0 And PermNextno > MemPoc Then
                TreeXUB = UBound(TreeX, 1)
                TreeXInFileFlag = 1
                Open "RDP5TreeX" + UFTag For Binary As #FF
                Put #FF, , TreeX()
                Close #FF
                Erase TreeX
            End If
            ChDrive oDirX
            ChDir oDirX
        End If
            
        
        
      ' Next X
      ' ee = Abs(GetTickCount)
      ' tt = ee - ss
      
        'end section 19*********************************************
        '2.824 5k perms
        '2.714 5 K perms
        '1.422 5K perms with addseqstoUPGMA
        '0.781 5k perms with treedist2
        'Begin section 20*********************************************
        
        'if the recombinant region fragment is added then scan it (ie seq1)
        'against the other sequences.
        ReDim MaxXOP(AddNum - 1, NextNo)
        Call ResetMaxPVCO(NextNo)
        ReDim CurrentXOver(NextNo)
        Call SignalCount(PXOList(), PCurrentXover())
        Call UpdateRecNums(SEventNumber)
        
        
        
        
        
        'change this - xosize can get VERY VERY BIG- must work on ways to keep xosize as small
        'as possible but must also reset the xoverlist size to something smaller
        oXOSize = XOSize
        XOSize = XOverListSize
        If NextNo > sNextno Then ReDim XoverList(NextNo, XOSize)
        XOSize = oXOSize
        If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            For x = NextNo - RNum(WinPP) To NextNo
                If TraceSub(x) <= NextNo Then
                    MaskSeq(x) = MaskSeq(TraceSub(x)): GrpMaskSeq(x) = GrpMaskSeq(TraceSub(x))
                Else
                    TraceSub(x) = x
                End If
            Next x
            If QvRFlag = 1 Then
                For x = NextNo - RNum(WinPP) To NextNo
                    If TraceSub(x) <= NextNo Then
                        ReferenceList(x) = ReferenceList(TraceSub(x))
                    Else
                        TraceSub(x) = x
                    End If
                Next x
            End If
            
            For x = NextNo - RNum(WinPP) To NextNo
                If ActualSeqSize(x) > MinSeqSize Then Exit For
            Next x
        End If
        
        
        If x <= NextNo And BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
            
            Call MakeSLookup(NextNo, IndividualA, IndividualB, ISeqs(), RNum(), MaskSeq(), TraceSub(), SLookup(), SLookupNum, ActualSeqSize())
            
        
            If SSOutlyerFlag = 2 Then
               Call GetOutie
               oSeq = Outie
            End If
            ReDim TSub(NextNo)
            For x = 0 To NextNo
               TSub(x) = x
            Next x
            
            b = 0
            
            VarA = (NextNo + 1)
            VarA = VarA * (NextNo) / 2
            VarA = VarA * (RNum(WinPP) + 1)
            SAll = Abs(GetTickCount)
            MCCorrectX = VarA
            SAll = Abs(GetTickCount)
    '        ReDim DoPairs(Nextno, Nextno)
    '        For X = 0 To Nextno
    '            For Y = 0 To Nextno
    '                DoPairs(X, Y) = 1
    '            Next Y
    '        Next X
    
    
            etxx = GetTickCount
            silly4 = silly4 + (etxx - stxxsilly4)
    
            stxx = GetTickCount
            'Call OuterScan3(MCCorrectX, SAll, sNextno, WinPP, SLookup(), ISeqs(), RNum(), RList(), TraceSub(), ActualSeqSize(), SLookupNum(), DoPairs(), 0, WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), BackUpNextno, MissingData())
            Call OuterScan4(STime, MCCorrectX, SAll, sNextno, WinPP, SLookup(), ISeqs(), RNum(), RList(), TraceSub(), ActualSeqSize(), SLookupNum(), DoPairs(), 0, WinNum, SeqMap(), ZPScoreHolder(), ZSScoreHolder(), CorrectP, oSeq, PermSScores(), PermPScores(), SScoreHolder(), PScoreHolder(), SeqScore3(), MeanPScore(), SDPScore(), Seq34Conv(), VRandConv(), VRandTemplate(), HRandTemplate(), TakenPos(), DG1(), DG2(), DoGroupS(), DoGroupP(), BackUpNextno, MissingData())
            etxx = GetTickCount
            'silly2 = 0
            silly2 = silly2 + etxx - stxx
            'Erase NumSeq
            'Erase Iseq4
            
            stxxsilly4 = GetTickCount
            
            ET = Abs(GetTickCount)
            Call UpdateTimeCaps(ET, SAll)
            For x = 0 To AddNum - 1
                MethodTime(x) = MethodTime(x) + Abs(ET - SAll) * TimeFract(x)
            Next x
            
            'Form1.SSPanel1.Caption = Trim(Str(MCcorrectX)) & " of " & Trim(Str(MCcorrectX)) & " triplets reexamined"
            'Form1.Refresh
            'Add events from xoverlist to pxolist
            Call CopyXOLists(XOSize, TempDone(), TempXOList(), PXOList(), PCurrentXover(), XoverList(), CurrentXOver(), NumRecsI())
        End If
        
        ReDim XoverList(UBound(XoverList, 1), 0)
        
           
        'end section 20*********************************************
        '7.952 5k perms
        '0.360 5k perms
        
            xNextno = NextNo
            'Check for any evidence in the new seqs
            If BusyWithExcludes = 0 And Len(StrainSeq(0)) < 100000 Then
                Call CheckDrop(ActualSeqSize(), Steps(), SEventNumber, StepNo, NextNo, oNextno, NumRecsI(), RedoListSize, RedoList())
                
                x = oNextno + 1
                
               
               
                Call DropSeqs(x, StepNo, NextNo, Steps(), RedoListSize, RedoList(), OriginalName(), MissingData(), SeqNum(), PermValid(), PermDIffs(), TempDone(), PXOList(), PCurrentXover(), TraceSub(), ActualSeqSize(), MinSeqSize, NumRecsI())
    
            End If
            
            If NextNo > -1 Then
                If NextNo < xNextno Then
    '                    If BusyWithExcludes = 1 Then
    '                        x = x
    '                    End If
                    
                        ReDim TValid(NextNo, NextNo)
                        Dummy = CopyFloatArray(NextNo, UBound(TValid, 1), UBound(PermValid, 1), PermValid(0, 0), TValid(0, 0))
                        ReDim PermValid(NextNo, NextNo)
                        '&'&
                        Dummy = CopyFloatArray(NextNo, UBound(PermValid, 1), UBound(TValid, 1), TValid(0, 0), PermValid(0, 0))
                        Erase TValid
                        '&
                        ReDim TDiffs(NextNo, NextNo)
                        Dummy = CopyFloatArray(NextNo, UBound(TDiffs, 1), UBound(PermDIffs, 1), PermDIffs(0, 0), TDiffs(0, 0))
                        ReDim PermDIffs(NextNo, NextNo)
                        Dummy = CopyFloatArray(NextNo, UBound(PermDIffs, 1), UBound(TDiffs, 1), TDiffs(0, 0), PermDIffs(0, 0))
                        Erase TDiffs
                        
                        If PermNextno > MemPoc Then
                            'XX = PermValid(0, 1)
                            Call PutPermValid
                            Call PutPermDiffs
                            ReDim PermValid(0, 0)
                            ReDim PermDIffs(0, 0)
                            
                        End If
                End If
                
                ReDim DoneSeq(NextNo, UBound(PXOList, 2))
                Dim UBTD As Long
                UBTD = UBound(TempDone, 2)
                
                For x = 0 To NextNo
                    For Y = 0 To PCurrentXover(x)
                        If Y <= UBTD Then
    '                        If TempDone(x, Y) = 1 Then
    '                            x = x
    '                        End If
                            '$'$
                            If PXOList(x, Y).OutsideFlag = 1 Then
                                If TempDone(x, Y) = 0 Then
                                    TempDone(x, Y) = 1
                                End If
                            End If
                            DoneSeq(x, Y) = TempDone(x, Y)
                        End If
                    Next Y
                Next x
            End If
    End If
    Eventnumber = Eventnumber + EventAdd
    
    If sNextno < NextNo Then
        ReDim Relevant(NextNo), Uninvolved(NextNo)
        ReDim TempXOList(NextNo, 0)
        TXOS = NextNo
    End If
    
    'ReDim TempXOList(UBound(TempXOList, 1), 0)
   etxx = GetTickCount
    silly5 = silly5 + (etxx - stxxsilly4)
    
Loop



End Sub
Public Sub TestMoveInTree(CompressSVSDFlag As Byte, Reps As Integer, BootFlag As Byte, BPos3 As Long, EPos3 As Long, SeqPair() As Byte, MinPair() As Byte, ISeqs() As Long, SeqNum() As Integer)
'XX = ISeqs(1)
'If Reps > 0 Then Reps = 30
Dim MDValS As Single, MDValF As Single, WinS As Long, WinF As Long, BestSeqS() As Long, BestSeqF() As Long
Dim oDirX As String, oDir As String, NameLen As Long, MyValue As Long, CurTot As Long, onN As Long, TempVal As Double, Y As Long, Z As Long, Dummy As Long, x As Long, TT As Long, ETx As Long, LmB As Long
Dim A As Long, b As Long, C As Long, D As Long, e As Long
Dim UBFM As Long, UBSM As Long
TT = Abs(GetTickCount)

XX = UBound(Distance)
XX = UBound(TreeDistance)

If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
    If Form1.SSPanel1.Caption = "" Then Form1.SSPanel1.Caption = "Testing for phylogenetic evidence of recombination"
    ETx = Abs(GetTickCount)
    Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))

 '
    If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
End If
 ' ' '
'Form1.SSPanel1.Refresh

Dim FF As Long
Dim ValidX() As Single, DiffsX() As Single, ListToRedo() As Long
Dim Cutoff As Double, tFCMat() As Single, tSCMat() As Single, TraceBak() As Single, OS As String
Dim TotAdd As Long
Dim DLen() As Single, Treebyte() As Byte, NodeDepth() As Integer, BootDepth() As Integer, ReplaceVal As Double, AvDX As Double, k As Long

Dim EraseF As Byte
Dim tSMat() As Single, tFMat() As Single, MinDist(1) As Double, Outlyer(2) As Long
Dim Valtot(1) As Long, MaxMD() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Px() As Integer, XX1() As Integer, XX2() As Integer
Dim LTree(1) As Long, FHolder() As Byte, SHolder() As Byte, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
Dim UB As Long, NSeqs As Long, TraceSeqs() As Long, tFAMat() As Single, tSAMat() As Single
Dim SCO As Long


If ISeqs(0) > NextNo Or ISeqs(1) > NextNo Or ISeqs(2) > NextNo Then
    MinPair(0) = 0
    MinPair(1) = MinPair(0)
    MinDist(0) = 0
    MinDist(1) = 0
    Exit Sub
End If


If EPos3 > Decompress(Len(StrainSeq(0))) Then EPos3 = Decompress(Len(StrainSeq(0)))
If BPos3 > Decompress(Len(StrainSeq(0))) Then BPos3 = Decompress(Len(StrainSeq(0)))

If EPos3 < 1 Then EPos3 = 1
If BPos3 < 1 Then BPos3 = 1

ReDim FCMat(0, 0), SCMat(0, 0)
ReDim SAMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0)
ReDim FAMat(0, 0)


'permvalids and permdiffs arrays are in memory when testmoveintree is loaded - they have been modified in the last parts
'of dordp and the small versions of the arrays need to be filled in here
'If SEventNumber = 15 Then
'    x = x
'End If
If UBound(PermValid, 1) > 0 Then

    
    
    If PermNextno > MemPoc Then
        'need to initialize permvalid and permdiffs on the disk
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        If UBound(PermValid, 1) > 0 Then
            
            Call PutPermValid
            ReDim PermValid(0, 0)
        End If
        If UBound(PermDIffs, 1) > 0 Then
            
            Call PutPermDiffs
            ReDim PermDIffs(0, 0)
        End If
        ChDrive oDirX
        ChDir oDirX
        
    End If
Else
x = x
End If
If PermNextno > MemPoc Then
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        'Erase TreeDistance
        TempTreeDistanceDumpFlag = 1
        ReDim TreeDistance(0, 0)
        ChDrive oDirX
        ChDir oDirX
    End If
    
End If


APhys = Abs(MemSit.dwTotalPhys)
'memload = Abs(MemSit.dwMemoryLoad)
If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
'APhys = CLng(APhys * ((100 - memload) / 100))

Cutoff = 50


'If DoQuick = 0 Then
'    Reps = 10
'Else
'    Reps = 0
'End If

LmB = Len(StrainSeq(0))
LmB = LmB * Reps
LmB = LmB * 32
If APhys < LmB Then
    Reps = CLng(Reps * (APhys / LmB))
End If


If BPos3 < EPos3 Then
    SCO = CLng((EPos3 - BPos3) / 2)
Else
    SCO = CLng((EPos3 + Len(StrainSeq(0)) - BPos3) / 2)
End If
If SCO > 20 Then SCO = 20

'Dim UBFM As Long

If DebuggingFlag < 2 Then On Error Resume Next
UBFM = 0
UBFM = UBound(FMat, 1)
On Error GoTo 0
If LongWindedFlag = 1 Then
    ReDim FMatSmall(2, NextNo)
    ReDim SMatSmall(2, NextNo)
    If SEventNumber > 0 Then
        
        
        If PermNextno > MemPoc Then

        Else
            If NextNo <> UBFM Then
                
                ReDim FMat(NextNo, NextNo)
                
                DontRedoQuickDistFlag = 0
            Else
                For x = 0 To NextNo
                    FMat(x, x) = 0
                Next x
            End If
        
        
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB = UBound(SMat, 1)
            
            
            On Error GoTo 0
            
            If NextNo <> UB Then
                
                
                ReDim SMat(NextNo, NextNo)
                
                DontRedoQuickDistFlag = 0
            Else
                For x = 0 To NextNo
                    SMat(x, x) = 0
                Next x
            End If
        
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(SubValid, 1)
            On Error GoTo 0
            If UB <> NextNo Then '1827,1827
                
                ReDim SubValid(NextNo, NextNo)
                ReDim SubDiffs(NextNo, NextNo)
                DontRedoQuickDistFlag = 0
            End If
        End If
    Else
        If PermNextno > MemPoc Then
            ReDim FMatSmall(2, NextNo)
            ReDim SMatSmall(2, NextNo)
        Else
            If DontRedoQuickDistFlag = 0 Then
                ReDim FMat(NextNo, NextNo)
                ReDim SMat(NextNo, NextNo)
                ReDim SubValid(NextNo, NextNo)
                ReDim SubDiffs(NextNo, NextNo)
                
            Else
                For x = 0 To NextNo
                    FMat(x, x) = 0
                    SMat(x, x) = 0
                Next x
            End If
        
        End If
    End If
    
    If LongFlag = 0 Then
        TT = Abs(GetTickCount)
        If TT - GlobalTimer > 500 Then
            GlobalTimer = TT
            If Right(Form1.SSPanel1.Caption, 9) <> "evidence)" Then
            ' '
                Form1.SSPanel1.Caption = "Calculating distances"
                ETx = Abs(GetTickCount)
                Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            End If
             ' ' '
            'Form1.SSPanel1.Refresh
            If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
             '
        End If
        UB = UBound(PermValid, 1)
        
        'SS = Abs(GetTickCount)
        
        If BPos3 <> BeginMark Or EPos3 <> EndMark Then
            If PermNextno > MemPoc Then
                
                Call GetPermValid
                
                Call GetPermDiffs
                
                ReDim FMat(NextNo, NextNo)
                
                'smat, subvalid and subdiffs are undimmed and are not used here - different halves of fmat,permvalid and permdiffs are used instead
                Dummy = vQuickDist2(Len(StrainSeq(0)), NextNo, UBPermValid, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0), ISeqs(0))
                
                ReDim PermDIffs(0, 0)
                ReDim PermValid(0, 0)
                
            Else
                
                Dummy = vQuickDist(Len(StrainSeq(0)), NextNo, UB, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0), ISeqs(0))
            End If
                
                
            
        End If
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS
        MinDist(0) = 1000000
        MinDist(1) = 1000000
        
        Outlyer(0) = 2
        Outlyer(1) = 1
        Outlyer(2) = 0
        Z = 0
        
        If ISeqs(0) > UBound(FMat, 1) Or ISeqs(1) > UBound(FMat, 1) Or ISeqs(2) > UBound(FMat, 1) Then
            MinPair(0) = 0
            MinPair(1) = MinPair(0)
            MinDist(0) = 0
            MinDist(1) = 0
            Exit Sub
        End If
        'XX = FMat(5, 3)
        If PermNextno > MemPoc Then
            'this section is needed because whenthere are >2000 sequences the version of vquickdist used puts values that
            'would have been added to smat into the bottom half of fmat.
            
               
                
                
            
            For x = 0 To 1
                For Y = x + 1 To 2
                
                    If ISeqs(x) < ISeqs(Y) Then
                        If FMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '2.04079 (4,5), 2.0144 (4,3),1.859 (5,3)
                            MinDist(0) = FMat(ISeqs(x), ISeqs(Y))
                            MinPair(0) = Z
                            SeqPair(0) = x
                            SeqPair(1) = Y
                            SeqPair(2) = Outlyer(Z)
                        End If
                        
                        If FMat(ISeqs(Y), ISeqs(x)) < MinDist(1) Then
                            MinDist(1) = FMat(ISeqs(Y), ISeqs(x))
                            MinPair(1) = Z
                        End If
                    Else
                        If FMat(ISeqs(Y), ISeqs(x)) < MinDist(0) Then '2.04079 (4,5), 2.0144 (4,3),1.859 (5,3)
                            MinDist(0) = FMat(ISeqs(Y), ISeqs(x))
                            MinPair(0) = Z
                            SeqPair(0) = x
                            SeqPair(1) = Y
                            SeqPair(2) = Outlyer(Z)
                        End If
                        
                        If FMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then
                            MinDist(1) = FMat(ISeqs(x), ISeqs(Y))
                            MinPair(1) = Z
                        End If
                    End If
                    Z = Z + 1
                Next Y
            Next x
        Else
            For x = 0 To 1
                For Y = x + 1 To 2
                    If FMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '2.04079 (4,5), 2.0144 (4,3),1.859 (5,3)
                        MinDist(0) = FMat(ISeqs(x), ISeqs(Y))
                        MinPair(0) = Z
                        SeqPair(0) = x
                        SeqPair(1) = Y
                        SeqPair(2) = Outlyer(Z)
                    End If
                    
                    If SMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then
                        MinDist(1) = SMat(ISeqs(x), ISeqs(Y))
                        MinPair(1) = Z
                    End If
                    Z = Z + 1
                Next Y
            Next x
        End If
            
        
        
        
        If MinPair(0) = MinPair(1) And ForcePhylE = 1 Then
            
            If DebuggingFlag < 2 Then On Error Resume Next
            'If UBound(SCMat, 1) <> Nextno Then
            If PermNextno > MemPoc Then
            
            Else
                ReDim FCMatSmall(2, NextNo), SCMatSmall(2, NextNo)
                ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo)
            End If
            On Error GoTo 0
           ' End If
            Exit Sub
        
        End If
    End If
    
    '0.021
    
    'ReDim SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo), SMat(NextNo, NextNo)
    
'    SS = Abs(GetTickCount)
    'For X = 1 To 1000
    If DontRedoQuickDistFlag = 0 Then
        'Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
        
        
        Dim AVD As Double, UDS As Double, tRedo() As Integer
        ReDim tRedo(NextNo)
        For x = 0 To NextNo
            tRedo(x) = 1
        Next x
'       XX = UBound(SMat, 1)
'       XX = UBound(SubValid, 1)
'       XX = UBound(SubDiffs, 1)
        If PermNextno > MemPoc Then
            ReDim SMat(NextNo, NextNo), SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo)
        End If
        Call FastDistanceCalcZ(1, 0, BPos3, EPos3, NextNo, SubDiffs(), SubValid(), SeqNum(), SMat(), AVD, UDS, tRedo())
'                EE = Abs(GetTickCount)
'
'                TT = EE - SS
'                SS = gettickcocunt
        
'                If NextNo <> UBound(PermValid, 1) Then
'                    x = x
'                End If
        
        Call MakeSmallArrays(ISeqs(), SubValid(), SubValidSmall())
        Call MakeSmallArrays(ISeqs(), SubDiffs(), SubDiffsSmall())
        
        If PermNextno > MemPoc And x = 1234567 Then
            Call GetPermValid
            
            Call GetPermDiffs
        
        End If
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            Call PutSMat
            ReDim SMat(0, 0)
            
            Call GetPermValid
            
            For x = 0 To UBSMat
                For Y = x + 1 To UBSMat
                    'FMat(Y, x) = SMat(x, Y)
                    PermValid(Y, x) = SubValid(x, Y)
                    
                Next Y
            Next x
            ''''''''''''''''''''''''''''''''''''''''''''''''''''
            'it would save time and effort to compress subvalid and subdiffs here (wouldnt need to write it to the disk and then retrieve it later
            '''''''''''''''''''''''''''''''''''''''''''''''''''
            
            Call PutSubValid
            ReDim SubValid(0, 0)
            
            Call GetPermDiffs
            
            For x = 0 To UBSMat
                For Y = x + 1 To UBSMat
                    PermDIffs(Y, x) = SubDiffs(x, Y)
                Next Y
            Next x
            Call PutSubDiffs
            ReDim SubDiffs(0, 0)
            If UBound(FMat, 1) <> NextNo Then
                Call GetFMat
            End If
            '@
            'this uses the top half of the matrix for the fscores and the bottom half for the s scores, subvalid and subdiffs can be dimmed to 0,0 because they are not used
            Dummy = FinishDists3(Len(StrainSeq(0)), NextNo, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0))
            
            'dont need to fix and resave permvalid or permdiffs because the version on disk didnt change
            
            ReDim PermValid(0, 0)
            ReDim PermDIffs(0, 0)

            Call GetSMat
            
            For x = 0 To UBound(SMat, 1) - 1
                For Y = x + 1 To UBound(SMat, 1)
                    SMat(Y, x) = FMat(Y, x)
                    SMat(x, Y) = SMat(Y, x)
                    FMat(Y, x) = FMat(x, Y)
                    
                Next Y
            Next x
            
            
            Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
            Call PutSMat
            ReDim SMat(0, 0)
            
            ChDrive oDirX
            ChDir oDirX
        Else
            '@'@
            Dummy = FinishDists(Len(StrainSeq(0)), NextNo, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0))
            Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())
            Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
        'XX = RedoListSize
        End If
    End If
    
    
    'if sequences are compressed the distances in the matrices must be adjusted to account for this.
'    XX = Len(StrainSeq(0))
'    SS = Abs(GetTickCount)
    If EPos3 > Len(StrainSeq(0)) Then
        ReDim Preserve Decompress(EPos3)
        Decompress(EPos3) = Decompress(Len(StrainSeq(0)))
    End If
    If BPos3 > Len(StrainSeq(0)) Then
        ReDim Preserve Decompress(BPos3)
        Decompress(BPos3) = Decompress(Len(StrainSeq(0)))
    End If
    
    
    'May need to be careful here with memory if given lots of long sequences
    If Decompress(EPos3) <> EPos3 Or Decompress(BPos3) <> BPos3 Then 'this corrects distances if there is compression
        TotAdd = 0
        If Decompress(EPos3) > Decompress(BPos3) Then
            
            For x = Decompress(BPos3) To Decompress(EPos3)
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
        Else
            For x = Decompress(BPos3) To Decompress(Len(StrainSeq(0)))
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
            For x = 1 To Decompress(EPos3)
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
        End If
        If PermNextno > MemPoc Then
            GetSubValid
            GetPermValid
            GetPermDiffs
            GetSubDiffs
            GetSMat
        End If
        '@
        For x = 0 To NextNo
            For Y = x + 1 To NextNo
                SubValid(x, Y) = SubValid(x, Y) + TotAdd
                SubValid(Y, x) = SubValid(x, Y)
                TempVal = PermValid(x, Y) - SubValid(x, Y)
                
                If TempVal > 0 Then
                    TempVal = (((TempVal - PermDIffs(x, Y)) - SubDiffs(x, Y)) / TempVal)
                    If TempVal > 0.25 Then
                        TempVal = (4 * TempVal - 1) / 3
                        TempVal = Log(TempVal)
                        FMat(x, Y) = -0.75 * TempVal
                        'x = x
                    Else
                        FMat(x, Y) = 10
                    End If
                Else
                    FMat(x, Y) = 10
                    
                End If
                FMat(Y, x) = FMat(x, Y)
                
                TempVal = SubValid(x, Y)
                
                If TempVal > 0 Then
                    TempVal = (TempVal - SubDiffs(x, Y)) / TempVal
                    If TempVal > 0.25 Then
                        TempVal = (4 * TempVal - 1) / 3
                        TempVal = Log(TempVal)
                        SMat(x, Y) = -0.75 * TempVal
                        x = x
                    Else
                        SMat(x, Y) = 10
                    End If
                Else
                    SMat(x, Y) = 10
                    
                End If
                SMat(Y, x) = SMat(x, Y)
            Next Y
            
   
        Next x
        
    End If
    
    
    
    '0.240
    
   
    
    
    'Which pair is most closely related in the backgound?
    For x = 0 To NextNo
        FMat(x, x) = 0
    Next x
'    If X = 12345 Then
'        Open "distmat.csv" For Output As #1
'
'        For X = 0 To Nextno
'            OS = ""
'
'            For Y = 0 To Nextno
'                If PermValid(X, Y) > 0 Or X = X Then
'                    OS = OS + " 0" + Trim(Str(CLng(FMat(X, Y) * 10000) / 10000))
'                Else
'                    OS = OS + " 0.0000"
'                End If
'            Next Y
'            Print #1, OS
'        Next X
'        Close #1
'
'        X = X
'    End If

'Else
'    ReDim xx1(3), xx2(3), Prod1(Len(StrainSeq(0))), Prod2(Len(StrainSeq(0))), Prod3(Len(StrainSeq(0))), Alias(Len(StrainSeq(0))), Ally(Len(StrainSeq(0))), Location(Len(StrainSeq(0))), Weight(0, Len(StrainSeq(0)))
End If
 
'SS = Abs(GetTickCount)
'For X = 0 To Nextno
'    For Y = X + 1 To Nextno
'        FMat(X, Y) = (CLng(FMat(X, Y) * 10000000)) / 10000000
'        FMat(Y, X) = FMat(X, Y)
'        SMat(X, Y) = (CLng(SMat(X, Y) * 10000000)) / 10000000
'        SMat(Y, X) = SMat(X, Y)
'    Next Y
'Next X
'
'
'EE = Abs(GetTickCount)
'TT = EE - SS
'X = X
 '
If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
'2,231 for 3200
'0.240

''Impute missing entries in distance matrices (ie with pernvalid/subvalid= 0)
''using a nearest neghbours method
'If X = 12345 And SEventNumber = 9 Then
'        Open "distmat.csv" For Output As #1
'        XX = CurDir
'        For X = 0 To PermNextno ' To 0 Step -1  'XXXX0 To
'            OS = ""
'
'            For Y = 0 To PermNextno    'xxxx 0 To
'                If SubValid(X, Y) > 0 Or X = X Then
'                    OS = OS + " 0" + Trim(Str(CLng(FMat(X, Y) * 10000) / 10000))
'                Else
'                    OS = OS + " 0.0000"
'                End If
'            Next Y
'            Print #1, OS
'        Next X
'        Close #1
'        X = X
'End If
'If SEventNumber = 80 Then
'    X = X
'End If



'Checkmatrix is a big problem - 4 nextno*nextno arrays will not work for >4k sequences
'    FF = FreeFile
'    Open "test highmem early.csv" For Append As #FF
'    Print #FF, "x,y,smat,fmat,permdiffs,permvalid"
'    For x = 0 To Nextno
'        For Y = 0 To Nextno
'            Print #1, Str(x) + "," + Str(Y) + "," + Str(SMat(x, Y)) + "," + Str(FMat(x, Y)) + "," + Str(PermValid(x, Y)) + "," + Str(SubValid(x, Y))
'        Next Y
'    Next x
'
'    Close #FF
If LongWindedFlag = 1 Then


    'fmat and smat entries are marked for later removal with a "3.0" in the matrix and a 3.0 on the fmat diagonal
    
    'checkmatrix uses smat but checkmatrix2 does not - i.e. it is OK to redim smat 0,0 above to save memory
    If PermNextno > MemPoc Then
        Call GetPermValid
        
        Call GetSubValid
        'NOTE SMat, FAMat and SAMat here can be dimmed to 0,0 - they are not accessed
        
        'Dummy = CheckMatrix2(UB, SCO, MinSeqSize, Nextno, Valtot(0), ISeqs(0), PermValid(0, 0), SubValid(0, 0), FMat(0, 0), SMat(0, 0), FAMat(0, 0), SAMat(0, 0))
        Call CheckMatrixX2(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat())
    
    Else
       ' Dummy = CheckMatrix(UB, SCO, MinSeqSize, Nextno, Valtot(0), ISeqs(0), PermValid(0, 0), SubValid(0, 0), FMat(0, 0), SMat(0, 0), FAMat(0, 0), SAMat(0, 0))
        Call CheckMatrixX(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat(), SMat())
        'highmem
        'ub = 90
        'sco=20
        'minseqsize = 83
        
        XX = ISeqs(0) '81
        XX = ISeqs(1) '16
        XX = ISeqs(2) '29
        XX = Valtot(0) '0
        
        XX = Valtot(1) '0
        'XX = UBound(Valtot, 1)
    End If
    
'     FF = FreeFile
'    Open "test highmem early.csv" For Append As #FF
'    Print #FF, "x,y,smat,fmat,permdiffs,permvalid"
'    For x = 0 To Nextno
'        For Y = 0 To Nextno
'            Print #1, Str(x) + "," + Str(Y) + "," + Str(SMat(x, Y)) + "," + Str(FMat(x, Y)) + "," + Str(PermValid(x, Y)) + "," + Str(SubValid(x, Y))
'        Next Y
'    Next x
'
'    Close #FF
    
    If PermNextno > MemPoc Then
        'drop permvalid and subvalid
        
        'dont need to resave permvalid and subvalid because they didnt change
        
        ReDim PermValid(0, 0)
        
        ReDim SubValid(0, 0)
        
        Call GetSMat
        
        For x = 0 To NextNo
            For Y = 0 To NextNo
                If FMat(x, Y) = 3 Then
                    SMat(x, Y) = 3
                End If
            Next Y
        Next x
    End If
    'Call CheckMatrixX(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat(), SMat())

End If



   


Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
If PermNextno > MemPoc Then
    If UBound(SMat, 1) > 0 Then
        Call PutSMat
        ReDim SMat(0, 0)
    End If
End If

If CompressSVSDFlag = 1 Then
    If PermNextno > MemPoc Then
        
        Call GetSubValid
        
        Call GetSubDiffs
        
    End If
    'compress subdiffs and subvalid
    Dim TSD() As Single, TSV() As Single
    ReDim TSD(2, NextNo), TSV(2, NextNo)
    '
    For x = 0 To 2
        For Y = 0 To NextNo
            TSD(x, Y) = SubDiffs(ISeqs(x), Y)
            TSV(x, Y) = SubValid(ISeqs(x), Y)
        Next Y
    Next x
    ReDim SubDiffs(2, NextNo), SubValid(2, NextNo)
    '@
    For x = 0 To 2
        For Y = 0 To NextNo
            SubDiffs(x, Y) = TSD(x, Y) ' = SubDiffs(ISeqs(X), Y)
            SubValid(x, Y) = TSV(x, Y) ' = SubValid(ISeqs(X), Y)
        Next Y
    Next x
    Erase TSD: Erase TSV
End If
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'End of part E
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'EE = Abs(GetTickCount)
'TT = EE - SS
'
'
'
'X = X
 '0.060
 
 
 
 '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Part F: treedistance and fmat used here - no reason to use fmat though - could just used ListToRedo instead
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'Make bAckup of Fmat (it is destroyed by neighbour)
ReDim TraceSeqs(1, NextNo)
ReDim ListToRedo(NextNo)




'use this code to remove masked sequences for extra speed
If IndividualA = -1 Then
    If UBound(MaskSeq) < NextNo Then ReDim Preserve MaskSeq(NextNo)
    For x = 0 To NextNo
        If MaskSeq(x) > 0 Then
            FMat(x, x) = 3
            ListToRedo(x) = 1
        ElseIf FMat(x, x) = 3 Then
            ListToRedo(x) = 1
        
        End If
    Next x
End If


NSeqs = -1
For x = 0 To NextNo
    If ListToRedo(x) = 0 Then
        NSeqs = NSeqs + 1
    End If
Next x
x = x


If NSeqs > 300 Then
    
    UBTD = UBound(TreeDistance, 1)
    If (UBTD <> UBTD1 And UBTD1 <> 0) Or UBTD = 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        ReDim TreeDistance(UBTD1, UBTD1)
        FF = FreeFile
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Get #FF, , TreeDistance
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        'Erase TreeDistance
        TempTreeDistanceDumpFlag = 1
    End If
    'remove irrelevant outlyers/inlyers
    Dim MAxD As Single, MinD As Single
    MAxD = 1: MinD = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If TreeDistance(ISeqs(x), ISeqs(Y)) < MAxD Then
                MAxD = TreeDistance(ISeqs(x), ISeqs(Y))
                A = ISeqs(x)
                b = ISeqs(Y)
            End If
            If TreeDistance(ISeqs(x), ISeqs(Y)) > MinD Then
                MinD = TreeDistance(ISeqs(x), ISeqs(Y))
                D = ISeqs(x)
                e = ISeqs(Y)
            End If
        Next Y
    Next x
    If A = D Or A = e Then
        A = b
    End If
    'XX = StraiName(A)
    'XX = StraiName(D)
    'XX = StraiName(E)
    'XX = StraiName(B)
    'XX = TreeDistance(A, D)
    'XX = TreeDistance(A, E)
    'XX = TreeDistance(D, E)
'    SS = Abs(GetTickCount)
    
    For x = 0 To NextNo
        If x <> A And x <> D And x <> e Then
            If ListToRedo(x) = 0 Then
                If TreeDistance(A, x) < MAxD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            'XX = StraiName(Y)
                            'XX = StraiName(X)
                            If ListToRedo(Y) = 0 Then
                                If TreeDistance(A, Y) = TreeDistance(A, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                End If
                If TreeDistance(D, x) > MinD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            If ListToRedo(Y) = 0 Then
                                If TreeDistance(D, Y) = TreeDistance(D, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                
                End If
                'XX = UBound(TreeDistance, 1)
                'XX = UBound(Distance)
                If TreeDistance(e, x) > MinD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            If ListToRedo(Y) = 0 Then
                                If TreeDistance(e, Y) = TreeDistance(e, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                
                End If
                
            End If
        End If
    
    Next x

End If






NSeqs = -1
For x = 0 To NextNo
    If ListToRedo(x) = 0 Then
        NSeqs = NSeqs + 1
        TraceSeqs(0, x) = NSeqs
        TraceSeqs(1, NSeqs) = x
    
    End If
Next x
'0.260
Rnd (-BSRndNumSeed)
onN = UBound(FMat, 1)
''''''''''''''''''''''''''''''''''''''''''''''
'End of Part F
''''''''''''''''''''''''''''''''''''''''''

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Start Part G: Uses: treedistance, FMat
'(but does not need to use fmat - fmat is only used to store info on which sequences will be diregarded)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If NSeqs > 300 Then
    Rnd (-BSRndNumSeed)
    'th reps=0 part will only get executed during the first of the two calls from dordp - in the second pass the "else" bit will be executed
    'this makes the datasets that are used to make famat, samat scmat and fcmat
    If Reps = 0 And x = 12345 Then
        'remove sequences from branches in tree between the inlyers and outlyer
        For x = 0 To NextNo
            If x <> A And x <> D And x <> e Then
                If ListToRedo(x) = 0 Then
                    If TreeDistance(D, x) > MAxD And TreeDistance(D, x) < MinD Then
                        For Y = x + 1 To NextNo
                            If Y <> A And Y <> D And Y <> e Then
                                'XX = StraiName(Y)
                                'XX = StraiName(X)
                                If ListToRedo(Y) = 0 Then
                                    If TreeDistance(D, Y) = TreeDistance(D, x) Then
                                        FMat(Y, Y) = 3
                                        ListToRedo(Y) = 1
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                    'and remove sequences between the outlyer and the MRCA of the inlyer and outlyer
                    If TreeDistance(A, x) > MAxD And TreeDistance(D, x) = TreeDistance(A, D) Then
                        For Y = x + 1 To NextNo
                            If Y <> A And Y <> D And Y <> e Then
                                'XX = StraiName(Y)
                                'XX = StraiName(X)
                                If ListToRedo(Y) = 0 Then
                                    If TreeDistance(A, Y) = TreeDistance(A, x) Then
                                        FMat(Y, Y) = 3
                                        ListToRedo(Y) = 1
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                    
                    
                End If
            End If
        
        Next x
        
        If PermNextno > MemPoc Then
            If UBound(TreeDistance, 1) > 0 Then
                UBTD1 = UBound(TreeDistance, 1)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "RDP5TreeDistance" + UFTag For Binary As #FF
                Put #FF, , TreeDistance
                Close #FF
                ReDim TreeDistance(0, 0)
                TempTreeDistanceDumpFlag = 1
                ChDrive oDirX
                ChDir oDirX
            End If
        End If
    
        NSeqs = -1
        'XX = UBound(ListToRedo)
        For x = 0 To NextNo
            If ListToRedo(x) = 0 Then
                NSeqs = NSeqs + 1
                TraceSeqs(0, x) = NSeqs
                TraceSeqs(1, NSeqs) = x
            
            End If
        Next x
        
        'drop treedistance if necessary
        
    
        'if there are still too many sequences then remove sequences at random untill only 100 remain
        If NSeqs > 100 Then
    
            CurTot = NSeqs
            Do
                MyValue = Int(onN * Rnd)
                If MyValue <> ISeqs(0) And MyValue <> ISeqs(1) And MyValue <> ISeqs(2) Then
                    'if treedistance(e,myvalue)
                    If ListToRedo(MyValue) = 0 Then
                        'If TreeDistance(A, Y) = TreeDistance(A, x)
                        FMat(MyValue, MyValue) = 3
                        ListToRedo(MyValue) = 1
                        CurTot = CurTot - 1
                        If CurTot = 100 Then Exit Do
                    End If
                End If
            Loop
        End If
    
    
    
    Else 'if reps>0 it means this is the second of the two calls from dordp
        
        If NSeqs > 300 Then 'randomly throw out sequences until ~300 remain
            CurTot = NSeqs
            Do
                MyValue = Int(onN * Rnd)
                If MyValue <> ISeqs(0) And MyValue <> ISeqs(1) And MyValue <> ISeqs(2) Then
                    If ListToRedo(MyValue) = 0 Then
                        FMat(MyValue, MyValue) = 3
                        ListToRedo(MyValue) = 1
                        CurTot = CurTot - 1
                        If CurTot = 300 Then Exit Do
                    End If
                End If
            Loop
        
        End If
    End If

    NSeqs = -1
    For x = 0 To NextNo
        If ListToRedo(x) = 0 Then
            NSeqs = NSeqs + 1
            TraceSeqs(0, x) = NSeqs
            TraceSeqs(1, NSeqs) = x
        
        End If
    Next x
End If


'''''''''''''''''''''''''''''''''''''''
'End of Part G
'''''''''''''''''''''''''''''''''''''''''

If NSeqs > 2 Then
    ReDim FAMat(0, 0)
    ReDim SAMat(0, 0)
    ReDim FCMatSmall(2, NextNo), FAMatSmall(2, NextNo), SCMatSmall(2, NextNo), SAMatSmall(2, NextNo)
    ReDim SHolder((NSeqs + 1) * 40 * 2), FHolder((NSeqs + 1) * 40 * 2)
Else
    MinPair(0) = MinPair(1)
    If DebuggingFlag < 2 Then On Error Resume Next
    ReDim FCMatSmall(2, NextNo), FAMatSmall(2, NextNo), SCMatSmall(2, NextNo), SAMatSmall(2, NextNo)
    If PermNextno > MemPoc Then
    
    Else
        
        ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo), FAMat(NextNo, NextNo), SAMat(NextNo, NextNo)
    
    End If
    On Error GoTo 0
    Exit Sub
End If

'0.260

''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Start of Part H: uses fmat to make tfmat
'''''''''''''''''''''''''''''''''''''''''''''''''''''
Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())

NameLen = Len(Trim$(CStr(NSeqs)))
If NameLen < 2 Then NameLen = 2
    
'SSSSs = abs(gettickcount)
'For XXX = 0 To 50

If NSeqs < 500 And PermNextno <= MemPoc Then
    
    ReDim FAMat(NextNo, NextNo)
    ReDim SAMat(NextNo, NextNo)
    ReDim tFAMat(NSeqs, NSeqs), tSAMat(NSeqs, NSeqs)
    'SS = abs(gettickcount)
    'For x = 1 To 50
   '@'@'@'@'@
   
   
    'Dummy = MakeNJTrees(NSeqs, NextNo, ISeqs(0), MinPair(0), SeqPair(0), BSRndNumSeed, NameLen, Len(StrainSeq(0)), UBound(TraceSeqs, 1), Outlyer(0), TraceSeqs(0, 0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0), UBound(FAMat, 1), FAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0), FHolder(0), SHolder(0), tFAMat(0, 0), tSAMat(0, 0))
    
    'Dim aSMat As Single
    Dummy = MakeNJTreesP(NSeqs, NextNo, ISeqs(0), MinPair(0), SeqPair(0), BSRndNumSeed, NameLen, Len(StrainSeq(0)), UBound(TraceSeqs, 1), Outlyer(0), TraceSeqs(0, 0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0), UBound(FAMat, 1), FAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0), FHolder(0), SHolder(0), tFAMat(0, 0), tSAMat(0, 0))
    
    
    
    Dim Samatb() As Single, Famatb() As Single
    
    'Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
    'Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
'    XXX = 0
'    yyy = 0
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            If tSAMat(x, Y) * 1000 > NextNo Then
'                x = x
'                XXX = XXX + 1 '46518
'            Else
'                yyy = yyy + 1 '4107
'            End If
'        Next Y
'    Next x
'    Dim TotS() As Long
'    ReDim TotS(50000)
'    For x = 0 To NextNo
'        For Y = x + 1 To NextNo
'            'XX = SAMat(x, Y)
'          TotS(tSAMat(x, Y) * 1000) = TotS(tSAMat(x, Y) * 1000) + 1
'
'        Next Y
'    Next x
'    For x = 0 To UBound(TotS)
'        If TotS(x) = 0 Then
'            x = x
'        Else
'            x = x
'            If TotS(x) > 64 Then
'                x = x
'            End If
'        End If
'    Next x
'    x = x
'    'Next x
    'EE = abs(gettickcount)
    '        TT = EE - SS '1.484; 1.015
            '2.609,2.609
            '63 seconds on this
'            TotFGCT = TotFGCT + TT
'            LoopENum = LoopENum + 1
'            Form1.Caption = Str(TotFGCT) + Str(LoopENum)
    '90.623 seconds
Else
    
    ReDim tFMat(NSeqs, NSeqs) 'the distance matrix that will be usued to make the tree (should be <500x500
    
    If x = 12345 Then
        Dummy = MaketFSMat(NextNo, UBound(FMat, 1), UBound(tFMat, 1), FMat(0, 0), tFMat(0, 0))
    Else
        If x = x Then
            Dummy = MaketFSMatL(NextNo, UBound(FMat, 1), UBound(tFMat, 1), FMat(0, 0), tFMat(0, 0), ListToRedo(0))
        Else
        '@
            A = 0
            b = 0
            For x = 0 To NextNo
        
                If ListToRedo(x) = 0 Then
                    tFMat(A, A) = 0
                    b = A + 1
        
                    For Y = x + 1 To NextNo
                        If ListToRedo(Y) = 0 Then
                            tFMat(A, b) = FMat(x, Y)
                            tFMat(b, A) = FMat(x, Y)
                            b = b + 1
                        End If
        
                    Next Y
                    A = A + 1
        
                End If
            Next x
        End If
    End If

    If PermNextno > MemPoc Then

        'drop FMat onto the disk
        FMatInFileFlag = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        UBF1 = UBound(FMat, 1)
    '    For x = 0 To Nextno
    '        For Y = 0 To Nextno
    '            If FMat(x, Y) > 0 Then
    '                x = x
    '            End If
    '        Next Y
    '    Next x
        If DontRedoQuickDistFlag = 0 Then
        Call PutFMat
        ReDim FMat(0, 0)
        End If
    
        
    End If
    
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'end of part H
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
        Dim TotMat() As Single, MaxSc As Double
        ReDim TotMat(NSeqs)
        
        For x = 0 To NSeqs
            For Y = x + 1 To NSeqs
                If tFMat(x, x) < 3 Then
                    If tFMat(Y, Y) < 3 Then
                        TotMat(x) = TotMat(x) + tFMat(x, Y)
                        TotMat(Y) = TotMat(Y) + tFMat(x, Y)
                    End If
                End If
            Next Y
        Next x
        MaxSc = 0
        For x = 0 To NSeqs
            If TotMat(x) > MaxSc Then
                Outie = x
                MaxSc = TotMat(x)
            End If
        Next x
    
    
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        ETx = Abs(GetTickCount)
        ' '
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
        'Form1.Refresh
        If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
        'DoEvents
    End If
    If AbortFlag = 1 Then Exit Sub
    
    ReDim tFAMat(0, 0)
    ReDim ColTotals(NSeqs)
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
    'nt1
    'LTree(0) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tFMat(0, 0), FHolder(0), ColTotals(0), tFMat(0, 0))
    LTree(0) = Clearcut(0, NSeqs, 1, 100, BSRndNumSeed, 1, UBound(tFMat, 1), tFMat(0, 0), FHolder(0))
    '
    '             Open "test5.tre" For Binary As #1
    '             'Put #1, , FHolder
    '             Put #1, , FHolder
    '             Close #1
    '
    'XX = CurDir
    Erase tFMat
    
    
    ReDim tFAMat(NSeqs, NSeqs)
    
    'SS = Abs(GetTickCount)
    'Call Tree2Array(1, NameLen, NSeqs, LTree(0), FHolder(), tFAMat())
    Dummy = Tree2ArrayP(1, NameLen, NSeqs, LTree(0), FHolder(0), UBound(tFAMat, 1), tFAMat(0, 0))
    
    'EE = Abs(GetTickCount)
    'TT = EE - SS '1.293 for 1410 seqs
    'X = X
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''
    'start of Part I: Makes FAMat from tFAMat: if number of sequences is large FAMat will be pretty sparse
    ''''''''''''''''''''''''''''''''''''''''''
    ReDim FAMat(NextNo, NextNo)
    
    If x = x Then
        Dummy = FtoFA(NSeqs, Len(StrainSeq(0)), UBound(TraceSeqs, 1), TraceSeqs(0, 0), UBound(tFAMat, 1), tFAMat(0, 0), UBound(FAMat, 1), FAMat(0, 0))
    Else
        
        For x = 0 To NSeqs
            For Y = x + 1 To NSeqs
                tFAMat(x, Y) = CLng(tFAMat(x, Y) * 10000) / 10000
                tFAMat(Y, x) = tFAMat(x, Y)
                FAMat(TraceSeqs(1, x), TraceSeqs(1, Y)) = tFAMat(x, Y)
                FAMat(TraceSeqs(1, Y), TraceSeqs(1, x)) = tFAMat(x, Y)
            Next Y
        Next x
    End If
    'this fills in any blanks in FAmat (in many cases only some of the sequences will be used to make famat)
    If x = x Then
        'dont use fmat here - use involved instead
        'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(FAMat, 1), FAMat(0, 0), FMat(0, 0))
        
        Dummy = CleanFCMat2P(NextNo, NextNo, UBound(FAMat, 1), FAMat(0, 0), ListToRedo(0))
    Else
        For x = 0 To NextNo
            If ListToRedo(x) = 1 Then
                For Y = 0 To NextNo
                    FAMat(x, Y) = ((NextNo * 3) - 1) / 1000
                    FAMat(Y, x) = ((NextNo * 3) - 1) / 1000
                    
                Next Y
            End If
        Next x
    End If
    
    'Use famat to make minpair 1
    MinDist(0) = 1000000
    Outlyer(0) = 2
    Outlyer(1) = 1
    Outlyer(2) = 0
    Z = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If FAMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '0.001 (4,5)
                MinDist(0) = FAMat(ISeqs(x), ISeqs(Y))
                MinPair(0) = Z
                SeqPair(0) = x
                SeqPair(1) = Y
                SeqPair(2) = Outlyer(Z)
            End If
            Z = Z + 1
        Next Y
    Next x
    
    For x = 0 To NextNo
        
        FAMat(x, x) = 0
       
    Next x
    
    
    If PermNextno > MemPoc Then
    'drop famat onto the disk
        Call PutFAMat
        ReDim FAMat(0, 0)
    End If
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'fAMat is still not finished here - it is lacking proper estinated values for many array entries - these get added in part L together with entries to SCMat
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'End of part I
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
     If AbortFlag = 1 Then Exit Sub
     
     
     
     ReDim ColTotals(NSeqs)
     TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        Form1.SSPanel1.Caption = "Making second NJ tree"
        ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
      '
     'Form1.SSPanel1.Refresh
     ' ' '
     'Form1.Refresh
     If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
    End If
     
     A = 0
    b = 0
    '0.260
    'SS = Abs(GetTickCount)
    ReDim tSMat(NSeqs, NSeqs)
    If PermNextno > MemPoc Then
        'get smat off the disk
        Call GetSMat
    End If
    'XX = UBound(SMat, 1)
    If x = 12345 Then
        Dummy = MaketFSMat(NextNo, UBound(SMat, 1), UBound(tSMat, 1), SMat(0, 0), tSMat(0, 0))
    Else
        If x = x Then
            Dummy = MaketFSMatL(NextNo, UBound(SMat, 1), UBound(tSMat, 1), SMat(0, 0), tSMat(0, 0), ListToRedo(0))
        Else
        
            For x = 0 To NextNo
        
                If ListToRedo(x) = 0 Then
                    tSMat(A, A) = 0
                    b = A + 1
                    For Y = x + 1 To NextNo
                        If ListToRedo(Y) = 0 Then
                            tSMat(A, b) = SMat(x, Y)
                            tSMat(b, A) = SMat(x, Y)
                            b = b + 1
                        End If
        
                    Next Y
                    A = A + 1
        
                End If
            Next x
        End If
    End If
    
    If PermNextno > MemPoc Then
        ReDim SMat(0, 0)
    End If
    
    
    ReDim tSAMat(0, 0)
    'If SEventNumber = 8 Then
    '    X = X
    'End If
    ' '
    'If SEventNumber = 46 Then
    '    X = X
    '    Open "bus1n.csv" For Output As #20
    '    For X = 0 To NSeqs
    '        For Y = X + 1 To NSeqs
    '            Print #20, Str(tSMat(0, 1))
    '        Next Y
    '    Next X
    '    Close #20
    '    X = X
    '    X = X
    'End If
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
    'nt2
    LTree(1) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tSMat(0, 0), SHolder(0), ColTotals(0), tSMat(0, 0))
    'LTree(1) = Clearcut(0,NSeqs, 1, 100, BSRndNumSeed, 1, UBound(tSMat, 1), tSMat(0, 0), SHolder(0))
    'XX = tSAMat(4, 5)
    x = x
    Erase tSMat
    'DoEvents
    'If SEventNumber = 8 Then
    '    X = X
    'End If
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Part J: Make SAMat
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ReDim tSAMat(NSeqs, NSeqs)
    '
    If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
    'Call Tree2Array(1, NameLen, NSeqs, LTree(1), SHolder(), tSAMat())
    Dummy = Tree2ArrayP(1, NameLen, NSeqs, LTree(1), SHolder(0), UBound(tSAMat, 1), tSAMat(0, 0))
    ReDim SAMat(NextNo, NextNo)
    If x = x Then
        Dummy = FtoFA(NSeqs, Len(StrainSeq(0)), UBound(TraceSeqs, 1), TraceSeqs(0, 0), UBound(tSAMat, 1), tSAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0))
    
    Else
        For x = 0 To NSeqs
            For Y = x + 1 To NSeqs
                tSAMat(x, Y) = CLng(tSAMat(x, Y) * 10000) / 10000
                tSAMat(Y, x) = tSAMat(x, Y)
                SAMat(TraceSeqs(1, x), TraceSeqs(1, Y)) = tSAMat(x, Y)
                SAMat(TraceSeqs(1, Y), TraceSeqs(1, x)) = tSAMat(x, Y)
            Next Y
        Next x
    End If
    '''''''''''''''''''''''''''''''''''''''''''''''''''
    'End of Part J
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'XX = SAMat(ISeqs(0), ISeqs(1))
    'X = X
    'XX = SEventNumber
    'XX = SAMat(ISeqs(2), 10)
    
     'Erase tSAMat
     'Outputs trees if you want these for debugging purposes
     
     
     
     ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
     'Part K - fill in all the blanks in SAMat
     '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' If X = X Then
        'dont use fmat here - use involved instead
        'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(SAMat, 1), SAMat(0, 0), FMat(0, 0))
       
        Dummy = CleanFCMat2P(NextNo, NextNo, UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0))
    ' Else
    '    For X = 0 To Nextno
    '        If ListToRedo(X) = 1 Then
    '            For Y = 0 To Nextno
    '
    '                SAMat(X, Y) = ((Nextno * 3) - 1) / 1000
    '                SAMat(Y, X) = ((Nextno * 3) - 1) / 1000
    '            Next Y
    '        End If
    '    Next X
    'End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'End of Part K
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
     '0.330
     '1.045 for 1834 seqs
    ' EE = Abs(GetTickCount)
    ' TT = EE - SS
     '1.544 for 3200
    'use SAMat to make minpair(1)
    MinDist(1) = 1000000
    Z = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If SAMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then '15-4 = 0.04, 15-11 = 0.014, 4-11=0.04
                MinDist(1) = SAMat(ISeqs(x), ISeqs(Y))
                MinPair(1) = Z
            End If
            Z = Z + 1
        Next Y
    Next x
    
    For x = 0 To NextNo
        
        SAMat(x, x) = 0
       
    Next x

End If

'Next XXX
'EEee = abs(gettickcount)
'TT = EEee - SSSSs '2781,2656 - fullc++,2360 with partial sections parallelization but with threadprivate for curtree
'x = x
If PermNextno > MemPoc Then
    'put samat onto the disk
    Call PutSAMat
    ReDim SAMat(0, 0)
    
End If




'exit if there is no phylogenetic evidence
If MinPair(0) = MinPair(1) And ForcePhylE = 1 Then
            
    If DebuggingFlag < 2 Then On Error Resume Next
    'If UBound(SCMat, 1) <> Nextno Then
    If PermNextno > MemPoc Then
    
    Else
        ReDim FCMatSmall(2, NextNo), SCMatSmall(2, NextNo)
        ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo)
    End If
    On Error GoTo 0
   ' End If
    Exit Sub

End If



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SAMat is still not finished here - it is lacking proper estinated values for many array entries - these get added in part L
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' EE = Abs(GetTickCount)
' TT = EE - SS
'
 '0.320
'  SS = Abs(GetTickCount)


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Part L: Uses dstmat (which cntains bootrep distances and could get as big as reps*500*500))
'it makes tscmat on a first pass and tfcmat on a second pass.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'reps refers to the number of bootstrap reps needed when making fcmat and scmat
'this part only gets executed in the second of 2 passes from dordp
 If Reps > 0 And BootFlag = 1 And (MinPair(1) <> MinPair(0) Or LongFlag = 1 Or ForcePhylE = 0) Then
     Dim tMatch() As Byte
     TT = Abs(GetTickCount)
     If TT - GlobalTimer > 500 Then
        GlobalTimer = TT
        Form1.SSPanel1.Caption = "Making bootstrapped NJ tree"
        ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
    End If
     oDir = CurDir
     If DebuggingFlag < 2 Then On Error Resume Next
 
     ChDir App.Path
     ChDrive App.Path
     On Error GoTo 0
     'Perform bootstrap replicates
     Dim tSeqNum2() As Integer, tSeqnum() As Integer, WeightMod() As Long, Scratch() As Integer, Length As Long
     Dim Treestring As String, DstMat() As Single, Num1() As Long, Num2() As Long, num() As Double
     'XX = StrainSeq(1)
     
     'this does not need to use fmat - it should use a small version of fmat
     'Dummy = MaketSeqNum(Len(StrainSeq(0)), NextNo, tSeqNum2(0, 0), SeqNum(0, 0), FMat(0, 0)
     Dim LoadSeqNumFromFile As Byte
     If ((Len(StrainSeq(0)) * NSeqs) > 20000000) Then  ' need to first create tseqnum on disk, then drop seqnum to disk, erase it, redim tseqnum and load it from disk
        Dim UBSN1 As Long, UBSN2 As Long
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqNum2(Len(StrainSeq(0))), tListToRedo(NextNo)
        Open "RDP5tSeqnum2" + UFTag For Binary As #FF
        For x = 0 To NextNo
            If ListToRedo(x) = 0 Then
                Dummy = MaketSeqNum2(Len(StrainSeq(0)), 0, tSeqNum2(0), SeqNum(0, x), tListToRedo(0))
                Put #FF, , tSeqNum2()
            End If
        Next x
        Close #FF
        LoadSeqNumFromFile = 1
        UBSN1 = UBound(SeqNum, 1)
        UBSN2 = UBound(SeqNum, 2)
        '@'@'@'@
        Open "RDP5SeqNumFile" + UFTag For Binary As #FF
        Put #FF, , SeqNum
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
        Erase SeqNum
        ReDim tSeqNum2(Len(StrainSeq(0)), NSeqs)
        Open "RDP5tSeqnum2" + UFTag For Binary As #FF
            Get #FF, , tSeqNum2()
        Close #FF
        Kill "RDP5tSeqnum2" + UFTag
     Else
        LoadSeqNumFromFile = 0
        ReDim tSeqNum2(Len(StrainSeq(0)), NSeqs)
        Dummy = MaketSeqNum2(Len(StrainSeq(0)), NextNo, tSeqNum2(0, 0), SeqNum(0, 0), ListToRedo(0))
     End If
     
     
     'Erase tSeqNum2
     
     
        
    
     'This part makes the identicalf and identical R arrays that are used by ViSRD
     'Call MakeConsenseFiles(NSeqs)
     '0.411
     Dim IdentiCalFX() As Long, IdenticalRX() As Long, BPos10 As Long, EPos10 As Long
'     XX = IdenticalF(Len(StrainSeq(0)))
     For x = 0 To 1
         FF = FreeFile
'         SS = Abs(GetTickCount)
         'Close #FF
         
         If x = 0 Then 'ie inner alignment
             Call MakeETSeqNum(NSeqs, Length, BPos3, EPos3, tSeqnum(), tSeqNum2())
             Call MakeNodeDepth(NSeqs, TraceBak(), tSAMat(), NodeDepth())
             
             BPos10 = BPos3
             EPos10 = EPos3
         Else
             Call MakeETSeqNum(NSeqs, Length, EPos3 + 1, BPos3 - 1, tSeqnum(), tSeqNum2())
             Erase tSeqNum2
             Call MakeNodeDepth(NSeqs, TraceBak(), tFAMat(), NodeDepth())
             BPos10 = EPos3 + 1
             If BPos10 > Len(StrainSeq(0)) Then BPos10 = 1
             EPos10 = BPos3 - 1
             If EPos10 < 1 Then EPos10 = Len(StrainSeq(0))
         End If
         
         ReDim IdentiCalFX(Len(StrainSeq(0))), IdenticalRX(Len(StrainSeq(0)))
         If BPos10 < EPos10 Then
            If BPos10 = 0 Then BPos10 = 1
            b = 1
            For A = BPos10 To EPos10
                IdentiCalFX(b) = IdenticalF(A) - IdenticalF(BPos10 - 1)
                b = b + 1
            Next A
            
            'find first non-identical site after bpos10
            For C = BPos10 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
            Next C
            b = 1
            For A = IdenticalF(C) To IdenticalF(EPos10)
                IdenticalRX(b) = IdenticalR(A) - (BPos10 - 1)
                b = b + 1
            Next A
        Else
            If BPos10 = 0 Then BPos10 = 1
            b = 1
            For A = BPos10 To Len(StrainSeq(0))
                IdentiCalFX(b) = IdenticalF(A) - IdenticalF(BPos10 - 1)
                b = b + 1
            Next A
            C = b - 1
            '@
            For A = 1 To EPos10
                If b <= UBound(IdentiCalFX, 1) Then
                    IdentiCalFX(b) = IdenticalF(A) + IdentiCalFX(C)
                Else
                    Exit For
                End If
                b = b + 1
            Next A
           
            'find first non-identical site after bpos10
            For C = BPos10 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
            Next C
            If C = Len(StrainSeq(0)) + 1 Then
                For C = 1 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
                Next C
                D = 0
            Else
                b = 1
                For A = IdenticalF(C) To IdenticalF(Len(StrainSeq(0)))
                    IdenticalRX(b) = IdenticalR(A) - (BPos10 - 1)
                    b = b + 1
                Next A
                D = b - 1
                For C = 1 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
                Next C
            End If
            b = 1
            '@
            For A = IdenticalF(C) To IdenticalF(EPos10)
            
                IdenticalRX(b) = IdenticalR(A) + IdenticalRX(D)
                b = b + 1
            Next A
            
            
        End If
         
         
         Call MakeTMatch(NSeqs, tMatch(), NodeDepth())
         
         
         
         ReDim WeightMod(Reps, Length - 1), Scratch(Length)
         
         '0.461
         '0.441
         
         
         'Dummy = SEQBOOT(BSRndNumSeed, Reps, Length, Scratch(0), WeightMod(0, 0))
         '@'@
         Dummy = SEQBOOT2(BSRndNumSeed, Reps, Length, Scratch(0), WeightMod(0, 0))
         
         '0.671
         '0.641
         
         
         
         TT = Abs(GetTickCount)
         If TT - GlobalTimer > 500 Then
          GlobalTimer = TT
            If x = 0 Then
                Form1.SSPanel1.Caption = "Making first set of bootsrap distance matrices"
                ETx = Abs(GetTickCount)
               Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            Else
                Form1.SSPanel1.Caption = "Making second set of bootsrap distance matrices"
                ETx = Abs(GetTickCount)
               Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            End If
         
         'Form1.SSPanel1.Refresh
         'Form1.Refresh
         
            If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
         End If
         SS = Abs(GetTickCount)
        ' For ZZ = 1 To 100
         '@
         Dim DstMat2() As Single
         ReDim ValidX(Reps), DiffsX(Reps), DstMat(Reps, NSeqs, NSeqs)
         'redim DstMat2(Reps, NSeqs, NSeqs)
         
'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
         'Dummy = FastBootDistIP(1, Reps, NSeqs, Length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqnum(0, 0), DstMat(0, 0, 0))
         Dummy = FastBootDistIP6(1, Reps, NSeqs, Length, DiffsX(0), ValidX(0), UBound(WeightMod, 1), UBound(WeightMod, 2), WeightMod(0, 0), UBound(tSeqnum, 1), UBound(tSeqnum, 2), tSeqnum(0, 0), UBound(DstMat, 1), UBound(DstMat, 2), DstMat(0, 0, 0))
        x = x
        'Next ZZ
         
         
'         For A = 0 To NSeqs
'            For b = 0 To NSeqs
'                For C = 0 To Reps
'                    If DstMat2(C, A, b) <> DstMat(C, A, b) Then
'                        x = x
'                    End If
'                Next C
'            Next b
'         Next A
         
         
        ' 307, 329 seconds with ip
        ' 447 seconds with ip7
        '@'@
         Erase tSeqnum
         
         If CurrentlyRunningFlag = 1 Then
            DoEvents
         End If
         
         If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
         
         
         '2.668 for 975 x 779 nt long seqs with 10 reps
         '86.175 for 975 X 11381 seqs with 10 reps
         x = x
         '0.873 for 3200
         '2.864
         '2.153 with fastbootdist
         '2.144,1.933, 1.913, 1.883, 1.882
         
         
         If AbortFlag = 1 Then Exit For
         ReDim DLen(NSeqs)
         
'         SS = abs(gettickcount)
'         For ZZ = 0 To 100
'
         If x = x Then
            'ReDim tFMat(NSeqs, NSeqs),
            'SS = abs(gettickcount)
            '@'@'@
             Dummy = TreeRepsP(NSeqs, Reps, BSRndNumSeed, NameLen, DstMat(0, 0, 0), 0, LTree(0), tMatch(0, 0), DLen(0))
'            EE = abs(gettickcount)
'            TT = EE - SS '1.484; 1.015
'            '2.609,2.609
'            '63 seconds on this
'            TotFGCT = TotFGCT + TT
'            Form1.Caption = TotFGCT
'            For ZZ = 0 To NextNo
'                XX = DLen(ZZ)
'                If DLen(ZZ) > 0 Then
'                    x = x
'                End If
'            Next ZZ
            x = x
         Else
             Dim FT As Long
             ReDim tFMat(NSeqs, NSeqs)
             
             For Y = 1 To Reps
                 
                 FT = Abs(GetTickCount)
                 If Abs(FT - GlobalTimer) > 500 Then
                     
                     GlobalTimer = FT
                     '
                     Form1.SSPanel1.Caption = Trim(Str(Y + (x * 10))) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
                     Call UpdateF2Prog
                     'Form1.SSPanel1.Refresh
                     'Form1.Refresh
                     
                     '
                    If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
                End If
                 If AbortFlag = 1 Then
                     Close #FF
                     Exit For
                 End If
                 ReDim FHolder(NSeqs * 40 * 2)
                 
                 Dummy = TransferDistP(NSeqs, Y, Reps, tFMat(0, 0), DstMat(0, 0, 0))
                 'ReDim ColTotals(NSeqs)
                 'SS = Abs(GetTickCount)
                 '
    '             LTree(0) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tFMat(0, 0), FHolder(0), ColTotals(0), tFAMat(0, 0))
                 x = x
                 
                 LTree(0) = Clearcut(0, NSeqs, 1, 100, BSRndNumSeed, 0, UBound(tFMat, 1), tFMat(0, 0), FHolder(0))
    '             For YY = 0 To UBound(FHolder, 1)
    '                If FHolder(YY) <> 0 Then
    '                    x = x
    '                End If
    '             Next YY
'                 Open "test2.tre" For Binary As #1
'                 Put #1, , FHolder
'                 Close #1
                 x = x
                 '2.965
                 'XX = tFMat(1, 0)
                'XX = UBound(FHolder, 1)
                'XX = PermNextno
                
                If AbortFlag = 1 Then
                     Close #FF
                     Exit For
                 End If
                 'Call TreeGroups(NSeqs, FHolder(), LTree(0), NameLen, tMatch(), DLen())
                
                 Dummy = TreeGroupsXP(NSeqs, FHolder(0), LTree(0), NameLen, tMatch(0, 0), DLen(0))
                 
'                 For ZZ = 0 To NextNo
'                    If DLen(ZZ) > 0 Then
'                        x = x
'                    End If
'                 Next ZZ
                 
                 If AbortFlag = 1 Then
                     Close #FF
                     Exit For
                 End If
                 TT = Abs(GetTickCount)
                If TT - GlobalTimer > 500 Then
                   GlobalTimer = TT
                   Form1.SSPanel1.Caption = Trim(Str(Reps * x + (Y / Reps * 10))) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
                   If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
                End If
             Next Y
         End If
'         Next ZZ
'         EE = abs(gettickcount)
'         TT = EE - SS '3563 VB, 3609 - C++ non-parallel:1234 parallel
'
'         '
'         TT = Abs(GetTickCount)
         If TT - GlobalTimer > 500 Then
            GlobalTimer = TT
            Form1.SSPanel1.Caption = Trim(Str(Reps * 2)) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
            If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
         End If
         If AbortFlag = 1 Then
            
            Exit For
         End If
         
         Erase DstMat
         
         '3.555
         '3.075
         
         For Z = 0 To NSeqs
              DLen(Z) = CLng((DLen(Z) + 1) / (Reps + 1) * 100)
              'X = X '100,100,100,100,82,82,100,100,64,100,100,100,55
         Next Z
         'Collapse nodes in FAMat/SAMat with no support - Put these in FCMat and SCMat
         'famat/samat = tree distance matrices - not path lengths but an encoding of
         'the rooted tree topology in a distance matrix
         'fcmat/scmat = tree distance matrices with nodes collapsed
         'Dlen = array containing bootstrap support for nodes
         'tracebak = contains an encoding of the tree topology - ie tells you which node corrsponds to which
         'distance in samat/famat
         ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
         If x = 0 Then
             Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tSAMat(), tSCMat())
             Erase tSAMat
             ReDim SCMat(NextNo, NextNo)
             '@'@
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    SCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tSCMat(Z, Y)
                    SCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tSCMat(Z, Y)
                Next Y
            Next Z
            
            Erase tSCMat
            
            'this does not need to use fmat - it should use listtoredo
            'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(SCMat, 1), SCMat(0, 0), FMat(0, 0))
            Dummy = CleanFCMat2(NextNo, NextNo, UBound(SCMat, 1), SCMat(0, 0), ListToRedo(0))

            ReDim BestSeqS(NextNo)
            
            For Z = 0 To NextNo
                BestSeqS(Z) = Z
            Next Z
            If PermNextno > MemPoc Then
                'get smat off the disk
                
                Call GetSMat
            End If
            Dummy = FindBesSeqS(NextNo, ListToRedo(0), SMat(0, 0), BestSeqS(0))
            
            If PermNextno > MemPoc Then
                ReDim SMat(0, 0)
                'load samat off the disk
                Call GetSAMat
            End If
            
            '@
            Dummy = ReAddDistsB(NextNo, ListToRedo(0), SAMat(0, 0), SCMat(0, 0), BestSeqS(0))
            Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
            Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
            If PermNextno > MemPoc Then
                
                Call PutSCMat
                ReDim SCMat(0, 0)
                
                'drop SAMat and SCMat back onto the disk
                
                Call PutSAMat
                ReDim SAMat(0, 0)
                
                
            End If
         Else
             
             Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tFAMat(), tFCMat())
             Erase tFAMat
             ReDim FCMat(NextNo, NextNo)
             ReDim FCMatSmall(2, NextNo)
             '@
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    '
                    FCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tFCMat(Z, Y)
                    FCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tFCMat(Z, Y)
                Next Y
            Next Z
            
        
            Erase tFCMat
            'dont use fmat here - its shitty - use a smaller array
            XX = UBound(FMat, 1)
            'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), FMat(0, 0))
            Dummy = CleanFCMat2(NextNo, NextNo, UBound(FCMat, 1), FCMat(0, 0), ListToRedo(0))

            ReDim BestSeqF(NextNo)
            For Z = 0 To NextNo
                BestSeqF(Z) = Z
            Next Z
            If PermNextno > MemPoc Then
                'get fmat off the disk
                Call GetFMat
            End If
            Dummy = FindBesSeqS(NextNo, ListToRedo(0), FMat(0, 0), BestSeqF(0))
            
            If PermNextno > MemPoc Then
                ReDim FMat(0, 0)
            End If
            If PermNextno > MemPoc Then
                'load famat off the disk
                Call GetFAMat
            End If
            
            Dummy = ReAddDistsB(NextNo, ListToRedo(0), FAMat(0, 0), FCMat(0, 0), BestSeqF(0))
            
            Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
            Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
            If PermNextno > MemPoc Then
                'drop fCMat back onto the disk
                Call PutFCMat
                ReDim FCMat(0, 0)
                
            End If
            If PermNextno > MemPoc Then
                'drop fAMat  onto the disk
                Call PutFAMat
                ReDim FAMat(0, 0)
                
            End If

         End If
         '3.075
         
     Next x
     'Exit Sub
     '9.794
     '8.813
      'Exit Sub
     
     'ReDim FCMat(Nextno, Nextno), SCMat(Nextno, Nextno)
     If AbortFlag = 1 Then
        
        
        If LoadSeqNumFromFile = 1 Then
            
            ReDim SeqNum(UBSN1, UBSN2)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5SeqNumFile" + UFTag For Binary As #FF
            Get #FF, , SeqNum
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        If UBound(FCMat, 1) = 0 Then
            ReDim FCMatSmall(2, NextNo)
        End If
        If UBound(SCMat, 1) = 0 Then
            ReDim SCMatSmall(2, NextNo)
        End If
        If PermNextno > MemPoc Then
        
        Else
            If UBound(FCMat, 1) = 0 Then
                ReDim FCMat(NextNo, NextNo)
            End If
            
            If UBound(SCMat, 1) = 0 Then
                ReDim SCMat(NextNo, NextNo)
            End If
            
        End If
        On Error GoTo 0
        Exit Sub
     End If
     
     
     ' This is where guestimated values were readded to FAMat, FCmat, SAMat and SCMat
     
     
     'If x = x Then
'        Dummy = CleanSCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), SCMat(0, 0), FMat(0, 0))
        
'     Else
'
'        For x = 0 To NextNo
'            If FMat(x, x) = 3 Then
'                For Y = 0 To NextNo
'                    FCMat(x, Y) = ((NextNo * 3) - 1) / 1000
'                    FCMat(Y, x) = FCMat(x, Y)
'                    SCMat(x, Y) = ((NextNo * 3) - 1) / 1000
'                    SCMat(Y, x) = SCMat(x, Y)
'                Next Y
'            End If
'
'        Next x
'        For x = 0 To NextNo
'            For Y = x + 1 To NextNo
'                FCMat(x, Y) = (CLng(FCMat(x, Y) * 10000000)) / 10000000
'                FCMat(Y, x) = FCMat(x, Y)
'                SCMat(x, Y) = (CLng(SCMat(x, Y) * 10000000)) / 10000000
'                SCMat(Y, x) = SCMat(x, Y)
'            Next Y
'        Next x
'    End If
     If DebuggingFlag < 2 Then On Error Resume Next
     ChDir oDir
     ChDrive oDir
     On Error GoTo 0
     
 Else
     'this is where things go on the first of 2 passes from do rdp
     'XX = UBound(Distance, 1)
     Erase tSeqNum2
     Erase tSeqnum
     
     'Erase MinP
     'XX = UBound(Daught, 2)
    
     
        ReDim BestSeqS(NextNo)
            
        For Z = 0 To NextNo
            BestSeqS(Z) = Z
        Next Z
        If PermNextno > MemPoc Then
            'get smat off the disk
            
            Call GetSMat
        End If
        Dummy = FindBesSeqS(NextNo, ListToRedo(0), SMat(0, 0), BestSeqS(0))
        
        If PermNextno > MemPoc Then
            ReDim SMat(0, 0)
            'load samat off the disk
            Call GetSAMat
        End If
        '@
        Dummy = ReAddDistsB(NextNo, ListToRedo(0), SAMat(0, 0), SCMat(0, 0), BestSeqS(0))
        Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
        Call MakeSmallArrays(ISeqs(), SAMat(), SCMatSmall())
        
        
        If PermNextno > MemPoc Then
           oDirX = CurDir
           ChDrive App.Path
           ChDir App.Path
           FF = FreeFile
           UBSCMat = UBound(SAMat, 1)
           Open "RDP5SCMat" + UFTag For Binary As #FF
           Put #FF, , SAMat
           Close #FF
          
           ReDim SCMat(0, 0)
           
           
           ChDrive oDirX
           ChDir oDirX
        Else
            ReDim SCMat(NextNo, NextNo)
            For x = 0 To NextNo
                For Y = 0 To NextNo
                    SCMat(x, Y) = SAMat(x, Y)
                Next Y
            Next x
        End If
        
        
        
     ReDim BestSeqF(NextNo)
            
        For Z = 0 To NextNo
            BestSeqF(Z) = Z
        Next Z
        If PermNextno > MemPoc Then
            'get smat off the disk
            
            Call GetFMat
        End If
        Dummy = FindBesSeqS(NextNo, ListToRedo(0), FMat(0, 0), BestSeqF(0))
        
        If PermNextno > MemPoc Then
            ReDim FMat(0, 0)
            'load samat off the disk
            Call GetFAMat
        End If
        '@
        Dummy = ReAddDistsB(NextNo, ListToRedo(0), FAMat(0, 0), FCMat(0, 0), BestSeqF(0))
        Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
        Call MakeSmallArrays(ISeqs(), FAMat(), FCMatSmall())
        
        
     
     
     If PermNextno > MemPoc Then
        'drop fCMat back onto the disk
        '@
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        'Call MakeSmallArrays(ISeqs(), FAMat(), FCMatSmall()) 'this looks wrong but it must be famat - look carefully
        UBFCMat = UBound(FAMat, 1)
        Open "RDP5FCMat" + UFTag For Binary As #FF
        Put #FF, , FAMat
        Close #FF
        PutFAMat
        ReDim FCMat(0, 0)
        ReDim FAMat(0, 0)
        ChDrive oDirX
        ChDir oDirX
     Else
        ReDim FCMat(NextNo, NextNo)
        For x = 0 To NextNo
            For Y = 0 To NextNo
                FCMat(x, Y) = FAMat(x, Y)
            Next Y
        Next x
     End If
     
     
     If UBound(FAMat, 1) = NextNo And UBound(FAMat, 2) = NextNo And UBound(SAMat, 1) = NextNo And UBound(SAMat, 2) = NextNo And PermNextno > MemPoc Then
     'do the array copy on disk rather than in actual memory (ie copying famat to fcmat and samat to scmat)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
        
        
        Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
        
        
        ChDrive oDirX
        ChDir oDirX
     Else
        UBFM = UBound(FMat, 1)
        If UBFM > NextNo Then
            Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())
        End If
        UBSM = UBound(SMat, 1)
        If UBSM > 1 Then
            Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
        End If
        '@
        If PermNextno > MemPoc Then
           oDirX = CurDir
           ChDrive App.Path
           ChDir App.Path
           UBFM = UBound(FMat, 1)
           UBSM = UBound(SMat, 1)
           If UBFM > 0 Then
                Call PutFMat
                ReDim FMat(0, 0)
           End If
           If UBSM > 0 Then
                UBSMat = UBSM
                Open "SMat" + UFTag For Binary As #FF
                Put #FF, , SMat
                Close #FF
                ReDim SMat(0, 0)
            End If
           
            ChDrive oDirX
            ChDir oDirX
        
        
        Else
            ReDim FCMat(NextNo, NextNo)
        End If
        If PermNextno > MemPoc And UBound(FAMat, 1) = 0 And UBFAMat = NextNo Then
            Call GetFAMat
        Else
            ReDim FAMat(NextNo, NextNo)
        End If
        If UBound(FAMat, 1) = NextNo Then
            Dummy = CopyFloatArray(NextNo, UBound(FCMat, 1), UBound(FAMat, 1), FAMat(0, 0), FCMat(0, 0))
        End If
        FF = FreeFile
        
        Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
        Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
           Open "FCMat" + UFTag For Binary As #FF
           Put #FF, , FCMat
           Close #FF
           ReDim FCMat(0, 0)
           
           Open "FAMat" + UFTag For Binary As #FF
           Put #FF, , FAMat
           Close #FF
           ReDim FAMat(0, 0)
           ChDrive oDirX
            ChDir oDirX
        End If
        ReDim SCMat(NextNo, NextNo)
        
        If PermNextno > MemPoc Then
            Call GetSAMat
        End If
        
        If UBound(SAMat, 1) <> NextNo Then
            ReDim SAMat(NextNo, NextNo)
        End If
        '@
        If UBound(SAMat, 1) = NextNo Then
            Dummy = CopyFloatArray(NextNo, UBound(SCMat, 1), UBound(SAMat, 1), SAMat(0, 0), SCMat(0, 0))
        End If
        Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
        Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
        'need to do some memory gymnastics
        If PermNextno > MemPoc Then
           Call PutSCMat
           ReDim SCMat(0, 0)
           
           Call PutSAMat
           ReDim SAMat(0, 0)
        
           'UBFM = UBound(FMat, 1)
           'UBSM = UBound(SMat, 1)
'           ReDim FMat(UBFM, UBFM)
'           FF = FreeFile
'           Open "FMat" + UFTag For Binary As #FF
'           Get #FF, , FMat
'           Close #FF
'
'           ReDim SMat(UBSM, UBSM)
'           Open "SMat" + UFTag For Binary As #FF
'           Get #FF, , SMat
'           Close #FF

        End If
     End If
     
 End If
'
'EE = Abs(GetTickCount)
'    TT = EE - SS
'For x = 0 To NextNo
'    For Y = 0 To NextNo
'        If SCMat(x, Y) <> SAMat(x, Y) Then
'            x = x
'        End If
'    Next Y
'Next x

x = x

'Make sure diagonals = 0


If PermNextno > MemPoc Then
    If UBound(TreeDistance, 1) > 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        ChDrive oDirX
        ChDir oDirX
    End If
End If



If LoadSeqNumFromFile = 1 Then
    If CompressSVSDFlag = 1 Then
        Erase TreeY
        Erase SeqText
    End If
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    
    
    If TreeXInFileFlag = 1 Then
        Erase TreeX
    End If
    If DebuggingFlag < 3 Then On Error Resume Next
    UB = -1
    ReDim SeqNum(UBSN1, UBSN2)
    UB = UBound(SeqNum, 1)
    On Error GoTo 0
    If UB = -1 Then
        If UBound(SCMat, 2) > 0 Then
            Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
            Call PutSCMat
            ReDim SCMat(0, 0)
        End If
        If UBound(FCMat, 1) > 0 Then
            Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
            Call PutFCMat
            ReDim FCMat(0, 0)
        End If
        ReDim SeqNum(UBSN1, UBSN2)
    End If
    Open "RDP5SeqNumFile" + UFTag For Binary As #FF
    Get #FF, , SeqNum
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
    
End If
'force minpair(0) to be different to minpair(1)
'If ReassortmentFlag = 1 Then
'    MinPair(0) = 0
'    MinPair(1) = 1
'End If

If (CLine <> "" And CLine <> " ") Then
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole vbClearLine
    
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole "Evidence of" & Str(SEventNumber) & " unique recombination events detected (" + Trim(Str(oRecombNo(100))) & " recombination signals remaining)       "
End If


End Sub
Public Sub TestMoveInTreeAlt(CompressSVSDFlag As Byte, Reps As Integer, BootFlag As Byte, BPos3 As Long, EPos3 As Long, SeqPair() As Byte, MinPair() As Byte, ISeqs() As Long, SeqNum() As Integer)
'XX = ISeqs(1)
'If Reps > 0 Then Reps = 30
Dim MDValS As Single, MDValF As Single, WinS As Long, WinF As Long, BestSeqS() As Long, BestSeqF() As Long
Dim oDirX As String, oDir As String, NameLen As Long, MyValue As Long, CurTot As Long, onN As Long, TempVal As Double, Y As Long, Z As Long, Dummy As Long, x As Long, TT As Long, ETx As Long, LmB As Long
Dim A As Long, b As Long, C As Long, D As Long, e As Long
Dim UBFM As Long, UBSM As Long
TT = Abs(GetTickCount)
Dim I0 As Long, I1 As Long, V As Long, RT(2) As Single, BT(2) As Single, T As Long, MinDist(1) As Double, RT2(2) As Single, BT2(2) As Single
'ultraquickdist
'$
If UBound(PermValid, 1) > 0 And x = x Then

    If x = x Then
        If ISeqs(0) > UBound(SeqNum, 2) Or ISeqs(1) > UBound(SeqNum, 2) Or ISeqs(2) > UBound(SeqNum, 2) Then
            x = x
            MinPair(0) = 0
            MinPair(1) = MinPair(0)
            MinDist(0) = 0
            MinDist(1) = 0
            Exit Sub
        End If
        Dummy = UFDist(Len(StrainSeq(0)), BPos3, EPos3, UBound(PermValid, 1), PermValid(0, 0), PermDIffs(0, 0), BT(0), RT(0), ISeqs(0), UBound(SeqNum, 1), SeqNum(0, 0))
'    Else
'        T = -1
'        For x = 0 To 1
'            I0 = ISeqs(x)
'            For Y = x + 1 To 2
'
'                T = T + 1
'                I1 = ISeqs(Y)
'                V = 0
'                D = 0
'                If BPos3 < EPos3 Then
'                    For Z = BPos3 To EPos3
'                        If SeqNum(Z, I0) <> 46 Then
'                            If SeqNum(Z, I1) <> 46 Then
'                                If SeqNum(Z, I0) <> SeqNum(Z, I1) Then
'                                    D = D + 1
'                                End If
'                                V = V + 1
'                            End If
'                        End If
'                    Next Z
'                Else
'                    For Z = BPos3 To Len(StrainSeq(0))
'                        If SeqNum(Z, I0) <> 46 Then
'                            If SeqNum(Z, I1) <> 46 Then
'                                If SeqNum(Z, I0) <> SeqNum(Z, I1) Then
'                                    D = D + 1
'                                End If
'                                V = V + 1
'                            End If
'                        End If
'                    Next Z
'                    For Z = 1 To EPos3
'                        If SeqNum(Z, I0) <> 46 Then
'                            If SeqNum(Z, I1) <> 46 Then
'                                If SeqNum(Z, I0) <> SeqNum(Z, I1) Then
'                                    D = D + 1
'                                End If
'                                V = V + 1
'                            End If
'                        End If
'                    Next Z
'                End If
'                If V > 0 Then
'                    BT(T) = D / V
'                Else
'                    BT(T) = 10
'                End If
'                If PermValid(I0, I1) - V > 0 Then
'                    RT(T) = (PermDIffs(I0, I1) - D) / (PermValid(I0, I1) - V)
'                Else
'                    RT(T) = 10
'                End If
'            Next Y
'        Next x
'
'
'        For x = 0 To 2
'            If BT(x) <> BT2(x) Or RT(x) <> RT2(x) Then
'                x = x
'            End If
'        Next x
        
    End If
    MinPair(0) = 3: MinPair(1) = 3
    If RT(0) < RT(1) And RT(0) < RT(2) Then
        MinPair(1) = 0
        
    ElseIf RT(1) < RT(0) And RT(1) < RT(2) Then
        MinPair(1) = 1
        
    ElseIf RT(2) < RT(1) And RT(2) < RT(0) Then
        MinPair(1) = 2
        
    End If
    
    If BT(0) < BT(1) And BT(0) < BT(2) Then
        MinPair(0) = 0
        
    ElseIf BT(1) < BT(0) And BT(1) < BT(2) Then
        MinPair(0) = 1
        
    ElseIf BT(2) < BT(1) And BT(2) < BT(0) Then
        MinPair(0) = 2
    End If
    
    If MinPair(0) = MinPair(1) Then
        MinDist(0) = 0
        MinDist(1) = 0
        Exit Sub
    End If
    
End If


If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
    If Form1.SSPanel1.Caption = "" Then Form1.SSPanel1.Caption = "Testing for phylogenetic evidence of recombination"
    ETx = Abs(GetTickCount)
    Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))

 '
    If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
End If
 ' ' '
'Form1.SSPanel1.Refresh

Dim FF As Long
Dim ValidX() As Single, DiffsX() As Single, ListToRedo() As Long
Dim Cutoff As Double, tFCMat() As Single, tSCMat() As Single, TraceBak() As Single, OS As String
Dim TotAdd As Long
Dim DLen() As Single, Treebyte() As Byte, NodeDepth() As Integer, BootDepth() As Integer, ReplaceVal As Double, AvDX As Double, k As Long

Dim EraseF As Byte
Dim tSMat() As Single, tFMat() As Single, Outlyer(2) As Long
Dim Valtot(1) As Long, MaxMD() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Px() As Integer, XX1() As Integer, XX2() As Integer
Dim LTree(1) As Long, FHolder() As Byte, SHolder() As Byte, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
Dim UB As Long, NSeqs As Long, TraceSeqs() As Long, tFAMat() As Single, tSAMat() As Single
Dim SCO As Long


If ISeqs(0) > NextNo Or ISeqs(1) > NextNo Or ISeqs(2) > NextNo Then
    MinPair(0) = 0
    MinPair(1) = MinPair(0)
    MinDist(0) = 0
    MinDist(1) = 0
    Exit Sub
End If


If EPos3 > Decompress(Len(StrainSeq(0))) Then EPos3 = Decompress(Len(StrainSeq(0)))
If BPos3 > Decompress(Len(StrainSeq(0))) Then BPos3 = Decompress(Len(StrainSeq(0)))

If EPos3 < 1 Then EPos3 = 1
If BPos3 < 1 Then BPos3 = 1

ReDim FCMat(0, 0), SCMat(0, 0)
ReDim SAMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0)
ReDim FAMat(0, 0)


'permvalids and permdiffs arrays are in memory when testmoveintree is loaded - they have been modified in the last parts
'of dordp and the small versions of the arrays need to be filled in here
'If SEventNumber = 15 Then
'    x = x
'End If
If UBound(PermValid, 1) > 0 Then

    
    
    If PermNextno > MemPoc Then
        'need to initialize permvalid and permdiffs on the disk
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        If UBound(PermValid, 1) > 0 Then
            
            Call PutPermValid
            ReDim PermValid(0, 0)
        End If
        If UBound(PermDIffs, 1) > 0 Then
            
            Call PutPermDiffs
            ReDim PermDIffs(0, 0)
        End If
        ChDrive oDirX
        ChDir oDirX
        
    End If
Else
x = x
End If
If PermNextno > MemPoc Then
    FF = FreeFile
    If UBound(TreeDistance, 1) > 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        'Erase TreeDistance
        TempTreeDistanceDumpFlag = 1
        ReDim TreeDistance(0, 0)
        ChDrive oDirX
        ChDir oDirX
    End If
    
End If


APhys = Abs(MemSit.dwTotalPhys)
'memload = Abs(MemSit.dwMemoryLoad)
If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
'APhys = CLng(APhys * ((100 - memload) / 100))

Cutoff = 50


'If DoQuick = 0 Then
'    Reps = 10
'Else
'    Reps = 0
'End If

LmB = Len(StrainSeq(0))
LmB = LmB * Reps
LmB = LmB * 32
If APhys < LmB Then
    Reps = CLng(Reps * (APhys / LmB))
End If


If BPos3 < EPos3 Then
    SCO = CLng((EPos3 - BPos3) / 2)
Else
    SCO = CLng((EPos3 + Len(StrainSeq(0)) - BPos3) / 2)
End If
If SCO > 20 Then SCO = 20

'Dim UBFM As Long

If DebuggingFlag < 2 Then On Error Resume Next
UBFM = 0
UBFM = UBound(FMat, 1)
On Error GoTo 0
If LongWindedFlag = 1 Then
    ReDim FMatSmall(2, NextNo)
    ReDim SMatSmall(2, NextNo)
    If SEventNumber > 0 Then
        
        
        If PermNextno > MemPoc Then

        Else
            If NextNo <> UBFM Then
                
                ReDim FMat(NextNo, NextNo)
                
                DontRedoQuickDistFlag = 0
            Else
                For x = 0 To NextNo
                    FMat(x, x) = 0
                Next x
            End If
        
        
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB = UBound(SMat, 1)
            
            
            On Error GoTo 0
            
            If NextNo <> UB Then
                
                
                ReDim SMat(NextNo, NextNo)
                
                DontRedoQuickDistFlag = 0
            Else
                For x = 0 To NextNo
                    SMat(x, x) = 0
                Next x
            End If
        
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(SubValid, 1)
            On Error GoTo 0
            If UB <> NextNo Then '1827,1827
                
                ReDim SubValid(NextNo, NextNo)
                '@
                ReDim SubDiffs(NextNo, NextNo)
                DontRedoQuickDistFlag = 0
            End If
        End If
    Else
        If PermNextno > MemPoc Then
            ReDim FMatSmall(2, NextNo)
            ReDim SMatSmall(2, NextNo)
        Else
            If DontRedoQuickDistFlag = 0 Then
                ReDim FMat(NextNo, NextNo)
                ReDim SMat(NextNo, NextNo)
                ReDim SubValid(NextNo, NextNo)
                ReDim SubDiffs(NextNo, NextNo)
                
            Else
                For x = 0 To NextNo
                    FMat(x, x) = 0
                    SMat(x, x) = 0
                Next x
            End If
        
        End If
    End If
    
    If LongFlag = 0 Then
        TT = Abs(GetTickCount)
        If TT - GlobalTimer > 500 Then
            GlobalTimer = TT
            If Right(Form1.SSPanel1.Caption, 9) <> "evidence)" Then
            ' '
                Form1.SSPanel1.Caption = "Calculating distances"
                ETx = Abs(GetTickCount)
                Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            End If
             ' ' '
            'Form1.SSPanel1.Refresh
            If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
             '
        End If
        UB = UBound(PermValid, 1)
        
        'SS = Abs(GetTickCount)
        
        If BPos3 <> BeginMark Or EPos3 <> EndMark Then
            If PermNextno > MemPoc Then
                
                Call GetPermValid
                
                Call GetPermDiffs
                
                ReDim FMat(NextNo, NextNo)
                
                'smat, subvalid and subdiffs are undimmed and are not used here - different halves of fmat,permvalid and permdiffs are used instead
                Dummy = vQuickDist2(Len(StrainSeq(0)), NextNo, UBPermValid, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0), ISeqs(0))
                
                ReDim PermDIffs(0, 0)
                ReDim PermValid(0, 0)
                
            Else
                
                Dummy = vQuickDist(Len(StrainSeq(0)), NextNo, UB, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0), ISeqs(0))
            End If
                
                
            
        End If
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS
        MinDist(0) = 1000000
        MinDist(1) = 1000000
        
        Outlyer(0) = 2
        Outlyer(1) = 1
        Outlyer(2) = 0
        Z = 0
        
        If ISeqs(0) > UBound(FMat, 1) Or ISeqs(1) > UBound(FMat, 1) Or ISeqs(2) > UBound(FMat, 1) Then
            MinPair(0) = 0
            MinPair(1) = MinPair(0)
            MinDist(0) = 0
            MinDist(1) = 0
            Exit Sub
        End If
        'XX = FMat(5, 3)
        If PermNextno > MemPoc Then
            'this section is needed because whenthere are >2000 sequences the version of vquickdist used puts values that
            'would have been added to smat into the bottom half of fmat.
            
               
                
                
            
            For x = 0 To 1
                For Y = x + 1 To 2
                
                    If ISeqs(x) < ISeqs(Y) Then
                        If FMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '2.04079 (4,5), 2.0144 (4,3),1.859 (5,3)
                            MinDist(0) = FMat(ISeqs(x), ISeqs(Y))
                            MinPair(0) = Z
                            SeqPair(0) = x
                            SeqPair(1) = Y
                            SeqPair(2) = Outlyer(Z)
                        End If
                        
                        If FMat(ISeqs(Y), ISeqs(x)) < MinDist(1) Then
                            MinDist(1) = FMat(ISeqs(Y), ISeqs(x))
                            MinPair(1) = Z
                        End If
                    Else
                        If FMat(ISeqs(Y), ISeqs(x)) < MinDist(0) Then '2.04079 (4,5), 2.0144 (4,3),1.859 (5,3)
                            MinDist(0) = FMat(ISeqs(Y), ISeqs(x))
                            MinPair(0) = Z
                            SeqPair(0) = x
                            SeqPair(1) = Y
                            SeqPair(2) = Outlyer(Z)
                        End If
                        
                        If FMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then
                            MinDist(1) = FMat(ISeqs(x), ISeqs(Y))
                            MinPair(1) = Z
                        End If
                    End If
                    Z = Z + 1
                Next Y
            Next x
        Else
            For x = 0 To 1
                For Y = x + 1 To 2
                    If FMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '2.04079 (4,5), 2.0144 (4,3),1.859 (5,3)
                        MinDist(0) = FMat(ISeqs(x), ISeqs(Y))
                        MinPair(0) = Z
                        SeqPair(0) = x
                        SeqPair(1) = Y
                        SeqPair(2) = Outlyer(Z)
                    End If
                    
                    If SMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then
                        MinDist(1) = SMat(ISeqs(x), ISeqs(Y))
                        MinPair(1) = Z
                    End If
                    Z = Z + 1
                Next Y
            Next x
        End If
            
        
        x = x
        
        If MinPair(0) = MinPair(1) And ForcePhylE = 1 Then
            
            If DebuggingFlag < 2 Then On Error Resume Next
            'If UBound(SCMat, 1) <> Nextno Then
            If PermNextno > MemPoc Then
            
            Else
                '@
                ReDim FCMatSmall(2, NextNo), SCMatSmall(2, NextNo)
                ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo)
            End If
            On Error GoTo 0
           ' End If
            Exit Sub
        
        End If
    End If
    
    '0.021
    
    'ReDim SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo), SMat(NextNo, NextNo)
    
'    SS = Abs(GetTickCount)
    'For X = 1 To 1000
    If DontRedoQuickDistFlag = 0 Then
        'Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
        
        
        Dim AVD As Double, UDS As Double, tRedo() As Integer
        ReDim tRedo(NextNo)
        For x = 0 To NextNo
            tRedo(x) = 1
        Next x
'       XX = UBound(SMat, 1)
'       XX = UBound(SubValid, 1)
'       XX = UBound(SubDiffs, 1)
        If PermNextno > MemPoc Then
            ReDim SMat(NextNo, NextNo), SubValid(NextNo, NextNo), SubDiffs(NextNo, NextNo)
        End If
        '$
        Call FastDistanceCalcZ(1, 0, BPos3, EPos3, NextNo, SubDiffs(), SubValid(), SeqNum(), SMat(), AVD, UDS, tRedo())
'                EE = Abs(GetTickCount)
'
'                TT = EE - SS
'                SS = gettickcocunt
        
'                If NextNo <> UBound(PermValid, 1) Then
'                    x = x
'                End If
        
        Call MakeSmallArrays(ISeqs(), SubValid(), SubValidSmall())
        Call MakeSmallArrays(ISeqs(), SubDiffs(), SubDiffsSmall())
        
        If PermNextno > MemPoc And x = 1234567 Then
            Call GetPermValid
            
            Call GetPermDiffs
        
        End If
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            
            Call PutSMat
            ReDim SMat(0, 0)
            
            Call GetPermValid
            '&
            For x = 0 To UBSMat
                For Y = x + 1 To UBSMat
                    'FMat(Y, x) = SMat(x, Y)
                    PermValid(Y, x) = SubValid(x, Y)
                    
                Next Y
            Next x
            ''''''''''''''''''''''''''''''''''''''''''''''''''''
            'it would save time and effort to compress subvalid and subdiffs here (wouldnt need to write it to the disk and then retrieve it later
            '''''''''''''''''''''''''''''''''''''''''''''''''''
            
            Call PutSubValid
            ReDim SubValid(0, 0)
            
            Call GetPermDiffs
            
            For x = 0 To UBSMat
                For Y = x + 1 To UBSMat
                    PermDIffs(Y, x) = SubDiffs(x, Y)
                Next Y
            Next x
            If SEventNumber >= 34 Then
             x = x
            End If
            Call PutSubDiffs
            ReDim SubDiffs(0, 0)
            If UBound(FMat, 1) <> NextNo Then
                Call GetFMat
            End If
            '@'&'&'&
            'this uses the top half of the matrix for the fscores and the bottom half for the s scores, subvalid and subdiffs can be dimmed to 0,0 because they are not used
            Dummy = FinishDists3(Len(StrainSeq(0)), NextNo, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0))
            
            'dont need to fix and resave permvalid or permdiffs because the version on disk didnt change
            
            ReDim PermValid(0, 0)
            ReDim PermDIffs(0, 0)
'XX = MemPoc
'XX = PermNextno
            Call GetSMat
            '&'&'&'&'&'&'&'&'&'&
            Dim UBSM2 As Long
            UBSM2 = UBound(SMat, 1)
            For x = 0 To UBSM2 - 1
                For Y = x + 1 To UBSM2
                    SMat(Y, x) = FMat(Y, x)
                    SMat(x, Y) = SMat(Y, x)
                    FMat(Y, x) = FMat(x, Y)
                    
                Next Y
            Next x
            
            
            Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
            Call PutSMat
            ReDim SMat(0, 0)
            
            ChDrive oDirX
            ChDir oDirX
        Else
            '@'@'$
            Dummy = FinishDists(Len(StrainSeq(0)), NextNo, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0))
            Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())
            Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
        'XX = RedoListSize
        End If
    End If
    
    
    'if sequences are compressed the distances in the matrices must be adjusted to account for this.
'    XX = Len(StrainSeq(0))
'    SS = Abs(GetTickCount)
    If EPos3 > Len(StrainSeq(0)) Then
        ReDim Preserve Decompress(EPos3)
        Decompress(EPos3) = Decompress(Len(StrainSeq(0)))
    End If
    If BPos3 > Len(StrainSeq(0)) Then
        ReDim Preserve Decompress(BPos3)
        Decompress(BPos3) = Decompress(Len(StrainSeq(0)))
    End If
    
    
    'May need to be careful here with memory if given lots of long sequences
    If Decompress(EPos3) <> EPos3 Or Decompress(BPos3) <> BPos3 Then 'this corrects distances if there is compression
        TotAdd = 0
        If Decompress(EPos3) > Decompress(BPos3) Then
            '@
            For x = Decompress(BPos3) To Decompress(EPos3)
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
        Else
            For x = Decompress(BPos3) To Decompress(Len(StrainSeq(0)))
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
            For x = 1 To Decompress(EPos3)
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
        End If
        If PermNextno > MemPoc Then
            GetSubValid
            GetPermValid
            GetPermDiffs
            GetSubDiffs
            GetSMat
        End If
        '@
        For x = 0 To NextNo
            For Y = x + 1 To NextNo
                SubValid(x, Y) = SubValid(x, Y) + TotAdd
                SubValid(Y, x) = SubValid(x, Y)
                TempVal = PermValid(x, Y) - SubValid(x, Y)
                
                If TempVal > 0 Then
                    TempVal = (((TempVal - PermDIffs(x, Y)) - SubDiffs(x, Y)) / TempVal)
                    If TempVal > 0.25 Then
                        TempVal = (4 * TempVal - 1) / 3
                        '@
                        TempVal = Log(TempVal)
                        FMat(x, Y) = -0.75 * TempVal
                        'x = x
                    Else
                        FMat(x, Y) = 10
                    End If
                Else
                    FMat(x, Y) = 10
                    
                End If
                FMat(Y, x) = FMat(x, Y)
                
                TempVal = SubValid(x, Y)
                
                If TempVal > 0 Then
                    TempVal = (TempVal - SubDiffs(x, Y)) / TempVal
                    If TempVal > 0.25 Then
                        TempVal = (4 * TempVal - 1) / 3
                        TempVal = Log(TempVal)
                        SMat(x, Y) = -0.75 * TempVal
                        x = x
                    Else
                        SMat(x, Y) = 10
                    End If
                Else
                    SMat(x, Y) = 10
                    
                End If
                SMat(Y, x) = SMat(x, Y)
            Next Y
            
   
        Next x
        
    End If
    
    
    
    '0.240
    
   
    
    
    'Which pair is most closely related in the backgound?
    For x = 0 To NextNo
        FMat(x, x) = 0
    Next x
'    If X = 12345 Then
'        Open "distmat.csv" For Output As #1
'
'        For X = 0 To Nextno
'            OS = ""
'
'            For Y = 0 To Nextno
'                If PermValid(X, Y) > 0 Or X = X Then
'                    OS = OS + " 0" + Trim(Str(CLng(FMat(X, Y) * 10000) / 10000))
'                Else
'                    OS = OS + " 0.0000"
'                End If
'            Next Y
'            Print #1, OS
'        Next X
'        Close #1
'
'        X = X
'    End If

'Else
'    ReDim xx1(3), xx2(3), Prod1(Len(StrainSeq(0))), Prod2(Len(StrainSeq(0))), Prod3(Len(StrainSeq(0))), Alias(Len(StrainSeq(0))), Ally(Len(StrainSeq(0))), Location(Len(StrainSeq(0))), Weight(0, Len(StrainSeq(0)))
End If
 
'SS = Abs(GetTickCount)
'For X = 0 To Nextno
'    For Y = X + 1 To Nextno
'        FMat(X, Y) = (CLng(FMat(X, Y) * 10000000)) / 10000000
'        FMat(Y, X) = FMat(X, Y)
'        SMat(X, Y) = (CLng(SMat(X, Y) * 10000000)) / 10000000
'        SMat(Y, X) = SMat(X, Y)
'    Next Y
'Next X
'
'
'EE = Abs(GetTickCount)
'TT = EE - SS
'X = X
 '
If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
'2,231 for 3200
'0.240

''Impute missing entries in distance matrices (ie with pernvalid/subvalid= 0)
''using a nearest neghbours method
'If X = 12345 And SEventNumber = 9 Then
'        Open "distmat.csv" For Output As #1
'        XX = CurDir
'        For X = 0 To PermNextno ' To 0 Step -1  'XXXX0 To
'            OS = ""
'
'            For Y = 0 To PermNextno    'xxxx 0 To
'                If SubValid(X, Y) > 0 Or X = X Then
'                    OS = OS + " 0" + Trim(Str(CLng(FMat(X, Y) * 10000) / 10000))
'                Else
'                    OS = OS + " 0.0000"
'                End If
'            Next Y
'            Print #1, OS
'        Next X
'        Close #1
'        X = X
'End If
'If SEventNumber = 80 Then
'    X = X
'End If



'Checkmatrix is a big problem - 4 nextno*nextno arrays will not work for >4k sequences
'    FF = FreeFile
'    Open "test highmem early.csv" For Append As #FF
'    Print #FF, "x,y,smat,fmat,permdiffs,permvalid"
'    For x = 0 To Nextno
'        For Y = 0 To Nextno
'            Print #1, Str(x) + "," + Str(Y) + "," + Str(SMat(x, Y)) + "," + Str(FMat(x, Y)) + "," + Str(PermValid(x, Y)) + "," + Str(SubValid(x, Y))
'        Next Y
'    Next x
'
'    Close #FF
If LongWindedFlag = 1 Then


    'fmat and smat entries are marked for later removal with a "3.0" in the matrix and a 3.0 on the fmat diagonal
    
    'checkmatrix uses smat but checkmatrix2 does not - i.e. it is OK to redim smat 0,0 above to save memory
    If PermNextno > MemPoc Then
        Call GetPermValid
        
        Call GetSubValid
        'NOTE SMat, FAMat and SAMat here can be dimmed to 0,0 - they are not accessed
        
        'Dummy = CheckMatrix2(UB, SCO, MinSeqSize, Nextno, Valtot(0), ISeqs(0), PermValid(0, 0), SubValid(0, 0), FMat(0, 0), SMat(0, 0), FAMat(0, 0), SAMat(0, 0))
        Call CheckMatrixX2(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat())
    
    Else
       ' Dummy = CheckMatrix(UB, SCO, MinSeqSize, Nextno, Valtot(0), ISeqs(0), PermValid(0, 0), SubValid(0, 0), FMat(0, 0), SMat(0, 0), FAMat(0, 0), SAMat(0, 0))
        Call CheckMatrixX(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat(), SMat())
        'highmem
        'ub = 90
        'sco=20
        'minseqsize = 83
        
        XX = ISeqs(0) '81
        XX = ISeqs(1) '16
        XX = ISeqs(2) '29
        XX = Valtot(0) '0
        
        XX = Valtot(1) '0
        'XX = UBound(Valtot, 1)
    End If
    
'     FF = FreeFile
'    Open "test highmem early.csv" For Append As #FF
'    Print #FF, "x,y,smat,fmat,permdiffs,permvalid"
'    For x = 0 To Nextno
'        For Y = 0 To Nextno
'            Print #1, Str(x) + "," + Str(Y) + "," + Str(SMat(x, Y)) + "," + Str(FMat(x, Y)) + "," + Str(PermValid(x, Y)) + "," + Str(SubValid(x, Y))
'        Next Y
'    Next x
'
'    Close #FF
    
    If PermNextno > MemPoc Then
        'drop permvalid and subvalid
        
        'dont need to resave permvalid and subvalid because they didnt change
        
        ReDim PermValid(0, 0)
        
        ReDim SubValid(0, 0)
        
        Call GetSMat
        '&'&
        For x = 0 To NextNo
            For Y = 0 To NextNo
                If FMat(x, Y) = 3 Then
                    SMat(x, Y) = 3
                End If
            Next Y
        Next x
    End If
    'Call CheckMatrixX(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat(), SMat())

End If



   


Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
If PermNextno > MemPoc Then
    If UBound(SMat, 1) > 0 Then
        Call PutSMat
        ReDim SMat(0, 0)
    End If
End If

If CompressSVSDFlag = 1 Then
    If PermNextno > MemPoc Then
        
        Call GetSubValid
        
        Call GetSubDiffs
        
    End If
    'compress subdiffs and subvalid
    Dim TSD() As Single, TSV() As Single
    ReDim TSD(2, NextNo), TSV(2, NextNo)
    '$
    For x = 0 To 2
        For Y = 0 To NextNo
            TSD(x, Y) = SubDiffs(ISeqs(x), Y)
            TSV(x, Y) = SubValid(ISeqs(x), Y)
        Next Y
    Next x
    ReDim SubDiffs(2, NextNo), SubValid(2, NextNo)
    '@
    For x = 0 To 2
        For Y = 0 To NextNo
            SubDiffs(x, Y) = TSD(x, Y) ' = SubDiffs(ISeqs(X), Y)
            SubValid(x, Y) = TSV(x, Y) ' = SubValid(ISeqs(X), Y)
        Next Y
    Next x
    Erase TSD: Erase TSV
End If
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'End of part E
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'EE = Abs(GetTickCount)
'TT = EE - SS
'
'
'
'X = X
 '0.060
 
 
 
 '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Part F: treedistance and fmat used here - no reason to use fmat though - could just used ListToRedo instead
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'Make bAckup of Fmat (it is destroyed by neighbour)
ReDim TraceSeqs(1, NextNo)
ReDim ListToRedo(NextNo)




'use this code to remove masked sequences for extra speed
If IndividualA = -1 Then
    If UBound(MaskSeq) < NextNo Then ReDim Preserve MaskSeq(NextNo)
    For x = 0 To NextNo
        If MaskSeq(x) = 2 Then
            FMat(x, x) = 3
            ListToRedo(x) = 1
        ElseIf FMat(x, x) = 3 Then
            ListToRedo(x) = 1
        
        End If
    Next x
End If


NSeqs = -1
For x = 0 To NextNo
    If ListToRedo(x) = 0 Then
        NSeqs = NSeqs + 1
    End If
Next x
x = x


If NSeqs > 300 Then
    
    UBTD = UBound(TreeDistance, 1)
    If (UBTD <> UBTD1 And UBTD1 <> 0) Or UBTD = 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        '&
        ReDim TreeDistance(UBTD1, UBTD1)
        FF = FreeFile
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Get #FF, , TreeDistance
        Close #FF
        ChDrive oDirX
        ChDir oDirX
        'Erase TreeDistance
        TempTreeDistanceDumpFlag = 1
    End If
    'remove irrelevant outlyers/inlyers
    Dim MAxD As Single, MinD As Single
    MAxD = 1: MinD = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If TreeDistance(ISeqs(x), ISeqs(Y)) < MAxD Then
                MAxD = TreeDistance(ISeqs(x), ISeqs(Y))
                A = ISeqs(x)
                b = ISeqs(Y)
            End If
            If TreeDistance(ISeqs(x), ISeqs(Y)) > MinD Then
                MinD = TreeDistance(ISeqs(x), ISeqs(Y))
                D = ISeqs(x)
                e = ISeqs(Y)
            End If
        Next Y
    Next x
    If A = D Or A = e Then
        A = b
    End If
    'XX = StraiName(A)
    'XX = StraiName(D)
    'XX = StraiName(E)
    'XX = StraiName(B)
    'XX = TreeDistance(A, D)
    'XX = TreeDistance(A, E)
    'XX = TreeDistance(D, E)
'    SS = Abs(GetTickCount)
    
    For x = 0 To NextNo
        If x <> A And x <> D And x <> e Then
            If ListToRedo(x) = 0 Then
                If TreeDistance(A, x) < MAxD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            'XX = StraiName(Y)
                            'XX = StraiName(X)
                            If ListToRedo(Y) = 0 Then
                                If TreeDistance(A, Y) = TreeDistance(A, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                End If
                If TreeDistance(D, x) > MinD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            If ListToRedo(Y) = 0 Then
                                If TreeDistance(D, Y) = TreeDistance(D, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                
                End If
                'XX = UBound(TreeDistance, 1)
                'XX = UBound(Distance)
                If TreeDistance(e, x) > MinD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            If ListToRedo(Y) = 0 Then
                                If TreeDistance(e, Y) = TreeDistance(e, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                
                End If
                
            End If
        End If
    
    Next x

End If






NSeqs = -1
For x = 0 To NextNo
    If ListToRedo(x) = 0 Then
        NSeqs = NSeqs + 1
        TraceSeqs(0, x) = NSeqs
        TraceSeqs(1, NSeqs) = x
    
    End If
Next x
'0.260
Rnd (-BSRndNumSeed)
onN = UBound(FMat, 1)
''''''''''''''''''''''''''''''''''''''''''''''
'End of Part F
''''''''''''''''''''''''''''''''''''''''''

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Start Part G: Uses: treedistance, FMat
'(but does not need to use fmat - fmat is only used to store info on which sequences will be diregarded)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If NSeqs > 300 Then
    Rnd (-BSRndNumSeed)
    'th reps=0 part will only get executed during the first of the two calls from dordp - in the second pass the "else" bit will be executed
    'this makes the datasets that are used to make famat, samat scmat and fcmat
    If Reps = 0 And x = 12345 Then
        'remove sequences from branches in tree between the inlyers and outlyer
        For x = 0 To NextNo
            If x <> A And x <> D And x <> e Then
                If ListToRedo(x) = 0 Then
                    If TreeDistance(D, x) > MAxD And TreeDistance(D, x) < MinD Then
                        For Y = x + 1 To NextNo
                            If Y <> A And Y <> D And Y <> e Then
                                'XX = StraiName(Y)
                                'XX = StraiName(X)
                                If ListToRedo(Y) = 0 Then
                                    If TreeDistance(D, Y) = TreeDistance(D, x) Then
                                        FMat(Y, Y) = 3
                                        ListToRedo(Y) = 1
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                    'and remove sequences between the outlyer and the MRCA of the inlyer and outlyer
                    If TreeDistance(A, x) > MAxD And TreeDistance(D, x) = TreeDistance(A, D) Then
                        For Y = x + 1 To NextNo
                            If Y <> A And Y <> D And Y <> e Then
                                'XX = StraiName(Y)
                                'XX = StraiName(X)
                                If ListToRedo(Y) = 0 Then
                                    If TreeDistance(A, Y) = TreeDistance(A, x) Then
                                        FMat(Y, Y) = 3
                                        ListToRedo(Y) = 1
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                    
                    
                End If
            End If
        
        Next x
        
        If PermNextno > MemPoc Then
            If UBound(TreeDistance, 1) > 0 Then
                UBTD1 = UBound(TreeDistance, 1)
                oDirX = CurDir
                ChDrive App.Path
                ChDir App.Path
                Open "RDP5TreeDistance" + UFTag For Binary As #FF
                Put #FF, , TreeDistance
                Close #FF
                ReDim TreeDistance(0, 0)
                TempTreeDistanceDumpFlag = 1
                ChDrive oDirX
                ChDir oDirX
            End If
        End If
    
        NSeqs = -1
        'XX = UBound(ListToRedo)
        For x = 0 To NextNo
            If ListToRedo(x) = 0 Then
                NSeqs = NSeqs + 1
                TraceSeqs(0, x) = NSeqs
                TraceSeqs(1, NSeqs) = x
            
            End If
        Next x
        
        'drop treedistance if necessary
        
    
        'if there are still too many sequences then remove sequences at random untill only 100 remain
        If NSeqs > 100 Then
    
            CurTot = NSeqs
            Do
                MyValue = Int(onN * Rnd)
                If MyValue <> ISeqs(0) And MyValue <> ISeqs(1) And MyValue <> ISeqs(2) Then
                    'if treedistance(e,myvalue)
                    If ListToRedo(MyValue) = 0 Then
                        'If TreeDistance(A, Y) = TreeDistance(A, x)
                        FMat(MyValue, MyValue) = 3
                        ListToRedo(MyValue) = 1
                        CurTot = CurTot - 1
                        If CurTot = 100 Then Exit Do
                    End If
                End If
            Loop
        End If
    
    
    
    Else 'if reps>0 it means this is the second of the two calls from dordp
        
        If NSeqs > 300 Then 'randomly throw out sequences until ~300 remain
            CurTot = NSeqs
            Do
                MyValue = Int(onN * Rnd)
                If MyValue <> ISeqs(0) And MyValue <> ISeqs(1) And MyValue <> ISeqs(2) Then
                    If ListToRedo(MyValue) = 0 Then
                        FMat(MyValue, MyValue) = 3
                        ListToRedo(MyValue) = 1
                        CurTot = CurTot - 1
                        If CurTot = 300 Then Exit Do
                    End If
                End If
            Loop
        
        End If
    End If

    NSeqs = -1
    For x = 0 To NextNo
        If ListToRedo(x) = 0 Then
            NSeqs = NSeqs + 1
            TraceSeqs(0, x) = NSeqs
            TraceSeqs(1, NSeqs) = x
        
        End If
    Next x
End If


'''''''''''''''''''''''''''''''''''''''
'End of Part G
'''''''''''''''''''''''''''''''''''''''''

If NSeqs > 2 Then
    ReDim FAMat(0, 0)
    ReDim SAMat(0, 0)
    ReDim FCMatSmall(2, NextNo), FAMatSmall(2, NextNo), SCMatSmall(2, NextNo), SAMatSmall(2, NextNo)
    ReDim SHolder((NSeqs + 1) * 40 * 2), FHolder((NSeqs + 1) * 40 * 2)
Else
    MinPair(0) = MinPair(1)
    If DebuggingFlag < 2 Then On Error Resume Next
    ReDim FCMatSmall(2, NextNo), FAMatSmall(2, NextNo), SCMatSmall(2, NextNo), SAMatSmall(2, NextNo)
    If PermNextno > MemPoc Then
    
    Else
        
        ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo), FAMat(NextNo, NextNo), SAMat(NextNo, NextNo)
    
    End If
    On Error GoTo 0
    Exit Sub
End If

'0.260

''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Start of Part H: uses fmat to make tfmat
'''''''''''''''''''''''''''''''''''''''''''''''''''''
Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())

NameLen = Len(Trim$(CStr(NSeqs)))
If NameLen < 2 Then NameLen = 2
    
'SSSSs = abs(gettickcount)
'For XXX = 0 To 50

If NSeqs < 500 And PermNextno <= MemPoc Then
    
    ReDim FAMat(NextNo, NextNo)
    ReDim SAMat(NextNo, NextNo)
    ReDim tFAMat(NSeqs, NSeqs), tSAMat(NSeqs, NSeqs)
    'SS = abs(gettickcount)
    'For x = 1 To 50
   '@'@'@'@'@
    'Dummy = MakeNJTrees(NSeqs, NextNo, ISeqs(0), MinPair(0), SeqPair(0), BSRndNumSeed, NameLen, Len(StrainSeq(0)), UBound(TraceSeqs, 1), Outlyer(0), TraceSeqs(0, 0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0), UBound(FAMat, 1), FAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0), FHolder(0), SHolder(0), tFAMat(0, 0), tSAMat(0, 0))
    
'    Dim ASamat() As Single, AFamat() As Single, TAfamat() As Single, TAsamat() As Single
'    ReDim ASamat(UBound(SAMat, 1), UBound(SAMat, 1)), AFamat(UBound(FAMat, 1), UBound(FAMat, 1)), TAfamat(UBound(tFAMat, 1), UBound(tFAMat, 1)), TAsamat(UBound(tSAMat, 1), UBound(tSAMat, 1))
'
'   For x = 0 To NSeqs
'        For Y = 0 To neseqs
'            TAfamat(x, Y) = tFAMat(x, Y)
'            TAsamat(x, Y) = tSAMat(x, Y)
'        Next Y
'   Next x
'   For x = 0 To NextNo
'        For Y = 0 To NextNo
'            AFamat(x, Y) = FAMat(x, Y)
'            ASamat(x, Y) = SAMat(x, Y)
'        Next Y
'   Next x
'    Dim mp() As Byte, sp() As Byte, ol() As Long
'    ReDim mp(UBound(MinPair, 1)), sp(UBound(SeqPair, 1)), ol(UBound(Outlyer, 1))
'    For x = 0 To UBound(MinPair, 1)
'        mp(x) = MinPair(x)
'    Next x
'    For x = 0 To UBound(SeqPair, 1)
'        sp(x) = SeqPair(x)
'    Next x
'    For x = 0 To UBound(Outlyer, 1)
'        ol(x) = Outlyer(x)
'    Next x
Dim ResRootFlag As Long
ResRootFlag = 1
'The importnant difference between MakeNJTreesP2 and MakeNJTreesP is that the midopoint root in MakeNJTreesP is a trifuracation (all samat/famat distance between sequences that are joined by the actualnode closest to the root node have the dame distance) and in MakeNJTreesP2 it is a bifurcation
''@
    'Dummy = MakeNJTreesP(NSeqs, NextNo, ISeqs(0), MinPair(0), SeqPair(0), BSRndNumSeed, NameLen, Len(StrainSeq(0)), UBound(TraceSeqs, 1), Outlyer(0), TraceSeqs(0, 0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0), UBound(FAMat, 1), FAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0), FHolder(0), SHolder(0), tFAMat(0, 0), tSAMat(0, 0))
    Dummy = MakeNJTreesP2(ResRootFlag, NSeqs, NextNo, ISeqs(0), MinPair(0), SeqPair(0), BSRndNumSeed, NameLen, Len(StrainSeq(0)), UBound(TraceSeqs, 1), Outlyer(0), TraceSeqs(0, 0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0), UBound(FAMat, 1), FAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0), FHolder(0), SHolder(0), tFAMat(0, 0), tSAMat(0, 0))
    'Dummy = MakeNJTreesP2(0, NSeqs, NextNo, ISeqs(0), mp(0), sp(0), BSRndNumSeed, NameLen, Len(StrainSeq(0)), UBound(TraceSeqs, 1), ol(0), TraceSeqs(0, 0), UBound(FMat, 1), FMat(0, 0), UBound(SMat, 1), SMat(0, 0), UBound(FAMat, 1), AFamat(0, 0), UBound(SAMat, 1), ASamat(0, 0), ListToRedo(0), FHolder(0), SHolder(0), TAfamat(0, 0), TAsamat(0, 0))
    
    XX = SEventNumber
'
If ResRootFlag = 0 Then
    If SAMat(ISeqs(0), ISeqs(1)) = SAMat(ISeqs(0), ISeqs(2)) And SAMat(ISeqs(0), ISeqs(1)) = SAMat(ISeqs(2), ISeqs(1)) Then
        MinPair(0) = 3
        MinPair(1) = 3
    ElseIf FAMat(ISeqs(0), ISeqs(1)) = FAMat(ISeqs(0), ISeqs(2)) And FAMat(ISeqs(0), ISeqs(1)) = FAMat(ISeqs(2), ISeqs(1)) Then
        MinPair(0) = 3
        MinPair(1) = 3
    End If
End If

'
'      XX = ASamat(ISeqs(0), ISeqs(1))
'     XX = ASamat(ISeqs(0), ISeqs(2))
'      XX = ASamat(ISeqs(2), ISeqs(1))
'      XX = FAMat(ISeqs(0), ISeqs(1))
'     XX = FAMat(ISeqs(0), ISeqs(2))
'      XX = FAMat(ISeqs(2), ISeqs(1))
'
'      XX = AFamat(ISeqs(0), ISeqs(1))
'     XX = AFamat(ISeqs(0), ISeqs(2))
'      XX = AFamat(ISeqs(2), ISeqs(1))
'
'    For x = 0 To UBound(MinPair, 1)
'        If mp(x) <> MinPair(x) Then
'            x = x
'        End If
'    Next x
'    For x = 0 To UBound(SeqPair, 1)
'        If sp(x) <> SeqPair(x) Then
'            x = x
'        End If
'    Next x
'    For x = 0 To UBound(Outlyer, 1)
'        If ol(x) <> Outlyer(x) Then
'            x = x
'        End If
'    Next x
'    For x = 0 To NSeqs
'        For Y = x + 1 To NSeqs
'            For A = Y + 1 To NSeqs
'                'For b = A + 1 To NSeqs
'                    If tSAMat(x, Y) < tSAMat(x, A) And tSAMat(x, Y) < tSAMat(Y, A) Then
'                        If TAsamat(x, Y) < TAsamat(x, A) And TAsamat(x, Y) < TAsamat(Y, A) Then
'                        Else
'                            x = x
'                        End If
'                    ElseIf tSAMat(x, A) < tSAMat(x, Y) And tSAMat(x, A) < tSAMat(Y, A) Then
'                        If TAsamat(x, A) < TAsamat(x, Y) And TAsamat(x, A) < TAsamat(Y, A) Then
'                        Else
'                            x = x
'                        End If
'                    ElseIf tSAMat(A, Y) < tSAMat(x, A) And tSAMat(A, Y) < tSAMat(Y, x) Then '8,7 = 12; 8,1 = 21; 7,1=21
'                        If TAsamat(A, Y) < TAsamat(x, A) And TAsamat(A, Y) < TAsamat(Y, x) Then '8,7=17; 1,8=15; 7,1=24
'                        Else
'                            XX = SMat(A, Y)
'                            XX = SMat(x, A)
'                            XX = SMat(Y, x)
'                            x = x
'                        End If
'                    End If
'
'                    If tFAMat(x, Y) < tFAMat(x, A) And tFAMat(x, Y) < tFAMat(Y, A) Then
'                        If TAfamat(x, Y) < TAfamat(x, A) And TAfamat(x, Y) < TAfamat(Y, A) Then
'                        Else
'                            x = x
'                        End If
'                    ElseIf tFAMat(x, A) < tFAMat(x, Y) And tFAMat(x, A) < tFAMat(Y, A) Then
'                        If TAfamat(x, A) < TAfamat(x, Y) And TAfamat(x, A) < TAfamat(Y, A) Then
'                        Else
'                            x = x
'                        End If
'                    ElseIf tFAMat(A, Y) < tFAMat(x, A) And tFAMat(A, Y) < tFAMat(Y, x) Then
'                        If TAfamat(A, Y) < TAfamat(x, A) And TAfamat(A, Y) < TAfamat(Y, x) Then
'                        Else
'                            x = x
'                        End If
'                    End If
'                'Next b
'            Next A
'
'        Next Y
'    Next x
'    x = x
    
    'Dim Samatb() As Single, Famatb() As Single
    
    
    
    
    'Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
    'Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
'    XXX = 0
'    yyy = 0
'    For x = 0 To NextNo
'        For Y = 0 To NextNo
'            If tSAMat(x, Y) * 1000 > NextNo Then
'                x = x
'                XXX = XXX + 1 '46518
'            Else
'                yyy = yyy + 1 '4107
'            End If
'        Next Y
'    Next x
'    Dim TotS() As Long
'    ReDim TotS(50000)
'    For x = 0 To NextNo
'        For Y = x + 1 To NextNo
'            'XX = SAMat(x, Y)
'          TotS(tSAMat(x, Y) * 1000) = TotS(tSAMat(x, Y) * 1000) + 1
'
'        Next Y
'    Next x
'    For x = 0 To UBound(TotS)
'        If TotS(x) = 0 Then
'            x = x
'        Else
'            x = x
'            If TotS(x) > 64 Then
'                x = x
'            End If
'        End If
'    Next x
'    x = x
'    'Next x
    'EE = abs(gettickcount)
    '        TT = EE - SS '1.484; 1.015
            '2.609,2.609
            '63 seconds on this
'            TotFGCT = TotFGCT + TT
'            LoopENum = LoopENum + 1
'            Form1.Caption = Str(TotFGCT) + Str(LoopENum)
    '90.623 seconds
Else
    
    ReDim tFMat(NSeqs, NSeqs) 'the distance matrix that will be usued to make the tree (should be <500x500
    
    If x = 12345 Then
        Dummy = MaketFSMat(NextNo, UBound(FMat, 1), UBound(tFMat, 1), FMat(0, 0), tFMat(0, 0))
    Else
        If x = x Then
            Dummy = MaketFSMatL(NextNo, UBound(FMat, 1), UBound(tFMat, 1), FMat(0, 0), tFMat(0, 0), ListToRedo(0))
        Else
        '@
            A = 0
            b = 0
            For x = 0 To NextNo
        
                If ListToRedo(x) = 0 Then
                    tFMat(A, A) = 0
                    b = A + 1
        
                    For Y = x + 1 To NextNo
                        If ListToRedo(Y) = 0 Then
                            tFMat(A, b) = FMat(x, Y)
                            tFMat(b, A) = FMat(x, Y)
                            b = b + 1
                        End If
        
                    Next Y
                    A = A + 1
        
                End If
            Next x
        End If
    End If

    If PermNextno > MemPoc Then

        'drop FMat onto the disk
        FMatInFileFlag = 1
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        UBF1 = UBound(FMat, 1)
    '    For x = 0 To Nextno
    '        For Y = 0 To Nextno
    '            If FMat(x, Y) > 0 Then
    '                x = x
    '            End If
    '        Next Y
    '    Next x
        If DontRedoQuickDistFlag = 0 Then
        Call PutFMat
        ReDim FMat(0, 0)
        End If
    
        
    End If
    
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'end of part H
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
        Dim TotMat() As Single, MaxSc As Double
        ReDim TotMat(NSeqs)
        
        For x = 0 To NSeqs
            For Y = x + 1 To NSeqs
                If tFMat(x, x) < 3 Then
                    If tFMat(Y, Y) < 3 Then
                        TotMat(x) = TotMat(x) + tFMat(x, Y)
                        TotMat(Y) = TotMat(Y) + tFMat(x, Y)
                    End If
                End If
            Next Y
        Next x
        MaxSc = 0
        For x = 0 To NSeqs
            If TotMat(x) > MaxSc Then
                Outie = x
                MaxSc = TotMat(x)
            End If
        Next x
    
    
    TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        ETx = Abs(GetTickCount)
        ' '
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
        'Form1.Refresh
        If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
        'DoEvents
    End If
    If AbortFlag = 1 Then Exit Sub
    
    ReDim tFAMat(0, 0)
    ReDim ColTotals(NSeqs)
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
    'nt1
    'LTree(0) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tFMat(0, 0), FHolder(0), ColTotals(0), tFMat(0, 0))
    LTree(0) = Clearcut(0, NSeqs, 1, 100, BSRndNumSeed, 1, UBound(tFMat, 1), tFMat(0, 0), FHolder(0))
    '
    '             Open "test5.tre" For Binary As #1
    '             'Put #1, , FHolder
    '             Put #1, , FHolder
    '             Close #1
    '
    'XX = CurDir
    Erase tFMat
    
    
    ReDim tFAMat(NSeqs, NSeqs)
    
    'SS = Abs(GetTickCount)
    'Call Tree2Array(1, NameLen, NSeqs, LTree(0), FHolder(), tFAMat())
    '&'&
    Dummy = Tree2ArrayP(1, NameLen, NSeqs, LTree(0), FHolder(0), UBound(tFAMat, 1), tFAMat(0, 0))
    
    'EE = Abs(GetTickCount)
    'TT = EE - SS '1.293 for 1410 seqs
    'X = X
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''
    'start of Part I: Makes FAMat from tFAMat: if number of sequences is large FAMat will be pretty sparse
    ''''''''''''''''''''''''''''''''''''''''''
    ReDim FAMat(NextNo, NextNo)
    
    If x = x Then
        Dummy = FtoFA(NSeqs, Len(StrainSeq(0)), UBound(TraceSeqs, 1), TraceSeqs(0, 0), UBound(tFAMat, 1), tFAMat(0, 0), UBound(FAMat, 1), FAMat(0, 0))
    Else
        
        For x = 0 To NSeqs
            For Y = x + 1 To NSeqs
                tFAMat(x, Y) = CLng(tFAMat(x, Y) * 10000) / 10000
                tFAMat(Y, x) = tFAMat(x, Y)
                FAMat(TraceSeqs(1, x), TraceSeqs(1, Y)) = tFAMat(x, Y)
                FAMat(TraceSeqs(1, Y), TraceSeqs(1, x)) = tFAMat(x, Y)
            Next Y
        Next x
    End If
    'this fills in any blanks in FAmat (in many cases only some of the sequences will be used to make famat)
    If x = x Then
        'dont use fmat here - use involved instead
        'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(FAMat, 1), FAMat(0, 0), FMat(0, 0))
        '&
        Dummy = CleanFCMat2P(NextNo, NextNo, UBound(FAMat, 1), FAMat(0, 0), ListToRedo(0))
    Else
        For x = 0 To NextNo
            If ListToRedo(x) = 1 Then
                For Y = 0 To NextNo
                    FAMat(x, Y) = ((NextNo * 3) - 1) / 1000
                    FAMat(Y, x) = ((NextNo * 3) - 1) / 1000
                    
                Next Y
            End If
        Next x
    End If
    
    'Use famat to make minpair 1
    MinDist(0) = 1000000
    Outlyer(0) = 2
    Outlyer(1) = 1
    Outlyer(2) = 0
    Z = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If FAMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '0.001 (4,5)
                MinDist(0) = FAMat(ISeqs(x), ISeqs(Y))
                MinPair(0) = Z
                SeqPair(0) = x
                SeqPair(1) = Y
                SeqPair(2) = Outlyer(Z)
            End If
            Z = Z + 1
        Next Y
    Next x
    
    For x = 0 To NextNo
        
        FAMat(x, x) = 0
       
    Next x
    
    
    If PermNextno > MemPoc Then
    'drop famat onto the disk
        Call PutFAMat
        ReDim FAMat(0, 0)
    End If
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'fAMat is still not finished here - it is lacking proper estinated values for many array entries - these get added in part L together with entries to SCMat
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'End of part I
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
     If AbortFlag = 1 Then Exit Sub
     
     
     
     ReDim ColTotals(NSeqs)
     TT = Abs(GetTickCount)
    If TT - GlobalTimer > 500 Then
      GlobalTimer = TT
        Form1.SSPanel1.Caption = "Making second NJ tree"
        ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
      '
     'Form1.SSPanel1.Refresh
     ' ' '
     'Form1.Refresh
     If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
    End If
     
     A = 0
    b = 0
    '0.260
    'SS = Abs(GetTickCount)
    ReDim tSMat(NSeqs, NSeqs)
    If PermNextno > MemPoc Then
        'get smat off the disk
        Call GetSMat
    End If
    'XX = UBound(SMat, 1)
    If x = 12345 Then
        Dummy = MaketFSMat(NextNo, UBound(SMat, 1), UBound(tSMat, 1), SMat(0, 0), tSMat(0, 0))
    Else
        If x = x Then
            Dummy = MaketFSMatL(NextNo, UBound(SMat, 1), UBound(tSMat, 1), SMat(0, 0), tSMat(0, 0), ListToRedo(0))
        Else
        
            For x = 0 To NextNo
        
                If ListToRedo(x) = 0 Then
                    tSMat(A, A) = 0
                    b = A + 1
                    For Y = x + 1 To NextNo
                        If ListToRedo(Y) = 0 Then
                            tSMat(A, b) = SMat(x, Y)
                            tSMat(b, A) = SMat(x, Y)
                            b = b + 1
                        End If
        
                    Next Y
                    A = A + 1
        
                End If
            Next x
        End If
    End If
    
    If PermNextno > MemPoc Then
        ReDim SMat(0, 0)
    End If
    
    
    ReDim tSAMat(0, 0)
    'If SEventNumber = 8 Then
    '    X = X
    'End If
    ' '
    'If SEventNumber = 46 Then
    '    X = X
    '    Open "bus1n.csv" For Output As #20
    '    For X = 0 To NSeqs
    '        For Y = X + 1 To NSeqs
    '            Print #20, Str(tSMat(0, 1))
    '        Next Y
    '    Next X
    '    Close #20
    '    X = X
    '    X = X
    'End If
    '@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
    'nt2
    'LTree(1) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tSMat(0, 0), SHolder(0), ColTotals(0), tSMat(0, 0))
    LTree(1) = Clearcut(0, NSeqs, 1, 100, BSRndNumSeed, 1, UBound(tSMat, 1), tSMat(0, 0), SHolder(0))
    'XX = tSAMat(4, 5)
    x = x
    Erase tSMat
    'DoEvents
    'If SEventNumber = 8 Then
    '    X = X
    'End If
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Part J: Make SAMat
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ReDim tSAMat(NSeqs, NSeqs)
    '
    If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
    'Call Tree2Array(1, NameLen, NSeqs, LTree(1), SHolder(), tSAMat())
    '&'&'&
    Dummy = Tree2ArrayP(1, NameLen, NSeqs, LTree(1), SHolder(0), UBound(tSAMat, 1), tSAMat(0, 0))
    ReDim SAMat(NextNo, NextNo)
    If x = x Then
        Dummy = FtoFA(NSeqs, Len(StrainSeq(0)), UBound(TraceSeqs, 1), TraceSeqs(0, 0), UBound(tSAMat, 1), tSAMat(0, 0), UBound(SAMat, 1), SAMat(0, 0))
    
    Else
        For x = 0 To NSeqs
            For Y = x + 1 To NSeqs
                tSAMat(x, Y) = CLng(tSAMat(x, Y) * 10000) / 10000
                tSAMat(Y, x) = tSAMat(x, Y)
                SAMat(TraceSeqs(1, x), TraceSeqs(1, Y)) = tSAMat(x, Y)
                SAMat(TraceSeqs(1, Y), TraceSeqs(1, x)) = tSAMat(x, Y)
            Next Y
        Next x
    End If
    '''''''''''''''''''''''''''''''''''''''''''''''''''
    'End of Part J
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'XX = SAMat(ISeqs(0), ISeqs(1))
    'X = X
    'XX = SEventNumber
    'XX = SAMat(ISeqs(2), 10)
    
     'Erase tSAMat
     'Outputs trees if you want these for debugging purposes
     
     
     
     ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
     'Part K - fill in all the blanks in SAMat
     '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' If X = X Then
        'dont use fmat here - use involved instead
        'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(SAMat, 1), SAMat(0, 0), FMat(0, 0))
       
        Dummy = CleanFCMat2P(NextNo, NextNo, UBound(SAMat, 1), SAMat(0, 0), ListToRedo(0))
    ' Else
    '    For X = 0 To Nextno
    '        If ListToRedo(X) = 1 Then
    '            For Y = 0 To Nextno
    '
    '                SAMat(X, Y) = ((Nextno * 3) - 1) / 1000
    '                SAMat(Y, X) = ((Nextno * 3) - 1) / 1000
    '            Next Y
    '        End If
    '    Next X
    'End If
    
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'End of Part K
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
     '0.330
     '1.045 for 1834 seqs
    ' EE = Abs(GetTickCount)
    ' TT = EE - SS
     '1.544 for 3200
    'use SAMat to make minpair(1)
    MinDist(1) = 1000000
    Z = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If SAMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then '15-4 = 0.04, 15-11 = 0.014, 4-11=0.04
                MinDist(1) = SAMat(ISeqs(x), ISeqs(Y))
                MinPair(1) = Z
            End If
            Z = Z + 1
        Next Y
    Next x
    
    For x = 0 To NextNo
        
        SAMat(x, x) = 0
       
    Next x

End If

'Next XXX
'EEee = abs(gettickcount)
'TT = EEee - SSSSs '2781,2656 - fullc++,2360 with partial sections parallelization but with threadprivate for curtree
'x = x
If PermNextno > MemPoc Then
    'put samat onto the disk
    Call PutSAMat
    ReDim SAMat(0, 0)
    
End If




'exit if there is no phylogenetic evidence
If MinPair(0) = MinPair(1) And ForcePhylE = 1 Then
            
    If DebuggingFlag < 2 Then On Error Resume Next
    'If UBound(SCMat, 1) <> Nextno Then
    If PermNextno > MemPoc Then
    
    Else
        ReDim FCMatSmall(2, NextNo), SCMatSmall(2, NextNo)
        ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo)
    End If
    On Error GoTo 0
   ' End If
    Exit Sub

End If



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'SAMat is still not finished here - it is lacking proper estinated values for many array entries - these get added in part L
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' EE = Abs(GetTickCount)
' TT = EE - SS
'
 '0.320
'  SS = Abs(GetTickCount)


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Part L: Uses dstmat (which cntains bootrep distances and could get as big as reps*500*500))
'it makes tscmat on a first pass and tfcmat on a second pass.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'reps refers to the number of bootstrap reps needed when making fcmat and scmat
'this part only gets executed in the second of 2 passes from dordp
 If Reps > 0 And BootFlag = 1 And (MinPair(1) <> MinPair(0) Or LongFlag = 1 Or ForcePhylE = 0) Then
     Dim tMatch() As Byte
     TT = Abs(GetTickCount)
     If TT - GlobalTimer > 500 Then
        GlobalTimer = TT
        Form1.SSPanel1.Caption = "Making bootstrapped NJ tree"
        ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
    End If
     oDir = CurDir
     If DebuggingFlag < 2 Then On Error Resume Next
 
     ChDir App.Path
     ChDrive App.Path
     On Error GoTo 0
     'Perform bootstrap replicates
     Dim tSeqNum2() As Integer, tSeqnum() As Integer, WeightMod() As Long, Scratch() As Integer, Length As Long
     Dim Treestring As String, DstMat() As Single, Num1() As Long, Num2() As Long, num() As Double
     'XX = StrainSeq(1)
     
     'this does not need to use fmat - it should use a small version of fmat
     'Dummy = MaketSeqNum(Len(StrainSeq(0)), NextNo, tSeqNum2(0, 0), SeqNum(0, 0), FMat(0, 0)
     Dim LoadSeqNumFromFile As Byte
     If ((Len(StrainSeq(0)) * NSeqs) > 20000000) Then  ' need to first create tseqnum on disk, then drop seqnum to disk, erase it, redim tseqnum and load it from disk
        Dim UBSN1 As Long, UBSN2 As Long
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        ReDim tSeqNum2(Len(StrainSeq(0))), tListToRedo(NextNo)
        Open "RDP5tSeqnum2" + UFTag For Binary As #FF
        For x = 0 To NextNo
            If ListToRedo(x) = 0 Then
                Dummy = MaketSeqNum2(Len(StrainSeq(0)), 0, tSeqNum2(0), SeqNum(0, x), tListToRedo(0))
                Put #FF, , tSeqNum2()
            End If
        Next x
        Close #FF
        LoadSeqNumFromFile = 1
        UBSN1 = UBound(SeqNum, 1)
        UBSN2 = UBound(SeqNum, 2)
        '@'@'@'@
        Open "RDP5SeqNumFile" + UFTag For Binary As #FF
        Put #FF, , SeqNum
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
        Erase SeqNum
        ReDim tSeqNum2(Len(StrainSeq(0)), NSeqs)
        Open "RDP5tSeqnum2" + UFTag For Binary As #FF
            Get #FF, , tSeqNum2()
        Close #FF
        Kill "RDP5tSeqnum2" + UFTag
     Else
        LoadSeqNumFromFile = 0
        ReDim tSeqNum2(Len(StrainSeq(0)), NSeqs)
        Dummy = MaketSeqNum2(Len(StrainSeq(0)), NextNo, tSeqNum2(0, 0), SeqNum(0, 0), ListToRedo(0))
     End If
     
     
     'Erase tSeqNum2
     
     
        
    
     'This part makes the identicalf and identical R arrays that are used by ViSRD
     'Call MakeConsenseFiles(NSeqs)
     '0.411
     Dim IdentiCalFX() As Long, IdenticalRX() As Long, BPos10 As Long, EPos10 As Long
'     XX = IdenticalF(Len(StrainSeq(0)))
     For x = 0 To 1
         FF = FreeFile
'         SS = Abs(GetTickCount)
         'Close #FF
         
         If x = 0 Then 'ie inner alignment
             Call MakeETSeqNum(NSeqs, Length, BPos3, EPos3, tSeqnum(), tSeqNum2())
             Call MakeNodeDepth(NSeqs, TraceBak(), tSAMat(), NodeDepth())
             
             BPos10 = BPos3
             EPos10 = EPos3
         Else
             Call MakeETSeqNum(NSeqs, Length, EPos3 + 1, BPos3 - 1, tSeqnum(), tSeqNum2())
             Erase tSeqNum2
             Call MakeNodeDepth(NSeqs, TraceBak(), tFAMat(), NodeDepth())
             BPos10 = EPos3 + 1
             If BPos10 > Len(StrainSeq(0)) Then BPos10 = 1
             EPos10 = BPos3 - 1
             If EPos10 < 1 Then EPos10 = Len(StrainSeq(0))
         End If
         
         ReDim IdentiCalFX(Len(StrainSeq(0))), IdenticalRX(Len(StrainSeq(0)))
         If BPos10 < EPos10 Then
            If BPos10 = 0 Then BPos10 = 1
            b = 1
            For A = BPos10 To EPos10
                IdentiCalFX(b) = IdenticalF(A) - IdenticalF(BPos10 - 1)
                b = b + 1
            Next A
            
            'find first non-identical site after bpos10
            For C = BPos10 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
            Next C
            b = 1
            For A = IdenticalF(C) To IdenticalF(EPos10)
                IdenticalRX(b) = IdenticalR(A) - (BPos10 - 1)
                b = b + 1
            Next A
        Else
            If BPos10 = 0 Then BPos10 = 1
            b = 1
            For A = BPos10 To Len(StrainSeq(0))
                IdentiCalFX(b) = IdenticalF(A) - IdenticalF(BPos10 - 1)
                b = b + 1
            Next A
            C = b - 1
            '@
            For A = 1 To EPos10
                If b <= UBound(IdentiCalFX, 1) Then
                    IdentiCalFX(b) = IdenticalF(A) + IdentiCalFX(C)
                Else
                    Exit For
                End If
                b = b + 1
            Next A
           
            'find first non-identical site after bpos10
            For C = BPos10 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
            Next C
            If C = Len(StrainSeq(0)) + 1 Then
                For C = 1 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
                Next C
                D = 0
            Else
                b = 1
                For A = IdenticalF(C) To IdenticalF(Len(StrainSeq(0)))
                    IdenticalRX(b) = IdenticalR(A) - (BPos10 - 1)
                    b = b + 1
                Next A
                D = b - 1
                For C = 1 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
                Next C
            End If
            b = 1
            '@
            For A = IdenticalF(C) To IdenticalF(EPos10)
            
                IdenticalRX(b) = IdenticalR(A) + IdenticalRX(D)
                b = b + 1
            Next A
            
            
        End If
         
         
         Call MakeTMatch(NSeqs, tMatch(), NodeDepth())
         
         
         
         ReDim WeightMod(Reps, Length - 1), Scratch(Length)
         
         '0.461
         '0.441
         
         
         'Dummy = SEQBOOT(BSRndNumSeed, Reps, Length, Scratch(0), WeightMod(0, 0))
         '@'@
         Dummy = SEQBOOT2(BSRndNumSeed, Reps, Length, Scratch(0), WeightMod(0, 0))
         
         '0.671
         '0.641
         
         
         
         TT = Abs(GetTickCount)
         If TT - GlobalTimer > 500 Then
          GlobalTimer = TT
            If x = 0 Then
                Form1.SSPanel1.Caption = "Making first set of bootsrap distance matrices"
                ETx = Abs(GetTickCount)
               Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            Else
                Form1.SSPanel1.Caption = "Making second set of bootsrap distance matrices"
                ETx = Abs(GetTickCount)
               Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            End If
         
         'Form1.SSPanel1.Refresh
         'Form1.Refresh
         
            If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
         End If
         SS = Abs(GetTickCount)
        ' For ZZ = 1 To 100
         '@
         Dim DstMat2() As Single
         ReDim ValidX(Reps), DiffsX(Reps), DstMat(Reps, NSeqs, NSeqs)
         'redim DstMat2(Reps, NSeqs, NSeqs)
         
'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@'@
         'Dummy = FastBootDistIP(1, Reps, NSeqs, Length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqnum(0, 0), DstMat(0, 0, 0))
         Dummy = FastBootDistIP6(1, Reps, NSeqs, Length, DiffsX(0), ValidX(0), UBound(WeightMod, 1), UBound(WeightMod, 2), WeightMod(0, 0), UBound(tSeqnum, 1), UBound(tSeqnum, 2), tSeqnum(0, 0), UBound(DstMat, 1), UBound(DstMat, 2), DstMat(0, 0, 0))
'        EE = abs(gettickcount)
'         TT = EE - SS
'         If TT < 7 Then TT = T
'         FBD = FBD + TT
'        x = x
        'Next ZZ
         
         
'         For A = 0 To NSeqs
'            For b = 0 To NSeqs
'                For C = 0 To Reps
'                    If DstMat2(C, A, b) <> DstMat(C, A, b) Then
'                        x = x
'                    End If
'                Next C
'            Next b
'         Next A
         
         
        ' 307, 329 seconds with ip
        ' 447 seconds with ip7
        '@'@
         Erase tSeqnum
         
         If CurrentlyRunningFlag = 1 Then
            DoEvents
         End If
         
         If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
         
         
         '2.668 for 975 x 779 nt long seqs with 10 reps
         '86.175 for 975 X 11381 seqs with 10 reps
         x = x
         '0.873 for 3200
         '2.864
         '2.153 with fastbootdist
         '2.144,1.933, 1.913, 1.883, 1.882
         
         
         If AbortFlag = 1 Then Exit For
         ReDim DLen(NSeqs)
         
'         SS = abs(gettickcount)
'         For ZZ = 0 To 100
'
         If x = x Then
            'ReDim tFMat(NSeqs, NSeqs),
            'SS = abs(gettickcount)
            '@'@'@
             Dummy = TreeRepsP(NSeqs, Reps, BSRndNumSeed, NameLen, DstMat(0, 0, 0), 0, LTree(0), tMatch(0, 0), DLen(0))
'            EE = abs(gettickcount)
'            TT = EE - SS '1.484; 1.015
'            '2.609,2.609
'            '63 seconds on this
'            TotFGCT = TotFGCT + TT
'            Form1.Caption = TotFGCT
'            For ZZ = 0 To NextNo
'                XX = DLen(ZZ)
'                If DLen(ZZ) > 0 Then
'                    x = x
'                End If
'            Next ZZ
            x = x
         Else
             Dim FT As Long
             ReDim tFMat(NSeqs, NSeqs)
             
             For Y = 1 To Reps
                 
                 FT = Abs(GetTickCount)
                 If Abs(FT - GlobalTimer) > 500 Then
                     
                     GlobalTimer = FT
                     '
                     Form1.SSPanel1.Caption = Trim(Str(Y + (x * 10))) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
                     Call UpdateF2Prog
                     'Form1.SSPanel1.Refresh
                     'Form1.Refresh
                     
                     '
                    If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
                End If
                 If AbortFlag = 1 Then
                     Close #FF
                     Exit For
                 End If
                 ReDim FHolder(NSeqs * 40 * 2)
                 
                 Dummy = TransferDistP(NSeqs, Y, Reps, tFMat(0, 0), DstMat(0, 0, 0))
                 'ReDim ColTotals(NSeqs)
                 'SS = Abs(GetTickCount)
                 '
    '             LTree(0) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tFMat(0, 0), FHolder(0), ColTotals(0), tFAMat(0, 0))
                 x = x
                 
                 LTree(0) = Clearcut(0, NSeqs, 1, 100, BSRndNumSeed, 0, UBound(tFMat, 1), tFMat(0, 0), FHolder(0))
    '             For YY = 0 To UBound(FHolder, 1)
    '                If FHolder(YY) <> 0 Then
    '                    x = x
    '                End If
    '             Next YY
'                 Open "test2.tre" For Binary As #1
'                 Put #1, , FHolder
'                 Close #1
                 x = x
                 '2.965
                 'XX = tFMat(1, 0)
                'XX = UBound(FHolder, 1)
                'XX = PermNextno
                
                If AbortFlag = 1 Then
                     Close #FF
                     Exit For
                 End If
                 'Call TreeGroups(NSeqs, FHolder(), LTree(0), NameLen, tMatch(), DLen())
                
                 Dummy = TreeGroupsXP(NSeqs, FHolder(0), LTree(0), NameLen, tMatch(0, 0), DLen(0))
                 
'                 For ZZ = 0 To NextNo
'                    If DLen(ZZ) > 0 Then
'                        x = x
'                    End If
'                 Next ZZ
                 
                 If AbortFlag = 1 Then
                     Close #FF
                     Exit For
                 End If
                 TT = Abs(GetTickCount)
                If TT - GlobalTimer > 500 Then
                   GlobalTimer = TT
                   Form1.SSPanel1.Caption = Trim(Str(Reps * x + (Y / Reps * 10))) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
                   If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
                End If
             Next Y
         End If
'         Next ZZ
'         EE = abs(gettickcount)
'         TT = EE - SS '3563 VB, 3609 - C++ non-parallel:1234 parallel
'
'         '
'         TT = Abs(GetTickCount)
         If TT - GlobalTimer > 500 Then
            GlobalTimer = TT
            Form1.SSPanel1.Caption = Trim(Str(Reps * 2)) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
            If DebuggingFlag < 3 Then Form1.WindowState = Form1.WindowState
         End If
         If AbortFlag = 1 Then
            
            Exit For
         End If
         
         Erase DstMat
         
         '3.555
         '3.075
         
         For Z = 0 To NSeqs
              DLen(Z) = CLng((DLen(Z) + 1) / (Reps + 1) * 100)
              'X = X '100,100,100,100,82,82,100,100,64,100,100,100,55
         Next Z
         'Collapse nodes in FAMat/SAMat with no support - Put these in FCMat and SCMat
         'famat/samat = tree distance matrices - not path lengths but an encoding of
         'the rooted tree topology in a distance matrix
         'fcmat/scmat = tree distance matrices with nodes collapsed
         'Dlen = array containing bootstrap support for nodes
         'tracebak = contains an encoding of the tree topology - ie tells you which node corrsponds to which
         'distance in samat/famat
         ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
         If x = 0 Then
             Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tSAMat(), tSCMat())
             Erase tSAMat
             ReDim SCMat(NextNo, NextNo)
             '@'@
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    SCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tSCMat(Z, Y)
                    SCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tSCMat(Z, Y)
                Next Y
            Next Z
            
            Erase tSCMat
            
            'this does not need to use fmat - it should use listtoredo
            'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(SCMat, 1), SCMat(0, 0), FMat(0, 0))
            Dummy = CleanFCMat2(NextNo, NextNo, UBound(SCMat, 1), SCMat(0, 0), ListToRedo(0))

            ReDim BestSeqS(NextNo)
            
            For Z = 0 To NextNo
                BestSeqS(Z) = Z
            Next Z
            If PermNextno > MemPoc Then
                'get smat off the disk
                
                Call GetSMat
            End If
            Dummy = FindBesSeqS(NextNo, ListToRedo(0), SMat(0, 0), BestSeqS(0))
            
            If PermNextno > MemPoc Then
                ReDim SMat(0, 0)
                'load samat off the disk
                Call GetSAMat
            End If
            
            '@
            Dummy = ReAddDistsB(NextNo, ListToRedo(0), SAMat(0, 0), SCMat(0, 0), BestSeqS(0))
            Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
            Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
            If PermNextno > MemPoc Then
                
                Call PutSCMat
                ReDim SCMat(0, 0)
                
                'drop SAMat and SCMat back onto the disk
                
                Call PutSAMat
                ReDim SAMat(0, 0)
                
                
            End If
         Else
             
             Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tFAMat(), tFCMat())
             Erase tFAMat
             ReDim FCMat(NextNo, NextNo)
             ReDim FCMatSmall(2, NextNo)
             '@
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    '
                    FCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tFCMat(Z, Y)
                    FCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tFCMat(Z, Y)
                Next Y
            Next Z
            
        
            Erase tFCMat
            'dont use fmat here - its shitty - use a smaller array
            XX = UBound(FMat, 1)
            'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), FMat(0, 0))
            Dummy = CleanFCMat2(NextNo, NextNo, UBound(FCMat, 1), FCMat(0, 0), ListToRedo(0))

            ReDim BestSeqF(NextNo)
            For Z = 0 To NextNo
                BestSeqF(Z) = Z
            Next Z
            If PermNextno > MemPoc Then
                'get fmat off the disk
                Call GetFMat
            End If
            Dummy = FindBesSeqS(NextNo, ListToRedo(0), FMat(0, 0), BestSeqF(0))
            
            If PermNextno > MemPoc Then
                ReDim FMat(0, 0)
            End If
            If PermNextno > MemPoc Then
                'load famat off the disk
                Call GetFAMat
            End If
            
            Dummy = ReAddDistsB(NextNo, ListToRedo(0), FAMat(0, 0), FCMat(0, 0), BestSeqF(0))
            
            Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
            Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
            If PermNextno > MemPoc Then
                'drop fCMat back onto the disk
                Call PutFCMat
                ReDim FCMat(0, 0)
                
            End If
            If PermNextno > MemPoc Then
                'drop fAMat  onto the disk
                Call PutFAMat
                ReDim FAMat(0, 0)
                
            End If

         End If
         '3.075
         
     Next x
     'Exit Sub
     '9.794
     '8.813
      'Exit Sub
     
     'ReDim FCMat(Nextno, Nextno), SCMat(Nextno, Nextno)
     If AbortFlag = 1 Then
        
        
        If LoadSeqNumFromFile = 1 Then
            
            ReDim SeqNum(UBSN1, UBSN2)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5SeqNumFile" + UFTag For Binary As #FF
            Get #FF, , SeqNum
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        If UBound(FCMat, 1) = 0 Then
            ReDim FCMatSmall(2, NextNo)
        End If
        If UBound(SCMat, 1) = 0 Then
            ReDim SCMatSmall(2, NextNo)
        End If
        If PermNextno > MemPoc Then
        
        Else
            If UBound(FCMat, 1) = 0 Then
                ReDim FCMat(NextNo, NextNo)
            End If
            
            If UBound(SCMat, 1) = 0 Then
                ReDim SCMat(NextNo, NextNo)
            End If
            
        End If
        On Error GoTo 0
        Exit Sub
     End If
     
     
     ' This is where guestimated values were readded to FAMat, FCmat, SAMat and SCMat
     
     
     'If x = x Then
'        Dummy = CleanSCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), SCMat(0, 0), FMat(0, 0))
        
'     Else
'
'        For x = 0 To NextNo
'            If FMat(x, x) = 3 Then
'                For Y = 0 To NextNo
'                    FCMat(x, Y) = ((NextNo * 3) - 1) / 1000
'                    FCMat(Y, x) = FCMat(x, Y)
'                    SCMat(x, Y) = ((NextNo * 3) - 1) / 1000
'                    SCMat(Y, x) = SCMat(x, Y)
'                Next Y
'            End If
'
'        Next x
'        For x = 0 To NextNo
'            For Y = x + 1 To NextNo
'                FCMat(x, Y) = (CLng(FCMat(x, Y) * 10000000)) / 10000000
'                FCMat(Y, x) = FCMat(x, Y)
'                SCMat(x, Y) = (CLng(SCMat(x, Y) * 10000000)) / 10000000
'                SCMat(Y, x) = SCMat(x, Y)
'            Next Y
'        Next x
'    End If
     If DebuggingFlag < 2 Then On Error Resume Next
     ChDir oDir
     ChDrive oDir
     On Error GoTo 0
 ElseIf Reps = 0 And BootFlag = 1 And (MinPair(1) <> MinPair(0) Or LongFlag = 1 Or ForcePhylE = 0) Then
 
    
     oDir = CurDir
     If DebuggingFlag < 2 Then On Error Resume Next
 
     ChDir App.Path
     ChDrive App.Path
     On Error GoTo 0
     'Perform bootstrap replicates
'     Dim tSeqNum2() As Integer, tSeqnum() As Integer, WeightMod() As Long, Scratch() As Integer, Length As Long
'     Dim Treestring As String, DstMat() As Single, Num1() As Long, Num2() As Long, num() As Double
     'XX = StrainSeq(1)
     
     'this does not need to use fmat - it should use a small version of fmat
     'Dummy = MaketSeqNum(Len(StrainSeq(0)), NextNo, tSeqNum2(0, 0), SeqNum(0, 0), FMat(0, 0)
     'Dim LoadSeqNumFromFile As Byte
     
     
     
     'Erase tSeqNum2
     
     
        
    
     'This part makes the identicalf and identical R arrays that are used by ViSRD
     'Call MakeConsenseFiles(NSeqs)
     '0.411
     'Dim IdentiCalFX() As Long, IdenticalRX() As Long, BPos10 As Long, EPos10 As Long
'     XX = IdenticalF(Len(StrainSeq(0)))
     For x = 0 To 1
         If x = 0 Then
             'Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tSAMat(), tSCMat())
             'Erase tSAMat
             ReDim SCMat(NextNo, NextNo)
             '@'@
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    SCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tSAMat(Z, Y)
                    SCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tSAMat(Z, Y)
                Next Y
            Next Z
            
            Erase tSAMat
            
            'this does not need to use fmat - it should use listtoredo
            'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(SCMat, 1), SCMat(0, 0), FMat(0, 0))
            '@
            Dummy = CleanFCMat2(NextNo, NextNo, UBound(SCMat, 1), SCMat(0, 0), ListToRedo(0))

            ReDim BestSeqS(NextNo)
            '$
            For Z = 0 To NextNo
                BestSeqS(Z) = Z
            Next Z
            If PermNextno > MemPoc Then
                'get smat off the disk
                
                Call GetSMat
            End If
            Dummy = FindBesSeqS(NextNo, ListToRedo(0), SMat(0, 0), BestSeqS(0))
            
            If PermNextno > MemPoc Then
                ReDim SMat(0, 0)
                'load samat off the disk
                Call GetSAMat
            End If
            
            '@'@'&
            Dummy = ReAddDistsB(NextNo, ListToRedo(0), SAMat(0, 0), SCMat(0, 0), BestSeqS(0))
            Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
            Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
            If PermNextno > MemPoc Then
                
                Call PutSCMat
                ReDim SCMat(0, 0)
                
                'drop SAMat and SCMat back onto the disk
                
                Call PutSAMat
                ReDim SAMat(0, 0)
                
                
            End If
         Else
             
             'Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tFAMat(), tFCMat())
             
             ReDim FCMat(NextNo, NextNo)
             ReDim FCMatSmall(2, NextNo)
             '@'@'@
             For Z = 0 To NSeqs
                '@
                For Y = x + 1 To NSeqs
                    '
                    FCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tFAMat(Z, Y)
                    FCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tFAMat(Z, Y)
                Next Y
            Next Z
            Erase tFAMat
        
            'Erase tFCMat
            'dont use fmat here - its shitty - use a smaller array
            XX = UBound(FMat, 1)
            'Dummy = CleanFCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), FMat(0, 0))
            Dummy = CleanFCMat2(NextNo, NextNo, UBound(FCMat, 1), FCMat(0, 0), ListToRedo(0))

            ReDim BestSeqF(NextNo)
            For Z = 0 To NextNo
                BestSeqF(Z) = Z
            Next Z
            If PermNextno > MemPoc Then
                'get fmat off the disk
                Call GetFMat
            End If
            Dummy = FindBesSeqS(NextNo, ListToRedo(0), FMat(0, 0), BestSeqF(0))
            
            If PermNextno > MemPoc Then
                ReDim FMat(0, 0)
            End If
            If PermNextno > MemPoc Then
                'load famat off the disk
                Call GetFAMat
            End If
            '&'&
            Dummy = ReAddDistsB(NextNo, ListToRedo(0), FAMat(0, 0), FCMat(0, 0), BestSeqF(0))
            
            Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
            Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
            If PermNextno > MemPoc Then
                'drop fCMat back onto the disk
                Call PutFCMat
                ReDim FCMat(0, 0)
                
            End If
            If PermNextno > MemPoc Then
                'drop fAMat  onto the disk
                Call PutFAMat
                ReDim FAMat(0, 0)
                
            End If

         End If
         '3.075
         
     Next x
     'Exit Sub
     '9.794
     '8.813
      'Exit Sub
     
     'ReDim FCMat(Nextno, Nextno), SCMat(Nextno, Nextno)
     If AbortFlag = 1 Then
        
        
        If LoadSeqNumFromFile = 1 Then
            
            ReDim SeqNum(UBSN1, UBSN2)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5SeqNumFile" + UFTag For Binary As #FF
            Get #FF, , SeqNum
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        If UBound(FCMat, 1) = 0 Then
            ReDim FCMatSmall(2, NextNo)
        End If
        If UBound(SCMat, 1) = 0 Then
            ReDim SCMatSmall(2, NextNo)
        End If
        If PermNextno > MemPoc Then
        
        Else
            If UBound(FCMat, 1) = 0 Then
                ReDim FCMat(NextNo, NextNo)
            End If
            
            If UBound(SCMat, 1) = 0 Then
                ReDim SCMat(NextNo, NextNo)
            End If
            
        End If
        On Error GoTo 0
        Exit Sub
     End If
     
     
     ' This is where guestimated values were readded to FAMat, FCmat, SAMat and SCMat
     
     
     'If x = x Then
'        Dummy = CleanSCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), SCMat(0, 0), FMat(0, 0))
        
'     Else
'
'        For x = 0 To NextNo
'            If FMat(x, x) = 3 Then
'                For Y = 0 To NextNo
'                    FCMat(x, Y) = ((NextNo * 3) - 1) / 1000
'                    FCMat(Y, x) = FCMat(x, Y)
'                    SCMat(x, Y) = ((NextNo * 3) - 1) / 1000
'                    SCMat(Y, x) = SCMat(x, Y)
'                Next Y
'            End If
'
'        Next x
'        For x = 0 To NextNo
'            For Y = x + 1 To NextNo
'                FCMat(x, Y) = (CLng(FCMat(x, Y) * 10000000)) / 10000000
'                FCMat(Y, x) = FCMat(x, Y)
'                SCMat(x, Y) = (CLng(SCMat(x, Y) * 10000000)) / 10000000
'                SCMat(Y, x) = SCMat(x, Y)
'            Next Y
'        Next x
'    End If
     If DebuggingFlag < 2 Then On Error Resume Next
     ChDir oDir
     ChDrive oDir
     On Error GoTo 0
 
 
 Else
     'this is where things go on the first of 2 passes from do rdp
     'XX = UBound(Distance, 1)
     Erase tSeqNum2
     Erase tSeqnum
     
     'Erase MinP
     'XX = UBound(Daught, 2)
    
     
        ReDim BestSeqS(NextNo)
            
        For Z = 0 To NextNo
            BestSeqS(Z) = Z
        Next Z
        If PermNextno > MemPoc Then
            'get smat off the disk
            
            Call GetSMat
        End If
        Dummy = FindBesSeqS(NextNo, ListToRedo(0), SMat(0, 0), BestSeqS(0))
        
        If PermNextno > MemPoc Then
            ReDim SMat(0, 0)
            'load samat off the disk
            Call GetSAMat
        End If
        '@
        Dummy = ReAddDistsB(NextNo, ListToRedo(0), SAMat(0, 0), SCMat(0, 0), BestSeqS(0))
        Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
        Call MakeSmallArrays(ISeqs(), SAMat(), SCMatSmall())
        
        
        If PermNextno > MemPoc Then
           oDirX = CurDir
           ChDrive App.Path
           ChDir App.Path
           FF = FreeFile
           UBSCMat = UBound(SAMat, 1)
           Open "RDP5SCMat" + UFTag For Binary As #FF
           Put #FF, , SAMat
           Close #FF
          
           ReDim SCMat(0, 0)
           
           
           ChDrive oDirX
           ChDir oDirX
        Else
            ReDim SCMat(NextNo, NextNo)
            For x = 0 To NextNo
                For Y = 0 To NextNo
                    SCMat(x, Y) = SAMat(x, Y)
                Next Y
            Next x
        End If
        
        
        
     ReDim BestSeqF(NextNo)
            
        For Z = 0 To NextNo
            BestSeqF(Z) = Z
        Next Z
        If PermNextno > MemPoc Then
            'get smat off the disk
            
            Call GetFMat
        End If
        Dummy = FindBesSeqS(NextNo, ListToRedo(0), FMat(0, 0), BestSeqF(0))
        
        If PermNextno > MemPoc Then
            ReDim FMat(0, 0)
            'load samat off the disk
            Call GetFAMat
        End If
        '@
        Dummy = ReAddDistsB(NextNo, ListToRedo(0), FAMat(0, 0), FCMat(0, 0), BestSeqF(0))
        Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
        Call MakeSmallArrays(ISeqs(), FAMat(), FCMatSmall())
        
        
     
     
     If PermNextno > MemPoc Then
        'drop fCMat back onto the disk
        '@
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        
        'Call MakeSmallArrays(ISeqs(), FAMat(), FCMatSmall()) 'this looks wrong but it must be famat - look carefully
        UBFCMat = UBound(FAMat, 1)
        Open "RDP5FCMat" + UFTag For Binary As #FF
        Put #FF, , FAMat
        Close #FF
        PutFAMat
        ReDim FCMat(0, 0)
        ReDim FAMat(0, 0)
        ChDrive oDirX
        ChDir oDirX
     Else
        ReDim FCMat(NextNo, NextNo)
        For x = 0 To NextNo
            For Y = 0 To NextNo
                FCMat(x, Y) = FAMat(x, Y)
            Next Y
        Next x
     End If
     
     
     If UBound(FAMat, 1) = NextNo And UBound(FAMat, 2) = NextNo And UBound(SAMat, 1) = NextNo And UBound(SAMat, 2) = NextNo And PermNextno > MemPoc Then
     'do the array copy on disk rather than in actual memory (ie copying famat to fcmat and samat to scmat)
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
        
        
        Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
        
        
        ChDrive oDirX
        ChDir oDirX
     Else
        UBFM = UBound(FMat, 1)
        If UBFM > NextNo Then
            Call MakeSmallArrays(ISeqs(), FMat(), FMatSmall())
        End If
        UBSM = UBound(SMat, 1)
        If UBSM > 1 Then
            Call MakeSmallArrays(ISeqs(), SMat(), SMatSmall())
        End If
        '@
        If PermNextno > MemPoc Then
           oDirX = CurDir
           ChDrive App.Path
           ChDir App.Path
           UBFM = UBound(FMat, 1)
           UBSM = UBound(SMat, 1)
           If UBFM > 0 Then
                Call PutFMat
                ReDim FMat(0, 0)
           End If
           If UBSM > 0 Then
                UBSMat = UBSM
                Open "SMat" + UFTag For Binary As #FF
                Put #FF, , SMat
                Close #FF
                ReDim SMat(0, 0)
            End If
           
            ChDrive oDirX
            ChDir oDirX
        
        
        Else
            ReDim FCMat(NextNo, NextNo)
        End If
        If PermNextno > MemPoc And UBound(FAMat, 1) = 0 And UBFAMat = NextNo Then
            Call GetFAMat
        Else
            ReDim FAMat(NextNo, NextNo)
        End If
        If UBound(FAMat, 1) = NextNo Then
            Dummy = CopyFloatArray(NextNo, UBound(FCMat, 1), UBound(FAMat, 1), FAMat(0, 0), FCMat(0, 0))
        End If
        FF = FreeFile
        
        Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
        Call MakeSmallArrays(ISeqs(), FAMat(), FAMatSmall())
        If PermNextno > MemPoc Then
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
           Open "FCMat" + UFTag For Binary As #FF
           Put #FF, , FCMat
           Close #FF
           ReDim FCMat(0, 0)
           
           Open "FAMat" + UFTag For Binary As #FF
           Put #FF, , FAMat
           Close #FF
           ReDim FAMat(0, 0)
           ChDrive oDirX
            ChDir oDirX
        End If
        ReDim SCMat(NextNo, NextNo)
        
        If PermNextno > MemPoc Then
            Call GetSAMat
        End If
        
        If UBound(SAMat, 1) <> NextNo Then
            ReDim SAMat(NextNo, NextNo)
        End If
        '@
        If UBound(SAMat, 1) = NextNo Then
            Dummy = CopyFloatArray(NextNo, UBound(SCMat, 1), UBound(SAMat, 1), SAMat(0, 0), SCMat(0, 0))
        End If
        Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
        Call MakeSmallArrays(ISeqs(), SAMat(), SAMatSmall())
        'need to do some memory gymnastics
        If PermNextno > MemPoc Then
           Call PutSCMat
           ReDim SCMat(0, 0)
           
           Call PutSAMat
           ReDim SAMat(0, 0)
        
           'UBFM = UBound(FMat, 1)
           'UBSM = UBound(SMat, 1)
'           ReDim FMat(UBFM, UBFM)
'           FF = FreeFile
'           Open "FMat" + UFTag For Binary As #FF
'           Get #FF, , FMat
'           Close #FF
'
'           ReDim SMat(UBSM, UBSM)
'           Open "SMat" + UFTag For Binary As #FF
'           Get #FF, , SMat
'           Close #FF

        End If
     End If
     
 End If
'
'EE = Abs(GetTickCount)
'    TT = EE - SS
'For x = 0 To NextNo
'    For Y = 0 To NextNo
'        If SCMat(x, Y) <> SAMat(x, Y) Then
'            x = x
'        End If
'    Next Y
'Next x

x = x

'Make sure diagonals = 0


If PermNextno > MemPoc Then
    If UBound(TreeDistance, 1) > 0 Then
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    
        ChDrive oDirX
        ChDir oDirX
    End If
End If



If LoadSeqNumFromFile = 1 Then
    If CompressSVSDFlag = 1 Then
        Erase TreeY
        Erase SeqText
    End If
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    
    
    If TreeXInFileFlag = 1 Then
        Erase TreeX
    End If
    If DebuggingFlag < 3 Then On Error Resume Next
    UB = -1
    ReDim SeqNum(UBSN1, UBSN2)
    UB = UBound(SeqNum, 1)
    On Error GoTo 0
    If UB = -1 Then
        If UBound(SCMat, 2) > 0 Then
            Call MakeSmallArrays(ISeqs(), SCMat(), SCMatSmall())
            Call PutSCMat
            ReDim SCMat(0, 0)
        End If
        If UBound(FCMat, 1) > 0 Then
            Call MakeSmallArrays(ISeqs(), FCMat(), FCMatSmall())
            Call PutFCMat
            ReDim FCMat(0, 0)
        End If
        ReDim SeqNum(UBSN1, UBSN2)
    End If
    Open "RDP5SeqNumFile" + UFTag For Binary As #FF
    Get #FF, , SeqNum
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
    
End If
'force minpair(0) to be different to minpair(1)
'If ReassortmentFlag = 1 Then
'    MinPair(0) = 0
'    MinPair(1) = 1
'End If

If (CLine <> "" And CLine <> " ") Then
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole vbClearLine & "      "
    
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole "Evidence of" & Str(SEventNumber) & " unique recombination events detected (" + Trim(Str(oRecombNo(100))) & " recombination signals remaining)       "
End If


End Sub

Public Sub MakeTMatch(NextNo As Long, tMatch() As Byte, NodeDepth() As Integer)
Dim Y As Long, x As Long
ReDim tMatch(NextNo, NextNo)
For x = 0 To NextNo
    For Y = 0 To NextNo
        If NodeDepth(x, Y) > -1 Then
            tMatch(x, NodeDepth(x, Y)) = 1
        Else
            Exit For
        End If
    Next Y
Next x
End Sub

Public Sub TreeGroups(NextNo As Long, THolder() As Byte, TLen As Long, NLen, tMatch() As Byte, DLen() As Single)
Dim Dummy As Long, x As Long, Y As Long, Z As Long, Cnt As Long, SeqID As Long, TArray() As Byte, nCount As Long


Dim Miss As Long, Hit As Long, DoneNode() As Byte

ReDim TArray(NextNo, NextNo)
ReDim DoneNode(NextNo)

'If X = X Then
'    SS = Abs(GetTickCount)
'@'@'@'@'@'@'@'@'@'@'@'@'@
    Dummy = TreeGroupsX(NextNo, THolder(0), TLen, NLen, DoneNode(0), TArray(0, 0), tMatch(0, 0), DLen(0))

End Sub
Public Sub TestMoveInTreeOlder(CompressSVSDFlag As Byte, Reps As Integer, BootFlag As Byte, BPos3 As Long, EPos3 As Long, SeqPair() As Byte, MinPair() As Byte, ISeqs() As Long, SeqNum() As Integer)
'XX = ISeqs(1)
'If Reps > 0 Then Reps = 30

Dim oDirX As String, oDir As String, NameLen As Long, MyValue As Long, CurTot As Long, onN As Long, TempVal As Long, Y As Long, Z As Long, Dummy As Long, x As Long, TT As Long, ETx As Long, LmB As Long
Dim A As Long, b As Long, C As Long, D As Long, e As Long
TT = Abs(GetTickCount)
If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
    If Form1.SSPanel1.Caption = "" Then Form1.SSPanel1.Caption = "Testing for phylogenetic evidence of recombination"
    ETx = Abs(GetTickCount)
    Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))

 '
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If
 ' ' '
'Form1.SSPanel1.Refresh

Dim FF As Long
Dim ValidX() As Single, DiffsX() As Single, ListToRedo() As Long
Dim Cutoff As Double, tFCMat() As Single, tSCMat() As Single, TraceBak() As Single, OS As String
Dim TotAdd As Long
Dim DLen() As Single, Treebyte() As Byte, NodeDepth() As Integer, BootDepth() As Integer, ReplaceVal As Double, AvDX As Double, k As Long

Dim EraseF As Byte
Dim tSMat() As Single, tFMat() As Single, MinDist(1) As Double, Outlyer(2) As Byte
Dim Valtot(1) As Long, MaxMD() As Long, Weight() As Long, Location() As Long, Ally() As Long, Alias() As Long, Px() As Integer, XX1() As Integer, XX2() As Integer
Dim LTree(1) As Long, FHolder() As Byte, SHolder() As Byte, Prod1() As Double, Prod2() As Double, Prod3() As Double, DEN() As Long
Dim UB As Long, NSeqs As Long, TraceSeqs() As Long, tFAMat() As Single, tSAMat() As Single
Dim SCO As Long

If EPos3 > Decompress(Len(StrainSeq(0))) Then EPos3 = Decompress(Len(StrainSeq(0)))
If BPos3 > Decompress(Len(StrainSeq(0))) Then BPos3 = Decompress(Len(StrainSeq(0)))

If EPos3 < 1 Then EPos3 = 1
If BPos3 < 1 Then BPos3 = 1

ReDim FCMat(0, 0), SCMat(0, 0)
ReDim SAMat(0, 0)
ReDim FAMat(0, 0)
APhys = Abs(MemSit.dwTotalPhys)
'memload = Abs(MemSit.dwMemoryLoad)
If APhys > 1000000000 Or APhys < 1000000 Then APhys = 1000000000
'APhys = CLng(APhys * ((100 - memload) / 100))

Cutoff = 50


'If DoQuick = 0 Then
'    Reps = 10
'Else
'    Reps = 0
'End If

LmB = Len(StrainSeq(0))
LmB = LmB * Reps
LmB = LmB * 32
If APhys < LmB Then
    Reps = CLng(Reps * (APhys / LmB))
End If


If BPos3 < EPos3 Then
    SCO = CLng((EPos3 - BPos3) / 2)
Else
    SCO = CLng((EPos3 + Len(StrainSeq(0)) - BPos3) / 2)
End If
If SCO > 20 Then SCO = 20

Dim UBFM As Long

If DebuggingFlag < 2 Then On Error Resume Next
UBFM = 0
UBFM = UBound(FMat, 1)
On Error GoTo 0
If LongWindedFlag = 1 Then
    
    If x = x Then
        'mp0 = -1
        If SEventNumber > 0 Then
            If NextNo <> UBFM Then
                ReDim FMat(NextNo, NextNo)
                DontRedoQuickDistFlag = 0
            Else
                For x = 0 To NextNo
                    FMat(x, x) = 0
                Next x
            End If
            
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = -1
            UB = UBound(SMat, 1)
            
            On Error GoTo 0
            
            If NextNo <> UB Then
                ReDim SMat(NextNo, NextNo)
                DontRedoQuickDistFlag = 0
            Else
                For x = 0 To NextNo
                    SMat(x, x) = 0
                Next x
            End If
            If DebuggingFlag < 2 Then On Error Resume Next
            UB = 0
            UB = UBound(SubValid, 1)
            On Error GoTo 0
            'XX = UBound(StrainSeq, 1)
            
            'distance(), output() could be dumped here
            'confirmp, comfirmpmi,confirmpma
            'confirm, comfirmmi,confirmma
            'treeseqnum
            'treedrawb
            'treeblocks
            'schemstring
            'schemblocks
            'mapblocks
            'XX = UBound(MapBlocks, 1)
            'Erase MapBlocks
    '        Erase ConfirmMi
    '        Erase ConfirmMa
            'XX = UBound(SeqNum, 2)
            XX = UBound(SubValid, 1)
            'XX = UBound(AnalysisList, 2)
            If UB <> NextNo Then '1827,1827
                ReDim SubValid(NextNo, NextNo)
                ReDim SubDiffs(NextNo, NextNo)
                DontRedoQuickDistFlag = 0
            End If
                'BeginMark = -1
                'EndMark = -1
            
               
          x = x
        Else
            If DontRedoQuickDistFlag = 0 Then
                ReDim FMat(NextNo, NextNo)
                ReDim SMat(NextNo, NextNo)
                ReDim SubValid(NextNo, NextNo)
                ReDim SubDiffs(NextNo, NextNo)
            Else
                For x = 0 To NextNo
                    FMat(x, x) = 0
                    SMat(x, x) = 0
                
                Next x
            End If
            'BeginMark = -1
            'EndMark = -1
        End If
    Else
        If DontRedoQuickDistFlag = 0 Then
            ReDim FMat(NextNo, NextNo)
            ReDim SMat(NextNo, NextNo)
            ReDim SubValid(NextNo, NextNo)
            ReDim SubDiffs(NextNo, NextNo)
        Else
            For x = 0 To NextNo
                FMat(x, x) = 0
                SMat(x, x) = 0
            Next x
        End If
    End If
   ' efl = 0
    
    If LongFlag = 0 Then
        TT = Abs(GetTickCount)
        If TT - GlobalTimer > 500 Then
            GlobalTimer = TT
            If Right(Form1.SSPanel1.Caption, 9) <> "evidence)" Then
            ' '
                Form1.SSPanel1.Caption = "Calculating distances"
                ETx = Abs(GetTickCount)
                Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            End If
             ' ' '
            'Form1.SSPanel1.Refresh
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
             '
        End If
        UB = UBound(PermValid, 1)
        'SS = Abs(GetTickCount)
        
        If BPos3 <> BeginMark Or EPos3 <> EndMark Then
            Dummy = vQuickDist(Len(StrainSeq(0)), NextNo, UB, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0), ISeqs(0))
        Else
            x = x
        End If
        
'        EE = Abs(GetTickCount)
'        TT = EE - SS
        MinDist(0) = 1000000
        MinDist(1) = 1000000
        
        Outlyer(0) = 2
        Outlyer(1) = 1
        Outlyer(2) = 0
        Z = 0
        
        If ISeqs(0) > UBound(FMat, 1) Or ISeqs(1) > UBound(FMat, 1) Or ISeqs(2) > UBound(FMat, 1) Then
            MinPair(0) = 0
            MinPair(1) = MinPair(0)
            MinDist(0) = 0
            MinDist(1) = 0
            Exit Sub
        End If
        
            For x = 0 To 1
                For Y = x + 1 To 2
                    If FMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then
                        MinDist(0) = FMat(ISeqs(x), ISeqs(Y))
                        MinPair(0) = Z
                        SeqPair(0) = x
                        SeqPair(1) = Y
                        SeqPair(2) = Outlyer(Z)
                    End If
                    
                    If SMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then
                        MinDist(1) = SMat(ISeqs(x), ISeqs(Y))
                        MinPair(1) = Z
                    End If
                    Z = Z + 1
                Next Y
            Next x
            
            If MinPair(0) = MinPair(1) And ForcePhylE = 1 Then
                
                If DebuggingFlag < 2 Then On Error Resume Next
                'If UBound(SCMat, 1) <> Nextno Then
                ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo)
                On Error GoTo 0
               ' End If
                Exit Sub
               ' efl = 1
            'ElseIf ReassortmentFlag = 1 Then
                'ReDim FCMat(Nextno, Nextno), SCMat(Nextno, Nextno)
                'Exit Sub
            
            End If
    End If
    
    '0.021
    
    
    
'    SS = Abs(GetTickCount)
    'For X = 1 To 1000
    If x = x Then
'        If BPos3 < EPos3 Then
'            If EPos3 - BPos3 < Len(StrainSeq(0)) / 2 Then
'                Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UB, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
'            Else
'                Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UB, EPos3, BPos3, SMat(0, 0), FMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
'            End If
'        Else
'            If Len(StrainSeq(0)) - BPos3 + EPos3 < Len(StrainSeq(0)) / 2 Then
'                Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UB, BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
'            Else
'                Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UB, EPos3, BPos3, SMat(0, 0), FMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
'            End If
'        End If
        
        'Form1.SSPanel1.Refresh
        'DoEvents
        'If BPos3 <> BeginMark Or EPos3 <> EndMark Then
            If DontRedoQuickDistFlag = 0 Then
                'Dummy = QuickDist(Len(StrainSeq(0)), Nextno, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDiffs(0, 0), SeqNum(0, 0))
                
                
                Dim AVD As Double, UDS As Double, tRedo() As Integer
                ReDim tRedo(NextNo)
                For x = 0 To NextNo
                    tRedo(x) = 1
                Next x
                
                'SS = Abs(GetTickCount)
                Call FastDistanceCalcZ(0, 0, BPos3, EPos3, NextNo, SubDiffs(), SubValid(), SeqNum(), SMat(), AVD, UDS, tRedo())
'                EE = Abs(GetTickCount)
'
'                TT = EE - SS
'                SS = gettickcocunt
                '@
                Dummy = FinishDists(Len(StrainSeq(0)), NextNo, UBound(PermValid, 1), BPos3, EPos3, FMat(0, 0), SMat(0, 0), SubValid(0, 0), SubDiffs(0, 0), PermValid(0, 0), PermDIffs(0, 0), SeqNum(0, 0))
                
'                If SEventNumber = 8 Then
'                    XX = SMat(ISeqs(2), ISeqs(0))
'                    XX = SubValid(ISeqs(2), ISeqs(0))
'                    XX = SubDiffs(ISeqs(2), ISeqs(0))
'                End If
'                EE = Abs(GetTickCount)
'                TT = EE - SS
'                X = X
            End If
            'XX = UBound(SeqSpaces, 1)
            
            
            
            'BeginMark = BPos3
           ' EndMark = EPos3
'        Else
'            X = X
'        End If
        'Form1.SSPanel1.Refresh
        'DoEvents
    Else
        Dim tRedoDist() As Integer
        ReDim tRedoDist(NextNo)
        'Call fastdistancecalcx(0,BP, EP, Nextno, FubDiffs(), FubValid(), SeqNum(), SMat(), AvDst, UDst, tRedoDist())
        
        Call MakeSFMats(NextNo, BPos3, EPos3, FMat(), SMat(), SubValid(), SubDiffs(), PermValid(), PermDIffs(), SeqNum(), tRedoDist())

    End If
    
    x = x
    'XX = SEventNumber
'    If SEventNumber = 80 Then
'        X = X
'    End If
    'Next X
'    EE = Abs(GetTickCount)
'    TT = EE - SS '2.902 seconds
'    'X = X
'    X = X
    
    'if sequences are compressed the distances in the matrices must be adjusted to account for this.
'    XX = Len(StrainSeq(0))
'    SS = Abs(GetTickCount)
    If EPos3 > Len(StrainSeq(0)) Then
        ReDim Preserve Decompress(EPos3)
        Decompress(EPos3) = Decompress(Len(StrainSeq(0)))
    End If
    If BPos3 > Len(StrainSeq(0)) Then
        ReDim Preserve Decompress(BPos3)
        Decompress(BPos3) = Decompress(Len(StrainSeq(0)))
    End If
    
    If Decompress(EPos3) <> EPos3 Or Decompress(BPos3) <> BPos3 Then 'this corrects distances if there is compression
        TotAdd = 0
        If Decompress(EPos3) > Decompress(BPos3) Then
            
            For x = Decompress(BPos3) To Decompress(EPos3)
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
        Else
            For x = Decompress(BPos3) To Decompress(Len(StrainSeq(0)))
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
            For x = 1 To Decompress(EPos3)
                If ABCons(x) > 0 Then
                    TotAdd = TotAdd + 1
                End If
            Next x
        End If
        For x = 0 To NextNo
            For Y = x + 1 To NextNo
                SubValid(x, Y) = SubValid(x, Y) + TotAdd
                SubValid(Y, x) = SubValid(x, Y)
                TempVal = PermValid(x, Y) - SubValid(x, Y)
                If TempVal > 0 Then
                    TempVal = (((TempVal - PermDIffs(x, Y)) - SubDiffs(x, Y)) / TempVal)
                    If TempVal > 0.25 Then
                        TempVal = (4 * TempVal - 1) / 3
                        TempVal = Log(TempVal)
                        FMat(x, Y) = -0.75 * TempVal
                        x = x
                    Else
                        FMat(x, Y) = 10
                    End If
                Else
                    FMat(x, Y) = 10
                    
                End If
                FMat(Y, x) = FMat(x, Y)
                TempVal = SubValid(x, Y)
                
                If TempVal > 0 Then
                    TempVal = (TempVal - SubDiffs(x, Y)) / TempVal
                    If TempVal > 0.25 Then
                        TempVal = (4 * TempVal - 1) / 3
                        TempVal = Log(TempVal)
                        SMat(x, Y) = -0.75 * TempVal
                        x = x
                    Else
                        SMat(x, Y) = 10
                    End If
                Else
                    SMat(x, Y) = 10
                    
                End If
                SMat(Y, x) = SMat(x, Y)
            Next Y
            
   
        Next x
    End If
    
    
    
    '0.240
    
   
    
    
    'Which pair is most closely related in the backgound?
    For x = 0 To NextNo
        FMat(x, x) = 0
    Next x
'    If X = 12345 Then
'        Open "distmat.csv" For Output As #1
'
'        For X = 0 To Nextno
'            OS = ""
'
'            For Y = 0 To Nextno
'                If PermValid(X, Y) > 0 Or X = X Then
'                    OS = OS + " 0" + Trim(Str(CLng(FMat(X, Y) * 10000) / 10000))
'                Else
'                    OS = OS + " 0.0000"
'                End If
'            Next Y
'            Print #1, OS
'        Next X
'        Close #1
'
'        X = X
'    End If

'Else
'    ReDim xx1(3), xx2(3), Prod1(Len(StrainSeq(0))), Prod2(Len(StrainSeq(0))), Prod3(Len(StrainSeq(0))), Alias(Len(StrainSeq(0))), Ally(Len(StrainSeq(0))), Location(Len(StrainSeq(0))), Weight(0, Len(StrainSeq(0)))
End If
 
'SS = Abs(GetTickCount)
'For X = 0 To Nextno
'    For Y = X + 1 To Nextno
'        FMat(X, Y) = (CLng(FMat(X, Y) * 10000000)) / 10000000
'        FMat(Y, X) = FMat(X, Y)
'        SMat(X, Y) = (CLng(SMat(X, Y) * 10000000)) / 10000000
'        SMat(Y, X) = SMat(X, Y)
'    Next Y
'Next X
'
'
'EE = Abs(GetTickCount)
'TT = EE - SS
'X = X
 '
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
'2,231 for 3200
'0.240

''Impute missing entries in distance matrices (ie with pernvalid/subvalid= 0)
''using a nearest neghbours method
'If X = 12345 And SEventNumber = 9 Then
'        Open "distmat.csv" For Output As #1
'        XX = CurDir
'        For X = 0 To PermNextno ' To 0 Step -1  'XXXX0 To
'            OS = ""
'
'            For Y = 0 To PermNextno    'xxxx 0 To
'                If SubValid(X, Y) > 0 Or X = X Then
'                    OS = OS + " 0" + Trim(Str(CLng(FMat(X, Y) * 10000) / 10000))
'                Else
'                    OS = OS + " 0.0000"
'                End If
'            Next Y
'            Print #1, OS
'        Next X
'        Close #1
'        X = X
'End If
'If SEventNumber = 80 Then
'    X = X
'End If
If LongWindedFlag = 1 Then

    'Dummy = CheckMatrix(UB, SCO, MinSeqSize, Nextno, ValTot(0), ISeqs(0), PermValid(0, 0), SubValid(0, 0), FMat(0, 0), SMat(0, 0), FAMat(0, 0), SAMat(0, 0))
    
    
    Call CheckMatrixX(UB, SCO, MinSeqSize, NextNo, Valtot(), ISeqs(), PermValid(), SubValid(), FMat(), SMat())

End If
If CompressSVSDFlag = 1 Then
    'compress subdiffs and subvalid
    Dim TSD() As Single, TSV() As Single
    ReDim TSD(2, NextNo), TSV(2, NextNo)
    '
    For x = 0 To 2
        For Y = 0 To NextNo
            TSD(x, Y) = SubDiffs(ISeqs(x), Y)
            TSV(x, Y) = SubValid(ISeqs(x), Y)
        Next Y
    Next x
    ReDim SubDiffs(2, NextNo), SubValid(2, NextNo)
    For x = 0 To 2
        For Y = 0 To NextNo
            SubDiffs(x, Y) = TSD(x, Y) ' = SubDiffs(ISeqs(X), Y)
            SubValid(x, Y) = TSV(x, Y) ' = SubValid(ISeqs(X), Y)
        Next Y
    Next x
    Erase TSD: Erase TSV
End If


'EE = Abs(GetTickCount)
'TT = EE - SS
'
'
'
'X = X
 '0.060

'Make bAckup of Fmat (it is destroyed by neighbour)
ReDim TraceSeqs(1, NextNo)
ReDim ListToRedo(NextNo)
'use this code to remove masked sequences for extra speed
If IndividualA = -1 Then
     '
    For x = 0 To NextNo
        If MaskSeq(x) > 0 Then
            FMat(x, x) = 3
            ListToRedo(x) = 1
        End If
    Next x
End If


NSeqs = -1
For x = 0 To NextNo
    If FMat(x, x) <> 3 Then
        NSeqs = NSeqs + 1
        
    End If
Next x
x = x


If NSeqs > 500 Or (NSeqs > 100 And Reps = 0) Then
    
    
    'remove irrelevant outlyers/inlyers
    Dim MAxD As Single, MinD As Single
    MAxD = 1: MinD = 0
    For x = 0 To 1
        For Y = x + 1 To 2
            If TreeDistance(ISeqs(x), ISeqs(Y)) < MAxD Then
                MAxD = TreeDistance(ISeqs(x), ISeqs(Y))
                A = ISeqs(x)
                b = ISeqs(Y)
            End If
            If TreeDistance(ISeqs(x), ISeqs(Y)) > MinD Then
                MinD = TreeDistance(ISeqs(x), ISeqs(Y))
                D = ISeqs(x)
                e = ISeqs(Y)
            End If
        Next Y
    Next x
    If A = D Or A = e Then
        A = b
    End If
    'XX = StraiName(A)
    'XX = StraiName(D)
    'XX = StraiName(E)
    'XX = StraiName(B)
    'XX = TreeDistance(A, D)
    'XX = TreeDistance(A, E)
    'XX = TreeDistance(D, E)
'    SS = Abs(GetTickCount)
    
    For x = 0 To NextNo
        If x <> A And x <> D And x <> e Then
            If FMat(x, x) < 3 Then
                If TreeDistance(A, x) < MAxD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            'XX = StraiName(Y)
                            'XX = StraiName(X)
                            If FMat(Y, Y) < 3 Then
                                If TreeDistance(A, Y) = TreeDistance(A, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                End If
                If TreeDistance(D, x) > MinD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            If FMat(Y, Y) < 3 Then
                                If TreeDistance(D, Y) = TreeDistance(D, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                
                End If
                'XX = UBound(TreeDistance, 1)
                'XX = UBound(Distance)
                If TreeDistance(e, x) > MinD Then
                    For Y = x + 1 To NextNo
                        If Y <> A And Y <> D And Y <> e Then
                            If FMat(Y, Y) < 3 Then
                                If TreeDistance(e, Y) = TreeDistance(e, x) Then
                                    FMat(Y, Y) = 3
                                    ListToRedo(Y) = 1
                                End If
                            End If
                        End If
                    Next Y
                
                End If
                
            End If
        End If
    
    Next x
'   EE =  Abs(GetTickCount)
'    TT = EE - SS
'
End If


NSeqs = -1
For x = 0 To NextNo
    If FMat(x, x) <> 3 Then
        NSeqs = NSeqs + 1
        TraceSeqs(0, x) = NSeqs
        TraceSeqs(1, NSeqs) = x
    
    End If
Next x
'0.260
Rnd (-BSRndNumSeed)
onN = UBound(FMat, 1)
If NSeqs > 100 Then
    Rnd (-BSRndNumSeed)
    If Reps = 0 And NSeqs > 100 Then
        'remove sequences from branches in tree between the inlyers and outlyer
        For x = 0 To NextNo
            If x <> A And x <> D And x <> e Then
                If FMat(x, x) < 3 Then
                    If TreeDistance(D, x) > MAxD And TreeDistance(D, x) < MinD Then
                        For Y = x + 1 To NextNo
                            If Y <> A And Y <> D And Y <> e Then
                                'XX = StraiName(Y)
                                'XX = StraiName(X)
                                If FMat(Y, Y) < 3 Then
                                    If TreeDistance(D, Y) = TreeDistance(D, x) Then
                                        FMat(Y, Y) = 3
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                    'and remove sequences between the outlyer and the MRCA of the inlyer and outlyer
                    If TreeDistance(A, x) > MAxD And TreeDistance(D, x) = TreeDistance(A, D) Then
                        For Y = x + 1 To NextNo
                            If Y <> A And Y <> D And Y <> e Then
                                'XX = StraiName(Y)
                                'XX = StraiName(X)
                                If FMat(Y, Y) < 3 Then
                                    If TreeDistance(A, Y) = TreeDistance(A, x) Then
                                        FMat(Y, Y) = 3
                                    End If
                                End If
                            End If
                        Next Y
                    End If
                    
                    
                End If
            End If
        
        Next x
        
    
        NSeqs = -1
        For x = 0 To NextNo
            If FMat(x, x) <> 3 Then
                NSeqs = NSeqs + 1
                TraceSeqs(0, x) = NSeqs
                TraceSeqs(1, NSeqs) = x
            
            End If
        Next x
    
    
        'if there are still too many sequences then remove sequences at random untill only 100 remain
        If NSeqs > 100 Then
    
            CurTot = NSeqs
            Do
                MyValue = Int(onN * Rnd)
                If MyValue <> ISeqs(0) And MyValue <> ISeqs(1) And MyValue <> ISeqs(2) Then
                    'if treedistance(e,myvalue)
                    If FMat(MyValue, MyValue) <> 3 Then
                        FMat(MyValue, MyValue) = 3
                        CurTot = CurTot - 1
                        If CurTot = 100 Then Exit Do
                    End If
                End If
            Loop
        End If
    
    
    
    Else
        If NSeqs > 500 Then
            CurTot = NSeqs
            Do
                MyValue = Int(onN * Rnd)
                If MyValue <> ISeqs(0) And MyValue <> ISeqs(1) And MyValue <> ISeqs(2) Then
                    If FMat(MyValue, MyValue) <> 3 Then
                        FMat(MyValue, MyValue) = 3
                        CurTot = CurTot - 1
                        If CurTot = 500 Then Exit Do
                    End If
                End If
            Loop
        
        End If
    End If

    NSeqs = -1
    For x = 0 To NextNo
        If FMat(x, x) <> 3 Then
            NSeqs = NSeqs + 1
            TraceSeqs(0, x) = NSeqs
            TraceSeqs(1, NSeqs) = x
        
        End If
    Next x
End If

If NSeqs > 2 Then
    ReDim FAMat(0, 0)
    ReDim SAMat(0, 0)

    ReDim SHolder((NSeqs + 1) * 40 * 2), FHolder((NSeqs + 1) * 40 * 2)
Else
    MinPair(0) = MinPair(1)
    If DebuggingFlag < 2 Then On Error Resume Next
    ReDim FCMat(NextNo, NextNo), SCMat(NextNo, NextNo), FAMat(NextNo, NextNo), SAMat(NextNo, NextNo)
    On Error GoTo 0
    Exit Sub
End If

'0.260

ReDim tFMat(NSeqs, NSeqs)

If x = 12345 Then
    Dummy = MaketFSMat(NextNo, UBound(FMat, 1), UBound(tFMat, 1), FMat(0, 0), tFMat(0, 0))
Else
    A = 0
    b = 0
    For x = 0 To NextNo

        If FMat(x, x) <> 3 Then
            tFMat(A, A) = 0
            b = A + 1

            For Y = x + 1 To NextNo
                If FMat(Y, Y) <> 3 Then
                    tFMat(A, b) = FMat(x, Y)
                    tFMat(b, A) = FMat(x, Y)
                    b = b + 1
                End If

            Next Y
            A = A + 1

        End If
    Next x
End If



'0.4 for 3200
'0.270
'find outie in fmat
'SS = Abs(GetTickCount)
    Dim TotMat() As Single, MaxSc As Double
    ReDim TotMat(NSeqs)
    '@
    For x = 0 To NSeqs
        For Y = x + 1 To NSeqs
            If tFMat(x, x) < 3 Then
                If tFMat(Y, Y) < 3 Then
                    TotMat(x) = TotMat(x) + tFMat(x, Y)
                    TotMat(Y) = TotMat(Y) + tFMat(x, Y)
                End If
            End If
        Next Y
    Next x
    MaxSc = 0
    For x = 0 To NSeqs
        If TotMat(x) > MaxSc Then
            Outie = x
            MaxSc = TotMat(x)
        End If
    Next x
'0.260

'EE = Abs(GetTickCount)
'TT = EE - SS
'X = X




 'Do NJ trees
 '
'Form1.SSPanel1.Caption = "Making first NJ tree"
'Form1.SSPanel1.Refresh


TT = Abs(GetTickCount)
If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
    ETx = Abs(GetTickCount)
    ' '
    Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
    'Form1.Refresh
    If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
    'DoEvents
End If
If AbortFlag = 1 Then Exit Sub

ReDim tFAMat(0, 0)
ReDim ColTotals(NSeqs)

LTree(0) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tFMat(0, 0), FHolder(0), ColTotals(0), tFAMat(0, 0))

Erase tFMat

ReDim tFAMat(NSeqs, NSeqs)
NameLen = Len(Trim$(CStr(NSeqs)))
If NameLen < 2 Then NameLen = 2
'SS = Abs(GetTickCount)
Call Tree2Array(1, NameLen, NSeqs, LTree(0), FHolder(), tFAMat())
'EE = Abs(GetTickCount)
'TT = EE - SS '1.293 for 1410 seqs
'X = X
ReDim FAMat(NextNo, NextNo)
'@
For x = 0 To NSeqs
    For Y = x + 1 To NSeqs
        tFAMat(x, Y) = CLng(tFAMat(x, Y) * 10000) / 10000
        tFAMat(Y, x) = tFAMat(x, Y)
        FAMat(TraceSeqs(1, x), TraceSeqs(1, Y)) = tFAMat(x, Y)
        FAMat(TraceSeqs(1, Y), TraceSeqs(1, x)) = tFAMat(x, Y)
    Next Y
Next x
 
 
 
 If AbortFlag = 1 Then Exit Sub
 
 
 
 ReDim ColTotals(NSeqs)
 TT = Abs(GetTickCount)
If TT - GlobalTimer > 500 Then
  GlobalTimer = TT
    Form1.SSPanel1.Caption = "Making second NJ tree"
    ETx = Abs(GetTickCount)
    Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
  '
 'Form1.SSPanel1.Refresh
 ' ' '
 'Form1.Refresh
 If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
End If
 
 A = 0
b = 0
'0.260
'SS = Abs(GetTickCount)
ReDim tSMat(NSeqs, NSeqs)

If x = 12345 Then
    Dummy = MaketFSMat(NextNo, UBound(SMat, 1), UBound(tSMat, 1), SMat(0, 0), tSMat(0, 0))
Else
    For x = 0 To NextNo

        If FMat(x, x) <> 3 Then
            tSMat(A, A) = 0
            b = A + 1
            For Y = x + 1 To NextNo
                If FMat(Y, Y) <> 3 Then
                    tSMat(A, b) = SMat(x, Y)
                    tSMat(b, A) = SMat(x, Y)
                    b = b + 1
                End If

            Next Y
            A = A + 1

        End If
    Next x
End If
ReDim tSAMat(0, 0)
'If SEventNumber = 8 Then
'    X = X
'End If
' '
'If SEventNumber = 46 Then
'    X = X
'    Open "bus1n.csv" For Output As #20
'    For X = 0 To NSeqs
'        For Y = X + 1 To NSeqs
'            Print #20, Str(tSMat(0, 1))
'        Next Y
'    Next X
'    Close #20
'    X = X
'    X = X
'End If
'@
LTree(1) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tSMat(0, 0), SHolder(0), ColTotals(0), tSAMat(0, 0))
x = x
Erase tSMat
'DoEvents
'If SEventNumber = 8 Then
'    X = X
'End If
ReDim tSAMat(NSeqs, NSeqs)
'
If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
Call Tree2Array(1, NameLen, NSeqs, LTree(1), SHolder(), tSAMat())
ReDim SAMat(NextNo, NextNo)
For x = 0 To NSeqs
    For Y = x + 1 To NSeqs
        tSAMat(x, Y) = CLng(tSAMat(x, Y) * 10000) / 10000
        tSAMat(Y, x) = tSAMat(x, Y)
        SAMat(TraceSeqs(1, x), TraceSeqs(1, Y)) = tSAMat(x, Y)
        SAMat(TraceSeqs(1, Y), TraceSeqs(1, x)) = tSAMat(x, Y)
    Next Y
Next x

'XX = SAMat(ISeqs(0), ISeqs(1))
'X = X
'XX = SEventNumber
'XX = SAMat(ISeqs(2), 10)

 'Erase tSAMat
 'Outputs trees if you want these for debugging purposes
 
 'If X = 12345 Then
 '    xxx = CurDir
 '    ssy = ""
 '    XX = BPos3
 '    XX = EPos3
 '    SX = ""
 '
 '    For Z = 1 To LTree(1) '1264
 '        ssy = ssy + Chr(SHolder(Z))
 '    Next Z '
 '
 '    For Z = 1 To LTree(0) '1264
 '        SX = SX + Chr(FHolder(Z))
 '    Next Z '
 '
 '    Open "testfa" & Str(SEventNumber + 1) & ".tre" For Output As #1
 '    Print #1, SX
 '
 '    Close #1
 '     Open "testfb" & Str(SEventNumber + 1) & ".tre" For Output As #1
 '
 '    Print #1, ssy
 '    Close #1
 '    X = X
 '    XX = TraceSeqs(1, 60)
 'End If

' SS = Abs(GetTickCount)
 
 If x = x Then
    Dummy = CleanSCMat(NextNo, UBound(FMat, 1), UBound(FAMat, 1), FAMat(0, 0), SAMat(0, 0), FMat(0, 0))
 Else
    For x = 0 To NextNo
        If FMat(x, x) = 3 Then
            For Y = 0 To NextNo
                FAMat(x, Y) = ((NextNo * 3) - 1) / 1000
                FAMat(Y, x) = ((NextNo * 3) - 1) / 1000
                SAMat(x, Y) = ((NextNo * 3) - 1) / 1000
                SAMat(Y, x) = ((NextNo * 3) - 1) / 1000
            Next Y
        End If
    Next x
End If
 '0.330
 '1.045 for 1834 seqs
' EE = Abs(GetTickCount)
' TT = EE - SS
 '1.544 for 3200

MinDist(0) = 1000000
MinDist(1) = 1000000

Outlyer(0) = 2
Outlyer(1) = 1
Outlyer(2) = 0
Z = 0


'Eventnumber = Eventnumber
'Nextno = Nextno
For x = 0 To 1
    For Y = x + 1 To 2
        If FAMat(ISeqs(x), ISeqs(Y)) < MinDist(0) Then '15-4 = 0.045: 15-11 = 0.042, 4-11 = 0.045
            MinDist(0) = FAMat(ISeqs(x), ISeqs(Y))
            MinPair(0) = Z
            SeqPair(0) = x
            SeqPair(1) = Y
            SeqPair(2) = Outlyer(Z)
        End If
        If SAMat(ISeqs(x), ISeqs(Y)) < MinDist(1) Then '15-4 = 0.04, 15-11 = 0.014, 4-11=0.04
            MinDist(1) = SAMat(ISeqs(x), ISeqs(Y))
            MinPair(1) = Z
        End If
        Z = Z + 1
    Next Y
Next x

' EE = Abs(GetTickCount)
' TT = EE - SS
'
 '0.320
'  SS = Abs(GetTickCount)
 If Reps > 0 And BootFlag = 1 And (MinPair(1) <> MinPair(0) Or LongFlag = 1 Or ForcePhylE = 0) Then
     
     Dim tMatch() As Byte
     
     oDir = CurDir
     
     If DebuggingFlag < 2 Then On Error Resume Next
 
     ChDir App.Path
     ChDrive App.Path
     On Error GoTo 0
     'Perform bootstrap replicates
     Dim tSeqNum2() As Integer, tSeqnum() As Integer, WeightMod() As Long, Scratch() As Integer, Length As Long
     Dim Treestring As String, DstMat() As Single, Num1() As Long, Num2() As Long, num() As Double
     
     ReDim tSeqNum2(Len(StrainSeq(0)), NSeqs)
     Dummy = MaketSeqNum(Len(StrainSeq(0)), NextNo, tSeqNum2(0, 0), SeqNum(0, 0), FMat(0, 0))
     'Erase tSeqNum2
     Dim LoadSeqNumFromFile As Byte
     If NextNo * Len(StrainSeq(0)) > 30000000 Then
        Dim UBSN1 As Long, UBSN2 As Long
        LoadSeqNumFromFile = 1
        UBSN1 = UBound(SeqNum, 1)
        UBSN2 = UBound(SeqNum, 2)
        
        oDirX = CurDir
        ChDrive App.Path
        ChDir App.Path
        FF = FreeFile
        Open "RDP5SeqNumFile" + UFTag For Binary As #FF
        Put #FF, , SeqNum
        Close #FF
        
        ChDrive oDirX
        ChDir oDirX
        Erase SeqNum
    Else
        LoadSeqNumFromFile = 0
    End If
     'Call MakeConsenseFiles(NSeqs)
     '0.411
     Dim IdentiCalFX() As Long, IdenticalRX() As Long, BPos10 As Long, EPos10 As Long
'     XX = IdenticalF(Len(StrainSeq(0)))
     For x = 0 To 1
         FF = FreeFile
'         SS = Abs(GetTickCount)
         'Close #FF
         
         If x = 0 Then 'ie inner alignment
             Call MakeETSeqNum(NSeqs, Length, BPos3, EPos3, tSeqnum(), tSeqNum2())
             Call MakeNodeDepth(NSeqs, TraceBak(), tSAMat(), NodeDepth())
             
             BPos10 = BPos3
             EPos10 = EPos3
         Else
             Call MakeETSeqNum(NSeqs, Length, EPos3 + 1, BPos3 - 1, tSeqnum(), tSeqNum2())
             Erase tSeqNum2
             Call MakeNodeDepth(NSeqs, TraceBak(), tFAMat(), NodeDepth())
             BPos10 = EPos3 + 1
             If BPos10 > Len(StrainSeq(0)) Then BPos10 = 1
             EPos10 = BPos3 - 1
             If EPos10 < 1 Then EPos10 = Len(StrainSeq(0))
         End If
         
         ReDim IdentiCalFX(Len(StrainSeq(0))), IdenticalRX(Len(StrainSeq(0)))
         If BPos10 < EPos10 Then
            If BPos10 = 0 Then BPos10 = 1
            b = 1
            For A = BPos10 To EPos10
                IdentiCalFX(b) = IdenticalF(A) - IdenticalF(BPos10 - 1)
                b = b + 1
            Next A
            
            'find first non-identical site after bpos10
            For C = BPos10 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
            Next C
            b = 1
            For A = IdenticalF(C) To IdenticalF(EPos10)
                IdenticalRX(b) = IdenticalR(A) - (BPos10 - 1)
                b = b + 1
            Next A
        Else
            If BPos10 = 0 Then BPos10 = 1
            b = 1
            For A = BPos10 To Len(StrainSeq(0))
                IdentiCalFX(b) = IdenticalF(A) - IdenticalF(BPos10 - 1)
                b = b + 1
            Next A
            C = b - 1
            
            For A = 1 To EPos10
                If b <= UBound(IdentiCalFX, 1) Then
                    IdentiCalFX(b) = IdenticalF(A) + IdentiCalFX(C)
                Else
                    Exit For
                End If
                b = b + 1
            Next A
           
            'find first non-identical site after bpos10
            For C = BPos10 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
            Next C
            If C = Len(StrainSeq(0)) + 1 Then
                For C = 1 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
                Next C
                D = 0
            Else
                b = 1
                For A = IdenticalF(C) To IdenticalF(Len(StrainSeq(0)))
                    IdenticalRX(b) = IdenticalR(A) - (BPos10 - 1)
                    b = b + 1
                Next A
                D = b - 1
                For C = 1 To Len(StrainSeq(0))
                    If IdenticalF(C) <> IdenticalF(C - 1) Then Exit For
                Next C
            End If
            b = 1
            For A = IdenticalF(C) To IdenticalF(EPos10)
                IdenticalRX(b) = IdenticalR(A) + IdenticalRX(D)
                b = b + 1
            Next A
            
            
        End If
         
         
         Call MakeTMatch(NSeqs, tMatch(), NodeDepth())
         
         
         
         ReDim WeightMod(Reps, Length - 1), Scratch(Length)
         
         '0.461
         '0.441
         
         
         'Dummy = SEQBOOT(BSRndNumSeed, Reps, Length, Scratch(0), WeightMod(0, 0))
         '@
         Dummy = SEQBOOT2(BSRndNumSeed, Reps, Length, Scratch(0), WeightMod(0, 0))
         
         '0.671
         '0.641
         
         
         
         TT = Abs(GetTickCount)
         If TT - GlobalTimer > 500 Then
          GlobalTimer = TT
            If x = 0 Then
                Form1.SSPanel1.Caption = "Making first set of bootsrap distance matrices"
                ETx = Abs(GetTickCount)
               Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            Else
                Form1.SSPanel1.Caption = "Making second set of bootsrap distance matrices"
                ETx = Abs(GetTickCount)
               Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
            End If
         
         'Form1.SSPanel1.Refresh
         'Form1.Refresh
         
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
         End If
'         SS = Abs(GetTickCount)
'         For ZZ = 1 To 200
         ReDim ValidX(Reps), DiffsX(Reps), DstMat(Reps, NSeqs, NSeqs)
         
         'Dummy = FastBootDist(1, Reps, NSeqs, length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqNum(0, 0), DstMat(0, 0, 0))
          
         ''''''''''''''''''''''''''''''''
         
         'Dummy = FastBootDistIP(1, Reps, NSeqs, length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqNum(0, 0), DstMat(0, 0, 0))
         'Dummy = FastBootDistIP4(1, Reps, NSeqs, length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqNum(0, 0), DstMat(0, 0, 0), FlatDiff(0, 0), FlatValid(0, 0))
         
         
         Dummy = FastBootDistIP(1, Reps, NSeqs, Length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqnum(0, 0), DstMat(0, 0, 0))
          
          
          'Dummy = FastBootDistI(1, Reps, NSeqs, length, DiffsX(0), ValidX(0), WeightMod(0, 0), tSeqNum(0, 0), DstMat(0, 0, 0), IdentiCalFX(0), IdenticalRX(0))
'         Next ZZ
         ''19.83 fastbootdist
         '19.67 fastbootdistip
'         EE = Abs(GetTickCount)
'         TT = EE - SS '19.235/6.677; 19.11, 6.59 using all floats, 18.938/6.56 joining loops, 8.034/2.605 using indenticalR
         '5.766, 5.686 fastbootdisti
         '4.594, 4.563 fastbootdistip
         '2.891 fastbootdistip
         '0.641 fastbootdistp
         '0.797 fastbootdist
         '6.156 50 seqs fastbootdistip
         Erase tSeqnum
'           Call FastBootDistB(1, Reps, NSeqs, length, DiffsX(), ValidX(), WeightMod(), tSeqNum(), DstMat())
         'If DebuggingFlag < 2 Then On Error Resume Next
'            For D = 0 To Reps
'                For G = 0 To NSeqs
'                    For H = 0 To NSeqs
'                        xxx = -1
'                        xxx = DstMat(D, G, H)
'                        If xxx >= 0 Then
'                            X = X '0.58, 0.18, 0.62, 0.58,0.58, 0.56,0.64,0.25,0.20, 0.25
'                        Else
'                            X = X
'                        End If
'
'                    Next
'                Next
'
'            Next
'            xxx = DstMat(4, 1, 20)
         'On Error GoTo 0
         
         
         'DoEvents
         
         'Form1.SSPanel1.Refresh
         'Form1.Refresh
         If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
         
'         EE = Abs(GetTickCount)
'         TT = EE - SS
         '2.668 for 975 x 779 nt long seqs with 10 reps
         '86.175 for 975 X 11381 seqs with 10 reps
         x = x
         '0.873 for 3200
         '2.864
         '2.153 with fastbootdist
         '2.144,1.933, 1.913, 1.883, 1.882
         If AbortFlag = 1 Then Exit For
         
         Dim FT As Long
         ReDim tFMat(NSeqs, NSeqs), DLen(NSeqs)
         For Y = 1 To Reps
             
             FT = Abs(GetTickCount)
             If Abs(FT - GlobalTimer) > 500 Then
                 '
                 GlobalTimer = FT
                 '
                 Form1.SSPanel1.Caption = Trim(Str(Y + (x * 10))) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
                 Call UpdateF2Prog
                 'Form1.SSPanel1.Refresh
                 'Form1.Refresh
                 
                 '
                If DebuggingFlag < 1 Then Form1.WindowState = Form1.WindowState
            End If
             If AbortFlag = 1 Then
                 Close #FF
                 Exit For
             End If
             ReDim FHolder(NextNo * 40 * 2)
             Dummy = TransferDist(NSeqs, Y, Reps, tFMat(0, 0), DstMat(0, 0, 0))
             LTree(0) = NEIGHBOUR(1, 0, BSRndNumSeed, Outie + 1, NSeqs + 1, tFMat(0, 0), FHolder(0), ColTotals(0), tFAMat(0, 0))
            If AbortFlag = 1 Then
                 Close #FF
                 Exit For
             End If
             'Call TreeGroups(NSeqs, FHolder(), LTree(0), NameLen, tMatch(), DLen())
             Dummy = TreeGroupsXP(NSeqs, FHolder(0), LTree(0), NameLen, tMatch(0, 0), DLen(0))
             If AbortFlag = 1 Then
                 Close #FF
                 Exit For
             End If
         Next Y
         '
         TT = Abs(GetTickCount)
         If TT - GlobalTimer > 500 Then
            GlobalTimer = TT
            Form1.SSPanel1.Caption = Trim(Str(Reps + (x * 10))) + " of " + Trim(Str(Reps * 2)) + " NJ bootstrap replicates completed"
            If DebuggingFlag < 2 Then Form1.WindowState = Form1.WindowState
         End If
         If AbortFlag = 1 Then
            
            Exit For
         End If
         
         Erase DstMat
         
         '3.555
         '3.075
         
         For Z = 0 To NSeqs
              DLen(Z) = CLng((DLen(Z) + 1) / (Reps + 1) * 100)
              'X = X '100,100,100,100,82,82,100,100,64,100,100,100,55
         Next Z
         'Collapse nodes in FAMat/SAMat with no support - Put these in FCMat and SCMat
         'famat/samat = tree distance matrices - not path lengths but an encoding of
         'the rooted tree topology in a distance matrix
         'fcmat/scmat = tree distance matrices with nodes collapsed
         'Dlen = array containing bootstrap support for nodes
         'tracebak = contains an encoding of the tree topology - ie tells you which node corrsponds to which
         'distance in samat/famat
         ETx = Abs(GetTickCount)
        Form1.Label50(12).Caption = DoTimeII(Abs(ETx - ST))
         If x = 0 Then
             Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tSAMat(), tSCMat())
             Erase tSAMat
             ReDim SCMat(NextNo, NextNo)
             
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    SCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tSCMat(Z, Y)
                    SCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tSCMat(Z, Y)
                Next Y
            Next Z
            Erase tSCMat
         Else
             
             Call CollapseNodes(NSeqs, Cutoff, DLen(), TraceBak(), tFAMat(), tFCMat())
             Erase tFAMat
             ReDim FCMat(NextNo, NextNo)
             For Z = 0 To NSeqs
                For Y = x + 1 To NSeqs
                    '
                    FCMat(TraceSeqs(1, Z), TraceSeqs(1, Y)) = tFCMat(Z, Y)
                    FCMat(TraceSeqs(1, Y), TraceSeqs(1, Z)) = tFCMat(Z, Y)
                Next Y
            Next Z
            Erase tFCMat
         End If
         '3.075
         
     Next x
     'Exit Sub
     '9.794
     '8.813
      'Exit Sub
     
     'ReDim FCMat(Nextno, Nextno), SCMat(Nextno, Nextno)
     If AbortFlag = 1 Then
        
        
        If LoadSeqNumFromFile = 1 Then
            
            ReDim SeqNum(UBSN1, UBSN2)
            oDirX = CurDir
            ChDrive App.Path
            ChDir App.Path
            FF = FreeFile
            Open "RDP5SeqNumFile" + UFTag For Binary As #FF
            Get #FF, , SeqNum
            Close #FF
            
            ChDrive oDirX
            ChDir oDirX
            
        End If
        If DebuggingFlag < 2 Then On Error Resume Next
        If UBound(FCMat, 1) = 0 Then
            ReDim FCMat(NextNo, NextNo)
        End If
        If UBound(SCMat, 1) = 0 Then
            ReDim SCMat(NextNo, NextNo)
        End If
        On Error GoTo 0
        Exit Sub
     End If
     
     
     ' This is where guestimated values have to be readded to FAMat, FCmat, SAMat and SCMat
     
     
     If x = x Then
        Dummy = CleanSCMat(NextNo, UBound(FMat, 1), UBound(FCMat, 1), FCMat(0, 0), SCMat(0, 0), FMat(0, 0))
        
     Else
     
        For x = 0 To NextNo
            If FMat(x, x) = 3 Then
                For Y = 0 To NextNo
                    FCMat(x, Y) = ((NextNo * 3) - 1) / 1000
                    FCMat(Y, x) = FCMat(x, Y)
                    SCMat(x, Y) = ((NextNo * 3) - 1) / 1000
                    SCMat(Y, x) = SCMat(x, Y)
                Next Y
            End If
            
        Next x
        For x = 0 To NextNo
            For Y = x + 1 To NextNo
                FCMat(x, Y) = (CLng(FCMat(x, Y) * 10000000)) / 10000000
                FCMat(Y, x) = FCMat(x, Y)
                SCMat(x, Y) = (CLng(SCMat(x, Y) * 10000000)) / 10000000
                SCMat(Y, x) = SCMat(x, Y)
            Next Y
        Next x
    End If
     If DebuggingFlag < 2 Then On Error Resume Next
     ChDir oDir
     ChDrive oDir
     On Error GoTo 0
     
     'add inferred entires to samat, scmat etc

    Dim MDValS As Single, MDValF As Single, WinS As Long, WinF As Long, BestSeqS() As Long, BestSeqF() As Long
    ReDim BestSeqS(NextNo), BestSeqF(NextNo)
    
    For x = 0 To NextNo
        BestSeqS(x) = x
        BestSeqF(x) = x
    Next x
'
'    SS = Abs(GetTickCount)
'
    If x = x Then
        '
        Dummy = FindBesSeqSF(NextNo, ListToRedo(0), SMat(0, 0), FMat(0, 0), BestSeqS(0), BestSeqF(0))
    Else
    
        For x = 0 To NextNo
            If ListToRedo(x) = 1 Then
                MDValS = 10
                MDValF = 10
                WinF = -1
                WinS = -1
                For Y = 0 To NextNo
                
                    If Y <> x And ListToRedo(Y) = 0 Then
                        If SMat(x, Y) < MDValS Then
                            MDValS = SMat(x, Y)
                            BestSeqS(x) = Y
                        End If
                        If FMat(x, Y) < MDValF Then
                            MDValF = FMat(x, Y)
                            BestSeqF(x) = Y
                        End If
                    End If
                Next Y
                
                
                
            End If
        
        Next x
    End If
    
    
    
    
    If x = x Then
        Dummy = ReAddDists(NextNo, ListToRedo(0), SAMat(0, 0), FAMat(0, 0), SCMat(0, 0), FCMat(0, 0), BestSeqS(0), BestSeqF(0))
    Else
    
        For x = 0 To NextNo
            If ListToRedo(x) = 1 Then
                
                For Y = 0 To NextNo
                    
                    If Y <> x Then
                        If ListToRedo(Y) = 1 Then
                            If SAMat(x, Y) > SAMat(BestSeqS(x), BestSeqS(Y)) Then
                                SCMat(x, Y) = SCMat(BestSeqS(x), BestSeqS(Y))
                                SCMat(Y, x) = SCMat(x, Y)
                                SAMat(x, Y) = SAMat(BestSeqS(x), BestSeqS(Y))
                                SAMat(Y, x) = SAMat(x, Y)
                            End If
                            If FAMat(x, Y) > FAMat(BestSeqF(x), BestSeqF(Y)) Then
                                FCMat(x, Y) = FCMat(BestSeqF(x), BestSeqF(Y))
                                FAMat(x, Y) = FAMat(BestSeqF(x), BestSeqF(Y))
                                FCMat(Y, x) = FCMat(x, Y)
                                FAMat(Y, x) = FAMat(x, Y)
                            End If
                        Else
                            
                            
                            If SAMat(x, Y) > SAMat(BestSeqS(x), Y) Then
                                SCMat(x, Y) = SCMat(BestSeqS(x), Y)
                                SCMat(Y, x) = SCMat(x, Y)
                                SAMat(x, Y) = SAMat(BestSeqS(x), Y)
                                SAMat(Y, x) = SAMat(x, Y)
                            End If
                            If FAMat(x, Y) > FAMat(BestSeqF(x), Y) Then
                                FCMat(x, Y) = FCMat(BestSeqF(x), Y)
                                FAMat(x, Y) = FAMat(BestSeqF(x), Y)
                                FCMat(Y, x) = FCMat(x, Y)
                                FAMat(Y, x) = FAMat(x, Y)
                            End If
                        
                        
                        End If
                    Else
                        SCMat(Y, Y) = 0
                        SAMat(Y, Y) = 0
                        FCMat(Y, Y) = 0
                        FAMat(Y, Y) = 0
                    End If
                
                Next Y
                
            End If
        
        Next x
    End If
'    EE = Abs(GetTickCount)
'    TT = EE - SS '13.946
'    X = X
     
 Else
     
     'XX = UBound(Distance, 1)
     Erase tSeqNum2
     Erase tSeqnum
     
     'Erase MinP
     'XX = UBound(Daught, 2)
     ReDim FCMat(NextNo, NextNo)
     ReDim SCMat(NextNo, NextNo)
'     If X = X Then
        Dummy = CopyFloatArray(NextNo, UBound(FCMat, 1), UBound(FAMat, 1), FAMat(0, 0), FCMat(0, 0))
        Dummy = CopyFloatArray(NextNo, UBound(SCMat, 1), UBound(SAMat, 1), SAMat(0, 0), SCMat(0, 0))
'     Else
'
'        For X = 0 To Nextno
'            For Y = 0 To Nextno
'                FCMat(X, Y) = FAMat(X, Y)
'                SCMat(X, Y) = SAMat(X, Y)
'            Next Y
'        Next X
'
'     End If
 End If
'
'EE = Abs(GetTickCount)
'    TT = EE - SS


'For X = 0 To Nextno
'    For Y = 0 To Nextno
'        If SCMat(X, Y) > 1 Then
'            X = X
'        End If
'    Next Y
'Next X


'Make sure diagonals = 0
For x = 0 To NextNo
    
    FMat(x, x) = 0
    SMat(x, x) = 0
    FAMat(x, x) = 0
    SAMat(x, x) = 0
   
Next x

If LoadSeqNumFromFile = 1 Then
    If CompressSVSDFlag = 1 Then
        Erase TreeY
        Erase SeqText
    End If
    
    oDirX = CurDir
    ChDrive App.Path
    ChDir App.Path
    FF = FreeFile
    
    If TempTreeDistanceDumpFlag = 0 Or NextNo * NextNo > 5000000 Then
        UBTD1 = UBound(TreeDistance, 1)
        Open "RDP5TreeDistance" + UFTag For Binary As #FF
        Put #FF, , TreeDistance
        Close #FF
        ReDim TreeDistance(0, 0)
        TempTreeDistanceDumpFlag = 1
    End If
    If TreeXInFileFlag = 1 Then
        Erase TreeX
    End If
    If DebuggingFlag < 2 Then On Error Resume Next
    UB = -1
    ReDim SeqNum(UBSN1, UBSN2)
    UB = UBound(SeqNum, 1)
    On Error GoTo 0
    If UB = -1 Then
        Open "SCMat" + UFTag For Binary As #FF
        Put #FF, , SCMat
        Close #FF
        ReDim SCMat(0, 0)
        
        Open "FCMat" + UFTag For Binary As #FF
        Put #FF, , FCMat
        Close #FF
        ReDim FCMat(0, 0)
        ReDim SeqNum(UBSN1, UBSN2)
    End If
    Open "RDP5SeqNumFile" + UFTag For Binary As #FF
    Get #FF, , SeqNum
    Close #FF
    
    ChDrive oDirX
    ChDir oDirX
    
End If

'force minpair(0) to be different to minpair(1)
'If ReassortmentFlag = 1 Then
'    MinPair(0) = 0
'    MinPair(1) = 1
'End If

If (CLine <> "" And CLine <> " ") Then
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole vbClearLine
    hOutput = GetStdHandle(STD_OUTPUT_HANDLE)
    GetConsoleScreenBufferInfo hOutput, scrbuf
    WriteToConsole "Evidence of" & Str(SEventNumber) & " unique recombination events detected (" + Trim(Str(oRecombNo(100))) & " recombination signals remaining)       "
End If


End Sub
